(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["DrawTool"] = factory();
	else
		root["DrawTool"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _DrawTool = __webpack_require__(1);
	
	var _DrawTool2 = _interopRequireDefault(_DrawTool);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = _DrawTool2.default;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _fontLoader = __webpack_require__(2);
	
	var _fontLoader2 = _interopRequireDefault(_fontLoader);
	
	var _errors = __webpack_require__(3);
	
	var _errors2 = _interopRequireDefault(_errors);
	
	var _escapeJSON = __webpack_require__(4);
	
	var _escapeJSON2 = _interopRequireDefault(_escapeJSON);
	
	var _clip = __webpack_require__(5);
	
	var _clip2 = _interopRequireDefault(_clip);
	
	__webpack_require__(6);
	
	var _Sides = __webpack_require__(48);
	
	var _Sides2 = _interopRequireDefault(_Sides);
	
	var _DrawHistory = __webpack_require__(54);
	
	var _DrawHistory2 = _interopRequireDefault(_DrawHistory);
	
	__webpack_require__(55);
	
	__webpack_require__(56);
	
	__webpack_require__(57);
	
	__webpack_require__(58);
	
	__webpack_require__(59);
	
	__webpack_require__(60);
	
	__webpack_require__(61);
	
	__webpack_require__(62);
	
	__webpack_require__(63);
	
	__webpack_require__(64);
	
	__webpack_require__(65);
	
	__webpack_require__(66);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	if (!global._babelPolyfill) {
	  __webpack_require__(67);
	}
	
	/**
	 * @namespace DrawTool
	 */
	var DrawTool = {
	
	  /**
	   * @property editable
	   * @default false
	   * @memberOf DrawTool
	   * @type {boolean}
	   */
	  editable: false,
	
	  /**
	   * @property Container
	   * @default container: {target: document.body, size: {width: document.body.clientWidth, height: document.body.clientHeight}}
	   * @memberOf DrawTool
	   * @type {{target: HTMLElement, size: {width: Number, height: Number}}}
	   */
	  container: {
	    target: document.body,
	    size: {
	      width: 0,
	      height: 0
	    }
	  },
	
	  /**
	   * @property Grid Step
	   * @default 10
	   * @memberOf DrawTool
	   * @type {Number}
	   */
	  gridStep: 10,
	
	  /**
	   * @property Callbacks
	   * @default {}
	   * @memberOf DrawTool
	   * @type {Object}
	   * @private
	   */
	  _callbacks: {},
	
	  /**
	   * @property Sides
	   * @default null
	   * @memberOf DrawTool
	   * @type {Object}
	   */
	  sides: null,
	  /**
	   * @method
	   * @memberOf DrawTool
	   * @param target {HTMLElement} target container
	   * @param size {Object} Size of canvas
	   * @param size.width {Number} Width of canvas
	   * @param size.height {Number} height of canvas
	   */
	  initialize: function initialize(target, size) {
	
	    if (!(target instanceof HTMLElement)) {
	      throw new Error(JSON.stringify({ error: _errors2.default.HTMLElementUndefined }));
	      return false;
	    }
	
	    var _target = window.hasOwnProperty('jQuery') && target instanceof jQuery ? target[0] : target;
	
	    var _size = size || {};
	
	    this.container = {
	      target: _target,
	      size: _size
	    };
	
	    this.container.target.textContent = '';
	    this.container.target.style.position = 'relative';
	
	    this.sides = new _Sides2.default();
	
	    this.history = new _DrawHistory2.default();
	  },
	
	
	  /**
	   * Set sides editable
	   * @memberOf DrawTool
	   * @method
	   * @param val {Boolean} default: true
	   */
	  setEditable: function setEditable() {
	    var _this = this;
	
	    var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	
	    this.editable = val;
	
	    this.sides._collection.forEach(function (side) {
	      if (side.FabricBorder) {
	        side.FabricBorder.set('selectable', _this.editable);
	        side.FabricCanvas.deactivateAll().renderAll();
	      }
	    });
	  },
	
	
	  /**
	   * Add event handler
	   * @param {String} event event name
	   * @param {Function} handler Handler function
	   */
	  on: function on(event, handler) {
	    this._callbacks[event] = this._callbacks[event] || [];
	    this._callbacks[event].push(handler);
	  },
	
	
	  /**
	   * Remove event handler
	   * @param {String} event event name
	   * @param {Function} handler Handler function
	   */
	  off: function off(event, handler) {
	    this._callbacks[event].delete(handler);
	  },
	
	
	  /**
	   * Trigger event
	   * @param {String} event event name
	   * @param {Object} data
	   */
	  trigger: function trigger(event, data) {
	
	    if (event === 'history:update') {
	      this.history.pushState(data.side.id);
	      this.sides.getSide(data.side.id).layers.update();
	    }
	
	    if (typeof this._callbacks[event] !== 'undefined') {
	
	      this._callbacks[event].forEach(function (cb) {
	        return cb(JSON.stringify(data));
	      });
	    }
	  },
	
	
	  /**
	   * Export product data
	   * @return {String}
	   */
	  exportJSON: function exportJSON() {
	    var data = this.sides._collection.map(function (side) {
	      return side.toObject();
	    });
	    return JSON.stringify(data);
	  },
	
	
	  /**
	   * Import product data
	   * @param {String} json
	   * @param {Number} initialZoom
	   */
	  importJSON: function importJSON(json, initialZoom) {
	    var _this2 = this;
	
	    if (this.sides) {
	      this.sides.empty();
	    }
	
	    var data = JSON.parse((0, _escapeJSON2.default)(json));
	
	    data.forEach(function (side) {
	
	      var _side = _this2.sides.addSide(side.id);
	      _side.setImage(side.imageUrl, side.size).then(function (id) {
	
	        _side.setBorder(side.border);
	
	        if (initialZoom) {
	          _side.zoomToVal(initialZoom);
	        }
	
	        _side.FabricCanvas.renderAll.bind(_side.FabricCanvas);
	      });
	    });
	  },
	
	
	  fontLoader: _fontLoader2.default
	
	};
	
	exports.default = DrawTool;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 *
	 * @param title {String}
	 * @param urls {Object}
	 * @param urls.eot {String}
	 * @param urls.ttf {String}
	 * @param urls.woff {String}
	 * @param urls.woff2 {String}
	 * @param urls.svg {String}
	 */
	function fontLoader(title, urls) {
	
	  var fontFace = '@font-face {font-family: \'' + title + '\';\n    src: url(\'' + (urls.eot || '') + '\');\n    src: url(\'' + (urls.eot || '') + '?#iefix\') format(\'embedded-opentype\'),\n      url(\'' + (urls.woff2 || '') + '\') format(\'woff2\'),\n      url(\'' + (urls.woff || '') + '\') format(\'woff\'),\n      url(\'' + (urls.ttf || '') + '\') format(\'truetype\'),\n      url(\'' + (urls.svg || '') + '\') format(\'svg\');\n    font-weight: normal;\n    font-style: normal;\n  }';
	
	  var style = document.createElement('style');
	  style.innerText = fontFace;
	  document.head.appendChild(style);
	
	  var forceCall = document.createElement('span');
	  forceCall.innerText = '&nbsp;';
	  forceCall.style.fontFamily = title;
	  forceCall.style.textIndent = '-99999px';
	  forceCall.style.position = 'absolute';
	  forceCall.style.zIndex = '0';
	  forceCall.style.left = '-9999px';
	  forceCall.style.top = '-9999px';
	
	  document.body.appendChild(forceCall);
	}
	
	exports.default = fontLoader;

/***/ },
/* 3 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var errors = {
	  sideNoSize: {
	    code: 1,
	    message: 'Side has no size'
	  },
	  sideNoBorder: {
	    code: 2,
	    message: 'Side has no work area'
	  },
	  HTMLElementUndefined: {
	    code: 3,
	    message: 'DrawTool: Target should be a HTMLElement'
	  }
	};
	
	exports.default = errors;

/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	function escapeJSON(string) {
	
	  var str = string.replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
	
	  return str;
	}
	
	exports.default = escapeJSON;

/***/ },
/* 5 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function (border) {
	
	  var rect = Object.assign({}, _defineProperty({
	    left: border.left,
	    top: border.top,
	    width: border.width,
	    height: border.height,
	    strokeWidth: border.strokeWidth
	  }, 'strokeWidth', border.strokeWidth));
	
	  var generate = function generate() {
	    return 'this.setCoords();\n      let clipRect = ' + JSON.stringify(rect) + ';\n      ctx.save();\n      var m = this.calcTransformMatrix();\n      var iM = fabric.util.invertTransform(m);\n      ctx.transform.apply(ctx, iM);\n      ctx.beginPath();\n\n      ctx.rect(\n        clipRect.left,\n        clipRect.top,\n        clipRect.width - clipRect.strokeWidth,\n        clipRect.height - clipRect.strokeWidth\n      );\n      ctx.closePath();\n      ctx.restore();';
	  };
	
	  return new Function('ctx', generate());
	};
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _fabric = __webpack_require__(7);
	
	function uuid() {
	  return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	    var r = Math.random() * 16 | 0,
	        v = c == 'x' ? r : r & 0x3 | 0x8;
	    return v.toString(16);
	  });
	}
	
	_fabric.fabric.Object.prototype.setOptions = function (setOptions) {
	  return function (options) {
	    setOptions.apply(this, [options]);
	    this.uuid = this.uuid || uuid();
	  };
	}(_fabric.fabric.Object.prototype.setOptions);
	
	_fabric.fabric.Object.prototype.toObject = function (toObject) {
	  return function (propertiesToInclude) {
	    propertiesToInclude = (propertiesToInclude || []).concat(['uuid']);
	    return toObject.apply(this, [propertiesToInclude]);
	  };
	}(_fabric.fabric.Object.prototype.toObject);

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {/* build: `node build.js modules=ALL exclude=json,gestures minifier=uglifyjs` */
	/*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */
	
	var fabric = fabric || { version: "1.6.6" };
	if (true) {
	  exports.fabric = fabric;
	}
	
	if (typeof document !== 'undefined' && typeof window !== 'undefined') {
	  fabric.document = document;
	  fabric.window = window;
	  // ensure globality even if entire library were function wrapped (as in Meteor.js packaging system)
	  window.fabric = fabric;
	}
	else {
	  // assume we're running under node.js when document/window are not present
	  fabric.document = __webpack_require__(13)
	    .jsdom("<!DOCTYPE html><html><head></head><body></body></html>");
	
	  if (fabric.document.createWindow) {
	    fabric.window = fabric.document.createWindow();
	  } else {
	    fabric.window = fabric.document.parentWindow;
	  }
	}
	
	/**
	 * True when in environment that supports touch events
	 * @type boolean
	 */
	fabric.isTouchSupported = "ontouchstart" in fabric.document.documentElement;
	
	/**
	 * True when in environment that's probably Node.js
	 * @type boolean
	 */
	fabric.isLikelyNode = typeof Buffer !== 'undefined' &&
	                      typeof window === 'undefined';
	
	/* _FROM_SVG_START_ */
	/**
	 * Attributes parsed from all SVG elements
	 * @type array
	 */
	fabric.SHARED_ATTRIBUTES = [
	  "display",
	  "transform",
	  "fill", "fill-opacity", "fill-rule",
	  "opacity",
	  "stroke", "stroke-dasharray", "stroke-linecap",
	  "stroke-linejoin", "stroke-miterlimit",
	  "stroke-opacity", "stroke-width",
	  "id"
	];
	/* _FROM_SVG_END_ */
	
	/**
	 * Pixel per Inch as a default value set to 96. Can be changed for more realistic conversion.
	 */
	fabric.DPI = 96;
	fabric.reNum = '(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:e[-+]?\\d+)?)';
	fabric.fontPaths = { };
	
	/**
	 * Cache Object for widths of chars in text rendering.
	 */
	fabric.charWidthsCache = { };
	
	/**
	 * Device Pixel Ratio
	 * @see https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html
	 */
	fabric.devicePixelRatio = fabric.window.devicePixelRatio ||
	                          fabric.window.webkitDevicePixelRatio ||
	                          fabric.window.mozDevicePixelRatio ||
	                          1;
	
	
	(function() {
	
	  /**
	   * @private
	   * @param {String} eventName
	   * @param {Function} handler
	   */
	  function _removeEventListener(eventName, handler) {
	    if (!this.__eventListeners[eventName]) {
	      return;
	    }
	    var eventListener = this.__eventListeners[eventName];
	    if (handler) {
	      eventListener[eventListener.indexOf(handler)] = false;
	    }
	    else {
	      fabric.util.array.fill(eventListener, false);
	    }
	  }
	
	  /**
	   * Observes specified event
	   * @deprecated `observe` deprecated since 0.8.34 (use `on` instead)
	   * @memberOf fabric.Observable
	   * @alias on
	   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
	   * @param {Function} handler Function that receives a notification when an event of the specified type occurs
	   * @return {Self} thisArg
	   * @chainable
	   */
	  function observe(eventName, handler) {
	    if (!this.__eventListeners) {
	      this.__eventListeners = { };
	    }
	    // one object with key/value pairs was passed
	    if (arguments.length === 1) {
	      for (var prop in eventName) {
	        this.on(prop, eventName[prop]);
	      }
	    }
	    else {
	      if (!this.__eventListeners[eventName]) {
	        this.__eventListeners[eventName] = [];
	      }
	      this.__eventListeners[eventName].push(handler);
	    }
	    return this;
	  }
	
	  /**
	   * Stops event observing for a particular event handler. Calling this method
	   * without arguments removes all handlers for all events
	   * @deprecated `stopObserving` deprecated since 0.8.34 (use `off` instead)
	   * @memberOf fabric.Observable
	   * @alias off
	   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
	   * @param {Function} handler Function to be deleted from EventListeners
	   * @return {Self} thisArg
	   * @chainable
	   */
	  function stopObserving(eventName, handler) {
	    if (!this.__eventListeners) {
	      return;
	    }
	
	    // remove all key/value pairs (event name -> event handler)
	    if (arguments.length === 0) {
	      for (eventName in this.__eventListeners) {
	        _removeEventListener.call(this, eventName);
	      }
	    }
	    // one object with key/value pairs was passed
	    else if (arguments.length === 1 && typeof arguments[0] === 'object') {
	      for (var prop in eventName) {
	        _removeEventListener.call(this, prop, eventName[prop]);
	      }
	    }
	    else {
	      _removeEventListener.call(this, eventName, handler);
	    }
	    return this;
	  }
	
	  /**
	   * Fires event with an optional options object
	   * @deprecated `fire` deprecated since 1.0.7 (use `trigger` instead)
	   * @memberOf fabric.Observable
	   * @alias trigger
	   * @param {String} eventName Event name to fire
	   * @param {Object} [options] Options object
	   * @return {Self} thisArg
	   * @chainable
	   */
	  function fire(eventName, options) {
	    if (!this.__eventListeners) {
	      return;
	    }
	
	    var listenersForEvent = this.__eventListeners[eventName];
	    if (!listenersForEvent) {
	      return;
	    }
	
	    for (var i = 0, len = listenersForEvent.length; i < len; i++) {
	      listenersForEvent[i] && listenersForEvent[i].call(this, options || { });
	    }
	    this.__eventListeners[eventName] = listenersForEvent.filter(function(value) {
	      return value !== false;
	    });
	    return this;
	  }
	
	  /**
	   * @namespace fabric.Observable
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#events}
	   * @see {@link http://fabricjs.com/events|Events demo}
	   */
	  fabric.Observable = {
	    observe: observe,
	    stopObserving: stopObserving,
	    fire: fire,
	
	    on: observe,
	    off: stopObserving,
	    trigger: fire
	  };
	})();
	
	
	/**
	 * @namespace fabric.Collection
	 */
	fabric.Collection = {
	
	  _objects: [],
	
	  /**
	   * Adds objects to collection, Canvas or Group, then renders canvas
	   * (if `renderOnAddRemove` is not `false`).
	   * in case of Group no changes to bounding box are made.
	   * Objects should be instances of (or inherit from) fabric.Object
	   * @param {...fabric.Object} object Zero or more fabric instances
	   * @return {Self} thisArg
	   * @chainable
	   */
	  add: function () {
	    this._objects.push.apply(this._objects, arguments);
	    if (this._onObjectAdded) {
	      for (var i = 0, length = arguments.length; i < length; i++) {
	        this._onObjectAdded(arguments[i]);
	      }
	    }
	    this.renderOnAddRemove && this.renderAll();
	    return this;
	  },
	
	  /**
	   * Inserts an object into collection at specified index, then renders canvas (if `renderOnAddRemove` is not `false`)
	   * An object should be an instance of (or inherit from) fabric.Object
	   * @param {Object} object Object to insert
	   * @param {Number} index Index to insert object at
	   * @param {Boolean} nonSplicing When `true`, no splicing (shifting) of objects occurs
	   * @return {Self} thisArg
	   * @chainable
	   */
	  insertAt: function (object, index, nonSplicing) {
	    var objects = this.getObjects();
	    if (nonSplicing) {
	      objects[index] = object;
	    }
	    else {
	      objects.splice(index, 0, object);
	    }
	    this._onObjectAdded && this._onObjectAdded(object);
	    this.renderOnAddRemove && this.renderAll();
	    return this;
	  },
	
	  /**
	   * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)
	   * @param {...fabric.Object} object Zero or more fabric instances
	   * @return {Self} thisArg
	   * @chainable
	   */
	  remove: function() {
	    var objects = this.getObjects(),
	        index, somethingRemoved = false;
	
	    for (var i = 0, length = arguments.length; i < length; i++) {
	      index = objects.indexOf(arguments[i]);
	
	      // only call onObjectRemoved if an object was actually removed
	      if (index !== -1) {
	        somethingRemoved = true;
	        objects.splice(index, 1);
	        this._onObjectRemoved && this._onObjectRemoved(arguments[i]);
	      }
	    }
	
	    this.renderOnAddRemove && somethingRemoved && this.renderAll();
	    return this;
	  },
	
	  /**
	   * Executes given function for each object in this group
	   * @param {Function} callback
	   *                   Callback invoked with current object as first argument,
	   *                   index - as second and an array of all objects - as third.
	   *                   Callback is invoked in a context of Global Object (e.g. `window`)
	   *                   when no `context` argument is given
	   *
	   * @param {Object} context Context (aka thisObject)
	   * @return {Self} thisArg
	   * @chainable
	   */
	  forEachObject: function(callback, context) {
	    var objects = this.getObjects();
	    for (var i = 0, len = objects.length; i < len; i++) {
	      callback.call(context, objects[i], i, objects);
	    }
	    return this;
	  },
	
	  /**
	   * Returns an array of children objects of this instance
	   * Type parameter introduced in 1.3.10
	   * @param {String} [type] When specified, only objects of this type are returned
	   * @return {Array}
	   */
	  getObjects: function(type) {
	    if (typeof type === 'undefined') {
	      return this._objects;
	    }
	    return this._objects.filter(function(o) {
	      return o.type === type;
	    });
	  },
	
	  /**
	   * Returns object at specified index
	   * @param {Number} index
	   * @return {Self} thisArg
	   */
	  item: function (index) {
	    return this.getObjects()[index];
	  },
	
	  /**
	   * Returns true if collection contains no objects
	   * @return {Boolean} true if collection is empty
	   */
	  isEmpty: function () {
	    return this.getObjects().length === 0;
	  },
	
	  /**
	   * Returns a size of a collection (i.e: length of an array containing its objects)
	   * @return {Number} Collection size
	   */
	  size: function() {
	    return this.getObjects().length;
	  },
	
	  /**
	   * Returns true if collection contains an object
	   * @param {Object} object Object to check against
	   * @return {Boolean} `true` if collection contains an object
	   */
	  contains: function(object) {
	    return this.getObjects().indexOf(object) > -1;
	  },
	
	  /**
	   * Returns number representation of a collection complexity
	   * @return {Number} complexity
	   */
	  complexity: function () {
	    return this.getObjects().reduce(function (memo, current) {
	      memo += current.complexity ? current.complexity() : 0;
	      return memo;
	    }, 0);
	  }
	};
	
	
	(function(global) {
	
	  var sqrt = Math.sqrt,
	      atan2 = Math.atan2,
	      pow = Math.pow,
	      abs = Math.abs,
	      PiBy180 = Math.PI / 180;
	
	  /**
	   * @namespace fabric.util
	   */
	  fabric.util = {
	
	    /**
	     * Removes value from an array.
	     * Presence of value (and its position in an array) is determined via `Array.prototype.indexOf`
	     * @static
	     * @memberOf fabric.util
	     * @param {Array} array
	     * @param {*} value
	     * @return {Array} original array
	     */
	    removeFromArray: function(array, value) {
	      var idx = array.indexOf(value);
	      if (idx !== -1) {
	        array.splice(idx, 1);
	      }
	      return array;
	    },
	
	    /**
	     * Returns random number between 2 specified ones.
	     * @static
	     * @memberOf fabric.util
	     * @param {Number} min lower limit
	     * @param {Number} max upper limit
	     * @return {Number} random value (between min and max)
	     */
	    getRandomInt: function(min, max) {
	      return Math.floor(Math.random() * (max - min + 1)) + min;
	    },
	
	    /**
	     * Transforms degrees to radians.
	     * @static
	     * @memberOf fabric.util
	     * @param {Number} degrees value in degrees
	     * @return {Number} value in radians
	     */
	    degreesToRadians: function(degrees) {
	      return degrees * PiBy180;
	    },
	
	    /**
	     * Transforms radians to degrees.
	     * @static
	     * @memberOf fabric.util
	     * @param {Number} radians value in radians
	     * @return {Number} value in degrees
	     */
	    radiansToDegrees: function(radians) {
	      return radians / PiBy180;
	    },
	
	    /**
	     * Rotates `point` around `origin` with `radians`
	     * @static
	     * @memberOf fabric.util
	     * @param {fabric.Point} point The point to rotate
	     * @param {fabric.Point} origin The origin of the rotation
	     * @param {Number} radians The radians of the angle for the rotation
	     * @return {fabric.Point} The new rotated point
	     */
	    rotatePoint: function(point, origin, radians) {
	      point.subtractEquals(origin);
	      var v = fabric.util.rotateVector(point, radians);
	      return new fabric.Point(v.x, v.y).addEquals(origin);
	    },
	
	    /**
	     * Rotates `vector` with `radians`
	     * @static
	     * @memberOf fabric.util
	     * @param {Object} vector The vector to rotate (x and y)
	     * @param {Number} radians The radians of the angle for the rotation
	     * @return {Object} The new rotated point
	     */
	    rotateVector: function(vector, radians) {
	      var sin = Math.sin(radians),
	          cos = Math.cos(radians),
	          rx = vector.x * cos - vector.y * sin,
	          ry = vector.x * sin + vector.y * cos;
	      return {
	        x: rx,
	        y: ry
	      };
	    },
	
	    /**
	     * Apply transform t to point p
	     * @static
	     * @memberOf fabric.util
	     * @param  {fabric.Point} p The point to transform
	     * @param  {Array} t The transform
	     * @param  {Boolean} [ignoreOffset] Indicates that the offset should not be applied
	     * @return {fabric.Point} The transformed point
	     */
	    transformPoint: function(p, t, ignoreOffset) {
	      if (ignoreOffset) {
	        return new fabric.Point(
	          t[0] * p.x + t[2] * p.y,
	          t[1] * p.x + t[3] * p.y
	        );
	      }
	      return new fabric.Point(
	        t[0] * p.x + t[2] * p.y + t[4],
	        t[1] * p.x + t[3] * p.y + t[5]
	      );
	    },
	
	    /**
	     * Returns coordinates of points's bounding rectangle (left, top, width, height)
	     * @param {Array} points 4 points array
	     * @return {Object} Object with left, top, width, height properties
	     */
	    makeBoundingBoxFromPoints: function(points) {
	      var xPoints = [points[0].x, points[1].x, points[2].x, points[3].x],
	          minX = fabric.util.array.min(xPoints),
	          maxX = fabric.util.array.max(xPoints),
	          width = Math.abs(minX - maxX),
	          yPoints = [points[0].y, points[1].y, points[2].y, points[3].y],
	          minY = fabric.util.array.min(yPoints),
	          maxY = fabric.util.array.max(yPoints),
	          height = Math.abs(minY - maxY);
	
	      return {
	        left: minX,
	        top: minY,
	        width: width,
	        height: height
	      };
	    },
	
	    /**
	     * Invert transformation t
	     * @static
	     * @memberOf fabric.util
	     * @param {Array} t The transform
	     * @return {Array} The inverted transform
	     */
	    invertTransform: function(t) {
	      var a = 1 / (t[0] * t[3] - t[1] * t[2]),
	          r = [a * t[3], -a * t[1], -a * t[2], a * t[0]],
	          o = fabric.util.transformPoint({ x: t[4], y: t[5] }, r, true);
	      r[4] = -o.x;
	      r[5] = -o.y;
	      return r;
	    },
	
	    /**
	     * A wrapper around Number#toFixed, which contrary to native method returns number, not string.
	     * @static
	     * @memberOf fabric.util
	     * @param {Number|String} number number to operate on
	     * @param {Number} fractionDigits number of fraction digits to "leave"
	     * @return {Number}
	     */
	    toFixed: function(number, fractionDigits) {
	      return parseFloat(Number(number).toFixed(fractionDigits));
	    },
	
	    /**
	     * Converts from attribute value to pixel value if applicable.
	     * Returns converted pixels or original value not converted.
	     * @param {Number|String} value number to operate on
	     * @param {Number} fontSize
	     * @return {Number|String}
	     */
	    parseUnit: function(value, fontSize) {
	      var unit = /\D{0,2}$/.exec(value),
	          number = parseFloat(value);
	      if (!fontSize) {
	        fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;
	      }
	      switch (unit[0]) {
	        case 'mm':
	          return number * fabric.DPI / 25.4;
	
	        case 'cm':
	          return number * fabric.DPI / 2.54;
	
	        case 'in':
	          return number * fabric.DPI;
	
	        case 'pt':
	          return number * fabric.DPI / 72; // or * 4 / 3
	
	        case 'pc':
	          return number * fabric.DPI / 72 * 12; // or * 16
	
	        case 'em':
	          return number * fontSize;
	
	        default:
	          return number;
	      }
	    },
	
	    /**
	     * Function which always returns `false`.
	     * @static
	     * @memberOf fabric.util
	     * @return {Boolean}
	     */
	    falseFunction: function() {
	      return false;
	    },
	
	    /**
	     * Returns klass "Class" object of given namespace
	     * @memberOf fabric.util
	     * @param {String} type Type of object (eg. 'circle')
	     * @param {String} namespace Namespace to get klass "Class" object from
	     * @return {Object} klass "Class"
	     */
	    getKlass: function(type, namespace) {
	      // capitalize first letter only
	      type = fabric.util.string.camelize(type.charAt(0).toUpperCase() + type.slice(1));
	      return fabric.util.resolveNamespace(namespace)[type];
	    },
	
	    /**
	     * Returns object of given namespace
	     * @memberOf fabric.util
	     * @param {String} namespace Namespace string e.g. 'fabric.Image.filter' or 'fabric'
	     * @return {Object} Object for given namespace (default fabric)
	     */
	    resolveNamespace: function(namespace) {
	      if (!namespace) {
	        return fabric;
	      }
	
	      var parts = namespace.split('.'),
	          len = parts.length, i,
	          obj = global || fabric.window;
	
	      for (i = 0; i < len; ++i) {
	        obj = obj[parts[i]];
	      }
	
	      return obj;
	    },
	
	    /**
	     * Loads image element from given url and passes it to a callback
	     * @memberOf fabric.util
	     * @param {String} url URL representing an image
	     * @param {Function} callback Callback; invoked with loaded image
	     * @param {*} [context] Context to invoke callback in
	     * @param {Object} [crossOrigin] crossOrigin value to set image element to
	     */
	    loadImage: function(url, callback, context, crossOrigin) {
	      if (!url) {
	        callback && callback.call(context, url);
	        return;
	      }
	
	      var img = fabric.util.createImage();
	
	      /** @ignore */
	      img.onload = function () {
	        callback && callback.call(context, img);
	        img = img.onload = img.onerror = null;
	      };
	
	      /** @ignore */
	      img.onerror = function() {
	        fabric.log('Error loading ' + img.src);
	        callback && callback.call(context, null, true);
	        img = img.onload = img.onerror = null;
	      };
	
	      // data-urls appear to be buggy with crossOrigin
	      // https://github.com/kangax/fabric.js/commit/d0abb90f1cd5c5ef9d2a94d3fb21a22330da3e0a#commitcomment-4513767
	      // see https://code.google.com/p/chromium/issues/detail?id=315152
	      //     https://bugzilla.mozilla.org/show_bug.cgi?id=935069
	      if (url.indexOf('data') !== 0 && crossOrigin) {
	        img.crossOrigin = crossOrigin;
	      }
	
	      img.src = url;
	    },
	
	    /**
	     * Creates corresponding fabric instances from their object representations
	     * @static
	     * @memberOf fabric.util
	     * @param {Array} objects Objects to enliven
	     * @param {Function} callback Callback to invoke when all objects are created
	     * @param {String} namespace Namespace to get klass "Class" object from
	     * @param {Function} reviver Method for further parsing of object elements,
	     * called after each fabric object created.
	     */
	    enlivenObjects: function(objects, callback, namespace, reviver) {
	      objects = objects || [];
	
	      function onLoaded() {
	        if (++numLoadedObjects === numTotalObjects) {
	          callback && callback(enlivenedObjects);
	        }
	      }
	
	      var enlivenedObjects = [],
	          numLoadedObjects = 0,
	          numTotalObjects = objects.length;
	
	      if (!numTotalObjects) {
	        callback && callback(enlivenedObjects);
	        return;
	      }
	
	      objects.forEach(function (o, index) {
	        // if sparse array
	        if (!o || !o.type) {
	          onLoaded();
	          return;
	        }
	        var klass = fabric.util.getKlass(o.type, namespace);
	        if (klass.async) {
	          klass.fromObject(o, function (obj, error) {
	            if (!error) {
	              enlivenedObjects[index] = obj;
	              reviver && reviver(o, enlivenedObjects[index]);
	            }
	            onLoaded();
	          });
	        }
	        else {
	          enlivenedObjects[index] = klass.fromObject(o);
	          reviver && reviver(o, enlivenedObjects[index]);
	          onLoaded();
	        }
	      });
	    },
	
	    /**
	     * Groups SVG elements (usually those retrieved from SVG document)
	     * @static
	     * @memberOf fabric.util
	     * @param {Array} elements SVG elements to group
	     * @param {Object} [options] Options object
	     * @param {String} path Value to set sourcePath to
	     * @return {fabric.Object|fabric.PathGroup}
	     */
	    groupSVGElements: function(elements, options, path) {
	      var object;
	
	      object = new fabric.PathGroup(elements, options);
	
	      if (typeof path !== 'undefined') {
	        object.setSourcePath(path);
	      }
	      return object;
	    },
	
	    /**
	     * Populates an object with properties of another object
	     * @static
	     * @memberOf fabric.util
	     * @param {Object} source Source object
	     * @param {Object} destination Destination object
	     * @return {Array} properties Propertie names to include
	     */
	    populateWithProperties: function(source, destination, properties) {
	      if (properties && Object.prototype.toString.call(properties) === '[object Array]') {
	        for (var i = 0, len = properties.length; i < len; i++) {
	          if (properties[i] in source) {
	            destination[properties[i]] = source[properties[i]];
	          }
	        }
	      }
	    },
	
	    /**
	     * Draws a dashed line between two points
	     *
	     * This method is used to draw dashed line around selection area.
	     * See <a href="http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas">dotted stroke in canvas</a>
	     *
	     * @param {CanvasRenderingContext2D} ctx context
	     * @param {Number} x  start x coordinate
	     * @param {Number} y start y coordinate
	     * @param {Number} x2 end x coordinate
	     * @param {Number} y2 end y coordinate
	     * @param {Array} da dash array pattern
	     */
	    drawDashedLine: function(ctx, x, y, x2, y2, da) {
	      var dx = x2 - x,
	          dy = y2 - y,
	          len = sqrt(dx * dx + dy * dy),
	          rot = atan2(dy, dx),
	          dc = da.length,
	          di = 0,
	          draw = true;
	
	      ctx.save();
	      ctx.translate(x, y);
	      ctx.moveTo(0, 0);
	      ctx.rotate(rot);
	
	      x = 0;
	      while (len > x) {
	        x += da[di++ % dc];
	        if (x > len) {
	          x = len;
	        }
	        ctx[draw ? 'lineTo' : 'moveTo'](x, 0);
	        draw = !draw;
	      }
	
	      ctx.restore();
	    },
	
	    /**
	     * Creates canvas element and initializes it via excanvas if necessary
	     * @static
	     * @memberOf fabric.util
	     * @param {CanvasElement} [canvasEl] optional canvas element to initialize;
	     * when not given, element is created implicitly
	     * @return {CanvasElement} initialized canvas element
	     */
	    createCanvasElement: function(canvasEl) {
	      canvasEl || (canvasEl = fabric.document.createElement('canvas'));
	      /* eslint-disable camelcase */
	      if (!canvasEl.getContext && typeof G_vmlCanvasManager !== 'undefined') {
	        G_vmlCanvasManager.initElement(canvasEl);
	      }
	      /* eslint-enable camelcase */
	      return canvasEl;
	    },
	
	    /**
	     * Creates image element (works on client and node)
	     * @static
	     * @memberOf fabric.util
	     * @return {HTMLImageElement} HTML image element
	     */
	    createImage: function() {
	      return fabric.isLikelyNode
	        ? new (__webpack_require__(14).Image)()
	        : fabric.document.createElement('img');
	    },
	
	    /**
	     * Creates accessors (getXXX, setXXX) for a "class", based on "stateProperties" array
	     * @static
	     * @memberOf fabric.util
	     * @param {Object} klass "Class" to create accessors for
	     */
	    createAccessors: function(klass) {
	      var proto = klass.prototype, i, propName,
	          capitalizedPropName, setterName, getterName;
	
	      for (i = proto.stateProperties.length; i--; ) {
	
	        propName = proto.stateProperties[i];
	        capitalizedPropName = propName.charAt(0).toUpperCase() + propName.slice(1);
	        setterName = 'set' + capitalizedPropName;
	        getterName = 'get' + capitalizedPropName;
	
	        // using `new Function` for better introspection
	        if (!proto[getterName]) {
	          proto[getterName] = (function(property) {
	            return new Function('return this.get("' + property + '")');
	          })(propName);
	        }
	        if (!proto[setterName]) {
	          proto[setterName] = (function(property) {
	            return new Function('value', 'return this.set("' + property + '", value)');
	          })(propName);
	        }
	      }
	    },
	
	    /**
	     * @static
	     * @memberOf fabric.util
	     * @param {fabric.Object} receiver Object implementing `clipTo` method
	     * @param {CanvasRenderingContext2D} ctx Context to clip
	     */
	    clipContext: function(receiver, ctx) {
	      ctx.save();
	      ctx.beginPath();
	      receiver.clipTo(ctx);
	      ctx.clip();
	    },
	
	    /**
	     * Multiply matrix A by matrix B to nest transformations
	     * @static
	     * @memberOf fabric.util
	     * @param  {Array} a First transformMatrix
	     * @param  {Array} b Second transformMatrix
	     * @param  {Boolean} is2x2 flag to multiply matrices as 2x2 matrices
	     * @return {Array} The product of the two transform matrices
	     */
	    multiplyTransformMatrices: function(a, b, is2x2) {
	      // Matrix multiply a * b
	      return [
	        a[0] * b[0] + a[2] * b[1],
	        a[1] * b[0] + a[3] * b[1],
	        a[0] * b[2] + a[2] * b[3],
	        a[1] * b[2] + a[3] * b[3],
	        is2x2 ? 0 : a[0] * b[4] + a[2] * b[5] + a[4],
	        is2x2 ? 0 : a[1] * b[4] + a[3] * b[5] + a[5]
	      ];
	    },
	
	    /**
	     * Decomposes standard 2x2 matrix into transform componentes
	     * @static
	     * @memberOf fabric.util
	     * @param  {Array} a transformMatrix
	     * @return {Object} Components of transform
	     */
	    qrDecompose: function(a) {
	      var angle = atan2(a[1], a[0]),
	          denom = pow(a[0], 2) + pow(a[1], 2),
	          scaleX = sqrt(denom),
	          scaleY = (a[0] * a[3] - a[2] * a [1]) / scaleX,
	          skewX = atan2(a[0] * a[2] + a[1] * a [3], denom);
	      return {
	        angle: angle  / PiBy180,
	        scaleX: scaleX,
	        scaleY: scaleY,
	        skewX: skewX / PiBy180,
	        skewY: 0,
	        translateX: a[4],
	        translateY: a[5]
	      };
	    },
	
	    customTransformMatrix: function(scaleX, scaleY, skewX) {
	      var skewMatrixX = [1, 0, abs(Math.tan(skewX * PiBy180)), 1],
	          scaleMatrix = [abs(scaleX), 0, 0, abs(scaleY)];
	      return fabric.util.multiplyTransformMatrices(scaleMatrix, skewMatrixX, true);
	    },
	
	    resetObjectTransform: function (target) {
	      target.scaleX = 1;
	      target.scaleY = 1;
	      target.skewX = 0;
	      target.skewY = 0;
	      target.flipX = false;
	      target.flipY = false;
	      target.setAngle(0);
	    },
	
	    /**
	     * Returns string representation of function body
	     * @param {Function} fn Function to get body of
	     * @return {String} Function body
	     */
	    getFunctionBody: function(fn) {
	      return (String(fn).match(/function[^{]*\{([\s\S]*)\}/) || {})[1];
	    },
	
	    /**
	     * Returns true if context has transparent pixel
	     * at specified location (taking tolerance into account)
	     * @param {CanvasRenderingContext2D} ctx context
	     * @param {Number} x x coordinate
	     * @param {Number} y y coordinate
	     * @param {Number} tolerance Tolerance
	     */
	    isTransparent: function(ctx, x, y, tolerance) {
	
	      // If tolerance is > 0 adjust start coords to take into account.
	      // If moves off Canvas fix to 0
	      if (tolerance > 0) {
	        if (x > tolerance) {
	          x -= tolerance;
	        }
	        else {
	          x = 0;
	        }
	        if (y > tolerance) {
	          y -= tolerance;
	        }
	        else {
	          y = 0;
	        }
	      }
	
	      var _isTransparent = true, i, temp,
	          imageData = ctx.getImageData(x, y, (tolerance * 2) || 1, (tolerance * 2) || 1),
	          l = imageData.data.length;
	
	      // Split image data - for tolerance > 1, pixelDataSize = 4;
	      for (i = 3; i < l; i += 4) {
	        temp = imageData.data[i];
	        _isTransparent = temp <= 0;
	        if (_isTransparent === false) {
	          break; // Stop if colour found
	        }
	      }
	
	      imageData = null;
	
	      return _isTransparent;
	    },
	
	    /**
	     * Parse preserveAspectRatio attribute from element
	     * @param {string} attribute to be parsed
	     * @return {Object} an object containing align and meetOrSlice attribute
	     */
	    parsePreserveAspectRatioAttribute: function(attribute) {
	      var meetOrSlice = 'meet', alignX = 'Mid', alignY = 'Mid',
	          aspectRatioAttrs = attribute.split(' '), align;
	
	      if (aspectRatioAttrs && aspectRatioAttrs.length) {
	        meetOrSlice = aspectRatioAttrs.pop();
	        if (meetOrSlice !== 'meet' && meetOrSlice !== 'slice') {
	          align = meetOrSlice;
	          meetOrSlice = 'meet';
	        }
	        else if (aspectRatioAttrs.length) {
	          align = aspectRatioAttrs.pop();
	        }
	      }
	      //divide align in alignX and alignY
	      alignX = align !== 'none' ? align.slice(1, 4) : 'none';
	      alignY = align !== 'none' ? align.slice(5, 8) : 'none';
	      return {
	        meetOrSlice: meetOrSlice,
	        alignX: alignX,
	        alignY: alignY
	      };
	    },
	
	    /**
	     * Clear char widths cache for a font family.
	     * @memberOf fabric.util
	     * @param {String} [fontFamily] font family to clear
	     */
	    clearFabricFontCache: function(fontFamily) {
	      if (!fontFamily) {
	        fabric.charWidthsCache = { };
	      }
	      else if (fabric.charWidthsCache[fontFamily]) {
	        delete fabric.charWidthsCache[fontFamily];
	      }
	    }
	  };
	
	})( true ? exports : this);
	
	
	(function() {
	
	  var arcToSegmentsCache = { },
	      segmentToBezierCache = { },
	      boundsOfCurveCache = { },
	      _join = Array.prototype.join;
	
	  /* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp
	   * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here
	   * http://mozilla.org/MPL/2.0/
	   */
	  function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {
	    var argsString = _join.call(arguments);
	    if (arcToSegmentsCache[argsString]) {
	      return arcToSegmentsCache[argsString];
	    }
	
	    var PI = Math.PI, th = rotateX * PI / 180,
	        sinTh = Math.sin(th),
	        cosTh = Math.cos(th),
	        fromX = 0, fromY = 0;
	
	    rx = Math.abs(rx);
	    ry = Math.abs(ry);
	
	    var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5,
	        py = -cosTh * toY * 0.5 + sinTh * toX * 0.5,
	        rx2 = rx * rx, ry2 = ry * ry, py2 = py * py, px2 = px * px,
	        pl = rx2 * ry2 - rx2 * py2 - ry2 * px2,
	        root = 0;
	
	    if (pl < 0) {
	      var s = Math.sqrt(1 - pl / (rx2 * ry2));
	      rx *= s;
	      ry *= s;
	    }
	    else {
	      root = (large === sweep ? -1.0 : 1.0) *
	              Math.sqrt( pl / (rx2 * py2 + ry2 * px2));
	    }
	
	    var cx = root * rx * py / ry,
	        cy = -root * ry * px / rx,
	        cx1 = cosTh * cx - sinTh * cy + toX * 0.5,
	        cy1 = sinTh * cx + cosTh * cy + toY * 0.5,
	        mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry),
	        dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);
	
	    if (sweep === 0 && dtheta > 0) {
	      dtheta -= 2 * PI;
	    }
	    else if (sweep === 1 && dtheta < 0) {
	      dtheta += 2 * PI;
	    }
	
	    // Convert into cubic bezier segments <= 90deg
	    var segments = Math.ceil(Math.abs(dtheta / PI * 2)),
	        result = [], mDelta = dtheta / segments,
	        mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2),
	        th3 = mTheta + mDelta;
	
	    for (var i = 0; i < segments; i++) {
	      result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);
	      fromX = result[i][4];
	      fromY = result[i][5];
	      mTheta = th3;
	      th3 += mDelta;
	    }
	    arcToSegmentsCache[argsString] = result;
	    return result;
	  }
	
	  function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {
	    var argsString2 = _join.call(arguments);
	    if (segmentToBezierCache[argsString2]) {
	      return segmentToBezierCache[argsString2];
	    }
	
	    var costh2 = Math.cos(th2),
	        sinth2 = Math.sin(th2),
	        costh3 = Math.cos(th3),
	        sinth3 = Math.sin(th3),
	        toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1,
	        toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1,
	        cp1X = fromX + mT * ( -cosTh * rx * sinth2 - sinTh * ry * costh2),
	        cp1Y = fromY + mT * ( -sinTh * rx * sinth2 + cosTh * ry * costh2),
	        cp2X = toX + mT * ( cosTh * rx * sinth3 + sinTh * ry * costh3),
	        cp2Y = toY + mT * ( sinTh * rx * sinth3 - cosTh * ry * costh3);
	
	    segmentToBezierCache[argsString2] = [
	      cp1X, cp1Y,
	      cp2X, cp2Y,
	      toX, toY
	    ];
	    return segmentToBezierCache[argsString2];
	  }
	
	  /*
	   * Private
	   */
	  function calcVectorAngle(ux, uy, vx, vy) {
	    var ta = Math.atan2(uy, ux),
	        tb = Math.atan2(vy, vx);
	    if (tb >= ta) {
	      return tb - ta;
	    }
	    else {
	      return 2 * Math.PI - (ta - tb);
	    }
	  }
	
	  /**
	   * Draws arc
	   * @param {CanvasRenderingContext2D} ctx
	   * @param {Number} fx
	   * @param {Number} fy
	   * @param {Array} coords
	   */
	  fabric.util.drawArc = function(ctx, fx, fy, coords) {
	    var rx = coords[0],
	        ry = coords[1],
	        rot = coords[2],
	        large = coords[3],
	        sweep = coords[4],
	        tx = coords[5],
	        ty = coords[6],
	        segs = [[], [], [], []],
	        segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);
	
	    for (var i = 0, len = segsNorm.length; i < len; i++) {
	      segs[i][0] = segsNorm[i][0] + fx;
	      segs[i][1] = segsNorm[i][1] + fy;
	      segs[i][2] = segsNorm[i][2] + fx;
	      segs[i][3] = segsNorm[i][3] + fy;
	      segs[i][4] = segsNorm[i][4] + fx;
	      segs[i][5] = segsNorm[i][5] + fy;
	      ctx.bezierCurveTo.apply(ctx, segs[i]);
	    }
	  };
	
	  /**
	   * Calculate bounding box of a elliptic-arc
	   * @param {Number} fx start point of arc
	   * @param {Number} fy
	   * @param {Number} rx horizontal radius
	   * @param {Number} ry vertical radius
	   * @param {Number} rot angle of horizontal axe
	   * @param {Number} large 1 or 0, whatever the arc is the big or the small on the 2 points
	   * @param {Number} sweep 1 or 0, 1 clockwise or counterclockwise direction
	   * @param {Number} tx end point of arc
	   * @param {Number} ty
	   */
	  fabric.util.getBoundsOfArc = function(fx, fy, rx, ry, rot, large, sweep, tx, ty) {
	
	    var fromX = 0, fromY = 0, bound, bounds = [],
	        segs = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);
	
	    for (var i = 0, len = segs.length; i < len; i++) {
	      bound = getBoundsOfCurve(fromX, fromY, segs[i][0], segs[i][1], segs[i][2], segs[i][3], segs[i][4], segs[i][5]);
	      bounds.push({ x: bound[0].x + fx, y: bound[0].y + fy });
	      bounds.push({ x: bound[1].x + fx, y: bound[1].y + fy });
	      fromX = segs[i][4];
	      fromY = segs[i][5];
	    }
	    return bounds;
	  };
	
	  /**
	   * Calculate bounding box of a beziercurve
	   * @param {Number} x0 starting point
	   * @param {Number} y0
	   * @param {Number} x1 first control point
	   * @param {Number} y1
	   * @param {Number} x2 secondo control point
	   * @param {Number} y2
	   * @param {Number} x3 end of beizer
	   * @param {Number} y3
	   */
	  // taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.
	  function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {
	    var argsString = _join.call(arguments);
	    if (boundsOfCurveCache[argsString]) {
	      return boundsOfCurveCache[argsString];
	    }
	
	    var sqrt = Math.sqrt,
	        min = Math.min, max = Math.max,
	        abs = Math.abs, tvalues = [],
	        bounds = [[], []],
	        a, b, c, t, t1, t2, b2ac, sqrtb2ac;
	
	    b = 6 * x0 - 12 * x1 + 6 * x2;
	    a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
	    c = 3 * x1 - 3 * x0;
	
	    for (var i = 0; i < 2; ++i) {
	      if (i > 0) {
	        b = 6 * y0 - 12 * y1 + 6 * y2;
	        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
	        c = 3 * y1 - 3 * y0;
	      }
	
	      if (abs(a) < 1e-12) {
	        if (abs(b) < 1e-12) {
	          continue;
	        }
	        t = -c / b;
	        if (0 < t && t < 1) {
	          tvalues.push(t);
	        }
	        continue;
	      }
	      b2ac = b * b - 4 * c * a;
	      if (b2ac < 0) {
	        continue;
	      }
	      sqrtb2ac = sqrt(b2ac);
	      t1 = (-b + sqrtb2ac) / (2 * a);
	      if (0 < t1 && t1 < 1) {
	        tvalues.push(t1);
	      }
	      t2 = (-b - sqrtb2ac) / (2 * a);
	      if (0 < t2 && t2 < 1) {
	        tvalues.push(t2);
	      }
	    }
	
	    var x, y, j = tvalues.length, jlen = j, mt;
	    while (j--) {
	      t = tvalues[j];
	      mt = 1 - t;
	      x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);
	      bounds[0][j] = x;
	
	      y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);
	      bounds[1][j] = y;
	    }
	
	    bounds[0][jlen] = x0;
	    bounds[1][jlen] = y0;
	    bounds[0][jlen + 1] = x3;
	    bounds[1][jlen + 1] = y3;
	    var result = [
	      {
	        x: min.apply(null, bounds[0]),
	        y: min.apply(null, bounds[1])
	      },
	      {
	        x: max.apply(null, bounds[0]),
	        y: max.apply(null, bounds[1])
	      }
	    ];
	    boundsOfCurveCache[argsString] = result;
	    return result;
	  }
	
	  fabric.util.getBoundsOfCurve = getBoundsOfCurve;
	
	})();
	
	
	(function() {
	
	  var slice = Array.prototype.slice;
	
	  /* _ES5_COMPAT_START_ */
	
	  if (!Array.prototype.indexOf) {
	    /**
	     * Finds index of an element in an array
	     * @param {*} searchElement
	     * @return {Number}
	     */
	    Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
	      if (this === void 0 || this === null) {
	        throw new TypeError();
	      }
	      var t = Object(this), len = t.length >>> 0;
	      if (len === 0) {
	        return -1;
	      }
	      var n = 0;
	      if (arguments.length > 0) {
	        n = Number(arguments[1]);
	        if (n !== n) { // shortcut for verifying if it's NaN
	          n = 0;
	        }
	        else if (n !== 0 && n !== Number.POSITIVE_INFINITY && n !== Number.NEGATIVE_INFINITY) {
	          n = (n > 0 || -1) * Math.floor(Math.abs(n));
	        }
	      }
	      if (n >= len) {
	        return -1;
	      }
	      var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
	      for (; k < len; k++) {
	        if (k in t && t[k] === searchElement) {
	          return k;
	        }
	      }
	      return -1;
	    };
	  }
	
	  if (!Array.prototype.forEach) {
	    /**
	     * Iterates an array, invoking callback for each element
	     * @param {Function} fn Callback to invoke for each element
	     * @param {Object} [context] Context to invoke callback in
	     * @return {Array}
	     */
	    Array.prototype.forEach = function(fn, context) {
	      for (var i = 0, len = this.length >>> 0; i < len; i++) {
	        if (i in this) {
	          fn.call(context, this[i], i, this);
	        }
	      }
	    };
	  }
	
	  if (!Array.prototype.map) {
	    /**
	     * Returns a result of iterating over an array, invoking callback for each element
	     * @param {Function} fn Callback to invoke for each element
	     * @param {Object} [context] Context to invoke callback in
	     * @return {Array}
	     */
	    Array.prototype.map = function(fn, context) {
	      var result = [];
	      for (var i = 0, len = this.length >>> 0; i < len; i++) {
	        if (i in this) {
	          result[i] = fn.call(context, this[i], i, this);
	        }
	      }
	      return result;
	    };
	  }
	
	  if (!Array.prototype.every) {
	    /**
	     * Returns true if a callback returns truthy value for all elements in an array
	     * @param {Function} fn Callback to invoke for each element
	     * @param {Object} [context] Context to invoke callback in
	     * @return {Boolean}
	     */
	    Array.prototype.every = function(fn, context) {
	      for (var i = 0, len = this.length >>> 0; i < len; i++) {
	        if (i in this && !fn.call(context, this[i], i, this)) {
	          return false;
	        }
	      }
	      return true;
	    };
	  }
	
	  if (!Array.prototype.some) {
	    /**
	     * Returns true if a callback returns truthy value for at least one element in an array
	     * @param {Function} fn Callback to invoke for each element
	     * @param {Object} [context] Context to invoke callback in
	     * @return {Boolean}
	     */
	    Array.prototype.some = function(fn, context) {
	      for (var i = 0, len = this.length >>> 0; i < len; i++) {
	        if (i in this && fn.call(context, this[i], i, this)) {
	          return true;
	        }
	      }
	      return false;
	    };
	  }
	
	  if (!Array.prototype.filter) {
	    /**
	     * Returns the result of iterating over elements in an array
	     * @param {Function} fn Callback to invoke for each element
	     * @param {Object} [context] Context to invoke callback in
	     * @return {Array}
	     */
	    Array.prototype.filter = function(fn, context) {
	      var result = [], val;
	      for (var i = 0, len = this.length >>> 0; i < len; i++) {
	        if (i in this) {
	          val = this[i]; // in case fn mutates this
	          if (fn.call(context, val, i, this)) {
	            result.push(val);
	          }
	        }
	      }
	      return result;
	    };
	  }
	
	  if (!Array.prototype.reduce) {
	    /**
	     * Returns "folded" (reduced) result of iterating over elements in an array
	     * @param {Function} fn Callback to invoke for each element
	     * @return {*}
	     */
	    Array.prototype.reduce = function(fn /*, initial*/) {
	      var len = this.length >>> 0,
	          i = 0,
	          rv;
	
	      if (arguments.length > 1) {
	        rv = arguments[1];
	      }
	      else {
	        do {
	          if (i in this) {
	            rv = this[i++];
	            break;
	          }
	          // if array contains no values, no initial value to return
	          if (++i >= len) {
	            throw new TypeError();
	          }
	        }
	        while (true);
	      }
	      for (; i < len; i++) {
	        if (i in this) {
	          rv = fn.call(null, rv, this[i], i, this);
	        }
	      }
	      return rv;
	    };
	  }
	
	  /* _ES5_COMPAT_END_ */
	
	  /**
	   * Invokes method on all items in a given array
	   * @memberOf fabric.util.array
	   * @param {Array} array Array to iterate over
	   * @param {String} method Name of a method to invoke
	   * @return {Array}
	   */
	  function invoke(array, method) {
	    var args = slice.call(arguments, 2), result = [];
	    for (var i = 0, len = array.length; i < len; i++) {
	      result[i] = args.length ? array[i][method].apply(array[i], args) : array[i][method].call(array[i]);
	    }
	    return result;
	  }
	
	  /**
	   * Finds maximum value in array (not necessarily "first" one)
	   * @memberOf fabric.util.array
	   * @param {Array} array Array to iterate over
	   * @param {String} byProperty
	   * @return {*}
	   */
	  function max(array, byProperty) {
	    return find(array, byProperty, function(value1, value2) {
	      return value1 >= value2;
	    });
	  }
	
	  /**
	   * Finds minimum value in array (not necessarily "first" one)
	   * @memberOf fabric.util.array
	   * @param {Array} array Array to iterate over
	   * @param {String} byProperty
	   * @return {*}
	   */
	  function min(array, byProperty) {
	    return find(array, byProperty, function(value1, value2) {
	      return value1 < value2;
	    });
	  }
	
	  /**
	   * @private
	   */
	  function fill(array, value) {
	    var k = array.length;
	    while (k--) {
	      array[k] = value;
	    }
	    return array;
	  }
	
	  /**
	   * @private
	   */
	  function find(array, byProperty, condition) {
	    if (!array || array.length === 0) {
	      return;
	    }
	
	    var i = array.length - 1,
	        result = byProperty ? array[i][byProperty] : array[i];
	    if (byProperty) {
	      while (i--) {
	        if (condition(array[i][byProperty], result)) {
	          result = array[i][byProperty];
	        }
	      }
	    }
	    else {
	      while (i--) {
	        if (condition(array[i], result)) {
	          result = array[i];
	        }
	      }
	    }
	    return result;
	  }
	
	  /**
	   * @namespace fabric.util.array
	   */
	  fabric.util.array = {
	    fill: fill,
	    invoke: invoke,
	    min: min,
	    max: max
	  };
	
	})();
	
	
	(function() {
	  /**
	   * Copies all enumerable properties of one object to another
	   * @memberOf fabric.util.object
	   * @param {Object} destination Where to copy to
	   * @param {Object} source Where to copy from
	   * @return {Object}
	   */
	
	  function extend(destination, source, deep) {
	    // JScript DontEnum bug is not taken care of
	    // the deep clone is for internal use, is not meant to avoid
	    // javascript traps or cloning html element or self referenced objects.
	    if (deep) {
	      if (!fabric.isLikelyNode && source instanceof Element) {
	        // avoid cloning deep images, canvases,
	        destination = source;
	      }
	      else if (source instanceof Array) {
	        destination = source.map(function(v) {
	          return clone(v, deep)
	        })
	      }
	      else if (source instanceof Object) {
	        for (var property in source) {
	          destination[property] = clone(source[property], deep)
	        }
	      }
	      else {
	        // this sounds odd for an extend but is ok for recursive use
	        destination = source;
	      }
	    }
	    else {
	      for (var property in source) {
	        destination[property] = source[property];
	      }
	    }
	    return destination;
	  }
	
	  /**
	   * Creates an empty object and copies all enumerable properties of another object to it
	   * @memberOf fabric.util.object
	   * @param {Object} object Object to clone
	   * @return {Object}
	   */
	  function clone(object, deep) {
	    return extend({ }, object, deep);
	  }
	
	  /** @namespace fabric.util.object */
	  fabric.util.object = {
	    extend: extend,
	    clone: clone
	  };
	
	})();
	
	
	(function() {
	
	  /* _ES5_COMPAT_START_ */
	  if (!String.prototype.trim) {
	    /**
	     * Trims a string (removing whitespace from the beginning and the end)
	     * @function external:String#trim
	     * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String/Trim">String#trim on MDN</a>
	     */
	    String.prototype.trim = function () {
	      // this trim is not fully ES3 or ES5 compliant, but it should cover most cases for now
	      return this.replace(/^[\s\xA0]+/, '').replace(/[\s\xA0]+$/, '');
	    };
	  }
	  /* _ES5_COMPAT_END_ */
	
	  /**
	   * Camelizes a string
	   * @memberOf fabric.util.string
	   * @param {String} string String to camelize
	   * @return {String} Camelized version of a string
	   */
	  function camelize(string) {
	    return string.replace(/-+(.)?/g, function(match, character) {
	      return character ? character.toUpperCase() : '';
	    });
	  }
	
	  /**
	   * Capitalizes a string
	   * @memberOf fabric.util.string
	   * @param {String} string String to capitalize
	   * @param {Boolean} [firstLetterOnly] If true only first letter is capitalized
	   * and other letters stay untouched, if false first letter is capitalized
	   * and other letters are converted to lowercase.
	   * @return {String} Capitalized version of a string
	   */
	  function capitalize(string, firstLetterOnly) {
	    return string.charAt(0).toUpperCase() +
	      (firstLetterOnly ? string.slice(1) : string.slice(1).toLowerCase());
	  }
	
	  /**
	   * Escapes XML in a string
	   * @memberOf fabric.util.string
	   * @param {String} string String to escape
	   * @return {String} Escaped version of a string
	   */
	  function escapeXml(string) {
	    return string.replace(/&/g, '&amp;')
	       .replace(/"/g, '&quot;')
	       .replace(/'/g, '&apos;')
	       .replace(/</g, '&lt;')
	       .replace(/>/g, '&gt;');
	  }
	
	  /**
	   * String utilities
	   * @namespace fabric.util.string
	   */
	  fabric.util.string = {
	    camelize: camelize,
	    capitalize: capitalize,
	    escapeXml: escapeXml
	  };
	})();
	
	
	/* _ES5_COMPAT_START_ */
	(function() {
	
	  var slice = Array.prototype.slice,
	      apply = Function.prototype.apply,
	      Dummy = function() { };
	
	  if (!Function.prototype.bind) {
	    /**
	     * Cross-browser approximation of ES5 Function.prototype.bind (not fully spec conforming)
	     * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind">Function#bind on MDN</a>
	     * @param {Object} thisArg Object to bind function to
	     * @param {Any[]} Values to pass to a bound function
	     * @return {Function}
	     */
	    Function.prototype.bind = function(thisArg) {
	      var _this = this, args = slice.call(arguments, 1), bound;
	      if (args.length) {
	        bound = function() {
	          return apply.call(_this, this instanceof Dummy ? this : thisArg, args.concat(slice.call(arguments)));
	        };
	      }
	      else {
	        /** @ignore */
	        bound = function() {
	          return apply.call(_this, this instanceof Dummy ? this : thisArg, arguments);
	        };
	      }
	      Dummy.prototype = this.prototype;
	      bound.prototype = new Dummy();
	
	      return bound;
	    };
	  }
	
	})();
	/* _ES5_COMPAT_END_ */
	
	
	(function() {
	
	  var slice = Array.prototype.slice, emptyFunction = function() { },
	
	      IS_DONTENUM_BUGGY = (function() {
	        for (var p in { toString: 1 }) {
	          if (p === 'toString') {
	            return false;
	          }
	        }
	        return true;
	      })(),
	
	      /** @ignore */
	      addMethods = function(klass, source, parent) {
	        for (var property in source) {
	
	          if (property in klass.prototype &&
	              typeof klass.prototype[property] === 'function' &&
	              (source[property] + '').indexOf('callSuper') > -1) {
	
	            klass.prototype[property] = (function(property) {
	              return function() {
	
	                var superclass = this.constructor.superclass;
	                this.constructor.superclass = parent;
	                var returnValue = source[property].apply(this, arguments);
	                this.constructor.superclass = superclass;
	
	                if (property !== 'initialize') {
	                  return returnValue;
	                }
	              };
	            })(property);
	          }
	          else {
	            klass.prototype[property] = source[property];
	          }
	
	          if (IS_DONTENUM_BUGGY) {
	            if (source.toString !== Object.prototype.toString) {
	              klass.prototype.toString = source.toString;
	            }
	            if (source.valueOf !== Object.prototype.valueOf) {
	              klass.prototype.valueOf = source.valueOf;
	            }
	          }
	        }
	      };
	
	  function Subclass() { }
	
	  function callSuper(methodName) {
	    var fn = this.constructor.superclass.prototype[methodName];
	    return (arguments.length > 1)
	      ? fn.apply(this, slice.call(arguments, 1))
	      : fn.call(this);
	  }
	
	  /**
	   * Helper for creation of "classes".
	   * @memberOf fabric.util
	   * @param {Function} [parent] optional "Class" to inherit from
	   * @param {Object} [properties] Properties shared by all instances of this class
	   *                  (be careful modifying objects defined here as this would affect all instances)
	   */
	  function createClass() {
	    var parent = null,
	        properties = slice.call(arguments, 0);
	
	    if (typeof properties[0] === 'function') {
	      parent = properties.shift();
	    }
	    function klass() {
	      this.initialize.apply(this, arguments);
	    }
	
	    klass.superclass = parent;
	    klass.subclasses = [];
	
	    if (parent) {
	      Subclass.prototype = parent.prototype;
	      klass.prototype = new Subclass();
	      parent.subclasses.push(klass);
	    }
	    for (var i = 0, length = properties.length; i < length; i++) {
	      addMethods(klass, properties[i], parent);
	    }
	    if (!klass.prototype.initialize) {
	      klass.prototype.initialize = emptyFunction;
	    }
	    klass.prototype.constructor = klass;
	    klass.prototype.callSuper = callSuper;
	    return klass;
	  }
	
	  fabric.util.createClass = createClass;
	})();
	
	
	(function () {
	
	  var unknown = 'unknown';
	
	  /* EVENT HANDLING */
	
	  function areHostMethods(object) {
	    var methodNames = Array.prototype.slice.call(arguments, 1),
	        t, i, len = methodNames.length;
	    for (i = 0; i < len; i++) {
	      t = typeof object[methodNames[i]];
	      if (!(/^(?:function|object|unknown)$/).test(t)) {
	        return false;
	      }
	    }
	    return true;
	  }
	
	  /** @ignore */
	  var getElement,
	      setElement,
	      getUniqueId = (function () {
	        var uid = 0;
	        return function (element) {
	          return element.__uniqueID || (element.__uniqueID = 'uniqueID__' + uid++);
	        };
	      })();
	
	  (function () {
	    var elements = { };
	    /** @ignore */
	    getElement = function (uid) {
	      return elements[uid];
	    };
	    /** @ignore */
	    setElement = function (uid, element) {
	      elements[uid] = element;
	    };
	  })();
	
	  function createListener(uid, handler) {
	    return {
	      handler: handler,
	      wrappedHandler: createWrappedHandler(uid, handler)
	    };
	  }
	
	  function createWrappedHandler(uid, handler) {
	    return function (e) {
	      handler.call(getElement(uid), e || fabric.window.event);
	    };
	  }
	
	  function createDispatcher(uid, eventName) {
	    return function (e) {
	      if (handlers[uid] && handlers[uid][eventName]) {
	        var handlersForEvent = handlers[uid][eventName];
	        for (var i = 0, len = handlersForEvent.length; i < len; i++) {
	          handlersForEvent[i].call(this, e || fabric.window.event);
	        }
	      }
	    };
	  }
	
	  var shouldUseAddListenerRemoveListener = (
	        areHostMethods(fabric.document.documentElement, 'addEventListener', 'removeEventListener') &&
	        areHostMethods(fabric.window, 'addEventListener', 'removeEventListener')),
	
	      shouldUseAttachEventDetachEvent = (
	        areHostMethods(fabric.document.documentElement, 'attachEvent', 'detachEvent') &&
	        areHostMethods(fabric.window, 'attachEvent', 'detachEvent')),
	
	      // IE branch
	      listeners = { },
	
	      // DOM L0 branch
	      handlers = { },
	
	      addListener, removeListener;
	
	  if (shouldUseAddListenerRemoveListener) {
	    /** @ignore */
	    addListener = function (element, eventName, handler) {
	      element.addEventListener(eventName, handler, false);
	    };
	    /** @ignore */
	    removeListener = function (element, eventName, handler) {
	      element.removeEventListener(eventName, handler, false);
	    };
	  }
	
	  else if (shouldUseAttachEventDetachEvent) {
	    /** @ignore */
	    addListener = function (element, eventName, handler) {
	      var uid = getUniqueId(element);
	      setElement(uid, element);
	      if (!listeners[uid]) {
	        listeners[uid] = { };
	      }
	      if (!listeners[uid][eventName]) {
	        listeners[uid][eventName] = [];
	
	      }
	      var listener = createListener(uid, handler);
	      listeners[uid][eventName].push(listener);
	      element.attachEvent('on' + eventName, listener.wrappedHandler);
	    };
	    /** @ignore */
	    removeListener = function (element, eventName, handler) {
	      var uid = getUniqueId(element), listener;
	      if (listeners[uid] && listeners[uid][eventName]) {
	        for (var i = 0, len = listeners[uid][eventName].length; i < len; i++) {
	          listener = listeners[uid][eventName][i];
	          if (listener && listener.handler === handler) {
	            element.detachEvent('on' + eventName, listener.wrappedHandler);
	            listeners[uid][eventName][i] = null;
	          }
	        }
	      }
	    };
	  }
	  else {
	    /** @ignore */
	    addListener = function (element, eventName, handler) {
	      var uid = getUniqueId(element);
	      if (!handlers[uid]) {
	        handlers[uid] = { };
	      }
	      if (!handlers[uid][eventName]) {
	        handlers[uid][eventName] = [];
	        var existingHandler = element['on' + eventName];
	        if (existingHandler) {
	          handlers[uid][eventName].push(existingHandler);
	        }
	        element['on' + eventName] = createDispatcher(uid, eventName);
	      }
	      handlers[uid][eventName].push(handler);
	    };
	    /** @ignore */
	    removeListener = function (element, eventName, handler) {
	      var uid = getUniqueId(element);
	      if (handlers[uid] && handlers[uid][eventName]) {
	        var handlersForEvent = handlers[uid][eventName];
	        for (var i = 0, len = handlersForEvent.length; i < len; i++) {
	          if (handlersForEvent[i] === handler) {
	            handlersForEvent.splice(i, 1);
	          }
	        }
	      }
	    };
	  }
	
	  /**
	   * Adds an event listener to an element
	   * @function
	   * @memberOf fabric.util
	   * @param {HTMLElement} element
	   * @param {String} eventName
	   * @param {Function} handler
	   */
	  fabric.util.addListener = addListener;
	
	  /**
	   * Removes an event listener from an element
	   * @function
	   * @memberOf fabric.util
	   * @param {HTMLElement} element
	   * @param {String} eventName
	   * @param {Function} handler
	   */
	  fabric.util.removeListener = removeListener;
	
	  /**
	   * Cross-browser wrapper for getting event's coordinates
	   * @memberOf fabric.util
	   * @param {Event} event Event object
	   */
	  function getPointer(event) {
	    event || (event = fabric.window.event);
	
	    var element = event.target ||
	                  (typeof event.srcElement !== unknown ? event.srcElement : null),
	
	        scroll = fabric.util.getScrollLeftTop(element);
	
	    return {
	      x: pointerX(event) + scroll.left,
	      y: pointerY(event) + scroll.top
	    };
	  }
	
	  var pointerX = function(event) {
	    // looks like in IE (<9) clientX at certain point (apparently when mouseup fires on VML element)
	    // is represented as COM object, with all the consequences, like "unknown" type and error on [[Get]]
	    // need to investigate later
	        return (typeof event.clientX !== unknown ? event.clientX : 0);
	      },
	
	      pointerY = function(event) {
	        return (typeof event.clientY !== unknown ? event.clientY : 0);
	      };
	
	  function _getPointer(event, pageProp, clientProp) {
	    var touchProp = event.type === 'touchend' ? 'changedTouches' : 'touches';
	
	    return (event[touchProp] && event[touchProp][0]
	      ? (event[touchProp][0][pageProp] - (event[touchProp][0][pageProp] - event[touchProp][0][clientProp]))
	        || event[clientProp]
	      : event[clientProp]);
	  }
	
	  if (fabric.isTouchSupported) {
	    pointerX = function(event) {
	      return _getPointer(event, 'pageX', 'clientX');
	    };
	    pointerY = function(event) {
	      return _getPointer(event, 'pageY', 'clientY');
	    };
	  }
	
	  fabric.util.getPointer = getPointer;
	
	  fabric.util.object.extend(fabric.util, fabric.Observable);
	
	})();
	
	
	(function () {
	
	  /**
	   * Cross-browser wrapper for setting element's style
	   * @memberOf fabric.util
	   * @param {HTMLElement} element
	   * @param {Object} styles
	   * @return {HTMLElement} Element that was passed as a first argument
	   */
	  function setStyle(element, styles) {
	    var elementStyle = element.style;
	    if (!elementStyle) {
	      return element;
	    }
	    if (typeof styles === 'string') {
	      element.style.cssText += ';' + styles;
	      return styles.indexOf('opacity') > -1
	        ? setOpacity(element, styles.match(/opacity:\s*(\d?\.?\d*)/)[1])
	        : element;
	    }
	    for (var property in styles) {
	      if (property === 'opacity') {
	        setOpacity(element, styles[property]);
	      }
	      else {
	        var normalizedProperty = (property === 'float' || property === 'cssFloat')
	          ? (typeof elementStyle.styleFloat === 'undefined' ? 'cssFloat' : 'styleFloat')
	          : property;
	        elementStyle[normalizedProperty] = styles[property];
	      }
	    }
	    return element;
	  }
	
	  var parseEl = fabric.document.createElement('div'),
	      supportsOpacity = typeof parseEl.style.opacity === 'string',
	      supportsFilters = typeof parseEl.style.filter === 'string',
	      reOpacity = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/,
	
	      /** @ignore */
	      setOpacity = function (element) { return element; };
	
	  if (supportsOpacity) {
	    /** @ignore */
	    setOpacity = function(element, value) {
	      element.style.opacity = value;
	      return element;
	    };
	  }
	  else if (supportsFilters) {
	    /** @ignore */
	    setOpacity = function(element, value) {
	      var es = element.style;
	      if (element.currentStyle && !element.currentStyle.hasLayout) {
	        es.zoom = 1;
	      }
	      if (reOpacity.test(es.filter)) {
	        value = value >= 0.9999 ? '' : ('alpha(opacity=' + (value * 100) + ')');
	        es.filter = es.filter.replace(reOpacity, value);
	      }
	      else {
	        es.filter += ' alpha(opacity=' + (value * 100) + ')';
	      }
	      return element;
	    };
	  }
	
	  fabric.util.setStyle = setStyle;
	
	})();
	
	
	(function() {
	
	  var _slice = Array.prototype.slice;
	
	  /**
	   * Takes id and returns an element with that id (if one exists in a document)
	   * @memberOf fabric.util
	   * @param {String|HTMLElement} id
	   * @return {HTMLElement|null}
	   */
	  function getById(id) {
	    return typeof id === 'string' ? fabric.document.getElementById(id) : id;
	  }
	
	  var sliceCanConvertNodelists,
	      /**
	       * Converts an array-like object (e.g. arguments or NodeList) to an array
	       * @memberOf fabric.util
	       * @param {Object} arrayLike
	       * @return {Array}
	       */
	      toArray = function(arrayLike) {
	        return _slice.call(arrayLike, 0);
	      };
	
	  try {
	    sliceCanConvertNodelists = toArray(fabric.document.childNodes) instanceof Array;
	  }
	  catch (err) { }
	
	  if (!sliceCanConvertNodelists) {
	    toArray = function(arrayLike) {
	      var arr = new Array(arrayLike.length), i = arrayLike.length;
	      while (i--) {
	        arr[i] = arrayLike[i];
	      }
	      return arr;
	    };
	  }
	
	  /**
	   * Creates specified element with specified attributes
	   * @memberOf fabric.util
	   * @param {String} tagName Type of an element to create
	   * @param {Object} [attributes] Attributes to set on an element
	   * @return {HTMLElement} Newly created element
	   */
	  function makeElement(tagName, attributes) {
	    var el = fabric.document.createElement(tagName);
	    for (var prop in attributes) {
	      if (prop === 'class') {
	        el.className = attributes[prop];
	      }
	      else if (prop === 'for') {
	        el.htmlFor = attributes[prop];
	      }
	      else {
	        el.setAttribute(prop, attributes[prop]);
	      }
	    }
	    return el;
	  }
	
	  /**
	   * Adds class to an element
	   * @memberOf fabric.util
	   * @param {HTMLElement} element Element to add class to
	   * @param {String} className Class to add to an element
	   */
	  function addClass(element, className) {
	    if (element && (' ' + element.className + ' ').indexOf(' ' + className + ' ') === -1) {
	      element.className += (element.className ? ' ' : '') + className;
	    }
	  }
	
	  /**
	   * Wraps element with another element
	   * @memberOf fabric.util
	   * @param {HTMLElement} element Element to wrap
	   * @param {HTMLElement|String} wrapper Element to wrap with
	   * @param {Object} [attributes] Attributes to set on a wrapper
	   * @return {HTMLElement} wrapper
	   */
	  function wrapElement(element, wrapper, attributes) {
	    if (typeof wrapper === 'string') {
	      wrapper = makeElement(wrapper, attributes);
	    }
	    if (element.parentNode) {
	      element.parentNode.replaceChild(wrapper, element);
	    }
	    wrapper.appendChild(element);
	    return wrapper;
	  }
	
	  /**
	   * Returns element scroll offsets
	   * @memberOf fabric.util
	   * @param {HTMLElement} element Element to operate on
	   * @return {Object} Object with left/top values
	   */
	  function getScrollLeftTop(element) {
	
	    var left = 0,
	        top = 0,
	        docElement = fabric.document.documentElement,
	        body = fabric.document.body || {
	          scrollLeft: 0, scrollTop: 0
	        };
	
	    // While loop checks (and then sets element to) .parentNode OR .host
	    //  to account for ShadowDOM. We still want to traverse up out of ShadowDOM,
	    //  but the .parentNode of a root ShadowDOM node will always be null, instead
	    //  it should be accessed through .host. See http://stackoverflow.com/a/24765528/4383938
	    while (element && (element.parentNode || element.host)) {
	
	      // Set element to element parent, or 'host' in case of ShadowDOM
	      element = element.parentNode || element.host;
	
	      if (element === fabric.document) {
	        left = body.scrollLeft || docElement.scrollLeft || 0;
	        top = body.scrollTop ||  docElement.scrollTop || 0;
	      }
	      else {
	        left += element.scrollLeft || 0;
	        top += element.scrollTop || 0;
	      }
	
	      if (element.nodeType === 1 &&
	          fabric.util.getElementStyle(element, 'position') === 'fixed') {
	        break;
	      }
	    }
	
	    return { left: left, top: top };
	  }
	
	  /**
	   * Returns offset for a given element
	   * @function
	   * @memberOf fabric.util
	   * @param {HTMLElement} element Element to get offset for
	   * @return {Object} Object with "left" and "top" properties
	   */
	  function getElementOffset(element) {
	    var docElem,
	        doc = element && element.ownerDocument,
	        box = { left: 0, top: 0 },
	        offset = { left: 0, top: 0 },
	        scrollLeftTop,
	        offsetAttributes = {
	          borderLeftWidth: 'left',
	          borderTopWidth:  'top',
	          paddingLeft:     'left',
	          paddingTop:      'top'
	        };
	
	    if (!doc) {
	      return offset;
	    }
	
	    for (var attr in offsetAttributes) {
	      offset[offsetAttributes[attr]] += parseInt(getElementStyle(element, attr), 10) || 0;
	    }
	
	    docElem = doc.documentElement;
	    if ( typeof element.getBoundingClientRect !== 'undefined' ) {
	      box = element.getBoundingClientRect();
	    }
	
	    scrollLeftTop = getScrollLeftTop(element);
	
	    return {
	      left: box.left + scrollLeftTop.left - (docElem.clientLeft || 0) + offset.left,
	      top: box.top + scrollLeftTop.top - (docElem.clientTop || 0)  + offset.top
	    };
	  }
	
	  /**
	   * Returns style attribute value of a given element
	   * @memberOf fabric.util
	   * @param {HTMLElement} element Element to get style attribute for
	   * @param {String} attr Style attribute to get for element
	   * @return {String} Style attribute value of the given element.
	   */
	  var getElementStyle;
	  if (fabric.document.defaultView && fabric.document.defaultView.getComputedStyle) {
	    getElementStyle = function(element, attr) {
	      var style = fabric.document.defaultView.getComputedStyle(element, null);
	      return style ? style[attr] : undefined;
	    };
	  }
	  else {
	    getElementStyle = function(element, attr) {
	      var value = element.style[attr];
	      if (!value && element.currentStyle) {
	        value = element.currentStyle[attr];
	      }
	      return value;
	    };
	  }
	
	  (function () {
	    var style = fabric.document.documentElement.style,
	        selectProp = 'userSelect' in style
	          ? 'userSelect'
	          : 'MozUserSelect' in style
	            ? 'MozUserSelect'
	            : 'WebkitUserSelect' in style
	              ? 'WebkitUserSelect'
	              : 'KhtmlUserSelect' in style
	                ? 'KhtmlUserSelect'
	                : '';
	
	    /**
	     * Makes element unselectable
	     * @memberOf fabric.util
	     * @param {HTMLElement} element Element to make unselectable
	     * @return {HTMLElement} Element that was passed in
	     */
	    function makeElementUnselectable(element) {
	      if (typeof element.onselectstart !== 'undefined') {
	        element.onselectstart = fabric.util.falseFunction;
	      }
	      if (selectProp) {
	        element.style[selectProp] = 'none';
	      }
	      else if (typeof element.unselectable === 'string') {
	        element.unselectable = 'on';
	      }
	      return element;
	    }
	
	    /**
	     * Makes element selectable
	     * @memberOf fabric.util
	     * @param {HTMLElement} element Element to make selectable
	     * @return {HTMLElement} Element that was passed in
	     */
	    function makeElementSelectable(element) {
	      if (typeof element.onselectstart !== 'undefined') {
	        element.onselectstart = null;
	      }
	      if (selectProp) {
	        element.style[selectProp] = '';
	      }
	      else if (typeof element.unselectable === 'string') {
	        element.unselectable = '';
	      }
	      return element;
	    }
	
	    fabric.util.makeElementUnselectable = makeElementUnselectable;
	    fabric.util.makeElementSelectable = makeElementSelectable;
	  })();
	
	  (function() {
	
	    /**
	     * Inserts a script element with a given url into a document; invokes callback, when that script is finished loading
	     * @memberOf fabric.util
	     * @param {String} url URL of a script to load
	     * @param {Function} callback Callback to execute when script is finished loading
	     */
	    function getScript(url, callback) {
	      var headEl = fabric.document.getElementsByTagName('head')[0],
	          scriptEl = fabric.document.createElement('script'),
	          loading = true;
	
	      /** @ignore */
	      scriptEl.onload = /** @ignore */ scriptEl.onreadystatechange = function(e) {
	        if (loading) {
	          if (typeof this.readyState === 'string' &&
	              this.readyState !== 'loaded' &&
	              this.readyState !== 'complete') {
	            return;
	          }
	          loading = false;
	          callback(e || fabric.window.event);
	          scriptEl = scriptEl.onload = scriptEl.onreadystatechange = null;
	        }
	      };
	      scriptEl.src = url;
	      headEl.appendChild(scriptEl);
	      // causes issue in Opera
	      // headEl.removeChild(scriptEl);
	    }
	
	    fabric.util.getScript = getScript;
	  })();
	
	  fabric.util.getById = getById;
	  fabric.util.toArray = toArray;
	  fabric.util.makeElement = makeElement;
	  fabric.util.addClass = addClass;
	  fabric.util.wrapElement = wrapElement;
	  fabric.util.getScrollLeftTop = getScrollLeftTop;
	  fabric.util.getElementOffset = getElementOffset;
	  fabric.util.getElementStyle = getElementStyle;
	
	})();
	
	
	(function() {
	
	  function addParamToUrl(url, param) {
	    return url + (/\?/.test(url) ? '&' : '?') + param;
	  }
	
	  var makeXHR = (function() {
	    var factories = [
	      function() { return new ActiveXObject('Microsoft.XMLHTTP'); },
	      function() { return new ActiveXObject('Msxml2.XMLHTTP'); },
	      function() { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); },
	      function() { return new XMLHttpRequest(); }
	    ];
	    for (var i = factories.length; i--; ) {
	      try {
	        var req = factories[i]();
	        if (req) {
	          return factories[i];
	        }
	      }
	      catch (err) { }
	    }
	  })();
	
	  function emptyFn() { }
	
	  /**
	   * Cross-browser abstraction for sending XMLHttpRequest
	   * @memberOf fabric.util
	   * @param {String} url URL to send XMLHttpRequest to
	   * @param {Object} [options] Options object
	   * @param {String} [options.method="GET"]
	   * @param {String} [options.parameters] parameters to append to url in GET or in body
	   * @param {String} [options.body] body to send with POST or PUT request
	   * @param {Function} options.onComplete Callback to invoke when request is completed
	   * @return {XMLHttpRequest} request
	   */
	  function request(url, options) {
	
	    options || (options = { });
	
	    var method = options.method ? options.method.toUpperCase() : 'GET',
	        onComplete = options.onComplete || function() { },
	        xhr = makeXHR(),
	        body = options.body || options.parameters;
	
	    /** @ignore */
	    xhr.onreadystatechange = function() {
	      if (xhr.readyState === 4) {
	        onComplete(xhr);
	        xhr.onreadystatechange = emptyFn;
	      }
	    };
	
	    if (method === 'GET') {
	      body = null;
	      if (typeof options.parameters === 'string') {
	        url = addParamToUrl(url, options.parameters);
	      }
	    }
	
	    xhr.open(method, url, true);
	
	    if (method === 'POST' || method === 'PUT') {
	      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
	    }
	
	    xhr.send(body);
	    return xhr;
	  }
	
	  fabric.util.request = request;
	})();
	
	
	/**
	 * Wrapper around `console.log` (when available)
	 * @param {*} [values] Values to log
	 */
	fabric.log = function() { };
	
	/**
	 * Wrapper around `console.warn` (when available)
	 * @param {*} [values] Values to log as a warning
	 */
	fabric.warn = function() { };
	
	/* eslint-disable */
	if (typeof console !== 'undefined') {
	
	  ['log', 'warn'].forEach(function(methodName) {
	
	    if (typeof console[methodName] !== 'undefined' &&
	        typeof console[methodName].apply === 'function') {
	
	      fabric[methodName] = function() {
	        return console[methodName].apply(console, arguments);
	      };
	    }
	  });
	}
	/* eslint-enable */
	
	
	(function() {
	
	  /**
	   * Changes value from one to another within certain period of time, invoking callbacks as value is being changed.
	   * @memberOf fabric.util
	   * @param {Object} [options] Animation options
	   * @param {Function} [options.onChange] Callback; invoked on every value change
	   * @param {Function} [options.onComplete] Callback; invoked when value change is completed
	   * @param {Number} [options.startValue=0] Starting value
	   * @param {Number} [options.endValue=100] Ending value
	   * @param {Number} [options.byValue=100] Value to modify the property by
	   * @param {Function} [options.easing] Easing function
	   * @param {Number} [options.duration=500] Duration of change (in ms)
	   */
	  function animate(options) {
	
	    requestAnimFrame(function(timestamp) {
	      options || (options = { });
	
	      var start = timestamp || +new Date(),
	          duration = options.duration || 500,
	          finish = start + duration, time,
	          onChange = options.onChange || function() { },
	          abort = options.abort || function() { return false; },
	          easing = options.easing || function(t, b, c, d) {return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;},
	          startValue = 'startValue' in options ? options.startValue : 0,
	          endValue = 'endValue' in options ? options.endValue : 100,
	          byValue = options.byValue || endValue - startValue;
	
	      options.onStart && options.onStart();
	
	      (function tick(ticktime) {
	        time = ticktime || +new Date();
	        var currentTime = time > finish ? duration : (time - start);
	        if (abort()) {
	          options.onComplete && options.onComplete();
	          return;
	        }
	        onChange(easing(currentTime, startValue, byValue, duration));
	        if (time > finish) {
	          options.onComplete && options.onComplete();
	          return;
	        }
	        requestAnimFrame(tick);
	      })(start);
	    });
	
	  }
	
	  var _requestAnimFrame = fabric.window.requestAnimationFrame       ||
	                          fabric.window.webkitRequestAnimationFrame ||
	                          fabric.window.mozRequestAnimationFrame    ||
	                          fabric.window.oRequestAnimationFrame      ||
	                          fabric.window.msRequestAnimationFrame     ||
	                          function(callback) {
	                            fabric.window.setTimeout(callback, 1000 / 60);
	                          };
	
	  /**
	   * requestAnimationFrame polyfill based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/
	   * In order to get a precise start time, `requestAnimFrame` should be called as an entry into the method
	   * @memberOf fabric.util
	   * @param {Function} callback Callback to invoke
	   * @param {DOMElement} element optional Element to associate with animation
	   */
	  function requestAnimFrame() {
	    return _requestAnimFrame.apply(fabric.window, arguments);
	  }
	
	  fabric.util.animate = animate;
	  fabric.util.requestAnimFrame = requestAnimFrame;
	
	})();
	
	
	(function() {
	
	  function normalize(a, c, p, s) {
	    if (a < Math.abs(c)) {
	      a = c;
	      s = p / 4;
	    }
	    else {
	      //handle the 0/0 case:
	      if (c === 0 && a === 0) {
	        s = p / (2 * Math.PI) * Math.asin(1);
	      }
	      else {
	        s = p / (2 * Math.PI) * Math.asin(c / a);
	      }
	    }
	    return { a: a, c: c, p: p, s: s };
	  }
	
	  function elastic(opts, t, d) {
	    return opts.a *
	      Math.pow(2, 10 * (t -= 1)) *
	      Math.sin( (t * d - opts.s) * (2 * Math.PI) / opts.p );
	  }
	
	  /**
	   * Cubic easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutCubic(t, b, c, d) {
	    return c * ((t = t / d - 1) * t * t + 1) + b;
	  }
	
	  /**
	   * Cubic easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutCubic(t, b, c, d) {
	    t /= d / 2;
	    if (t < 1) {
	      return c / 2 * t * t * t + b;
	    }
	    return c / 2 * ((t -= 2) * t * t + 2) + b;
	  }
	
	  /**
	   * Quartic easing in
	   * @memberOf fabric.util.ease
	   */
	  function easeInQuart(t, b, c, d) {
	    return c * (t /= d) * t * t * t + b;
	  }
	
	  /**
	   * Quartic easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutQuart(t, b, c, d) {
	    return -c * ((t = t / d - 1) * t * t * t - 1) + b;
	  }
	
	  /**
	   * Quartic easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutQuart(t, b, c, d) {
	    t /= d / 2;
	    if (t < 1) {
	      return c / 2 * t * t * t * t + b;
	    }
	    return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
	  }
	
	  /**
	   * Quintic easing in
	   * @memberOf fabric.util.ease
	   */
	  function easeInQuint(t, b, c, d) {
	    return c * (t /= d) * t * t * t * t + b;
	  }
	
	  /**
	   * Quintic easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutQuint(t, b, c, d) {
	    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
	  }
	
	  /**
	   * Quintic easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutQuint(t, b, c, d) {
	    t /= d / 2;
	    if (t < 1) {
	      return c / 2 * t * t * t * t * t + b;
	    }
	    return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
	  }
	
	  /**
	   * Sinusoidal easing in
	   * @memberOf fabric.util.ease
	   */
	  function easeInSine(t, b, c, d) {
	    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
	  }
	
	  /**
	   * Sinusoidal easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutSine(t, b, c, d) {
	    return c * Math.sin(t / d * (Math.PI / 2)) + b;
	  }
	
	  /**
	   * Sinusoidal easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutSine(t, b, c, d) {
	    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
	  }
	
	  /**
	   * Exponential easing in
	   * @memberOf fabric.util.ease
	   */
	  function easeInExpo(t, b, c, d) {
	    return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
	  }
	
	  /**
	   * Exponential easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutExpo(t, b, c, d) {
	    return (t === d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
	  }
	
	  /**
	   * Exponential easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutExpo(t, b, c, d) {
	    if (t === 0) {
	      return b;
	    }
	    if (t === d) {
	      return b + c;
	    }
	    t /= d / 2;
	    if (t < 1) {
	      return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
	    }
	    return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
	  }
	
	  /**
	   * Circular easing in
	   * @memberOf fabric.util.ease
	   */
	  function easeInCirc(t, b, c, d) {
	    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
	  }
	
	  /**
	   * Circular easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutCirc(t, b, c, d) {
	    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
	  }
	
	  /**
	   * Circular easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutCirc(t, b, c, d) {
	    t /= d / 2;
	    if (t < 1) {
	      return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
	    }
	    return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
	  }
	
	  /**
	   * Elastic easing in
	   * @memberOf fabric.util.ease
	   */
	  function easeInElastic(t, b, c, d) {
	    var s = 1.70158, p = 0, a = c;
	    if (t === 0) {
	      return b;
	    }
	    t /= d;
	    if (t === 1) {
	      return b + c;
	    }
	    if (!p) {
	      p = d * 0.3;
	    }
	    var opts = normalize(a, c, p, s);
	    return -elastic(opts, t, d) + b;
	  }
	
	  /**
	   * Elastic easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutElastic(t, b, c, d) {
	    var s = 1.70158, p = 0, a = c;
	    if (t === 0) {
	      return b;
	    }
	    t /= d;
	    if (t === 1) {
	      return b + c;
	    }
	    if (!p) {
	      p = d * 0.3;
	    }
	    var opts = normalize(a, c, p, s);
	    return opts.a * Math.pow(2, -10 * t) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) + opts.c + b;
	  }
	
	  /**
	   * Elastic easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutElastic(t, b, c, d) {
	    var s = 1.70158, p = 0, a = c;
	    if (t === 0) {
	      return b;
	    }
	    t /= d / 2;
	    if (t === 2) {
	      return b + c;
	    }
	    if (!p) {
	      p = d * (0.3 * 1.5);
	    }
	    var opts = normalize(a, c, p, s);
	    if (t < 1) {
	      return -0.5 * elastic(opts, t, d) + b;
	    }
	    return opts.a * Math.pow(2, -10 * (t -= 1)) *
	      Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) * 0.5 + opts.c + b;
	  }
	
	  /**
	   * Backwards easing in
	   * @memberOf fabric.util.ease
	   */
	  function easeInBack(t, b, c, d, s) {
	    if (s === undefined) {
	      s = 1.70158;
	    }
	    return c * (t /= d) * t * ((s + 1) * t - s) + b;
	  }
	
	  /**
	   * Backwards easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutBack(t, b, c, d, s) {
	    if (s === undefined) {
	      s = 1.70158;
	    }
	    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
	  }
	
	  /**
	   * Backwards easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutBack(t, b, c, d, s) {
	    if (s === undefined) {
	      s = 1.70158;
	    }
	    t /= d / 2;
	    if (t < 1) {
	      return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
	    }
	    return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
	  }
	
	  /**
	   * Bouncing easing in
	   * @memberOf fabric.util.ease
	   */
	  function easeInBounce(t, b, c, d) {
	    return c - easeOutBounce (d - t, 0, c, d) + b;
	  }
	
	  /**
	   * Bouncing easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutBounce(t, b, c, d) {
	    if ((t /= d) < (1 / 2.75)) {
	      return c * (7.5625 * t * t) + b;
	    }
	    else if (t < (2 / 2.75)) {
	      return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
	    }
	    else if (t < (2.5 / 2.75)) {
	      return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
	    }
	    else {
	      return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
	    }
	  }
	
	  /**
	   * Bouncing easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutBounce(t, b, c, d) {
	    if (t < d / 2) {
	      return easeInBounce (t * 2, 0, c, d) * 0.5 + b;
	    }
	    return easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
	  }
	
	  /**
	   * Easing functions
	   * See <a href="http://gizma.com/easing/">Easing Equations by Robert Penner</a>
	   * @namespace fabric.util.ease
	   */
	  fabric.util.ease = {
	
	    /**
	     * Quadratic easing in
	     * @memberOf fabric.util.ease
	     */
	    easeInQuad: function(t, b, c, d) {
	      return c * (t /= d) * t + b;
	    },
	
	    /**
	     * Quadratic easing out
	     * @memberOf fabric.util.ease
	     */
	    easeOutQuad: function(t, b, c, d) {
	      return -c * (t /= d) * (t - 2) + b;
	    },
	
	    /**
	     * Quadratic easing in and out
	     * @memberOf fabric.util.ease
	     */
	    easeInOutQuad: function(t, b, c, d) {
	      t /= (d / 2);
	      if (t < 1) {
	        return c / 2 * t * t + b;
	      }
	      return -c / 2 * ((--t) * (t - 2) - 1) + b;
	    },
	
	    /**
	     * Cubic easing in
	     * @memberOf fabric.util.ease
	     */
	    easeInCubic: function(t, b, c, d) {
	      return c * (t /= d) * t * t + b;
	    },
	
	    easeOutCubic: easeOutCubic,
	    easeInOutCubic: easeInOutCubic,
	    easeInQuart: easeInQuart,
	    easeOutQuart: easeOutQuart,
	    easeInOutQuart: easeInOutQuart,
	    easeInQuint: easeInQuint,
	    easeOutQuint: easeOutQuint,
	    easeInOutQuint: easeInOutQuint,
	    easeInSine: easeInSine,
	    easeOutSine: easeOutSine,
	    easeInOutSine: easeInOutSine,
	    easeInExpo: easeInExpo,
	    easeOutExpo: easeOutExpo,
	    easeInOutExpo: easeInOutExpo,
	    easeInCirc: easeInCirc,
	    easeOutCirc: easeOutCirc,
	    easeInOutCirc: easeInOutCirc,
	    easeInElastic: easeInElastic,
	    easeOutElastic: easeOutElastic,
	    easeInOutElastic: easeInOutElastic,
	    easeInBack: easeInBack,
	    easeOutBack: easeOutBack,
	    easeInOutBack: easeInOutBack,
	    easeInBounce: easeInBounce,
	    easeOutBounce: easeOutBounce,
	    easeInOutBounce: easeInOutBounce
	  };
	
	})();
	
	
	(function(global) {
	
	  'use strict';
	
	  /**
	   * @name fabric
	   * @namespace
	   */
	
	  var fabric = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      capitalize = fabric.util.string.capitalize,
	      clone = fabric.util.object.clone,
	      toFixed = fabric.util.toFixed,
	      parseUnit = fabric.util.parseUnit,
	      multiplyTransformMatrices = fabric.util.multiplyTransformMatrices,
	
	      reAllowedSVGTagNames = /^(path|circle|polygon|polyline|ellipse|rect|line|image|text)$/i,
	      reViewBoxTagNames = /^(symbol|image|marker|pattern|view|svg)$/i,
	      reNotAllowedAncestors = /^(?:pattern|defs|symbol|metadata)$/i,
	      reAllowedParents = /^(symbol|g|a|svg)$/i,
	
	      attributesMap = {
	        cx:                   'left',
	        x:                    'left',
	        r:                    'radius',
	        cy:                   'top',
	        y:                    'top',
	        display:              'visible',
	        visibility:           'visible',
	        transform:            'transformMatrix',
	        'fill-opacity':       'fillOpacity',
	        'fill-rule':          'fillRule',
	        'font-family':        'fontFamily',
	        'font-size':          'fontSize',
	        'font-style':         'fontStyle',
	        'font-weight':        'fontWeight',
	        'stroke-dasharray':   'strokeDashArray',
	        'stroke-linecap':     'strokeLineCap',
	        'stroke-linejoin':    'strokeLineJoin',
	        'stroke-miterlimit':  'strokeMiterLimit',
	        'stroke-opacity':     'strokeOpacity',
	        'stroke-width':       'strokeWidth',
	        'text-decoration':    'textDecoration',
	        'text-anchor':        'originX'
	      },
	
	      colorAttributes = {
	        stroke: 'strokeOpacity',
	        fill:   'fillOpacity'
	      };
	
	  fabric.cssRules = { };
	  fabric.gradientDefs = { };
	
	  function normalizeAttr(attr) {
	    // transform attribute names
	    if (attr in attributesMap) {
	      return attributesMap[attr];
	    }
	    return attr;
	  }
	
	  function normalizeValue(attr, value, parentAttributes, fontSize) {
	    var isArray = Object.prototype.toString.call(value) === '[object Array]',
	        parsed;
	
	    if ((attr === 'fill' || attr === 'stroke') && value === 'none') {
	      value = '';
	    }
	    else if (attr === 'strokeDashArray') {
	      value = value.replace(/,/g, ' ').split(/\s+/).map(function(n) {
	        return parseFloat(n);
	      });
	    }
	    else if (attr === 'transformMatrix') {
	      if (parentAttributes && parentAttributes.transformMatrix) {
	        value = multiplyTransformMatrices(
	          parentAttributes.transformMatrix, fabric.parseTransformAttribute(value));
	      }
	      else {
	        value = fabric.parseTransformAttribute(value);
	      }
	    }
	    else if (attr === 'visible') {
	      value = (value === 'none' || value === 'hidden') ? false : true;
	      // display=none on parent element always takes precedence over child element
	      if (parentAttributes && parentAttributes.visible === false) {
	        value = false;
	      }
	    }
	    else if (attr === 'originX' /* text-anchor */) {
	      value = value === 'start' ? 'left' : value === 'end' ? 'right' : 'center';
	    }
	    else {
	      parsed = isArray ? value.map(parseUnit) : parseUnit(value, fontSize);
	    }
	
	    return (!isArray && isNaN(parsed) ? value : parsed);
	  }
	
	  /**
	   * @private
	   * @param {Object} attributes Array of attributes to parse
	   */
	  function _setStrokeFillOpacity(attributes) {
	    for (var attr in colorAttributes) {
	
	      if (typeof attributes[colorAttributes[attr]] === 'undefined' || attributes[attr] === '') {
	        continue;
	      }
	
	      if (typeof attributes[attr] === 'undefined') {
	        if (!fabric.Object.prototype[attr]) {
	          continue;
	        }
	        attributes[attr] = fabric.Object.prototype[attr];
	      }
	
	      if (attributes[attr].indexOf('url(') === 0) {
	        continue;
	      }
	
	      var color = new fabric.Color(attributes[attr]);
	      attributes[attr] = color.setAlpha(toFixed(color.getAlpha() * attributes[colorAttributes[attr]], 2)).toRgba();
	    }
	    return attributes;
	  }
	
	  /**
	   * @private
	   */
	  function _getMultipleNodes(doc, nodeNames) {
	    var nodeName, nodeArray = [], nodeList;
	    for (var i = 0; i < nodeNames.length; i++) {
	      nodeName = nodeNames[i];
	      nodeList = doc.getElementsByTagName(nodeName);
	      nodeArray = nodeArray.concat(Array.prototype.slice.call(nodeList));
	    }
	    return nodeArray;
	  }
	
	  /**
	   * Parses "transform" attribute, returning an array of values
	   * @static
	   * @function
	   * @memberOf fabric
	   * @param {String} attributeValue String containing attribute value
	   * @return {Array} Array of 6 elements representing transformation matrix
	   */
	  fabric.parseTransformAttribute = (function() {
	    function rotateMatrix(matrix, args) {
	      var angle = args[0],
	          x = (args.length === 3) ? args[1] : 0,
	          y = (args.length === 3) ? args[2] : 0;
	
	      matrix[0] = Math.cos(angle);
	      matrix[1] = Math.sin(angle);
	      matrix[2] = -Math.sin(angle);
	      matrix[3] = Math.cos(angle);
	      matrix[4] = x - (matrix[0] * x + matrix[2] * y);
	      matrix[5] = y - (matrix[1] * x + matrix[3] * y);
	    }
	
	    function scaleMatrix(matrix, args) {
	      var multiplierX = args[0],
	          multiplierY = (args.length === 2) ? args[1] : args[0];
	
	      matrix[0] = multiplierX;
	      matrix[3] = multiplierY;
	    }
	
	    function skewXMatrix(matrix, args) {
	      matrix[2] = Math.tan(fabric.util.degreesToRadians(args[0]));
	    }
	
	    function skewYMatrix(matrix, args) {
	      matrix[1] = Math.tan(fabric.util.degreesToRadians(args[0]));
	    }
	
	    function translateMatrix(matrix, args) {
	      matrix[4] = args[0];
	      if (args.length === 2) {
	        matrix[5] = args[1];
	      }
	    }
	
	    // identity matrix
	    var iMatrix = [
	          1, // a
	          0, // b
	          0, // c
	          1, // d
	          0, // e
	          0  // f
	        ],
	
	        // == begin transform regexp
	        number = fabric.reNum,
	
	        commaWsp = '(?:\\s+,?\\s*|,\\s*)',
	
	        skewX = '(?:(skewX)\\s*\\(\\s*(' + number + ')\\s*\\))',
	
	        skewY = '(?:(skewY)\\s*\\(\\s*(' + number + ')\\s*\\))',
	
	        rotate = '(?:(rotate)\\s*\\(\\s*(' + number + ')(?:' +
	                    commaWsp + '(' + number + ')' +
	                    commaWsp + '(' + number + '))?\\s*\\))',
	
	        scale = '(?:(scale)\\s*\\(\\s*(' + number + ')(?:' +
	                    commaWsp + '(' + number + '))?\\s*\\))',
	
	        translate = '(?:(translate)\\s*\\(\\s*(' + number + ')(?:' +
	                    commaWsp + '(' + number + '))?\\s*\\))',
	
	        matrix = '(?:(matrix)\\s*\\(\\s*' +
	                  '(' + number + ')' + commaWsp +
	                  '(' + number + ')' + commaWsp +
	                  '(' + number + ')' + commaWsp +
	                  '(' + number + ')' + commaWsp +
	                  '(' + number + ')' + commaWsp +
	                  '(' + number + ')' +
	                  '\\s*\\))',
	
	        transform = '(?:' +
	                    matrix + '|' +
	                    translate + '|' +
	                    scale + '|' +
	                    rotate + '|' +
	                    skewX + '|' +
	                    skewY +
	                    ')',
	
	        transforms = '(?:' + transform + '(?:' + commaWsp + '*' + transform + ')*' + ')',
	
	        transformList = '^\\s*(?:' + transforms + '?)\\s*$',
	
	        // http://www.w3.org/TR/SVG/coords.html#TransformAttribute
	        reTransformList = new RegExp(transformList),
	        // == end transform regexp
	
	        reTransform = new RegExp(transform, 'g');
	
	    return function(attributeValue) {
	
	      // start with identity matrix
	      var matrix = iMatrix.concat(),
	          matrices = [];
	
	      // return if no argument was given or
	      // an argument does not match transform attribute regexp
	      if (!attributeValue || (attributeValue && !reTransformList.test(attributeValue))) {
	        return matrix;
	      }
	
	      attributeValue.replace(reTransform, function(match) {
	
	        var m = new RegExp(transform).exec(match).filter(function (match) {
	              // match !== '' && match != null
	              return (!!match);
	            }),
	            operation = m[1],
	            args = m.slice(2).map(parseFloat);
	
	        switch (operation) {
	          case 'translate':
	            translateMatrix(matrix, args);
	            break;
	          case 'rotate':
	            args[0] = fabric.util.degreesToRadians(args[0]);
	            rotateMatrix(matrix, args);
	            break;
	          case 'scale':
	            scaleMatrix(matrix, args);
	            break;
	          case 'skewX':
	            skewXMatrix(matrix, args);
	            break;
	          case 'skewY':
	            skewYMatrix(matrix, args);
	            break;
	          case 'matrix':
	            matrix = args;
	            break;
	        }
	
	        // snapshot current matrix into matrices array
	        matrices.push(matrix.concat());
	        // reset
	        matrix = iMatrix.concat();
	      });
	
	      var combinedMatrix = matrices[0];
	      while (matrices.length > 1) {
	        matrices.shift();
	        combinedMatrix = fabric.util.multiplyTransformMatrices(combinedMatrix, matrices[0]);
	      }
	      return combinedMatrix;
	    };
	  })();
	
	  /**
	   * @private
	   */
	  function parseStyleString(style, oStyle) {
	    var attr, value;
	    style.replace(/;\s*$/, '').split(';').forEach(function (chunk) {
	      var pair = chunk.split(':');
	
	      attr = normalizeAttr(pair[0].trim().toLowerCase());
	      value = normalizeValue(attr, pair[1].trim());
	
	      oStyle[attr] = value;
	    });
	  }
	
	  /**
	   * @private
	   */
	  function parseStyleObject(style, oStyle) {
	    var attr, value;
	    for (var prop in style) {
	      if (typeof style[prop] === 'undefined') {
	        continue;
	      }
	
	      attr = normalizeAttr(prop.toLowerCase());
	      value = normalizeValue(attr, style[prop]);
	
	      oStyle[attr] = value;
	    }
	  }
	
	  /**
	   * @private
	   */
	  function getGlobalStylesForElement(element, svgUid) {
	    var styles = { };
	    for (var rule in fabric.cssRules[svgUid]) {
	      if (elementMatchesRule(element, rule.split(' '))) {
	        for (var property in fabric.cssRules[svgUid][rule]) {
	          styles[property] = fabric.cssRules[svgUid][rule][property];
	        }
	      }
	    }
	    return styles;
	  }
	
	  /**
	   * @private
	   */
	  function elementMatchesRule(element, selectors) {
	    var firstMatching, parentMatching = true;
	    //start from rightmost selector.
	    firstMatching = selectorMatches(element, selectors.pop());
	    if (firstMatching && selectors.length) {
	      parentMatching = doesSomeParentMatch(element, selectors);
	    }
	    return firstMatching && parentMatching && (selectors.length === 0);
	  }
	
	  function doesSomeParentMatch(element, selectors) {
	    var selector, parentMatching = true;
	    while (element.parentNode && element.parentNode.nodeType === 1 && selectors.length) {
	      if (parentMatching) {
	        selector = selectors.pop();
	      }
	      element = element.parentNode;
	      parentMatching = selectorMatches(element, selector);
	    }
	    return selectors.length === 0;
	  }
	
	  /**
	   * @private
	   */
	  function selectorMatches(element, selector) {
	    var nodeName = element.nodeName,
	        classNames = element.getAttribute('class'),
	        id = element.getAttribute('id'), matcher;
	    // i check if a selector matches slicing away part from it.
	    // if i get empty string i should match
	    matcher = new RegExp('^' + nodeName, 'i');
	    selector = selector.replace(matcher, '');
	    if (id && selector.length) {
	      matcher = new RegExp('#' + id + '(?![a-zA-Z\\-]+)', 'i');
	      selector = selector.replace(matcher, '');
	    }
	    if (classNames && selector.length) {
	      classNames = classNames.split(' ');
	      for (var i = classNames.length; i--;) {
	        matcher = new RegExp('\\.' + classNames[i] + '(?![a-zA-Z\\-]+)', 'i');
	        selector = selector.replace(matcher, '');
	      }
	    }
	    return selector.length === 0;
	  }
	
	  /**
	   * @private
	   * to support IE8 missing getElementById on SVGdocument
	   */
	  function elementById(doc, id) {
	    var el;
	    doc.getElementById && (el = doc.getElementById(id));
	    if (el) {
	      return el;
	    }
	    var node, i, nodelist = doc.getElementsByTagName('*');
	    for (i = 0; i < nodelist.length; i++) {
	      node = nodelist[i];
	      if (id === node.getAttribute('id')) {
	        return node;
	      }
	    }
	  }
	
	  /**
	   * @private
	   */
	  function parseUseDirectives(doc) {
	    var nodelist = _getMultipleNodes(doc, ['use', 'svg:use']), i = 0;
	
	    while (nodelist.length && i < nodelist.length) {
	      var el = nodelist[i],
	          xlink = el.getAttribute('xlink:href').substr(1),
	          x = el.getAttribute('x') || 0,
	          y = el.getAttribute('y') || 0,
	          el2 = elementById(doc, xlink).cloneNode(true),
	          currentTrans = (el2.getAttribute('transform') || '') + ' translate(' + x + ', ' + y + ')',
	          parentNode, oldLength = nodelist.length, attr, j, attrs, l;
	
	      applyViewboxTransform(el2);
	      if (/^svg$/i.test(el2.nodeName)) {
	        var el3 = el2.ownerDocument.createElement('g');
	        for (j = 0, attrs = el2.attributes, l = attrs.length; j < l; j++) {
	          attr = attrs.item(j);
	          el3.setAttribute(attr.nodeName, attr.nodeValue);
	        }
	        // el2.firstChild != null
	        while (el2.firstChild) {
	          el3.appendChild(el2.firstChild);
	        }
	        el2 = el3;
	      }
	
	      for (j = 0, attrs = el.attributes, l = attrs.length; j < l; j++) {
	        attr = attrs.item(j);
	        if (attr.nodeName === 'x' || attr.nodeName === 'y' || attr.nodeName === 'xlink:href') {
	          continue;
	        }
	
	        if (attr.nodeName === 'transform') {
	          currentTrans = attr.nodeValue + ' ' + currentTrans;
	        }
	        else {
	          el2.setAttribute(attr.nodeName, attr.nodeValue);
	        }
	      }
	
	      el2.setAttribute('transform', currentTrans);
	      el2.setAttribute('instantiated_by_use', '1');
	      el2.removeAttribute('id');
	      parentNode = el.parentNode;
	      parentNode.replaceChild(el2, el);
	      // some browsers do not shorten nodelist after replaceChild (IE8)
	      if (nodelist.length === oldLength) {
	        i++;
	      }
	    }
	  }
	
	  // http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute
	  // matches, e.g.: +14.56e-12, etc.
	  var reViewBoxAttrValue = new RegExp(
	    '^' +
	    '\\s*(' + fabric.reNum + '+)\\s*,?' +
	    '\\s*(' + fabric.reNum + '+)\\s*,?' +
	    '\\s*(' + fabric.reNum + '+)\\s*,?' +
	    '\\s*(' + fabric.reNum + '+)\\s*' +
	    '$'
	  );
	
	  /**
	   * Add a <g> element that envelop all child elements and makes the viewbox transformMatrix descend on all elements
	   */
	  function applyViewboxTransform(element) {
	
	    var viewBoxAttr = element.getAttribute('viewBox'),
	        scaleX = 1,
	        scaleY = 1,
	        minX = 0,
	        minY = 0,
	        viewBoxWidth, viewBoxHeight, matrix, el,
	        widthAttr = element.getAttribute('width'),
	        heightAttr = element.getAttribute('height'),
	        x = element.getAttribute('x') || 0,
	        y = element.getAttribute('y') || 0,
	        preserveAspectRatio = element.getAttribute('preserveAspectRatio') || '',
	        missingViewBox = (!viewBoxAttr || !reViewBoxTagNames.test(element.nodeName)
	                           || !(viewBoxAttr = viewBoxAttr.match(reViewBoxAttrValue))),
	        missingDimAttr = (!widthAttr || !heightAttr || widthAttr === '100%' || heightAttr === '100%'),
	        toBeParsed = missingViewBox && missingDimAttr,
	        parsedDim = { }, translateMatrix = '';
	
	    parsedDim.width = 0;
	    parsedDim.height = 0;
	    parsedDim.toBeParsed = toBeParsed;
	
	    if (toBeParsed) {
	      return parsedDim;
	    }
	
	    if (missingViewBox) {
	      parsedDim.width = parseUnit(widthAttr);
	      parsedDim.height = parseUnit(heightAttr);
	      return parsedDim;
	    }
	
	    minX = -parseFloat(viewBoxAttr[1]);
	    minY = -parseFloat(viewBoxAttr[2]);
	    viewBoxWidth = parseFloat(viewBoxAttr[3]);
	    viewBoxHeight = parseFloat(viewBoxAttr[4]);
	
	    if (!missingDimAttr) {
	      parsedDim.width = parseUnit(widthAttr);
	      parsedDim.height = parseUnit(heightAttr);
	      scaleX = parsedDim.width / viewBoxWidth;
	      scaleY = parsedDim.height / viewBoxHeight;
	    }
	    else {
	      parsedDim.width = viewBoxWidth;
	      parsedDim.height = viewBoxHeight;
	    }
	
	    // default is to preserve aspect ratio
	    preserveAspectRatio = fabric.util.parsePreserveAspectRatioAttribute(preserveAspectRatio);
	    if (preserveAspectRatio.alignX !== 'none') {
	      //translate all container for the effect of Mid, Min, Max
	      scaleY = scaleX = (scaleX > scaleY ? scaleY : scaleX);
	    }
	
	    if (scaleX === 1 && scaleY === 1 && minX === 0 && minY === 0 && x === 0 && y === 0) {
	      return parsedDim;
	    }
	
	    if (x || y) {
	      translateMatrix = ' translate(' + parseUnit(x) + ' ' + parseUnit(y) + ') ';
	    }
	
	    matrix = translateMatrix + ' matrix(' + scaleX +
	                  ' 0' +
	                  ' 0 ' +
	                  scaleY + ' ' +
	                  (minX * scaleX) + ' ' +
	                  (minY * scaleY) + ') ';
	
	    if (element.nodeName === 'svg') {
	      el = element.ownerDocument.createElement('g');
	      // element.firstChild != null
	      while (element.firstChild) {
	        el.appendChild(element.firstChild);
	      }
	      element.appendChild(el);
	    }
	    else {
	      el = element;
	      matrix = el.getAttribute('transform') + matrix;
	    }
	
	    el.setAttribute('transform', matrix);
	    return parsedDim;
	  }
	
	  /**
	   * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback
	   * @static
	   * @function
	   * @memberOf fabric
	   * @param {SVGDocument} doc SVG document to parse
	   * @param {Function} callback Callback to call when parsing is finished;
	   * It's being passed an array of elements (parsed from a document).
	   * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
	   */
	  fabric.parseSVGDocument = (function() {
	
	    function hasAncestorWithNodeName(element, nodeName) {
	      while (element && (element = element.parentNode)) {
	        if (element.nodeName && nodeName.test(element.nodeName.replace('svg:', ''))
	          && !element.getAttribute('instantiated_by_use')) {
	          return true;
	        }
	      }
	      return false;
	    }
	
	    return function(doc, callback, reviver) {
	      if (!doc) {
	        return;
	      }
	
	      parseUseDirectives(doc);
	
	      var startTime = new Date(),
	          svgUid =  fabric.Object.__uid++,
	          options = applyViewboxTransform(doc),
	          descendants = fabric.util.toArray(doc.getElementsByTagName('*'));
	
	      options.svgUid = svgUid;
	
	      if (descendants.length === 0 && fabric.isLikelyNode) {
	        // we're likely in node, where "o3-xml" library fails to gEBTN("*")
	        // https://github.com/ajaxorg/node-o3-xml/issues/21
	        descendants = doc.selectNodes('//*[name(.)!="svg"]');
	        var arr = [];
	        for (var i = 0, len = descendants.length; i < len; i++) {
	          arr[i] = descendants[i];
	        }
	        descendants = arr;
	      }
	
	      var elements = descendants.filter(function(el) {
	        applyViewboxTransform(el);
	        return reAllowedSVGTagNames.test(el.nodeName.replace('svg:', '')) &&
	              !hasAncestorWithNodeName(el, reNotAllowedAncestors); // http://www.w3.org/TR/SVG/struct.html#DefsElement
	      });
	
	      if (!elements || (elements && !elements.length)) {
	        callback && callback([], {});
	        return;
	      }
	
	      fabric.gradientDefs[svgUid] = fabric.getGradientDefs(doc);
	      fabric.cssRules[svgUid] = fabric.getCSSRules(doc);
	      // Precedence of rules:   style > class > attribute
	      fabric.parseElements(elements, function(instances) {
	        fabric.documentParsingTime = new Date() - startTime;
	        if (callback) {
	          callback(instances, options);
	        }
	      }, clone(options), reviver);
	    };
	  })();
	
	  /**
	   * Used for caching SVG documents (loaded via `fabric.Canvas#loadSVGFromURL`)
	   * @namespace
	   */
	  var svgCache = {
	
	    /**
	     * @param {String} name
	     * @param {Function} callback
	     */
	    has: function (name, callback) {
	      callback(false);
	    },
	
	    get: function () {
	      /* NOOP */
	    },
	
	    set: function () {
	      /* NOOP */
	    }
	  };
	
	  /**
	   * @private
	   */
	  function _enlivenCachedObject(cachedObject) {
	
	    var objects = cachedObject.objects,
	        options = cachedObject.options;
	
	    objects = objects.map(function (o) {
	      return fabric[capitalize(o.type)].fromObject(o);
	    });
	
	    return ({ objects: objects, options: options });
	  }
	
	  /**
	   * @private
	   */
	  function _createSVGPattern(markup, canvas, property) {
	    if (canvas[property] && canvas[property].toSVG) {
	      markup.push(
	        '\t<pattern x="0" y="0" id="', property, 'Pattern" ',
	          'width="', canvas[property].source.width,
	          '" height="', canvas[property].source.height,
	          '" patternUnits="userSpaceOnUse">\n',
	        '\t\t<image x="0" y="0" ',
	        'width="', canvas[property].source.width,
	        '" height="', canvas[property].source.height,
	        '" xlink:href="', canvas[property].source.src,
	        '"></image>\n\t</pattern>\n'
	      );
	    }
	  }
	
	  var reFontDeclaration = new RegExp(
	    '(normal|italic)?\\s*(normal|small-caps)?\\s*' +
	    '(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(' +
	      fabric.reNum +
	    '(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|' + fabric.reNum + '))?\\s+(.*)');
	
	  extend(fabric, {
	    /**
	     * Parses a short font declaration, building adding its properties to a style object
	     * @static
	     * @function
	     * @memberOf fabric
	     * @param {String} value font declaration
	     * @param {Object} oStyle definition
	     */
	    parseFontDeclaration: function(value, oStyle) {
	      var match = value.match(reFontDeclaration);
	
	      if (!match) {
	        return;
	      }
	      var fontStyle = match[1],
	          // font variant is not used
	          // fontVariant = match[2],
	          fontWeight = match[3],
	          fontSize = match[4],
	          lineHeight = match[5],
	          fontFamily = match[6];
	
	      if (fontStyle) {
	        oStyle.fontStyle = fontStyle;
	      }
	      if (fontWeight) {
	        oStyle.fontWeight = isNaN(parseFloat(fontWeight)) ? fontWeight : parseFloat(fontWeight);
	      }
	      if (fontSize) {
	        oStyle.fontSize = parseUnit(fontSize);
	      }
	      if (fontFamily) {
	        oStyle.fontFamily = fontFamily;
	      }
	      if (lineHeight) {
	        oStyle.lineHeight = lineHeight === 'normal' ? 1 : lineHeight;
	      }
	    },
	
	    /**
	     * Parses an SVG document, returning all of the gradient declarations found in it
	     * @static
	     * @function
	     * @memberOf fabric
	     * @param {SVGDocument} doc SVG document to parse
	     * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element
	     */
	    getGradientDefs: function(doc) {
	      var tagArray = [
	            'linearGradient',
	            'radialGradient',
	            'svg:linearGradient',
	            'svg:radialGradient'],
	          elList = _getMultipleNodes(doc, tagArray),
	          el, j = 0, id, xlink,
	          gradientDefs = { }, idsToXlinkMap = { };
	
	      j = elList.length;
	
	      while (j--) {
	        el = elList[j];
	        xlink = el.getAttribute('xlink:href');
	        id = el.getAttribute('id');
	        if (xlink) {
	          idsToXlinkMap[id] = xlink.substr(1);
	        }
	        gradientDefs[id] = el;
	      }
	
	      for (id in idsToXlinkMap) {
	        var el2 = gradientDefs[idsToXlinkMap[id]].cloneNode(true);
	        el = gradientDefs[id];
	        while (el2.firstChild) {
	          el.appendChild(el2.firstChild);
	        }
	      }
	      return gradientDefs;
	    },
	
	    /**
	     * Returns an object of attributes' name/value, given element and an array of attribute names;
	     * Parses parent "g" nodes recursively upwards.
	     * @static
	     * @memberOf fabric
	     * @param {DOMElement} element Element to parse
	     * @param {Array} attributes Array of attributes to parse
	     * @return {Object} object containing parsed attributes' names/values
	     */
	    parseAttributes: function(element, attributes, svgUid) {
	
	      if (!element) {
	        return;
	      }
	
	      var value,
	          parentAttributes = { },
	          fontSize;
	
	      if (typeof svgUid === 'undefined') {
	        svgUid = element.getAttribute('svgUid');
	      }
	      // if there's a parent container (`g` or `a` or `symbol` node), parse its attributes recursively upwards
	      if (element.parentNode && reAllowedParents.test(element.parentNode.nodeName)) {
	        parentAttributes = fabric.parseAttributes(element.parentNode, attributes, svgUid);
	      }
	      fontSize = (parentAttributes && parentAttributes.fontSize ) ||
	                 element.getAttribute('font-size') || fabric.Text.DEFAULT_SVG_FONT_SIZE;
	
	      var ownAttributes = attributes.reduce(function(memo, attr) {
	        value = element.getAttribute(attr);
	        if (value) {
	          attr = normalizeAttr(attr);
	          value = normalizeValue(attr, value, parentAttributes, fontSize);
	
	          memo[attr] = value;
	        }
	        return memo;
	      }, { });
	
	      // add values parsed from style, which take precedence over attributes
	      // (see: http://www.w3.org/TR/SVG/styling.html#UsingPresentationAttributes)
	      ownAttributes = extend(ownAttributes,
	        extend(getGlobalStylesForElement(element, svgUid), fabric.parseStyleAttribute(element)));
	      if (ownAttributes.font) {
	        fabric.parseFontDeclaration(ownAttributes.font, ownAttributes);
	      }
	      return _setStrokeFillOpacity(extend(parentAttributes, ownAttributes));
	    },
	
	    /**
	     * Transforms an array of svg elements to corresponding fabric.* instances
	     * @static
	     * @memberOf fabric
	     * @param {Array} elements Array of elements to parse
	     * @param {Function} callback Being passed an array of fabric instances (transformed from SVG elements)
	     * @param {Object} [options] Options object
	     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
	     */
	    parseElements: function(elements, callback, options, reviver) {
	      new fabric.ElementsParser(elements, callback, options, reviver).parse();
	    },
	
	    /**
	     * Parses "style" attribute, retuning an object with values
	     * @static
	     * @memberOf fabric
	     * @param {SVGElement} element Element to parse
	     * @return {Object} Objects with values parsed from style attribute of an element
	     */
	    parseStyleAttribute: function(element) {
	      var oStyle = { },
	          style = element.getAttribute('style');
	
	      if (!style) {
	        return oStyle;
	      }
	
	      if (typeof style === 'string') {
	        parseStyleString(style, oStyle);
	      }
	      else {
	        parseStyleObject(style, oStyle);
	      }
	
	      return oStyle;
	    },
	
	    /**
	     * Parses "points" attribute, returning an array of values
	     * @static
	     * @memberOf fabric
	     * @param {String} points points attribute string
	     * @return {Array} array of points
	     */
	    parsePointsAttribute: function(points) {
	
	      // points attribute is required and must not be empty
	      if (!points) {
	        return null;
	      }
	
	      // replace commas with whitespace and remove bookending whitespace
	      points = points.replace(/,/g, ' ').trim();
	
	      points = points.split(/\s+/);
	      var parsedPoints = [], i, len;
	
	      i = 0;
	      len = points.length;
	      for (; i < len; i += 2) {
	        parsedPoints.push({
	          x: parseFloat(points[i]),
	          y: parseFloat(points[i + 1])
	        });
	      }
	
	      // odd number of points is an error
	      // if (parsedPoints.length % 2 !== 0) {
	      //   return null;
	      // }
	
	      return parsedPoints;
	    },
	
	    /**
	     * Returns CSS rules for a given SVG document
	     * @static
	     * @function
	     * @memberOf fabric
	     * @param {SVGDocument} doc SVG document to parse
	     * @return {Object} CSS rules of this document
	     */
	    getCSSRules: function(doc) {
	      var styles = doc.getElementsByTagName('style'),
	          allRules = { }, rules;
	
	      // very crude parsing of style contents
	      for (var i = 0, len = styles.length; i < len; i++) {
	        // IE9 doesn't support textContent, but provides text instead.
	        var styleContents = styles[i].textContent || styles[i].text;
	
	        // remove comments
	        styleContents = styleContents.replace(/\/\*[\s\S]*?\*\//g, '');
	        if (styleContents.trim() === '') {
	          continue;
	        }
	        rules = styleContents.match(/[^{]*\{[\s\S]*?\}/g);
	        rules = rules.map(function(rule) { return rule.trim(); });
	        rules.forEach(function(rule) {
	
	          var match = rule.match(/([\s\S]*?)\s*\{([^}]*)\}/),
	              ruleObj = { }, declaration = match[2].trim(),
	              propertyValuePairs = declaration.replace(/;$/, '').split(/\s*;\s*/);
	
	          for (var i = 0, len = propertyValuePairs.length; i < len; i++) {
	            var pair = propertyValuePairs[i].split(/\s*:\s*/),
	                property = normalizeAttr(pair[0]),
	                value = normalizeValue(property, pair[1], pair[0]);
	            ruleObj[property] = value;
	          }
	          rule = match[1];
	          rule.split(',').forEach(function(_rule) {
	            _rule = _rule.replace(/^svg/i, '').trim();
	            if (_rule === '') {
	              return;
	            }
	            if (allRules[_rule]) {
	              fabric.util.object.extend(allRules[_rule], ruleObj);
	            }
	            else {
	              allRules[_rule] = fabric.util.object.clone(ruleObj);
	            }
	          });
	        });
	      }
	      return allRules;
	    },
	
	    /**
	     * Takes url corresponding to an SVG document, and parses it into a set of fabric objects.
	     * Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)
	     * @memberOf fabric
	     * @param {String} url
	     * @param {Function} callback
	     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
	     */
	    loadSVGFromURL: function(url, callback, reviver) {
	
	      url = url.replace(/^\n\s*/, '').trim();
	      svgCache.has(url, function (hasUrl) {
	        if (hasUrl) {
	          svgCache.get(url, function (value) {
	            var enlivedRecord = _enlivenCachedObject(value);
	            callback(enlivedRecord.objects, enlivedRecord.options);
	          });
	        }
	        else {
	          new fabric.util.request(url, {
	            method: 'get',
	            onComplete: onComplete
	          });
	        }
	      });
	
	      function onComplete(r) {
	
	        var xml = r.responseXML;
	        if (xml && !xml.documentElement && fabric.window.ActiveXObject && r.responseText) {
	          xml = new ActiveXObject('Microsoft.XMLDOM');
	          xml.async = 'false';
	          //IE chokes on DOCTYPE
	          xml.loadXML(r.responseText.replace(/<!DOCTYPE[\s\S]*?(\[[\s\S]*\])*?>/i, ''));
	        }
	        if (!xml || !xml.documentElement) {
	          callback && callback(null);
	        }
	
	        fabric.parseSVGDocument(xml.documentElement, function (results, options) {
	          svgCache.set(url, {
	            objects: fabric.util.array.invoke(results, 'toObject'),
	            options: options
	          });
	          callback && callback(results, options);
	        }, reviver);
	      }
	    },
	
	    /**
	     * Takes string corresponding to an SVG document, and parses it into a set of fabric objects
	     * @memberOf fabric
	     * @param {String} string
	     * @param {Function} callback
	     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
	     */
	    loadSVGFromString: function(string, callback, reviver) {
	      string = string.trim();
	      var doc;
	      if (typeof DOMParser !== 'undefined') {
	        var parser = new DOMParser();
	        if (parser && parser.parseFromString) {
	          doc = parser.parseFromString(string, 'text/xml');
	        }
	      }
	      else if (fabric.window.ActiveXObject) {
	        doc = new ActiveXObject('Microsoft.XMLDOM');
	        doc.async = 'false';
	        // IE chokes on DOCTYPE
	        doc.loadXML(string.replace(/<!DOCTYPE[\s\S]*?(\[[\s\S]*\])*?>/i, ''));
	      }
	
	      fabric.parseSVGDocument(doc.documentElement, function (results, options) {
	        callback(results, options);
	      }, reviver);
	    },
	
	    /**
	     * Creates markup containing SVG font faces,
	     * font URLs for font faces must be collected by developers
	     * and are not extracted from the DOM by fabricjs
	     * @param {Array} objects Array of fabric objects
	     * @return {String}
	     */
	    createSVGFontFacesMarkup: function(objects) {
	      var markup = '', fontList = { }, obj, fontFamily,
	          style, row, rowIndex, _char, charIndex,
	          fontPaths = fabric.fontPaths;
	
	      for (var i = 0, len = objects.length; i < len; i++) {
	        obj = objects[i];
	        fontFamily = obj.fontFamily;
	        if (obj.type.indexOf('text') === -1 || fontList[fontFamily] || !fontPaths[fontFamily]) {
	          continue;
	        }
	        fontList[fontFamily] = true;
	        if (!obj.styles) {
	          continue;
	        }
	        style = obj.styles;
	        for (rowIndex in style) {
	          row = style[rowIndex];
	          for (charIndex in row) {
	            _char = row[charIndex];
	            fontFamily = _char.fontFamily;
	            if (!fontList[fontFamily] && fontPaths[fontFamily]) {
	              fontList[fontFamily] = true;
	            }
	          }
	        }
	      }
	
	      for (var j in fontList) {
	        markup += [
	          '\t\t@font-face {\n',
	          '\t\t\tfont-family: \'', j, '\';\n',
	          '\t\t\tsrc: url(\'', fontPaths[j], '\');\n',
	          '\t\t}\n'
	        ].join('');
	      }
	
	      if (markup) {
	        markup = [
	          '\t<style type="text/css">',
	          '<![CDATA[\n',
	          markup,
	          ']]>',
	          '</style>\n'
	        ].join('');
	      }
	
	      return markup;
	    },
	
	    /**
	     * Creates markup containing SVG referenced elements like patterns, gradients etc.
	     * @param {fabric.Canvas} canvas instance of fabric.Canvas
	     * @return {String}
	     */
	    createSVGRefElementsMarkup: function(canvas) {
	      var markup = [];
	
	      _createSVGPattern(markup, canvas, 'backgroundColor');
	      _createSVGPattern(markup, canvas, 'overlayColor');
	
	      return markup.join('');
	    }
	  });
	
	})( true ? exports : this);
	
	
	fabric.ElementsParser = function(elements, callback, options, reviver) {
	  this.elements = elements;
	  this.callback = callback;
	  this.options = options;
	  this.reviver = reviver;
	  this.svgUid = (options && options.svgUid) || 0;
	};
	
	fabric.ElementsParser.prototype.parse = function() {
	  this.instances = new Array(this.elements.length);
	  this.numElements = this.elements.length;
	
	  this.createObjects();
	};
	
	fabric.ElementsParser.prototype.createObjects = function() {
	  for (var i = 0, len = this.elements.length; i < len; i++) {
	    this.elements[i].setAttribute('svgUid', this.svgUid);
	    (function(_obj, i) {
	      setTimeout(function() {
	        _obj.createObject(_obj.elements[i], i);
	      }, 0);
	    })(this, i);
	  }
	};
	
	fabric.ElementsParser.prototype.createObject = function(el, index) {
	  var klass = fabric[fabric.util.string.capitalize(el.tagName.replace('svg:', ''))];
	  if (klass && klass.fromElement) {
	    try {
	      this._createObject(klass, el, index);
	    }
	    catch (err) {
	      fabric.log(err);
	    }
	  }
	  else {
	    this.checkIfDone();
	  }
	};
	
	fabric.ElementsParser.prototype._createObject = function(klass, el, index) {
	  if (klass.async) {
	    klass.fromElement(el, this.createCallback(index, el), this.options);
	  }
	  else {
	    var obj = klass.fromElement(el, this.options);
	    this.resolveGradient(obj, 'fill');
	    this.resolveGradient(obj, 'stroke');
	    this.reviver && this.reviver(el, obj);
	    this.instances[index] = obj;
	    this.checkIfDone();
	  }
	};
	
	fabric.ElementsParser.prototype.createCallback = function(index, el) {
	  var _this = this;
	  return function(obj) {
	    _this.resolveGradient(obj, 'fill');
	    _this.resolveGradient(obj, 'stroke');
	    _this.reviver && _this.reviver(el, obj);
	    _this.instances[index] = obj;
	    _this.checkIfDone();
	  };
	};
	
	fabric.ElementsParser.prototype.resolveGradient = function(obj, property) {
	
	  var instanceFillValue = obj.get(property);
	  if (!(/^url\(/).test(instanceFillValue)) {
	    return;
	  }
	  var gradientId = instanceFillValue.slice(5, instanceFillValue.length - 1);
	  if (fabric.gradientDefs[this.svgUid][gradientId]) {
	    obj.set(property,
	      fabric.Gradient.fromElement(fabric.gradientDefs[this.svgUid][gradientId], obj));
	  }
	};
	
	fabric.ElementsParser.prototype.checkIfDone = function() {
	  if (--this.numElements === 0) {
	    this.instances = this.instances.filter(function(el) {
	      // eslint-disable-next-line no-eq-null, eqeqeq
	      return el != null;
	    });
	    this.callback(this.instances);
	  }
	};
	
	
	(function(global) {
	
	  'use strict';
	
	  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */
	
	  var fabric = global.fabric || (global.fabric = { });
	
	  if (fabric.Point) {
	    fabric.warn('fabric.Point is already defined');
	    return;
	  }
	
	  fabric.Point = Point;
	
	  /**
	   * Point class
	   * @class fabric.Point
	   * @memberOf fabric
	   * @constructor
	   * @param {Number} x
	   * @param {Number} y
	   * @return {fabric.Point} thisArg
	   */
	  function Point(x, y) {
	    this.x = x;
	    this.y = y;
	  }
	
	  Point.prototype = /** @lends fabric.Point.prototype */ {
	
	    type: 'point',
	
	    constructor: Point,
	
	    /**
	     * Adds another point to this one and returns another one
	     * @param {fabric.Point} that
	     * @return {fabric.Point} new Point instance with added values
	     */
	    add: function (that) {
	      return new Point(this.x + that.x, this.y + that.y);
	    },
	
	    /**
	     * Adds another point to this one
	     * @param {fabric.Point} that
	     * @return {fabric.Point} thisArg
	     * @chainable
	     */
	    addEquals: function (that) {
	      this.x += that.x;
	      this.y += that.y;
	      return this;
	    },
	
	    /**
	     * Adds value to this point and returns a new one
	     * @param {Number} scalar
	     * @return {fabric.Point} new Point with added value
	     */
	    scalarAdd: function (scalar) {
	      return new Point(this.x + scalar, this.y + scalar);
	    },
	
	    /**
	     * Adds value to this point
	     * @param {Number} scalar
	     * @return {fabric.Point} thisArg
	     * @chainable
	     */
	    scalarAddEquals: function (scalar) {
	      this.x += scalar;
	      this.y += scalar;
	      return this;
	    },
	
	    /**
	     * Subtracts another point from this point and returns a new one
	     * @param {fabric.Point} that
	     * @return {fabric.Point} new Point object with subtracted values
	     */
	    subtract: function (that) {
	      return new Point(this.x - that.x, this.y - that.y);
	    },
	
	    /**
	     * Subtracts another point from this point
	     * @param {fabric.Point} that
	     * @return {fabric.Point} thisArg
	     * @chainable
	     */
	    subtractEquals: function (that) {
	      this.x -= that.x;
	      this.y -= that.y;
	      return this;
	    },
	
	    /**
	     * Subtracts value from this point and returns a new one
	     * @param {Number} scalar
	     * @return {fabric.Point}
	     */
	    scalarSubtract: function (scalar) {
	      return new Point(this.x - scalar, this.y - scalar);
	    },
	
	    /**
	     * Subtracts value from this point
	     * @param {Number} scalar
	     * @return {fabric.Point} thisArg
	     * @chainable
	     */
	    scalarSubtractEquals: function (scalar) {
	      this.x -= scalar;
	      this.y -= scalar;
	      return this;
	    },
	
	    /**
	     * Miltiplies this point by a value and returns a new one
	     * TODO: rename in scalarMultiply in 2.0
	     * @param {Number} scalar
	     * @return {fabric.Point}
	     */
	    multiply: function (scalar) {
	      return new Point(this.x * scalar, this.y * scalar);
	    },
	
	    /**
	     * Miltiplies this point by a value
	     * TODO: rename in scalarMultiplyEquals in 2.0
	     * @param {Number} scalar
	     * @return {fabric.Point} thisArg
	     * @chainable
	     */
	    multiplyEquals: function (scalar) {
	      this.x *= scalar;
	      this.y *= scalar;
	      return this;
	    },
	
	    /**
	     * Divides this point by a value and returns a new one
	     * TODO: rename in scalarDivide in 2.0
	     * @param {Number} scalar
	     * @return {fabric.Point}
	     */
	    divide: function (scalar) {
	      return new Point(this.x / scalar, this.y / scalar);
	    },
	
	    /**
	     * Divides this point by a value
	     * TODO: rename in scalarDivideEquals in 2.0
	     * @param {Number} scalar
	     * @return {fabric.Point} thisArg
	     * @chainable
	     */
	    divideEquals: function (scalar) {
	      this.x /= scalar;
	      this.y /= scalar;
	      return this;
	    },
	
	    /**
	     * Returns true if this point is equal to another one
	     * @param {fabric.Point} that
	     * @return {Boolean}
	     */
	    eq: function (that) {
	      return (this.x === that.x && this.y === that.y);
	    },
	
	    /**
	     * Returns true if this point is less than another one
	     * @param {fabric.Point} that
	     * @return {Boolean}
	     */
	    lt: function (that) {
	      return (this.x < that.x && this.y < that.y);
	    },
	
	    /**
	     * Returns true if this point is less than or equal to another one
	     * @param {fabric.Point} that
	     * @return {Boolean}
	     */
	    lte: function (that) {
	      return (this.x <= that.x && this.y <= that.y);
	    },
	
	    /**
	
	     * Returns true if this point is greater another one
	     * @param {fabric.Point} that
	     * @return {Boolean}
	     */
	    gt: function (that) {
	      return (this.x > that.x && this.y > that.y);
	    },
	
	    /**
	     * Returns true if this point is greater than or equal to another one
	     * @param {fabric.Point} that
	     * @return {Boolean}
	     */
	    gte: function (that) {
	      return (this.x >= that.x && this.y >= that.y);
	    },
	
	    /**
	     * Returns new point which is the result of linear interpolation with this one and another one
	     * @param {fabric.Point} that
	     * @param {Number} t , position of interpolation, between 0 and 1 default 0.5
	     * @return {fabric.Point}
	     */
	    lerp: function (that, t) {
	      if (typeof t === 'undefined') {
	        t = 0.5;
	      }
	      t = Math.max(Math.min(1, t), 0);
	      return new Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);
	    },
	
	    /**
	     * Returns distance from this point and another one
	     * @param {fabric.Point} that
	     * @return {Number}
	     */
	    distanceFrom: function (that) {
	      var dx = this.x - that.x,
	          dy = this.y - that.y;
	      return Math.sqrt(dx * dx + dy * dy);
	    },
	
	    /**
	     * Returns the point between this point and another one
	     * @param {fabric.Point} that
	     * @return {fabric.Point}
	     */
	    midPointFrom: function (that) {
	      return this.lerp(that);
	    },
	
	    /**
	     * Returns a new point which is the min of this and another one
	     * @param {fabric.Point} that
	     * @return {fabric.Point}
	     */
	    min: function (that) {
	      return new Point(Math.min(this.x, that.x), Math.min(this.y, that.y));
	    },
	
	    /**
	     * Returns a new point which is the max of this and another one
	     * @param {fabric.Point} that
	     * @return {fabric.Point}
	     */
	    max: function (that) {
	      return new Point(Math.max(this.x, that.x), Math.max(this.y, that.y));
	    },
	
	    /**
	     * Returns string representation of this point
	     * @return {String}
	     */
	    toString: function () {
	      return this.x + ',' + this.y;
	    },
	
	    /**
	     * Sets x/y of this point
	     * @param {Number} x
	     * @param {Number} y
	     * @chainable
	     */
	    setXY: function (x, y) {
	      this.x = x;
	      this.y = y;
	      return this;
	    },
	
	    /**
	     * Sets x of this point
	     * @param {Number} x
	     * @chainable
	     */
	    setX: function (x) {
	      this.x = x;
	      return this;
	    },
	
	    /**
	     * Sets y of this point
	     * @param {Number} y
	     * @chainable
	     */
	    setY: function (y) {
	      this.y = y;
	      return this;
	    },
	
	    /**
	     * Sets x/y of this point from another point
	     * @param {fabric.Point} that
	     * @chainable
	     */
	    setFromPoint: function (that) {
	      this.x = that.x;
	      this.y = that.y;
	      return this;
	    },
	
	    /**
	     * Swaps x/y of this point and another point
	     * @param {fabric.Point} that
	     */
	    swap: function (that) {
	      var x = this.x,
	          y = this.y;
	      this.x = that.x;
	      this.y = that.y;
	      that.x = x;
	      that.y = y;
	    },
	
	    /**
	     * return a cloned instance of the point
	     * @return {fabric.Point}
	     */
	    clone: function () {
	      return new Point(this.x, this.y);
	    }
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */
	  var fabric = global.fabric || (global.fabric = { });
	
	  if (fabric.Intersection) {
	    fabric.warn('fabric.Intersection is already defined');
	    return;
	  }
	
	  /**
	   * Intersection class
	   * @class fabric.Intersection
	   * @memberOf fabric
	   * @constructor
	   */
	  function Intersection(status) {
	    this.status = status;
	    this.points = [];
	  }
	
	  fabric.Intersection = Intersection;
	
	  fabric.Intersection.prototype = /** @lends fabric.Intersection.prototype */ {
	
	    constructor: Intersection,
	
	    /**
	     * Appends a point to intersection
	     * @param {fabric.Point} point
	     * @return {fabric.Intersection} thisArg
	     * @chainable
	     */
	    appendPoint: function (point) {
	      this.points.push(point);
	      return this;
	    },
	
	    /**
	     * Appends points to intersection
	     * @param {Array} points
	     * @return {fabric.Intersection} thisArg
	     * @chainable
	     */
	    appendPoints: function (points) {
	      this.points = this.points.concat(points);
	      return this;
	    }
	  };
	
	  /**
	   * Checks if one line intersects another
	   * TODO: rename in intersectSegmentSegment
	   * @static
	   * @param {fabric.Point} a1
	   * @param {fabric.Point} a2
	   * @param {fabric.Point} b1
	   * @param {fabric.Point} b2
	   * @return {fabric.Intersection}
	   */
	  fabric.Intersection.intersectLineLine = function (a1, a2, b1, b2) {
	    var result,
	        uaT = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),
	        ubT = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),
	        uB = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
	    if (uB !== 0) {
	      var ua = uaT / uB,
	          ub = ubT / uB;
	      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
	        result = new Intersection('Intersection');
	        result.appendPoint(new fabric.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));
	      }
	      else {
	        result = new Intersection();
	      }
	    }
	    else {
	      if (uaT === 0 || ubT === 0) {
	        result = new Intersection('Coincident');
	      }
	      else {
	        result = new Intersection('Parallel');
	      }
	    }
	    return result;
	  };
	
	  /**
	   * Checks if line intersects polygon
	   * TODO: rename in intersectSegmentPolygon
	   * fix detection of coincident
	   * @static
	   * @param {fabric.Point} a1
	   * @param {fabric.Point} a2
	   * @param {Array} points
	   * @return {fabric.Intersection}
	   */
	  fabric.Intersection.intersectLinePolygon = function(a1, a2, points) {
	    var result = new Intersection(),
	        length = points.length,
	        b1, b2, inter;
	
	    for (var i = 0; i < length; i++) {
	      b1 = points[i];
	      b2 = points[(i + 1) % length];
	      inter = Intersection.intersectLineLine(a1, a2, b1, b2);
	
	      result.appendPoints(inter.points);
	    }
	    if (result.points.length > 0) {
	      result.status = 'Intersection';
	    }
	    return result;
	  };
	
	  /**
	   * Checks if polygon intersects another polygon
	   * @static
	   * @param {Array} points1
	   * @param {Array} points2
	   * @return {fabric.Intersection}
	   */
	  fabric.Intersection.intersectPolygonPolygon = function (points1, points2) {
	    var result = new Intersection(),
	        length = points1.length;
	
	    for (var i = 0; i < length; i++) {
	      var a1 = points1[i],
	          a2 = points1[(i + 1) % length],
	          inter = Intersection.intersectLinePolygon(a1, a2, points2);
	
	      result.appendPoints(inter.points);
	    }
	    if (result.points.length > 0) {
	      result.status = 'Intersection';
	    }
	    return result;
	  };
	
	  /**
	   * Checks if polygon intersects rectangle
	   * @static
	   * @param {Array} points
	   * @param {fabric.Point} r1
	   * @param {fabric.Point} r2
	   * @return {fabric.Intersection}
	   */
	  fabric.Intersection.intersectPolygonRectangle = function (points, r1, r2) {
	    var min = r1.min(r2),
	        max = r1.max(r2),
	        topRight = new fabric.Point(max.x, min.y),
	        bottomLeft = new fabric.Point(min.x, max.y),
	        inter1 = Intersection.intersectLinePolygon(min, topRight, points),
	        inter2 = Intersection.intersectLinePolygon(topRight, max, points),
	        inter3 = Intersection.intersectLinePolygon(max, bottomLeft, points),
	        inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points),
	        result = new Intersection();
	
	    result.appendPoints(inter1.points);
	    result.appendPoints(inter2.points);
	    result.appendPoints(inter3.points);
	    result.appendPoints(inter4.points);
	
	    if (result.points.length > 0) {
	      result.status = 'Intersection';
	    }
	    return result;
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { });
	
	  if (fabric.Color) {
	    fabric.warn('fabric.Color is already defined.');
	    return;
	  }
	
	  /**
	   * Color class
	   * The purpose of {@link fabric.Color} is to abstract and encapsulate common color operations;
	   * {@link fabric.Color} is a constructor and creates instances of {@link fabric.Color} objects.
	   *
	   * @class fabric.Color
	   * @param {String} color optional in hex or rgb(a) or hsl format or from known color list
	   * @return {fabric.Color} thisArg
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#colors}
	   */
	  function Color(color) {
	    if (!color) {
	      this.setSource([0, 0, 0, 1]);
	    }
	    else {
	      this._tryParsingColor(color);
	    }
	  }
	
	  fabric.Color = Color;
	
	  fabric.Color.prototype = /** @lends fabric.Color.prototype */ {
	
	    /**
	     * @private
	     * @param {String|Array} color Color value to parse
	     */
	    _tryParsingColor: function(color) {
	      var source;
	
	      if (color in Color.colorNameMap) {
	        color = Color.colorNameMap[color];
	      }
	
	      if (color === 'transparent') {
	        source = [255, 255, 255, 0];
	      }
	
	      if (!source) {
	        source = Color.sourceFromHex(color);
	      }
	      if (!source) {
	        source = Color.sourceFromRgb(color);
	      }
	      if (!source) {
	        source = Color.sourceFromHsl(color);
	      }
	      if (!source) {
	        //if color is not recognize let's make black as canvas does
	        source = [0, 0, 0, 1];
	      }
	      if (source) {
	        this.setSource(source);
	      }
	    },
	
	    /**
	     * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
	     * @private
	     * @param {Number} r Red color value
	     * @param {Number} g Green color value
	     * @param {Number} b Blue color value
	     * @return {Array} Hsl color
	     */
	    _rgbToHsl: function(r, g, b) {
	      r /= 255; g /= 255; b /= 255;
	
	      var h, s, l,
	          max = fabric.util.array.max([r, g, b]),
	          min = fabric.util.array.min([r, g, b]);
	
	      l = (max + min) / 2;
	
	      if (max === min) {
	        h = s = 0; // achromatic
	      }
	      else {
	        var d = max - min;
	        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
	        switch (max) {
	          case r:
	            h = (g - b) / d + (g < b ? 6 : 0);
	            break;
	          case g:
	            h = (b - r) / d + 2;
	            break;
	          case b:
	            h = (r - g) / d + 4;
	            break;
	        }
	        h /= 6;
	      }
	
	      return [
	        Math.round(h * 360),
	        Math.round(s * 100),
	        Math.round(l * 100)
	      ];
	    },
	
	    /**
	     * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])
	     * @return {Array}
	     */
	    getSource: function() {
	      return this._source;
	    },
	
	    /**
	     * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])
	     * @param {Array} source
	     */
	    setSource: function(source) {
	      this._source = source;
	    },
	
	    /**
	     * Returns color represenation in RGB format
	     * @return {String} ex: rgb(0-255,0-255,0-255)
	     */
	    toRgb: function() {
	      var source = this.getSource();
	      return 'rgb(' + source[0] + ',' + source[1] + ',' + source[2] + ')';
	    },
	
	    /**
	     * Returns color represenation in RGBA format
	     * @return {String} ex: rgba(0-255,0-255,0-255,0-1)
	     */
	    toRgba: function() {
	      var source = this.getSource();
	      return 'rgba(' + source[0] + ',' + source[1] + ',' + source[2] + ',' + source[3] + ')';
	    },
	
	    /**
	     * Returns color represenation in HSL format
	     * @return {String} ex: hsl(0-360,0%-100%,0%-100%)
	     */
	    toHsl: function() {
	      var source = this.getSource(),
	          hsl = this._rgbToHsl(source[0], source[1], source[2]);
	
	      return 'hsl(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%)';
	    },
	
	    /**
	     * Returns color represenation in HSLA format
	     * @return {String} ex: hsla(0-360,0%-100%,0%-100%,0-1)
	     */
	    toHsla: function() {
	      var source = this.getSource(),
	          hsl = this._rgbToHsl(source[0], source[1], source[2]);
	
	      return 'hsla(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%,' + source[3] + ')';
	    },
	
	    /**
	     * Returns color represenation in HEX format
	     * @return {String} ex: FF5555
	     */
	    toHex: function() {
	      var source = this.getSource(), r, g, b;
	
	      r = source[0].toString(16);
	      r = (r.length === 1) ? ('0' + r) : r;
	
	      g = source[1].toString(16);
	      g = (g.length === 1) ? ('0' + g) : g;
	
	      b = source[2].toString(16);
	      b = (b.length === 1) ? ('0' + b) : b;
	
	      return r.toUpperCase() + g.toUpperCase() + b.toUpperCase();
	    },
	
	    /**
	     * Gets value of alpha channel for this color
	     * @return {Number} 0-1
	     */
	    getAlpha: function() {
	      return this.getSource()[3];
	    },
	
	    /**
	     * Sets value of alpha channel for this color
	     * @param {Number} alpha Alpha value 0-1
	     * @return {fabric.Color} thisArg
	     */
	    setAlpha: function(alpha) {
	      var source = this.getSource();
	      source[3] = alpha;
	      this.setSource(source);
	      return this;
	    },
	
	    /**
	     * Transforms color to its grayscale representation
	     * @return {fabric.Color} thisArg
	     */
	    toGrayscale: function() {
	      var source = this.getSource(),
	          average = parseInt((source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), 10),
	          currentAlpha = source[3];
	      this.setSource([average, average, average, currentAlpha]);
	      return this;
	    },
	
	    /**
	     * Transforms color to its black and white representation
	     * @param {Number} threshold
	     * @return {fabric.Color} thisArg
	     */
	    toBlackWhite: function(threshold) {
	      var source = this.getSource(),
	          average = (source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0),
	          currentAlpha = source[3];
	
	      threshold = threshold || 127;
	
	      average = (Number(average) < Number(threshold)) ? 0 : 255;
	      this.setSource([average, average, average, currentAlpha]);
	      return this;
	    },
	
	    /**
	     * Overlays color with another color
	     * @param {String|fabric.Color} otherColor
	     * @return {fabric.Color} thisArg
	     */
	    overlayWith: function(otherColor) {
	      if (!(otherColor instanceof Color)) {
	        otherColor = new Color(otherColor);
	      }
	
	      var result = [],
	          alpha = this.getAlpha(),
	          otherAlpha = 0.5,
	          source = this.getSource(),
	          otherSource = otherColor.getSource();
	
	      for (var i = 0; i < 3; i++) {
	        result.push(Math.round((source[i] * (1 - otherAlpha)) + (otherSource[i] * otherAlpha)));
	      }
	
	      result[3] = alpha;
	      this.setSource(result);
	      return this;
	    }
	  };
	
	  /**
	   * Regex matching color in RGB or RGBA formats (ex: rgb(0, 0, 0), rgba(255, 100, 10, 0.5), rgba( 255 , 100 , 10 , 0.5 ), rgb(1,1,1), rgba(100%, 60%, 10%, 0.5))
	   * @static
	   * @field
	   * @memberOf fabric.Color
	   */
	   // eslint-disable-next-line max-len
	  fabric.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/;
	
	  /**
	   * Regex matching color in HSL or HSLA formats (ex: hsl(200, 80%, 10%), hsla(300, 50%, 80%, 0.5), hsla( 300 , 50% , 80% , 0.5 ))
	   * @static
	   * @field
	   * @memberOf fabric.Color
	   */
	  fabric.Color.reHSLa = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/;
	
	  /**
	   * Regex matching color in HEX format (ex: #FF5544CC, #FF5555, 010155, aff)
	   * @static
	   * @field
	   * @memberOf fabric.Color
	   */
	  fabric.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;
	
	  /**
	   * Map of the 17 basic color names with HEX code
	   * @static
	   * @field
	   * @memberOf fabric.Color
	   * @see: http://www.w3.org/TR/CSS2/syndata.html#color-units
	   */
	  fabric.Color.colorNameMap = {
	    aqua:    '#00FFFF',
	    black:   '#000000',
	    blue:    '#0000FF',
	    fuchsia: '#FF00FF',
	    gray:    '#808080',
	    grey:    '#808080',
	    green:   '#008000',
	    lime:    '#00FF00',
	    maroon:  '#800000',
	    navy:    '#000080',
	    olive:   '#808000',
	    orange:  '#FFA500',
	    purple:  '#800080',
	    red:     '#FF0000',
	    silver:  '#C0C0C0',
	    teal:    '#008080',
	    white:   '#FFFFFF',
	    yellow:  '#FFFF00'
	  };
	
	  /**
	   * @private
	   * @param {Number} p
	   * @param {Number} q
	   * @param {Number} t
	   * @return {Number}
	   */
	  function hue2rgb(p, q, t) {
	    if (t < 0) {
	      t += 1;
	    }
	    if (t > 1) {
	      t -= 1;
	    }
	    if (t < 1 / 6) {
	      return p + (q - p) * 6 * t;
	    }
	    if (t < 1 / 2) {
	      return q;
	    }
	    if (t < 2 / 3) {
	      return p + (q - p) * (2 / 3 - t) * 6;
	    }
	    return p;
	  }
	
	  /**
	   * Returns new color object, when given a color in RGB format
	   * @memberOf fabric.Color
	   * @param {String} color Color value ex: rgb(0-255,0-255,0-255)
	   * @return {fabric.Color}
	   */
	  fabric.Color.fromRgb = function(color) {
	    return Color.fromSource(Color.sourceFromRgb(color));
	  };
	
	  /**
	   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in RGB or RGBA format
	   * @memberOf fabric.Color
	   * @param {String} color Color value ex: rgb(0-255,0-255,0-255), rgb(0%-100%,0%-100%,0%-100%)
	   * @return {Array} source
	   */
	  fabric.Color.sourceFromRgb = function(color) {
	    var match = color.match(Color.reRGBa);
	    if (match) {
	      var r = parseInt(match[1], 10) / (/%$/.test(match[1]) ? 100 : 1) * (/%$/.test(match[1]) ? 255 : 1),
	          g = parseInt(match[2], 10) / (/%$/.test(match[2]) ? 100 : 1) * (/%$/.test(match[2]) ? 255 : 1),
	          b = parseInt(match[3], 10) / (/%$/.test(match[3]) ? 100 : 1) * (/%$/.test(match[3]) ? 255 : 1);
	
	      return [
	        parseInt(r, 10),
	        parseInt(g, 10),
	        parseInt(b, 10),
	        match[4] ? parseFloat(match[4]) : 1
	      ];
	    }
	  };
	
	  /**
	   * Returns new color object, when given a color in RGBA format
	   * @static
	   * @function
	   * @memberOf fabric.Color
	   * @param {String} color
	   * @return {fabric.Color}
	   */
	  fabric.Color.fromRgba = Color.fromRgb;
	
	  /**
	   * Returns new color object, when given a color in HSL format
	   * @param {String} color Color value ex: hsl(0-260,0%-100%,0%-100%)
	   * @memberOf fabric.Color
	   * @return {fabric.Color}
	   */
	  fabric.Color.fromHsl = function(color) {
	    return Color.fromSource(Color.sourceFromHsl(color));
	  };
	
	  /**
	   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HSL or HSLA format.
	   * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
	   * @memberOf fabric.Color
	   * @param {String} color Color value ex: hsl(0-360,0%-100%,0%-100%) or hsla(0-360,0%-100%,0%-100%, 0-1)
	   * @return {Array} source
	   * @see http://http://www.w3.org/TR/css3-color/#hsl-color
	   */
	  fabric.Color.sourceFromHsl = function(color) {
	    var match = color.match(Color.reHSLa);
	    if (!match) {
	      return;
	    }
	
	    var h = (((parseFloat(match[1]) % 360) + 360) % 360) / 360,
	        s = parseFloat(match[2]) / (/%$/.test(match[2]) ? 100 : 1),
	        l = parseFloat(match[3]) / (/%$/.test(match[3]) ? 100 : 1),
	        r, g, b;
	
	    if (s === 0) {
	      r = g = b = l;
	    }
	    else {
	      var q = l <= 0.5 ? l * (s + 1) : l + s - l * s,
	          p = l * 2 - q;
	
	      r = hue2rgb(p, q, h + 1 / 3);
	      g = hue2rgb(p, q, h);
	      b = hue2rgb(p, q, h - 1 / 3);
	    }
	
	    return [
	      Math.round(r * 255),
	      Math.round(g * 255),
	      Math.round(b * 255),
	      match[4] ? parseFloat(match[4]) : 1
	    ];
	  };
	
	  /**
	   * Returns new color object, when given a color in HSLA format
	   * @static
	   * @function
	   * @memberOf fabric.Color
	   * @param {String} color
	   * @return {fabric.Color}
	   */
	  fabric.Color.fromHsla = Color.fromHsl;
	
	  /**
	   * Returns new color object, when given a color in HEX format
	   * @static
	   * @memberOf fabric.Color
	   * @param {String} color Color value ex: FF5555
	   * @return {fabric.Color}
	   */
	  fabric.Color.fromHex = function(color) {
	    return Color.fromSource(Color.sourceFromHex(color));
	  };
	
	  /**
	   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HEX format
	   * @static
	   * @memberOf fabric.Color
	   * @param {String} color ex: FF5555 or FF5544CC (RGBa)
	   * @return {Array} source
	   */
	  fabric.Color.sourceFromHex = function(color) {
	    if (color.match(Color.reHex)) {
	      var value = color.slice(color.indexOf('#') + 1),
	          isShortNotation = (value.length === 3 || value.length === 4),
	          isRGBa = (value.length === 8 || value.length === 4),
	          r = isShortNotation ? (value.charAt(0) + value.charAt(0)) : value.substring(0, 2),
	          g = isShortNotation ? (value.charAt(1) + value.charAt(1)) : value.substring(2, 4),
	          b = isShortNotation ? (value.charAt(2) + value.charAt(2)) : value.substring(4, 6),
	          a = isRGBa ? (isShortNotation ? (value.charAt(3) + value.charAt(3)) : value.substring(6, 8)) : 'FF';
	
	      return [
	        parseInt(r, 16),
	        parseInt(g, 16),
	        parseInt(b, 16),
	        parseFloat((parseInt(a, 16) / 255).toFixed(2))
	      ];
	    }
	  };
	
	  /**
	   * Returns new color object, when given color in array representation (ex: [200, 100, 100, 0.5])
	   * @static
	   * @memberOf fabric.Color
	   * @param {Array} source
	   * @return {fabric.Color}
	   */
	  fabric.Color.fromSource = function(source) {
	    var oColor = new Color();
	    oColor.setSource(source);
	    return oColor;
	  };
	
	})( true ? exports : this);
	
	
	(function() {
	
	  /* _FROM_SVG_START_ */
	  function getColorStop(el) {
	    var style = el.getAttribute('style'),
	        offset = el.getAttribute('offset') || 0,
	        color, colorAlpha, opacity;
	
	    // convert percents to absolute values
	    offset = parseFloat(offset) / (/%$/.test(offset) ? 100 : 1);
	    offset = offset < 0 ? 0 : offset > 1 ? 1 : offset;
	    if (style) {
	      var keyValuePairs = style.split(/\s*;\s*/);
	
	      if (keyValuePairs[keyValuePairs.length - 1] === '') {
	        keyValuePairs.pop();
	      }
	
	      for (var i = keyValuePairs.length; i--; ) {
	
	        var split = keyValuePairs[i].split(/\s*:\s*/),
	            key = split[0].trim(),
	            value = split[1].trim();
	
	        if (key === 'stop-color') {
	          color = value;
	        }
	        else if (key === 'stop-opacity') {
	          opacity = value;
	        }
	      }
	    }
	
	    if (!color) {
	      color = el.getAttribute('stop-color') || 'rgb(0,0,0)';
	    }
	    if (!opacity) {
	      opacity = el.getAttribute('stop-opacity');
	    }
	
	    color = new fabric.Color(color);
	    colorAlpha = color.getAlpha();
	    opacity = isNaN(parseFloat(opacity)) ? 1 : parseFloat(opacity);
	    opacity *= colorAlpha;
	
	    return {
	      offset: offset,
	      color: color.toRgb(),
	      opacity: opacity
	    };
	  }
	
	  function getLinearCoords(el) {
	    return {
	      x1: el.getAttribute('x1') || 0,
	      y1: el.getAttribute('y1') || 0,
	      x2: el.getAttribute('x2') || '100%',
	      y2: el.getAttribute('y2') || 0
	    };
	  }
	
	  function getRadialCoords(el) {
	    return {
	      x1: el.getAttribute('fx') || el.getAttribute('cx') || '50%',
	      y1: el.getAttribute('fy') || el.getAttribute('cy') || '50%',
	      r1: 0,
	      x2: el.getAttribute('cx') || '50%',
	      y2: el.getAttribute('cy') || '50%',
	      r2: el.getAttribute('r') || '50%'
	    };
	  }
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Gradient class
	   * @class fabric.Gradient
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#gradients}
	   * @see {@link fabric.Gradient#initialize} for constructor definition
	   */
	  fabric.Gradient = fabric.util.createClass(/** @lends fabric.Gradient.prototype */ {
	
	    /**
	     * Horizontal offset for aligning gradients coming from SVG when outside pathgroups
	     * @type Number
	     * @default 0
	     */
	    offsetX: 0,
	
	    /**
	     * Vertical offset for aligning gradients coming from SVG when outside pathgroups
	     * @type Number
	     * @default 0
	     */
	    offsetY: 0,
	
	    /**
	     * Constructor
	     * @param {Object} [options] Options object with type, coords, gradientUnits and colorStops
	     * @return {fabric.Gradient} thisArg
	     */
	    initialize: function(options) {
	      options || (options = { });
	
	      var coords = { };
	
	      this.id = fabric.Object.__uid++;
	      this.type = options.type || 'linear';
	
	      coords = {
	        x1: options.coords.x1 || 0,
	        y1: options.coords.y1 || 0,
	        x2: options.coords.x2 || 0,
	        y2: options.coords.y2 || 0
	      };
	
	      if (this.type === 'radial') {
	        coords.r1 = options.coords.r1 || 0;
	        coords.r2 = options.coords.r2 || 0;
	      }
	      this.coords = coords;
	      this.colorStops = options.colorStops.slice();
	      if (options.gradientTransform) {
	        this.gradientTransform = options.gradientTransform;
	      }
	      this.offsetX = options.offsetX || this.offsetX;
	      this.offsetY = options.offsetY || this.offsetY;
	    },
	
	    /**
	     * Adds another colorStop
	     * @param {Object} colorStop Object with offset and color
	     * @return {fabric.Gradient} thisArg
	     */
	    addColorStop: function(colorStop) {
	      for (var position in colorStop) {
	        var color = new fabric.Color(colorStop[position]);
	        this.colorStops.push({
	          offset: position,
	          color: color.toRgb(),
	          opacity: color.getAlpha()
	        });
	      }
	      return this;
	    },
	
	    /**
	     * Returns object representation of a gradient
	     * @return {Object}
	     */
	    toObject: function() {
	      return {
	        type: this.type,
	        coords: this.coords,
	        colorStops: this.colorStops,
	        offsetX: this.offsetX,
	        offsetY: this.offsetY,
	        gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform
	      };
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns SVG representation of an gradient
	     * @param {Object} object Object to create a gradient for
	     * @return {String} SVG representation of an gradient (linear/radial)
	     */
	    toSVG: function(object) {
	      var coords = fabric.util.object.clone(this.coords),
	          markup, commonAttributes;
	
	      // colorStops must be sorted ascending
	      this.colorStops.sort(function(a, b) {
	        return a.offset - b.offset;
	      });
	
	      if (!(object.group && object.group.type === 'path-group')) {
	        for (var prop in coords) {
	          if (prop === 'x1' || prop === 'x2' || prop === 'r2') {
	            coords[prop] += this.offsetX - object.width / 2;
	          }
	          else if (prop === 'y1' || prop === 'y2') {
	            coords[prop] += this.offsetY - object.height / 2;
	          }
	        }
	      }
	
	      commonAttributes = 'id="SVGID_' + this.id +
	                     '" gradientUnits="userSpaceOnUse"';
	      if (this.gradientTransform) {
	        commonAttributes += ' gradientTransform="matrix(' + this.gradientTransform.join(' ') + ')" ';
	      }
	      if (this.type === 'linear') {
	        markup = [
	          '<linearGradient ',
	          commonAttributes,
	          ' x1="', coords.x1,
	          '" y1="', coords.y1,
	          '" x2="', coords.x2,
	          '" y2="', coords.y2,
	          '">\n'
	        ];
	      }
	      else if (this.type === 'radial') {
	        markup = [
	          '<radialGradient ',
	          commonAttributes,
	          ' cx="', coords.x2,
	          '" cy="', coords.y2,
	          '" r="', coords.r2,
	          '" fx="', coords.x1,
	          '" fy="', coords.y1,
	          '">\n'
	        ];
	      }
	
	      for (var i = 0; i < this.colorStops.length; i++) {
	        markup.push(
	          '<stop ',
	            'offset="', (this.colorStops[i].offset * 100) + '%',
	            '" style="stop-color:', this.colorStops[i].color,
	            (this.colorStops[i].opacity !== null ? ';stop-opacity: ' + this.colorStops[i].opacity : ';'),
	          '"/>\n'
	        );
	      }
	
	      markup.push((this.type === 'linear' ? '</linearGradient>\n' : '</radialGradient>\n'));
	
	      return markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns an instance of CanvasGradient
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Object} object
	     * @return {CanvasGradient}
	     */
	    toLive: function(ctx, object) {
	      var gradient, prop, coords = fabric.util.object.clone(this.coords);
	
	      if (!this.type) {
	        return;
	      }
	
	      if (object.group && object.group.type === 'path-group') {
	        for (prop in coords) {
	          if (prop === 'x1' || prop === 'x2') {
	            coords[prop] += -this.offsetX + object.width / 2;
	          }
	          else if (prop === 'y1' || prop === 'y2') {
	            coords[prop] += -this.offsetY + object.height / 2;
	          }
	        }
	      }
	
	      if (this.type === 'linear') {
	        gradient = ctx.createLinearGradient(
	          coords.x1, coords.y1, coords.x2, coords.y2);
	      }
	      else if (this.type === 'radial') {
	        gradient = ctx.createRadialGradient(
	          coords.x1, coords.y1, coords.r1, coords.x2, coords.y2, coords.r2);
	      }
	
	      for (var i = 0, len = this.colorStops.length; i < len; i++) {
	        var color = this.colorStops[i].color,
	            opacity = this.colorStops[i].opacity,
	            offset = this.colorStops[i].offset;
	
	        if (typeof opacity !== 'undefined') {
	          color = new fabric.Color(color).setAlpha(opacity).toRgba();
	        }
	        gradient.addColorStop(parseFloat(offset), color);
	      }
	
	      return gradient;
	    }
	  });
	
	  fabric.util.object.extend(fabric.Gradient, {
	
	    /* _FROM_SVG_START_ */
	    /**
	     * Returns {@link fabric.Gradient} instance from an SVG element
	     * @static
	     * @memberOf fabric.Gradient
	     * @param {SVGGradientElement} el SVG gradient element
	     * @param {fabric.Object} instance
	     * @return {fabric.Gradient} Gradient instance
	     * @see http://www.w3.org/TR/SVG/pservers.html#LinearGradientElement
	     * @see http://www.w3.org/TR/SVG/pservers.html#RadialGradientElement
	     */
	    fromElement: function(el, instance) {
	
	      /**
	       *  @example:
	       *
	       *  <linearGradient id="linearGrad1">
	       *    <stop offset="0%" stop-color="white"/>
	       *    <stop offset="100%" stop-color="black"/>
	       *  </linearGradient>
	       *
	       *  OR
	       *
	       *  <linearGradient id="linearGrad2">
	       *    <stop offset="0" style="stop-color:rgb(255,255,255)"/>
	       *    <stop offset="1" style="stop-color:rgb(0,0,0)"/>
	       *  </linearGradient>
	       *
	       *  OR
	       *
	       *  <radialGradient id="radialGrad1">
	       *    <stop offset="0%" stop-color="white" stop-opacity="1" />
	       *    <stop offset="50%" stop-color="black" stop-opacity="0.5" />
	       *    <stop offset="100%" stop-color="white" stop-opacity="1" />
	       *  </radialGradient>
	       *
	       *  OR
	       *
	       *  <radialGradient id="radialGrad2">
	       *    <stop offset="0" stop-color="rgb(255,255,255)" />
	       *    <stop offset="0.5" stop-color="rgb(0,0,0)" />
	       *    <stop offset="1" stop-color="rgb(255,255,255)" />
	       *  </radialGradient>
	       *
	       */
	
	      var colorStopEls = el.getElementsByTagName('stop'),
	          type,
	          gradientUnits = el.getAttribute('gradientUnits') || 'objectBoundingBox',
	          gradientTransform = el.getAttribute('gradientTransform'),
	          colorStops = [],
	          coords, ellipseMatrix;
	
	      if (el.nodeName === 'linearGradient' || el.nodeName === 'LINEARGRADIENT') {
	        type = 'linear';
	      }
	      else {
	        type = 'radial';
	      }
	
	      if (type === 'linear') {
	        coords = getLinearCoords(el);
	      }
	      else if (type === 'radial') {
	        coords = getRadialCoords(el);
	      }
	
	      for (var i = colorStopEls.length; i--; ) {
	        colorStops.push(getColorStop(colorStopEls[i]));
	      }
	
	      ellipseMatrix = _convertPercentUnitsToValues(instance, coords, gradientUnits);
	
	      var gradient = new fabric.Gradient({
	        type: type,
	        coords: coords,
	        colorStops: colorStops,
	        offsetX: -instance.left,
	        offsetY: -instance.top
	      });
	
	      if (gradientTransform || ellipseMatrix !== '') {
	        gradient.gradientTransform = fabric.parseTransformAttribute((gradientTransform || '') + ellipseMatrix);
	      }
	      return gradient;
	    },
	    /* _FROM_SVG_END_ */
	
	    /**
	     * Returns {@link fabric.Gradient} instance from its object representation
	     * @static
	     * @memberOf fabric.Gradient
	     * @param {Object} obj
	     * @param {Object} [options] Options object
	     */
	    forObject: function(obj, options) {
	      options || (options = { });
	      _convertPercentUnitsToValues(obj, options.coords, 'userSpaceOnUse');
	      return new fabric.Gradient(options);
	    }
	  });
	
	  /**
	   * @private
	   */
	  function _convertPercentUnitsToValues(object, options, gradientUnits) {
	    var propValue, addFactor = 0, multFactor = 1, ellipseMatrix = '';
	    for (var prop in options) {
	      if (options[prop] === 'Infinity') {
	        options[prop] = 1;
	      }
	      else if (options[prop] === '-Infinity') {
	        options[prop] = 0;
	      }
	      propValue = parseFloat(options[prop], 10);
	      if (typeof options[prop] === 'string' && /^\d+%$/.test(options[prop])) {
	        multFactor = 0.01;
	      }
	      else {
	        multFactor = 1;
	      }
	      if (prop === 'x1' || prop === 'x2' || prop === 'r2') {
	        multFactor *= gradientUnits === 'objectBoundingBox' ? object.width : 1;
	        addFactor = gradientUnits === 'objectBoundingBox' ? object.left || 0 : 0;
	      }
	      else if (prop === 'y1' || prop === 'y2') {
	        multFactor *= gradientUnits === 'objectBoundingBox' ? object.height : 1;
	        addFactor = gradientUnits === 'objectBoundingBox' ? object.top || 0 : 0;
	      }
	      options[prop] = propValue * multFactor + addFactor;
	    }
	    if (object.type === 'ellipse' &&
	        options.r2 !== null &&
	        gradientUnits === 'objectBoundingBox' &&
	        object.rx !== object.ry) {
	
	      var scaleFactor = object.ry / object.rx;
	      ellipseMatrix = ' scale(1, ' + scaleFactor + ')';
	      if (options.y1) {
	        options.y1 /= scaleFactor;
	      }
	      if (options.y2) {
	        options.y2 /= scaleFactor;
	      }
	    }
	    return ellipseMatrix;
	  }
	})();
	
	
	/**
	 * Pattern class
	 * @class fabric.Pattern
	 * @see {@link http://fabricjs.com/patterns|Pattern demo}
	 * @see {@link http://fabricjs.com/dynamic-patterns|DynamicPattern demo}
	 * @see {@link fabric.Pattern#initialize} for constructor definition
	 */
	fabric.Pattern = fabric.util.createClass(/** @lends fabric.Pattern.prototype */ {
	
	  /**
	   * Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)
	   * @type String
	   * @default
	   */
	  repeat: 'repeat',
	
	  /**
	   * Pattern horizontal offset from object's left/top corner
	   * @type Number
	   * @default
	   */
	  offsetX: 0,
	
	  /**
	   * Pattern vertical offset from object's left/top corner
	   * @type Number
	   * @default
	   */
	  offsetY: 0,
	
	  /**
	   * Constructor
	   * @param {Object} [options] Options object
	   * @return {fabric.Pattern} thisArg
	   */
	  initialize: function(options) {
	    options || (options = { });
	
	    this.id = fabric.Object.__uid++;
	
	    if (options.source) {
	      if (typeof options.source === 'string') {
	        // function string
	        if (typeof fabric.util.getFunctionBody(options.source) !== 'undefined') {
	          this.source = new Function(fabric.util.getFunctionBody(options.source));
	        }
	        else {
	          // img src string
	          var _this = this;
	          this.source = fabric.util.createImage();
	          fabric.util.loadImage(options.source, function(img) {
	            _this.source = img;
	          });
	        }
	      }
	      else {
	        // img element
	        this.source = options.source;
	      }
	    }
	    if (options.repeat) {
	      this.repeat = options.repeat;
	    }
	    if (options.offsetX) {
	      this.offsetX = options.offsetX;
	    }
	    if (options.offsetY) {
	      this.offsetY = options.offsetY;
	    }
	  },
	
	  /**
	   * Returns object representation of a pattern
	   * @return {Object} Object representation of a pattern instance
	   */
	  toObject: function() {
	
	    var source;
	
	    // callback
	    if (typeof this.source === 'function') {
	      source = String(this.source);
	    }
	    // <img> element
	    else if (typeof this.source.src === 'string') {
	      source = this.source.src;
	    }
	    // <canvas> element
	    else if (typeof this.source === 'object' && this.source.toDataURL) {
	      source = this.source.toDataURL();
	    }
	
	    return {
	      source: source,
	      repeat: this.repeat,
	      offsetX: this.offsetX,
	      offsetY: this.offsetY
	    };
	  },
	
	  /* _TO_SVG_START_ */
	  /**
	   * Returns SVG representation of a pattern
	   * @param {fabric.Object} object
	   * @return {String} SVG representation of a pattern
	   */
	  toSVG: function(object) {
	    var patternSource = typeof this.source === 'function' ? this.source() : this.source,
	        patternWidth = patternSource.width / object.getWidth(),
	        patternHeight = patternSource.height / object.getHeight(),
	        patternOffsetX = this.offsetX / object.getWidth(),
	        patternOffsetY = this.offsetY / object.getHeight(),
	        patternImgSrc = '';
	    if (this.repeat === 'repeat-x' || this.repeat === 'no-repeat') {
	      patternHeight = 1;
	    }
	    if (this.repeat === 'repeat-y' || this.repeat === 'no-repeat') {
	      patternWidth = 1;
	    }
	    if (patternSource.src) {
	      patternImgSrc = patternSource.src;
	    }
	    else if (patternSource.toDataURL) {
	      patternImgSrc = patternSource.toDataURL();
	    }
	
	    return '<pattern id="SVGID_' + this.id +
	                  '" x="' + patternOffsetX +
	                  '" y="' + patternOffsetY +
	                  '" width="' + patternWidth +
	                  '" height="' + patternHeight + '">\n' +
	             '<image x="0" y="0"' +
	                    ' width="' + patternSource.width +
	                    '" height="' + patternSource.height +
	                    '" xlink:href="' + patternImgSrc +
	             '"></image>\n' +
	           '</pattern>\n';
	  },
	  /* _TO_SVG_END_ */
	
	  /**
	   * Returns an instance of CanvasPattern
	   * @param {CanvasRenderingContext2D} ctx Context to create pattern
	   * @return {CanvasPattern}
	   */
	  toLive: function(ctx) {
	    var source = typeof this.source === 'function'
	      ? this.source()
	      : this.source;
	
	    // if the image failed to load, return, and allow rest to continue loading
	    if (!source) {
	      return '';
	    }
	
	    // if an image
	    if (typeof source.src !== 'undefined') {
	      if (!source.complete) {
	        return '';
	      }
	      if (source.naturalWidth === 0 || source.naturalHeight === 0) {
	        return '';
	      }
	    }
	    return ctx.createPattern(source, this.repeat);
	  }
	});
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      toFixed = fabric.util.toFixed;
	
	  if (fabric.Shadow) {
	    fabric.warn('fabric.Shadow is already defined.');
	    return;
	  }
	
	  /**
	   * Shadow class
	   * @class fabric.Shadow
	   * @see {@link http://fabricjs.com/shadows|Shadow demo}
	   * @see {@link fabric.Shadow#initialize} for constructor definition
	   */
	  fabric.Shadow = fabric.util.createClass(/** @lends fabric.Shadow.prototype */ {
	
	    /**
	     * Shadow color
	     * @type String
	     * @default
	     */
	    color: 'rgb(0,0,0)',
	
	    /**
	     * Shadow blur
	     * @type Number
	     */
	    blur: 0,
	
	    /**
	     * Shadow horizontal offset
	     * @type Number
	     * @default
	     */
	    offsetX: 0,
	
	    /**
	     * Shadow vertical offset
	     * @type Number
	     * @default
	     */
	    offsetY: 0,
	
	    /**
	     * Whether the shadow should affect stroke operations
	     * @type Boolean
	     * @default
	     */
	    affectStroke: false,
	
	    /**
	     * Indicates whether toObject should include default values
	     * @type Boolean
	     * @default
	     */
	    includeDefaultValues: true,
	
	    /**
	     * Constructor
	     * @param {Object|String} [options] Options object with any of color, blur, offsetX, offsetX properties or string (e.g. "rgba(0,0,0,0.2) 2px 2px 10px, "2px 2px 10px rgba(0,0,0,0.2)")
	     * @return {fabric.Shadow} thisArg
	     */
	    initialize: function(options) {
	
	      if (typeof options === 'string') {
	        options = this._parseShadow(options);
	      }
	
	      for (var prop in options) {
	        this[prop] = options[prop];
	      }
	
	      this.id = fabric.Object.__uid++;
	    },
	
	    /**
	     * @private
	     * @param {String} shadow Shadow value to parse
	     * @return {Object} Shadow object with color, offsetX, offsetY and blur
	     */
	    _parseShadow: function(shadow) {
	      var shadowStr = shadow.trim(),
	          offsetsAndBlur = fabric.Shadow.reOffsetsAndBlur.exec(shadowStr) || [],
	          color = shadowStr.replace(fabric.Shadow.reOffsetsAndBlur, '') || 'rgb(0,0,0)';
	
	      return {
	        color: color.trim(),
	        offsetX: parseInt(offsetsAndBlur[1], 10) || 0,
	        offsetY: parseInt(offsetsAndBlur[2], 10) || 0,
	        blur: parseInt(offsetsAndBlur[3], 10) || 0
	      };
	    },
	
	    /**
	     * Returns a string representation of an instance
	     * @see http://www.w3.org/TR/css-text-decor-3/#text-shadow
	     * @return {String} Returns CSS3 text-shadow declaration
	     */
	    toString: function() {
	      return [this.offsetX, this.offsetY, this.blur, this.color].join('px ');
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns SVG representation of a shadow
	     * @param {fabric.Object} object
	     * @return {String} SVG representation of a shadow
	     */
	    toSVG: function(object) {
	      var fBoxX = 40, fBoxY = 40, NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
	          offset = fabric.util.rotateVector(
	            { x: this.offsetX, y: this.offsetY },
	            fabric.util.degreesToRadians(-object.angle)),
	          BLUR_BOX = 20;
	
	      if (object.width && object.height) {
	        //http://www.w3.org/TR/SVG/filters.html#FilterEffectsRegion
	        // we add some extra space to filter box to contain the blur ( 20 )
	        fBoxX = toFixed((Math.abs(offset.x) + this.blur) / object.width, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;
	        fBoxY = toFixed((Math.abs(offset.y) + this.blur) / object.height, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;
	      }
	      if (object.flipX) {
	        offset.x *= -1;
	      }
	      if (object.flipY) {
	        offset.y *= -1;
	      }
	      return (
	        '<filter id="SVGID_' + this.id + '" y="-' + fBoxY + '%" height="' + (100 + 2 * fBoxY) + '%" ' +
	          'x="-' + fBoxX + '%" width="' + (100 + 2 * fBoxX) + '%" ' + '>\n' +
	          '\t<feGaussianBlur in="SourceAlpha" stdDeviation="' +
	            toFixed(this.blur ? this.blur / 2 : 0, NUM_FRACTION_DIGITS) + '"></feGaussianBlur>\n' +
	          '\t<feOffset dx="' + toFixed(offset.x, NUM_FRACTION_DIGITS) +
	          '" dy="' + toFixed(offset.y, NUM_FRACTION_DIGITS) + '" result="oBlur" ></feOffset>\n' +
	          '\t<feFlood flood-color="' + this.color + '"/>\n' +
	          '\t<feComposite in2="oBlur" operator="in" />\n' +
	          '\t<feMerge>\n' +
	            '\t\t<feMergeNode></feMergeNode>\n' +
	            '\t\t<feMergeNode in="SourceGraphic"></feMergeNode>\n' +
	          '\t</feMerge>\n' +
	        '</filter>\n');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns object representation of a shadow
	     * @return {Object} Object representation of a shadow instance
	     */
	    toObject: function() {
	      if (this.includeDefaultValues) {
	        return {
	          color: this.color,
	          blur: this.blur,
	          offsetX: this.offsetX,
	          offsetY: this.offsetY,
	          affectStroke: this.affectStroke
	        };
	      }
	      var obj = { }, proto = fabric.Shadow.prototype;
	
	      ['color', 'blur', 'offsetX', 'offsetY', 'affectStroke'].forEach(function(prop) {
	        if (this[prop] !== proto[prop]) {
	          obj[prop] = this[prop];
	        }
	      }, this);
	
	      return obj;
	    }
	  });
	
	  /**
	   * Regex matching shadow offsetX, offsetY and blur (ex: "2px 2px 10px rgba(0,0,0,0.2)", "rgb(0,255,0) 2px 2px")
	   * @static
	   * @field
	   * @memberOf fabric.Shadow
	   */
	  // eslint-disable-next-line max-len
	  fabric.Shadow.reOffsetsAndBlur = /(?:\s|^)(-?\d+(?:px)?(?:\s?|$))?(-?\d+(?:px)?(?:\s?|$))?(\d+(?:px)?)?(?:\s?|$)(?:$|\s)/;
	
	})( true ? exports : this);
	
	
	(function () {
	
	  'use strict';
	
	  if (fabric.StaticCanvas) {
	    fabric.warn('fabric.StaticCanvas is already defined.');
	    return;
	  }
	
	  // aliases for faster resolution
	  var extend = fabric.util.object.extend,
	      getElementOffset = fabric.util.getElementOffset,
	      removeFromArray = fabric.util.removeFromArray,
	      toFixed = fabric.util.toFixed,
	
	      CANVAS_INIT_ERROR = new Error('Could not initialize `canvas` element');
	
	  /**
	   * Static canvas class
	   * @class fabric.StaticCanvas
	   * @mixes fabric.Collection
	   * @mixes fabric.Observable
	   * @see {@link http://fabricjs.com/static_canvas|StaticCanvas demo}
	   * @see {@link fabric.StaticCanvas#initialize} for constructor definition
	   * @fires before:render
	   * @fires after:render
	   * @fires canvas:cleared
	   * @fires object:added
	   * @fires object:removed
	   */
	  fabric.StaticCanvas = fabric.util.createClass(/** @lends fabric.StaticCanvas.prototype */ {
	
	    /**
	     * Constructor
	     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
	     * @param {Object} [options] Options object
	     * @return {Object} thisArg
	     */
	    initialize: function(el, options) {
	      options || (options = { });
	
	      this._initStatic(el, options);
	    },
	
	    /**
	     * Background color of canvas instance.
	     * Should be set via {@link fabric.StaticCanvas#setBackgroundColor}.
	     * @type {(String|fabric.Pattern)}
	     * @default
	     */
	    backgroundColor: '',
	
	    /**
	     * Background image of canvas instance.
	     * Should be set via {@link fabric.StaticCanvas#setBackgroundImage}.
	     * <b>Backwards incompatibility note:</b> The "backgroundImageOpacity"
	     * and "backgroundImageStretch" properties are deprecated since 1.3.9.
	     * Use {@link fabric.Image#opacity}, {@link fabric.Image#width} and {@link fabric.Image#height}.
	     * @type fabric.Image
	     * @default
	     */
	    backgroundImage: null,
	
	    /**
	     * Overlay color of canvas instance.
	     * Should be set via {@link fabric.StaticCanvas#setOverlayColor}
	     * @since 1.3.9
	     * @type {(String|fabric.Pattern)}
	     * @default
	     */
	    overlayColor: '',
	
	    /**
	     * Overlay image of canvas instance.
	     * Should be set via {@link fabric.StaticCanvas#setOverlayImage}.
	     * <b>Backwards incompatibility note:</b> The "overlayImageLeft"
	     * and "overlayImageTop" properties are deprecated since 1.3.9.
	     * Use {@link fabric.Image#left} and {@link fabric.Image#top}.
	     * @type fabric.Image
	     * @default
	     */
	    overlayImage: null,
	
	    /**
	     * Indicates whether toObject/toDatalessObject should include default values
	     * @type Boolean
	     * @default
	     */
	    includeDefaultValues: true,
	
	    /**
	     * Indicates whether objects' state should be saved
	     * @type Boolean
	     * @default
	     */
	    stateful: true,
	
	    /**
	     * Indicates whether {@link fabric.Collection.add}, {@link fabric.Collection.insertAt} and {@link fabric.Collection.remove} should also re-render canvas.
	     * Disabling this option could give a great performance boost when adding/removing a lot of objects to/from canvas at once
	     * (followed by a manual rendering after addition/deletion)
	     * @type Boolean
	     * @default
	     */
	    renderOnAddRemove: true,
	
	    /**
	     * Function that determines clipping of entire canvas area
	     * Being passed context as first argument. See clipping canvas area in {@link https://github.com/kangax/fabric.js/wiki/FAQ}
	     * @type Function
	     * @default
	     */
	    clipTo: null,
	
	    /**
	     * Indicates whether object controls (borders/controls) are rendered above overlay image
	     * @type Boolean
	     * @default
	     */
	    controlsAboveOverlay: false,
	
	    /**
	     * Indicates whether the browser can be scrolled when using a touchscreen and dragging on the canvas
	     * @type Boolean
	     * @default
	     */
	    allowTouchScrolling: false,
	
	    /**
	     * Indicates whether this canvas will use image smoothing, this is on by default in browsers
	     * @type Boolean
	     * @default
	     */
	    imageSmoothingEnabled: true,
	
	    /**
	     * The transformation (in the format of Canvas transform) which focuses the viewport
	     * @type Array
	     * @default
	     */
	    viewportTransform: [1, 0, 0, 1, 0, 0],
	
	    /**
	     * if set to false background image is not affected by viewport transform
	     * @since 1.6.3
	     * @type Boolean
	     * @default
	     */
	    backgroundVpt: true,
	
	    /**
	     * if set to false overlya image is not affected by viewport transform
	     * @since 1.6.3
	     * @type Boolean
	     * @default
	     */
	    overlayVpt: true,
	
	    /**
	     * Callback; invoked right before object is about to be scaled/rotated
	     */
	    onBeforeScaleRotate: function () {
	      /* NOOP */
	    },
	
	    /**
	     * When true, canvas is scaled by devicePixelRatio for better rendering on retina screens
	     */
	    enableRetinaScaling: true,
	
	    /**
	     * @private
	     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
	     * @param {Object} [options] Options object
	     */
	    _initStatic: function(el, options) {
	      var cb = fabric.StaticCanvas.prototype.renderAll.bind(this);
	      this._objects = [];
	      this._createLowerCanvas(el);
	      this._initOptions(options);
	      this._setImageSmoothing();
	      // only initialize retina scaling once
	      if (!this.interactive) {
	        this._initRetinaScaling();
	      }
	
	      if (options.overlayImage) {
	        this.setOverlayImage(options.overlayImage, cb);
	      }
	      if (options.backgroundImage) {
	        this.setBackgroundImage(options.backgroundImage, cb);
	      }
	      if (options.backgroundColor) {
	        this.setBackgroundColor(options.backgroundColor, cb);
	      }
	      if (options.overlayColor) {
	        this.setOverlayColor(options.overlayColor, cb);
	      }
	      this.calcOffset();
	    },
	
	    /**
	     * @private
	     */
	    _isRetinaScaling: function() {
	      return (fabric.devicePixelRatio !== 1 && this.enableRetinaScaling);
	    },
	
	    /**
	     * @private
	     * @return {Number} retinaScaling if applied, otherwise 1;
	     */
	    getRetinaScaling: function() {
	      return this._isRetinaScaling() ? fabric.devicePixelRatio : 1;
	    },
	
	    /**
	     * @private
	     */
	    _initRetinaScaling: function() {
	      if (!this._isRetinaScaling()) {
	        return;
	      }
	      this.lowerCanvasEl.setAttribute('width', this.width * fabric.devicePixelRatio);
	      this.lowerCanvasEl.setAttribute('height', this.height * fabric.devicePixelRatio);
	
	      this.contextContainer.scale(fabric.devicePixelRatio, fabric.devicePixelRatio);
	    },
	
	    /**
	     * Calculates canvas element offset relative to the document
	     * This method is also attached as "resize" event handler of window
	     * @return {fabric.Canvas} instance
	     * @chainable
	     */
	    calcOffset: function () {
	      this._offset = getElementOffset(this.lowerCanvasEl);
	      return this;
	    },
	
	    /**
	     * Sets {@link fabric.StaticCanvas#overlayImage|overlay image} for this canvas
	     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set overlay to
	     * @param {Function} callback callback to invoke when image is loaded and set as an overlay
	     * @param {Object} [options] Optional options to set for the {@link fabric.Image|overlay image}.
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     * @see {@link http://jsfiddle.net/fabricjs/MnzHT/|jsFiddle demo}
	     * @example <caption>Normal overlayImage with left/top = 0</caption>
	     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
	     *   // Needed to position overlayImage at 0/0
	     *   originX: 'left',
	     *   originY: 'top'
	     * });
	     * @example <caption>overlayImage with different properties</caption>
	     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
	     *   opacity: 0.5,
	     *   angle: 45,
	     *   left: 400,
	     *   top: 400,
	     *   originX: 'left',
	     *   originY: 'top'
	     * });
	     * @example <caption>Stretched overlayImage #1 - width/height correspond to canvas width/height</caption>
	     * fabric.Image.fromURL('http://fabricjs.com/assets/jail_cell_bars.png', function(img) {
	     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
	     *    canvas.setOverlayImage(img, canvas.renderAll.bind(canvas));
	     * });
	     * @example <caption>Stretched overlayImage #2 - width/height correspond to canvas width/height</caption>
	     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
	     *   width: canvas.width,
	     *   height: canvas.height,
	     *   // Needed to position overlayImage at 0/0
	     *   originX: 'left',
	     *   originY: 'top'
	     * });
	     * @example <caption>overlayImage loaded from cross-origin</caption>
	     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
	     *   opacity: 0.5,
	     *   angle: 45,
	     *   left: 400,
	     *   top: 400,
	     *   originX: 'left',
	     *   originY: 'top',
	     *   crossOrigin: 'anonymous'
	     * });
	     */
	    setOverlayImage: function (image, callback, options) {
	      return this.__setBgOverlayImage('overlayImage', image, callback, options);
	    },
	
	    /**
	     * Sets {@link fabric.StaticCanvas#backgroundImage|background image} for this canvas
	     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set background to
	     * @param {Function} callback Callback to invoke when image is loaded and set as background
	     * @param {Object} [options] Optional options to set for the {@link fabric.Image|background image}.
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     * @see {@link http://jsfiddle.net/fabricjs/YH9yD/|jsFiddle demo}
	     * @example <caption>Normal backgroundImage with left/top = 0</caption>
	     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
	     *   // Needed to position backgroundImage at 0/0
	     *   originX: 'left',
	     *   originY: 'top'
	     * });
	     * @example <caption>backgroundImage with different properties</caption>
	     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
	     *   opacity: 0.5,
	     *   angle: 45,
	     *   left: 400,
	     *   top: 400,
	     *   originX: 'left',
	     *   originY: 'top'
	     * });
	     * @example <caption>Stretched backgroundImage #1 - width/height correspond to canvas width/height</caption>
	     * fabric.Image.fromURL('http://fabricjs.com/assets/honey_im_subtle.png', function(img) {
	     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
	     *    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
	     * });
	     * @example <caption>Stretched backgroundImage #2 - width/height correspond to canvas width/height</caption>
	     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
	     *   width: canvas.width,
	     *   height: canvas.height,
	     *   // Needed to position backgroundImage at 0/0
	     *   originX: 'left',
	     *   originY: 'top'
	     * });
	     * @example <caption>backgroundImage loaded from cross-origin</caption>
	     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
	     *   opacity: 0.5,
	     *   angle: 45,
	     *   left: 400,
	     *   top: 400,
	     *   originX: 'left',
	     *   originY: 'top',
	     *   crossOrigin: 'anonymous'
	     * });
	     */
	    setBackgroundImage: function (image, callback, options) {
	      return this.__setBgOverlayImage('backgroundImage', image, callback, options);
	    },
	
	    /**
	     * Sets {@link fabric.StaticCanvas#overlayColor|background color} for this canvas
	     * @param {(String|fabric.Pattern)} overlayColor Color or pattern to set background color to
	     * @param {Function} callback Callback to invoke when background color is set
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     * @see {@link http://jsfiddle.net/fabricjs/pB55h/|jsFiddle demo}
	     * @example <caption>Normal overlayColor - color value</caption>
	     * canvas.setOverlayColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
	     * @example <caption>fabric.Pattern used as overlayColor</caption>
	     * canvas.setOverlayColor({
	     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
	     * }, canvas.renderAll.bind(canvas));
	     * @example <caption>fabric.Pattern used as overlayColor with repeat and offset</caption>
	     * canvas.setOverlayColor({
	     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
	     *   repeat: 'repeat',
	     *   offsetX: 200,
	     *   offsetY: 100
	     * }, canvas.renderAll.bind(canvas));
	     */
	    setOverlayColor: function(overlayColor, callback) {
	      return this.__setBgOverlayColor('overlayColor', overlayColor, callback);
	    },
	
	    /**
	     * Sets {@link fabric.StaticCanvas#backgroundColor|background color} for this canvas
	     * @param {(String|fabric.Pattern)} backgroundColor Color or pattern to set background color to
	     * @param {Function} callback Callback to invoke when background color is set
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     * @see {@link http://jsfiddle.net/fabricjs/hXzvk/|jsFiddle demo}
	     * @example <caption>Normal backgroundColor - color value</caption>
	     * canvas.setBackgroundColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
	     * @example <caption>fabric.Pattern used as backgroundColor</caption>
	     * canvas.setBackgroundColor({
	     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
	     * }, canvas.renderAll.bind(canvas));
	     * @example <caption>fabric.Pattern used as backgroundColor with repeat and offset</caption>
	     * canvas.setBackgroundColor({
	     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
	     *   repeat: 'repeat',
	     *   offsetX: 200,
	     *   offsetY: 100
	     * }, canvas.renderAll.bind(canvas));
	     */
	    setBackgroundColor: function(backgroundColor, callback) {
	      return this.__setBgOverlayColor('backgroundColor', backgroundColor, callback);
	    },
	
	    /**
	     * @private
	     * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-imagesmoothingenabled|WhatWG Canvas Standard}
	     */
	    _setImageSmoothing: function() {
	      var ctx = this.getContext();
	
	      ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled || ctx.webkitImageSmoothingEnabled
	        || ctx.mozImageSmoothingEnabled || ctx.msImageSmoothingEnabled || ctx.oImageSmoothingEnabled;
	      ctx.imageSmoothingEnabled = this.imageSmoothingEnabled;
	    },
	
	    /**
	     * @private
	     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundImage|backgroundImage}
	     * or {@link fabric.StaticCanvas#overlayImage|overlayImage})
	     * @param {(fabric.Image|String|null)} image fabric.Image instance, URL of an image or null to set background or overlay to
	     * @param {Function} callback Callback to invoke when image is loaded and set as background or overlay
	     * @param {Object} [options] Optional options to set for the {@link fabric.Image|image}.
	     */
	    __setBgOverlayImage: function(property, image, callback, options) {
	      if (typeof image === 'string') {
	        fabric.util.loadImage(image, function(img) {
	          img && (this[property] = new fabric.Image(img, options));
	          callback && callback(img);
	        }, this, options && options.crossOrigin);
	      }
	      else {
	        options && image.setOptions(options);
	        this[property] = image;
	        callback && callback(image);
	      }
	
	      return this;
	    },
	
	    /**
	     * @private
	     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundColor|backgroundColor}
	     * or {@link fabric.StaticCanvas#overlayColor|overlayColor})
	     * @param {(Object|String|null)} color Object with pattern information, color value or null
	     * @param {Function} [callback] Callback is invoked when color is set
	     */
	    __setBgOverlayColor: function(property, color, callback) {
	      if (color && color.source) {
	        var _this = this;
	        fabric.util.loadImage(color.source, function(img) {
	          _this[property] = new fabric.Pattern({
	            source: img,
	            repeat: color.repeat,
	            offsetX: color.offsetX,
	            offsetY: color.offsetY
	          });
	          callback && callback();
	        });
	      }
	      else {
	        this[property] = color;
	        callback && callback();
	      }
	
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _createCanvasElement: function(canvasEl) {
	      var element = fabric.util.createCanvasElement(canvasEl)
	      if (!element.style) {
	        element.style = { };
	      }
	      if (!element) {
	        throw CANVAS_INIT_ERROR;
	      }
	      if (typeof element.getContext === 'undefined') {
	        throw CANVAS_INIT_ERROR;
	      }
	      return element;
	    },
	
	    /**
	     * @private
	     * @param {Object} [options] Options object
	     */
	    _initOptions: function (options) {
	      for (var prop in options) {
	        this[prop] = options[prop];
	      }
	
	      this.width = this.width || parseInt(this.lowerCanvasEl.width, 10) || 0;
	      this.height = this.height || parseInt(this.lowerCanvasEl.height, 10) || 0;
	
	      if (!this.lowerCanvasEl.style) {
	        return;
	      }
	
	      this.lowerCanvasEl.width = this.width;
	      this.lowerCanvasEl.height = this.height;
	
	      this.lowerCanvasEl.style.width = this.width + 'px';
	      this.lowerCanvasEl.style.height = this.height + 'px';
	
	      this.viewportTransform = this.viewportTransform.slice();
	    },
	
	    /**
	     * Creates a bottom canvas
	     * @private
	     * @param {HTMLElement} [canvasEl]
	     */
	    _createLowerCanvas: function (canvasEl) {
	      this.lowerCanvasEl = fabric.util.getById(canvasEl) || this._createCanvasElement(canvasEl);
	
	      fabric.util.addClass(this.lowerCanvasEl, 'lower-canvas');
	
	      if (this.interactive) {
	        this._applyCanvasStyle(this.lowerCanvasEl);
	      }
	
	      this.contextContainer = this.lowerCanvasEl.getContext('2d');
	    },
	
	    /**
	     * Returns canvas width (in px)
	     * @return {Number}
	     */
	    getWidth: function () {
	      return this.width;
	    },
	
	    /**
	     * Returns canvas height (in px)
	     * @return {Number}
	     */
	    getHeight: function () {
	      return this.height;
	    },
	
	    /**
	     * Sets width of this canvas instance
	     * @param {Number|String} value                         Value to set width to
	     * @param {Object}        [options]                     Options object
	     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
	     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    setWidth: function (value, options) {
	      return this.setDimensions({ width: value }, options);
	    },
	
	    /**
	     * Sets height of this canvas instance
	     * @param {Number|String} value                         Value to set height to
	     * @param {Object}        [options]                     Options object
	     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
	     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    setHeight: function (value, options) {
	      return this.setDimensions({ height: value }, options);
	    },
	
	    /**
	     * Sets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)
	     * @param {Object}        dimensions                    Object with width/height properties
	     * @param {Number|String} [dimensions.width]            Width of canvas element
	     * @param {Number|String} [dimensions.height]           Height of canvas element
	     * @param {Object}        [options]                     Options object
	     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
	     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    setDimensions: function (dimensions, options) {
	      var cssValue;
	
	      options = options || {};
	
	      for (var prop in dimensions) {
	        cssValue = dimensions[prop];
	
	        if (!options.cssOnly) {
	          this._setBackstoreDimension(prop, dimensions[prop]);
	          cssValue += 'px';
	        }
	
	        if (!options.backstoreOnly) {
	          this._setCssDimension(prop, cssValue);
	        }
	      }
	      this._initRetinaScaling();
	      this._setImageSmoothing();
	      this.calcOffset();
	
	      if (!options.cssOnly) {
	        this.renderAll();
	      }
	
	      return this;
	    },
	
	    /**
	     * Helper for setting width/height
	     * @private
	     * @param {String} prop property (width|height)
	     * @param {Number} value value to set property to
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    _setBackstoreDimension: function (prop, value) {
	      this.lowerCanvasEl[prop] = value;
	
	      if (this.upperCanvasEl) {
	        this.upperCanvasEl[prop] = value;
	      }
	
	      if (this.cacheCanvasEl) {
	        this.cacheCanvasEl[prop] = value;
	      }
	
	      this[prop] = value;
	
	      return this;
	    },
	
	    /**
	     * Helper for setting css width/height
	     * @private
	     * @param {String} prop property (width|height)
	     * @param {String} value value to set property to
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    _setCssDimension: function (prop, value) {
	      this.lowerCanvasEl.style[prop] = value;
	
	      if (this.upperCanvasEl) {
	        this.upperCanvasEl.style[prop] = value;
	      }
	
	      if (this.wrapperEl) {
	        this.wrapperEl.style[prop] = value;
	      }
	
	      return this;
	    },
	
	    /**
	     * Returns canvas zoom level
	     * @return {Number}
	     */
	    getZoom: function () {
	      return Math.sqrt(this.viewportTransform[0] * this.viewportTransform[3]);
	    },
	
	    /**
	     * Sets viewport transform of this canvas instance
	     * @param {Array} vpt the transform in the form of context.transform
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    setViewportTransform: function (vpt) {
	      var activeGroup = this._activeGroup, object;
	      this.viewportTransform = vpt;
	      for (var i = 0, len = this._objects.length; i < len; i++) {
	        object = this._objects[i];
	        object.group || object.setCoords();
	      }
	      if (activeGroup) {
	        activeGroup.setCoords();
	      }
	      this.renderAll();
	      return this;
	    },
	
	    /**
	     * Sets zoom level of this canvas instance, zoom centered around point
	     * @param {fabric.Point} point to zoom with respect to
	     * @param {Number} value to set zoom to, less than 1 zooms out
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    zoomToPoint: function (point, value) {
	      // TODO: just change the scale, preserve other transformations
	      var before = point, vpt = this.viewportTransform.slice(0);
	      point = fabric.util.transformPoint(point, fabric.util.invertTransform(this.viewportTransform));
	      vpt[0] = value;
	      vpt[3] = value;
	      var after = fabric.util.transformPoint(point, vpt);
	      vpt[4] += before.x - after.x;
	      vpt[5] += before.y - after.y;
	      return this.setViewportTransform(vpt);
	    },
	
	    /**
	     * Sets zoom level of this canvas instance
	     * @param {Number} value to set zoom to, less than 1 zooms out
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    setZoom: function (value) {
	      this.zoomToPoint(new fabric.Point(0, 0), value);
	      return this;
	    },
	
	    /**
	     * Pan viewport so as to place point at top left corner of canvas
	     * @param {fabric.Point} point to move to
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    absolutePan: function (point) {
	      var vpt = this.viewportTransform.slice(0);
	      vpt[4] = -point.x;
	      vpt[5] = -point.y;
	      return this.setViewportTransform(vpt);
	    },
	
	    /**
	     * Pans viewpoint relatively
	     * @param {fabric.Point} point (position vector) to move by
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    relativePan: function (point) {
	      return this.absolutePan(new fabric.Point(
	        -point.x - this.viewportTransform[4],
	        -point.y - this.viewportTransform[5]
	      ));
	    },
	
	    /**
	     * Returns &lt;canvas> element corresponding to this instance
	     * @return {HTMLCanvasElement}
	     */
	    getElement: function () {
	      return this.lowerCanvasEl;
	    },
	
	    /**
	     * @private
	     * @param {fabric.Object} obj Object that was added
	     */
	    _onObjectAdded: function(obj) {
	      this.stateful && obj.setupState();
	      obj._set('canvas', this);
	      obj.setCoords();
	      this.fire('object:added', { target: obj });
	      obj.fire('added');
	    },
	
	    /**
	     * @private
	     * @param {fabric.Object} obj Object that was removed
	     */
	    _onObjectRemoved: function(obj) {
	      this.fire('object:removed', { target: obj });
	      obj.fire('removed');
	      delete obj.canvas;
	    },
	
	    /**
	     * Clears specified context of canvas element
	     * @param {CanvasRenderingContext2D} ctx Context to clear
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    clearContext: function(ctx) {
	      ctx.clearRect(0, 0, this.width, this.height);
	      return this;
	    },
	
	    /**
	     * Returns context of canvas where objects are drawn
	     * @return {CanvasRenderingContext2D}
	     */
	    getContext: function () {
	      return this.contextContainer;
	    },
	
	    /**
	     * Clears all contexts (background, main, top) of an instance
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    clear: function () {
	      this._objects.length = 0;
	      this.backgroundImage = null;
	      this.overlayImage = null;
	      this.backgroundColor = '';
	      this.overlayColor = ''
	      if (this._hasITextHandlers) {
	        this.off('selection:cleared', this._canvasITextSelectionClearedHanlder);
	        this.off('object:selected', this._canvasITextSelectionClearedHanlder);
	        this.off('mouse:up', this._mouseUpITextHandler);
	        this._iTextInstances = null;
	        this._hasITextHandlers = false;
	      }
	      this.clearContext(this.contextContainer);
	      this.fire('canvas:cleared');
	      this.renderAll();
	      return this;
	    },
	
	    /**
	     * Renders both the canvas.
	     * @return {fabric.Canvas} instance
	     * @chainable
	     */
	    renderAll: function () {
	      var canvasToDrawOn = this.contextContainer;
	      this.renderCanvas(canvasToDrawOn, this._objects);
	      return this;
	    },
	
	    /**
	     * Renders background, objects, overlay and controls.
	     * @param {CanvasRenderingContext2D} ctx
	     * @param {Array} objects to render
	     * @return {fabric.Canvas} instance
	     * @chainable
	     */
	    renderCanvas: function(ctx, objects) {
	      this.clearContext(ctx);
	      this.fire('before:render');
	      if (this.clipTo) {
	        fabric.util.clipContext(this, ctx);
	      }
	      this._renderBackground(ctx);
	
	      ctx.save();
	      //apply viewport transform once for all rendering process
	      ctx.transform.apply(ctx, this.viewportTransform);
	      this._renderObjects(ctx, objects);
	      ctx.restore();
	      if (!this.controlsAboveOverlay && this.interactive) {
	        this.drawControls(ctx);
	      }
	      if (this.clipTo) {
	        ctx.restore();
	      }
	      this._renderOverlay(ctx);
	      if (this.controlsAboveOverlay && this.interactive) {
	        this.drawControls(ctx);
	      }
	      this.fire('after:render');
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Array} objects to render
	     */
	    _renderObjects: function(ctx, objects) {
	      for (var i = 0, length = objects.length; i < length; ++i) {
	        objects[i] && objects[i].render(ctx);
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {string} property 'background' or 'overlay'
	     */
	    _renderBackgroundOrOverlay: function(ctx, property) {
	      var object = this[property + 'Color'];
	      if (object) {
	        ctx.fillStyle = object.toLive
	          ? object.toLive(ctx)
	          : object;
	
	        ctx.fillRect(
	          object.offsetX || 0,
	          object.offsetY || 0,
	          this.width,
	          this.height);
	      }
	      object = this[property + 'Image'];
	      if (object) {
	        if (this[property + 'Vpt']) {
	          ctx.save();
	          ctx.transform.apply(ctx, this.viewportTransform);
	        }
	        object.render(ctx);
	        this[property + 'Vpt'] && ctx.restore();
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderBackground: function(ctx) {
	      this._renderBackgroundOrOverlay(ctx, 'background');
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderOverlay: function(ctx) {
	      this._renderBackgroundOrOverlay(ctx, 'overlay');
	    },
	
	    /**
	     * Returns coordinates of a center of canvas.
	     * Returned value is an object with top and left properties
	     * @return {Object} object with "top" and "left" number values
	     */
	    getCenter: function () {
	      return {
	        top: this.getHeight() / 2,
	        left: this.getWidth() / 2
	      };
	    },
	
	    /**
	     * Centers object horizontally in the canvas
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @param {fabric.Object} object Object to center horizontally
	     * @return {fabric.Canvas} thisArg
	     */
	    centerObjectH: function (object) {
	      return this._centerObject(object, new fabric.Point(this.getCenter().left, object.getCenterPoint().y));
	    },
	
	    /**
	     * Centers object vertically in the canvas
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @param {fabric.Object} object Object to center vertically
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    centerObjectV: function (object) {
	      return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, this.getCenter().top));
	    },
	
	    /**
	     * Centers object vertically and horizontally in the canvas
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @param {fabric.Object} object Object to center vertically and horizontally
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    centerObject: function(object) {
	      var center = this.getCenter();
	
	      return this._centerObject(object, new fabric.Point(center.left, center.top));
	    },
	
	    /**
	     * Centers object vertically and horizontally in the viewport
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @param {fabric.Object} object Object to center vertically and horizontally
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    viewportCenterObject: function(object) {
	      var vpCenter = this.getVpCenter();
	
	      return this._centerObject(object, vpCenter);
	    },
	
	    /**
	     * Centers object horizontally in the viewport, object.top is unchanged
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @param {fabric.Object} object Object to center vertically and horizontally
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    viewportCenterObjectH: function(object) {
	      var vpCenter = this.getVpCenter();
	      this._centerObject(object, new fabric.Point(vpCenter.x, object.getCenterPoint().y));
	      return this;
	    },
	
	    /**
	     * Centers object Vertically in the viewport, object.top is unchanged
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @param {fabric.Object} object Object to center vertically and horizontally
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    viewportCenterObjectV: function(object) {
	      var vpCenter = this.getVpCenter();
	
	      return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, vpCenter.y));
	    },
	
	    /**
	     * Calculate the point in canvas that correspond to the center of actual viewport.
	     * @return {fabric.Point} vpCenter, viewport center
	     * @chainable
	     */
	    getVpCenter: function() {
	      var center = this.getCenter(),
	          iVpt = fabric.util.invertTransform(this.viewportTransform);
	      return fabric.util.transformPoint({ x: center.left, y: center.top }, iVpt);
	    },
	
	    /**
	     * @private
	     * @param {fabric.Object} object Object to center
	     * @param {fabric.Point} center Center point
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    _centerObject: function(object, center) {
	      object.setPositionByOrigin(center, 'center', 'center');
	      this.renderAll();
	      return this;
	    },
	
	    /**
	     * Returs dataless JSON representation of canvas
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {String} json string
	     */
	    toDatalessJSON: function (propertiesToInclude) {
	      return this.toDatalessObject(propertiesToInclude);
	    },
	
	    /**
	     * Returns object representation of canvas
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function (propertiesToInclude) {
	      return this._toObjectMethod('toObject', propertiesToInclude);
	    },
	
	    /**
	     * Returns dataless object representation of canvas
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toDatalessObject: function (propertiesToInclude) {
	      return this._toObjectMethod('toDatalessObject', propertiesToInclude);
	    },
	
	    /**
	     * @private
	     */
	    _toObjectMethod: function (methodName, propertiesToInclude) {
	
	      var data = {
	        objects: this._toObjects(methodName, propertiesToInclude)
	      };
	
	      extend(data, this.__serializeBgOverlay(propertiesToInclude));
	
	      fabric.util.populateWithProperties(this, data, propertiesToInclude);
	
	      return data;
	    },
	
	    /**
	     * @private
	     */
	    _toObjects: function(methodName, propertiesToInclude) {
	      return this.getObjects().filter(function(object) {
	        return !object.excludeFromExport;
	      }).map(function(instance) {
	        return this._toObject(instance, methodName, propertiesToInclude);
	      }, this);
	    },
	
	    /**
	     * @private
	     */
	    _toObject: function(instance, methodName, propertiesToInclude) {
	      var originalValue;
	
	      if (!this.includeDefaultValues) {
	        originalValue = instance.includeDefaultValues;
	        instance.includeDefaultValues = false;
	      }
	
	      var object = instance[methodName](propertiesToInclude);
	      if (!this.includeDefaultValues) {
	        instance.includeDefaultValues = originalValue;
	      }
	      return object;
	    },
	
	    /**
	     * @private
	     */
	    __serializeBgOverlay: function(propertiesToInclude) {
	      var data = {
	        background: (this.backgroundColor && this.backgroundColor.toObject)
	          ? this.backgroundColor.toObject(propertiesToInclude)
	          : this.backgroundColor
	      };
	
	      if (this.overlayColor) {
	        data.overlay = this.overlayColor.toObject
	          ? this.overlayColor.toObject(propertiesToInclude)
	          : this.overlayColor;
	      }
	      if (this.backgroundImage) {
	        data.backgroundImage = this.backgroundImage.toObject(propertiesToInclude);
	      }
	      if (this.overlayImage) {
	        data.overlayImage = this.overlayImage.toObject(propertiesToInclude);
	      }
	
	      return data;
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * When true, getSvgTransform() will apply the StaticCanvas.viewportTransform to the SVG transformation. When true,
	     * a zoomed canvas will then produce zoomed SVG output.
	     * @type Boolean
	     * @default
	     */
	    svgViewportTransformation: true,
	
	    /**
	     * Returns SVG representation of canvas
	     * @function
	     * @param {Object} [options] Options object for SVG output
	     * @param {Boolean} [options.suppressPreamble=false] If true xml tag is not included
	     * @param {Object} [options.viewBox] SVG viewbox object
	     * @param {Number} [options.viewBox.x] x-cooridnate of viewbox
	     * @param {Number} [options.viewBox.y] y-coordinate of viewbox
	     * @param {Number} [options.viewBox.width] Width of viewbox
	     * @param {Number} [options.viewBox.height] Height of viewbox
	     * @param {String} [options.encoding=UTF-8] Encoding of SVG output
	     * @param {String} [options.width] desired width of svg with or without units
	     * @param {String} [options.height] desired height of svg with or without units
	     * @param {Function} [reviver] Method for further parsing of svg elements, called after each fabric object converted into svg representation.
	     * @return {String} SVG string
	     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}
	     * @see {@link http://jsfiddle.net/fabricjs/jQ3ZZ/|jsFiddle demo}
	     * @example <caption>Normal SVG output</caption>
	     * var svg = canvas.toSVG();
	     * @example <caption>SVG output without preamble (without &lt;?xml ../>)</caption>
	     * var svg = canvas.toSVG({suppressPreamble: true});
	     * @example <caption>SVG output with viewBox attribute</caption>
	     * var svg = canvas.toSVG({
	     *   viewBox: {
	     *     x: 100,
	     *     y: 100,
	     *     width: 200,
	     *     height: 300
	     *   }
	     * });
	     * @example <caption>SVG output with different encoding (default: UTF-8)</caption>
	     * var svg = canvas.toSVG({encoding: 'ISO-8859-1'});
	     * @example <caption>Modify SVG output with reviver function</caption>
	     * var svg = canvas.toSVG(null, function(svg) {
	     *   return svg.replace('stroke-dasharray: ; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; ', '');
	     * });
	     */
	    toSVG: function(options, reviver) {
	      options || (options = { });
	
	      var markup = [];
	
	      this._setSVGPreamble(markup, options);
	      this._setSVGHeader(markup, options);
	
	      this._setSVGBgOverlayColor(markup, 'backgroundColor');
	      this._setSVGBgOverlayImage(markup, 'backgroundImage', reviver);
	
	      this._setSVGObjects(markup, reviver);
	
	      this._setSVGBgOverlayColor(markup, 'overlayColor');
	      this._setSVGBgOverlayImage(markup, 'overlayImage', reviver);
	
	      markup.push('</svg>');
	
	      return markup.join('');
	    },
	
	    /**
	     * @private
	     */
	    _setSVGPreamble: function(markup, options) {
	      if (options.suppressPreamble) {
	        return;
	      }
	      markup.push(
	        '<?xml version="1.0" encoding="', (options.encoding || 'UTF-8'), '" standalone="no" ?>\n',
	          '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ',
	            '"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n'
	      );
	    },
	
	    /**
	     * @private
	     */
	    _setSVGHeader: function(markup, options) {
	      var width = options.width || this.width,
	          height = options.height || this.height,
	          vpt, viewBox = 'viewBox="0 0 ' + this.width + ' ' + this.height + '" ',
	          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
	
	      if (options.viewBox) {
	        viewBox = 'viewBox="' +
	                options.viewBox.x + ' ' +
	                options.viewBox.y + ' ' +
	                options.viewBox.width + ' ' +
	                options.viewBox.height + '" ';
	      }
	      else {
	        if (this.svgViewportTransformation) {
	          vpt = this.viewportTransform;
	          viewBox = 'viewBox="' +
	                  toFixed(-vpt[4] / vpt[0], NUM_FRACTION_DIGITS) + ' ' +
	                  toFixed(-vpt[5] / vpt[3], NUM_FRACTION_DIGITS) + ' ' +
	                  toFixed(this.width / vpt[0], NUM_FRACTION_DIGITS) + ' ' +
	                  toFixed(this.height / vpt[3], NUM_FRACTION_DIGITS) + '" ';
	        }
	      }
	
	      markup.push(
	        '<svg ',
	          'xmlns="http://www.w3.org/2000/svg" ',
	          'xmlns:xlink="http://www.w3.org/1999/xlink" ',
	          'version="1.1" ',
	          'width="', width, '" ',
	          'height="', height, '" ',
	          (this.backgroundColor && !this.backgroundColor.toLive
	            ? 'style="background-color: ' + this.backgroundColor + '" '
	            : null),
	          viewBox,
	          'xml:space="preserve">\n',
	        '<desc>Created with Fabric.js ', fabric.version, '</desc>\n',
	        '<defs>',
	          fabric.createSVGFontFacesMarkup(this.getObjects()),
	          fabric.createSVGRefElementsMarkup(this),
	        '</defs>\n'
	      );
	    },
	
	    /**
	     * @private
	     */
	    _setSVGObjects: function(markup, reviver) {
	      var instance;
	      for (var i = 0, objects = this.getObjects(), len = objects.length; i < len; i++) {
	        instance = objects[i];
	        if (instance.excludeFromExport) {
	          continue;
	        }
	        this._setSVGObject(markup, instance, reviver);
	      }
	    },
	
	    /**
	     * push single object svg representation in the markup
	     * @private
	     */
	    _setSVGObject: function(markup, instance, reviver) {
	      markup.push(instance.toSVG(reviver));
	    },
	
	    /**
	     * @private
	     */
	    _setSVGBgOverlayImage: function(markup, property, reviver) {
	      if (this[property] && this[property].toSVG) {
	        markup.push(this[property].toSVG(reviver));
	      }
	    },
	
	    /**
	     * @private
	     */
	    _setSVGBgOverlayColor: function(markup, property) {
	      if (this[property] && this[property].source) {
	        markup.push(
	          '<rect x="', this[property].offsetX, '" y="', this[property].offsetY, '" ',
	            'width="',
	              (this[property].repeat === 'repeat-y' || this[property].repeat === 'no-repeat'
	                ? this[property].source.width
	                : this.width),
	            '" height="',
	              (this[property].repeat === 'repeat-x' || this[property].repeat === 'no-repeat'
	                ? this[property].source.height
	                : this.height),
	            '" fill="url(#' + property + 'Pattern)"',
	          '></rect>\n'
	        );
	      }
	      else if (this[property] && property === 'overlayColor') {
	        markup.push(
	          '<rect x="0" y="0" ',
	            'width="', this.width,
	            '" height="', this.height,
	            '" fill="', this[property], '"',
	          '></rect>\n'
	        );
	      }
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Moves an object or the objects of a multiple selection
	     * to the bottom of the stack of drawn objects
	     * @param {fabric.Object} object Object to send to back
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    sendToBack: function (object) {
	      if (!object) {
	        return this;
	      }
	      var activeGroup = this._activeGroup,
	          i, obj, objs;
	      if (object === activeGroup) {
	        objs = activeGroup._objects;
	        for (i = objs.length; i--;) {
	          obj = objs[i];
	          removeFromArray(this._objects, obj);
	          this._objects.unshift(obj);
	        }
	      }
	      else {
	        removeFromArray(this._objects, object);
	        this._objects.unshift(object);
	      }
	      return this.renderAll && this.renderAll();
	    },
	
	    /**
	     * Moves an object or the objects of a multiple selection
	     * to the top of the stack of drawn objects
	     * @param {fabric.Object} object Object to send
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    bringToFront: function (object) {
	      if (!object) {
	        return this;
	      }
	      var activeGroup = this._activeGroup,
	          i, obj, objs;
	      if (object === activeGroup) {
	        objs = activeGroup._objects;
	        for (i = 0; i < objs.length; i++) {
	          obj = objs[i];
	          removeFromArray(this._objects, obj);
	          this._objects.push(obj);
	        }
	      }
	      else {
	        removeFromArray(this._objects, object);
	        this._objects.push(object);
	      }
	      return this.renderAll && this.renderAll();
	    },
	
	    /**
	     * Moves an object or a selection down in stack of drawn objects
	     * @param {fabric.Object} object Object to send
	     * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    sendBackwards: function (object, intersecting) {
	      if (!object) {
	        return this;
	      }
	      var activeGroup = this._activeGroup,
	          i, obj, idx, newIdx, objs;
	
	      if (object === activeGroup) {
	        objs = activeGroup._objects;
	        for (i = 0; i < objs.length; i++) {
	          obj = objs[i];
	          idx = this._objects.indexOf(obj);
	          if (idx !== 0) {
	            newIdx = idx - 1;
	            removeFromArray(this._objects, obj);
	            this._objects.splice(newIdx, 0, obj);
	          }
	        }
	      }
	      else {
	        idx = this._objects.indexOf(object);
	        if (idx !== 0) {
	          // if object is not on the bottom of stack
	          newIdx = this._findNewLowerIndex(object, idx, intersecting);
	          removeFromArray(this._objects, object);
	          this._objects.splice(newIdx, 0, object);
	        }
	      }
	      this.renderAll && this.renderAll();
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _findNewLowerIndex: function(object, idx, intersecting) {
	      var newIdx;
	
	      if (intersecting) {
	        newIdx = idx;
	
	        // traverse down the stack looking for the nearest intersecting object
	        for (var i = idx - 1; i >= 0; --i) {
	
	          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||
	                               object.isContainedWithinObject(this._objects[i]) ||
	                               this._objects[i].isContainedWithinObject(object);
	
	          if (isIntersecting) {
	            newIdx = i;
	            break;
	          }
	        }
	      }
	      else {
	        newIdx = idx - 1;
	      }
	
	      return newIdx;
	    },
	
	    /**
	     * Moves an object or a selection up in stack of drawn objects
	     * @param {fabric.Object} object Object to send
	     * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    bringForward: function (object, intersecting) {
	      if (!object) {
	        return this;
	      }
	      var activeGroup = this._activeGroup,
	          i, obj, idx, newIdx, objs;
	
	      if (object === activeGroup) {
	        objs = activeGroup._objects;
	        for (i = objs.length; i--;) {
	          obj = objs[i];
	          idx = this._objects.indexOf(obj);
	          if (idx !== this._objects.length - 1) {
	            newIdx = idx + 1;
	            removeFromArray(this._objects, obj);
	            this._objects.splice(newIdx, 0, obj);
	          }
	        }
	      }
	      else {
	        idx = this._objects.indexOf(object);
	        if (idx !== this._objects.length - 1) {
	          // if object is not on top of stack (last item in an array)
	          newIdx = this._findNewUpperIndex(object, idx, intersecting);
	          removeFromArray(this._objects, object);
	          this._objects.splice(newIdx, 0, object);
	        }
	      }
	      this.renderAll && this.renderAll();
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _findNewUpperIndex: function(object, idx, intersecting) {
	      var newIdx;
	
	      if (intersecting) {
	        newIdx = idx;
	
	        // traverse up the stack looking for the nearest intersecting object
	        for (var i = idx + 1; i < this._objects.length; ++i) {
	
	          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||
	                               object.isContainedWithinObject(this._objects[i]) ||
	                               this._objects[i].isContainedWithinObject(object);
	
	          if (isIntersecting) {
	            newIdx = i;
	            break;
	          }
	        }
	      }
	      else {
	        newIdx = idx + 1;
	      }
	
	      return newIdx;
	    },
	
	    /**
	     * Moves an object to specified level in stack of drawn objects
	     * @param {fabric.Object} object Object to send
	     * @param {Number} index Position to move to
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    moveTo: function (object, index) {
	      removeFromArray(this._objects, object);
	      this._objects.splice(index, 0, object);
	      return this.renderAll && this.renderAll();
	    },
	
	    /**
	     * Clears a canvas element and removes all event listeners
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    dispose: function () {
	      this.clear();
	      return this;
	    },
	
	    /**
	     * Returns a string representation of an instance
	     * @return {String} string representation of an instance
	     */
	    toString: function () {
	      return '#<fabric.Canvas (' + this.complexity() + '): ' +
	               '{ objects: ' + this.getObjects().length + ' }>';
	    }
	  });
	
	  extend(fabric.StaticCanvas.prototype, fabric.Observable);
	  extend(fabric.StaticCanvas.prototype, fabric.Collection);
	  extend(fabric.StaticCanvas.prototype, fabric.DataURLExporter);
	
	  extend(fabric.StaticCanvas, /** @lends fabric.StaticCanvas */ {
	
	    /**
	     * @static
	     * @type String
	     * @default
	     */
	    EMPTY_JSON: '{"objects": [], "background": "white"}',
	
	    /**
	     * Provides a way to check support of some of the canvas methods
	     * (either those of HTMLCanvasElement itself, or rendering context)
	     *
	     * @param {String} methodName Method to check support for;
	     *                            Could be one of "getImageData", "toDataURL", "toDataURLWithQuality" or "setLineDash"
	     * @return {Boolean | null} `true` if method is supported (or at least exists),
	     *                          `null` if canvas element or context can not be initialized
	     */
	    supports: function (methodName) {
	      var el = fabric.util.createCanvasElement();
	
	      if (!el || !el.getContext) {
	        return null;
	      }
	
	      var ctx = el.getContext('2d');
	      if (!ctx) {
	        return null;
	      }
	
	      switch (methodName) {
	
	        case 'getImageData':
	          return typeof ctx.getImageData !== 'undefined';
	
	        case 'setLineDash':
	          return typeof ctx.setLineDash !== 'undefined';
	
	        case 'toDataURL':
	          return typeof el.toDataURL !== 'undefined';
	
	        case 'toDataURLWithQuality':
	          try {
	            el.toDataURL('image/jpeg', 0);
	            return true;
	          }
	          catch (e) { }
	          return false;
	
	        default:
	          return null;
	      }
	    }
	  });
	
	  /**
	   * Returns JSON representation of canvas
	   * @function
	   * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	   * @return {String} JSON string
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}
	   * @see {@link http://jsfiddle.net/fabricjs/pec86/|jsFiddle demo}
	   * @example <caption>JSON without additional properties</caption>
	   * var json = canvas.toJSON();
	   * @example <caption>JSON with additional properties included</caption>
	   * var json = canvas.toJSON(['lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY', 'lockUniScaling']);
	   * @example <caption>JSON without default values</caption>
	   * canvas.includeDefaultValues = false;
	   * var json = canvas.toJSON();
	   */
	  fabric.StaticCanvas.prototype.toJSON = fabric.StaticCanvas.prototype.toObject;
	
	})();
	
	
	/**
	 * BaseBrush class
	 * @class fabric.BaseBrush
	 * @see {@link http://fabricjs.com/freedrawing|Freedrawing demo}
	 */
	fabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype */ {
	
	  /**
	   * Color of a brush
	   * @type String
	   * @default
	   */
	  color: 'rgb(0, 0, 0)',
	
	  /**
	   * Width of a brush
	   * @type Number
	   * @default
	   */
	  width: 1,
	
	  /**
	   * Shadow object representing shadow of this shape.
	   * <b>Backwards incompatibility note:</b> This property replaces "shadowColor" (String), "shadowOffsetX" (Number),
	   * "shadowOffsetY" (Number) and "shadowBlur" (Number) since v1.2.12
	   * @type fabric.Shadow
	   * @default
	   */
	  shadow: null,
	
	  /**
	   * Line endings style of a brush (one of "butt", "round", "square")
	   * @type String
	   * @default
	   */
	  strokeLineCap: 'round',
	
	  /**
	   * Corner style of a brush (one of "bevil", "round", "miter")
	   * @type String
	   * @default
	   */
	  strokeLineJoin: 'round',
	
	  /**
	   * Stroke Dash Array.
	   * @type Array
	   * @default
	   */
	  strokeDashArray: null,
	
	  /**
	   * Sets shadow of an object
	   * @param {Object|String} [options] Options object or string (e.g. "2px 2px 10px rgba(0,0,0,0.2)")
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  setShadow: function(options) {
	    this.shadow = new fabric.Shadow(options);
	    return this;
	  },
	
	  /**
	   * Sets brush styles
	   * @private
	   */
	  _setBrushStyles: function() {
	    var ctx = this.canvas.contextTop;
	
	    ctx.strokeStyle = this.color;
	    ctx.lineWidth = this.width;
	    ctx.lineCap = this.strokeLineCap;
	    ctx.lineJoin = this.strokeLineJoin;
	    if (this.strokeDashArray && fabric.StaticCanvas.supports('setLineDash')) {
	      ctx.setLineDash(this.strokeDashArray);
	    }
	  },
	
	  /**
	   * Sets brush shadow styles
	   * @private
	   */
	  _setShadow: function() {
	    if (!this.shadow) {
	      return;
	    }
	
	    var ctx = this.canvas.contextTop;
	
	    ctx.shadowColor = this.shadow.color;
	    ctx.shadowBlur = this.shadow.blur;
	    ctx.shadowOffsetX = this.shadow.offsetX;
	    ctx.shadowOffsetY = this.shadow.offsetY;
	  },
	
	  /**
	   * Removes brush shadow styles
	   * @private
	   */
	  _resetShadow: function() {
	    var ctx = this.canvas.contextTop;
	
	    ctx.shadowColor = '';
	    ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
	  }
	});
	
	
	(function() {
	
	  /**
	   * PencilBrush class
	   * @class fabric.PencilBrush
	   * @extends fabric.BaseBrush
	   */
	  fabric.PencilBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.PencilBrush.prototype */ {
	
	    /**
	     * Constructor
	     * @param {fabric.Canvas} canvas
	     * @return {fabric.PencilBrush} Instance of a pencil brush
	     */
	    initialize: function(canvas) {
	      this.canvas = canvas;
	      this._points = [];
	    },
	
	    /**
	     * Inovoked on mouse down
	     * @param {Object} pointer
	     */
	    onMouseDown: function(pointer) {
	      this._prepareForDrawing(pointer);
	      // capture coordinates immediately
	      // this allows to draw dots (when movement never occurs)
	      this._captureDrawingPath(pointer);
	      this._render();
	    },
	
	    /**
	     * Inovoked on mouse move
	     * @param {Object} pointer
	     */
	    onMouseMove: function(pointer) {
	      this._captureDrawingPath(pointer);
	      // redraw curve
	      // clear top canvas
	      this.canvas.clearContext(this.canvas.contextTop);
	      this._render();
	    },
	
	    /**
	     * Invoked on mouse up
	     */
	    onMouseUp: function() {
	      this._finalizeAndAddPath();
	    },
	
	    /**
	     * @private
	     * @param {Object} pointer Actual mouse position related to the canvas.
	     */
	    _prepareForDrawing: function(pointer) {
	
	      var p = new fabric.Point(pointer.x, pointer.y);
	
	      this._reset();
	      this._addPoint(p);
	
	      this.canvas.contextTop.moveTo(p.x, p.y);
	    },
	
	    /**
	     * @private
	     * @param {fabric.Point} point Point to be added to points array
	     */
	    _addPoint: function(point) {
	      this._points.push(point);
	    },
	
	    /**
	     * Clear points array and set contextTop canvas style.
	     * @private
	     */
	    _reset: function() {
	      this._points.length = 0;
	
	      this._setBrushStyles();
	      this._setShadow();
	    },
	
	    /**
	     * @private
	     * @param {Object} pointer Actual mouse position related to the canvas.
	     */
	    _captureDrawingPath: function(pointer) {
	      var pointerPoint = new fabric.Point(pointer.x, pointer.y);
	      this._addPoint(pointerPoint);
	    },
	
	    /**
	     * Draw a smooth path on the topCanvas using quadraticCurveTo
	     * @private
	     */
	    _render: function() {
	      var ctx  = this.canvas.contextTop,
	          v = this.canvas.viewportTransform,
	          p1 = this._points[0],
	          p2 = this._points[1];
	
	      ctx.save();
	      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
	      ctx.beginPath();
	
	      //if we only have 2 points in the path and they are the same
	      //it means that the user only clicked the canvas without moving the mouse
	      //then we should be drawing a dot. A path isn't drawn between two identical dots
	      //that's why we set them apart a bit
	      if (this._points.length === 2 && p1.x === p2.x && p1.y === p2.y) {
	        p1.x -= 0.5;
	        p2.x += 0.5;
	      }
	      ctx.moveTo(p1.x, p1.y);
	
	      for (var i = 1, len = this._points.length; i < len; i++) {
	        // we pick the point between pi + 1 & pi + 2 as the
	        // end point and p1 as our control point.
	        var midPoint = p1.midPointFrom(p2);
	        ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);
	
	        p1 = this._points[i];
	        p2 = this._points[i + 1];
	      }
	      // Draw last line as a straight line while
	      // we wait for the next point to be able to calculate
	      // the bezier control point
	      ctx.lineTo(p1.x, p1.y);
	      ctx.stroke();
	      ctx.restore();
	    },
	
	    /**
	     * Converts points to SVG path
	     * @param {Array} points Array of points
	     * @return {String} SVG path
	     */
	    convertPointsToSVGPath: function(points) {
	      var path = [],
	          p1 = new fabric.Point(points[0].x, points[0].y),
	          p2 = new fabric.Point(points[1].x, points[1].y);
	
	      path.push('M ', points[0].x, ' ', points[0].y, ' ');
	      for (var i = 1, len = points.length; i < len; i++) {
	        var midPoint = p1.midPointFrom(p2);
	        // p1 is our bezier control point
	        // midpoint is our endpoint
	        // start point is p(i-1) value.
	        path.push('Q ', p1.x, ' ', p1.y, ' ', midPoint.x, ' ', midPoint.y, ' ');
	        p1 = new fabric.Point(points[i].x, points[i].y);
	        if ((i + 1) < points.length) {
	          p2 = new fabric.Point(points[i + 1].x, points[i + 1].y);
	        }
	      }
	      path.push('L ', p1.x, ' ', p1.y, ' ');
	      return path;
	    },
	
	    /**
	     * Creates fabric.Path object to add on canvas
	     * @param {String} pathData Path data
	     * @return {fabric.Path} Path to add on canvas
	     */
	    createPath: function(pathData) {
	      var path = new fabric.Path(pathData, {
	        fill: null,
	        stroke: this.color,
	        strokeWidth: this.width,
	        strokeLineCap: this.strokeLineCap,
	        strokeLineJoin: this.strokeLineJoin,
	        strokeDashArray: this.strokeDashArray,
	        originX: 'center',
	        originY: 'center'
	      });
	
	      if (this.shadow) {
	        this.shadow.affectStroke = true;
	        path.setShadow(this.shadow);
	      }
	
	      return path;
	    },
	
	    /**
	     * On mouseup after drawing the path on contextTop canvas
	     * we use the points captured to create an new fabric path object
	     * and add it to the fabric canvas.
	     */
	    _finalizeAndAddPath: function() {
	      var ctx = this.canvas.contextTop;
	      ctx.closePath();
	
	      var pathData = this.convertPointsToSVGPath(this._points).join('');
	      if (pathData === 'M 0 0 Q 0 0 0 0 L 0 0') {
	        // do not create 0 width/height paths, as they are
	        // rendered inconsistently across browsers
	        // Firefox 4, for example, renders a dot,
	        // whereas Chrome 10 renders nothing
	        this.canvas.renderAll();
	        return;
	      }
	
	      var path = this.createPath(pathData);
	
	      this.canvas.add(path);
	      path.setCoords();
	
	      this.canvas.clearContext(this.canvas.contextTop);
	      this._resetShadow();
	      this.canvas.renderAll();
	
	      // fire event 'path' created
	      this.canvas.fire('path:created', { path: path });
	    }
	  });
	})();
	
	
	/**
	 * CircleBrush class
	 * @class fabric.CircleBrush
	 */
	fabric.CircleBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.CircleBrush.prototype */ {
	
	  /**
	   * Width of a brush
	   * @type Number
	   * @default
	   */
	  width: 10,
	
	  /**
	   * Constructor
	   * @param {fabric.Canvas} canvas
	   * @return {fabric.CircleBrush} Instance of a circle brush
	   */
	  initialize: function(canvas) {
	    this.canvas = canvas;
	    this.points = [];
	  },
	
	  /**
	   * Invoked inside on mouse down and mouse move
	   * @param {Object} pointer
	   */
	  drawDot: function(pointer) {
	    var point = this.addPoint(pointer),
	        ctx = this.canvas.contextTop,
	        v = this.canvas.viewportTransform;
	    ctx.save();
	    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
	
	    ctx.fillStyle = point.fill;
	    ctx.beginPath();
	    ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);
	    ctx.closePath();
	    ctx.fill();
	
	    ctx.restore();
	  },
	
	  /**
	   * Invoked on mouse down
	   */
	  onMouseDown: function(pointer) {
	    this.points.length = 0;
	    this.canvas.clearContext(this.canvas.contextTop);
	    this._setShadow();
	    this.drawDot(pointer);
	  },
	
	  /**
	   * Invoked on mouse move
	   * @param {Object} pointer
	   */
	  onMouseMove: function(pointer) {
	    this.drawDot(pointer);
	  },
	
	  /**
	   * Invoked on mouse up
	   */
	  onMouseUp: function() {
	    var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;
	    this.canvas.renderOnAddRemove = false;
	
	    var circles = [];
	
	    for (var i = 0, len = this.points.length; i < len; i++) {
	      var point = this.points[i],
	          circle = new fabric.Circle({
	            radius: point.radius,
	            left: point.x,
	            top: point.y,
	            originX: 'center',
	            originY: 'center',
	            fill: point.fill
	          });
	
	      this.shadow && circle.setShadow(this.shadow);
	
	      circles.push(circle);
	    }
	    var group = new fabric.Group(circles, { originX: 'center', originY: 'center' });
	    group.canvas = this.canvas;
	
	    this.canvas.add(group);
	    this.canvas.fire('path:created', { path: group });
	
	    this.canvas.clearContext(this.canvas.contextTop);
	    this._resetShadow();
	    this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
	    this.canvas.renderAll();
	  },
	
	  /**
	   * @param {Object} pointer
	   * @return {fabric.Point} Just added pointer point
	   */
	  addPoint: function(pointer) {
	    var pointerPoint = new fabric.Point(pointer.x, pointer.y),
	
	        circleRadius = fabric.util.getRandomInt(
	                        Math.max(0, this.width - 20), this.width + 20) / 2,
	
	        circleColor = new fabric.Color(this.color)
	                        .setAlpha(fabric.util.getRandomInt(0, 100) / 100)
	                        .toRgba();
	
	    pointerPoint.radius = circleRadius;
	    pointerPoint.fill = circleColor;
	
	    this.points.push(pointerPoint);
	
	    return pointerPoint;
	  }
	});
	
	
	/**
	 * SprayBrush class
	 * @class fabric.SprayBrush
	 */
	fabric.SprayBrush = fabric.util.createClass( fabric.BaseBrush, /** @lends fabric.SprayBrush.prototype */ {
	
	  /**
	   * Width of a spray
	   * @type Number
	   * @default
	   */
	  width:              10,
	
	  /**
	   * Density of a spray (number of dots per chunk)
	   * @type Number
	   * @default
	   */
	  density:            20,
	
	  /**
	   * Width of spray dots
	   * @type Number
	   * @default
	   */
	  dotWidth:           1,
	
	  /**
	   * Width variance of spray dots
	   * @type Number
	   * @default
	   */
	  dotWidthVariance:   1,
	
	  /**
	   * Whether opacity of a dot should be random
	   * @type Boolean
	   * @default
	   */
	  randomOpacity:        false,
	
	  /**
	   * Whether overlapping dots (rectangles) should be removed (for performance reasons)
	   * @type Boolean
	   * @default
	   */
	  optimizeOverlapping:  true,
	
	  /**
	   * Constructor
	   * @param {fabric.Canvas} canvas
	   * @return {fabric.SprayBrush} Instance of a spray brush
	   */
	  initialize: function(canvas) {
	    this.canvas = canvas;
	    this.sprayChunks = [];
	  },
	
	  /**
	   * Invoked on mouse down
	   * @param {Object} pointer
	   */
	  onMouseDown: function(pointer) {
	    this.sprayChunks.length = 0;
	    this.canvas.clearContext(this.canvas.contextTop);
	    this._setShadow();
	
	    this.addSprayChunk(pointer);
	    this.render();
	  },
	
	  /**
	   * Invoked on mouse move
	   * @param {Object} pointer
	   */
	  onMouseMove: function(pointer) {
	    this.addSprayChunk(pointer);
	    this.render();
	  },
	
	  /**
	   * Invoked on mouse up
	   */
	  onMouseUp: function() {
	    var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;
	    this.canvas.renderOnAddRemove = false;
	
	    var rects = [];
	
	    for (var i = 0, ilen = this.sprayChunks.length; i < ilen; i++) {
	      var sprayChunk = this.sprayChunks[i];
	
	      for (var j = 0, jlen = sprayChunk.length; j < jlen; j++) {
	
	        var rect = new fabric.Rect({
	          width: sprayChunk[j].width,
	          height: sprayChunk[j].width,
	          left: sprayChunk[j].x + 1,
	          top: sprayChunk[j].y + 1,
	          originX: 'center',
	          originY: 'center',
	          fill: this.color
	        });
	
	        this.shadow && rect.setShadow(this.shadow);
	        rects.push(rect);
	      }
	    }
	
	    if (this.optimizeOverlapping) {
	      rects = this._getOptimizedRects(rects);
	    }
	
	    var group = new fabric.Group(rects, { originX: 'center', originY: 'center' });
	    group.canvas = this.canvas;
	
	    this.canvas.add(group);
	    this.canvas.fire('path:created', { path: group });
	
	    this.canvas.clearContext(this.canvas.contextTop);
	    this._resetShadow();
	    this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
	    this.canvas.renderAll();
	  },
	
	  /**
	   * @private
	   * @param {Array} rects
	   */
	  _getOptimizedRects: function(rects) {
	
	    // avoid creating duplicate rects at the same coordinates
	    var uniqueRects = { }, key;
	
	    for (var i = 0, len = rects.length; i < len; i++) {
	      key = rects[i].left + '' + rects[i].top;
	      if (!uniqueRects[key]) {
	        uniqueRects[key] = rects[i];
	      }
	    }
	    var uniqueRectsArray = [];
	    for (key in uniqueRects) {
	      uniqueRectsArray.push(uniqueRects[key]);
	    }
	
	    return uniqueRectsArray;
	  },
	
	  /**
	   * Renders brush
	   */
	  render: function() {
	    var ctx = this.canvas.contextTop;
	    ctx.fillStyle = this.color;
	
	    var v = this.canvas.viewportTransform;
	    ctx.save();
	    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
	
	    for (var i = 0, len = this.sprayChunkPoints.length; i < len; i++) {
	      var point = this.sprayChunkPoints[i];
	      if (typeof point.opacity !== 'undefined') {
	        ctx.globalAlpha = point.opacity;
	      }
	      ctx.fillRect(point.x, point.y, point.width, point.width);
	    }
	    ctx.restore();
	  },
	
	  /**
	   * @param {Object} pointer
	   */
	  addSprayChunk: function(pointer) {
	    this.sprayChunkPoints = [];
	
	    var x, y, width, radius = this.width / 2;
	
	    for (var i = 0; i < this.density; i++) {
	
	      x = fabric.util.getRandomInt(pointer.x - radius, pointer.x + radius);
	      y = fabric.util.getRandomInt(pointer.y - radius, pointer.y + radius);
	
	      if (this.dotWidthVariance) {
	        width = fabric.util.getRandomInt(
	          // bottom clamp width to 1
	          Math.max(1, this.dotWidth - this.dotWidthVariance),
	          this.dotWidth + this.dotWidthVariance);
	      }
	      else {
	        width = this.dotWidth;
	      }
	
	      var point = new fabric.Point(x, y);
	      point.width = width;
	
	      if (this.randomOpacity) {
	        point.opacity = fabric.util.getRandomInt(0, 100) / 100;
	      }
	
	      this.sprayChunkPoints.push(point);
	    }
	
	    this.sprayChunks.push(this.sprayChunkPoints);
	  }
	});
	
	
	/**
	 * PatternBrush class
	 * @class fabric.PatternBrush
	 * @extends fabric.BaseBrush
	 */
	fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fabric.PatternBrush.prototype */ {
	
	  getPatternSrc: function() {
	
	    var dotWidth = 20,
	        dotDistance = 5,
	        patternCanvas = fabric.document.createElement('canvas'),
	        patternCtx = patternCanvas.getContext('2d');
	
	    patternCanvas.width = patternCanvas.height = dotWidth + dotDistance;
	
	    patternCtx.fillStyle = this.color;
	    patternCtx.beginPath();
	    patternCtx.arc(dotWidth / 2, dotWidth / 2, dotWidth / 2, 0, Math.PI * 2, false);
	    patternCtx.closePath();
	    patternCtx.fill();
	
	    return patternCanvas;
	  },
	
	  getPatternSrcFunction: function() {
	    return String(this.getPatternSrc).replace('this.color', '"' + this.color + '"');
	  },
	
	  /**
	   * Creates "pattern" instance property
	   */
	  getPattern: function() {
	    return this.canvas.contextTop.createPattern(this.source || this.getPatternSrc(), 'repeat');
	  },
	
	  /**
	   * Sets brush styles
	   */
	  _setBrushStyles: function() {
	    this.callSuper('_setBrushStyles');
	    this.canvas.contextTop.strokeStyle = this.getPattern();
	  },
	
	  /**
	   * Creates path
	   */
	  createPath: function(pathData) {
	    var path = this.callSuper('createPath', pathData),
	        topLeft = path._getLeftTopCoords().scalarAdd(path.strokeWidth / 2);
	
	    path.stroke = new fabric.Pattern({
	      source: this.source || this.getPatternSrcFunction(),
	      offsetX: -topLeft.x,
	      offsetY: -topLeft.y
	    });
	    return path;
	  }
	});
	
	
	(function() {
	
	  var getPointer = fabric.util.getPointer,
	      degreesToRadians = fabric.util.degreesToRadians,
	      radiansToDegrees = fabric.util.radiansToDegrees,
	      atan2 = Math.atan2,
	      abs = Math.abs,
	      supportLineDash = fabric.StaticCanvas.supports('setLineDash'),
	
	      STROKE_OFFSET = 0.5;
	
	  /**
	   * Canvas class
	   * @class fabric.Canvas
	   * @extends fabric.StaticCanvas
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#canvas}
	   * @see {@link fabric.Canvas#initialize} for constructor definition
	   *
	   * @fires object:added
	   * @fires object:modified
	   * @fires object:rotating
	   * @fires object:scaling
	   * @fires object:moving
	   * @fires object:selected
	   *
	   * @fires before:selection:cleared
	   * @fires selection:cleared
	   * @fires selection:created
	   *
	   * @fires path:created
	   * @fires mouse:down
	   * @fires mouse:move
	   * @fires mouse:up
	   * @fires mouse:over
	   * @fires mouse:out
	   *
	   */
	  fabric.Canvas = fabric.util.createClass(fabric.StaticCanvas, /** @lends fabric.Canvas.prototype */ {
	
	    /**
	     * Constructor
	     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
	     * @param {Object} [options] Options object
	     * @return {Object} thisArg
	     */
	    initialize: function(el, options) {
	      options || (options = { });
	
	      this._initStatic(el, options);
	      this._initInteractive();
	      this._createCacheCanvas();
	    },
	
	    /**
	     * When true, objects can be transformed by one side (unproportionally)
	     * @type Boolean
	     * @default
	     */
	    uniScaleTransform:      false,
	
	    /**
	     * Indicates which key enable unproportional scaling
	     * values: altKey, shiftKey, ctrlKey
	     * @since 1.6.2
	     * @type String
	     * @default
	     */
	    uniScaleKey:           'shiftKey',
	
	    /**
	     * When true, objects use center point as the origin of scale transformation.
	     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
	     * @since 1.3.4
	     * @type Boolean
	     * @default
	     */
	    centeredScaling:        false,
	
	    /**
	     * When true, objects use center point as the origin of rotate transformation.
	     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
	     * @since 1.3.4
	     * @type Boolean
	     * @default
	     */
	    centeredRotation:       false,
	
	    /**
	     * Indicates which key enable centered Transfrom
	     * values: altKey, shiftKey, ctrlKey
	     * @since 1.6.2
	     * @type String
	     * @default
	     */
	    centeredKey:           'altKey',
	
	    /**
	     * Indicates which key enable alternate action on corner
	     * values: altKey, shiftKey, ctrlKey
	     * @since 1.6.2
	     * @type String
	     * @default
	     */
	    altActionKey:           'shiftKey',
	
	    /**
	     * Indicates that canvas is interactive. This property should not be changed.
	     * @type Boolean
	     * @default
	     */
	    interactive:            true,
	
	    /**
	     * Indicates whether group selection should be enabled
	     * @type Boolean
	     * @default
	     */
	    selection:              true,
	
	    /**
	     * Indicates which key enable multiple click selection
	     * values: altKey, shiftKey, ctrlKey, cmdKey
	     * @since 1.6.2
	     * @type String
	     * @default
	     */
	    selectionKey:           'shiftKey',
	
	    /**
	     * Indicates which key enable alternative selection
	     * in case of target overlapping with active object
	     * values: altKey, shiftKey, ctrlKey, cmdKey
	     * @since 1.6.5
	     * @type null|String
	     * @default
	     */
	    altSelectionKey:           null,
	
	    /**
	     * Color of selection
	     * @type String
	     * @default
	     */
	    selectionColor:         'rgba(100, 100, 255, 0.3)', // blue
	
	    /**
	     * Default dash array pattern
	     * If not empty the selection border is dashed
	     * @type Array
	     */
	    selectionDashArray:     [],
	
	    /**
	     * Color of the border of selection (usually slightly darker than color of selection itself)
	     * @type String
	     * @default
	     */
	    selectionBorderColor:   'rgba(255, 255, 255, 0.3)',
	
	    /**
	     * Width of a line used in object/group selection
	     * @type Number
	     * @default
	     */
	    selectionLineWidth:     1,
	
	    /**
	     * Default cursor value used when hovering over an object on canvas
	     * @type String
	     * @default
	     */
	    hoverCursor:            'move',
	
	    /**
	     * Default cursor value used when moving an object on canvas
	     * @type String
	     * @default
	     */
	    moveCursor:             'move',
	
	    /**
	     * Default cursor value used for the entire canvas
	     * @type String
	     * @default
	     */
	    defaultCursor:          'default',
	
	    /**
	     * Cursor value used during free drawing
	     * @type String
	     * @default
	     */
	    freeDrawingCursor:      'crosshair',
	
	    /**
	     * Cursor value used for rotation point
	     * @type String
	     * @default
	     */
	    rotationCursor:         'crosshair',
	
	    /**
	     * Default element class that's given to wrapper (div) element of canvas
	     * @type String
	     * @default
	     */
	    containerClass:         'canvas-container',
	
	    /**
	     * When true, object detection happens on per-pixel basis rather than on per-bounding-box
	     * @type Boolean
	     * @default
	     */
	    perPixelTargetFind:     false,
	
	    /**
	     * Number of pixels around target pixel to tolerate (consider active) during object detection
	     * @type Number
	     * @default
	     */
	    targetFindTolerance:    0,
	
	    /**
	     * When true, target detection is skipped when hovering over canvas. This can be used to improve performance.
	     * @type Boolean
	     * @default
	     */
	    skipTargetFind:         false,
	
	    /**
	     * When true, mouse events on canvas (mousedown/mousemove/mouseup) result in free drawing.
	     * After mousedown, mousemove creates a shape,
	     * and then mouseup finalizes it and adds an instance of `fabric.Path` onto canvas.
	     * @tutorial {@link http://fabricjs.com/fabric-intro-part-4#free_drawing}
	     * @type Boolean
	     * @default
	     */
	    isDrawingMode:          false,
	
	    /**
	     * Indicates whether objects should remain in current stack position when selected.
	     * When false objects are brought to top and rendered as part of the selection group
	     * @type Boolean
	     * @default
	     */
	    preserveObjectStacking: false,
	
	    /**
	     * Indicates if the right click on canvas can output the context menu or not
	     * @type Boolean
	     * @since 1.6.5
	     * @default
	     */
	    stopContextMenu: false,
	
	    /**
	     * Indicates if the canvas can fire right click events
	     * @type Boolean
	     * @since 1.6.5
	     * @default
	     */
	    fireRightClick: false,
	
	    /**
	     * @private
	     */
	    _initInteractive: function() {
	      this._currentTransform = null;
	      this._groupSelector = null;
	      this._initWrapperElement();
	      this._createUpperCanvas();
	      this._initEventListeners();
	
	      this._initRetinaScaling();
	
	      this.freeDrawingBrush = fabric.PencilBrush && new fabric.PencilBrush(this);
	
	      this.calcOffset();
	    },
	
	    /**
	     * Divides objects in two groups, one to render immediately
	     * and one to render as activeGroup.
	     * @return {Array} objects to render immediately and pushes the other in the activeGroup.
	     */
	    _chooseObjectsToRender: function() {
	      var activeGroup = this.getActiveGroup(),
	          activeObject = this.getActiveObject(),
	          object, objsToRender = [], activeGroupObjects = [];
	
	      if ((activeGroup || activeObject) && !this.preserveObjectStacking) {
	        for (var i = 0, length = this._objects.length; i < length; i++) {
	          object = this._objects[i];
	          if ((!activeGroup || !activeGroup.contains(object)) && object !== activeObject) {
	            objsToRender.push(object);
	          }
	          else {
	            activeGroupObjects.push(object);
	          }
	        }
	        if (activeGroup) {
	          activeGroup._set('_objects', activeGroupObjects);
	          objsToRender.push(activeGroup);
	        }
	        activeObject && objsToRender.push(activeObject);
	      }
	      else {
	        objsToRender = this._objects;
	      }
	      return objsToRender;
	    },
	
	    /**
	     * Renders both the top canvas and the secondary container canvas.
	     * @return {fabric.Canvas} instance
	     * @chainable
	     */
	    renderAll: function () {
	      if (this.selection && !this._groupSelector && !this.isDrawingMode) {
	        this.clearContext(this.contextTop);
	      }
	      var canvasToDrawOn = this.contextContainer;
	      this.renderCanvas(canvasToDrawOn, this._chooseObjectsToRender());
	      return this;
	    },
	
	    /**
	     * Method to render only the top canvas.
	     * Also used to render the group selection box.
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    renderTop: function () {
	      var ctx = this.contextTop;
	      this.clearContext(ctx);
	
	      // we render the top context - last object
	      if (this.selection && this._groupSelector) {
	        this._drawSelection(ctx);
	      }
	
	      this.fire('after:render');
	
	      return this;
	    },
	
	    /**
	     * Resets the current transform to its original values and chooses the type of resizing based on the event
	     * @private
	     */
	    _resetCurrentTransform: function() {
	      var t = this._currentTransform;
	
	      t.target.set({
	        scaleX: t.original.scaleX,
	        scaleY: t.original.scaleY,
	        skewX: t.original.skewX,
	        skewY: t.original.skewY,
	        left: t.original.left,
	        top: t.original.top
	      });
	
	      if (this._shouldCenterTransform(t.target)) {
	        if (t.action === 'rotate') {
	          this._setOriginToCenter(t.target);
	        }
	        else {
	          if (t.originX !== 'center') {
	            if (t.originX === 'right') {
	              t.mouseXSign = -1;
	            }
	            else {
	              t.mouseXSign = 1;
	            }
	          }
	          if (t.originY !== 'center') {
	            if (t.originY === 'bottom') {
	              t.mouseYSign = -1;
	            }
	            else {
	              t.mouseYSign = 1;
	            }
	          }
	
	          t.originX = 'center';
	          t.originY = 'center';
	        }
	      }
	      else {
	        t.originX = t.original.originX;
	        t.originY = t.original.originY;
	      }
	    },
	
	    /**
	     * Checks if point is contained within an area of given object
	     * @param {Event} e Event object
	     * @param {fabric.Object} target Object to test against
	     * @param {Object} [point] x,y object of point coordinates we want to check.
	     * @return {Boolean} true if point is contained within an area of given object
	     */
	    containsPoint: function (e, target, point) {
	      var ignoreZoom = true,
	          pointer = point || this.getPointer(e, ignoreZoom),
	          xy;
	
	      if (target.group && target.group === this.getActiveGroup()) {
	        xy = this._normalizePointer(target.group, pointer);
	      }
	      else {
	        xy = { x: pointer.x, y: pointer.y };
	      }
	      // http://www.geog.ubc.ca/courses/klink/gis.notes/ncgia/u32.html
	      // http://idav.ucdavis.edu/~okreylos/TAship/Spring2000/PointInPolygon.html
	      return (target.containsPoint(xy) || target._findTargetCorner(pointer));
	    },
	
	    /**
	     * @private
	     */
	    _normalizePointer: function (object, pointer) {
	      var m = object.calcTransformMatrix(),
	          invertedM = fabric.util.invertTransform(m),
	          vpt = this.viewportTransform,
	          vptPointer = this.restorePointerVpt(pointer),
	          p = fabric.util.transformPoint(vptPointer, invertedM);
	      return fabric.util.transformPoint(p, vpt);
	    },
	
	    /**
	     * Returns true if object is transparent at a certain location
	     * @param {fabric.Object} target Object to check
	     * @param {Number} x Left coordinate
	     * @param {Number} y Top coordinate
	     * @return {Boolean}
	     */
	    isTargetTransparent: function (target, x, y) {
	      var hasBorders = target.hasBorders,
	          transparentCorners = target.transparentCorners,
	          ctx = this.contextCache,
	          originalColor = target.selectionBackgroundColor;
	
	      target.hasBorders = target.transparentCorners = false;
	      target.selectionBackgroundColor = '';
	
	      ctx.save();
	      ctx.transform.apply(ctx, this.viewportTransform);
	      target.render(ctx);
	      ctx.restore();
	
	      target.active && target._renderControls(ctx);
	
	      target.hasBorders = hasBorders;
	      target.transparentCorners = transparentCorners;
	      target.selectionBackgroundColor = originalColor;
	
	      var isTransparent = fabric.util.isTransparent(
	        ctx, x, y, this.targetFindTolerance);
	
	      this.clearContext(ctx);
	
	      return isTransparent;
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object
	     * @param {fabric.Object} target
	     */
	    _shouldClearSelection: function (e, target) {
	      var activeGroup = this.getActiveGroup(),
	          activeObject = this.getActiveObject();
	
	      return (
	        !target
	        ||
	        (target &&
	          activeGroup &&
	          !activeGroup.contains(target) &&
	          activeGroup !== target &&
	          !e[this.selectionKey])
	        ||
	        (target && !target.evented)
	        ||
	        (target &&
	          !target.selectable &&
	          activeObject &&
	          activeObject !== target)
	      );
	    },
	
	    /**
	     * @private
	     * @param {fabric.Object} target
	     */
	    _shouldCenterTransform: function (target) {
	      if (!target) {
	        return;
	      }
	
	      var t = this._currentTransform,
	          centerTransform;
	
	      if (t.action === 'scale' || t.action === 'scaleX' || t.action === 'scaleY') {
	        centerTransform = this.centeredScaling || target.centeredScaling;
	      }
	      else if (t.action === 'rotate') {
	        centerTransform = this.centeredRotation || target.centeredRotation;
	      }
	
	      return centerTransform ? !t.altKey : t.altKey;
	    },
	
	    /**
	     * @private
	     */
	    _getOriginFromCorner: function(target, corner) {
	      var origin = {
	        x: target.originX,
	        y: target.originY
	      };
	
	      if (corner === 'ml' || corner === 'tl' || corner === 'bl') {
	        origin.x = 'right';
	      }
	      else if (corner === 'mr' || corner === 'tr' || corner === 'br') {
	        origin.x = 'left';
	      }
	
	      if (corner === 'tl' || corner === 'mt' || corner === 'tr') {
	        origin.y = 'bottom';
	      }
	      else if (corner === 'bl' || corner === 'mb' || corner === 'br') {
	        origin.y = 'top';
	      }
	
	      return origin;
	    },
	
	    /**
	     * @private
	     */
	    _getActionFromCorner: function(target, corner, e) {
	      if (!corner) {
	        return 'drag';
	      }
	
	      switch (corner) {
	        case 'mtr':
	          return 'rotate';
	        case 'ml':
	        case 'mr':
	          return e[this.altActionKey] ? 'skewY' : 'scaleX';
	        case 'mt':
	        case 'mb':
	          return e[this.altActionKey] ? 'skewX' : 'scaleY';
	        default:
	          return 'scale';
	      }
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object
	     * @param {fabric.Object} target
	     */
	    _setupCurrentTransform: function (e, target) {
	      if (!target) {
	        return;
	      }
	
	      var pointer = this.getPointer(e),
	          corner = target._findTargetCorner(this.getPointer(e, true)),
	          action = this._getActionFromCorner(target, corner, e),
	          origin = this._getOriginFromCorner(target, corner);
	
	      this._currentTransform = {
	        target: target,
	        action: action,
	        corner: corner,
	        scaleX: target.scaleX,
	        scaleY: target.scaleY,
	        skewX: target.skewX,
	        skewY: target.skewY,
	        offsetX: pointer.x - target.left,
	        offsetY: pointer.y - target.top,
	        originX: origin.x,
	        originY: origin.y,
	        ex: pointer.x,
	        ey: pointer.y,
	        lastX: pointer.x,
	        lastY: pointer.y,
	        left: target.left,
	        top: target.top,
	        theta: degreesToRadians(target.angle),
	        width: target.width * target.scaleX,
	        mouseXSign: 1,
	        mouseYSign: 1,
	        shiftKey: e.shiftKey,
	        altKey: e[this.centeredKey]
	      };
	
	      this._currentTransform.original = {
	        left: target.left,
	        top: target.top,
	        scaleX: target.scaleX,
	        scaleY: target.scaleY,
	        skewX: target.skewX,
	        skewY: target.skewY,
	        originX: origin.x,
	        originY: origin.y
	      };
	
	      this._resetCurrentTransform();
	    },
	
	    /**
	     * Translates object by "setting" its left/top
	     * @private
	     * @param {Number} x pointer's x coordinate
	     * @param {Number} y pointer's y coordinate
	     * @return {Boolean} true if the translation occurred
	     */
	    _translateObject: function (x, y) {
	      var transform = this._currentTransform,
	          target = transform.target,
	          newLeft = x - transform.offsetX,
	          newTop = y - transform.offsetY,
	          moveX = !target.get('lockMovementX') && target.left !== newLeft,
	          moveY = !target.get('lockMovementY') && target.top !== newTop;
	
	      moveX && target.set('left', newLeft);
	      moveY && target.set('top', newTop);
	      return moveX || moveY;
	    },
	
	    /**
	     * Check if we are increasing a positive skew or lower it,
	     * checking mouse direction and pressed corner.
	     * @private
	     */
	    _changeSkewTransformOrigin: function(mouseMove, t, by) {
	      var property = 'originX', origins = { 0: 'center' },
	          skew = t.target.skewX, originA = 'left', originB = 'right',
	          corner = t.corner === 'mt' || t.corner === 'ml' ? 1 : -1,
	          flipSign = 1;
	
	      mouseMove = mouseMove > 0 ? 1 : -1;
	      if (by === 'y') {
	        skew = t.target.skewY;
	        originA = 'top';
	        originB = 'bottom';
	        property = 'originY';
	      }
	      origins[-1] = originA;
	      origins[1] = originB;
	
	      t.target.flipX && (flipSign *= -1);
	      t.target.flipY && (flipSign *= -1);
	
	      if (skew === 0) {
	        t.skewSign = -corner * mouseMove * flipSign;
	        t[property] = origins[-mouseMove];
	      }
	      else {
	        skew = skew > 0 ? 1 : -1;
	        t.skewSign = skew;
	        t[property] = origins[skew * corner * flipSign];
	      }
	    },
	
	    /**
	     * Skew object by mouse events
	     * @private
	     * @param {Number} x pointer's x coordinate
	     * @param {Number} y pointer's y coordinate
	     * @param {String} by Either 'x' or 'y'
	     * @return {Boolean} true if the skewing occurred
	     */
	    _skewObject: function (x, y, by) {
	      var t = this._currentTransform,
	          target = t.target, skewed = false,
	          lockSkewingX = target.get('lockSkewingX'),
	          lockSkewingY = target.get('lockSkewingY');
	
	      if ((lockSkewingX && by === 'x') || (lockSkewingY && by === 'y')) {
	        return false;
	      }
	
	      // Get the constraint point
	      var center = target.getCenterPoint(),
	          actualMouseByCenter = target.toLocalPoint(new fabric.Point(x, y), 'center', 'center')[by],
	          lastMouseByCenter = target.toLocalPoint(new fabric.Point(t.lastX, t.lastY), 'center', 'center')[by],
	          actualMouseByOrigin, constraintPosition, dim = target._getTransformedDimensions();
	
	      this._changeSkewTransformOrigin(actualMouseByCenter - lastMouseByCenter, t, by);
	      actualMouseByOrigin = target.toLocalPoint(new fabric.Point(x, y), t.originX, t.originY)[by];
	      constraintPosition = target.translateToOriginPoint(center, t.originX, t.originY);
	      // Actually skew the object
	      skewed = this._setObjectSkew(actualMouseByOrigin, t, by, dim);
	      t.lastX = x;
	      t.lastY = y;
	      // Make sure the constraints apply
	      target.setPositionByOrigin(constraintPosition, t.originX, t.originY);
	      return skewed;
	    },
	
	    /**
	     * Set object skew
	     * @private
	     * @return {Boolean} true if the skewing occurred
	     */
	    _setObjectSkew: function(localMouse, transform, by, _dim) {
	      var target = transform.target, newValue, skewed = false,
	          skewSign = transform.skewSign, newDim, dimNoSkew,
	          otherBy, _otherBy, _by, newDimMouse, skewX, skewY;
	
	      if (by === 'x') {
	        otherBy = 'y';
	        _otherBy = 'Y';
	        _by = 'X';
	        skewX = 0;
	        skewY = target.skewY;
	      }
	      else {
	        otherBy = 'x';
	        _otherBy = 'X';
	        _by = 'Y';
	        skewX = target.skewX;
	        skewY = 0;
	      }
	
	      dimNoSkew = target._getTransformedDimensions(skewX, skewY);
	      newDimMouse = 2 * Math.abs(localMouse) - dimNoSkew[by];
	      if (newDimMouse <= 2) {
	        newValue = 0;
	      }
	      else {
	        newValue = skewSign * Math.atan((newDimMouse / target['scale' + _by]) /
	                                        (dimNoSkew[otherBy] / target['scale' + _otherBy]));
	        newValue = fabric.util.radiansToDegrees(newValue);
	      }
	      skewed = target['skew' + _by] !== newValue;
	      target.set('skew' + _by, newValue);
	      if (target['skew' + _otherBy] !== 0) {
	        newDim = target._getTransformedDimensions();
	        newValue = (_dim[otherBy] / newDim[otherBy]) * target['scale' + _otherBy];
	        target.set('scale' + _otherBy, newValue);
	      }
	      return skewed;
	    },
	
	    /**
	     * Scales object by invoking its scaleX/scaleY methods
	     * @private
	     * @param {Number} x pointer's x coordinate
	     * @param {Number} y pointer's y coordinate
	     * @param {String} by Either 'x' or 'y' - specifies dimension constraint by which to scale an object.
	     *                    When not provided, an object is scaled by both dimensions equally
	     * @return {Boolean} true if the scaling occurred
	     */
	    _scaleObject: function (x, y, by) {
	      var t = this._currentTransform,
	          target = t.target,
	          lockScalingX = target.get('lockScalingX'),
	          lockScalingY = target.get('lockScalingY'),
	          lockScalingFlip = target.get('lockScalingFlip');
	
	      if (lockScalingX && lockScalingY) {
	        return false;
	      }
	
	      // Get the constraint point
	      var constraintPosition = target.translateToOriginPoint(target.getCenterPoint(), t.originX, t.originY),
	          localMouse = target.toLocalPoint(new fabric.Point(x, y), t.originX, t.originY),
	          dim = target._getTransformedDimensions(), scaled = false;
	
	      this._setLocalMouse(localMouse, t);
	
	      // Actually scale the object
	      scaled = this._setObjectScale(localMouse, t, lockScalingX, lockScalingY, by, lockScalingFlip, dim);
	
	      // Make sure the constraints apply
	      target.setPositionByOrigin(constraintPosition, t.originX, t.originY);
	      return scaled;
	    },
	
	    /**
	     * @private
	     * @return {Boolean} true if the scaling occurred
	     */
	    _setObjectScale: function(localMouse, transform, lockScalingX, lockScalingY, by, lockScalingFlip, _dim) {
	      var target = transform.target, forbidScalingX = false, forbidScalingY = false, scaled = false,
	          changeX, changeY, scaleX, scaleY;
	
	      scaleX = localMouse.x * target.scaleX / _dim.x;
	      scaleY = localMouse.y * target.scaleY / _dim.y;
	      changeX = target.scaleX !== scaleX;
	      changeY = target.scaleY !== scaleY;
	
	      if (lockScalingFlip && scaleX <= 0 && scaleX < target.scaleX) {
	        forbidScalingX = true;
	      }
	
	      if (lockScalingFlip && scaleY <= 0 && scaleY < target.scaleY) {
	        forbidScalingY = true;
	      }
	
	      if (by === 'equally' && !lockScalingX && !lockScalingY) {
	        forbidScalingX || forbidScalingY || (scaled = this._scaleObjectEqually(localMouse, target, transform, _dim));
	      }
	      else if (!by) {
	        forbidScalingX || lockScalingX || (target.set('scaleX', scaleX) && (scaled = scaled || changeX));
	        forbidScalingY || lockScalingY || (target.set('scaleY', scaleY) && (scaled = scaled || changeY));
	      }
	      else if (by === 'x' && !target.get('lockUniScaling')) {
	        forbidScalingX || lockScalingX || (target.set('scaleX', scaleX) && (scaled = scaled || changeX));
	      }
	      else if (by === 'y' && !target.get('lockUniScaling')) {
	        forbidScalingY || lockScalingY || (target.set('scaleY', scaleY) && (scaled = scaled || changeY));
	      }
	      transform.newScaleX = scaleX;
	      transform.newScaleY = scaleY;
	      forbidScalingX || forbidScalingY || this._flipObject(transform, by);
	      return scaled;
	    },
	
	    /**
	     * @private
	     * @return {Boolean} true if the scaling occurred
	     */
	    _scaleObjectEqually: function(localMouse, target, transform, _dim) {
	
	      var dist = localMouse.y + localMouse.x,
	          lastDist = _dim.y * transform.original.scaleY / target.scaleY +
	                     _dim.x * transform.original.scaleX / target.scaleX,
	          scaled;
	
	      // We use transform.scaleX/Y instead of target.scaleX/Y
	      // because the object may have a min scale and we'll loose the proportions
	      transform.newScaleX = transform.original.scaleX * dist / lastDist;
	      transform.newScaleY = transform.original.scaleY * dist / lastDist;
	      scaled = transform.newScaleX !== target.scaleX || transform.newScaleY !== target.scaleY;
	      target.set('scaleX', transform.newScaleX);
	      target.set('scaleY', transform.newScaleY);
	      return scaled;
	    },
	
	    /**
	     * @private
	     */
	    _flipObject: function(transform, by) {
	      if (transform.newScaleX < 0 && by !== 'y') {
	        if (transform.originX === 'left') {
	          transform.originX = 'right';
	        }
	        else if (transform.originX === 'right') {
	          transform.originX = 'left';
	        }
	      }
	
	      if (transform.newScaleY < 0 && by !== 'x') {
	        if (transform.originY === 'top') {
	          transform.originY = 'bottom';
	        }
	        else if (transform.originY === 'bottom') {
	          transform.originY = 'top';
	        }
	      }
	    },
	
	    /**
	     * @private
	     */
	    _setLocalMouse: function(localMouse, t) {
	      var target = t.target;
	
	      if (t.originX === 'right') {
	        localMouse.x *= -1;
	      }
	      else if (t.originX === 'center') {
	        localMouse.x *= t.mouseXSign * 2;
	        if (localMouse.x < 0) {
	          t.mouseXSign = -t.mouseXSign;
	        }
	      }
	
	      if (t.originY === 'bottom') {
	        localMouse.y *= -1;
	      }
	      else if (t.originY === 'center') {
	        localMouse.y *= t.mouseYSign * 2;
	        if (localMouse.y < 0) {
	          t.mouseYSign = -t.mouseYSign;
	        }
	      }
	
	      // adjust the mouse coordinates when dealing with padding
	      if (abs(localMouse.x) > target.padding) {
	        if (localMouse.x < 0) {
	          localMouse.x += target.padding;
	        }
	        else {
	          localMouse.x -= target.padding;
	        }
	      }
	      else { // mouse is within the padding, set to 0
	        localMouse.x = 0;
	      }
	
	      if (abs(localMouse.y) > target.padding) {
	        if (localMouse.y < 0) {
	          localMouse.y += target.padding;
	        }
	        else {
	          localMouse.y -= target.padding;
	        }
	      }
	      else {
	        localMouse.y = 0;
	      }
	    },
	
	    /**
	     * Rotates object by invoking its rotate method
	     * @private
	     * @param {Number} x pointer's x coordinate
	     * @param {Number} y pointer's y coordinate
	     * @return {Boolean} true if the rotation occurred
	     */
	    _rotateObject: function (x, y) {
	
	      var t = this._currentTransform;
	
	      if (t.target.get('lockRotation')) {
	        return false;
	      }
	
	      var lastAngle = atan2(t.ey - t.top, t.ex - t.left),
	          curAngle = atan2(y - t.top, x - t.left),
	          angle = radiansToDegrees(curAngle - lastAngle + t.theta);
	
	      // normalize angle to positive value
	      if (angle < 0) {
	        angle = 360 + angle;
	      }
	
	      t.target.angle = angle % 360;
	      return true;
	    },
	
	    /**
	     * Set the cursor type of the canvas element
	     * @param {String} value Cursor type of the canvas element.
	     * @see http://www.w3.org/TR/css3-ui/#cursor
	     */
	    setCursor: function (value) {
	      this.upperCanvasEl.style.cursor = value;
	    },
	
	    /**
	     * @param {fabric.Object} target to reset transform
	     * @private
	     */
	    _resetObjectTransform: function (target) {
	      target.scaleX = 1;
	      target.scaleY = 1;
	      target.skewX = 0;
	      target.skewY = 0;
	      target.setAngle(0);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx to draw the selection on
	     */
	    _drawSelection: function (ctx) {
	      var groupSelector = this._groupSelector,
	          left = groupSelector.left,
	          top = groupSelector.top,
	          aleft = abs(left),
	          atop = abs(top);
	
	      if (this.selectionColor) {
	        ctx.fillStyle = this.selectionColor;
	
	        ctx.fillRect(
	          groupSelector.ex - ((left > 0) ? 0 : -left),
	          groupSelector.ey - ((top > 0) ? 0 : -top),
	          aleft,
	          atop
	        );
	      }
	
	      if (!this.selectionLineWidth || !this.selectionBorderColor) {
	        return;
	      }
	      ctx.lineWidth = this.selectionLineWidth;
	      ctx.strokeStyle = this.selectionBorderColor;
	
	      // selection border
	      if (this.selectionDashArray.length > 1 && !supportLineDash) {
	
	        var px = groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0 : aleft),
	            py = groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0 : atop);
	
	        ctx.beginPath();
	
	        fabric.util.drawDashedLine(ctx, px, py, px + aleft, py, this.selectionDashArray);
	        fabric.util.drawDashedLine(ctx, px, py + atop - 1, px + aleft, py + atop - 1, this.selectionDashArray);
	        fabric.util.drawDashedLine(ctx, px, py, px, py + atop, this.selectionDashArray);
	        fabric.util.drawDashedLine(ctx, px + aleft - 1, py, px + aleft - 1, py + atop, this.selectionDashArray);
	
	        ctx.closePath();
	        ctx.stroke();
	      }
	      else {
	        fabric.Object.prototype._setLineDash.call(this, ctx, this.selectionDashArray);
	        ctx.strokeRect(
	          groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0 : aleft),
	          groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0 : atop),
	          aleft,
	          atop
	        );
	      }
	    },
	
	    /**
	     * Method that determines what object we are clicking on
	     * @param {Event} e mouse event
	     * @param {Boolean} skipGroup when true, activeGroup is skipped and only objects are traversed through
	     */
	    findTarget: function (e, skipGroup) {
	      if (this.skipTargetFind) {
	        return;
	      }
	
	      var ignoreZoom = true,
	          pointer = this.getPointer(e, ignoreZoom),
	          activeGroup = this.getActiveGroup(),
	          activeObject = this.getActiveObject(),
	          activeTarget;
	
	      // first check current group (if one exists)
	      // active group does not check sub targets like normal groups.
	      // if active group just exits.
	      if (activeGroup && !skipGroup && this._checkTarget(pointer, activeGroup)) {
	        this._fireOverOutEvents(activeGroup, e);
	        return activeGroup;
	      }
	      // if we hit the corner of an activeObject, let's return that.
	      if (activeObject && activeObject._findTargetCorner(pointer)) {
	        this._fireOverOutEvents(activeObject, e);
	        return activeObject;
	      }
	      if (activeObject && this._checkTarget(pointer, activeObject)) {
	        if (!this.preserveObjectStacking) {
	          this._fireOverOutEvents(activeObject, e);
	          return activeObject;
	        }
	        else {
	          activeTarget = activeObject;
	        }
	      }
	
	      this.targets = [];
	
	      var target = this._searchPossibleTargets(this._objects, pointer);
	      if (e[this.altSelectionKey] && target && activeTarget && target !== activeTarget) {
	        target = activeTarget;
	      }
	      this._fireOverOutEvents(target, e);
	      return target;
	    },
	
	    /**
	     * @private
	     */
	    _fireOverOutEvents: function(target, e) {
	      if (target) {
	        if (this._hoveredTarget !== target) {
	          if (this._hoveredTarget) {
	            this.fire('mouse:out', { target: this._hoveredTarget, e: e });
	            this._hoveredTarget.fire('mouseout');
	          }
	          this.fire('mouse:over', { target: target, e: e });
	          target.fire('mouseover');
	          this._hoveredTarget = target;
	        }
	      }
	      else if (this._hoveredTarget) {
	        this.fire('mouse:out', { target: this._hoveredTarget, e: e });
	        this._hoveredTarget.fire('mouseout');
	        this._hoveredTarget = null;
	      }
	    },
	
	    /**
	     * @private
	     */
	    _checkTarget: function(pointer, obj) {
	      if (obj &&
	          obj.visible &&
	          obj.evented &&
	          this.containsPoint(null, obj, pointer)){
	        if ((this.perPixelTargetFind || obj.perPixelTargetFind) && !obj.isEditing) {
	          var isTransparent = this.isTargetTransparent(obj, pointer.x, pointer.y);
	          if (!isTransparent) {
	            return true;
	          }
	        }
	        else {
	          return true;
	        }
	      }
	    },
	
	    /**
	     * @private
	     */
	    _searchPossibleTargets: function(objects, pointer) {
	
	      // Cache all targets where their bounding box contains point.
	      var target, i = objects.length, normalizedPointer, subTarget;
	      // Do not check for currently grouped objects, since we check the parent group itself.
	      // untill we call this function specifically to search inside the activeGroup
	      while (i--) {
	        if (this._checkTarget(pointer, objects[i])) {
	          target = objects[i];
	          if (target.type === 'group' && target.subTargetCheck) {
	            normalizedPointer = this._normalizePointer(target, pointer);
	            subTarget = this._searchPossibleTargets(target._objects, normalizedPointer);
	            subTarget && this.targets.push(subTarget);
	          }
	          break;
	        }
	      }
	      return target;
	    },
	
	    /**
	     * Returns pointer coordinates without the effect of the viewport
	     * @param {Object} pointer with "x" and "y" number values
	     * @return {Object} object with "x" and "y" number values
	     */
	    restorePointerVpt: function(pointer) {
	      return fabric.util.transformPoint(
	        pointer,
	        fabric.util.invertTransform(this.viewportTransform)
	      );
	    },
	
	    /**
	     * Returns pointer coordinates relative to canvas.
	     * @param {Event} e
	     * @param {Boolean} ignoreZoom
	     * @return {Object} object with "x" and "y" number values
	     */
	    getPointer: function (e, ignoreZoom, upperCanvasEl) {
	      if (!upperCanvasEl) {
	        upperCanvasEl = this.upperCanvasEl;
	      }
	      var pointer = getPointer(e),
	          bounds = upperCanvasEl.getBoundingClientRect(),
	          boundsWidth = bounds.width || 0,
	          boundsHeight = bounds.height || 0,
	          cssScale;
	
	      if (!boundsWidth || !boundsHeight ) {
	        if ('top' in bounds && 'bottom' in bounds) {
	          boundsHeight = Math.abs( bounds.top - bounds.bottom );
	        }
	        if ('right' in bounds && 'left' in bounds) {
	          boundsWidth = Math.abs( bounds.right - bounds.left );
	        }
	      }
	
	      this.calcOffset();
	
	      pointer.x = pointer.x - this._offset.left;
	      pointer.y = pointer.y - this._offset.top;
	      if (!ignoreZoom) {
	        pointer = this.restorePointerVpt(pointer);
	      }
	
	      if (boundsWidth === 0 || boundsHeight === 0) {
	        // If bounds are not available (i.e. not visible), do not apply scale.
	        cssScale = { width: 1, height: 1 };
	      }
	      else {
	        cssScale = {
	          width: upperCanvasEl.width / boundsWidth,
	          height: upperCanvasEl.height / boundsHeight
	        };
	      }
	
	      return {
	        x: pointer.x * cssScale.width,
	        y: pointer.y * cssScale.height
	      };
	    },
	
	    /**
	     * @private
	     * @throws {CANVAS_INIT_ERROR} If canvas can not be initialized
	     */
	    _createUpperCanvas: function () {
	      var lowerCanvasClass = this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/, '');
	
	      this.upperCanvasEl = this._createCanvasElement();
	      fabric.util.addClass(this.upperCanvasEl, 'upper-canvas ' + lowerCanvasClass);
	
	      this.wrapperEl.appendChild(this.upperCanvasEl);
	
	      this._copyCanvasStyle(this.lowerCanvasEl, this.upperCanvasEl);
	      this._applyCanvasStyle(this.upperCanvasEl);
	      this.contextTop = this.upperCanvasEl.getContext('2d');
	    },
	
	    /**
	     * @private
	     */
	    _createCacheCanvas: function () {
	      this.cacheCanvasEl = this._createCanvasElement();
	      this.cacheCanvasEl.setAttribute('width', this.width);
	      this.cacheCanvasEl.setAttribute('height', this.height);
	      this.contextCache = this.cacheCanvasEl.getContext('2d');
	    },
	
	    /**
	     * @private
	     */
	    _initWrapperElement: function () {
	      this.wrapperEl = fabric.util.wrapElement(this.lowerCanvasEl, 'div', {
	        'class': this.containerClass
	      });
	      fabric.util.setStyle(this.wrapperEl, {
	        width: this.getWidth() + 'px',
	        height: this.getHeight() + 'px',
	        position: 'relative'
	      });
	      fabric.util.makeElementUnselectable(this.wrapperEl);
	    },
	
	    /**
	     * @private
	     * @param {HTMLElement} element canvas element to apply styles on
	     */
	    _applyCanvasStyle: function (element) {
	      var width = this.getWidth() || element.width,
	          height = this.getHeight() || element.height;
	
	      fabric.util.setStyle(element, {
	        position: 'absolute',
	        width: width + 'px',
	        height: height + 'px',
	        left: 0,
	        top: 0
	      });
	      element.width = width;
	      element.height = height;
	      fabric.util.makeElementUnselectable(element);
	    },
	
	    /**
	     * Copys the the entire inline style from one element (fromEl) to another (toEl)
	     * @private
	     * @param {Element} fromEl Element style is copied from
	     * @param {Element} toEl Element copied style is applied to
	     */
	    _copyCanvasStyle: function (fromEl, toEl) {
	      toEl.style.cssText = fromEl.style.cssText;
	    },
	
	    /**
	     * Returns context of canvas where object selection is drawn
	     * @return {CanvasRenderingContext2D}
	     */
	    getSelectionContext: function() {
	      return this.contextTop;
	    },
	
	    /**
	     * Returns &lt;canvas> element on which object selection is drawn
	     * @return {HTMLCanvasElement}
	     */
	    getSelectionElement: function () {
	      return this.upperCanvasEl;
	    },
	
	    /**
	     * @private
	     * @param {Object} object
	     */
	    _setActiveObject: function(object) {
	      if (this._activeObject) {
	        this._activeObject.set('active', false);
	      }
	      this._activeObject = object;
	      object.set('active', true);
	    },
	
	    /**
	     * Sets given object as the only active object on canvas
	     * @param {fabric.Object} object Object to set as an active one
	     * @param {Event} [e] Event (passed along when firing "object:selected")
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    setActiveObject: function (object, e) {
	      this._setActiveObject(object);
	      this.renderAll();
	      this.fire('object:selected', { target: object, e: e });
	      object.fire('selected', { e: e });
	      return this;
	    },
	
	    /**
	     * Returns currently active object
	     * @return {fabric.Object} active object
	     */
	    getActiveObject: function () {
	      return this._activeObject;
	    },
	
	    /**
	     * @private
	     * @param {fabric.Object} obj Object that was removed
	     */
	    _onObjectRemoved: function(obj) {
	      // removing active object should fire "selection:cleared" events
	      if (this.getActiveObject() === obj) {
	        this.fire('before:selection:cleared', { target: obj });
	        this._discardActiveObject();
	        this.fire('selection:cleared', { target: obj });
	        obj.fire('deselected');
	      }
	      this.callSuper('_onObjectRemoved', obj);
	    },
	
	    /**
	     * @private
	     */
	    _discardActiveObject: function() {
	      if (this._activeObject) {
	        this._activeObject.set('active', false);
	      }
	      this._activeObject = null;
	    },
	
	    /**
	     * Discards currently active object and fire events
	     * @param {event} e
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    discardActiveObject: function (e) {
	      var activeObject = this._activeObject;
	      this.fire('before:selection:cleared', { target: activeObject, e: e });
	      this._discardActiveObject();
	      this.fire('selection:cleared', { e: e });
	      activeObject && activeObject.fire('deselected', { e: e });
	      return this;
	    },
	
	    /**
	     * @private
	     * @param {fabric.Group} group
	     */
	    _setActiveGroup: function(group) {
	      this._activeGroup = group;
	      if (group) {
	        group.set('active', true);
	      }
	    },
	
	    /**
	     * Sets active group to a specified one
	     * @param {fabric.Group} group Group to set as a current one
	     * @param {Event} e Event object
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    setActiveGroup: function (group, e) {
	      this._setActiveGroup(group);
	      if (group) {
	        this.fire('object:selected', { target: group, e: e });
	        group.fire('selected', { e: e });
	      }
	      return this;
	    },
	
	    /**
	     * Returns currently active group
	     * @return {fabric.Group} Current group
	     */
	    getActiveGroup: function () {
	      return this._activeGroup;
	    },
	
	    /**
	     * @private
	     */
	    _discardActiveGroup: function() {
	      var g = this.getActiveGroup();
	      if (g) {
	        g.destroy();
	      }
	      this.setActiveGroup(null);
	    },
	
	    /**
	     * Discards currently active group and fire events
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    discardActiveGroup: function (e) {
	      var g = this.getActiveGroup();
	      this.fire('before:selection:cleared', { e: e, target: g });
	      this._discardActiveGroup();
	      this.fire('selection:cleared', { e: e });
	      return this;
	    },
	
	    /**
	     * Deactivates all objects on canvas, removing any active group or object
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    deactivateAll: function () {
	      var allObjects = this.getObjects(),
	          i = 0,
	          len = allObjects.length;
	      for ( ; i < len; i++) {
	        allObjects[i].set('active', false);
	      }
	      this._discardActiveGroup();
	      this._discardActiveObject();
	      return this;
	    },
	
	    /**
	     * Deactivates all objects and dispatches appropriate events
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    deactivateAllWithDispatch: function (e) {
	      var activeGroup = this.getActiveGroup(),
	          activeObject = this.getActiveObject();
	      if (activeObject || activeGroup) {
	        this.fire('before:selection:cleared', { target: activeObject || activeGroup, e: e });
	      }
	      this.deactivateAll();
	      if (activeObject || activeGroup) {
	        this.fire('selection:cleared', { e: e, target: activeObject });
	        activeObject && activeObject.fire('deselected');
	      }
	      return this;
	    },
	
	    /**
	     * Clears a canvas element and removes all event listeners
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    dispose: function () {
	      this.callSuper('dispose');
	      var wrapper = this.wrapperEl;
	      this.removeListeners();
	      wrapper.removeChild(this.upperCanvasEl);
	      wrapper.removeChild(this.lowerCanvasEl);
	      delete this.upperCanvasEl;
	      if (wrapper.parentNode) {
	        wrapper.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl);
	      }
	      delete this.wrapperEl;
	      return this;
	    },
	
	    /**
	     * Clears all contexts (background, main, top) of an instance
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    clear: function () {
	      this.discardActiveGroup();
	      this.discardActiveObject();
	      this.clearContext(this.contextTop);
	      return this.callSuper('clear');
	    },
	
	    /**
	     * Draws objects' controls (borders/controls)
	     * @param {CanvasRenderingContext2D} ctx Context to render controls on
	     */
	    drawControls: function(ctx) {
	      var activeGroup = this.getActiveGroup();
	
	      if (activeGroup) {
	        activeGroup._renderControls(ctx);
	      }
	      else {
	        this._drawObjectsControls(ctx);
	      }
	    },
	
	    /**
	     * @private
	     */
	    _drawObjectsControls: function(ctx) {
	      for (var i = 0, len = this._objects.length; i < len; ++i) {
	        if (!this._objects[i] || !this._objects[i].active) {
	          continue;
	        }
	        this._objects[i]._renderControls(ctx);
	      }
	    },
	
	    /**
	     * @private
	     */
	    _toObject: function(instance, methodName, propertiesToInclude) {
	      //If the object is part of the current selection group, it should
	      //be transformed appropriately
	      //i.e. it should be serialised as it would appear if the selection group
	      //were to be destroyed.
	      var originalProperties = this._realizeGroupTransformOnObject(instance),
	          object = this.callSuper('_toObject', instance, methodName, propertiesToInclude);
	      //Undo the damage we did by changing all of its properties
	      this._unwindGroupTransformOnObject(instance, originalProperties);
	      return object;
	    },
	
	    /**
	     * Realises an object's group transformation on it
	     * @private
	     * @param {fabric.Object} [instance] the object to transform (gets mutated)
	     * @returns the original values of instance which were changed
	     */
	    _realizeGroupTransformOnObject: function(instance) {
	      var layoutProps = ['angle', 'flipX', 'flipY', 'height', 'left', 'scaleX', 'scaleY', 'top', 'width'];
	      if (instance.group && instance.group === this.getActiveGroup()) {
	        //Copy all the positionally relevant properties across now
	        var originalValues = {};
	        layoutProps.forEach(function(prop) {
	          originalValues[prop] = instance[prop];
	        });
	        this.getActiveGroup().realizeTransform(instance);
	        return originalValues;
	      }
	      else {
	        return null;
	      }
	    },
	
	    /**
	     * Restores the changed properties of instance
	     * @private
	     * @param {fabric.Object} [instance] the object to un-transform (gets mutated)
	     * @param {Object} [originalValues] the original values of instance, as returned by _realizeGroupTransformOnObject
	     */
	    _unwindGroupTransformOnObject: function(instance, originalValues) {
	      if (originalValues) {
	        instance.set(originalValues);
	      }
	    },
	
	    /**
	     * @private
	     */
	    _setSVGObject: function(markup, instance, reviver) {
	      var originalProperties;
	      //If the object is in a selection group, simulate what would happen to that
	      //object when the group is deselected
	      originalProperties = this._realizeGroupTransformOnObject(instance);
	      this.callSuper('_setSVGObject', markup, instance, reviver);
	      this._unwindGroupTransformOnObject(instance, originalProperties);
	    },
	  });
	
	  // copying static properties manually to work around Opera's bug,
	  // where "prototype" property is enumerable and overrides existing prototype
	  for (var prop in fabric.StaticCanvas) {
	    if (prop !== 'prototype') {
	      fabric.Canvas[prop] = fabric.StaticCanvas[prop];
	    }
	  }
	
	  if (fabric.isTouchSupported) {
	    /** @ignore */
	    fabric.Canvas.prototype._setCursorFromEvent = function() { };
	  }
	
	  /**
	   * @ignore
	   * @class fabric.Element
	   * @alias fabric.Canvas
	   * @deprecated Use {@link fabric.Canvas} instead.
	   * @constructor
	   */
	  fabric.Element = fabric.Canvas;
	})();
	
	
	(function() {
	
	  var cursorOffset = {
	        mt: 0, // n
	        tr: 1, // ne
	        mr: 2, // e
	        br: 3, // se
	        mb: 4, // s
	        bl: 5, // sw
	        ml: 6, // w
	        tl: 7 // nw
	      },
	      addListener = fabric.util.addListener,
	      removeListener = fabric.util.removeListener;
	
	  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {
	
	    /**
	     * Map of cursor style values for each of the object controls
	     * @private
	     */
	    cursorMap: [
	      'n-resize',
	      'ne-resize',
	      'e-resize',
	      'se-resize',
	      's-resize',
	      'sw-resize',
	      'w-resize',
	      'nw-resize'
	    ],
	
	    /**
	     * Adds mouse listeners to canvas
	     * @private
	     */
	    _initEventListeners: function () {
	
	      this._bindEvents();
	
	      addListener(fabric.window, 'resize', this._onResize);
	
	      // mouse events
	      addListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);
	      addListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);
	      addListener(this.upperCanvasEl, 'mouseout', this._onMouseOut);
	      addListener(this.upperCanvasEl, 'wheel', this._onMouseWheel);
	      addListener(this.upperCanvasEl, 'contextmenu', this._onContextMenu);
	
	      // touch events
	      addListener(this.upperCanvasEl, 'touchstart', this._onMouseDown);
	      addListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);
	
	      if (typeof eventjs !== 'undefined' && 'add' in eventjs) {
	        eventjs.add(this.upperCanvasEl, 'gesture', this._onGesture);
	        eventjs.add(this.upperCanvasEl, 'drag', this._onDrag);
	        eventjs.add(this.upperCanvasEl, 'orientation', this._onOrientationChange);
	        eventjs.add(this.upperCanvasEl, 'shake', this._onShake);
	        eventjs.add(this.upperCanvasEl, 'longpress', this._onLongPress);
	      }
	    },
	
	    /**
	     * @private
	     */
	    _bindEvents: function() {
	      this._onMouseDown = this._onMouseDown.bind(this);
	      this._onMouseMove = this._onMouseMove.bind(this);
	      this._onMouseUp = this._onMouseUp.bind(this);
	      this._onResize = this._onResize.bind(this);
	      this._onGesture = this._onGesture.bind(this);
	      this._onDrag = this._onDrag.bind(this);
	      this._onShake = this._onShake.bind(this);
	      this._onLongPress = this._onLongPress.bind(this);
	      this._onOrientationChange = this._onOrientationChange.bind(this);
	      this._onMouseWheel = this._onMouseWheel.bind(this);
	      this._onMouseOut = this._onMouseOut.bind(this);
	      this._onContextMenu = this._onContextMenu.bind(this);
	    },
	
	    /**
	     * Removes all event listeners
	     */
	    removeListeners: function() {
	      removeListener(fabric.window, 'resize', this._onResize);
	
	      removeListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);
	      removeListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);
	      removeListener(this.upperCanvasEl, 'mouseout', this._onMouseOut);
	      removeListener(this.upperCanvasEl, 'wheel', this._onMouseWheel);
	      removeListener(this.upperCanvasEl, 'contextmenu', this._onContextMenu);
	
	      removeListener(this.upperCanvasEl, 'touchstart', this._onMouseDown);
	      removeListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);
	
	      if (typeof eventjs !== 'undefined' && 'remove' in eventjs) {
	        eventjs.remove(this.upperCanvasEl, 'gesture', this._onGesture);
	        eventjs.remove(this.upperCanvasEl, 'drag', this._onDrag);
	        eventjs.remove(this.upperCanvasEl, 'orientation', this._onOrientationChange);
	        eventjs.remove(this.upperCanvasEl, 'shake', this._onShake);
	        eventjs.remove(this.upperCanvasEl, 'longpress', this._onLongPress);
	      }
	    },
	
	    /**
	     * @private
	     * @param {Event} [e] Event object fired on Event.js gesture
	     * @param {Event} [self] Inner Event object
	     */
	    _onGesture: function(e, self) {
	      this.__onTransformGesture && this.__onTransformGesture(e, self);
	    },
	
	    /**
	     * @private
	     * @param {Event} [e] Event object fired on Event.js drag
	     * @param {Event} [self] Inner Event object
	     */
	    _onDrag: function(e, self) {
	      this.__onDrag && this.__onDrag(e, self);
	    },
	
	    /**
	     * @private
	     * @param {Event} [e] Event object fired on wheel event
	     */
	    _onMouseWheel: function(e) {
	      this.__onMouseWheel(e);
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object fired on mousedown
	     */
	    _onMouseOut: function(e) {
	      var target = this._hoveredTarget;
	      this.fire('mouse:out', { target: target, e: e });
	      this._hoveredTarget = null;
	      target && target.fire('mouseout', { e: e });
	    },
	
	    /**
	     * @private
	     * @param {Event} [e] Event object fired on Event.js orientation change
	     * @param {Event} [self] Inner Event object
	     */
	    _onOrientationChange: function(e, self) {
	      this.__onOrientationChange && this.__onOrientationChange(e, self);
	    },
	
	    /**
	     * @private
	     * @param {Event} [e] Event object fired on Event.js shake
	     * @param {Event} [self] Inner Event object
	     */
	    _onShake: function(e, self) {
	      this.__onShake && this.__onShake(e, self);
	    },
	
	    /**
	     * @private
	     * @param {Event} [e] Event object fired on Event.js shake
	     * @param {Event} [self] Inner Event object
	     */
	    _onLongPress: function(e, self) {
	      this.__onLongPress && this.__onLongPress(e, self);
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object fired on mousedown
	     */
	    _onContextMenu: function (e) {
	      if (this.stopContextMenu) {
	        e.stopPropagation()
	        e.preventDefault();
	      }
	      return false;
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object fired on mousedown
	     */
	    _onMouseDown: function (e) {
	      this.__onMouseDown(e);
	
	      addListener(fabric.document, 'touchend', this._onMouseUp);
	      addListener(fabric.document, 'touchmove', this._onMouseMove);
	
	      removeListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);
	      removeListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);
	
	      if (e.type === 'touchstart') {
	        // Unbind mousedown to prevent double triggers from touch devices
	        removeListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);
	      }
	      else {
	        addListener(fabric.document, 'mouseup', this._onMouseUp);
	        addListener(fabric.document, 'mousemove', this._onMouseMove);
	      }
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object fired on mouseup
	     */
	    _onMouseUp: function (e) {
	      this.__onMouseUp(e);
	
	      removeListener(fabric.document, 'mouseup', this._onMouseUp);
	      removeListener(fabric.document, 'touchend', this._onMouseUp);
	
	      removeListener(fabric.document, 'mousemove', this._onMouseMove);
	      removeListener(fabric.document, 'touchmove', this._onMouseMove);
	
	      addListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);
	      addListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);
	
	      if (e.type === 'touchend') {
	        // Wait 400ms before rebinding mousedown to prevent double triggers
	        // from touch devices
	        var _this = this;
	        setTimeout(function() {
	          addListener(_this.upperCanvasEl, 'mousedown', _this._onMouseDown);
	        }, 400);
	      }
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object fired on mousemove
	     */
	    _onMouseMove: function (e) {
	      !this.allowTouchScrolling && e.preventDefault && e.preventDefault();
	      this.__onMouseMove(e);
	    },
	
	    /**
	     * @private
	     */
	    _onResize: function () {
	      this.calcOffset();
	    },
	
	    /**
	     * Decides whether the canvas should be redrawn in mouseup and mousedown events.
	     * @private
	     * @param {Object} target
	     * @param {Object} pointer
	     */
	    _shouldRender: function(target, pointer) {
	      var activeObject = this.getActiveGroup() || this.getActiveObject();
	
	      return !!(
	        (target && (
	          target.isMoving ||
	          target !== activeObject))
	        ||
	        (!target && !!activeObject)
	        ||
	        (!target && !activeObject && !this._groupSelector)
	        ||
	        (pointer &&
	          this._previousPointer &&
	          this.selection && (
	          pointer.x !== this._previousPointer.x ||
	          pointer.y !== this._previousPointer.y))
	      );
	    },
	
	    /**
	     * Method that defines the actions when mouse is released on canvas.
	     * The method resets the currentTransform parameters, store the image corner
	     * position in the image object and render the canvas on top.
	     * @private
	     * @param {Event} e Event object fired on mouseup
	     */
	    __onMouseUp: function (e) {
	      var target, searchTarget = true, transform = this._currentTransform,
	          groupSelector = this._groupSelector,
	          isClick = (!groupSelector || (groupSelector.left === 0 && groupSelector.top === 0));
	
	      if (this.isDrawingMode && this._isCurrentlyDrawing) {
	        this._onMouseUpInDrawingMode(e);
	        return;
	      }
	
	      if (transform) {
	        this._finalizeCurrentTransform();
	        searchTarget = !transform.actionPerformed;
	      }
	
	      target = searchTarget ? this.findTarget(e, true) : transform.target;
	
	      var shouldRender = this._shouldRender(target, this.getPointer(e));
	
	      if (target || !isClick) {
	        this._maybeGroupObjects(e);
	      }
	      else {
	        // those are done by default on mouse up
	        // by _maybeGroupObjects, we are skipping it in case of no target find
	        this._groupSelector = null;
	        this._currentTransform = null;
	      }
	
	      if (target) {
	        target.isMoving = false;
	      }
	
	      this._handleCursorAndEvent(e, target, 'up');
	      target && (target.__corner = 0);
	      shouldRender && this.renderAll();
	    },
	
	    /**
	     * set cursor for mouse up and handle mouseUp event
	     * @param {Event} e event from mouse
	     * @param {fabric.Object} target receiving event
	     * @param {String} eventType event to fire (up, down or move)
	     */
	    _handleCursorAndEvent: function(e, target, eventType) {
	      this._setCursorFromEvent(e, target);
	      this._handleEvent(e, eventType, target ? target : null);
	    },
	
	    /**
	     * Handle event firing for target and subtargets
	     * @param {Event} e event from mouse
	     * @param {String} eventType event to fire (up, down or move)
	     * @param {fabric.Object} targetObj receiving event
	     */
	    _handleEvent: function(e, eventType, targetObj) {
	      var target = typeof targetObj === undefined ? this.findTarget(e) : targetObj,
	          targets = this.targets || [],
	          options = { e: e, target: target, subTargets: targets };
	
	      this.fire('mouse:' + eventType, options);
	      target && target.fire('mouse' + eventType, options);
	      for (var i = 0; i < targets.length; i++) {
	        targets[i].fire('mouse' + eventType, options);
	      }
	    },
	
	    /**
	     * @private
	     */
	    _finalizeCurrentTransform: function() {
	
	      var transform = this._currentTransform,
	          target = transform.target;
	
	      if (target._scaling) {
	        target._scaling = false;
	      }
	
	      target.setCoords();
	      this._restoreOriginXY(target);
	
	      if (transform.actionPerformed || (this.stateful && target.hasStateChanged())) {
	        this.fire('object:modified', { target: target });
	        target.fire('modified');
	      }
	    },
	
	    /**
	     * @private
	     * @param {Object} target Object to restore
	     */
	    _restoreOriginXY: function(target) {
	      if (this._previousOriginX && this._previousOriginY) {
	
	        var originPoint = target.translateToOriginPoint(
	          target.getCenterPoint(),
	          this._previousOriginX,
	          this._previousOriginY);
	
	        target.originX = this._previousOriginX;
	        target.originY = this._previousOriginY;
	
	        target.left = originPoint.x;
	        target.top = originPoint.y;
	
	        this._previousOriginX = null;
	        this._previousOriginY = null;
	      }
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object fired on mousedown
	     */
	    _onMouseDownInDrawingMode: function(e) {
	      this._isCurrentlyDrawing = true;
	      this.discardActiveObject(e).renderAll();
	      if (this.clipTo) {
	        fabric.util.clipContext(this, this.contextTop);
	      }
	      var pointer = this.getPointer(e);
	      this.freeDrawingBrush.onMouseDown(pointer);
	      this._handleEvent(e, 'down');
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object fired on mousemove
	     */
	    _onMouseMoveInDrawingMode: function(e) {
	      if (this._isCurrentlyDrawing) {
	        var pointer = this.getPointer(e);
	        this.freeDrawingBrush.onMouseMove(pointer);
	      }
	      this.setCursor(this.freeDrawingCursor);
	      this._handleEvent(e, 'move');
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object fired on mouseup
	     */
	    _onMouseUpInDrawingMode: function(e) {
	      this._isCurrentlyDrawing = false;
	      if (this.clipTo) {
	        this.contextTop.restore();
	      }
	      this.freeDrawingBrush.onMouseUp();
	      this._handleEvent(e, 'up');
	    },
	
	    /**
	     * Method that defines the actions when mouse is clic ked on canvas.
	     * The method inits the currentTransform parameters and renders all the
	     * canvas so the current image can be placed on the top canvas and the rest
	     * in on the container one.
	     * @private
	     * @param {Event} e Event object fired on mousedown
	     */
	    __onMouseDown: function (e) {
	
	      // if right click just fire events
	      var isRightClick  = 'which' in e ? e.which === 3 : e.button === 2;
	      if (isRightClick) {
	        if (this.fireRightClick) {
	          this._handleEvent(e, 'down', target ? target : null);
	        }
	        return;
	      }
	
	      if (this.isDrawingMode) {
	        this._onMouseDownInDrawingMode(e);
	        return;
	      }
	
	      // ignore if some object is being transformed at this moment
	      if (this._currentTransform) {
	        return;
	      }
	
	      var target = this.findTarget(e),
	          pointer = this.getPointer(e, true);
	
	      // save pointer for check in __onMouseUp event
	      this._previousPointer = pointer;
	
	      var shouldRender = this._shouldRender(target, pointer),
	          shouldGroup = this._shouldGroup(e, target);
	
	      if (this._shouldClearSelection(e, target)) {
	        this._clearSelection(e, target, pointer);
	      }
	      else if (shouldGroup) {
	        this._handleGrouping(e, target);
	        target = this.getActiveGroup();
	      }
	
	      if (target) {
	        if (target.selectable && (target.__corner || !shouldGroup)) {
	          this._beforeTransform(e, target);
	          this._setupCurrentTransform(e, target);
	        }
	
	        if (target !== this.getActiveGroup() && target !== this.getActiveObject()) {
	          this.deactivateAll();
	          target.selectable && this.setActiveObject(target, e);
	        }
	      }
	      this._handleEvent(e, 'down', target ? target : null);
	      // we must renderAll so that we update the visuals
	      shouldRender && this.renderAll();
	    },
	
	    /**
	     * @private
	     */
	    _beforeTransform: function(e, target) {
	      this.stateful && target.saveState();
	
	      // determine if it's a drag or rotate case
	      if (target._findTargetCorner(this.getPointer(e))) {
	        this.onBeforeScaleRotate(target);
	      }
	
	    },
	
	    /**
	     * @private
	     */
	    _clearSelection: function(e, target, pointer) {
	      this.deactivateAllWithDispatch(e);
	
	      if (target && target.selectable) {
	        this.setActiveObject(target, e);
	      }
	      else if (this.selection) {
	        this._groupSelector = {
	          ex: pointer.x,
	          ey: pointer.y,
	          top: 0,
	          left: 0
	        };
	      }
	    },
	
	    /**
	     * @private
	     * @param {Object} target Object for that origin is set to center
	     */
	    _setOriginToCenter: function(target) {
	      this._previousOriginX = this._currentTransform.target.originX;
	      this._previousOriginY = this._currentTransform.target.originY;
	
	      var center = target.getCenterPoint();
	
	      target.originX = 'center';
	      target.originY = 'center';
	
	      target.left = center.x;
	      target.top = center.y;
	
	      this._currentTransform.left = target.left;
	      this._currentTransform.top = target.top;
	    },
	
	    /**
	     * @private
	     * @param {Object} target Object for that center is set to origin
	     */
	    _setCenterToOrigin: function(target) {
	      var originPoint = target.translateToOriginPoint(
	        target.getCenterPoint(),
	        this._previousOriginX,
	        this._previousOriginY);
	
	      target.originX = this._previousOriginX;
	      target.originY = this._previousOriginY;
	
	      target.left = originPoint.x;
	      target.top = originPoint.y;
	
	      this._previousOriginX = null;
	      this._previousOriginY = null;
	    },
	
	    /**
	     * Method that defines the actions when mouse is hovering the canvas.
	     * The currentTransform parameter will definde whether the user is rotating/scaling/translating
	     * an image or neither of them (only hovering). A group selection is also possible and would cancel
	     * all any other type of action.
	     * In case of an image transformation only the top canvas will be rendered.
	     * @private
	     * @param {Event} e Event object fired on mousemove
	     */
	    __onMouseMove: function (e) {
	
	      var target, pointer;
	
	      if (this.isDrawingMode) {
	        this._onMouseMoveInDrawingMode(e);
	        return;
	      }
	      if (typeof e.touches !== 'undefined' && e.touches.length > 1) {
	        return;
	      }
	
	      var groupSelector = this._groupSelector;
	
	      // We initially clicked in an empty area, so we draw a box for multiple selection
	      if (groupSelector) {
	        pointer = this.getPointer(e, true);
	
	        groupSelector.left = pointer.x - groupSelector.ex;
	        groupSelector.top = pointer.y - groupSelector.ey;
	
	        this.renderTop();
	      }
	      else if (!this._currentTransform) {
	        target = this.findTarget(e);
	        this._setCursorFromEvent(e, target);
	      }
	      else {
	        this._transformObject(e);
	      }
	      this._handleEvent(e, 'move', target ? target : null);
	    },
	
	    /**
	     * Method that defines actions when an Event Mouse Wheel
	     * @param {Event} e Event object fired on mouseup
	     */
	    __onMouseWheel: function(e) {
	      this.fire('mouse:wheel', {
	        e: e
	      });
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event fired on mousemove
	     */
	    _transformObject: function(e) {
	      var pointer = this.getPointer(e),
	          transform = this._currentTransform;
	
	      transform.reset = false;
	      transform.target.isMoving = true;
	
	      this._beforeScaleTransform(e, transform);
	      this._performTransformAction(e, transform, pointer);
	
	      transform.actionPerformed && this.renderAll();
	    },
	
	    /**
	     * @private
	     */
	    _performTransformAction: function(e, transform, pointer) {
	      var x = pointer.x,
	          y = pointer.y,
	          target = transform.target,
	          action = transform.action,
	          actionPerformed = false;
	
	      if (action === 'rotate') {
	        (actionPerformed = this._rotateObject(x, y)) && this._fire('rotating', target, e);
	      }
	      else if (action === 'scale') {
	        (actionPerformed = this._onScale(e, transform, x, y)) && this._fire('scaling', target, e);
	      }
	      else if (action === 'scaleX') {
	        (actionPerformed = this._scaleObject(x, y, 'x')) && this._fire('scaling', target, e);
	      }
	      else if (action === 'scaleY') {
	        (actionPerformed = this._scaleObject(x, y, 'y')) && this._fire('scaling', target, e);
	      }
	      else if (action === 'skewX') {
	        (actionPerformed = this._skewObject(x, y, 'x')) && this._fire('skewing', target, e);
	      }
	      else if (action === 'skewY') {
	        (actionPerformed = this._skewObject(x, y, 'y')) && this._fire('skewing', target, e);
	      }
	      else {
	        actionPerformed = this._translateObject(x, y);
	        if (actionPerformed) {
	          this._fire('moving', target, e);
	          this.setCursor(target.moveCursor || this.moveCursor);
	        }
	      }
	      transform.actionPerformed = actionPerformed;
	    },
	
	    /**
	     * @private
	     */
	    _fire: function(eventName, target, e) {
	      this.fire('object:' + eventName, { target: target, e: e });
	      target.fire(eventName, { e: e });
	    },
	
	    /**
	     * @private
	     */
	    _beforeScaleTransform: function(e, transform) {
	      if (transform.action === 'scale' || transform.action === 'scaleX' || transform.action === 'scaleY') {
	        var centerTransform = this._shouldCenterTransform(transform.target);
	
	        // Switch from a normal resize to center-based
	        if ((centerTransform && (transform.originX !== 'center' || transform.originY !== 'center')) ||
	           // Switch from center-based resize to normal one
	           (!centerTransform && transform.originX === 'center' && transform.originY === 'center')
	        ) {
	          this._resetCurrentTransform();
	          transform.reset = true;
	        }
	      }
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object
	     * @param {Object} transform current tranform
	     * @param {Number} x mouse position x from origin
	     * @param {Number} y mouse poistion y from origin
	     * @return {Boolean} true if the scaling occurred
	     */
	    _onScale: function(e, transform, x, y) {
	      if ((e[this.uniScaleKey] || this.uniScaleTransform) && !transform.target.get('lockUniScaling')) {
	        transform.currentAction = 'scale';
	        return this._scaleObject(x, y);
	      }
	      else {
	        // Switch from a normal resize to proportional
	        if (!transform.reset && transform.currentAction === 'scale') {
	          this._resetCurrentTransform();
	        }
	
	        transform.currentAction = 'scaleEqually';
	        return this._scaleObject(x, y, 'equally');
	      }
	    },
	
	    /**
	     * Sets the cursor depending on where the canvas is being hovered.
	     * Note: very buggy in Opera
	     * @param {Event} e Event object
	     * @param {Object} target Object that the mouse is hovering, if so.
	     */
	    _setCursorFromEvent: function (e, target) {
	      if (!target) {
	        this.setCursor(this.defaultCursor);
	        return false;
	      }
	
	      var hoverCursor = target.hoverCursor || this.hoverCursor;
	      if (!target.selectable) {
	        //let's skip _findTargetCorner if object is not selectable
	        this.setCursor(hoverCursor);
	      }
	      else {
	        var activeGroup = this.getActiveGroup(),
	            // only show proper corner when group selection is not active
	            corner = target._findTargetCorner
	                      && (!activeGroup || !activeGroup.contains(target))
	                      && target._findTargetCorner(this.getPointer(e, true));
	
	        if (!corner) {
	          this.setCursor(hoverCursor);
	        }
	        else {
	          this._setCornerCursor(corner, target, e);
	        }
	      }
	      //actually unclear why it should return something
	      //is never evaluated
	      return true;
	    },
	
	    /**
	     * @private
	     */
	    _setCornerCursor: function(corner, target, e) {
	      if (corner in cursorOffset) {
	        this.setCursor(this._getRotatedCornerCursor(corner, target, e));
	      }
	      else if (corner === 'mtr' && target.hasRotatingPoint) {
	        this.setCursor(this.rotationCursor);
	      }
	      else {
	        this.setCursor(this.defaultCursor);
	        return false;
	      }
	    },
	
	    /**
	     * @private
	     */
	    _getRotatedCornerCursor: function(corner, target, e) {
	      var n = Math.round((target.getAngle() % 360) / 45);
	
	      if (n < 0) {
	        n += 8; // full circle ahead
	      }
	      n += cursorOffset[corner];
	      if (e[this.altActionKey] && cursorOffset[corner] % 2 === 0) {
	        //if we are holding shift and we are on a mx corner...
	        n += 2;
	      }
	      // normalize n to be from 0 to 7
	      n %= 8;
	
	      return this.cursorMap[n];
	    }
	  });
	})();
	
	
	(function() {
	
	  var min = Math.min,
	      max = Math.max;
	
	  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {
	
	    /**
	     * @private
	     * @param {Event} e Event object
	     * @param {fabric.Object} target
	     * @return {Boolean}
	     */
	    _shouldGroup: function(e, target) {
	      var activeObject = this.getActiveObject();
	      return e[this.selectionKey] && target && target.selectable &&
	            (this.getActiveGroup() || (activeObject && activeObject !== target))
	            && this.selection;
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object
	     * @param {fabric.Object} target
	     */
	    _handleGrouping: function (e, target) {
	      var activeGroup = this.getActiveGroup();
	
	      if (target === activeGroup) {
	        // if it's a group, find target again, using activeGroup objects
	        target = this.findTarget(e, true);
	        // if even object is not found, bail out
	        if (!target) {
	          return;
	        }
	      }
	      if (activeGroup) {
	        this._updateActiveGroup(target, e);
	      }
	      else {
	        this._createActiveGroup(target, e);
	      }
	
	      if (this._activeGroup) {
	        this._activeGroup.saveCoords();
	      }
	    },
	
	    /**
	     * @private
	     */
	    _updateActiveGroup: function(target, e) {
	      var activeGroup = this.getActiveGroup();
	
	      if (activeGroup.contains(target)) {
	
	        activeGroup.removeWithUpdate(target);
	        target.set('active', false);
	
	        if (activeGroup.size() === 1) {
	          // remove group alltogether if after removal it only contains 1 object
	          this.discardActiveGroup(e);
	          // activate last remaining object
	          this.setActiveObject(activeGroup.item(0));
	          return;
	        }
	      }
	      else {
	        activeGroup.addWithUpdate(target);
	      }
	      this.fire('selection:created', { target: activeGroup, e: e });
	      activeGroup.set('active', true);
	    },
	
	    /**
	     * @private
	     */
	    _createActiveGroup: function(target, e) {
	
	      if (this._activeObject && target !== this._activeObject) {
	
	        var group = this._createGroup(target);
	        group.addWithUpdate();
	
	        this.setActiveGroup(group);
	        this._activeObject = null;
	
	        this.fire('selection:created', { target: group, e: e });
	      }
	
	      target.set('active', true);
	    },
	
	    /**
	     * @private
	     * @param {Object} target
	     */
	    _createGroup: function(target) {
	
	      var objects = this.getObjects(),
	          isActiveLower = objects.indexOf(this._activeObject) < objects.indexOf(target),
	          groupObjects = isActiveLower
	            ? [this._activeObject, target]
	            : [target, this._activeObject];
	      this._activeObject.isEditing && this._activeObject.exitEditing();
	      return new fabric.Group(groupObjects, {
	        canvas: this
	      });
	    },
	
	    /**
	     * @private
	     * @param {Event} e mouse event
	     */
	    _groupSelectedObjects: function (e) {
	
	      var group = this._collectObjects();
	
	      // do not create group for 1 element only
	      if (group.length === 1) {
	        this.setActiveObject(group[0], e);
	      }
	      else if (group.length > 1) {
	        group = new fabric.Group(group.reverse(), {
	          canvas: this
	        });
	        group.addWithUpdate();
	        this.setActiveGroup(group, e);
	        group.saveCoords();
	        this.fire('selection:created', { target: group });
	        this.renderAll();
	      }
	    },
	
	    /**
	     * @private
	     */
	    _collectObjects: function() {
	      var group = [],
	          currentObject,
	          x1 = this._groupSelector.ex,
	          y1 = this._groupSelector.ey,
	          x2 = x1 + this._groupSelector.left,
	          y2 = y1 + this._groupSelector.top,
	          selectionX1Y1 = new fabric.Point(min(x1, x2), min(y1, y2)),
	          selectionX2Y2 = new fabric.Point(max(x1, x2), max(y1, y2)),
	          isClick = x1 === x2 && y1 === y2;
	
	      for (var i = this._objects.length; i--; ) {
	        currentObject = this._objects[i];
	
	        if (!currentObject || !currentObject.selectable || !currentObject.visible) {
	          continue;
	        }
	
	        if (currentObject.intersectsWithRect(selectionX1Y1, selectionX2Y2) ||
	            currentObject.isContainedWithinRect(selectionX1Y1, selectionX2Y2) ||
	            currentObject.containsPoint(selectionX1Y1) ||
	            currentObject.containsPoint(selectionX2Y2)
	        ) {
	          currentObject.set('active', true);
	          group.push(currentObject);
	
	          // only add one object if it's a click
	          if (isClick) {
	            break;
	          }
	        }
	      }
	
	      return group;
	    },
	
	    /**
	     * @private
	     */
	    _maybeGroupObjects: function(e) {
	      if (this.selection && this._groupSelector) {
	        this._groupSelectedObjects(e);
	      }
	
	      var activeGroup = this.getActiveGroup();
	      if (activeGroup) {
	        activeGroup.setObjectsCoords().setCoords();
	        activeGroup.isMoving = false;
	        this.setCursor(this.defaultCursor);
	      }
	
	      // clear selection and current transformation
	      this._groupSelector = null;
	      this._currentTransform = null;
	    }
	  });
	
	})();
	
	
	(function () {
	
	  var supportQuality = fabric.StaticCanvas.supports('toDataURLWithQuality');
	
	  fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {
	
	    /**
	     * Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately
	     * @param {Object} [options] Options object
	     * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
	     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
	     * @param {Number} [options.multiplier=1] Multiplier to scale by
	     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
	     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
	     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
	     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
	     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
	     * @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}
	     * @example <caption>Generate jpeg dataURL with lower quality</caption>
	     * var dataURL = canvas.toDataURL({
	     *   format: 'jpeg',
	     *   quality: 0.8
	     * });
	     * @example <caption>Generate cropped png dataURL (clipping of canvas)</caption>
	     * var dataURL = canvas.toDataURL({
	     *   format: 'png',
	     *   left: 100,
	     *   top: 100,
	     *   width: 200,
	     *   height: 200
	     * });
	     * @example <caption>Generate double scaled png dataURL</caption>
	     * var dataURL = canvas.toDataURL({
	     *   format: 'png',
	     *   multiplier: 2
	     * });
	     */
	    toDataURL: function (options) {
	      options || (options = { });
	
	      var format = options.format || 'png',
	          quality = options.quality || 1,
	          multiplier = options.multiplier || 1,
	          cropping = {
	            left: options.left || 0,
	            top: options.top || 0,
	            width: options.width || 0,
	            height: options.height || 0,
	          };
	      return this.__toDataURLWithMultiplier(format, quality, cropping, multiplier);
	    },
	
	    /**
	     * @private
	     */
	    __toDataURLWithMultiplier: function(format, quality, cropping, multiplier) {
	
	      var origWidth = this.getWidth(),
	          origHeight = this.getHeight(),
	          scaledWidth = (cropping.width || this.getWidth()) * multiplier,
	          scaledHeight = (cropping.height || this.getHeight()) * multiplier,
	          zoom = this.getZoom(),
	          newZoom = zoom * multiplier,
	          vp = this.viewportTransform,
	          translateX = (vp[4] - cropping.left) * multiplier,
	          translateY = (vp[5] - cropping.top) * multiplier,
	          newVp = [newZoom, 0, 0, newZoom, translateX, translateY],
	          originalInteractive = this.interactive;
	
	      this.viewportTransform = newVp;
	      // setting interactive to false avoid exporting controls
	      this.interactive && (this.interactive = false);
	      if (origWidth !== scaledWidth || origHeight !== scaledHeight) {
	        // this.setDimensions is going to renderAll also;
	        this.setDimensions({ width: scaledWidth, height: scaledHeight });
	      }
	      else {
	        this.renderAll();
	      }
	      var data = this.__toDataURL(format, quality, cropping);
	      originalInteractive && (this.interactive = originalInteractive);
	      this.viewportTransform = vp;
	      //setDimensions with no option object is taking care of:
	      //this.width, this.height, this.renderAll()
	      this.setDimensions({ width: origWidth, height: origHeight });
	      return data;
	    },
	
	    /**
	     * @private
	     */
	    __toDataURL: function(format, quality) {
	
	      var canvasEl = this.contextContainer.canvas;
	      // to avoid common confusion https://github.com/kangax/fabric.js/issues/806
	      if (format === 'jpg') {
	        format = 'jpeg';
	      }
	
	      var data = supportQuality
	                ? canvasEl.toDataURL('image/' + format, quality)
	                : canvasEl.toDataURL('image/' + format);
	
	      return data;
	    },
	
	    /**
	     * Exports canvas element to a dataurl image (allowing to change image size via multiplier).
	     * @deprecated since 1.0.13
	     * @param {String} format (png|jpeg)
	     * @param {Number} multiplier
	     * @param {Number} quality (0..1)
	     * @return {String}
	     */
	    toDataURLWithMultiplier: function (format, multiplier, quality) {
	      return this.toDataURL({
	        format: format,
	        multiplier: multiplier,
	        quality: quality
	      });
	    },
	  });
	
	})();
	
	
	fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {
	
	  /**
	   * Populates canvas with data from the specified dataless JSON.
	   * JSON format must conform to the one of {@link fabric.Canvas#toDatalessJSON}
	   * @deprecated since 1.2.2
	   * @param {String|Object} json JSON string or object
	   * @param {Function} callback Callback, invoked when json is parsed
	   *                            and corresponding objects (e.g: {@link fabric.Image})
	   *                            are initialized
	   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.
	   * @return {fabric.Canvas} instance
	   * @chainable
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}
	   */
	  loadFromDatalessJSON: function (json, callback, reviver) {
	    return this.loadFromJSON(json, callback, reviver);
	  },
	
	  /**
	   * Populates canvas with data from the specified JSON.
	   * JSON format must conform to the one of {@link fabric.Canvas#toJSON}
	   * @param {String|Object} json JSON string or object
	   * @param {Function} callback Callback, invoked when json is parsed
	   *                            and corresponding objects (e.g: {@link fabric.Image})
	   *                            are initialized
	   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.
	   * @return {fabric.Canvas} instance
	   * @chainable
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}
	   * @see {@link http://jsfiddle.net/fabricjs/fmgXt/|jsFiddle demo}
	   * @example <caption>loadFromJSON</caption>
	   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));
	   * @example <caption>loadFromJSON with reviver</caption>
	   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas), function(o, object) {
	   *   // `o` = json object
	   *   // `object` = fabric.Object instance
	   *   // ... do some stuff ...
	   * });
	   */
	  loadFromJSON: function (json, callback, reviver) {
	    if (!json) {
	      return;
	    }
	
	    // serialize if it wasn't already
	    var serialized = (typeof json === 'string')
	      ? JSON.parse(json)
	      : fabric.util.object.clone(json);
	
	    this.clear();
	
	    var _this = this;
	    this._enlivenObjects(serialized.objects, function () {
	      _this._setBgOverlay(serialized, function () {
	        // remove parts i cannot set as options
	        delete serialized.objects;
	        delete serialized.backgroundImage;
	        delete serialized.overlayImage;
	        delete serialized.background;
	        delete serialized.overlay;
	        // this._initOptions does too many things to just
	        // call it. Normally loading an Object from JSON
	        // create the Object instance. Here the Canvas is
	        // already an instance and we are just loading things over it
	        for (var prop in serialized) {
	          _this[prop] = serialized[prop];
	        }
	        callback && callback();
	      });
	    }, reviver);
	    return this;
	  },
	
	  /**
	   * @private
	   * @param {Object} serialized Object with background and overlay information
	   * @param {Function} callback Invoked after all background and overlay images/patterns loaded
	   */
	  _setBgOverlay: function(serialized, callback) {
	    var _this = this,
	        loaded = {
	          backgroundColor: false,
	          overlayColor: false,
	          backgroundImage: false,
	          overlayImage: false
	        };
	
	    if (!serialized.backgroundImage && !serialized.overlayImage && !serialized.background && !serialized.overlay) {
	      callback && callback();
	      return;
	    }
	
	    var cbIfLoaded = function () {
	      if (loaded.backgroundImage && loaded.overlayImage && loaded.backgroundColor && loaded.overlayColor) {
	        _this.renderAll();
	        callback && callback();
	      }
	    };
	
	    this.__setBgOverlay('backgroundImage', serialized.backgroundImage, loaded, cbIfLoaded);
	    this.__setBgOverlay('overlayImage', serialized.overlayImage, loaded, cbIfLoaded);
	    this.__setBgOverlay('backgroundColor', serialized.background, loaded, cbIfLoaded);
	    this.__setBgOverlay('overlayColor', serialized.overlay, loaded, cbIfLoaded);
	
	    cbIfLoaded();
	  },
	
	  /**
	   * @private
	   * @param {String} property Property to set (backgroundImage, overlayImage, backgroundColor, overlayColor)
	   * @param {(Object|String)} value Value to set
	   * @param {Object} loaded Set loaded property to true if property is set
	   * @param {Object} callback Callback function to invoke after property is set
	   */
	  __setBgOverlay: function(property, value, loaded, callback) {
	    var _this = this;
	
	    if (!value) {
	      loaded[property] = true;
	      return;
	    }
	
	    if (property === 'backgroundImage' || property === 'overlayImage') {
	      fabric.Image.fromObject(value, function(img) {
	        _this[property] = img;
	        loaded[property] = true;
	        callback && callback();
	      });
	    }
	    else {
	      this['set' + fabric.util.string.capitalize(property, true)](value, function() {
	        loaded[property] = true;
	        callback && callback();
	      });
	    }
	  },
	
	  /**
	   * @private
	   * @param {Array} objects
	   * @param {Function} callback
	   * @param {Function} [reviver]
	   */
	  _enlivenObjects: function (objects, callback, reviver) {
	    var _this = this;
	
	    if (!objects || objects.length === 0) {
	      callback && callback();
	      return;
	    }
	
	    var renderOnAddRemove = this.renderOnAddRemove;
	    this.renderOnAddRemove = false;
	
	    fabric.util.enlivenObjects(objects, function(enlivenedObjects) {
	      enlivenedObjects.forEach(function(obj, index) {
	        // we splice the array just in case some custom classes restored from JSON
	        // will add more object to canvas at canvas init.
	        _this.insertAt(obj, index);
	      });
	
	      _this.renderOnAddRemove = renderOnAddRemove;
	      callback && callback();
	    }, null, reviver);
	  },
	
	  /**
	   * @private
	   * @param {String} format
	   * @param {Function} callback
	   */
	  _toDataURL: function (format, callback) {
	    this.clone(function (clone) {
	      callback(clone.toDataURL(format));
	    });
	  },
	
	  /**
	   * @private
	   * @param {String} format
	   * @param {Number} multiplier
	   * @param {Function} callback
	   */
	  _toDataURLWithMultiplier: function (format, multiplier, callback) {
	    this.clone(function (clone) {
	      callback(clone.toDataURLWithMultiplier(format, multiplier));
	    });
	  },
	
	  /**
	   * Clones canvas instance
	   * @param {Object} [callback] Receives cloned instance as a first argument
	   * @param {Array} [properties] Array of properties to include in the cloned canvas and children
	   */
	  clone: function (callback, properties) {
	    var data = JSON.stringify(this.toJSON(properties));
	    this.cloneWithoutData(function(clone) {
	      clone.loadFromJSON(data, function() {
	        callback && callback(clone);
	      });
	    });
	  },
	
	  /**
	   * Clones canvas instance without cloning existing data.
	   * This essentially copies canvas dimensions, clipping properties, etc.
	   * but leaves data empty (so that you can populate it with your own)
	   * @param {Object} [callback] Receives cloned instance as a first argument
	   */
	  cloneWithoutData: function(callback) {
	    var el = fabric.document.createElement('canvas');
	
	    el.width = this.getWidth();
	    el.height = this.getHeight();
	
	    var clone = new fabric.Canvas(el);
	    clone.clipTo = this.clipTo;
	    if (this.backgroundImage) {
	      clone.setBackgroundImage(this.backgroundImage.src, function() {
	        clone.renderAll();
	        callback && callback(clone);
	      });
	      clone.backgroundImageOpacity = this.backgroundImageOpacity;
	      clone.backgroundImageStretch = this.backgroundImageStretch;
	    }
	    else {
	      callback && callback(clone);
	    }
	  }
	});
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      toFixed = fabric.util.toFixed,
	      capitalize = fabric.util.string.capitalize,
	      degreesToRadians = fabric.util.degreesToRadians,
	      supportsLineDash = fabric.StaticCanvas.supports('setLineDash');
	
	  if (fabric.Object) {
	    return;
	  }
	
	  /**
	   * Root object class from which all 2d shape classes inherit from
	   * @class fabric.Object
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#objects}
	   * @see {@link fabric.Object#initialize} for constructor definition
	   *
	   * @fires added
	   * @fires removed
	   *
	   * @fires selected
	   * @fires deselected
	   * @fires modified
	   * @fires rotating
	   * @fires scaling
	   * @fires moving
	   * @fires skewing
	   *
	   * @fires mousedown
	   * @fires mouseup
	   * @fires mouseover
	   * @fires mouseout
	   */
	  fabric.Object = fabric.util.createClass(/** @lends fabric.Object.prototype */ {
	
	    /**
	     * Retrieves object's {@link fabric.Object#clipTo|clipping function}
	     * @method getClipTo
	     * @memberOf fabric.Object.prototype
	     * @return {Function}
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#clipTo|clipping function}
	     * @method setClipTo
	     * @memberOf fabric.Object.prototype
	     * @param {Function} clipTo Clipping function
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#transformMatrix|transformMatrix}
	     * @method getTransformMatrix
	     * @memberOf fabric.Object.prototype
	     * @return {Array} transformMatrix
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#transformMatrix|transformMatrix}
	     * @method setTransformMatrix
	     * @memberOf fabric.Object.prototype
	     * @param {Array} transformMatrix
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#visible|visible} state
	     * @method getVisible
	     * @memberOf fabric.Object.prototype
	     * @return {Boolean} True if visible
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#visible|visible} state
	     * @method setVisible
	     * @memberOf fabric.Object.prototype
	     * @param {Boolean} value visible value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#shadow|shadow}
	     * @method getShadow
	     * @memberOf fabric.Object.prototype
	     * @return {Object} Shadow instance
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#stroke|stroke}
	     * @method getStroke
	     * @memberOf fabric.Object.prototype
	     * @return {String} stroke value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#stroke|stroke}
	     * @method setStroke
	     * @memberOf fabric.Object.prototype
	     * @param {String} value stroke value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#strokeWidth|strokeWidth}
	     * @method getStrokeWidth
	     * @memberOf fabric.Object.prototype
	     * @return {Number} strokeWidth value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#strokeWidth|strokeWidth}
	     * @method setStrokeWidth
	     * @memberOf fabric.Object.prototype
	     * @param {Number} value strokeWidth value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#originX|originX}
	     * @method getOriginX
	     * @memberOf fabric.Object.prototype
	     * @return {String} originX value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#originX|originX}
	     * @method setOriginX
	     * @memberOf fabric.Object.prototype
	     * @param {String} value originX value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#originY|originY}
	     * @method getOriginY
	     * @memberOf fabric.Object.prototype
	     * @return {String} originY value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#originY|originY}
	     * @method setOriginY
	     * @memberOf fabric.Object.prototype
	     * @param {String} value originY value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#fill|fill}
	     * @method getFill
	     * @memberOf fabric.Object.prototype
	     * @return {String} Fill value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#fill|fill}
	     * @method setFill
	     * @memberOf fabric.Object.prototype
	     * @param {String} value Fill value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#opacity|opacity}
	     * @method getOpacity
	     * @memberOf fabric.Object.prototype
	     * @return {Number} Opacity value (0-1)
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#opacity|opacity}
	     * @method setOpacity
	     * @memberOf fabric.Object.prototype
	     * @param {Number} value Opacity value (0-1)
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#angle|angle} (in degrees)
	     * @method getAngle
	     * @memberOf fabric.Object.prototype
	     * @return {Number}
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#top|top position}
	     * @method getTop
	     * @memberOf fabric.Object.prototype
	     * @return {Number} Top value (in pixels)
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#top|top position}
	     * @method setTop
	     * @memberOf fabric.Object.prototype
	     * @param {Number} value Top value (in pixels)
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#left|left position}
	     * @method getLeft
	     * @memberOf fabric.Object.prototype
	     * @return {Number} Left value (in pixels)
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#left|left position}
	     * @method setLeft
	     * @memberOf fabric.Object.prototype
	     * @param {Number} value Left value (in pixels)
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#scaleX|scaleX} value
	     * @method getScaleX
	     * @memberOf fabric.Object.prototype
	     * @return {Number} scaleX value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#scaleX|scaleX} value
	     * @method setScaleX
	     * @memberOf fabric.Object.prototype
	     * @param {Number} value scaleX value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#scaleY|scaleY} value
	     * @method getScaleY
	     * @memberOf fabric.Object.prototype
	     * @return {Number} scaleY value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#scaleY|scaleY} value
	     * @method setScaleY
	     * @memberOf fabric.Object.prototype
	     * @param {Number} value scaleY value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#flipX|flipX} value
	     * @method getFlipX
	     * @memberOf fabric.Object.prototype
	     * @return {Boolean} flipX value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#flipX|flipX} value
	     * @method setFlipX
	     * @memberOf fabric.Object.prototype
	     * @param {Boolean} value flipX value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#flipY|flipY} value
	     * @method getFlipY
	     * @memberOf fabric.Object.prototype
	     * @return {Boolean} flipY value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#flipY|flipY} value
	     * @method setFlipY
	     * @memberOf fabric.Object.prototype
	     * @param {Boolean} value flipY value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Type of an object (rect, circle, path, etc.).
	     * Note that this property is meant to be read-only and not meant to be modified.
	     * If you modify, certain parts of Fabric (such as JSON loading) won't work correctly.
	     * @type String
	     * @default
	     */
	    type:                     'object',
	
	    /**
	     * Horizontal origin of transformation of an object (one of "left", "right", "center")
	     * See http://jsfiddle.net/1ow02gea/40/ on how originX/originY affect objects in groups
	     * @type String
	     * @default
	     */
	    originX:                  'left',
	
	    /**
	     * Vertical origin of transformation of an object (one of "top", "bottom", "center")
	     * See http://jsfiddle.net/1ow02gea/40/ on how originX/originY affect objects in groups
	     * @type String
	     * @default
	     */
	    originY:                  'top',
	
	    /**
	     * Top position of an object. Note that by default it's relative to object top. You can change this by setting originY={top/center/bottom}
	     * @type Number
	     * @default
	     */
	    top:                      0,
	
	    /**
	     * Left position of an object. Note that by default it's relative to object left. You can change this by setting originX={left/center/right}
	     * @type Number
	     * @default
	     */
	    left:                     0,
	
	    /**
	     * Object width
	     * @type Number
	     * @default
	     */
	    width:                    0,
	
	    /**
	     * Object height
	     * @type Number
	     * @default
	     */
	    height:                   0,
	
	    /**
	     * Object scale factor (horizontal)
	     * @type Number
	     * @default
	     */
	    scaleX:                   1,
	
	    /**
	     * Object scale factor (vertical)
	     * @type Number
	     * @default
	     */
	    scaleY:                   1,
	
	    /**
	     * When true, an object is rendered as flipped horizontally
	     * @type Boolean
	     * @default
	     */
	    flipX:                    false,
	
	    /**
	     * When true, an object is rendered as flipped vertically
	     * @type Boolean
	     * @default
	     */
	    flipY:                    false,
	
	    /**
	     * Opacity of an object
	     * @type Number
	     * @default
	     */
	    opacity:                  1,
	
	    /**
	     * Angle of rotation of an object (in degrees)
	     * @type Number
	     * @default
	     */
	    angle:                    0,
	
	    /**
	     * Angle of skew on x axes of an object (in degrees)
	     * @type Number
	     * @default
	     */
	    skewX:                    0,
	
	    /**
	     * Angle of skew on y axes of an object (in degrees)
	     * @type Number
	     * @default
	     */
	    skewY:                    0,
	
	    /**
	     * Size of object's controlling corners (in pixels)
	     * @type Number
	     * @default
	     */
	    cornerSize:               13,
	
	    /**
	     * When true, object's controlling corners are rendered as transparent inside (i.e. stroke instead of fill)
	     * @type Boolean
	     * @default
	     */
	    transparentCorners:       true,
	
	    /**
	     * Default cursor value used when hovering over this object on canvas
	     * @type String
	     * @default
	     */
	    hoverCursor:              null,
	
	    /**
	     * Default cursor value used when moving this object on canvas
	     * @type String
	     * @default
	     */
	    moveCursor:               null,
	
	    /**
	     * Padding between object and its controlling borders (in pixels)
	     * @type Number
	     * @default
	     */
	    padding:                  0,
	
	    /**
	     * Color of controlling borders of an object (when it's active)
	     * @type String
	     * @default
	     */
	    borderColor:              'rgba(102,153,255,0.75)',
	
	    /**
	     * Array specifying dash pattern of an object's borders (hasBorder must be true)
	     * @since 1.6.2
	     * @type Array
	     */
	    borderDashArray:          null,
	
	    /**
	     * Color of controlling corners of an object (when it's active)
	     * @type String
	     * @default
	     */
	    cornerColor:              'rgba(102,153,255,0.5)',
	
	    /**
	     * Color of controlling corners of an object (when it's active and transparentCorners false)
	     * @since 1.6.2
	     * @type String
	     * @default
	     */
	    cornerStrokeColor:        null,
	
	    /**
	     * Specify style of control, 'rect' or 'circle'
	     * @since 1.6.2
	     * @type String
	     */
	    cornerStyle:          'rect',
	
	    /**
	     * Array specifying dash pattern of an object's control (hasBorder must be true)
	     * @since 1.6.2
	     * @type Array
	     */
	    cornerDashArray:          null,
	
	    /**
	     * When true, this object will use center point as the origin of transformation
	     * when being scaled via the controls.
	     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
	     * @since 1.3.4
	     * @type Boolean
	     * @default
	     */
	    centeredScaling:          false,
	
	    /**
	     * When true, this object will use center point as the origin of transformation
	     * when being rotated via the controls.
	     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
	     * @since 1.3.4
	     * @type Boolean
	     * @default
	     */
	    centeredRotation:         true,
	
	    /**
	     * Color of object's fill
	     * @type String
	     * @default
	     */
	    fill:                     'rgb(0,0,0)',
	
	    /**
	     * Fill rule used to fill an object
	     * accepted values are nonzero, evenodd
	     * <b>Backwards incompatibility note:</b> This property was used for setting globalCompositeOperation until v1.4.12 (use `fabric.Object#globalCompositeOperation` instead)
	     * @type String
	     * @default
	     */
	    fillRule:                 'nonzero',
	
	    /**
	     * Composite rule used for canvas globalCompositeOperation
	     * @type String
	     * @default
	     */
	    globalCompositeOperation: 'source-over',
	
	    /**
	     * Background color of an object. Only works with text objects at the moment.
	     * @type String
	     * @default
	     */
	    backgroundColor:          '',
	
	    /**
	     * Selection Background color of an object. colored layer behind the object when it is active.
	     * does not mix good with globalCompositeOperation methods.
	     * @type String
	     * @default
	     */
	    selectionBackgroundColor:          '',
	
	    /**
	     * When defined, an object is rendered via stroke and this property specifies its color
	     * @type String
	     * @default
	     */
	    stroke:                   null,
	
	    /**
	     * Width of a stroke used to render this object
	     * @type Number
	     * @default
	     */
	    strokeWidth:              1,
	
	    /**
	     * Array specifying dash pattern of an object's stroke (stroke must be defined)
	     * @type Array
	     */
	    strokeDashArray:          null,
	
	    /**
	     * Line endings style of an object's stroke (one of "butt", "round", "square")
	     * @type String
	     * @default
	     */
	    strokeLineCap:            'butt',
	
	    /**
	     * Corner style of an object's stroke (one of "bevil", "round", "miter")
	     * @type String
	     * @default
	     */
	    strokeLineJoin:           'miter',
	
	    /**
	     * Maximum miter length (used for strokeLineJoin = "miter") of an object's stroke
	     * @type Number
	     * @default
	     */
	    strokeMiterLimit:         10,
	
	    /**
	     * Shadow object representing shadow of this shape
	     * @type fabric.Shadow
	     * @default
	     */
	    shadow:                   null,
	
	    /**
	     * Opacity of object's controlling borders when object is active and moving
	     * @type Number
	     * @default
	     */
	    borderOpacityWhenMoving:  0.4,
	
	    /**
	     * Scale factor of object's controlling borders
	     * @type Number
	     * @default
	     */
	    borderScaleFactor:        1,
	
	    /**
	     * Transform matrix (similar to SVG's transform matrix)
	     * @type Array
	     */
	    transformMatrix:          null,
	
	    /**
	     * Minimum allowed scale value of an object
	     * @type Number
	     * @default
	     */
	    minScaleLimit:            0.01,
	
	    /**
	     * When set to `false`, an object can not be selected for modification (using either point-click-based or group-based selection).
	     * But events still fire on it.
	     * @type Boolean
	     * @default
	     */
	    selectable:               true,
	
	    /**
	     * When set to `false`, an object can not be a target of events. All events propagate through it. Introduced in v1.3.4
	     * @type Boolean
	     * @default
	     */
	    evented:                  true,
	
	    /**
	     * When set to `false`, an object is not rendered on canvas
	     * @type Boolean
	     * @default
	     */
	    visible:                  true,
	
	    /**
	     * When set to `false`, object's controls are not displayed and can not be used to manipulate object
	     * @type Boolean
	     * @default
	     */
	    hasControls:              true,
	
	    /**
	     * When set to `false`, object's controlling borders are not rendered
	     * @type Boolean
	     * @default
	     */
	    hasBorders:               true,
	
	    /**
	     * When set to `false`, object's controlling rotating point will not be visible or selectable
	     * @type Boolean
	     * @default
	     */
	    hasRotatingPoint:         true,
	
	    /**
	     * Offset for object's controlling rotating point (when enabled via `hasRotatingPoint`)
	     * @type Number
	     * @default
	     */
	    rotatingPointOffset:      40,
	
	    /**
	     * When set to `true`, objects are "found" on canvas on per-pixel basis rather than according to bounding box
	     * @type Boolean
	     * @default
	     */
	    perPixelTargetFind:       false,
	
	    /**
	     * When `false`, default object's values are not included in its serialization
	     * @type Boolean
	     * @default
	     */
	    includeDefaultValues:     true,
	
	    /**
	     * Function that determines clipping of an object (context is passed as a first argument)
	     * Note that context origin is at the object's center point (not left/top corner)
	     * @type Function
	     */
	    clipTo:                   null,
	
	    /**
	     * When `true`, object horizontal movement is locked
	     * @type Boolean
	     * @default
	     */
	    lockMovementX:            false,
	
	    /**
	     * When `true`, object vertical movement is locked
	     * @type Boolean
	     * @default
	     */
	    lockMovementY:            false,
	
	    /**
	     * When `true`, object rotation is locked
	     * @type Boolean
	     * @default
	     */
	    lockRotation:             false,
	
	    /**
	     * When `true`, object horizontal scaling is locked
	     * @type Boolean
	     * @default
	     */
	    lockScalingX:             false,
	
	    /**
	     * When `true`, object vertical scaling is locked
	     * @type Boolean
	     * @default
	     */
	    lockScalingY:             false,
	
	    /**
	     * When `true`, object non-uniform scaling is locked
	     * @type Boolean
	     * @default
	     */
	    lockUniScaling:           false,
	
	    /**
	     * When `true`, object horizontal skewing is locked
	     * @type Boolean
	     * @default
	     */
	    lockSkewingX:             false,
	
	    /**
	     * When `true`, object vertical skewing is locked
	     * @type Boolean
	     * @default
	     */
	    lockSkewingY:             false,
	
	    /**
	     * When `true`, object cannot be flipped by scaling into negative values
	     * @type Boolean
	     * @default
	     */
	
	    lockScalingFlip:          false,
	
	    /**
	     * When `true`, object is not exported in SVG or OBJECT/JSON
	     * since 1.6.3
	     * @type Boolean
	     * @default
	     */
	
	    excludeFromExport:          false,
	
	    /**
	     * List of properties to consider when checking if state
	     * of an object is changed (fabric.Object#hasStateChanged)
	     * as well as for history (undo/redo) purposes
	     * @type Array
	     */
	    stateProperties:  (
	      'top left width height scaleX scaleY flipX flipY originX originY transformMatrix ' +
	      'stroke strokeWidth strokeDashArray strokeLineCap strokeLineJoin strokeMiterLimit ' +
	      'angle opacity fill fillRule globalCompositeOperation shadow clipTo visible backgroundColor ' +
	      'skewX skewY'
	    ).split(' '),
	
	    /**
	     * Constructor
	     * @param {Object} [options] Options object
	     */
	    initialize: function(options) {
	      if (options) {
	        this.setOptions(options);
	      }
	    },
	
	    /**
	     * @private
	     * @param {Object} [options] Options object
	     */
	    _initGradient: function(options) {
	      if (options.fill && options.fill.colorStops && !(options.fill instanceof fabric.Gradient)) {
	        this.set('fill', new fabric.Gradient(options.fill));
	      }
	      if (options.stroke && options.stroke.colorStops && !(options.stroke instanceof fabric.Gradient)) {
	        this.set('stroke', new fabric.Gradient(options.stroke));
	      }
	    },
	
	    /**
	     * @private
	     * @param {Object} [options] Options object
	     */
	    _initPattern: function(options) {
	      if (options.fill && options.fill.source && !(options.fill instanceof fabric.Pattern)) {
	        this.set('fill', new fabric.Pattern(options.fill));
	      }
	      if (options.stroke && options.stroke.source && !(options.stroke instanceof fabric.Pattern)) {
	        this.set('stroke', new fabric.Pattern(options.stroke));
	      }
	    },
	
	    /**
	     * @private
	     * @param {Object} [options] Options object
	     */
	    _initClipping: function(options) {
	      if (!options.clipTo || typeof options.clipTo !== 'string') {
	        return;
	      }
	
	      var functionBody = fabric.util.getFunctionBody(options.clipTo);
	      if (typeof functionBody !== 'undefined') {
	        this.clipTo = new Function('ctx', functionBody);
	      }
	    },
	
	    /**
	     * Sets object's properties from options
	     * @param {Object} [options] Options object
	     */
	    setOptions: function(options) {
	      for (var prop in options) {
	        this.set(prop, options[prop]);
	      }
	      this._initGradient(options);
	      this._initPattern(options);
	      this._initClipping(options);
	    },
	
	    /**
	     * Transforms context when rendering an object
	     * @param {CanvasRenderingContext2D} ctx Context
	     * @param {Boolean} fromLeft When true, context is transformed to object's top/left corner. This is used when rendering text on Node
	     */
	    transform: function(ctx, fromLeft) {
	      if (this.group && !this.group._transformDone && this.group === this.canvas._activeGroup) {
	        this.group.transform(ctx);
	      }
	      var center = fromLeft ? this._getLeftTopCoords() : this.getCenterPoint();
	      ctx.translate(center.x, center.y);
	      ctx.rotate(degreesToRadians(this.angle));
	      ctx.scale(
	        this.scaleX * (this.flipX ? -1 : 1),
	        this.scaleY * (this.flipY ? -1 : 1)
	      );
	      ctx.transform(1, 0, Math.tan(degreesToRadians(this.skewX)), 1, 0, 0);
	      ctx.transform(1, Math.tan(degreesToRadians(this.skewY)), 0, 1, 0, 0);
	    },
	
	    /**
	     * Returns an object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
	
	          object = {
	            type:                     this.type,
	            originX:                  this.originX,
	            originY:                  this.originY,
	            left:                     toFixed(this.left, NUM_FRACTION_DIGITS),
	            top:                      toFixed(this.top, NUM_FRACTION_DIGITS),
	            width:                    toFixed(this.width, NUM_FRACTION_DIGITS),
	            height:                   toFixed(this.height, NUM_FRACTION_DIGITS),
	            fill:                     (this.fill && this.fill.toObject) ? this.fill.toObject() : this.fill,
	            stroke:                   (this.stroke && this.stroke.toObject) ? this.stroke.toObject() : this.stroke,
	            strokeWidth:              toFixed(this.strokeWidth, NUM_FRACTION_DIGITS),
	            strokeDashArray:          this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,
	            strokeLineCap:            this.strokeLineCap,
	            strokeLineJoin:           this.strokeLineJoin,
	            strokeMiterLimit:         toFixed(this.strokeMiterLimit, NUM_FRACTION_DIGITS),
	            scaleX:                   toFixed(this.scaleX, NUM_FRACTION_DIGITS),
	            scaleY:                   toFixed(this.scaleY, NUM_FRACTION_DIGITS),
	            angle:                    toFixed(this.getAngle(), NUM_FRACTION_DIGITS),
	            flipX:                    this.flipX,
	            flipY:                    this.flipY,
	            opacity:                  toFixed(this.opacity, NUM_FRACTION_DIGITS),
	            shadow:                   (this.shadow && this.shadow.toObject) ? this.shadow.toObject() : this.shadow,
	            visible:                  this.visible,
	            clipTo:                   this.clipTo && String(this.clipTo),
	            backgroundColor:          this.backgroundColor,
	            fillRule:                 this.fillRule,
	            globalCompositeOperation: this.globalCompositeOperation,
	            transformMatrix:          this.transformMatrix ? this.transformMatrix.concat() : this.transformMatrix,
	            skewX:                    toFixed(this.skewX, NUM_FRACTION_DIGITS),
	            skewY:                    toFixed(this.skewY, NUM_FRACTION_DIGITS)
	          };
	
	      if (!this.includeDefaultValues) {
	        object = this._removeDefaultValues(object);
	      }
	
	      fabric.util.populateWithProperties(this, object, propertiesToInclude);
	
	      return object;
	    },
	
	    /**
	     * Returns (dataless) object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} Object representation of an instance
	     */
	    toDatalessObject: function(propertiesToInclude) {
	      // will be overwritten by subclasses
	      return this.toObject(propertiesToInclude);
	    },
	
	    /**
	     * @private
	     * @param {Object} object
	     */
	    _removeDefaultValues: function(object) {
	      var prototype = fabric.util.getKlass(object.type).prototype,
	          stateProperties = prototype.stateProperties;
	
	      stateProperties.forEach(function(prop) {
	        if (object[prop] === prototype[prop]) {
	          delete object[prop];
	        }
	        var isArray = Object.prototype.toString.call(object[prop]) === '[object Array]' &&
	                      Object.prototype.toString.call(prototype[prop]) === '[object Array]';
	
	        // basically a check for [] === []
	        if (isArray && object[prop].length === 0 && prototype[prop].length === 0) {
	          delete object[prop];
	        }
	      });
	
	      return object;
	    },
	
	    /**
	     * Returns a string representation of an instance
	     * @return {String}
	     */
	    toString: function() {
	      return '#<fabric.' + capitalize(this.type) + '>';
	    },
	
	    /**
	     * Basic getter
	     * @param {String} property Property name
	     * @return {*} value of a property
	     */
	    get: function(property) {
	      return this[property];
	    },
	
	    /**
	     * Return the object scale factor counting also the group scaling
	     * @return {Object} object with scaleX and scaleY properties
	     */
	    getObjectScaling: function() {
	      var scaleX = this.scaleX, scaleY = this.scaleY;
	      if (this.group) {
	        var scaling = this.group.getObjectScaling();
	        scaleX *= scaling.scaleX;
	        scaleY *= scaling.scaleY;
	      }
	      return { scaleX: scaleX, scaleY: scaleY };
	    },
	
	    /**
	     * @private
	     */
	    _setObject: function(obj) {
	      for (var prop in obj) {
	        this._set(prop, obj[prop]);
	      }
	    },
	
	    /**
	     * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.
	     * @param {String|Object} key Property name or object (if object, iterate over the object properties)
	     * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    set: function(key, value) {
	      if (typeof key === 'object') {
	        this._setObject(key);
	      }
	      else {
	        if (typeof value === 'function' && key !== 'clipTo') {
	          this._set(key, value(this.get(key)));
	        }
	        else {
	          this._set(key, value);
	        }
	      }
	      return this;
	    },
	
	    /**
	     * @private
	     * @param {String} key
	     * @param {*} value
	     * @return {fabric.Object} thisArg
	     */
	    _set: function(key, value) {
	      var shouldConstrainValue = (key === 'scaleX' || key === 'scaleY');
	
	      if (shouldConstrainValue) {
	        value = this._constrainScale(value);
	      }
	      if (key === 'scaleX' && value < 0) {
	        this.flipX = !this.flipX;
	        value *= -1;
	      }
	      else if (key === 'scaleY' && value < 0) {
	        this.flipY = !this.flipY;
	        value *= -1;
	      }
	      else if (key === 'shadow' && value && !(value instanceof fabric.Shadow)) {
	        value = new fabric.Shadow(value);
	      }
	
	      this[key] = value;
	
	      if (key === 'width' || key === 'height') {
	        this.minScaleLimit = Math.min(0.1, 1 / Math.max(this.width, this.height));
	      }
	
	      return this;
	    },
	
	    /**
	     * This callback function is called by the parent group of an object every
	     * time a non-delegated property changes on the group. It is passed the key
	     * and value as parameters. Not adding in this function's signature to avoid
	     * Travis build error about unused variables.
	     */
	    setOnGroup: function() {
	      // implemented by sub-classes, as needed.
	    },
	
	    /**
	     * Toggles specified property from `true` to `false` or from `false` to `true`
	     * @param {String} property Property to toggle
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    toggle: function(property) {
	      var value = this.get(property);
	      if (typeof value === 'boolean') {
	        this.set(property, !value);
	      }
	      return this;
	    },
	
	    /**
	     * Sets sourcePath of an object
	     * @param {String} value Value to set sourcePath to
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    setSourcePath: function(value) {
	      this.sourcePath = value;
	      return this;
	    },
	
	    /**
	     * Retrieves viewportTransform from Object's canvas if possible
	     * @method getViewportTransform
	     * @memberOf fabric.Object.prototype
	     * @return {Boolean} flipY value // TODO
	     */
	    getViewportTransform: function() {
	      if (this.canvas && this.canvas.viewportTransform) {
	        return this.canvas.viewportTransform;
	      }
	      return [1, 0, 0, 1, 0, 0];
	    },
	
	    /**
	     * Renders an object on a specified context
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} [noTransform] When true, context is not transformed
	     */
	    render: function(ctx, noTransform) {
	      // do not render if width/height are zeros or object is not visible
	      if ((this.width === 0 && this.height === 0) || !this.visible) {
	        return;
	      }
	
	      ctx.save();
	
	      //setup fill rule for current object
	      this._setupCompositeOperation(ctx);
	      this.drawSelectionBackground(ctx);
	      if (!noTransform) {
	        this.transform(ctx);
	      }
	      this._setOpacity(ctx);
	      this._setShadow(ctx);
	      this._renderBackground(ctx);
	      this._setStrokeStyles(ctx);
	      this._setFillStyles(ctx);
	      if (this.transformMatrix) {
	        ctx.transform.apply(ctx, this.transformMatrix);
	      }
	      this.clipTo && fabric.util.clipContext(this, ctx);
	      this._render(ctx, noTransform);
	      this.clipTo && ctx.restore();
	
	      ctx.restore();
	    },
	
	    /**
	     * Draws a background for the object big as its width and height;
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderBackground: function(ctx) {
	      if (!this.backgroundColor) {
	        return;
	      }
	
	      ctx.fillStyle = this.backgroundColor;
	
	      ctx.fillRect(
	        -this.width / 2,
	        -this.height / 2,
	        this.width,
	        this.height
	      );
	      // if there is background color no other shadows
	      // should be casted
	      this._removeShadow(ctx);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _setOpacity: function(ctx) {
	      if (this.group) {
	        this.group._setOpacity(ctx);
	      }
	      ctx.globalAlpha *= this.opacity;
	    },
	
	    _setStrokeStyles: function(ctx) {
	      if (this.stroke) {
	        ctx.lineWidth = this.strokeWidth;
	        ctx.lineCap = this.strokeLineCap;
	        ctx.lineJoin = this.strokeLineJoin;
	        ctx.miterLimit = this.strokeMiterLimit;
	        ctx.strokeStyle = this.stroke.toLive
	          ? this.stroke.toLive(ctx, this)
	          : this.stroke;
	      }
	    },
	
	    _setFillStyles: function(ctx) {
	      if (this.fill) {
	        ctx.fillStyle = this.fill.toLive
	          ? this.fill.toLive(ctx, this)
	          : this.fill;
	      }
	    },
	
	    /**
	     * @private
	     * Sets line dash
	     * @param {CanvasRenderingContext2D} ctx Context to set the dash line on
	     * @param {Array} dashArray array representing dashes
	     * @param {Function} alternative function to call if browaser does not support lineDash
	     */
	    _setLineDash: function(ctx, dashArray, alternative) {
	      if (!dashArray) {
	        return;
	      }
	      // Spec requires the concatenation of two copies the dash list when the number of elements is odd
	      if (1 & dashArray.length) {
	        dashArray.push.apply(dashArray, dashArray);
	      }
	      if (supportsLineDash) {
	        ctx.setLineDash(dashArray);
	      }
	      else {
	        alternative && alternative(ctx);
	      }
	    },
	
	    /**
	     * Renders controls and borders for the object
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} [noTransform] When true, context is not transformed
	     */
	    _renderControls: function(ctx, noTransform) {
	      if (!this.active || noTransform
	          || (this.group && this.group !== this.canvas.getActiveGroup())) {
	        return;
	      }
	
	      var vpt = this.getViewportTransform(),
	          matrix = this.calcTransformMatrix(),
	          options;
	      matrix = fabric.util.multiplyTransformMatrices(vpt, matrix);
	      options = fabric.util.qrDecompose(matrix);
	
	      ctx.save();
	      ctx.translate(options.translateX, options.translateY);
	      ctx.lineWidth = 1 * this.borderScaleFactor;
	      ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
	
	      if (this.group && this.group === this.canvas.getActiveGroup()) {
	        ctx.rotate(degreesToRadians(options.angle));
	        this.drawBordersInGroup(ctx, options);
	      }
	      else {
	        ctx.rotate(degreesToRadians(this.angle));
	        this.drawBorders(ctx);
	      }
	      this.drawControls(ctx);
	      ctx.restore();
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _setShadow: function(ctx) {
	      if (!this.shadow) {
	        return;
	      }
	
	      var multX = (this.canvas && this.canvas.viewportTransform[0]) || 1,
	          multY = (this.canvas && this.canvas.viewportTransform[3]) || 1,
	          scaling = this.getObjectScaling();
	      if (this.canvas && this.canvas._isRetinaScaling()) {
	        multX *= fabric.devicePixelRatio;
	        multY *= fabric.devicePixelRatio;
	      }
	      ctx.shadowColor = this.shadow.color;
	      ctx.shadowBlur = this.shadow.blur * (multX + multY) * (scaling.scaleX + scaling.scaleY) / 4;
	      ctx.shadowOffsetX = this.shadow.offsetX * multX * scaling.scaleX;
	      ctx.shadowOffsetY = this.shadow.offsetY * multY * scaling.scaleY;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _removeShadow: function(ctx) {
	      if (!this.shadow) {
	        return;
	      }
	
	      ctx.shadowColor = '';
	      ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderFill: function(ctx) {
	      if (!this.fill) {
	        return;
	      }
	
	      ctx.save();
	      if (this.fill.gradientTransform) {
	        var g = this.fill.gradientTransform;
	        ctx.transform.apply(ctx, g);
	      }
	      if (this.fill.toLive) {
	        ctx.translate(
	          -this.width / 2 + this.fill.offsetX || 0,
	          -this.height / 2 + this.fill.offsetY || 0);
	      }
	      if (this.fillRule === 'evenodd') {
	        ctx.fill('evenodd');
	      }
	      else {
	        ctx.fill();
	      }
	      ctx.restore();
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderStroke: function(ctx) {
	      if (!this.stroke || this.strokeWidth === 0) {
	        return;
	      }
	
	      if (this.shadow && !this.shadow.affectStroke) {
	        this._removeShadow(ctx);
	      }
	
	      ctx.save();
	
	      this._setLineDash(ctx, this.strokeDashArray, this._renderDashedStroke);
	      if (this.stroke.gradientTransform) {
	        var g = this.stroke.gradientTransform;
	        ctx.transform.apply(ctx, g);
	      }
	      if (this.stroke.toLive) {
	        ctx.translate(
	          -this.width / 2 + this.stroke.offsetX || 0,
	          -this.height / 2 + this.stroke.offsetY || 0);
	      }
	      ctx.stroke();
	      ctx.restore();
	    },
	
	    /**
	     * Clones an instance, some objects are async, so using callback method will work for every object.
	     * Using the direct return does not work for images and groups.
	     * @param {Function} callback Callback is invoked with a clone as a first argument
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {fabric.Object} clone of an instance
	     */
	    clone: function(callback, propertiesToInclude) {
	      if (this.constructor.fromObject) {
	        return this.constructor.fromObject(this.toObject(propertiesToInclude), callback);
	      }
	      return new fabric.Object(this.toObject(propertiesToInclude));
	    },
	
	    /**
	     * Creates an instance of fabric.Image out of an object
	     * @param {Function} callback callback, invoked with an instance as a first argument
	     * @param {Object} [options] for clone as image, passed to toDataURL
	     * @param {Boolean} [options.enableRetinaScaling] enable retina scaling for the cloned image
	     * @return {fabric.Object} thisArg
	     */
	    cloneAsImage: function(callback, options) {
	      var dataUrl = this.toDataURL(options);
	      fabric.util.loadImage(dataUrl, function(img) {
	        if (callback) {
	          callback(new fabric.Image(img));
	        }
	      });
	      return this;
	    },
	
	    /**
	     * Converts an object into a data-url-like string
	     * @param {Object} options Options object
	     * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
	     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
	     * @param {Number} [options.multiplier=1] Multiplier to scale by
	     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
	     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
	     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
	     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
	     * @param {Boolean} [options.enableRetina] Enable retina scaling for clone image. Introduce in 1.6.4
	     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
	     */
	    toDataURL: function(options) {
	      options || (options = { });
	
	      var el = fabric.util.createCanvasElement(),
	          boundingRect = this.getBoundingRect();
	
	      el.width = boundingRect.width;
	      el.height = boundingRect.height;
	      fabric.util.wrapElement(el, 'div');
	      var canvas = new fabric.StaticCanvas(el, { enableRetinaScaling: options.enableRetinaScaling });
	      // to avoid common confusion https://github.com/kangax/fabric.js/issues/806
	      if (options.format === 'jpg') {
	        options.format = 'jpeg';
	      }
	
	      if (options.format === 'jpeg') {
	        canvas.backgroundColor = '#fff';
	      }
	
	      var origParams = {
	        active: this.get('active'),
	        left: this.getLeft(),
	        top: this.getTop()
	      };
	
	      this.set('active', false);
	      this.setPositionByOrigin(new fabric.Point(canvas.getWidth() / 2, canvas.getHeight() / 2), 'center', 'center');
	
	      var originalCanvas = this.canvas;
	      canvas.add(this);
	      var data = canvas.toDataURL(options);
	
	      this.set(origParams).setCoords();
	      this.canvas = originalCanvas;
	
	      canvas.dispose();
	      canvas = null;
	
	      return data;
	    },
	
	    /**
	     * Returns true if specified type is identical to the type of an instance
	     * @param {String} type Type to check against
	     * @return {Boolean}
	     */
	    isType: function(type) {
	      return this.type === type;
	    },
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity of this instance
	     */
	    complexity: function() {
	      return 0;
	    },
	
	    /**
	     * Returns a JSON representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} JSON
	     */
	    toJSON: function(propertiesToInclude) {
	      // delegate, not alias
	      return this.toObject(propertiesToInclude);
	    },
	
	    /**
	     * Sets gradient (fill or stroke) of an object
	     * <b>Backwards incompatibility note:</b> This method was named "setGradientFill" until v1.1.0
	     * @param {String} property Property name 'stroke' or 'fill'
	     * @param {Object} [options] Options object
	     * @param {String} [options.type] Type of gradient 'radial' or 'linear'
	     * @param {Number} [options.x1=0] x-coordinate of start point
	     * @param {Number} [options.y1=0] y-coordinate of start point
	     * @param {Number} [options.x2=0] x-coordinate of end point
	     * @param {Number} [options.y2=0] y-coordinate of end point
	     * @param {Number} [options.r1=0] Radius of start point (only for radial gradients)
	     * @param {Number} [options.r2=0] Radius of end point (only for radial gradients)
	     * @param {Object} [options.colorStops] Color stops object eg. {0: 'ff0000', 1: '000000'}
	     * @param {Object} [options.gradientTransform] transforMatrix for gradient
	     * @return {fabric.Object} thisArg
	     * @chainable
	     * @see {@link http://jsfiddle.net/fabricjs/58y8b/|jsFiddle demo}
	     * @example <caption>Set linear gradient</caption>
	     * object.setGradient('fill', {
	     *   type: 'linear',
	     *   x1: -object.width / 2,
	     *   y1: 0,
	     *   x2: object.width / 2,
	     *   y2: 0,
	     *   colorStops: {
	     *     0: 'red',
	     *     0.5: '#005555',
	     *     1: 'rgba(0,0,255,0.5)'
	     *   }
	     * });
	     * canvas.renderAll();
	     * @example <caption>Set radial gradient</caption>
	     * object.setGradient('fill', {
	     *   type: 'radial',
	     *   x1: 0,
	     *   y1: 0,
	     *   x2: 0,
	     *   y2: 0,
	     *   r1: object.width / 2,
	     *   r2: 10,
	     *   colorStops: {
	     *     0: 'red',
	     *     0.5: '#005555',
	     *     1: 'rgba(0,0,255,0.5)'
	     *   }
	     * });
	     * canvas.renderAll();
	     */
	    setGradient: function(property, options) {
	      options || (options = { });
	
	      var gradient = { colorStops: [] };
	
	      gradient.type = options.type || (options.r1 || options.r2 ? 'radial' : 'linear');
	      gradient.coords = {
	        x1: options.x1,
	        y1: options.y1,
	        x2: options.x2,
	        y2: options.y2
	      };
	
	      if (options.r1 || options.r2) {
	        gradient.coords.r1 = options.r1;
	        gradient.coords.r2 = options.r2;
	      }
	
	      options.gradientTransform && (gradient.gradientTransform = options.gradientTransform);
	
	      for (var position in options.colorStops) {
	        var color = new fabric.Color(options.colorStops[position]);
	        gradient.colorStops.push({
	          offset: position,
	          color: color.toRgb(),
	          opacity: color.getAlpha()
	        });
	      }
	
	      return this.set(property, fabric.Gradient.forObject(this, gradient));
	    },
	
	    /**
	     * Sets pattern fill of an object
	     * @param {Object} options Options object
	     * @param {(String|HTMLImageElement)} options.source Pattern source
	     * @param {String} [options.repeat=repeat] Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)
	     * @param {Number} [options.offsetX=0] Pattern horizontal offset from object's left/top corner
	     * @param {Number} [options.offsetY=0] Pattern vertical offset from object's left/top corner
	     * @return {fabric.Object} thisArg
	     * @chainable
	     * @see {@link http://jsfiddle.net/fabricjs/QT3pa/|jsFiddle demo}
	     * @example <caption>Set pattern</caption>
	     * fabric.util.loadImage('http://fabricjs.com/assets/escheresque_ste.png', function(img) {
	     *   object.setPatternFill({
	     *     source: img,
	     *     repeat: 'repeat'
	     *   });
	     *   canvas.renderAll();
	     * });
	     */
	    setPatternFill: function(options) {
	      return this.set('fill', new fabric.Pattern(options));
	    },
	
	    /**
	     * Sets {@link fabric.Object#shadow|shadow} of an object
	     * @param {Object|String} [options] Options object or string (e.g. "2px 2px 10px rgba(0,0,0,0.2)")
	     * @param {String} [options.color=rgb(0,0,0)] Shadow color
	     * @param {Number} [options.blur=0] Shadow blur
	     * @param {Number} [options.offsetX=0] Shadow horizontal offset
	     * @param {Number} [options.offsetY=0] Shadow vertical offset
	     * @return {fabric.Object} thisArg
	     * @chainable
	     * @see {@link http://jsfiddle.net/fabricjs/7gvJG/|jsFiddle demo}
	     * @example <caption>Set shadow with string notation</caption>
	     * object.setShadow('2px 2px 10px rgba(0,0,0,0.2)');
	     * canvas.renderAll();
	     * @example <caption>Set shadow with object notation</caption>
	     * object.setShadow({
	     *   color: 'red',
	     *   blur: 10,
	     *   offsetX: 20,
	     *   offsetY: 20
	     * });
	     * canvas.renderAll();
	     */
	    setShadow: function(options) {
	      return this.set('shadow', options ? new fabric.Shadow(options) : null);
	    },
	
	    /**
	     * Sets "color" of an instance (alias of `set('fill', &hellip;)`)
	     * @param {String} color Color value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    setColor: function(color) {
	      this.set('fill', color);
	      return this;
	    },
	
	    /**
	     * Sets "angle" of an instance
	     * @param {Number} angle Angle value (in degrees)
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    setAngle: function(angle) {
	      var shouldCenterOrigin = (this.originX !== 'center' || this.originY !== 'center') && this.centeredRotation;
	
	      if (shouldCenterOrigin) {
	        this._setOriginToCenter();
	      }
	
	      this.set('angle', angle);
	
	      if (shouldCenterOrigin) {
	        this._resetOrigin();
	      }
	
	      return this;
	    },
	
	    /**
	     * Centers object horizontally on canvas to which it was added last.
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    centerH: function () {
	      this.canvas && this.canvas.centerObjectH(this);
	      return this;
	    },
	
	    /**
	     * Centers object horizontally on current viewport of canvas to which it was added last.
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    viewportCenterH: function () {
	      this.canvas && this.canvas.viewportCenterObjectH(this);
	      return this;
	    },
	
	    /**
	     * Centers object vertically on canvas to which it was added last.
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    centerV: function () {
	      this.canvas && this.canvas.centerObjectV(this);
	      return this;
	    },
	
	    /**
	     * Centers object vertically on current viewport of canvas to which it was added last.
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    viewportCenterV: function () {
	      this.canvas && this.canvas.viewportCenterObjectV(this);
	      return this;
	    },
	
	    /**
	     * Centers object vertically and horizontally on canvas to which is was added last
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    center: function () {
	      this.canvas && this.canvas.centerObject(this);
	      return this;
	    },
	
	    /**
	     * Centers object on current viewport of canvas to which it was added last.
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    viewportCenter: function () {
	      this.canvas && this.canvas.viewportCenterObject(this);
	      return this;
	    },
	
	    /**
	     * Removes object from canvas to which it was added last
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    remove: function() {
	      this.canvas && this.canvas.remove(this);
	      return this;
	    },
	
	    /**
	     * Returns coordinates of a pointer relative to an object
	     * @param {Event} e Event to operate upon
	     * @param {Object} [pointer] Pointer to operate upon (instead of event)
	     * @return {Object} Coordinates of a pointer (x, y)
	     */
	    getLocalPointer: function(e, pointer) {
	      pointer = pointer || this.canvas.getPointer(e);
	      var pClicked = new fabric.Point(pointer.x, pointer.y),
	          objectLeftTop = this._getLeftTopCoords();
	      if (this.angle) {
	        pClicked = fabric.util.rotatePoint(
	          pClicked, objectLeftTop, fabric.util.degreesToRadians(-this.angle));
	      }
	      return {
	        x: pClicked.x - objectLeftTop.x,
	        y: pClicked.y - objectLeftTop.y
	      };
	    },
	
	    /**
	     * Sets canvas globalCompositeOperation for specific object
	     * custom composition operation for the particular object can be specifed using globalCompositeOperation property
	     * @param {CanvasRenderingContext2D} ctx Rendering canvas context
	     */
	    _setupCompositeOperation: function (ctx) {
	      if (this.globalCompositeOperation) {
	        ctx.globalCompositeOperation = this.globalCompositeOperation;
	      }
	    }
	  });
	
	  fabric.util.createAccessors(fabric.Object);
	
	  /**
	   * Alias for {@link fabric.Object.prototype.setAngle}
	   * @alias rotate -> setAngle
	   * @memberOf fabric.Object
	   */
	  fabric.Object.prototype.rotate = fabric.Object.prototype.setAngle;
	
	  extend(fabric.Object.prototype, fabric.Observable);
	
	  /**
	   * Defines the number of fraction digits to use when serializing object values.
	   * You can use it to increase/decrease precision of such values like left, top, scaleX, scaleY, etc.
	   * @static
	   * @memberOf fabric.Object
	   * @constant
	   * @type Number
	   */
	  fabric.Object.NUM_FRACTION_DIGITS = 2;
	
	  /**
	   * Unique id used internally when creating SVG elements
	   * @static
	   * @memberOf fabric.Object
	   * @type Number
	   */
	  fabric.Object.__uid = 0;
	
	})( true ? exports : this);
	
	
	(function() {
	
	  var degreesToRadians = fabric.util.degreesToRadians,
	      originXOffset = {
	        left: -0.5,
	        center: 0,
	        right: 0.5
	      },
	      originYOffset = {
	        top: -0.5,
	        center: 0,
	        bottom: 0.5
	      };
	
	  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
	
	    /**
	     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)
	     * @param {fabric.Point} point The point which corresponds to the originX and originY params
	     * @param {String} fromOriginX Horizontal origin: 'left', 'center' or 'right'
	     * @param {String} fromOriginY Vertical origin: 'top', 'center' or 'bottom'
	     * @param {String} toOriginX Horizontal origin: 'left', 'center' or 'right'
	     * @param {String} toOriginY Vertical origin: 'top', 'center' or 'bottom'
	     * @return {fabric.Point}
	     */
	    translateToGivenOrigin: function(point, fromOriginX, fromOriginY, toOriginX, toOriginY) {
	      var x = point.x,
	          y = point.y,
	          offsetX, offsetY, dim;
	
	      if (typeof fromOriginX === 'string') {
	        fromOriginX = originXOffset[fromOriginX];
	      }
	      else {
	        fromOriginX -= 0.5;
	      }
	
	      if (typeof toOriginX === 'string') {
	        toOriginX = originXOffset[toOriginX];
	      }
	      else {
	        toOriginX -= 0.5;
	      }
	
	      offsetX = toOriginX - fromOriginX;
	
	      if (typeof fromOriginY === 'string') {
	        fromOriginY = originYOffset[fromOriginY];
	      }
	      else {
	        fromOriginY -= 0.5;
	      }
	
	      if (typeof toOriginY === 'string') {
	        toOriginY = originYOffset[toOriginY];
	      }
	      else {
	        toOriginY -= 0.5;
	      }
	
	      offsetY = toOriginY - fromOriginY;
	
	      if (offsetX || offsetY) {
	        dim = this._getTransformedDimensions();
	        x = point.x + offsetX * dim.x;
	        y = point.y + offsetY * dim.y;
	      }
	
	      return new fabric.Point(x, y);
	    },
	
	    /**
	     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)
	     * @param {fabric.Point} point The point which corresponds to the originX and originY params
	     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
	     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
	     * @return {fabric.Point}
	     */
	    translateToCenterPoint: function(point, originX, originY) {
	      var p = this.translateToGivenOrigin(point, originX, originY, 'center', 'center');
	      if (this.angle) {
	        return fabric.util.rotatePoint(p, point, degreesToRadians(this.angle));
	      }
	      return p;
	    },
	
	    /**
	     * Translates the coordinates from center to origin coordinates (based on the object's dimensions)
	     * @param {fabric.Point} center The point which corresponds to center of the object
	     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
	     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
	     * @return {fabric.Point}
	     */
	    translateToOriginPoint: function(center, originX, originY) {
	      var p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
	      if (this.angle) {
	        return fabric.util.rotatePoint(p, center, degreesToRadians(this.angle));
	      }
	      return p;
	    },
	
	    /**
	     * Returns the real center coordinates of the object
	     * @return {fabric.Point}
	     */
	    getCenterPoint: function() {
	      var leftTop = new fabric.Point(this.left, this.top);
	      return this.translateToCenterPoint(leftTop, this.originX, this.originY);
	    },
	
	    /**
	     * Returns the coordinates of the object based on center coordinates
	     * @param {fabric.Point} point The point which corresponds to the originX and originY params
	     * @return {fabric.Point}
	     */
	    // getOriginPoint: function(center) {
	    //   return this.translateToOriginPoint(center, this.originX, this.originY);
	    // },
	
	    /**
	     * Returns the coordinates of the object as if it has a different origin
	     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
	     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
	     * @return {fabric.Point}
	     */
	    getPointByOrigin: function(originX, originY) {
	      var center = this.getCenterPoint();
	      return this.translateToOriginPoint(center, originX, originY);
	    },
	
	    /**
	     * Returns the point in local coordinates
	     * @param {fabric.Point} point The point relative to the global coordinate system
	     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
	     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
	     * @return {fabric.Point}
	     */
	    toLocalPoint: function(point, originX, originY) {
	      var center = this.getCenterPoint(),
	          p, p2;
	
	      if (typeof originX !== 'undefined' && typeof originY !== 'undefined' ) {
	        p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
	      }
	      else {
	        p = new fabric.Point(this.left, this.top);
	      }
	
	      p2 = new fabric.Point(point.x, point.y);
	      if (this.angle) {
	        p2 = fabric.util.rotatePoint(p2, center, -degreesToRadians(this.angle));
	      }
	      return p2.subtractEquals(p);
	    },
	
	    /**
	     * Returns the point in global coordinates
	     * @param {fabric.Point} The point relative to the local coordinate system
	     * @return {fabric.Point}
	     */
	    // toGlobalPoint: function(point) {
	    //   return fabric.util.rotatePoint(point, this.getCenterPoint(), degreesToRadians(this.angle)).addEquals(new fabric.Point(this.left, this.top));
	    // },
	
	    /**
	     * Sets the position of the object taking into consideration the object's origin
	     * @param {fabric.Point} pos The new position of the object
	     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
	     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
	     * @return {void}
	     */
	    setPositionByOrigin: function(pos, originX, originY) {
	      var center = this.translateToCenterPoint(pos, originX, originY),
	          position = this.translateToOriginPoint(center, this.originX, this.originY);
	
	      this.set('left', position.x);
	      this.set('top', position.y);
	    },
	
	    /**
	     * @param {String} to One of 'left', 'center', 'right'
	     */
	    adjustPosition: function(to) {
	      var angle = degreesToRadians(this.angle),
	          hypotFull = this.getWidth(),
	          xFull = Math.cos(angle) * hypotFull,
	          yFull = Math.sin(angle) * hypotFull,
	          offsetFrom, offsetTo;
	
	      //TODO: this function does not consider mixed situation like top, center.
	      if (typeof this.originX === 'string') {
	        offsetFrom = originXOffset[this.originX];
	      }
	      else {
	        offsetFrom = this.originX - 0.5;
	      }
	      if (typeof to === 'string') {
	        offsetTo = originXOffset[to];
	      }
	      else {
	        offsetTo = to - 0.5;
	      }
	      this.left += xFull * (offsetTo - offsetFrom);
	      this.top += yFull * (offsetTo - offsetFrom);
	      this.setCoords();
	      this.originX = to;
	    },
	
	    /**
	     * Sets the origin/position of the object to it's center point
	     * @private
	     * @return {void}
	     */
	    _setOriginToCenter: function() {
	      this._originalOriginX = this.originX;
	      this._originalOriginY = this.originY;
	
	      var center = this.getCenterPoint();
	
	      this.originX = 'center';
	      this.originY = 'center';
	
	      this.left = center.x;
	      this.top = center.y;
	    },
	
	    /**
	     * Resets the origin/position of the object to it's original origin
	     * @private
	     * @return {void}
	     */
	    _resetOrigin: function() {
	      var originPoint = this.translateToOriginPoint(
	        this.getCenterPoint(),
	        this._originalOriginX,
	        this._originalOriginY);
	
	      this.originX = this._originalOriginX;
	      this.originY = this._originalOriginY;
	
	      this.left = originPoint.x;
	      this.top = originPoint.y;
	
	      this._originalOriginX = null;
	      this._originalOriginY = null;
	    },
	
	    /**
	     * @private
	     */
	    _getLeftTopCoords: function() {
	      return this.translateToOriginPoint(this.getCenterPoint(), 'left', 'top');
	    }
	  });
	
	})();
	
	
	(function() {
	
	  function getCoords(oCoords) {
	    return [
	      new fabric.Point(oCoords.tl.x, oCoords.tl.y),
	      new fabric.Point(oCoords.tr.x, oCoords.tr.y),
	      new fabric.Point(oCoords.br.x, oCoords.br.y),
	      new fabric.Point(oCoords.bl.x, oCoords.bl.y)
	    ];
	  }
	
	  var degreesToRadians = fabric.util.degreesToRadians,
	      multiplyMatrices = fabric.util.multiplyTransformMatrices;
	
	  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
	
	    /**
	     * Object containing coordinates of object's controls
	     * @type Object
	     * @default
	     */
	    oCoords: null,
	
	    /**
	     * Checks if object intersects with an area formed by 2 points
	     * @param {Object} pointTL top-left point of area
	     * @param {Object} pointBR bottom-right point of area
	     * @return {Boolean} true if object intersects with an area formed by 2 points
	     */
	    intersectsWithRect: function(pointTL, pointBR) {
	      var oCoords = getCoords(this.oCoords),
	          intersection = fabric.Intersection.intersectPolygonRectangle(
	            oCoords,
	            pointTL,
	            pointBR
	          );
	      return intersection.status === 'Intersection';
	    },
	
	    /**
	     * Checks if object intersects with another object
	     * @param {Object} other Object to test
	     * @return {Boolean} true if object intersects with another object
	     */
	    intersectsWithObject: function(other) {
	      var intersection = fabric.Intersection.intersectPolygonPolygon(
	            getCoords(this.oCoords),
	            getCoords(other.oCoords)
	          );
	
	      return intersection.status === 'Intersection'
	        || other.isContainedWithinObject(this)
	        || this.isContainedWithinObject(other);
	    },
	
	    /**
	     * Checks if object is fully contained within area of another object
	     * @param {Object} other Object to test
	     * @return {Boolean} true if object is fully contained within area of another object
	     */
	    isContainedWithinObject: function(other) {
	      var points = getCoords(this.oCoords),
	          i = 0;
	      for (; i < 4; i++) {
	        if (!other.containsPoint(points[i])) {
	          return false;
	        }
	      }
	      return true;
	    },
	
	    /**
	     * Checks if object is fully contained within area formed by 2 points
	     * @param {Object} pointTL top-left point of area
	     * @param {Object} pointBR bottom-right point of area
	     * @return {Boolean} true if object is fully contained within area formed by 2 points
	     */
	    isContainedWithinRect: function(pointTL, pointBR) {
	      var boundingRect = this.getBoundingRect();
	
	      return (
	        boundingRect.left >= pointTL.x &&
	        boundingRect.left + boundingRect.width <= pointBR.x &&
	        boundingRect.top >= pointTL.y &&
	        boundingRect.top + boundingRect.height <= pointBR.y
	      );
	    },
	
	    /**
	     * Checks if point is inside the object
	     * @param {fabric.Point} point Point to check against
	     * @return {Boolean} true if point is inside the object
	     */
	    containsPoint: function(point) {
	      if (!this.oCoords) {
	        this.setCoords();
	      }
	      var lines = this._getImageLines(this.oCoords),
	          xPoints = this._findCrossPoints(point, lines);
	
	      // if xPoints is odd then point is inside the object
	      return (xPoints !== 0 && xPoints % 2 === 1);
	    },
	
	    /**
	     * Method that returns an object with the object edges in it, given the coordinates of the corners
	     * @private
	     * @param {Object} oCoords Coordinates of the object corners
	     */
	    _getImageLines: function(oCoords) {
	      return {
	        topline: {
	          o: oCoords.tl,
	          d: oCoords.tr
	        },
	        rightline: {
	          o: oCoords.tr,
	          d: oCoords.br
	        },
	        bottomline: {
	          o: oCoords.br,
	          d: oCoords.bl
	        },
	        leftline: {
	          o: oCoords.bl,
	          d: oCoords.tl
	        }
	      };
	    },
	
	    /**
	     * Helper method to determine how many cross points are between the 4 object edges
	     * and the horizontal line determined by a point on canvas
	     * @private
	     * @param {fabric.Point} point Point to check
	     * @param {Object} oCoords Coordinates of the object being evaluated
	     */
	     // remove yi, not used but left code here just in case.
	    _findCrossPoints: function(point, oCoords) {
	      var b1, b2, a1, a2, xi, // yi,
	          xcount = 0,
	          iLine;
	
	      for (var lineKey in oCoords) {
	        iLine = oCoords[lineKey];
	        // optimisation 1: line below point. no cross
	        if ((iLine.o.y < point.y) && (iLine.d.y < point.y)) {
	          continue;
	        }
	        // optimisation 2: line above point. no cross
	        if ((iLine.o.y >= point.y) && (iLine.d.y >= point.y)) {
	          continue;
	        }
	        // optimisation 3: vertical line case
	        if ((iLine.o.x === iLine.d.x) && (iLine.o.x >= point.x)) {
	          xi = iLine.o.x;
	          // yi = point.y;
	        }
	        // calculate the intersection point
	        else {
	          b1 = 0;
	          b2 = (iLine.d.y - iLine.o.y) / (iLine.d.x - iLine.o.x);
	          a1 = point.y - b1 * point.x;
	          a2 = iLine.o.y - b2 * iLine.o.x;
	
	          xi = -(a1 - a2) / (b1 - b2);
	          // yi = a1 + b1 * xi;
	        }
	        // dont count xi < point.x cases
	        if (xi >= point.x) {
	          xcount += 1;
	        }
	        // optimisation 4: specific for square images
	        if (xcount === 2) {
	          break;
	        }
	      }
	      return xcount;
	    },
	
	    /**
	     * Returns width of an object's bounding rectangle
	     * @deprecated since 1.0.4
	     * @return {Number} width value
	     */
	    getBoundingRectWidth: function() {
	      return this.getBoundingRect().width;
	    },
	
	    /**
	     * Returns height of an object's bounding rectangle
	     * @deprecated since 1.0.4
	     * @return {Number} height value
	     */
	    getBoundingRectHeight: function() {
	      return this.getBoundingRect().height;
	    },
	
	    /**
	     * Returns coordinates of object's bounding rectangle (left, top, width, height)
	     * @return {Object} Object with left, top, width, height properties
	     */
	    getBoundingRect: function() {
	      this.oCoords || this.setCoords();
	      return fabric.util.makeBoundingBoxFromPoints([
	        this.oCoords.tl,
	        this.oCoords.tr,
	        this.oCoords.br,
	        this.oCoords.bl
	      ]);
	    },
	
	    /**
	     * Returns width of an object bounding box counting transformations
	     * @return {Number} width value
	     */
	    getWidth: function() {
	      return this._getTransformedDimensions().x;
	    },
	
	    /**
	     * Returns height of an object bounding box counting transformations
	     * to be renamed in 2.0
	     * @return {Number} height value
	     */
	    getHeight: function() {
	      return this._getTransformedDimensions().y;
	    },
	
	    /**
	     * Makes sure the scale is valid and modifies it if necessary
	     * @private
	     * @param {Number} value
	     * @return {Number}
	     */
	    _constrainScale: function(value) {
	      if (Math.abs(value) < this.minScaleLimit) {
	        if (value < 0) {
	          return -this.minScaleLimit;
	        }
	        else {
	          return this.minScaleLimit;
	        }
	      }
	      return value;
	    },
	
	    /**
	     * Scales an object (equally by x and y)
	     * @param {Number} value Scale factor
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    scale: function(value) {
	      value = this._constrainScale(value);
	
	      if (value < 0) {
	        this.flipX = !this.flipX;
	        this.flipY = !this.flipY;
	        value *= -1;
	      }
	
	      this.scaleX = value;
	      this.scaleY = value;
	      this.setCoords();
	      return this;
	    },
	
	    /**
	     * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)
	     * @param {Number} value New width value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    scaleToWidth: function(value) {
	      // adjust to bounding rect factor so that rotated shapes would fit as well
	      var boundingRectFactor = this.getBoundingRect().width / this.getWidth();
	      return this.scale(value / this.width / boundingRectFactor);
	    },
	
	    /**
	     * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)
	     * @param {Number} value New height value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    scaleToHeight: function(value) {
	      // adjust to bounding rect factor so that rotated shapes would fit as well
	      var boundingRectFactor = this.getBoundingRect().height / this.getHeight();
	      return this.scale(value / this.height / boundingRectFactor);
	    },
	
	    /**
	     * Sets corner position coordinates based on current angle, width and height
	     * See https://github.com/kangax/fabric.js/wiki/When-to-call-setCoords
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    setCoords: function() {
	      var theta = degreesToRadians(this.angle),
	          vpt = this.getViewportTransform(),
	          dim = this._calculateCurrentDimensions(),
	          currentWidth = dim.x, currentHeight = dim.y;
	
	      // If width is negative, make postive. Fixes path selection issue
	      if (currentWidth < 0) {
	        currentWidth = Math.abs(currentWidth);
	      }
	
	      var sinTh = Math.sin(theta),
	          cosTh = Math.cos(theta),
	          _angle = currentWidth > 0 ? Math.atan(currentHeight / currentWidth) : 0,
	          _hypotenuse = (currentWidth / Math.cos(_angle)) / 2,
	          offsetX = Math.cos(_angle + theta) * _hypotenuse,
	          offsetY = Math.sin(_angle + theta) * _hypotenuse,
	
	          // offset added for rotate and scale actions
	          coords = fabric.util.transformPoint(this.getCenterPoint(), vpt),
	          tl  = new fabric.Point(coords.x - offsetX, coords.y - offsetY),
	          tr  = new fabric.Point(tl.x + (currentWidth * cosTh), tl.y + (currentWidth * sinTh)),
	          bl  = new fabric.Point(tl.x - (currentHeight * sinTh), tl.y + (currentHeight * cosTh)),
	          br  = new fabric.Point(coords.x + offsetX, coords.y + offsetY),
	          ml  = new fabric.Point((tl.x + bl.x) / 2, (tl.y + bl.y) / 2),
	          mt  = new fabric.Point((tr.x + tl.x) / 2, (tr.y + tl.y) / 2),
	          mr  = new fabric.Point((br.x + tr.x) / 2, (br.y + tr.y) / 2),
	          mb  = new fabric.Point((br.x + bl.x) / 2, (br.y + bl.y) / 2),
	          mtr = new fabric.Point(mt.x + sinTh * this.rotatingPointOffset, mt.y - cosTh * this.rotatingPointOffset);
	      // debugging
	
	      /* setTimeout(function() {
	         canvas.contextTop.fillStyle = 'green';
	         canvas.contextTop.fillRect(mb.x, mb.y, 3, 3);
	         canvas.contextTop.fillRect(bl.x, bl.y, 3, 3);
	         canvas.contextTop.fillRect(br.x, br.y, 3, 3);
	         canvas.contextTop.fillRect(tl.x, tl.y, 3, 3);
	         canvas.contextTop.fillRect(tr.x, tr.y, 3, 3);
	         canvas.contextTop.fillRect(ml.x, ml.y, 3, 3);
	         canvas.contextTop.fillRect(mr.x, mr.y, 3, 3);
	         canvas.contextTop.fillRect(mt.x, mt.y, 3, 3);
	         canvas.contextTop.fillRect(mtr.x, mtr.y, 3, 3);
	       }, 50); */
	
	      this.oCoords = {
	        // corners
	        tl: tl, tr: tr, br: br, bl: bl,
	        // middle
	        ml: ml, mt: mt, mr: mr, mb: mb,
	        // rotating point
	        mtr: mtr
	      };
	
	      // set coordinates of the draggable boxes in the corners used to scale/rotate the image
	      this._setCornerCoords && this._setCornerCoords();
	
	      return this;
	    },
	
	    /*
	     * calculate rotation matrix of an object
	     * @return {Array} rotation matrix for the object
	     */
	    _calcRotateMatrix: function() {
	      if (this.angle) {
	        var theta = degreesToRadians(this.angle), cos = Math.cos(theta), sin = Math.sin(theta);
	        return [cos, sin, -sin, cos, 0, 0];
	      }
	      return [1, 0, 0, 1, 0, 0];
	    },
	
	    /*
	     * calculate trasform Matrix that represent current transformation from
	     * object properties.
	     * @return {Array} matrix Transform Matrix for the object
	     */
	    calcTransformMatrix: function() {
	      var center = this.getCenterPoint(),
	          translateMatrix = [1, 0, 0, 1, center.x, center.y],
	          rotateMatrix = this._calcRotateMatrix(),
	          dimensionMatrix = this._calcDimensionsTransformMatrix(this.skewX, this.skewY, true),
	          matrix = this.group ? this.group.calcTransformMatrix() : [1, 0, 0, 1, 0, 0];
	      matrix = multiplyMatrices(matrix, translateMatrix);
	      matrix = multiplyMatrices(matrix, rotateMatrix);
	      matrix = multiplyMatrices(matrix, dimensionMatrix);
	      return matrix;
	    },
	
	    _calcDimensionsTransformMatrix: function(skewX, skewY, flipping) {
	      var skewMatrixX = [1, 0, Math.tan(degreesToRadians(skewX)), 1],
	          skewMatrixY = [1, Math.tan(degreesToRadians(skewY)), 0, 1],
	          scaleX = this.scaleX * (flipping && this.flipX ? -1 : 1),
	          scaleY = this.scaleY * (flipping && this.flipY ? -1 : 1),
	          scaleMatrix = [scaleX, 0, 0, scaleY],
	          m = multiplyMatrices(scaleMatrix, skewMatrixX, true);
	      return multiplyMatrices(m, skewMatrixY, true);
	    }
	  });
	})();
	
	
	fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
	
	  /**
	   * Moves an object to the bottom of the stack of drawn objects
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  sendToBack: function() {
	    if (this.group) {
	      fabric.StaticCanvas.prototype.sendToBack.call(this.group, this);
	    }
	    else {
	      this.canvas.sendToBack(this);
	    }
	    return this;
	  },
	
	  /**
	   * Moves an object to the top of the stack of drawn objects
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  bringToFront: function() {
	    if (this.group) {
	      fabric.StaticCanvas.prototype.bringToFront.call(this.group, this);
	    }
	    else {
	      this.canvas.bringToFront(this);
	    }
	    return this;
	  },
	
	  /**
	   * Moves an object down in stack of drawn objects
	   * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  sendBackwards: function(intersecting) {
	    if (this.group) {
	      fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, intersecting);
	    }
	    else {
	      this.canvas.sendBackwards(this, intersecting);
	    }
	    return this;
	  },
	
	  /**
	   * Moves an object up in stack of drawn objects
	   * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  bringForward: function(intersecting) {
	    if (this.group) {
	      fabric.StaticCanvas.prototype.bringForward.call(this.group, this, intersecting);
	    }
	    else {
	      this.canvas.bringForward(this, intersecting);
	    }
	    return this;
	  },
	
	  /**
	   * Moves an object to specified level in stack of drawn objects
	   * @param {Number} index New position of object
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  moveTo: function(index) {
	    if (this.group) {
	      fabric.StaticCanvas.prototype.moveTo.call(this.group, this, index);
	    }
	    else {
	      this.canvas.moveTo(this, index);
	    }
	    return this;
	  }
	});
	
	
	/* _TO_SVG_START_ */
	(function() {
	
	  function getSvgColorString(prop, value) {
	    if (!value) {
	      return prop + ': none; ';
	    }
	    else if (value.toLive) {
	      return prop + ': url(#SVGID_' + value.id + '); ';
	    }
	    else {
	      var color = new fabric.Color(value),
	          str = prop + ': ' + color.toRgb() + '; ',
	          opacity = color.getAlpha();
	      if (opacity !== 1) {
	        //change the color in rgb + opacity
	        str += prop + '-opacity: ' + opacity.toString() + '; ';
	      }
	      return str;
	    }
	  }
	
	  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
	    /**
	     * Returns styles-string for svg-export
	     * @param {Boolean} skipShadow a boolean to skip shadow filter output
	     * @return {String}
	     */
	    getSvgStyles: function(skipShadow) {
	
	      var fillRule = this.fillRule,
	          strokeWidth = this.strokeWidth ? this.strokeWidth : '0',
	          strokeDashArray = this.strokeDashArray ? this.strokeDashArray.join(' ') : 'none',
	          strokeLineCap = this.strokeLineCap ? this.strokeLineCap : 'butt',
	          strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : 'miter',
	          strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : '4',
	          opacity = typeof this.opacity !== 'undefined' ? this.opacity : '1',
	          visibility = this.visible ? '' : ' visibility: hidden;',
	          filter = skipShadow ? '' : this.getSvgFilter(),
	          fill = getSvgColorString('fill', this.fill),
	          stroke = getSvgColorString('stroke', this.stroke);
	
	      return [
	        stroke,
	        'stroke-width: ', strokeWidth, '; ',
	        'stroke-dasharray: ', strokeDashArray, '; ',
	        'stroke-linecap: ', strokeLineCap, '; ',
	        'stroke-linejoin: ', strokeLineJoin, '; ',
	        'stroke-miterlimit: ', strokeMiterLimit, '; ',
	        fill,
	        'fill-rule: ', fillRule, '; ',
	        'opacity: ', opacity, ';',
	        filter,
	        visibility
	      ].join('');
	    },
	
	    /**
	     * Returns filter for svg shadow
	     * @return {String}
	     */
	    getSvgFilter: function() {
	      return this.shadow ? 'filter: url(#SVGID_' + this.shadow.id + ');' : '';
	    },
	
	    /**
	     * Returns id attribute for svg output
	     * @return {String}
	     */
	    getSvgId: function() {
	      return this.id ? 'id="' + this.id + '" ' : '';
	    },
	
	    /**
	     * Returns transform-string for svg-export
	     * @return {String}
	     */
	    getSvgTransform: function() {
	      if (this.group && this.group.type === 'path-group') {
	        return '';
	      }
	      var toFixed = fabric.util.toFixed,
	          angle = this.getAngle(),
	          skewX = (this.getSkewX() % 360),
	          skewY = (this.getSkewY() % 360),
	          center = this.getCenterPoint(),
	
	          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
	
	          translatePart = this.type === 'path-group' ? '' : 'translate(' +
	                            toFixed(center.x, NUM_FRACTION_DIGITS) +
	                            ' ' +
	                            toFixed(center.y, NUM_FRACTION_DIGITS) +
	                          ')',
	
	          anglePart = angle !== 0
	            ? (' rotate(' + toFixed(angle, NUM_FRACTION_DIGITS) + ')')
	            : '',
	
	          scalePart = (this.scaleX === 1 && this.scaleY === 1)
	            ? '' :
	            (' scale(' +
	              toFixed(this.scaleX, NUM_FRACTION_DIGITS) +
	              ' ' +
	              toFixed(this.scaleY, NUM_FRACTION_DIGITS) +
	            ')'),
	
	          skewXPart = skewX !== 0 ? ' skewX(' + toFixed(skewX, NUM_FRACTION_DIGITS) + ')' : '',
	
	          skewYPart = skewY !== 0 ? ' skewY(' + toFixed(skewY, NUM_FRACTION_DIGITS) + ')' : '',
	
	          addTranslateX = this.type === 'path-group' ? this.width : 0,
	
	          flipXPart = this.flipX ? ' matrix(-1 0 0 1 ' + addTranslateX + ' 0) ' : '',
	
	          addTranslateY = this.type === 'path-group' ? this.height : 0,
	
	          flipYPart = this.flipY ? ' matrix(1 0 0 -1 0 ' + addTranslateY + ')' : '';
	
	      return [
	        translatePart, anglePart, scalePart, flipXPart, flipYPart, skewXPart, skewYPart
	      ].join('');
	    },
	
	    /**
	     * Returns transform-string for svg-export from the transform matrix of single elements
	     * @return {String}
	     */
	    getSvgTransformMatrix: function() {
	      return this.transformMatrix ? ' matrix(' + this.transformMatrix.join(' ') + ') ' : '';
	    },
	
	    /**
	     * @private
	     */
	    _createBaseSVGMarkup: function() {
	      var markup = [];
	
	      if (this.fill && this.fill.toLive) {
	        markup.push(this.fill.toSVG(this, false));
	      }
	      if (this.stroke && this.stroke.toLive) {
	        markup.push(this.stroke.toSVG(this, false));
	      }
	      if (this.shadow) {
	        markup.push(this.shadow.toSVG(this));
	      }
	      return markup;
	    }
	  });
	})();
	/* _TO_SVG_END_ */
	
	
	(function() {
	
	  var extend = fabric.util.object.extend;
	
	  /*
	    Depends on `stateProperties`
	  */
	  function saveProps(origin, destination, props) {
	    var tmpObj = { }, deep = true;
	    props.forEach(function(prop) {
	      tmpObj[prop] = origin[prop];
	    });
	    extend(origin[destination], tmpObj, deep);
	  }
	
	  function _isEqual(origValue, currentValue) {
	    if (!fabric.isLikelyNode && origValue instanceof Element) {
	      // avoid checking deep html elements
	      return origValue === currentValue;
	    }
	    else if (origValue instanceof Array) {
	      if (origValue.length !== currentValue.length) {
	        return false
	      }
	      var _currentValue = currentValue.concat().sort(),
	          _origValue = origValue.concat().sort();
	      return !_origValue.some(function(v, i) {
	        return !_isEqual(_currentValue[i], v);
	      });
	    }
	    else if (origValue instanceof Object) {
	      for (var key in origValue) {
	        if (!_isEqual(origValue[key], currentValue[key])) {
	          return false;
	        }
	      }
	      return true;
	    }
	    else {
	      return origValue === currentValue;
	    }
	  }
	
	
	  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
	
	    /**
	     * Returns true if object state (one of its state properties) was changed
	     * @return {Boolean} true if instance' state has changed since `{@link fabric.Object#saveState}` was called
	     */
	    hasStateChanged: function() {
	      return !_isEqual(this.originalState, this);
	    },
	
	    /**
	     * Saves state of an object
	     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
	     * @return {fabric.Object} thisArg
	     */
	    saveState: function(options) {
	      saveProps(this, 'originalState', this.stateProperties);
	      if (options && options.stateProperties) {
	        saveProps(this, 'originalState', options.stateProperties);
	      }
	      return this;
	    },
	
	    /**
	     * Setups state of an object
	     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
	     * @return {fabric.Object} thisArg
	     */
	    setupState: function(options) {
	      this.originalState = { };
	      this.saveState(options);
	      return this;
	    }
	  });
	})();
	
	
	(function() {
	
	  var degreesToRadians = fabric.util.degreesToRadians,
	      /* eslint-disable camelcase */
	      isVML = function() { return typeof G_vmlCanvasManager !== 'undefined'; };
	      /* eslint-enable camelcase */
	  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
	
	    /**
	     * The object interactivity controls.
	     * @private
	     */
	    _controlsVisibility: null,
	
	    /**
	     * Determines which corner has been clicked
	     * @private
	     * @param {Object} pointer The pointer indicating the mouse position
	     * @return {String|Boolean} corner code (tl, tr, bl, br, etc.), or false if nothing is found
	     */
	    _findTargetCorner: function(pointer) {
	      if (!this.hasControls || !this.active) {
	        return false;
	      }
	
	      var ex = pointer.x,
	          ey = pointer.y,
	          xPoints,
	          lines;
	      this.__corner = 0;
	      for (var i in this.oCoords) {
	
	        if (!this.isControlVisible(i)) {
	          continue;
	        }
	
	        if (i === 'mtr' && !this.hasRotatingPoint) {
	          continue;
	        }
	
	        if (this.get('lockUniScaling') &&
	           (i === 'mt' || i === 'mr' || i === 'mb' || i === 'ml')) {
	          continue;
	        }
	
	        lines = this._getImageLines(this.oCoords[i].corner);
	
	        // debugging
	
	        // canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);
	        // canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);
	
	        // canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);
	        // canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);
	
	        // canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);
	        // canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);
	
	        // canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);
	        // canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);
	
	        xPoints = this._findCrossPoints({ x: ex, y: ey }, lines);
	        if (xPoints !== 0 && xPoints % 2 === 1) {
	          this.__corner = i;
	          return i;
	        }
	      }
	      return false;
	    },
	
	    /**
	     * Sets the coordinates of the draggable boxes in the corners of
	     * the image used to scale/rotate it.
	     * @private
	     */
	    _setCornerCoords: function() {
	      var coords = this.oCoords,
	          newTheta = degreesToRadians(45 - this.angle),
	          /* Math.sqrt(2 * Math.pow(this.cornerSize, 2)) / 2, */
	          /* 0.707106 stands for sqrt(2)/2 */
	          cornerHypotenuse = this.cornerSize * 0.707106,
	          cosHalfOffset = cornerHypotenuse * Math.cos(newTheta),
	          sinHalfOffset = cornerHypotenuse * Math.sin(newTheta),
	          x, y;
	
	      for (var point in coords) {
	        x = coords[point].x;
	        y = coords[point].y;
	        coords[point].corner = {
	          tl: {
	            x: x - sinHalfOffset,
	            y: y - cosHalfOffset
	          },
	          tr: {
	            x: x + cosHalfOffset,
	            y: y - sinHalfOffset
	          },
	          bl: {
	            x: x - cosHalfOffset,
	            y: y + sinHalfOffset
	          },
	          br: {
	            x: x + sinHalfOffset,
	            y: y + cosHalfOffset
	          }
	        };
	      }
	    },
	
	    /*
	     * Calculate object dimensions from its properties
	     * @private
	     */
	    _getNonTransformedDimensions: function() {
	      var strokeWidth = this.strokeWidth,
	          w = this.width,
	          h = this.height,
	          addStrokeToW = true,
	          addStrokeToH = true;
	
	      if (this.type === 'line' && this.strokeLineCap === 'butt') {
	        addStrokeToH = w;
	        addStrokeToW = h;
	      }
	
	      if (addStrokeToH) {
	        h += h < 0 ? -strokeWidth : strokeWidth;
	      }
	
	      if (addStrokeToW) {
	        w += w < 0 ? -strokeWidth : strokeWidth;
	      }
	
	      return { x: w, y: h };
	    },
	
	    /*
	     * @private
	     */
	    _getTransformedDimensions: function(skewX, skewY) {
	      if (typeof skewX === 'undefined') {
	        skewX = this.skewX;
	      }
	      if (typeof skewY === 'undefined') {
	        skewY = this.skewY;
	      }
	      var dimensions = this._getNonTransformedDimensions(),
	          dimX = dimensions.x / 2, dimY = dimensions.y / 2,
	          points = [
	            {
	              x: -dimX,
	              y: -dimY
	            },
	            {
	              x: dimX,
	              y: -dimY
	            },
	            {
	              x: -dimX,
	              y: dimY
	            },
	            {
	              x: dimX,
	              y: dimY
	            }],
	          i, transformMatrix = this._calcDimensionsTransformMatrix(skewX, skewY, false),
	          bbox;
	      for (i = 0; i < points.length; i++) {
	        points[i] = fabric.util.transformPoint(points[i], transformMatrix);
	      }
	      bbox = fabric.util.makeBoundingBoxFromPoints(points);
	      return { x: bbox.width, y: bbox.height };
	    },
	
	    /*
	     * private
	     */
	    _calculateCurrentDimensions: function()  {
	      var vpt = this.getViewportTransform(),
	          dim = this._getTransformedDimensions(),
	          w = dim.x, h = dim.y,
	          p = fabric.util.transformPoint(new fabric.Point(w, h), vpt, true);
	
	      return p.scalarAdd(2 * this.padding);
	    },
	
	    /**
	     * Draws a colored layer behind the object, inside its selection borders.
	     * Requires public options: padding, selectionBackgroundColor
	     * this function is called when the context is transformed
	     * @param {CanvasRenderingContext2D} ctx Context to draw on
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    drawSelectionBackground: function(ctx) {
	      if (!this.selectionBackgroundColor || this.group || !this.active) {
	        return this;
	      }
	      ctx.save();
	      var center = this.getCenterPoint(), wh = this._calculateCurrentDimensions(),
	          vpt = this.canvas.viewportTransform;
	      ctx.translate(center.x, center.y);
	      ctx.scale(1 / vpt[0], 1 / vpt[3]);
	      ctx.rotate(degreesToRadians(this.angle));
	      ctx.fillStyle = this.selectionBackgroundColor;
	      ctx.fillRect(-wh.x / 2, -wh.y / 2, wh.x, wh.y);
	      ctx.restore();
	      return this;
	    },
	
	    /**
	     * Draws borders of an object's bounding box.
	     * Requires public properties: width, height
	     * Requires public options: padding, borderColor
	     * @param {CanvasRenderingContext2D} ctx Context to draw on
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    drawBorders: function(ctx) {
	      if (!this.hasBorders) {
	        return this;
	      }
	
	      var wh = this._calculateCurrentDimensions(),
	          strokeWidth = 1 / this.borderScaleFactor,
	          width = wh.x + strokeWidth,
	          height = wh.y + strokeWidth;
	
	      ctx.save();
	      ctx.strokeStyle = this.borderColor;
	      this._setLineDash(ctx, this.borderDashArray, null);
	
	      ctx.strokeRect(
	        -width / 2,
	        -height / 2,
	        width,
	        height
	      );
	
	      if (this.hasRotatingPoint && this.isControlVisible('mtr') && !this.get('lockRotation') && this.hasControls) {
	
	        var rotateHeight = -height / 2;
	
	        ctx.beginPath();
	        ctx.moveTo(0, rotateHeight);
	        ctx.lineTo(0, rotateHeight - this.rotatingPointOffset);
	        ctx.closePath();
	        ctx.stroke();
	      }
	
	      ctx.restore();
	      return this;
	    },
	
	    /**
	     * Draws borders of an object's bounding box when it is inside a group.
	     * Requires public properties: width, height
	     * Requires public options: padding, borderColor
	     * @param {CanvasRenderingContext2D} ctx Context to draw on
	     * @param {object} options object representing current object parameters
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    drawBordersInGroup: function(ctx, options) {
	      if (!this.hasBorders) {
	        return this;
	      }
	
	      var p = this._getNonTransformedDimensions(),
	          matrix = fabric.util.customTransformMatrix(options.scaleX, options.scaleY, options.skewX),
	          wh = fabric.util.transformPoint(p, matrix),
	          strokeWidth = 1 / this.borderScaleFactor,
	          width = wh.x + strokeWidth + 2 * this.padding,
	          height = wh.y + strokeWidth + 2 * this.padding;
	
	      ctx.save();
	      this._setLineDash(ctx, this.borderDashArray, null);
	      ctx.strokeStyle = this.borderColor;
	
	      ctx.strokeRect(
	        -width / 2,
	        -height / 2,
	        width,
	        height
	      );
	
	      ctx.restore();
	      return this;
	    },
	
	    /**
	     * Draws corners of an object's bounding box.
	     * Requires public properties: width, height
	     * Requires public options: cornerSize, padding
	     * @param {CanvasRenderingContext2D} ctx Context to draw on
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    drawControls: function(ctx) {
	      if (!this.hasControls) {
	        return this;
	      }
	
	      var wh = this._calculateCurrentDimensions(),
	          width = wh.x,
	          height = wh.y,
	          scaleOffset = this.cornerSize,
	          left = -(width + scaleOffset) / 2,
	          top = -(height + scaleOffset) / 2,
	          methodName = this.transparentCorners ? 'stroke' : 'fill';
	
	      ctx.save();
	      ctx.strokeStyle = ctx.fillStyle = this.cornerColor;
	      if (!this.transparentCorners) {
	        ctx.strokeStyle = this.cornerStrokeColor;
	      }
	      this._setLineDash(ctx, this.cornerDashArray, null);
	
	      // top-left
	      this._drawControl('tl', ctx, methodName,
	        left,
	        top);
	
	      // top-right
	      this._drawControl('tr', ctx, methodName,
	        left + width,
	        top);
	
	      // bottom-left
	      this._drawControl('bl', ctx, methodName,
	        left,
	        top + height);
	
	      // bottom-right
	      this._drawControl('br', ctx, methodName,
	        left + width,
	        top + height);
	
	      if (!this.get('lockUniScaling')) {
	
	        // middle-top
	        this._drawControl('mt', ctx, methodName,
	          left + width / 2,
	          top);
	
	        // middle-bottom
	        this._drawControl('mb', ctx, methodName,
	          left + width / 2,
	          top + height);
	
	        // middle-right
	        this._drawControl('mr', ctx, methodName,
	          left + width,
	          top + height / 2);
	
	        // middle-left
	        this._drawControl('ml', ctx, methodName,
	          left,
	          top + height / 2);
	      }
	
	      // middle-top-rotate
	      if (this.hasRotatingPoint) {
	        this._drawControl('mtr', ctx, methodName,
	          left + width / 2,
	          top - this.rotatingPointOffset);
	      }
	
	      ctx.restore();
	
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _drawControl: function(control, ctx, methodName, left, top) {
	      if (!this.isControlVisible(control)) {
	        return;
	      }
	      var size = this.cornerSize, stroke = !this.transparentCorners && this.cornerStrokeColor;
	      switch (this.cornerStyle) {
	        case 'circle':
	          ctx.beginPath();
	          ctx.arc(left + size / 2, top + size / 2, size / 2, 0, 2 * Math.PI, false);
	          ctx[methodName]();
	          if (stroke) {
	            ctx.stroke();
	          }
	          break;
	        default:
	          isVML() || this.transparentCorners || ctx.clearRect(left, top, size, size);
	          ctx[methodName + 'Rect'](left, top, size, size);
	          if (stroke) {
	            ctx.strokeRect(left, top, size, size);
	          }
	      }
	    },
	
	    /**
	     * Returns true if the specified control is visible, false otherwise.
	     * @param {String} controlName The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
	     * @returns {Boolean} true if the specified control is visible, false otherwise
	     */
	    isControlVisible: function(controlName) {
	      return this._getControlsVisibility()[controlName];
	    },
	
	    /**
	     * Sets the visibility of the specified control.
	     * @param {String} controlName The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
	     * @param {Boolean} visible true to set the specified control visible, false otherwise
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    setControlVisible: function(controlName, visible) {
	      this._getControlsVisibility()[controlName] = visible;
	      return this;
	    },
	
	    /**
	     * Sets the visibility state of object controls.
	     * @param {Object} [options] Options object
	     * @param {Boolean} [options.bl] true to enable the bottom-left control, false to disable it
	     * @param {Boolean} [options.br] true to enable the bottom-right control, false to disable it
	     * @param {Boolean} [options.mb] true to enable the middle-bottom control, false to disable it
	     * @param {Boolean} [options.ml] true to enable the middle-left control, false to disable it
	     * @param {Boolean} [options.mr] true to enable the middle-right control, false to disable it
	     * @param {Boolean} [options.mt] true to enable the middle-top control, false to disable it
	     * @param {Boolean} [options.tl] true to enable the top-left control, false to disable it
	     * @param {Boolean} [options.tr] true to enable the top-right control, false to disable it
	     * @param {Boolean} [options.mtr] true to enable the middle-top-rotate control, false to disable it
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    setControlsVisibility: function(options) {
	      options || (options = { });
	
	      for (var p in options) {
	        this.setControlVisible(p, options[p]);
	      }
	      return this;
	    },
	
	    /**
	     * Returns the instance of the control visibility set for this object.
	     * @private
	     * @returns {Object}
	     */
	    _getControlsVisibility: function() {
	      if (!this._controlsVisibility) {
	        this._controlsVisibility = {
	          tl: true,
	          tr: true,
	          br: true,
	          bl: true,
	          ml: true,
	          mt: true,
	          mr: true,
	          mb: true,
	          mtr: true
	        };
	      }
	      return this._controlsVisibility;
	    }
	  });
	})();
	
	
	fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {
	
	  /**
	   * Animation duration (in ms) for fx* methods
	   * @type Number
	   * @default
	   */
	  FX_DURATION: 500,
	
	  /**
	   * Centers object horizontally with animation.
	   * @param {fabric.Object} object Object to center
	   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
	   * @param {Function} [callbacks.onComplete] Invoked on completion
	   * @param {Function} [callbacks.onChange] Invoked on every step of animation
	   * @return {fabric.Canvas} thisArg
	   * @chainable
	   */
	  fxCenterObjectH: function (object, callbacks) {
	    callbacks = callbacks || { };
	
	    var empty = function() { },
	        onComplete = callbacks.onComplete || empty,
	        onChange = callbacks.onChange || empty,
	        _this = this;
	
	    fabric.util.animate({
	      startValue: object.get('left'),
	      endValue: this.getCenter().left,
	      duration: this.FX_DURATION,
	      onChange: function(value) {
	        object.set('left', value);
	        _this.renderAll();
	        onChange();
	      },
	      onComplete: function() {
	        object.setCoords();
	        onComplete();
	      }
	    });
	
	    return this;
	  },
	
	  /**
	   * Centers object vertically with animation.
	   * @param {fabric.Object} object Object to center
	   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
	   * @param {Function} [callbacks.onComplete] Invoked on completion
	   * @param {Function} [callbacks.onChange] Invoked on every step of animation
	   * @return {fabric.Canvas} thisArg
	   * @chainable
	   */
	  fxCenterObjectV: function (object, callbacks) {
	    callbacks = callbacks || { };
	
	    var empty = function() { },
	        onComplete = callbacks.onComplete || empty,
	        onChange = callbacks.onChange || empty,
	        _this = this;
	
	    fabric.util.animate({
	      startValue: object.get('top'),
	      endValue: this.getCenter().top,
	      duration: this.FX_DURATION,
	      onChange: function(value) {
	        object.set('top', value);
	        _this.renderAll();
	        onChange();
	      },
	      onComplete: function() {
	        object.setCoords();
	        onComplete();
	      }
	    });
	
	    return this;
	  },
	
	  /**
	   * Same as `fabric.Canvas#remove` but animated
	   * @param {fabric.Object} object Object to remove
	   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
	   * @param {Function} [callbacks.onComplete] Invoked on completion
	   * @param {Function} [callbacks.onChange] Invoked on every step of animation
	   * @return {fabric.Canvas} thisArg
	   * @chainable
	   */
	  fxRemove: function (object, callbacks) {
	    callbacks = callbacks || { };
	
	    var empty = function() { },
	        onComplete = callbacks.onComplete || empty,
	        onChange = callbacks.onChange || empty,
	        _this = this;
	
	    fabric.util.animate({
	      startValue: object.get('opacity'),
	      endValue: 0,
	      duration: this.FX_DURATION,
	      onStart: function() {
	        object.set('active', false);
	      },
	      onChange: function(value) {
	        object.set('opacity', value);
	        _this.renderAll();
	        onChange();
	      },
	      onComplete: function () {
	        _this.remove(object);
	        onComplete();
	      }
	    });
	
	    return this;
	  }
	});
	
	fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
	  /**
	   * Animates object's properties
	   * @param {String|Object} property Property to animate (if string) or properties to animate (if object)
	   * @param {Number|Object} value Value to animate property to (if string was given first) or options object
	   * @return {fabric.Object} thisArg
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#animation}
	   * @chainable
	   *
	   * As object  multiple properties
	   *
	   * object.animate({ left: ..., top: ... });
	   * object.animate({ left: ..., top: ... }, { duration: ... });
	   *
	   * As string  one property
	   *
	   * object.animate('left', ...);
	   * object.animate('left', { duration: ... });
	   *
	   */
	  animate: function() {
	    if (arguments[0] && typeof arguments[0] === 'object') {
	      var propsToAnimate = [], prop, skipCallbacks;
	      for (prop in arguments[0]) {
	        propsToAnimate.push(prop);
	      }
	      for (var i = 0, len = propsToAnimate.length; i < len; i++) {
	        prop = propsToAnimate[i];
	        skipCallbacks = i !== len - 1;
	        this._animate(prop, arguments[0][prop], arguments[1], skipCallbacks);
	      }
	    }
	    else {
	      this._animate.apply(this, arguments);
	    }
	    return this;
	  },
	
	  /**
	   * @private
	   * @param {String} property Property to animate
	   * @param {String} to Value to animate to
	   * @param {Object} [options] Options object
	   * @param {Boolean} [skipCallbacks] When true, callbacks like onchange and oncomplete are not invoked
	   */
	  _animate: function(property, to, options, skipCallbacks) {
	    var _this = this, propPair;
	
	    to = to.toString();
	
	    if (!options) {
	      options = { };
	    }
	    else {
	      options = fabric.util.object.clone(options);
	    }
	
	    if (~property.indexOf('.')) {
	      propPair = property.split('.');
	    }
	
	    var currentValue = propPair
	      ? this.get(propPair[0])[propPair[1]]
	      : this.get(property);
	
	    if (!('from' in options)) {
	      options.from = currentValue;
	    }
	
	    if (~to.indexOf('=')) {
	      to = currentValue + parseFloat(to.replace('=', ''));
	    }
	    else {
	      to = parseFloat(to);
	    }
	
	    fabric.util.animate({
	      startValue: options.from,
	      endValue: to,
	      byValue: options.by,
	      easing: options.easing,
	      duration: options.duration,
	      abort: options.abort && function() {
	        return options.abort.call(_this);
	      },
	      onChange: function(value) {
	        if (propPair) {
	          _this[propPair[0]][propPair[1]] = value;
	        }
	        else {
	          _this.set(property, value);
	        }
	        if (skipCallbacks) {
	          return;
	        }
	        options.onChange && options.onChange();
	      },
	      onComplete: function() {
	        if (skipCallbacks) {
	          return;
	        }
	
	        _this.setCoords();
	        options.onComplete && options.onComplete();
	      }
	    });
	  }
	});
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      coordProps = { x1: 1, x2: 1, y1: 1, y2: 1 },
	      supportsLineDash = fabric.StaticCanvas.supports('setLineDash');
	
	  if (fabric.Line) {
	    fabric.warn('fabric.Line is already defined');
	    return;
	  }
	
	  /**
	   * Line class
	   * @class fabric.Line
	   * @extends fabric.Object
	   * @see {@link fabric.Line#initialize} for constructor definition
	   */
	  fabric.Line = fabric.util.createClass(fabric.Object, /** @lends fabric.Line.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'line',
	
	    /**
	     * x value or first line edge
	     * @type Number
	     * @default
	     */
	    x1: 0,
	
	    /**
	     * y value or first line edge
	     * @type Number
	     * @default
	     */
	    y1: 0,
	
	    /**
	     * x value or second line edge
	     * @type Number
	     * @default
	     */
	    x2: 0,
	
	    /**
	     * y value or second line edge
	     * @type Number
	     * @default
	     */
	    y2: 0,
	
	    /**
	     * Constructor
	     * @param {Array} [points] Array of points
	     * @param {Object} [options] Options object
	     * @return {fabric.Line} thisArg
	     */
	    initialize: function(points, options) {
	      options = options || { };
	
	      if (!points) {
	        points = [0, 0, 0, 0];
	      }
	
	      this.callSuper('initialize', options);
	
	      this.set('x1', points[0]);
	      this.set('y1', points[1]);
	      this.set('x2', points[2]);
	      this.set('y2', points[3]);
	
	      this._setWidthHeight(options);
	    },
	
	    /**
	     * @private
	     * @param {Object} [options] Options
	     */
	    _setWidthHeight: function(options) {
	      options || (options = { });
	
	      this.width = Math.abs(this.x2 - this.x1);
	      this.height = Math.abs(this.y2 - this.y1);
	
	      this.left = 'left' in options
	        ? options.left
	        : this._getLeftToOriginX();
	
	      this.top = 'top' in options
	        ? options.top
	        : this._getTopToOriginY();
	    },
	
	    /**
	     * @private
	     * @param {String} key
	     * @param {*} value
	     */
	    _set: function(key, value) {
	      this.callSuper('_set', key, value);
	      if (typeof coordProps[key] !== 'undefined') {
	        this._setWidthHeight();
	      }
	      return this;
	    },
	
	    /**
	     * @private
	     * @return {Number} leftToOriginX Distance from left edge of canvas to originX of Line.
	     */
	    _getLeftToOriginX: makeEdgeToOriginGetter(
	      { // property names
	        origin: 'originX',
	        axis1: 'x1',
	        axis2: 'x2',
	        dimension: 'width'
	      },
	      { // possible values of origin
	        nearest: 'left',
	        center: 'center',
	        farthest: 'right'
	      }
	    ),
	
	    /**
	     * @private
	     * @return {Number} topToOriginY Distance from top edge of canvas to originY of Line.
	     */
	    _getTopToOriginY: makeEdgeToOriginGetter(
	      { // property names
	        origin: 'originY',
	        axis1: 'y1',
	        axis2: 'y2',
	        dimension: 'height'
	      },
	      { // possible values of origin
	        nearest: 'top',
	        center: 'center',
	        farthest: 'bottom'
	      }
	    ),
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} noTransform
	     */
	    _render: function(ctx, noTransform) {
	      ctx.beginPath();
	
	      if (noTransform) {
	        //  Line coords are distances from left-top of canvas to origin of line.
	        //  To render line in a path-group, we need to translate them to
	        //  distances from center of path-group to center of line.
	        var cp = this.getCenterPoint();
	        ctx.translate(
	          cp.x - this.strokeWidth / 2,
	          cp.y - this.strokeWidth / 2
	        );
	      }
	
	      if (!this.strokeDashArray || this.strokeDashArray && supportsLineDash) {
	        // move from center (of virtual box) to its left/top corner
	        // we can't assume x1, y1 is top left and x2, y2 is bottom right
	        var p = this.calcLinePoints();
	        ctx.moveTo(p.x1, p.y1);
	        ctx.lineTo(p.x2, p.y2);
	      }
	
	      ctx.lineWidth = this.strokeWidth;
	
	      // TODO: test this
	      // make sure setting "fill" changes color of a line
	      // (by copying fillStyle to strokeStyle, since line is stroked, not filled)
	      var origStrokeStyle = ctx.strokeStyle;
	      ctx.strokeStyle = this.stroke || ctx.fillStyle;
	      this.stroke && this._renderStroke(ctx);
	      ctx.strokeStyle = origStrokeStyle;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderDashedStroke: function(ctx) {
	      var p = this.calcLinePoints();
	
	      ctx.beginPath();
	      fabric.util.drawDashedLine(ctx, p.x1, p.y1, p.x2, p.y2, this.strokeDashArray);
	      ctx.closePath();
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @methd toObject
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      return extend(this.callSuper('toObject', propertiesToInclude), this.calcLinePoints());
	    },
	
	    /**
	     * Recalculates line points given width and height
	     * @private
	     */
	    calcLinePoints: function() {
	      var xMult = this.x1 <= this.x2 ? -1 : 1,
	          yMult = this.y1 <= this.y2 ? -1 : 1,
	          x1 = (xMult * this.width * 0.5),
	          y1 = (yMult * this.height * 0.5),
	          x2 = (xMult * this.width * -0.5),
	          y2 = (yMult * this.height * -0.5);
	
	      return {
	        x1: x1,
	        x2: x2,
	        y1: y1,
	        y2: y2
	      };
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns SVG representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var markup = this._createBaseSVGMarkup(),
	          p = { x1: this.x1, x2: this.x2, y1: this.y1, y2: this.y2 };
	
	      if (!(this.group && this.group.type === 'path-group')) {
	        p = this.calcLinePoints();
	      }
	      markup.push(
	        '<line ', this.getSvgId(),
	          'x1="', p.x1,
	          '" y1="', p.y1,
	          '" x2="', p.x2,
	          '" y2="', p.y2,
	          '" style="', this.getSvgStyles(),
	          '" transform="', this.getSvgTransform(),
	          this.getSvgTransformMatrix(),
	        '"/>\n'
	      );
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity
	     */
	    complexity: function() {
	      return 1;
	    }
	  });
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Line.fromElement})
	   * @static
	   * @memberOf fabric.Line
	   * @see http://www.w3.org/TR/SVG/shapes.html#LineElement
	   */
	  fabric.Line.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x1 y1 x2 y2'.split(' '));
	
	  /**
	   * Returns fabric.Line instance from an SVG element
	   * @static
	   * @memberOf fabric.Line
	   * @param {SVGElement} element Element to parse
	   * @param {Object} [options] Options object
	   * @return {fabric.Line} instance of fabric.Line
	   */
	  fabric.Line.fromElement = function(element, options) {
	    var parsedAttributes = fabric.parseAttributes(element, fabric.Line.ATTRIBUTE_NAMES),
	        points = [
	          parsedAttributes.x1 || 0,
	          parsedAttributes.y1 || 0,
	          parsedAttributes.x2 || 0,
	          parsedAttributes.y2 || 0
	        ];
	    return new fabric.Line(points, extend(parsedAttributes, options));
	  };
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Returns fabric.Line instance from an object representation
	   * @static
	   * @memberOf fabric.Line
	   * @param {Object} object Object to create an instance from
	   * @param {function} [callback] invoked with new instance as first argument
	   * @return {fabric.Line} instance of fabric.Line
	   */
	  fabric.Line.fromObject = function(object, callback) {
	    var points = [object.x1, object.y1, object.x2, object.y2],
	        line = new fabric.Line(points, object);
	    callback && callback(line);
	    return line;
	  };
	
	  /**
	   * Produces a function that calculates distance from canvas edge to Line origin.
	   */
	  function makeEdgeToOriginGetter(propertyNames, originValues) {
	    var origin = propertyNames.origin,
	        axis1 = propertyNames.axis1,
	        axis2 = propertyNames.axis2,
	        dimension = propertyNames.dimension,
	        nearest = originValues.nearest,
	        center = originValues.center,
	        farthest = originValues.farthest;
	
	    return function() {
	      switch (this.get(origin)) {
	        case nearest:
	          return Math.min(this.get(axis1), this.get(axis2));
	        case center:
	          return Math.min(this.get(axis1), this.get(axis2)) + (0.5 * this.get(dimension));
	        case farthest:
	          return Math.max(this.get(axis1), this.get(axis2));
	      }
	    };
	
	  }
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      pi = Math.PI,
	      extend = fabric.util.object.extend;
	
	  if (fabric.Circle) {
	    fabric.warn('fabric.Circle is already defined.');
	    return;
	  }
	
	  /**
	   * Circle class
	   * @class fabric.Circle
	   * @extends fabric.Object
	   * @see {@link fabric.Circle#initialize} for constructor definition
	   */
	  fabric.Circle = fabric.util.createClass(fabric.Object, /** @lends fabric.Circle.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'circle',
	
	    /**
	     * Radius of this circle
	     * @type Number
	     * @default
	     */
	    radius: 0,
	
	    /**
	     * Start angle of the circle, moving clockwise
	     * @type Number
	     * @default 0
	     */
	    startAngle: 0,
	
	    /**
	     * End angle of the circle
	     * @type Number
	     * @default 2Pi
	     */
	    endAngle: pi * 2,
	
	    /**
	     * Constructor
	     * @param {Object} [options] Options object
	     * @return {fabric.Circle} thisArg
	     */
	    initialize: function(options) {
	      options = options || { };
	
	      this.callSuper('initialize', options);
	      this.set('radius', options.radius || 0);
	
	      this.startAngle = options.startAngle || this.startAngle;
	      this.endAngle = options.endAngle || this.endAngle;
	    },
	
	    /**
	     * @private
	     * @param {String} key
	     * @param {*} value
	     * @return {fabric.Circle} thisArg
	     */
	    _set: function(key, value) {
	      this.callSuper('_set', key, value);
	
	      if (key === 'radius') {
	        this.setRadius(value);
	      }
	
	      return this;
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      return extend(this.callSuper('toObject', propertiesToInclude), {
	        radius: this.get('radius'),
	        startAngle: this.startAngle,
	        endAngle: this.endAngle
	      });
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns svg representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var markup = this._createBaseSVGMarkup(), x = 0, y = 0,
	          angle = (this.endAngle - this.startAngle) % ( 2 * pi);
	
	      if (angle === 0) {
	        if (this.group && this.group.type === 'path-group') {
	          x = this.left + this.radius;
	          y = this.top + this.radius;
	        }
	        markup.push(
	          '<circle ', this.getSvgId(),
	            'cx="' + x + '" cy="' + y + '" ',
	            'r="', this.radius,
	            '" style="', this.getSvgStyles(),
	            '" transform="', this.getSvgTransform(),
	            ' ', this.getSvgTransformMatrix(),
	          '"/>\n'
	        );
	      }
	      else {
	        var startX = Math.cos(this.startAngle) * this.radius,
	            startY = Math.sin(this.startAngle) * this.radius,
	            endX = Math.cos(this.endAngle) * this.radius,
	            endY = Math.sin(this.endAngle) * this.radius,
	            largeFlag = angle > pi ? '1' : '0';
	
	        markup.push(
	          '<path d="M ' + startX + ' ' + startY,
	          ' A ' + this.radius + ' ' + this.radius,
	          ' 0 ', +largeFlag + ' 1', ' ' + endX + ' ' + endY,
	          '" style="', this.getSvgStyles(),
	          '" transform="', this.getSvgTransform(),
	          ' ', this.getSvgTransformMatrix(),
	          '"/>\n'
	        );
	      }
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx context to render on
	     * @param {Boolean} [noTransform] When true, context is not transformed
	     */
	    _render: function(ctx, noTransform) {
	      ctx.beginPath();
	      ctx.arc(noTransform ? this.left + this.radius : 0,
	              noTransform ? this.top + this.radius : 0,
	              this.radius,
	              this.startAngle,
	              this.endAngle, false);
	      this._renderFill(ctx);
	      this._renderStroke(ctx);
	    },
	
	    /**
	     * Returns horizontal radius of an object (according to how an object is scaled)
	     * @return {Number}
	     */
	    getRadiusX: function() {
	      return this.get('radius') * this.get('scaleX');
	    },
	
	    /**
	     * Returns vertical radius of an object (according to how an object is scaled)
	     * @return {Number}
	     */
	    getRadiusY: function() {
	      return this.get('radius') * this.get('scaleY');
	    },
	
	    /**
	     * Sets radius of an object (and updates width accordingly)
	     * @return {fabric.Circle} thisArg
	     */
	    setRadius: function(value) {
	      this.radius = value;
	      return this.set('width', value * 2).set('height', value * 2);
	    },
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity of this instance
	     */
	    complexity: function() {
	      return 1;
	    }
	  });
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Circle.fromElement})
	   * @static
	   * @memberOf fabric.Circle
	   * @see: http://www.w3.org/TR/SVG/shapes.html#CircleElement
	   */
	  fabric.Circle.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy r'.split(' '));
	
	  /**
	   * Returns {@link fabric.Circle} instance from an SVG element
	   * @static
	   * @memberOf fabric.Circle
	   * @param {SVGElement} element Element to parse
	   * @param {Object} [options] Options object
	   * @throws {Error} If value of `r` attribute is missing or invalid
	   * @return {fabric.Circle} Instance of fabric.Circle
	   */
	  fabric.Circle.fromElement = function(element, options) {
	    options || (options = { });
	
	    var parsedAttributes = fabric.parseAttributes(element, fabric.Circle.ATTRIBUTE_NAMES);
	
	    if (!isValidRadius(parsedAttributes)) {
	      throw new Error('value of `r` attribute is required and can not be negative');
	    }
	
	    parsedAttributes.left = parsedAttributes.left || 0;
	    parsedAttributes.top = parsedAttributes.top || 0;
	
	    var obj = new fabric.Circle(extend(parsedAttributes, options));
	
	    obj.left -= obj.radius;
	    obj.top -= obj.radius;
	    return obj;
	  };
	
	  /**
	   * @private
	   */
	  function isValidRadius(attributes) {
	    return (('radius' in attributes) && (attributes.radius >= 0));
	  }
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Returns {@link fabric.Circle} instance from an object representation
	   * @static
	   * @memberOf fabric.Circle
	   * @param {Object} object Object to create an instance from
	   * @param {function} [callback] invoked with new instance as first argument
	   * @return {Object} Instance of fabric.Circle
	   */
	  fabric.Circle.fromObject = function(object, callback) {
	    var circle = new fabric.Circle(object);
	    callback && callback(circle);
	    return circle;
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { });
	
	  if (fabric.Triangle) {
	    fabric.warn('fabric.Triangle is already defined');
	    return;
	  }
	
	  /**
	   * Triangle class
	   * @class fabric.Triangle
	   * @extends fabric.Object
	   * @return {fabric.Triangle} thisArg
	   * @see {@link fabric.Triangle#initialize} for constructor definition
	   */
	  fabric.Triangle = fabric.util.createClass(fabric.Object, /** @lends fabric.Triangle.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'triangle',
	
	    /**
	     * Constructor
	     * @param {Object} [options] Options object
	     * @return {Object} thisArg
	     */
	    initialize: function(options) {
	      options = options || { };
	
	      this.callSuper('initialize', options);
	
	      this.set('width', options.width || 100)
	          .set('height', options.height || 100);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _render: function(ctx) {
	      var widthBy2 = this.width / 2,
	          heightBy2 = this.height / 2;
	
	      ctx.beginPath();
	      ctx.moveTo(-widthBy2, heightBy2);
	      ctx.lineTo(0, -heightBy2);
	      ctx.lineTo(widthBy2, heightBy2);
	      ctx.closePath();
	
	      this._renderFill(ctx);
	      this._renderStroke(ctx);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderDashedStroke: function(ctx) {
	      var widthBy2 = this.width / 2,
	          heightBy2 = this.height / 2;
	
	      ctx.beginPath();
	      fabric.util.drawDashedLine(ctx, -widthBy2, heightBy2, 0, -heightBy2, this.strokeDashArray);
	      fabric.util.drawDashedLine(ctx, 0, -heightBy2, widthBy2, heightBy2, this.strokeDashArray);
	      fabric.util.drawDashedLine(ctx, widthBy2, heightBy2, -widthBy2, heightBy2, this.strokeDashArray);
	      ctx.closePath();
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns SVG representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var markup = this._createBaseSVGMarkup(),
	          widthBy2 = this.width / 2,
	          heightBy2 = this.height / 2,
	          points = [
	            -widthBy2 + ' ' + heightBy2,
	            '0 ' + -heightBy2,
	            widthBy2 + ' ' + heightBy2
	          ]
	          .join(',');
	
	      markup.push(
	        '<polygon ', this.getSvgId(),
	          'points="', points,
	          '" style="', this.getSvgStyles(),
	          '" transform="', this.getSvgTransform(),
	        '"/>'
	      );
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity of this instance
	     */
	    complexity: function() {
	      return 1;
	    }
	  });
	
	  /**
	   * Returns fabric.Triangle instance from an object representation
	   * @static
	   * @memberOf fabric.Triangle
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] Callback to invoke when an fabric.Triangle instance is created
	   * @return {Object} instance of Canvas.Triangle
	   */
	  fabric.Triangle.fromObject = function(object, callback) {
	    var triangle = new fabric.Triangle(object);
	    callback && callback(triangle);
	    return triangle;
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      piBy2   = Math.PI * 2,
	      extend = fabric.util.object.extend;
	
	  if (fabric.Ellipse) {
	    fabric.warn('fabric.Ellipse is already defined.');
	    return;
	  }
	
	  /**
	   * Ellipse class
	   * @class fabric.Ellipse
	   * @extends fabric.Object
	   * @return {fabric.Ellipse} thisArg
	   * @see {@link fabric.Ellipse#initialize} for constructor definition
	   */
	  fabric.Ellipse = fabric.util.createClass(fabric.Object, /** @lends fabric.Ellipse.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'ellipse',
	
	    /**
	     * Horizontal radius
	     * @type Number
	     * @default
	     */
	    rx:   0,
	
	    /**
	     * Vertical radius
	     * @type Number
	     * @default
	     */
	    ry:   0,
	
	    /**
	     * Constructor
	     * @param {Object} [options] Options object
	     * @return {fabric.Ellipse} thisArg
	     */
	    initialize: function(options) {
	      options = options || { };
	
	      this.callSuper('initialize', options);
	
	      this.set('rx', options.rx || 0);
	      this.set('ry', options.ry || 0);
	    },
	
	    /**
	     * @private
	     * @param {String} key
	     * @param {*} value
	     * @return {fabric.Ellipse} thisArg
	     */
	    _set: function(key, value) {
	      this.callSuper('_set', key, value);
	      switch (key) {
	
	        case 'rx':
	          this.rx = value;
	          this.set('width', value * 2);
	          break;
	
	        case 'ry':
	          this.ry = value;
	          this.set('height', value * 2);
	          break;
	
	      }
	      return this;
	    },
	
	    /**
	     * Returns horizontal radius of an object (according to how an object is scaled)
	     * @return {Number}
	     */
	    getRx: function() {
	      return this.get('rx') * this.get('scaleX');
	    },
	
	    /**
	     * Returns Vertical radius of an object (according to how an object is scaled)
	     * @return {Number}
	     */
	    getRy: function() {
	      return this.get('ry') * this.get('scaleY');
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      return extend(this.callSuper('toObject', propertiesToInclude), {
	        rx: this.get('rx'),
	        ry: this.get('ry')
	      });
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns svg representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var markup = this._createBaseSVGMarkup(), x = 0, y = 0;
	      if (this.group && this.group.type === 'path-group') {
	        x = this.left + this.rx;
	        y = this.top + this.ry;
	      }
	      markup.push(
	        '<ellipse ', this.getSvgId(),
	          'cx="', x, '" cy="', y, '" ',
	          'rx="', this.rx,
	          '" ry="', this.ry,
	          '" style="', this.getSvgStyles(),
	          '" transform="', this.getSvgTransform(),
	          this.getSvgTransformMatrix(),
	        '"/>\n'
	      );
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx context to render on
	     * @param {Boolean} [noTransform] When true, context is not transformed
	     */
	    _render: function(ctx, noTransform) {
	      ctx.beginPath();
	      ctx.save();
	      ctx.transform(1, 0, 0, this.ry / this.rx, 0, 0);
	      ctx.arc(
	        noTransform ? this.left + this.rx : 0,
	        noTransform ? (this.top + this.ry) * this.rx / this.ry : 0,
	        this.rx,
	        0,
	        piBy2,
	        false);
	      ctx.restore();
	      this._renderFill(ctx);
	      this._renderStroke(ctx);
	    },
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity
	     */
	    complexity: function() {
	      return 1;
	    }
	  });
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Ellipse.fromElement})
	   * @static
	   * @memberOf fabric.Ellipse
	   * @see http://www.w3.org/TR/SVG/shapes.html#EllipseElement
	   */
	  fabric.Ellipse.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy rx ry'.split(' '));
	
	  /**
	   * Returns {@link fabric.Ellipse} instance from an SVG element
	   * @static
	   * @memberOf fabric.Ellipse
	   * @param {SVGElement} element Element to parse
	   * @param {Object} [options] Options object
	   * @return {fabric.Ellipse}
	   */
	  fabric.Ellipse.fromElement = function(element, options) {
	    options || (options = { });
	
	    var parsedAttributes = fabric.parseAttributes(element, fabric.Ellipse.ATTRIBUTE_NAMES);
	
	    parsedAttributes.left = parsedAttributes.left || 0;
	    parsedAttributes.top = parsedAttributes.top || 0;
	
	    var ellipse = new fabric.Ellipse(extend(parsedAttributes, options));
	
	    ellipse.top -= ellipse.ry;
	    ellipse.left -= ellipse.rx;
	    return ellipse;
	  };
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Returns {@link fabric.Ellipse} instance from an object representation
	   * @static
	   * @memberOf fabric.Ellipse
	   * @param {Object} object Object to create an instance from
	   * @param {function} [callback] invoked with new instance as first argument
	   * @return {fabric.Ellipse}
	   */
	  fabric.Ellipse.fromObject = function(object, callback) {
	    var ellipse = new fabric.Ellipse(object);
	    callback && callback(ellipse);
	    return ellipse;
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend;
	
	  if (fabric.Rect) {
	    fabric.warn('fabric.Rect is already defined');
	    return;
	  }
	
	  var stateProperties = fabric.Object.prototype.stateProperties.concat();
	  stateProperties.push('rx', 'ry', 'x', 'y');
	
	  /**
	   * Rectangle class
	   * @class fabric.Rect
	   * @extends fabric.Object
	   * @return {fabric.Rect} thisArg
	   * @see {@link fabric.Rect#initialize} for constructor definition
	   */
	  fabric.Rect = fabric.util.createClass(fabric.Object, /** @lends fabric.Rect.prototype */ {
	
	    /**
	     * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})
	     * as well as for history (undo/redo) purposes
	     * @type Array
	     */
	    stateProperties: stateProperties,
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'rect',
	
	    /**
	     * Horizontal border radius
	     * @type Number
	     * @default
	     */
	    rx:   0,
	
	    /**
	     * Vertical border radius
	     * @type Number
	     * @default
	     */
	    ry:   0,
	
	    /**
	     * Used to specify dash pattern for stroke on this object
	     * @type Array
	     */
	    strokeDashArray: null,
	
	    /**
	     * Constructor
	     * @param {Object} [options] Options object
	     * @return {Object} thisArg
	     */
	    initialize: function(options) {
	      options = options || { };
	
	      this.callSuper('initialize', options);
	      this._initRxRy();
	
	    },
	
	    /**
	     * Initializes rx/ry attributes
	     * @private
	     */
	    _initRxRy: function() {
	      if (this.rx && !this.ry) {
	        this.ry = this.rx;
	      }
	      else if (this.ry && !this.rx) {
	        this.rx = this.ry;
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} noTransform
	     */
	    _render: function(ctx, noTransform) {
	
	      // optimize 1x1 case (used in spray brush)
	      if (this.width === 1 && this.height === 1) {
	        ctx.fillRect(-0.5, -0.5, 1, 1);
	        return;
	      }
	
	      var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0,
	          ry = this.ry ? Math.min(this.ry, this.height / 2) : 0,
	          w = this.width,
	          h = this.height,
	          x = noTransform ? this.left : -this.width / 2,
	          y = noTransform ? this.top : -this.height / 2,
	          isRounded = rx !== 0 || ry !== 0,
	          /* "magic number" for bezier approximations of arcs (http://itc.ktu.lt/itc354/Riskus354.pdf) */
	          k = 1 - 0.5522847498;
	      ctx.beginPath();
	
	      ctx.moveTo(x + rx, y);
	
	      ctx.lineTo(x + w - rx, y);
	      isRounded && ctx.bezierCurveTo(x + w - k * rx, y, x + w, y + k * ry, x + w, y + ry);
	
	      ctx.lineTo(x + w, y + h - ry);
	      isRounded && ctx.bezierCurveTo(x + w, y + h - k * ry, x + w - k * rx, y + h, x + w - rx, y + h);
	
	      ctx.lineTo(x + rx, y + h);
	      isRounded && ctx.bezierCurveTo(x + k * rx, y + h, x, y + h - k * ry, x, y + h - ry);
	
	      ctx.lineTo(x, y + ry);
	      isRounded && ctx.bezierCurveTo(x, y + k * ry, x + k * rx, y, x + rx, y);
	
	      ctx.closePath();
	
	      this._renderFill(ctx);
	      this._renderStroke(ctx);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderDashedStroke: function(ctx) {
	      var x = -this.width / 2,
	          y = -this.height / 2,
	          w = this.width,
	          h = this.height;
	
	      ctx.beginPath();
	      fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);
	      fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);
	      fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);
	      fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);
	      ctx.closePath();
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      var object = extend(this.callSuper('toObject', propertiesToInclude), {
	        rx: this.get('rx') || 0,
	        ry: this.get('ry') || 0
	      });
	      if (!this.includeDefaultValues) {
	        this._removeDefaultValues(object);
	      }
	      return object;
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns svg representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var markup = this._createBaseSVGMarkup(), x = this.left, y = this.top;
	      if (!(this.group && this.group.type === 'path-group')) {
	        x = -this.width / 2;
	        y = -this.height / 2;
	      }
	      markup.push(
	        '<rect ', this.getSvgId(),
	          'x="', x, '" y="', y,
	          '" rx="', this.get('rx'), '" ry="', this.get('ry'),
	          '" width="', this.width, '" height="', this.height,
	          '" style="', this.getSvgStyles(),
	          '" transform="', this.getSvgTransform(),
	          this.getSvgTransformMatrix(),
	        '"/>\n');
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity
	     */
	    complexity: function() {
	      return 1;
	    }
	  });
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by `fabric.Rect.fromElement`)
	   * @static
	   * @memberOf fabric.Rect
	   * @see: http://www.w3.org/TR/SVG/shapes.html#RectElement
	   */
	  fabric.Rect.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x y rx ry width height'.split(' '));
	
	  /**
	   * Returns {@link fabric.Rect} instance from an SVG element
	   * @static
	   * @memberOf fabric.Rect
	   * @param {SVGElement} element Element to parse
	   * @param {Object} [options] Options object
	   * @return {fabric.Rect} Instance of fabric.Rect
	   */
	  fabric.Rect.fromElement = function(element, options) {
	    if (!element) {
	      return null;
	    }
	    options = options || { };
	
	    var parsedAttributes = fabric.parseAttributes(element, fabric.Rect.ATTRIBUTE_NAMES);
	
	    parsedAttributes.left = parsedAttributes.left || 0;
	    parsedAttributes.top  = parsedAttributes.top  || 0;
	    var rect = new fabric.Rect(extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));
	    rect.visible = rect.visible && rect.width > 0 && rect.height > 0;
	    return rect;
	  };
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Returns {@link fabric.Rect} instance from an object representation
	   * @static
	   * @memberOf fabric.Rect
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] Callback to invoke when an fabric.Rect instance is created
	   * @return {Object} instance of fabric.Rect
	   */
	  fabric.Rect.fromObject = function(object, callback) {
	    var rect = new fabric.Rect(object);
	    callback && callback(rect);
	    return rect;
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { });
	
	  if (fabric.Polyline) {
	    fabric.warn('fabric.Polyline is already defined');
	    return;
	  }
	
	  /**
	   * Polyline class
	   * @class fabric.Polyline
	   * @extends fabric.Object
	   * @see {@link fabric.Polyline#initialize} for constructor definition
	   */
	  fabric.Polyline = fabric.util.createClass(fabric.Object, /** @lends fabric.Polyline.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'polyline',
	
	    /**
	     * Points array
	     * @type Array
	     * @default
	     */
	    points: null,
	
	    /**
	     * Minimum X from points values, necessary to offset points
	     * @type Number
	     * @default
	     */
	    minX: 0,
	
	    /**
	     * Minimum Y from points values, necessary to offset points
	     * @type Number
	     * @default
	     */
	    minY: 0,
	
	    /**
	     * Constructor
	     * @param {Array} points Array of points (where each point is an object with x and y)
	     * @param {Object} [options] Options object
	     * @return {fabric.Polyline} thisArg
	     * @example
	     * var poly = new fabric.Polyline([
	     *     { x: 10, y: 10 },
	     *     { x: 50, y: 30 },
	     *     { x: 40, y: 70 },
	     *     { x: 60, y: 50 },
	     *     { x: 100, y: 150 },
	     *     { x: 40, y: 100 }
	     *   ], {
	     *   stroke: 'red',
	     *   left: 100,
	     *   top: 100
	     * });
	     */
	    initialize: function(points, options) {
	      return fabric.Polygon.prototype.initialize.call(this, points, options);
	    },
	
	    /**
	     * @private
	     */
	    _calcDimensions: function() {
	      return fabric.Polygon.prototype._calcDimensions.call(this);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      return fabric.Polygon.prototype.toObject.call(this, propertiesToInclude);
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns SVG representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      return fabric.Polygon.prototype.toSVG.call(this, reviver);
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} noTransform
	     */
	    _render: function(ctx, noTransform) {
	      if (!fabric.Polygon.prototype.commonRender.call(this, ctx, noTransform)) {
	        return;
	      }
	      this._renderFill(ctx);
	      this._renderStroke(ctx);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderDashedStroke: function(ctx) {
	      var p1, p2;
	
	      ctx.beginPath();
	      for (var i = 0, len = this.points.length; i < len; i++) {
	        p1 = this.points[i];
	        p2 = this.points[i + 1] || p1;
	        fabric.util.drawDashedLine(ctx, p1.x, p1.y, p2.x, p2.y, this.strokeDashArray);
	      }
	    },
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity of this instance
	     */
	    complexity: function() {
	      return this.get('points').length;
	    }
	  });
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Polyline.fromElement})
	   * @static
	   * @memberOf fabric.Polyline
	   * @see: http://www.w3.org/TR/SVG/shapes.html#PolylineElement
	   */
	  fabric.Polyline.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();
	
	  /**
	   * Returns fabric.Polyline instance from an SVG element
	   * @static
	   * @memberOf fabric.Polyline
	   * @param {SVGElement} element Element to parse
	   * @param {Object} [options] Options object
	   * @return {fabric.Polyline} Instance of fabric.Polyline
	   */
	  fabric.Polyline.fromElement = function(element, options) {
	    if (!element) {
	      return null;
	    }
	    options || (options = { });
	
	    var points = fabric.parsePointsAttribute(element.getAttribute('points')),
	        parsedAttributes = fabric.parseAttributes(element, fabric.Polyline.ATTRIBUTE_NAMES);
	
	    return new fabric.Polyline(points, fabric.util.object.extend(parsedAttributes, options));
	  };
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Returns fabric.Polyline instance from an object representation
	   * @static
	   * @memberOf fabric.Polyline
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
	   * @return {fabric.Polyline} Instance of fabric.Polyline
	   */
	  fabric.Polyline.fromObject = function(object, callback) {
	    var polyline = new fabric.Polyline(object.points, object);
	    callback && callback(polyline);
	    return polyline;
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      min = fabric.util.array.min,
	      max = fabric.util.array.max,
	      toFixed = fabric.util.toFixed;
	
	  if (fabric.Polygon) {
	    fabric.warn('fabric.Polygon is already defined');
	    return;
	  }
	
	  /**
	   * Polygon class
	   * @class fabric.Polygon
	   * @extends fabric.Object
	   * @see {@link fabric.Polygon#initialize} for constructor definition
	   */
	  fabric.Polygon = fabric.util.createClass(fabric.Object, /** @lends fabric.Polygon.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'polygon',
	
	    /**
	     * Points array
	     * @type Array
	     * @default
	     */
	    points: null,
	
	    /**
	     * Minimum X from points values, necessary to offset points
	     * @type Number
	     * @default
	     */
	    minX: 0,
	
	    /**
	     * Minimum Y from points values, necessary to offset points
	     * @type Number
	     * @default
	     */
	    minY: 0,
	
	    /**
	     * Constructor
	     * @param {Array} points Array of points
	     * @param {Object} [options] Options object
	     * @return {fabric.Polygon} thisArg
	     */
	    initialize: function(points, options) {
	      options = options || { };
	      this.points = points || [];
	      this.callSuper('initialize', options);
	      this._calcDimensions();
	      if (!('top' in options)) {
	        this.top = this.minY;
	      }
	      if (!('left' in options)) {
	        this.left = this.minX;
	      }
	      this.pathOffset = {
	        x: this.minX + this.width / 2,
	        y: this.minY + this.height / 2
	      };
	    },
	
	    /**
	     * @private
	     */
	    _calcDimensions: function() {
	
	      var points = this.points,
	          minX = min(points, 'x'),
	          minY = min(points, 'y'),
	          maxX = max(points, 'x'),
	          maxY = max(points, 'y');
	
	      this.width = (maxX - minX) || 0;
	      this.height = (maxY - minY) || 0;
	      this.minX = minX || 0;
	      this.minY = minY || 0;
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      return extend(this.callSuper('toObject', propertiesToInclude), {
	        points: this.points.concat()
	      });
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns svg representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var points = [], addTransform,
	          markup = this._createBaseSVGMarkup();
	
	      for (var i = 0, len = this.points.length; i < len; i++) {
	        points.push(toFixed(this.points[i].x, 2), ',', toFixed(this.points[i].y, 2), ' ');
	      }
	      if (!(this.group && this.group.type === 'path-group')) {
	        addTransform = ' translate(' + (-this.pathOffset.x) + ', ' + (-this.pathOffset.y) + ') ';
	      }
	      markup.push(
	        '<', this.type, ' ', this.getSvgId(),
	          'points="', points.join(''),
	          '" style="', this.getSvgStyles(),
	          '" transform="', this.getSvgTransform(), addTransform,
	          ' ', this.getSvgTransformMatrix(),
	        '"/>\n'
	      );
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} noTransform
	     */
	    _render: function(ctx, noTransform) {
	      if (!this.commonRender(ctx, noTransform)) {
	        return;
	      }
	      this._renderFill(ctx);
	      if (this.stroke || this.strokeDashArray) {
	        ctx.closePath();
	        this._renderStroke(ctx);
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} noTransform
	     */
	    commonRender: function(ctx, noTransform) {
	      var point, len = this.points.length;
	
	      if (!len || isNaN(this.points[len - 1].y)) {
	        // do not draw if no points or odd points
	        // NaN comes from parseFloat of a empty string in parser
	        return false;
	      }
	
	      noTransform || ctx.translate(-this.pathOffset.x, -this.pathOffset.y);
	      ctx.beginPath();
	      ctx.moveTo(this.points[0].x, this.points[0].y);
	      for (var i = 0; i < len; i++) {
	        point = this.points[i];
	        ctx.lineTo(point.x, point.y);
	      }
	      return true;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderDashedStroke: function(ctx) {
	      fabric.Polyline.prototype._renderDashedStroke.call(this, ctx);
	      ctx.closePath();
	    },
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity of this instance
	     */
	    complexity: function() {
	      return this.points.length;
	    }
	  });
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by `fabric.Polygon.fromElement`)
	   * @static
	   * @memberOf fabric.Polygon
	   * @see: http://www.w3.org/TR/SVG/shapes.html#PolygonElement
	   */
	  fabric.Polygon.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();
	
	  /**
	   * Returns {@link fabric.Polygon} instance from an SVG element
	   * @static
	   * @memberOf fabric.Polygon
	   * @param {SVGElement} element Element to parse
	   * @param {Object} [options] Options object
	   * @return {fabric.Polygon} Instance of fabric.Polygon
	   */
	  fabric.Polygon.fromElement = function(element, options) {
	    if (!element) {
	      return null;
	    }
	
	    options || (options = { });
	
	    var points = fabric.parsePointsAttribute(element.getAttribute('points')),
	        parsedAttributes = fabric.parseAttributes(element, fabric.Polygon.ATTRIBUTE_NAMES);
	
	    return new fabric.Polygon(points, extend(parsedAttributes, options));
	  };
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Returns fabric.Polygon instance from an object representation
	   * @static
	   * @memberOf fabric.Polygon
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
	   * @return {fabric.Polygon} Instance of fabric.Polygon
	   */
	  fabric.Polygon.fromObject = function(object, callback) {
	    var polygon = new fabric.Polygon(object.points, object);
	    callback && callback(polygon);
	    return polygon;
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      min = fabric.util.array.min,
	      max = fabric.util.array.max,
	      extend = fabric.util.object.extend,
	      _toString = Object.prototype.toString,
	      drawArc = fabric.util.drawArc,
	      commandLengths = {
	        m: 2,
	        l: 2,
	        h: 1,
	        v: 1,
	        c: 6,
	        s: 4,
	        q: 4,
	        t: 2,
	        a: 7
	      },
	      repeatedCommands = {
	        m: 'l',
	        M: 'L'
	      };
	
	  if (fabric.Path) {
	    fabric.warn('fabric.Path is already defined');
	    return;
	  }
	
	  /**
	   * Path class
	   * @class fabric.Path
	   * @extends fabric.Object
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#path_and_pathgroup}
	   * @see {@link fabric.Path#initialize} for constructor definition
	   */
	  fabric.Path = fabric.util.createClass(fabric.Object, /** @lends fabric.Path.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'path',
	
	    /**
	     * Array of path points
	     * @type Array
	     * @default
	     */
	    path: null,
	
	    /**
	     * Minimum X from points values, necessary to offset points
	     * @type Number
	     * @default
	     */
	    minX: 0,
	
	    /**
	     * Minimum Y from points values, necessary to offset points
	     * @type Number
	     * @default
	     */
	    minY: 0,
	
	    /**
	     * Constructor
	     * @param {Array|String} path Path data (sequence of coordinates and corresponding "command" tokens)
	     * @param {Object} [options] Options object
	     * @return {fabric.Path} thisArg
	     */
	    initialize: function(path, options) {
	      options = options || { };
	
	      this.setOptions(options);
	
	      if (!path) {
	        path = [];
	      }
	
	      var fromArray = _toString.call(path) === '[object Array]';
	
	      this.path = fromArray
	        ? path
	        // one of commands (m,M,l,L,q,Q,c,C,etc.) followed by non-command characters (i.e. command values)
	        : path.match && path.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
	
	      if (!this.path) {
	        return;
	      }
	
	      if (!fromArray) {
	        this.path = this._parsePath();
	      }
	
	      this._setPositionDimensions(options);
	
	      if (options.sourcePath) {
	        this.setSourcePath(options.sourcePath);
	      }
	    },
	
	    /**
	     * @private
	     * @param {Object} options Options object
	     */
	    _setPositionDimensions: function(options) {
	      var calcDim = this._parseDimensions();
	
	      this.minX = calcDim.left;
	      this.minY = calcDim.top;
	      this.width = calcDim.width;
	      this.height = calcDim.height;
	
	      if (typeof options.left === 'undefined') {
	        this.left = calcDim.left + (this.originX === 'center'
	          ? this.width / 2
	          : this.originX === 'right'
	            ? this.width
	            : 0);
	      }
	
	      if (typeof options.top === 'undefined') {
	        this.top = calcDim.top + (this.originY === 'center'
	          ? this.height / 2
	          : this.originY === 'bottom'
	            ? this.height
	            : 0);
	      }
	
	      this.pathOffset = this.pathOffset || {
	        x: this.minX + this.width / 2,
	        y: this.minY + this.height / 2
	      };
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx context to render path on
	     */
	    _renderPathCommands: function(ctx) {
	      var current, // current instruction
	          previous = null,
	          subpathStartX = 0,
	          subpathStartY = 0,
	          x = 0, // current x
	          y = 0, // current y
	          controlX = 0, // current control point x
	          controlY = 0, // current control point y
	          tempX,
	          tempY,
	          l = -this.pathOffset.x,
	          t = -this.pathOffset.y;
	
	      if (this.group && this.group.type === 'path-group') {
	        l = 0;
	        t = 0;
	      }
	
	      ctx.beginPath();
	
	      for (var i = 0, len = this.path.length; i < len; ++i) {
	
	        current = this.path[i];
	
	        switch (current[0]) { // first letter
	
	          case 'l': // lineto, relative
	            x += current[1];
	            y += current[2];
	            ctx.lineTo(x + l, y + t);
	            break;
	
	          case 'L': // lineto, absolute
	            x = current[1];
	            y = current[2];
	            ctx.lineTo(x + l, y + t);
	            break;
	
	          case 'h': // horizontal lineto, relative
	            x += current[1];
	            ctx.lineTo(x + l, y + t);
	            break;
	
	          case 'H': // horizontal lineto, absolute
	            x = current[1];
	            ctx.lineTo(x + l, y + t);
	            break;
	
	          case 'v': // vertical lineto, relative
	            y += current[1];
	            ctx.lineTo(x + l, y + t);
	            break;
	
	          case 'V': // verical lineto, absolute
	            y = current[1];
	            ctx.lineTo(x + l, y + t);
	            break;
	
	          case 'm': // moveTo, relative
	            x += current[1];
	            y += current[2];
	            subpathStartX = x;
	            subpathStartY = y;
	            ctx.moveTo(x + l, y + t);
	            break;
	
	          case 'M': // moveTo, absolute
	            x = current[1];
	            y = current[2];
	            subpathStartX = x;
	            subpathStartY = y;
	            ctx.moveTo(x + l, y + t);
	            break;
	
	          case 'c': // bezierCurveTo, relative
	            tempX = x + current[5];
	            tempY = y + current[6];
	            controlX = x + current[3];
	            controlY = y + current[4];
	            ctx.bezierCurveTo(
	              x + current[1] + l, // x1
	              y + current[2] + t, // y1
	              controlX + l, // x2
	              controlY + t, // y2
	              tempX + l,
	              tempY + t
	            );
	            x = tempX;
	            y = tempY;
	            break;
	
	          case 'C': // bezierCurveTo, absolute
	            x = current[5];
	            y = current[6];
	            controlX = current[3];
	            controlY = current[4];
	            ctx.bezierCurveTo(
	              current[1] + l,
	              current[2] + t,
	              controlX + l,
	              controlY + t,
	              x + l,
	              y + t
	            );
	            break;
	
	          case 's': // shorthand cubic bezierCurveTo, relative
	
	            // transform to absolute x,y
	            tempX = x + current[3];
	            tempY = y + current[4];
	
	            if (previous[0].match(/[CcSs]/) === null) {
	              // If there is no previous command or if the previous command was not a C, c, S, or s,
	              // the control point is coincident with the current point
	              controlX = x;
	              controlY = y;
	            }
	            else {
	              // calculate reflection of previous control points
	              controlX = 2 * x - controlX;
	              controlY = 2 * y - controlY;
	            }
	
	            ctx.bezierCurveTo(
	              controlX + l,
	              controlY + t,
	              x + current[1] + l,
	              y + current[2] + t,
	              tempX + l,
	              tempY + t
	            );
	            // set control point to 2nd one of this command
	            // "... the first control point is assumed to be
	            // the reflection of the second control point on
	            // the previous command relative to the current point."
	            controlX = x + current[1];
	            controlY = y + current[2];
	
	            x = tempX;
	            y = tempY;
	            break;
	
	          case 'S': // shorthand cubic bezierCurveTo, absolute
	            tempX = current[3];
	            tempY = current[4];
	            if (previous[0].match(/[CcSs]/) === null) {
	              // If there is no previous command or if the previous command was not a C, c, S, or s,
	              // the control point is coincident with the current point
	              controlX = x;
	              controlY = y;
	            }
	            else {
	              // calculate reflection of previous control points
	              controlX = 2 * x - controlX;
	              controlY = 2 * y - controlY;
	            }
	            ctx.bezierCurveTo(
	              controlX + l,
	              controlY + t,
	              current[1] + l,
	              current[2] + t,
	              tempX + l,
	              tempY + t
	            );
	            x = tempX;
	            y = tempY;
	
	            // set control point to 2nd one of this command
	            // "... the first control point is assumed to be
	            // the reflection of the second control point on
	            // the previous command relative to the current point."
	            controlX = current[1];
	            controlY = current[2];
	
	            break;
	
	          case 'q': // quadraticCurveTo, relative
	            // transform to absolute x,y
	            tempX = x + current[3];
	            tempY = y + current[4];
	
	            controlX = x + current[1];
	            controlY = y + current[2];
	
	            ctx.quadraticCurveTo(
	              controlX + l,
	              controlY + t,
	              tempX + l,
	              tempY + t
	            );
	            x = tempX;
	            y = tempY;
	            break;
	
	          case 'Q': // quadraticCurveTo, absolute
	            tempX = current[3];
	            tempY = current[4];
	
	            ctx.quadraticCurveTo(
	              current[1] + l,
	              current[2] + t,
	              tempX + l,
	              tempY + t
	            );
	            x = tempX;
	            y = tempY;
	            controlX = current[1];
	            controlY = current[2];
	            break;
	
	          case 't': // shorthand quadraticCurveTo, relative
	
	            // transform to absolute x,y
	            tempX = x + current[1];
	            tempY = y + current[2];
	
	            if (previous[0].match(/[QqTt]/) === null) {
	              // If there is no previous command or if the previous command was not a Q, q, T or t,
	              // assume the control point is coincident with the current point
	              controlX = x;
	              controlY = y;
	            }
	            else {
	              // calculate reflection of previous control point
	              controlX = 2 * x - controlX;
	              controlY = 2 * y - controlY;
	            }
	
	            ctx.quadraticCurveTo(
	              controlX + l,
	              controlY + t,
	              tempX + l,
	              tempY + t
	            );
	            x = tempX;
	            y = tempY;
	
	            break;
	
	          case 'T':
	            tempX = current[1];
	            tempY = current[2];
	
	            if (previous[0].match(/[QqTt]/) === null) {
	              // If there is no previous command or if the previous command was not a Q, q, T or t,
	              // assume the control point is coincident with the current point
	              controlX = x;
	              controlY = y;
	            }
	            else {
	              // calculate reflection of previous control point
	              controlX = 2 * x - controlX;
	              controlY = 2 * y - controlY;
	            }
	            ctx.quadraticCurveTo(
	              controlX + l,
	              controlY + t,
	              tempX + l,
	              tempY + t
	            );
	            x = tempX;
	            y = tempY;
	            break;
	
	          case 'a':
	            // TODO: optimize this
	            drawArc(ctx, x + l, y + t, [
	              current[1],
	              current[2],
	              current[3],
	              current[4],
	              current[5],
	              current[6] + x + l,
	              current[7] + y + t
	            ]);
	            x += current[6];
	            y += current[7];
	            break;
	
	          case 'A':
	            // TODO: optimize this
	            drawArc(ctx, x + l, y + t, [
	              current[1],
	              current[2],
	              current[3],
	              current[4],
	              current[5],
	              current[6] + l,
	              current[7] + t
	            ]);
	            x = current[6];
	            y = current[7];
	            break;
	
	          case 'z':
	          case 'Z':
	            x = subpathStartX;
	            y = subpathStartY;
	            ctx.closePath();
	            break;
	        }
	        previous = current;
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx context to render path on
	     */
	    _render: function(ctx) {
	      this._renderPathCommands(ctx);
	      this._renderFill(ctx);
	      this._renderStroke(ctx);
	    },
	
	    /**
	     * Returns string representation of an instance
	     * @return {String} string representation of an instance
	     */
	    toString: function() {
	      return '#<fabric.Path (' + this.complexity() +
	        '): { "top": ' + this.top + ', "left": ' + this.left + ' }>';
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      var o = extend(this.callSuper('toObject', propertiesToInclude), {
	        path: this.path.map(function(item) { return item.slice() }),
	        pathOffset: this.pathOffset
	      });
	      if (this.sourcePath) {
	        o.sourcePath = this.sourcePath;
	      }
	      if (this.transformMatrix) {
	        o.transformMatrix = this.transformMatrix;
	      }
	      return o;
	    },
	
	    /**
	     * Returns dataless object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toDatalessObject: function(propertiesToInclude) {
	      var o = this.toObject(propertiesToInclude);
	      if (this.sourcePath) {
	        o.path = this.sourcePath;
	      }
	      delete o.sourcePath;
	      return o;
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns svg representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var chunks = [],
	          markup = this._createBaseSVGMarkup(), addTransform = '';
	
	      for (var i = 0, len = this.path.length; i < len; i++) {
	        chunks.push(this.path[i].join(' '));
	      }
	      var path = chunks.join(' ');
	      if (!(this.group && this.group.type === 'path-group')) {
	        addTransform = ' translate(' + (-this.pathOffset.x) + ', ' + (-this.pathOffset.y) + ') ';
	      }
	      markup.push(
	        '<path ', this.getSvgId(),
	          'd="', path,
	          '" style="', this.getSvgStyles(),
	          '" transform="', this.getSvgTransform(), addTransform,
	          this.getSvgTransformMatrix(), '" stroke-linecap="round" ',
	        '/>\n'
	      );
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns number representation of an instance complexity
	     * @return {Number} complexity of this instance
	     */
	    complexity: function() {
	      return this.path.length;
	    },
	
	    /**
	     * @private
	     */
	    _parsePath: function() {
	      var result = [],
	          coords = [],
	          currentPath,
	          parsed,
	          re = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/ig,
	          match,
	          coordsStr;
	
	      for (var i = 0, coordsParsed, len = this.path.length; i < len; i++) {
	        currentPath = this.path[i];
	
	        coordsStr = currentPath.slice(1).trim();
	        coords.length = 0;
	
	        while ((match = re.exec(coordsStr))) {
	          coords.push(match[0]);
	        }
	
	        coordsParsed = [currentPath.charAt(0)];
	
	        for (var j = 0, jlen = coords.length; j < jlen; j++) {
	          parsed = parseFloat(coords[j]);
	          if (!isNaN(parsed)) {
	            coordsParsed.push(parsed);
	          }
	        }
	
	        var command = coordsParsed[0],
	            commandLength = commandLengths[command.toLowerCase()],
	            repeatedCommand = repeatedCommands[command] || command;
	
	        if (coordsParsed.length - 1 > commandLength) {
	          for (var k = 1, klen = coordsParsed.length; k < klen; k += commandLength) {
	            result.push([command].concat(coordsParsed.slice(k, k + commandLength)));
	            command = repeatedCommand;
	          }
	        }
	        else {
	          result.push(coordsParsed);
	        }
	      }
	
	      return result;
	    },
	
	    /**
	     * @private
	     */
	    _parseDimensions: function() {
	
	      var aX = [],
	          aY = [],
	          current, // current instruction
	          previous = null,
	          subpathStartX = 0,
	          subpathStartY = 0,
	          x = 0, // current x
	          y = 0, // current y
	          controlX = 0, // current control point x
	          controlY = 0, // current control point y
	          tempX,
	          tempY,
	          bounds;
	
	      for (var i = 0, len = this.path.length; i < len; ++i) {
	
	        current = this.path[i];
	
	        switch (current[0]) { // first letter
	
	          case 'l': // lineto, relative
	            x += current[1];
	            y += current[2];
	            bounds = [];
	            break;
	
	          case 'L': // lineto, absolute
	            x = current[1];
	            y = current[2];
	            bounds = [];
	            break;
	
	          case 'h': // horizontal lineto, relative
	            x += current[1];
	            bounds = [];
	            break;
	
	          case 'H': // horizontal lineto, absolute
	            x = current[1];
	            bounds = [];
	            break;
	
	          case 'v': // vertical lineto, relative
	            y += current[1];
	            bounds = [];
	            break;
	
	          case 'V': // verical lineto, absolute
	            y = current[1];
	            bounds = [];
	            break;
	
	          case 'm': // moveTo, relative
	            x += current[1];
	            y += current[2];
	            subpathStartX = x;
	            subpathStartY = y;
	            bounds = [];
	            break;
	
	          case 'M': // moveTo, absolute
	            x = current[1];
	            y = current[2];
	            subpathStartX = x;
	            subpathStartY = y;
	            bounds = [];
	            break;
	
	          case 'c': // bezierCurveTo, relative
	            tempX = x + current[5];
	            tempY = y + current[6];
	            controlX = x + current[3];
	            controlY = y + current[4];
	            bounds = fabric.util.getBoundsOfCurve(x, y,
	              x + current[1], // x1
	              y + current[2], // y1
	              controlX, // x2
	              controlY, // y2
	              tempX,
	              tempY
	            );
	            x = tempX;
	            y = tempY;
	            break;
	
	          case 'C': // bezierCurveTo, absolute
	            x = current[5];
	            y = current[6];
	            controlX = current[3];
	            controlY = current[4];
	            bounds = fabric.util.getBoundsOfCurve(x, y,
	              current[1],
	              current[2],
	              controlX,
	              controlY,
	              x,
	              y
	            );
	            break;
	
	          case 's': // shorthand cubic bezierCurveTo, relative
	
	            // transform to absolute x,y
	            tempX = x + current[3];
	            tempY = y + current[4];
	
	            if (previous[0].match(/[CcSs]/) === null) {
	              // If there is no previous command or if the previous command was not a C, c, S, or s,
	              // the control point is coincident with the current point
	              controlX = x;
	              controlY = y;
	            }
	            else {
	              // calculate reflection of previous control points
	              controlX = 2 * x - controlX;
	              controlY = 2 * y - controlY;
	            }
	
	            bounds = fabric.util.getBoundsOfCurve(x, y,
	              controlX,
	              controlY,
	              x + current[1],
	              y + current[2],
	              tempX,
	              tempY
	            );
	            // set control point to 2nd one of this command
	            // "... the first control point is assumed to be
	            // the reflection of the second control point on
	            // the previous command relative to the current point."
	            controlX = x + current[1];
	            controlY = y + current[2];
	            x = tempX;
	            y = tempY;
	            break;
	
	          case 'S': // shorthand cubic bezierCurveTo, absolute
	            tempX = current[3];
	            tempY = current[4];
	            if (previous[0].match(/[CcSs]/) === null) {
	              // If there is no previous command or if the previous command was not a C, c, S, or s,
	              // the control point is coincident with the current point
	              controlX = x;
	              controlY = y;
	            }
	            else {
	              // calculate reflection of previous control points
	              controlX = 2 * x - controlX;
	              controlY = 2 * y - controlY;
	            }
	            bounds = fabric.util.getBoundsOfCurve(x, y,
	              controlX,
	              controlY,
	              current[1],
	              current[2],
	              tempX,
	              tempY
	            );
	            x = tempX;
	            y = tempY;
	            // set control point to 2nd one of this command
	            // "... the first control point is assumed to be
	            // the reflection of the second control point on
	            // the previous command relative to the current point."
	            controlX = current[1];
	            controlY = current[2];
	            break;
	
	          case 'q': // quadraticCurveTo, relative
	            // transform to absolute x,y
	            tempX = x + current[3];
	            tempY = y + current[4];
	            controlX = x + current[1];
	            controlY = y + current[2];
	            bounds = fabric.util.getBoundsOfCurve(x, y,
	              controlX,
	              controlY,
	              controlX,
	              controlY,
	              tempX,
	              tempY
	            );
	            x = tempX;
	            y = tempY;
	            break;
	
	          case 'Q': // quadraticCurveTo, absolute
	            controlX = current[1];
	            controlY = current[2];
	            bounds = fabric.util.getBoundsOfCurve(x, y,
	              controlX,
	              controlY,
	              controlX,
	              controlY,
	              current[3],
	              current[4]
	            );
	            x = current[3];
	            y = current[4];
	            break;
	
	          case 't': // shorthand quadraticCurveTo, relative
	            // transform to absolute x,y
	            tempX = x + current[1];
	            tempY = y + current[2];
	            if (previous[0].match(/[QqTt]/) === null) {
	              // If there is no previous command or if the previous command was not a Q, q, T or t,
	              // assume the control point is coincident with the current point
	              controlX = x;
	              controlY = y;
	            }
	            else {
	              // calculate reflection of previous control point
	              controlX = 2 * x - controlX;
	              controlY = 2 * y - controlY;
	            }
	
	            bounds = fabric.util.getBoundsOfCurve(x, y,
	              controlX,
	              controlY,
	              controlX,
	              controlY,
	              tempX,
	              tempY
	            );
	            x = tempX;
	            y = tempY;
	
	            break;
	
	          case 'T':
	            tempX = current[1];
	            tempY = current[2];
	
	            if (previous[0].match(/[QqTt]/) === null) {
	              // If there is no previous command or if the previous command was not a Q, q, T or t,
	              // assume the control point is coincident with the current point
	              controlX = x;
	              controlY = y;
	            }
	            else {
	              // calculate reflection of previous control point
	              controlX = 2 * x - controlX;
	              controlY = 2 * y - controlY;
	            }
	            bounds = fabric.util.getBoundsOfCurve(x, y,
	              controlX,
	              controlY,
	              controlX,
	              controlY,
	              tempX,
	              tempY
	            );
	            x = tempX;
	            y = tempY;
	            break;
	
	          case 'a':
	            // TODO: optimize this
	            bounds = fabric.util.getBoundsOfArc(x, y,
	              current[1],
	              current[2],
	              current[3],
	              current[4],
	              current[5],
	              current[6] + x,
	              current[7] + y
	            );
	            x += current[6];
	            y += current[7];
	            break;
	
	          case 'A':
	            // TODO: optimize this
	            bounds = fabric.util.getBoundsOfArc(x, y,
	              current[1],
	              current[2],
	              current[3],
	              current[4],
	              current[5],
	              current[6],
	              current[7]
	            );
	            x = current[6];
	            y = current[7];
	            break;
	
	          case 'z':
	          case 'Z':
	            x = subpathStartX;
	            y = subpathStartY;
	            break;
	        }
	        previous = current;
	        bounds.forEach(function (point) {
	          aX.push(point.x);
	          aY.push(point.y);
	        });
	        aX.push(x);
	        aY.push(y);
	      }
	
	      var minX = min(aX) || 0,
	          minY = min(aY) || 0,
	          maxX = max(aX) || 0,
	          maxY = max(aY) || 0,
	          deltaX = maxX - minX,
	          deltaY = maxY - minY,
	
	          o = {
	            left: minX,
	            top: minY,
	            width: deltaX,
	            height: deltaY
	          };
	
	      return o;
	    }
	  });
	
	  /**
	   * Creates an instance of fabric.Path from an object
	   * @static
	   * @memberOf fabric.Path
	   * @param {Object} object
	   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
	   */
	  fabric.Path.fromObject = function(object, callback) {
	    // remove this pattern rom 2.0, accept just object.
	    var path;
	    if (typeof object.path === 'string') {
	      fabric.loadSVGFromURL(object.path, function (elements) {
	        var pathUrl = object.path;
	        path = elements[0];
	        delete object.path;
	
	        fabric.util.object.extend(path, object);
	        path.setSourcePath(pathUrl);
	
	        callback && callback(path);
	      });
	    }
	    else {
	      path = new fabric.Path(object.path, object);
	      callback && callback(path);
	      return path;
	    }
	  };
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by `fabric.Path.fromElement`)
	   * @static
	   * @memberOf fabric.Path
	   * @see http://www.w3.org/TR/SVG/paths.html#PathElement
	   */
	  fabric.Path.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(['d']);
	
	  /**
	   * Creates an instance of fabric.Path from an SVG <path> element
	   * @static
	   * @memberOf fabric.Path
	   * @param {SVGElement} element to parse
	   * @param {Function} callback Callback to invoke when an fabric.Path instance is created
	   * @param {Object} [options] Options object
	   */
	  fabric.Path.fromElement = function(element, callback, options) {
	    var parsedAttributes = fabric.parseAttributes(element, fabric.Path.ATTRIBUTE_NAMES);
	    callback && callback(new fabric.Path(parsedAttributes.d, extend(parsedAttributes, options)));
	  };
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Indicates that instances of this type are async
	   * @static
	   * @memberOf fabric.Path
	   * @type Boolean
	   * @default
	   */
	  fabric.Path.async = true;
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      invoke = fabric.util.array.invoke,
	      parentToObject = fabric.Object.prototype.toObject;
	
	  if (fabric.PathGroup) {
	    fabric.warn('fabric.PathGroup is already defined');
	    return;
	  }
	
	  /**
	   * Path group class
	   * @class fabric.PathGroup
	   * @extends fabric.Path
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#path_and_pathgroup}
	   * @see {@link fabric.PathGroup#initialize} for constructor definition
	   */
	  fabric.PathGroup = fabric.util.createClass(fabric.Path, /** @lends fabric.PathGroup.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'path-group',
	
	    /**
	     * Fill value
	     * @type String
	     * @default
	     */
	    fill: '',
	
	    /**
	     * Constructor
	     * @param {Array} paths
	     * @param {Object} [options] Options object
	     * @return {fabric.PathGroup} thisArg
	     */
	    initialize: function(paths, options) {
	
	      options = options || { };
	      this.paths = paths || [];
	
	      for (var i = this.paths.length; i--;) {
	        this.paths[i].group = this;
	      }
	
	      if (options.toBeParsed) {
	        this.parseDimensionsFromPaths(options);
	        delete options.toBeParsed;
	      }
	      this.setOptions(options);
	      this.setCoords();
	
	      if (options.sourcePath) {
	        this.setSourcePath(options.sourcePath);
	      }
	    },
	
	    /**
	     * Calculate width and height based on paths contained
	     */
	    parseDimensionsFromPaths: function(options) {
	      var points, p, xC = [], yC = [], path, height, width,
	          m;
	      for (var j = this.paths.length; j--;) {
	        path = this.paths[j];
	        height = path.height + path.strokeWidth;
	        width = path.width + path.strokeWidth;
	        points = [
	          { x: path.left, y: path.top },
	          { x: path.left + width, y: path.top },
	          { x: path.left, y: path.top + height },
	          { x: path.left + width, y: path.top + height }
	        ];
	        m = this.paths[j].transformMatrix;
	        for (var i = 0; i < points.length; i++) {
	          p = points[i];
	          if (m) {
	            p = fabric.util.transformPoint(p, m, false);
	          }
	          xC.push(p.x);
	          yC.push(p.y);
	        }
	      }
	      options.width = Math.max.apply(null, xC);
	      options.height = Math.max.apply(null, yC);
	    },
	
	    /**
	     * Renders this group on a specified context
	     * @param {CanvasRenderingContext2D} ctx Context to render this instance on
	     */
	    render: function(ctx) {
	      // do not render if object is not visible
	      if (!this.visible) {
	        return;
	      }
	
	      ctx.save();
	
	      if (this.transformMatrix) {
	        ctx.transform.apply(ctx, this.transformMatrix);
	      }
	      this.transform(ctx);
	
	      this._setShadow(ctx);
	      this.clipTo && fabric.util.clipContext(this, ctx);
	      ctx.translate(-this.width / 2, -this.height / 2);
	      for (var i = 0, l = this.paths.length; i < l; ++i) {
	        this.paths[i].render(ctx, true);
	      }
	      this.clipTo && ctx.restore();
	      ctx.restore();
	    },
	
	    /**
	     * Sets certain property to a certain value
	     * @param {String} prop
	     * @param {*} value
	     * @return {fabric.PathGroup} thisArg
	     */
	    _set: function(prop, value) {
	
	      if (prop === 'fill' && value && this.isSameColor()) {
	        var i = this.paths.length;
	        while (i--) {
	          this.paths[i]._set(prop, value);
	        }
	      }
	
	      return this.callSuper('_set', prop, value);
	    },
	
	    /**
	     * Returns object representation of this path group
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      var o = extend(parentToObject.call(this, propertiesToInclude), {
	        paths: invoke(this.getObjects(), 'toObject', propertiesToInclude)
	      });
	      if (this.sourcePath) {
	        o.sourcePath = this.sourcePath;
	      }
	      return o;
	    },
	
	    /**
	     * Returns dataless object representation of this path group
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} dataless object representation of an instance
	     */
	    toDatalessObject: function(propertiesToInclude) {
	      var o = this.toObject(propertiesToInclude);
	      if (this.sourcePath) {
	        o.paths = this.sourcePath;
	      }
	      return o;
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns svg representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var objects = this.getObjects(),
	          p = this.getPointByOrigin('left', 'top'),
	          translatePart = 'translate(' + p.x + ' ' + p.y + ')',
	          markup = this._createBaseSVGMarkup();
	      markup.push(
	        '<g ', this.getSvgId(),
	        'style="', this.getSvgStyles(), '" ',
	        'transform="', this.getSvgTransformMatrix(), translatePart, this.getSvgTransform(), '" ',
	        '>\n'
	      );
	
	      for (var i = 0, len = objects.length; i < len; i++) {
	        markup.push('\t', objects[i].toSVG(reviver));
	      }
	      markup.push('</g>\n');
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns a string representation of this path group
	     * @return {String} string representation of an object
	     */
	    toString: function() {
	      return '#<fabric.PathGroup (' + this.complexity() +
	        '): { top: ' + this.top + ', left: ' + this.left + ' }>';
	    },
	
	    /**
	     * Returns true if all paths in this group are of same color
	     * @return {Boolean} true if all paths are of the same color (`fill`)
	     */
	    isSameColor: function() {
	      var firstPathFill = this.getObjects()[0].get('fill') || '';
	      if (typeof firstPathFill !== 'string') {
	        return false;
	      }
	      firstPathFill = firstPathFill.toLowerCase();
	      return this.getObjects().every(function(path) {
	        var pathFill = path.get('fill') || '';
	        return typeof pathFill === 'string' && (pathFill).toLowerCase() === firstPathFill;
	      });
	    },
	
	    /**
	     * Returns number representation of object's complexity
	     * @return {Number} complexity
	     */
	    complexity: function() {
	      return this.paths.reduce(function(total, path) {
	        return total + ((path && path.complexity) ? path.complexity() : 0);
	      }, 0);
	    },
	
	    /**
	     * Returns all paths in this path group
	     * @return {Array} array of path objects included in this path group
	     */
	    getObjects: function() {
	      return this.paths;
	    }
	  });
	
	  /**
	   * Creates fabric.PathGroup instance from an object representation
	   * @static
	   * @memberOf fabric.PathGroup
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] Callback to invoke when an fabric.PathGroup instance is created
	   */
	  fabric.PathGroup.fromObject = function(object, callback) {
	    // remove this pattern from 2.0 accepts only object
	    if (typeof object.paths === 'string') {
	      fabric.loadSVGFromURL(object.paths, function (elements) {
	
	        var pathUrl = object.paths;
	        delete object.paths;
	
	        var pathGroup = fabric.util.groupSVGElements(elements, object, pathUrl);
	
	        callback(pathGroup);
	      });
	    }
	    else {
	      fabric.util.enlivenObjects(object.paths, function(enlivenedObjects) {
	        delete object.paths;
	        callback(new fabric.PathGroup(enlivenedObjects, object));
	      });
	    }
	  };
	
	  /**
	   * Indicates that instances of this type are async
	   * @static
	   * @memberOf fabric.PathGroup
	   * @type Boolean
	   * @default
	   */
	  fabric.PathGroup.async = true;
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      min = fabric.util.array.min,
	      max = fabric.util.array.max,
	      invoke = fabric.util.array.invoke;
	
	  if (fabric.Group) {
	    return;
	  }
	
	  // lock-related properties, for use in fabric.Group#get
	  // to enable locking behavior on group
	  // when one of its objects has lock-related properties set
	  var _lockProperties = {
	    lockMovementX:  true,
	    lockMovementY:  true,
	    lockRotation:   true,
	    lockScalingX:   true,
	    lockScalingY:   true,
	    lockUniScaling: true
	  };
	
	  /**
	   * Group class
	   * @class fabric.Group
	   * @extends fabric.Object
	   * @mixes fabric.Collection
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}
	   * @see {@link fabric.Group#initialize} for constructor definition
	   */
	  fabric.Group = fabric.util.createClass(fabric.Object, fabric.Collection, /** @lends fabric.Group.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'group',
	
	    /**
	     * Width of stroke
	     * @type Number
	     * @default
	     */
	    strokeWidth: 0,
	
	    /**
	     * Indicates if click events should also check for subtargets
	     * @type Boolean
	     * @default
	     */
	    subTargetCheck: false,
	
	    /**
	     * Constructor
	     * @param {Object} objects Group objects
	     * @param {Object} [options] Options object
	     * @param {Boolean} [isAlreadyGrouped] if true, objects have been grouped already.
	     * @return {Object} thisArg
	     */
	    initialize: function(objects, options, isAlreadyGrouped) {
	      options = options || { };
	
	      this._objects = [];
	      // if objects enclosed in a group have been grouped already,
	      // we cannot change properties of objects.
	      // Thus we need to set options to group without objects,
	      // because delegatedProperties propagate to objects.
	      isAlreadyGrouped && this.callSuper('initialize', options);
	
	      this._objects = objects || [];
	      for (var i = this._objects.length; i--; ) {
	        this._objects[i].group = this;
	      }
	
	      this.originalState = { };
	
	      if (options.originX) {
	        this.originX = options.originX;
	      }
	      if (options.originY) {
	        this.originY = options.originY;
	      }
	
	      if (isAlreadyGrouped) {
	        // do not change coordinate of objects enclosed in a group,
	        // because objects coordinate system have been group coodinate system already.
	        this._updateObjectsCoords(true);
	      }
	      else {
	        this._calcBounds();
	        this._updateObjectsCoords();
	        this.callSuper('initialize', options);
	      }
	
	      this.setCoords();
	      this.saveCoords();
	    },
	
	    /**
	     * @private
	     * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change
	     */
	    _updateObjectsCoords: function(skipCoordsChange) {
	      for (var i = this._objects.length; i--; ){
	        this._updateObjectCoords(this._objects[i], skipCoordsChange);
	      }
	    },
	
	    /**
	     * @private
	     * @param {Object} object
	     * @param {Boolean} [skipCoordsChange] if true, coordinates of object dose not change
	     */
	    _updateObjectCoords: function(object, skipCoordsChange) {
	      // do not display corners of objects enclosed in a group
	      object.__origHasControls = object.hasControls;
	      object.hasControls = false;
	
	      if (skipCoordsChange) {
	        return;
	      }
	
	      var objectLeft = object.getLeft(),
	          objectTop = object.getTop(),
	          center = this.getCenterPoint();
	
	      object.set({
	        originalLeft: objectLeft,
	        originalTop: objectTop,
	        left: objectLeft - center.x,
	        top: objectTop - center.y
	      });
	      object.setCoords();
	    },
	
	    /**
	     * Returns string represenation of a group
	     * @return {String}
	     */
	    toString: function() {
	      return '#<fabric.Group: (' + this.complexity() + ')>';
	    },
	
	    /**
	     * Adds an object to a group; Then recalculates group's dimension, position.
	     * @param {Object} object
	     * @return {fabric.Group} thisArg
	     * @chainable
	     */
	    addWithUpdate: function(object) {
	      this._restoreObjectsState();
	      fabric.util.resetObjectTransform(this);
	      if (object) {
	        this._objects.push(object);
	        object.group = this;
	        object._set('canvas', this.canvas);
	      }
	      // since _restoreObjectsState set objects inactive
	      this.forEachObject(this._setObjectActive, this);
	      this._calcBounds();
	      this._updateObjectsCoords();
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _setObjectActive: function(object) {
	      object.set('active', true);
	      object.group = this;
	    },
	
	    /**
	     * Removes an object from a group; Then recalculates group's dimension, position.
	     * @param {Object} object
	     * @return {fabric.Group} thisArg
	     * @chainable
	     */
	    removeWithUpdate: function(object) {
	      this._restoreObjectsState();
	      fabric.util.resetObjectTransform(this);
	      // since _restoreObjectsState set objects inactive
	      this.forEachObject(this._setObjectActive, this);
	
	      this.remove(object);
	      this._calcBounds();
	      this._updateObjectsCoords();
	
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _onObjectAdded: function(object) {
	      object.group = this;
	      object._set('canvas', this.canvas);
	    },
	
	    /**
	     * @private
	     */
	    _onObjectRemoved: function(object) {
	      delete object.group;
	      object.set('active', false);
	    },
	
	    /**
	     * Properties that are delegated to group objects when reading/writing
	     * @param {Object} delegatedProperties
	     */
	    delegatedProperties: {
	      fill:             true,
	      stroke:           true,
	      strokeWidth:      true,
	      fontFamily:       true,
	      fontWeight:       true,
	      fontSize:         true,
	      fontStyle:        true,
	      lineHeight:       true,
	      textDecoration:   true,
	      textAlign:        true,
	      backgroundColor:  true
	    },
	
	    /**
	     * @private
	     */
	    _set: function(key, value) {
	      var i = this._objects.length;
	
	      if (this.delegatedProperties[key] || key === 'canvas') {
	        while (i--) {
	          this._objects[i].set(key, value);
	        }
	      }
	      else {
	        while (i--) {
	          this._objects[i].setOnGroup(key, value);
	        }
	      }
	
	      this.callSuper('_set', key, value);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      return extend(this.callSuper('toObject', propertiesToInclude), {
	        objects: invoke(this._objects, 'toObject', propertiesToInclude)
	      });
	    },
	
	    /**
	     * Renders instance on a given context
	     * @param {CanvasRenderingContext2D} ctx context to render instance on
	     */
	    render: function(ctx) {
	      // do not render if object is not visible
	      if (!this.visible) {
	        return;
	      }
	
	      ctx.save();
	      if (this.transformMatrix) {
	        ctx.transform.apply(ctx, this.transformMatrix);
	      }
	      this.transform(ctx);
	      this._setShadow(ctx);
	      this.clipTo && fabric.util.clipContext(this, ctx);
	      this._transformDone = true;
	      // the array is now sorted in order of highest first, so start from end
	      for (var i = 0, len = this._objects.length; i < len; i++) {
	        this._renderObject(this._objects[i], ctx);
	      }
	
	      this.clipTo && ctx.restore();
	      ctx.restore();
	      this._transformDone = false;
	    },
	
	    /**
	     * Renders controls and borders for the object
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} [noTransform] When true, context is not transformed
	     */
	    _renderControls: function(ctx, noTransform) {
	      this.callSuper('_renderControls', ctx, noTransform);
	      for (var i = 0, len = this._objects.length; i < len; i++) {
	        this._objects[i]._renderControls(ctx);
	      }
	    },
	
	    /**
	     * @private
	     */
	    _renderObject: function(object, ctx) {
	      // do not render if object is not visible
	      if (!object.visible) {
	        return;
	      }
	
	      var originalHasRotatingPoint = object.hasRotatingPoint;
	      object.hasRotatingPoint = false;
	      object.render(ctx);
	      object.hasRotatingPoint = originalHasRotatingPoint;
	    },
	
	    /**
	     * Retores original state of each of group objects (original state is that which was before group was created).
	     * @private
	     * @return {fabric.Group} thisArg
	     * @chainable
	     */
	    _restoreObjectsState: function() {
	      this._objects.forEach(this._restoreObjectState, this);
	      return this;
	    },
	
	    /**
	     * Realises the transform from this group onto the supplied object
	     * i.e. it tells you what would happen if the supplied object was in
	     * the group, and then the group was destroyed. It mutates the supplied
	     * object.
	     * @param {fabric.Object} object
	     * @return {fabric.Object} transformedObject
	     */
	    realizeTransform: function(object) {
	      var matrix = object.calcTransformMatrix(),
	          options = fabric.util.qrDecompose(matrix),
	          center = new fabric.Point(options.translateX, options.translateY);
	      object.scaleX = options.scaleX;
	      object.scaleY = options.scaleY;
	      object.skewX = options.skewX;
	      object.skewY = options.skewY;
	      object.angle = options.angle;
	      object.flipX = false;
	      object.flipY = false;
	      object.setPositionByOrigin(center, 'center', 'center');
	      return object;
	    },
	
	    /**
	     * Restores original state of a specified object in group
	     * @private
	     * @param {fabric.Object} object
	     * @return {fabric.Group} thisArg
	     */
	    _restoreObjectState: function(object) {
	      this.realizeTransform(object);
	      object.setCoords();
	      object.hasControls = object.__origHasControls;
	      delete object.__origHasControls;
	      object.set('active', false);
	      delete object.group;
	
	      return this;
	    },
	
	    /**
	     * Destroys a group (restoring state of its objects)
	     * @return {fabric.Group} thisArg
	     * @chainable
	     */
	    destroy: function() {
	      return this._restoreObjectsState();
	    },
	
	    /**
	     * Saves coordinates of this instance (to be used together with `hasMoved`)
	     * @saveCoords
	     * @return {fabric.Group} thisArg
	     * @chainable
	     */
	    saveCoords: function() {
	      this._originalLeft = this.get('left');
	      this._originalTop = this.get('top');
	      return this;
	    },
	
	    /**
	     * Checks whether this group was moved (since `saveCoords` was called last)
	     * @return {Boolean} true if an object was moved (since fabric.Group#saveCoords was called)
	     */
	    hasMoved: function() {
	      return this._originalLeft !== this.get('left') ||
	             this._originalTop !== this.get('top');
	    },
	
	    /**
	     * Sets coordinates of all group objects
	     * @return {fabric.Group} thisArg
	     * @chainable
	     */
	    setObjectsCoords: function() {
	      this.forEachObject(function(object) {
	        object.setCoords();
	      });
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _calcBounds: function(onlyWidthHeight) {
	      var aX = [],
	          aY = [],
	          o, prop,
	          props = ['tr', 'br', 'bl', 'tl'],
	          i = 0, iLen = this._objects.length,
	          j, jLen = props.length;
	
	      for ( ; i < iLen; ++i) {
	        o = this._objects[i];
	        o.setCoords();
	        for (j = 0; j < jLen; j++) {
	          prop = props[j];
	          aX.push(o.oCoords[prop].x);
	          aY.push(o.oCoords[prop].y);
	        }
	      }
	
	      this.set(this._getBounds(aX, aY, onlyWidthHeight));
	    },
	
	    /**
	     * @private
	     */
	    _getBounds: function(aX, aY, onlyWidthHeight) {
	      var ivt = fabric.util.invertTransform(this.getViewportTransform()),
	          minXY = fabric.util.transformPoint(new fabric.Point(min(aX), min(aY)), ivt),
	          maxXY = fabric.util.transformPoint(new fabric.Point(max(aX), max(aY)), ivt),
	          obj = {
	            width: (maxXY.x - minXY.x) || 0,
	            height: (maxXY.y - minXY.y) || 0
	          };
	
	      if (!onlyWidthHeight) {
	        obj.left = minXY.x || 0;
	        obj.top = minXY.y || 0;
	        if (this.originX === 'center') {
	          obj.left += obj.width / 2;
	        }
	        if (this.originX === 'right') {
	          obj.left += obj.width;
	        }
	        if (this.originY === 'center') {
	          obj.top += obj.height / 2;
	        }
	        if (this.originY === 'bottom') {
	          obj.top += obj.height;
	        }
	      }
	      return obj;
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns svg representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var markup = this._createBaseSVGMarkup();
	      markup.push(
	        '<g ', this.getSvgId(), 'transform="',
	        /* avoiding styles intentionally */
	        this.getSvgTransform(),
	        this.getSvgTransformMatrix(),
	        '" style="',
	        this.getSvgFilter(),
	        '">\n'
	      );
	
	      for (var i = 0, len = this._objects.length; i < len; i++) {
	        markup.push('\t', this._objects[i].toSVG(reviver));
	      }
	
	      markup.push('</g>\n');
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns requested property
	     * @param {String} prop Property to get
	     * @return {*}
	     */
	    get: function(prop) {
	      if (prop in _lockProperties) {
	        if (this[prop]) {
	          return this[prop];
	        }
	        else {
	          for (var i = 0, len = this._objects.length; i < len; i++) {
	            if (this._objects[i][prop]) {
	              return true;
	            }
	          }
	          return false;
	        }
	      }
	      else {
	        if (prop in this.delegatedProperties) {
	          return this._objects[0] && this._objects[0].get(prop);
	        }
	        return this[prop];
	      }
	    }
	  });
	
	  /**
	   * Returns {@link fabric.Group} instance from an object representation
	   * @static
	   * @memberOf fabric.Group
	   * @param {Object} object Object to create a group from
	   * @param {Function} [callback] Callback to invoke when an group instance is created
	   */
	  fabric.Group.fromObject = function(object, callback) {
	    fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {
	      delete object.objects;
	      callback && callback(new fabric.Group(enlivenedObjects, object, true));
	    });
	  };
	
	  /**
	   * Indicates that instances of this type are async
	   * @static
	   * @memberOf fabric.Group
	   * @type Boolean
	   * @default
	   */
	  fabric.Group.async = true;
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var extend = fabric.util.object.extend;
	
	  if (!global.fabric) {
	    global.fabric = { };
	  }
	
	  if (global.fabric.Image) {
	    fabric.warn('fabric.Image is already defined.');
	    return;
	  }
	
	  var stateProperties = fabric.Object.prototype.stateProperties.concat();
	  stateProperties.push(
	    'alignX',
	    'alignY',
	    'meetOrSlice'
	  );
	
	  /**
	   * Image class
	   * @class fabric.Image
	   * @extends fabric.Object
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#images}
	   * @see {@link fabric.Image#initialize} for constructor definition
	   */
	  fabric.Image = fabric.util.createClass(fabric.Object, /** @lends fabric.Image.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'image',
	
	    /**
	     * crossOrigin value (one of "", "anonymous", "use-credentials")
	     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes
	     * @type String
	     * @default
	     */
	    crossOrigin: '',
	
	    /**
	     * AlignX value, part of preserveAspectRatio (one of "none", "mid", "min", "max")
	     * @see http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
	     * This parameter defines how the picture is aligned to its viewport when image element width differs from image width.
	     * @type String
	     * @default
	     */
	    alignX: 'none',
	
	    /**
	     * AlignY value, part of preserveAspectRatio (one of "none", "mid", "min", "max")
	     * @see http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
	     * This parameter defines how the picture is aligned to its viewport when image element height differs from image height.
	     * @type String
	     * @default
	     */
	    alignY: 'none',
	
	    /**
	     * meetOrSlice value, part of preserveAspectRatio  (one of "meet", "slice").
	     * if meet the image is always fully visibile, if slice the viewport is always filled with image.
	     * @see http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
	     * @type String
	     * @default
	     */
	    meetOrSlice: 'meet',
	
	    /**
	     * Width of a stroke.
	     * For image quality a stroke multiple of 2 gives better results.
	     * @type Number
	     * @default
	     */
	    strokeWidth: 0,
	
	    /**
	     * private
	     * contains last value of scaleX to detect
	     * if the Image got resized after the last Render
	     * @type Number
	     */
	    _lastScaleX: 1,
	
	    /**
	     * private
	     * contains last value of scaleY to detect
	     * if the Image got resized after the last Render
	     * @type Number
	     */
	    _lastScaleY: 1,
	
	    /**
	     * minimum scale factor under which any resizeFilter is triggered to resize the image
	     * 0 will disable the automatic resize. 1 will trigger automatically always.
	     * number bigger than 1 can be used in case we want to scale with some filter above
	     * the natural image dimensions
	     * @type Number
	     */
	    minimumScaleTrigger: 0.5,
	
	    /**
	     * List of properties to consider when checking if
	     * state of an object is changed ({@link fabric.Object#hasStateChanged})
	     * as well as for history (undo/redo) purposes
	     * @type Array
	     */
	    stateProperties: stateProperties,
	
	    /**
	     * Constructor
	     * @param {HTMLImageElement | String} element Image element
	     * @param {Object} [options] Options object
	     * @param {function} [callback] callback function to call after eventual filters applied.
	     * @return {fabric.Image} thisArg
	     */
	    initialize: function(element, options, callback) {
	      options || (options = { });
	      this.filters = [];
	      this.resizeFilters = [];
	      this.callSuper('initialize', options);
	      this._initElement(element, options, callback);
	    },
	
	    /**
	     * Returns image element which this instance if based on
	     * @return {HTMLImageElement} Image element
	     */
	    getElement: function() {
	      return this._element;
	    },
	
	    /**
	     * Sets image element for this instance to a specified one.
	     * If filters defined they are applied to new image.
	     * You might need to call `canvas.renderAll` and `object.setCoords` after replacing, to render new image and update controls area.
	     * @param {HTMLImageElement} element
	     * @param {Function} [callback] Callback is invoked when all filters have been applied and new image is generated
	     * @param {Object} [options] Options object
	     * @return {fabric.Image} thisArg
	     * @chainable
	     */
	    setElement: function(element, callback, options) {
	
	      var _callback, _this;
	
	      this._element = element;
	      this._originalElement = element;
	      this._initConfig(options);
	
	      if (this.resizeFilters.length === 0) {
	        _callback = callback;
	      }
	      else {
	        _this = this;
	        _callback = function() {
	          _this.applyFilters(callback, _this.resizeFilters, _this._filteredEl || _this._originalElement, true);
	        };
	      }
	
	      if (this.filters.length !== 0) {
	        this.applyFilters(_callback);
	      }
	      else if (_callback) {
	        _callback(this);
	      }
	
	      return this;
	    },
	
	    /**
	     * Sets crossOrigin value (on an instance and corresponding image element)
	     * @return {fabric.Image} thisArg
	     * @chainable
	     */
	    setCrossOrigin: function(value) {
	      this.crossOrigin = value;
	      this._element.crossOrigin = value;
	
	      return this;
	    },
	
	    /**
	     * Returns original size of an image
	     * @return {Object} Object with "width" and "height" properties
	     */
	    getOriginalSize: function() {
	      var element = this.getElement();
	      return {
	        width: element.width,
	        height: element.height
	      };
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _stroke: function(ctx) {
	      if (!this.stroke || this.strokeWidth === 0) {
	        return;
	      }
	      var w = this.width / 2, h = this.height / 2;
	      ctx.beginPath();
	      ctx.moveTo(-w, -h);
	      ctx.lineTo(w, -h);
	      ctx.lineTo(w, h);
	      ctx.lineTo(-w, h);
	      ctx.lineTo(-w, -h);
	      ctx.closePath();
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderDashedStroke: function(ctx) {
	      var x = -this.width / 2,
	          y = -this.height / 2,
	          w = this.width,
	          h = this.height;
	
	      ctx.save();
	      this._setStrokeStyles(ctx);
	
	      ctx.beginPath();
	      fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);
	      fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);
	      fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);
	      fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);
	      ctx.closePath();
	      ctx.restore();
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      var filters = [], resizeFilters = [],
	          scaleX = 1, scaleY = 1;
	
	      this.filters.forEach(function(filterObj) {
	        if (filterObj) {
	          if (filterObj.type === 'Resize') {
	            scaleX *= filterObj.scaleX;
	            scaleY *= filterObj.scaleY;
	          }
	          filters.push(filterObj.toObject());
	        }
	      });
	
	      this.resizeFilters.forEach(function(filterObj) {
	        filterObj && resizeFilters.push(filterObj.toObject());
	      });
	
	      var object = extend(this.callSuper('toObject', propertiesToInclude), {
	        src: this.getSrc(),
	        filters: filters,
	        resizeFilters: resizeFilters,
	        crossOrigin: this.crossOrigin,
	        alignX: this.alignX,
	        alignY: this.alignY,
	        meetOrSlice: this.meetOrSlice
	      });
	
	      object.width /= scaleX;
	      object.height /= scaleY;
	
	      if (!this.includeDefaultValues) {
	        this._removeDefaultValues(object);
	      }
	
	      return object;
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns SVG representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var markup = this._createBaseSVGMarkup(), x = -this.width / 2, y = -this.height / 2,
	          preserveAspectRatio = 'none', filtered = true;
	      if (this.group && this.group.type === 'path-group') {
	        x = this.left;
	        y = this.top;
	      }
	      if (this.alignX !== 'none' && this.alignY !== 'none') {
	        preserveAspectRatio = 'x' + this.alignX + 'Y' + this.alignY + ' ' + this.meetOrSlice;
	      }
	      markup.push(
	        '<g transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '">\n',
	          '<image ', this.getSvgId(), 'xlink:href="', this.getSvgSrc(filtered),
	            '" x="', x, '" y="', y,
	            '" style="', this.getSvgStyles(),
	            // we're essentially moving origin of transformation from top/left corner to the center of the shape
	            // by wrapping it in container <g> element with actual transformation, then offsetting object to the top/left
	            // so that object's center aligns with container's left/top
	            '" width="', this.width,
	            '" height="', this.height,
	            '" preserveAspectRatio="', preserveAspectRatio, '"',
	          '></image>\n'
	      );
	
	      if (this.stroke || this.strokeDashArray) {
	        var origFill = this.fill;
	        this.fill = null;
	        markup.push(
	          '<rect ',
	            'x="', x, '" y="', y,
	            '" width="', this.width, '" height="', this.height,
	            '" style="', this.getSvgStyles(),
	          '"/>\n'
	        );
	        this.fill = origFill;
	      }
	
	      markup.push('</g>\n');
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns source of an image
	     * @param {Boolean} filtered indicates if the src is needed for svg
	     * @return {String} Source of an image
	     */
	    getSrc: function(filtered) {
	      var element = filtered ? this._element : this._originalElement;
	      if (element) {
	        return fabric.isLikelyNode ? element._src : element.src;
	      }
	      else {
	        return this.src || '';
	      }
	    },
	
	    /**
	     * Sets source of an image
	     * @param {String} src Source string (URL)
	     * @param {Function} [callback] Callback is invoked when image has been loaded (and all filters have been applied)
	     * @param {Object} [options] Options object
	     * @return {fabric.Image} thisArg
	     * @chainable
	     */
	    setSrc: function(src, callback, options) {
	      fabric.util.loadImage(src, function(img) {
	        return this.setElement(img, callback, options);
	      }, this, options && options.crossOrigin);
	    },
	
	    /**
	     * Returns string representation of an instance
	     * @return {String} String representation of an instance
	     */
	    toString: function() {
	      return '#<fabric.Image: { src: "' + this.getSrc() + '" }>';
	    },
	
	    /**
	     * Applies filters assigned to this image (from "filters" array)
	     * @method applyFilters
	     * @param {Function} callback Callback is invoked when all filters have been applied and new image is generated
	     * @param {Array} filters to be applied
	     * @param {fabric.Image} imgElement image to filter ( default to this._element )
	     * @param {Boolean} forResizing
	     * @return {CanvasElement} canvasEl to be drawn immediately
	     * @chainable
	     */
	    applyFilters: function(callback, filters, imgElement, forResizing) {
	
	      filters = filters || this.filters;
	      imgElement = imgElement || this._originalElement;
	
	      if (!imgElement) {
	        return;
	      }
	
	      var replacement = fabric.util.createImage(),
	          retinaScaling = this.canvas ? this.canvas.getRetinaScaling() : fabric.devicePixelRatio,
	          minimumScale = this.minimumScaleTrigger / retinaScaling,
	          _this = this, scaleX, scaleY;
	
	      if (filters.length === 0) {
	        this._element = imgElement;
	        callback && callback(this);
	        return imgElement;
	      }
	
	      var canvasEl = fabric.util.createCanvasElement();
	      canvasEl.width = imgElement.width;
	      canvasEl.height = imgElement.height;
	      canvasEl.getContext('2d').drawImage(imgElement, 0, 0, imgElement.width, imgElement.height);
	
	      filters.forEach(function(filter) {
	        if (!filter) {
	          return;
	        }
	        if (forResizing) {
	          scaleX = _this.scaleX < minimumScale ? _this.scaleX : 1;
	          scaleY = _this.scaleY < minimumScale ? _this.scaleY : 1;
	          if (scaleX * retinaScaling < 1) {
	            scaleX *= retinaScaling;
	          }
	          if (scaleY * retinaScaling < 1) {
	            scaleY *= retinaScaling;
	          }
	        }
	        else {
	          scaleX = filter.scaleX;
	          scaleY = filter.scaleY;
	        }
	        filter.applyTo(canvasEl, scaleX, scaleY);
	        if (!forResizing && filter.type === 'Resize') {
	          _this.width *= filter.scaleX;
	          _this.height *= filter.scaleY;
	        }
	      });
	
	      /** @ignore */
	      replacement.width = canvasEl.width;
	      replacement.height = canvasEl.height;
	      if (fabric.isLikelyNode) {
	        replacement.src = canvasEl.toBuffer(undefined, fabric.Image.pngCompression);
	        // onload doesn't fire in some node versions, so we invoke callback manually
	        _this._element = replacement;
	        !forResizing && (_this._filteredEl = replacement);
	        callback && callback(_this);
	      }
	      else {
	        replacement.onload = function() {
	          _this._element = replacement;
	          !forResizing && (_this._filteredEl = replacement);
	          callback && callback(_this);
	          replacement.onload = canvasEl = null;
	        };
	        replacement.src = canvasEl.toDataURL('image/png');
	      }
	      return canvasEl;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} noTransform
	     */
	    _render: function(ctx, noTransform) {
	      var x, y, imageMargins = this._findMargins(), elementToDraw;
	
	      x = (noTransform ? this.left : -this.width / 2);
	      y = (noTransform ? this.top : -this.height / 2);
	
	      if (this.meetOrSlice === 'slice') {
	        ctx.beginPath();
	        ctx.rect(x, y, this.width, this.height);
	        ctx.clip();
	      }
	
	      if (this.isMoving === false && this.resizeFilters.length && this._needsResize()) {
	        this._lastScaleX = this.scaleX;
	        this._lastScaleY = this.scaleY;
	        elementToDraw = this.applyFilters(null, this.resizeFilters, this._filteredEl || this._originalElement, true);
	      }
	      else {
	        elementToDraw = this._element;
	      }
	      elementToDraw && ctx.drawImage(elementToDraw,
	                                     x + imageMargins.marginX,
	                                     y + imageMargins.marginY,
	                                     imageMargins.width,
	                                     imageMargins.height
	                                    );
	
	      this._stroke(ctx);
	      this._renderStroke(ctx);
	    },
	
	    /**
	     * @private, needed to check if image needs resize
	     */
	    _needsResize: function() {
	      return (this.scaleX !== this._lastScaleX || this.scaleY !== this._lastScaleY);
	    },
	
	    /**
	     * @private
	     */
	    _findMargins: function() {
	      var width = this.width, height = this.height, scales,
	          scale, marginX = 0, marginY = 0;
	
	      if (this.alignX !== 'none' || this.alignY !== 'none') {
	        scales = [this.width / this._element.width, this.height / this._element.height];
	        scale = this.meetOrSlice === 'meet'
	                ? Math.min.apply(null, scales) : Math.max.apply(null, scales);
	        width = this._element.width * scale;
	        height = this._element.height * scale;
	        if (this.alignX === 'Mid') {
	          marginX = (this.width - width) / 2;
	        }
	        if (this.alignX === 'Max') {
	          marginX = this.width - width;
	        }
	        if (this.alignY === 'Mid') {
	          marginY = (this.height - height) / 2;
	        }
	        if (this.alignY === 'Max') {
	          marginY = this.height - height;
	        }
	      }
	      return {
	        width:  width,
	        height: height,
	        marginX: marginX,
	        marginY: marginY
	      };
	    },
	
	    /**
	     * @private
	     */
	    _resetWidthHeight: function() {
	      var element = this.getElement();
	
	      this.set('width', element.width);
	      this.set('height', element.height);
	    },
	
	    /**
	     * The Image class's initialization method. This method is automatically
	     * called by the constructor.
	     * @private
	     * @param {HTMLImageElement|String} element The element representing the image
	     * @param {Object} [options] Options object
	     */
	    _initElement: function(element, options, callback) {
	      this.setElement(fabric.util.getById(element), callback, options);
	      fabric.util.addClass(this.getElement(), fabric.Image.CSS_CANVAS);
	    },
	
	    /**
	     * @private
	     * @param {Object} [options] Options object
	     */
	    _initConfig: function(options) {
	      options || (options = { });
	      this.setOptions(options);
	      this._setWidthHeight(options);
	      if (this._element && this.crossOrigin) {
	        this._element.crossOrigin = this.crossOrigin;
	      }
	    },
	
	    /**
	     * @private
	     * @param {Array} filters to be initialized
	     * @param {Function} callback Callback to invoke when all fabric.Image.filters instances are created
	     */
	    _initFilters: function(filters, callback) {
	      if (filters && filters.length) {
	        fabric.util.enlivenObjects(filters, function(enlivenedObjects) {
	          callback && callback(enlivenedObjects);
	        }, 'fabric.Image.filters');
	      }
	      else {
	        callback && callback();
	      }
	    },
	
	    /**
	     * @private
	     * @param {Object} [options] Object with width/height properties
	     */
	    _setWidthHeight: function(options) {
	      this.width = 'width' in options
	        ? options.width
	        : (this.getElement()
	            ? this.getElement().width || 0
	            : 0);
	
	      this.height = 'height' in options
	        ? options.height
	        : (this.getElement()
	            ? this.getElement().height || 0
	            : 0);
	    },
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity of this instance
	     */
	    complexity: function() {
	      return 1;
	    }
	  });
	
	  /**
	   * Default CSS class name for canvas
	   * @static
	   * @type String
	   * @default
	   */
	  fabric.Image.CSS_CANVAS = 'canvas-img';
	
	  /**
	   * Alias for getSrc
	   * @static
	   */
	  fabric.Image.prototype.getSvgSrc = fabric.Image.prototype.getSrc;
	
	  /**
	   * Creates an instance of fabric.Image from its object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @param {Function} callback Callback to invoke when an image instance is created
	   */
	  fabric.Image.fromObject = function(object, callback) {
	    fabric.util.loadImage(object.src, function(img) {
	      fabric.Image.prototype._initFilters.call(object, object.filters, function(filters) {
	        object.filters = filters || [];
	        fabric.Image.prototype._initFilters.call(object, object.resizeFilters, function(resizeFilters) {
	          object.resizeFilters = resizeFilters || [];
	          return new fabric.Image(img, object, callback);
	        });
	      });
	    }, null, object.crossOrigin);
	  };
	
	  /**
	   * Creates an instance of fabric.Image from an URL string
	   * @static
	   * @param {String} url URL to create an image from
	   * @param {Function} [callback] Callback to invoke when image is created (newly created image is passed as a first argument)
	   * @param {Object} [imgOptions] Options object
	   */
	  fabric.Image.fromURL = function(url, callback, imgOptions) {
	    fabric.util.loadImage(url, function(img) {
	      callback && callback(new fabric.Image(img, imgOptions));
	    }, null, imgOptions && imgOptions.crossOrigin);
	  };
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Image.fromElement})
	   * @static
	   * @see {@link http://www.w3.org/TR/SVG/struct.html#ImageElement}
	   */
	  fabric.Image.ATTRIBUTE_NAMES =
	    fabric.SHARED_ATTRIBUTES.concat('x y width height preserveAspectRatio xlink:href'.split(' '));
	
	  /**
	   * Returns {@link fabric.Image} instance from an SVG element
	   * @static
	   * @param {SVGElement} element Element to parse
	   * @param {Function} callback Callback to execute when fabric.Image object is created
	   * @param {Object} [options] Options object
	   * @return {fabric.Image} Instance of fabric.Image
	   */
	  fabric.Image.fromElement = function(element, callback, options) {
	    var parsedAttributes = fabric.parseAttributes(element, fabric.Image.ATTRIBUTE_NAMES),
	        preserveAR;
	
	    if (parsedAttributes.preserveAspectRatio) {
	      preserveAR = fabric.util.parsePreserveAspectRatioAttribute(parsedAttributes.preserveAspectRatio);
	      extend(parsedAttributes, preserveAR);
	    }
	
	    fabric.Image.fromURL(parsedAttributes['xlink:href'], callback,
	      extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));
	  };
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Indicates that instances of this type are async
	   * @static
	   * @type Boolean
	   * @default
	   */
	  fabric.Image.async = true;
	
	  /**
	   * Indicates compression level used when generating PNG under Node (in applyFilters). Any of 0-9
	   * @static
	   * @type Number
	   * @default
	   */
	  fabric.Image.pngCompression = 1;
	
	})( true ? exports : this);
	
	
	fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
	
	  /**
	   * @private
	   * @return {Number} angle value
	   */
	  _getAngleValueForStraighten: function() {
	    var angle = this.getAngle() % 360;
	    if (angle > 0) {
	      return Math.round((angle - 1) / 90) * 90;
	    }
	    return Math.round(angle / 90) * 90;
	  },
	
	  /**
	   * Straightens an object (rotating it from current angle to one of 0, 90, 180, 270, etc. depending on which is closer)
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  straighten: function() {
	    this.setAngle(this._getAngleValueForStraighten());
	    return this;
	  },
	
	  /**
	   * Same as {@link fabric.Object.prototype.straighten} but with animation
	   * @param {Object} callbacks Object with callback functions
	   * @param {Function} [callbacks.onComplete] Invoked on completion
	   * @param {Function} [callbacks.onChange] Invoked on every step of animation
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  fxStraighten: function(callbacks) {
	    callbacks = callbacks || { };
	
	    var empty = function() { },
	        onComplete = callbacks.onComplete || empty,
	        onChange = callbacks.onChange || empty,
	        _this = this;
	
	    fabric.util.animate({
	      startValue: this.get('angle'),
	      endValue: this._getAngleValueForStraighten(),
	      duration: this.FX_DURATION,
	      onChange: function(value) {
	        _this.setAngle(value);
	        onChange();
	      },
	      onComplete: function() {
	        _this.setCoords();
	        onComplete();
	      },
	      onStart: function() {
	        _this.set('active', false);
	      }
	    });
	
	    return this;
	  }
	});
	
	fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {
	
	  /**
	   * Straightens object, then rerenders canvas
	   * @param {fabric.Object} object Object to straighten
	   * @return {fabric.Canvas} thisArg
	   * @chainable
	   */
	  straightenObject: function (object) {
	    object.straighten();
	    this.renderAll();
	    return this;
	  },
	
	  /**
	   * Same as {@link fabric.Canvas.prototype.straightenObject}, but animated
	   * @param {fabric.Object} object Object to straighten
	   * @return {fabric.Canvas} thisArg
	   * @chainable
	   */
	  fxStraightenObject: function (object) {
	    object.fxStraighten({
	      onChange: this.renderAll.bind(this)
	    });
	    return this;
	  }
	});
	
	
	/**
	 * @namespace fabric.Image.filters
	 * @memberOf fabric.Image
	 * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#image_filters}
	 * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	 */
	fabric.Image.filters = fabric.Image.filters || { };
	
	/**
	 * Root filter class from which all filter classes inherit from
	 * @class fabric.Image.filters.BaseFilter
	 * @memberOf fabric.Image.filters
	 */
	fabric.Image.filters.BaseFilter = fabric.util.createClass(/** @lends fabric.Image.filters.BaseFilter.prototype */ {
	
	  /**
	   * Filter type
	   * @param {String} type
	   * @default
	   */
	  type: 'BaseFilter',
	
	  /**
	   * Constructor
	   * @param {Object} [options] Options object
	   */
	  initialize: function(options) {
	    if (options) {
	      this.setOptions(options);
	    }
	  },
	
	  /**
	   * Sets filter's properties from options
	   * @param {Object} [options] Options object
	   */
	  setOptions: function(options) {
	    for (var prop in options) {
	      this[prop] = options[prop];
	    }
	  },
	
	  /**
	   * Returns object representation of an instance
	   * @return {Object} Object representation of an instance
	   */
	  toObject: function() {
	    return { type: this.type };
	  },
	
	  /**
	   * Returns a JSON representation of an instance
	   * @return {Object} JSON
	   */
	  toJSON: function() {
	    // delegate, not alias
	    return this.toObject();
	  }
	});
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Brightness filter class
	   * @class fabric.Image.filters.Brightness
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.Brightness#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Brightness({
	   *   brightness: 200
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Brightness = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Brightness.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Brightness',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.Brightness.prototype
	     * @param {Object} [options] Options object
	     * @param {Number} [options.brightness=0] Value to brighten the image up (-255..255)
	     */
	    initialize: function(options) {
	      options = options || { };
	      this.brightness = options.brightness || 0;
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          brightness = this.brightness;
	
	      for (var i = 0, len = data.length; i < len; i += 4) {
	        data[i] += brightness;
	        data[i + 1] += brightness;
	        data[i + 2] += brightness;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        brightness: this.brightness
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.Image.filters.Brightness} Instance of fabric.Image.filters.Brightness
	   */
	  fabric.Image.filters.Brightness.fromObject = function(object) {
	    return new fabric.Image.filters.Brightness(object);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Adapted from <a href="http://www.html5rocks.com/en/tutorials/canvas/imagefilters/">html5rocks article</a>
	   * @class fabric.Image.filters.Convolute
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.Convolute#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example <caption>Sharpen filter</caption>
	   * var filter = new fabric.Image.filters.Convolute({
	   *   matrix: [ 0, -1,  0,
	   *            -1,  5, -1,
	   *             0, -1,  0 ]
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   * @example <caption>Blur filter</caption>
	   * var filter = new fabric.Image.filters.Convolute({
	   *   matrix: [ 1/9, 1/9, 1/9,
	   *             1/9, 1/9, 1/9,
	   *             1/9, 1/9, 1/9 ]
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   * @example <caption>Emboss filter</caption>
	   * var filter = new fabric.Image.filters.Convolute({
	   *   matrix: [ 1,   1,  1,
	   *             1, 0.7, -1,
	   *            -1,  -1, -1 ]
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   * @example <caption>Emboss filter with opaqueness</caption>
	   * var filter = new fabric.Image.filters.Convolute({
	   *   opaque: true,
	   *   matrix: [ 1,   1,  1,
	   *             1, 0.7, -1,
	   *            -1,  -1, -1 ]
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Convolute = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Convolute.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Convolute',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.Convolute.prototype
	     * @param {Object} [options] Options object
	     * @param {Boolean} [options.opaque=false] Opaque value (true/false)
	     * @param {Array} [options.matrix] Filter matrix
	     */
	    initialize: function(options) {
	      options = options || { };
	
	      this.opaque = options.opaque;
	      this.matrix = options.matrix || [
	        0, 0, 0,
	        0, 1, 0,
	        0, 0, 0
	      ];
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	
	      var weights = this.matrix,
	          context = canvasEl.getContext('2d'),
	          pixels = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	
	          side = Math.round(Math.sqrt(weights.length)),
	          halfSide = Math.floor(side / 2),
	          src = pixels.data,
	          sw = pixels.width,
	          sh = pixels.height,
	          output = context.createImageData(sw, sh),
	          dst = output.data,
	          // go through the destination image pixels
	          alphaFac = this.opaque ? 1 : 0,
	          r, g, b, a, dstOff,
	          scx, scy, srcOff, wt;
	
	      for (var y = 0; y < sh; y++) {
	        for (var x = 0; x < sw; x++) {
	          dstOff = (y * sw + x) * 4;
	          // calculate the weighed sum of the source image pixels that
	          // fall under the convolution matrix
	          r = 0; g = 0; b = 0; a = 0;
	
	          for (var cy = 0; cy < side; cy++) {
	            for (var cx = 0; cx < side; cx++) {
	              scy = y + cy - halfSide;
	              scx = x + cx - halfSide;
	
	              // eslint-disable-next-line max-depth
	              if (scy < 0 || scy > sh || scx < 0 || scx > sw) {
	                continue;
	              }
	
	              srcOff = (scy * sw + scx) * 4;
	              wt = weights[cy * side + cx];
	
	              r += src[srcOff] * wt;
	              g += src[srcOff + 1] * wt;
	              b += src[srcOff + 2] * wt;
	              a += src[srcOff + 3] * wt;
	            }
	          }
	          dst[dstOff] = r;
	          dst[dstOff + 1] = g;
	          dst[dstOff + 2] = b;
	          dst[dstOff + 3] = a + alphaFac * (255 - a);
	        }
	      }
	
	      context.putImageData(output, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        opaque: this.opaque,
	        matrix: this.matrix
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.Image.filters.Convolute} Instance of fabric.Image.filters.Convolute
	   */
	  fabric.Image.filters.Convolute.fromObject = function(object) {
	    return new fabric.Image.filters.Convolute(object);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * GradientTransparency filter class
	   * @class fabric.Image.filters.GradientTransparency
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.GradientTransparency#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.GradientTransparency({
	   *   threshold: 200
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	   // eslint-disable-next-line max-len
	  filters.GradientTransparency = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.GradientTransparency.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'GradientTransparency',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.GradientTransparency.prototype
	     * @param {Object} [options] Options object
	     * @param {Number} [options.threshold=100] Threshold value
	     */
	    initialize: function(options) {
	      options = options || { };
	      this.threshold = options.threshold || 100;
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          threshold = this.threshold,
	          total = data.length;
	
	      for (var i = 0, len = data.length; i < len; i += 4) {
	        data[i + 3] = threshold + 255 * (total - i) / total;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        threshold: this.threshold
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.Image.filters.GradientTransparency} Instance of fabric.Image.filters.GradientTransparency
	   */
	  fabric.Image.filters.GradientTransparency.fromObject = function(object) {
	    return new fabric.Image.filters.GradientTransparency(object);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Grayscale image filter class
	   * @class fabric.Image.filters.Grayscale
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Grayscale();
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Grayscale = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Grayscale.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Grayscale',
	
	    /**
	     * Applies filter to canvas element
	     * @memberOf fabric.Image.filters.Grayscale.prototype
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          len = imageData.width * imageData.height * 4,
	          index = 0,
	          average;
	
	      while (index < len) {
	        average = (data[index] + data[index + 1] + data[index + 2]) / 3;
	        data[index]     = average;
	        data[index + 1] = average;
	        data[index + 2] = average;
	        index += 4;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @return {fabric.Image.filters.Grayscale} Instance of fabric.Image.filters.Grayscale
	   */
	  fabric.Image.filters.Grayscale.fromObject = function() {
	    return new fabric.Image.filters.Grayscale();
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Invert filter class
	   * @class fabric.Image.filters.Invert
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Invert();
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Invert = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Invert.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Invert',
	
	    /**
	     * Applies filter to canvas element
	     * @memberOf fabric.Image.filters.Invert.prototype
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          iLen = data.length, i;
	
	      for (i = 0; i < iLen; i += 4) {
	        data[i] = 255 - data[i];
	        data[i + 1] = 255 - data[i + 1];
	        data[i + 2] = 255 - data[i + 2];
	      }
	
	      context.putImageData(imageData, 0, 0);
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @return {fabric.Image.filters.Invert} Instance of fabric.Image.filters.Invert
	   */
	  fabric.Image.filters.Invert.fromObject = function() {
	    return new fabric.Image.filters.Invert();
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Mask filter class
	   * See http://resources.aleph-1.com/mask/
	   * @class fabric.Image.filters.Mask
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.Mask#initialize} for constructor definition
	   */
	  filters.Mask = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Mask.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Mask',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.Mask.prototype
	     * @param {Object} [options] Options object
	     * @param {fabric.Image} [options.mask] Mask image object
	     * @param {Number} [options.channel=0] Rgb channel (0, 1, 2 or 3)
	     */
	    initialize: function(options) {
	      options = options || { };
	
	      this.mask = options.mask;
	      this.channel = [0, 1, 2, 3].indexOf(options.channel) > -1 ? options.channel : 0;
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      if (!this.mask) {
	        return;
	      }
	
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          maskEl = this.mask.getElement(),
	          maskCanvasEl = fabric.util.createCanvasElement(),
	          channel = this.channel,
	          i,
	          iLen = imageData.width * imageData.height * 4;
	
	      maskCanvasEl.width = canvasEl.width;
	      maskCanvasEl.height = canvasEl.height;
	
	      maskCanvasEl.getContext('2d').drawImage(maskEl, 0, 0, canvasEl.width, canvasEl.height);
	
	      var maskImageData = maskCanvasEl.getContext('2d').getImageData(0, 0, canvasEl.width, canvasEl.height),
	          maskData = maskImageData.data;
	
	      for (i = 0; i < iLen; i += 4) {
	        data[i + 3] = maskData[i + channel];
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        mask: this.mask.toObject(),
	        channel: this.channel
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] Callback to invoke when a mask filter instance is created
	   */
	  fabric.Image.filters.Mask.fromObject = function(object, callback) {
	    fabric.util.loadImage(object.mask.src, function(img) {
	      object.mask = new fabric.Image(img, object.mask);
	      callback && callback(new fabric.Image.filters.Mask(object));
	    });
	  };
	
	  /**
	   * Indicates that instances of this type are async
	   * @static
	   * @type Boolean
	   * @default
	   */
	  fabric.Image.filters.Mask.async = true;
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Noise filter class
	   * @class fabric.Image.filters.Noise
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.Noise#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Noise({
	   *   noise: 700
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Noise = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Noise.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Noise',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.Noise.prototype
	     * @param {Object} [options] Options object
	     * @param {Number} [options.noise=0] Noise value
	     */
	    initialize: function(options) {
	      options = options || { };
	      this.noise = options.noise || 0;
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          noise = this.noise, rand;
	
	      for (var i = 0, len = data.length; i < len; i += 4) {
	
	        rand = (0.5 - Math.random()) * noise;
	
	        data[i] += rand;
	        data[i + 1] += rand;
	        data[i + 2] += rand;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        noise: this.noise
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.Image.filters.Noise} Instance of fabric.Image.filters.Noise
	   */
	  fabric.Image.filters.Noise.fromObject = function(object) {
	    return new fabric.Image.filters.Noise(object);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Pixelate filter class
	   * @class fabric.Image.filters.Pixelate
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.Pixelate#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Pixelate({
	   *   blocksize: 8
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Pixelate = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Pixelate.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Pixelate',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.Pixelate.prototype
	     * @param {Object} [options] Options object
	     * @param {Number} [options.blocksize=4] Blocksize for pixelate
	     */
	    initialize: function(options) {
	      options = options || { };
	      this.blocksize = options.blocksize || 4;
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          iLen = imageData.height,
	          jLen = imageData.width,
	          index, i, j, r, g, b, a;
	
	      for (i = 0; i < iLen; i += this.blocksize) {
	        for (j = 0; j < jLen; j += this.blocksize) {
	
	          index = (i * 4) * jLen + (j * 4);
	
	          r = data[index];
	          g = data[index + 1];
	          b = data[index + 2];
	          a = data[index + 3];
	
	          /*
	           blocksize: 4
	
	           [1,x,x,x,1]
	           [x,x,x,x,1]
	           [x,x,x,x,1]
	           [x,x,x,x,1]
	           [1,1,1,1,1]
	           */
	
	          for (var _i = i, _ilen = i + this.blocksize; _i < _ilen; _i++) {
	            for (var _j = j, _jlen = j + this.blocksize; _j < _jlen; _j++) {
	              index = (_i * 4) * jLen + (_j * 4);
	              data[index] = r;
	              data[index + 1] = g;
	              data[index + 2] = b;
	              data[index + 3] = a;
	            }
	          }
	        }
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        blocksize: this.blocksize
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.Image.filters.Pixelate} Instance of fabric.Image.filters.Pixelate
	   */
	  fabric.Image.filters.Pixelate.fromObject = function(object) {
	    return new fabric.Image.filters.Pixelate(object);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Remove white filter class
	   * @class fabric.Image.filters.RemoveWhite
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.RemoveWhite#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.RemoveWhite({
	   *   threshold: 40,
	   *   distance: 140
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.RemoveWhite = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.RemoveWhite.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'RemoveWhite',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.RemoveWhite.prototype
	     * @param {Object} [options] Options object
	     * @param {Number} [options.threshold=30] Threshold value
	     * @param {Number} [options.distance=20] Distance value
	     */
	    initialize: function(options) {
	      options = options || { };
	      this.threshold = options.threshold || 30;
	      this.distance = options.distance || 20;
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          threshold = this.threshold,
	          distance = this.distance,
	          limit = 255 - threshold,
	          abs = Math.abs,
	          r, g, b;
	
	      for (var i = 0, len = data.length; i < len; i += 4) {
	        r = data[i];
	        g = data[i + 1];
	        b = data[i + 2];
	
	        if (r > limit &&
	            g > limit &&
	            b > limit &&
	            abs(r - g) < distance &&
	            abs(r - b) < distance &&
	            abs(g - b) < distance
	        ) {
	          data[i + 3] = 0;
	        }
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        threshold: this.threshold,
	        distance: this.distance
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.Image.filters.RemoveWhite} Instance of fabric.Image.filters.RemoveWhite
	   */
	  fabric.Image.filters.RemoveWhite.fromObject = function(object) {
	    return new fabric.Image.filters.RemoveWhite(object);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Sepia filter class
	   * @class fabric.Image.filters.Sepia
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Sepia();
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Sepia = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Sepia.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Sepia',
	
	    /**
	     * Applies filter to canvas element
	     * @memberOf fabric.Image.filters.Sepia.prototype
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          iLen = data.length, i, avg;
	
	      for (i = 0; i < iLen; i += 4) {
	        avg = 0.3  * data[i] + 0.59 * data[i + 1] + 0.11 * data[i + 2];
	        data[i] = avg + 100;
	        data[i + 1] = avg + 50;
	        data[i + 2] = avg + 255;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @return {fabric.Image.filters.Sepia} Instance of fabric.Image.filters.Sepia
	   */
	  fabric.Image.filters.Sepia.fromObject = function() {
	    return new fabric.Image.filters.Sepia();
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Sepia2 filter class
	   * @class fabric.Image.filters.Sepia2
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Sepia2();
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Sepia2 = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Sepia2.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Sepia2',
	
	    /**
	     * Applies filter to canvas element
	     * @memberOf fabric.Image.filters.Sepia.prototype
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          iLen = data.length, i, r, g, b;
	
	      for (i = 0; i < iLen; i += 4) {
	        r = data[i];
	        g = data[i + 1];
	        b = data[i + 2];
	
	        data[i] = (r * 0.393 + g * 0.769 + b * 0.189 ) / 1.351;
	        data[i + 1] = (r * 0.349 + g * 0.686 + b * 0.168 ) / 1.203;
	        data[i + 2] = (r * 0.272 + g * 0.534 + b * 0.131 ) / 2.140;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @return {fabric.Image.filters.Sepia2} Instance of fabric.Image.filters.Sepia2
	   */
	  fabric.Image.filters.Sepia2.fromObject = function() {
	    return new fabric.Image.filters.Sepia2();
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Tint filter class
	   * Adapted from <a href="https://github.com/mezzoblue/PaintbrushJS">https://github.com/mezzoblue/PaintbrushJS</a>
	   * @class fabric.Image.filters.Tint
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.Tint#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example <caption>Tint filter with hex color and opacity</caption>
	   * var filter = new fabric.Image.filters.Tint({
	   *   color: '#3513B0',
	   *   opacity: 0.5
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   * @example <caption>Tint filter with rgba color</caption>
	   * var filter = new fabric.Image.filters.Tint({
	   *   color: 'rgba(53, 21, 176, 0.5)'
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Tint = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Tint.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Tint',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.Tint.prototype
	     * @param {Object} [options] Options object
	     * @param {String} [options.color=#000000] Color to tint the image with
	     * @param {Number} [options.opacity] Opacity value that controls the tint effect's transparency (0..1)
	     */
	    initialize: function(options) {
	      options = options || { };
	
	      this.color = options.color || '#000000';
	      this.opacity = typeof options.opacity !== 'undefined'
	                      ? options.opacity
	                      : new fabric.Color(this.color).getAlpha();
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          iLen = data.length, i,
	          tintR, tintG, tintB,
	          r, g, b, alpha1,
	          source;
	
	      source = new fabric.Color(this.color).getSource();
	
	      tintR = source[0] * this.opacity;
	      tintG = source[1] * this.opacity;
	      tintB = source[2] * this.opacity;
	
	      alpha1 = 1 - this.opacity;
	
	      for (i = 0; i < iLen; i += 4) {
	        r = data[i];
	        g = data[i + 1];
	        b = data[i + 2];
	
	        // alpha compositing
	        data[i] = tintR + r * alpha1;
	        data[i + 1] = tintG + g * alpha1;
	        data[i + 2] = tintB + b * alpha1;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        color: this.color,
	        opacity: this.opacity
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.Image.filters.Tint} Instance of fabric.Image.filters.Tint
	   */
	  fabric.Image.filters.Tint.fromObject = function(object) {
	    return new fabric.Image.filters.Tint(object);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Multiply filter class
	   * Adapted from <a href="http://www.laurenscorijn.com/articles/colormath-basics">http://www.laurenscorijn.com/articles/colormath-basics</a>
	   * @class fabric.Image.filters.Multiply
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @example <caption>Multiply filter with hex color</caption>
	   * var filter = new fabric.Image.filters.Multiply({
	   *   color: '#F0F'
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   * @example <caption>Multiply filter with rgb color</caption>
	   * var filter = new fabric.Image.filters.Multiply({
	   *   color: 'rgb(53, 21, 176)'
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Multiply = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Multiply.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Multiply',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.Multiply.prototype
	     * @param {Object} [options] Options object
	     * @param {String} [options.color=#000000] Color to multiply the image pixels with
	     */
	    initialize: function(options) {
	      options = options || { };
	
	      this.color = options.color || '#000000';
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          iLen = data.length, i,
	          source;
	
	      source = new fabric.Color(this.color).getSource();
	
	      for (i = 0; i < iLen; i += 4) {
	        data[i] *= source[0] / 255;
	        data[i + 1] *= source[1] / 255;
	        data[i + 2] *= source[2] / 255;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        color: this.color
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.Image.filters.Multiply} Instance of fabric.Image.filters.Multiply
	   */
	  fabric.Image.filters.Multiply.fromObject = function(object) {
	    return new fabric.Image.filters.Multiply(object);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	  'use strict';
	
	  var fabric = global.fabric,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Color Blend filter class
	   * @class fabric.Image.filter.Blend
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @example
	   * var filter = new fabric.Image.filters.Blend({
	   *  color: '#000',
	   *  mode: 'multiply'
	   * });
	   *
	   * var filter = new fabric.Image.filters.Blend({
	   *  image: fabricImageObject,
	   *  mode: 'multiply',
	   *  alpha: 0.5
	   * });
	
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	
	  filters.Blend = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blend.prototype */ {
	    type: 'Blend',
	
	    initialize: function(options) {
	      options = options || {};
	      this.color = options.color || '#000';
	      this.image = options.image || false;
	      this.mode = options.mode || 'multiply';
	      this.alpha = options.alpha || 1;
	    },
	
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          tr, tg, tb,
	          r, g, b,
	          _r, _g, _b,
	          source,
	          isImage = false;
	
	      if (this.image) {
	        // Blend images
	        isImage = true;
	
	        var _el = fabric.util.createCanvasElement();
	        _el.width = this.image.width;
	        _el.height = this.image.height;
	
	        var tmpCanvas = new fabric.StaticCanvas(_el);
	        tmpCanvas.add(this.image);
	        var context2 =  tmpCanvas.getContext('2d');
	        source = context2.getImageData(0, 0, tmpCanvas.width, tmpCanvas.height).data;
	      }
	      else {
	        // Blend color
	        source = new fabric.Color(this.color).getSource();
	
	        tr = source[0] * this.alpha;
	        tg = source[1] * this.alpha;
	        tb = source[2] * this.alpha;
	      }
	
	      for (var i = 0, len = data.length; i < len; i += 4) {
	
	        r = data[i];
	        g = data[i + 1];
	        b = data[i + 2];
	
	        if (isImage) {
	          tr = source[i] * this.alpha;
	          tg = source[i + 1] * this.alpha;
	          tb = source[i + 2] * this.alpha;
	        }
	
	        switch (this.mode) {
	          case 'multiply':
	            data[i] = r * tr / 255;
	            data[i + 1] = g * tg / 255;
	            data[i + 2] = b * tb / 255;
	            break;
	          case 'screen':
	            data[i] = 1 - (1 - r) * (1 - tr);
	            data[i + 1] = 1 - (1 - g) * (1 - tg);
	            data[i + 2] = 1 - (1 - b) * (1 - tb);
	            break;
	          case 'add':
	            data[i] = Math.min(255, r + tr);
	            data[i + 1] = Math.min(255, g + tg);
	            data[i + 2] = Math.min(255, b + tb);
	            break;
	          case 'diff':
	          case 'difference':
	            data[i] = Math.abs(r - tr);
	            data[i + 1] = Math.abs(g - tg);
	            data[i + 2] = Math.abs(b - tb);
	            break;
	          case 'subtract':
	            _r = r - tr;
	            _g = g - tg;
	            _b = b - tb;
	
	            data[i] = (_r < 0) ? 0 : _r;
	            data[i + 1] = (_g < 0) ? 0 : _g;
	            data[i + 2] = (_b < 0) ? 0 : _b;
	            break;
	          case 'darken':
	            data[i] = Math.min(r, tr);
	            data[i + 1] = Math.min(g, tg);
	            data[i + 2] = Math.min(b, tb);
	            break;
	          case 'lighten':
	            data[i] = Math.max(r, tr);
	            data[i + 1] = Math.max(g, tg);
	            data[i + 2] = Math.max(b, tb);
	            break;
	        }
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return {
	        color: this.color,
	        image: this.image,
	        mode: this.mode,
	        alpha: this.alpha
	      };
	    }
	  });
	
	  fabric.Image.filters.Blend.fromObject = function(object) {
	    return new fabric.Image.filters.Blend(object);
	  };
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }), pow = Math.pow, floor = Math.floor,
	      sqrt = Math.sqrt, abs = Math.abs, max = Math.max, round = Math.round, sin = Math.sin,
	      ceil = Math.ceil,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Resize image filter class
	   * @class fabric.Image.filters.Resize
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Resize();
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Resize = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Resize.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Resize',
	
	    /**
	     * Resize type
	     * @param {String} resizeType
	     * @default
	     */
	    resizeType: 'hermite',
	
	    /**
	     * Scale factor for resizing, x axis
	     * @param {Number} scaleX
	     * @default
	     */
	    scaleX: 0,
	
	    /**
	     * Scale factor for resizing, y axis
	     * @param {Number} scaleY
	     * @default
	     */
	    scaleY: 0,
	
	    /**
	     * LanczosLobes parameter for lanczos filter
	     * @param {Number} lanczosLobes
	     * @default
	     */
	    lanczosLobes: 3,
	
	    /**
	     * Applies filter to canvas element
	     * @memberOf fabric.Image.filters.Resize.prototype
	     * @param {Object} canvasEl Canvas element to apply filter to
	     * @param {Number} scaleX
	     * @param {Number} scaleY
	     */
	    applyTo: function(canvasEl, scaleX, scaleY) {
	      if (scaleX === 1 && scaleY === 1) {
	        return;
	      }
	
	      this.rcpScaleX = 1 / scaleX;
	      this.rcpScaleY = 1 / scaleY;
	
	      var oW = canvasEl.width, oH = canvasEl.height,
	          dW = round(oW * scaleX), dH = round(oH * scaleY),
	          imageData;
	
	      if (this.resizeType === 'sliceHack') {
	        imageData = this.sliceByTwo(canvasEl, oW, oH, dW, dH);
	      }
	      if (this.resizeType === 'hermite') {
	        imageData = this.hermiteFastResize(canvasEl, oW, oH, dW, dH);
	      }
	      if (this.resizeType === 'bilinear') {
	        imageData = this.bilinearFiltering(canvasEl, oW, oH, dW, dH);
	      }
	      if (this.resizeType === 'lanczos') {
	        imageData = this.lanczosResize(canvasEl, oW, oH, dW, dH);
	      }
	      canvasEl.width = dW;
	      canvasEl.height = dH;
	      canvasEl.getContext('2d').putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Filter sliceByTwo
	     * @param {Object} canvasEl Canvas element to apply filter to
	     * @param {Number} oW Original Width
	     * @param {Number} oH Original Height
	     * @param {Number} dW Destination Width
	     * @param {Number} dH Destination Height
	     * @returns {ImageData}
	     */
	    sliceByTwo: function(canvasEl, oW, oH, dW, dH) {
	      var context = canvasEl.getContext('2d'), imageData,
	          multW = 0.5, multH = 0.5, signW = 1, signH = 1,
	          doneW = false, doneH = false, stepW = oW, stepH = oH,
	          tmpCanvas = fabric.util.createCanvasElement(),
	          tmpCtx = tmpCanvas.getContext('2d');
	      dW = floor(dW);
	      dH = floor(dH);
	      tmpCanvas.width = max(dW, oW);
	      tmpCanvas.height = max(dH, oH);
	
	      if (dW > oW) {
	        multW = 2;
	        signW = -1;
	      }
	      if (dH > oH) {
	        multH = 2;
	        signH = -1;
	      }
	      imageData = context.getImageData(0, 0, oW, oH);
	      canvasEl.width = max(dW, oW);
	      canvasEl.height = max(dH, oH);
	      context.putImageData(imageData, 0, 0);
	
	      while (!doneW || !doneH) {
	        oW = stepW;
	        oH = stepH;
	        if (dW * signW < floor(stepW * multW * signW)) {
	          stepW = floor(stepW * multW);
	        }
	        else {
	          stepW = dW;
	          doneW = true;
	        }
	        if (dH * signH < floor(stepH * multH * signH)) {
	          stepH = floor(stepH * multH);
	        }
	        else {
	          stepH = dH;
	          doneH = true;
	        }
	        imageData = context.getImageData(0, 0, oW, oH);
	        tmpCtx.putImageData(imageData, 0, 0);
	        context.clearRect(0, 0, stepW, stepH);
	        context.drawImage(tmpCanvas, 0, 0, oW, oH, 0, 0, stepW, stepH);
	      }
	      return context.getImageData(0, 0, dW, dH);
	    },
	
	    /**
	     * Filter lanczosResize
	     * @param {Object} canvasEl Canvas element to apply filter to
	     * @param {Number} oW Original Width
	     * @param {Number} oH Original Height
	     * @param {Number} dW Destination Width
	     * @param {Number} dH Destination Height
	     * @returns {ImageData}
	     */
	    lanczosResize: function(canvasEl, oW, oH, dW, dH) {
	
	      function lanczosCreate(lobes) {
	        return function(x) {
	          if (x > lobes) {
	            return 0;
	          }
	          x *= Math.PI;
	          if (abs(x) < 1e-16) {
	            return 1;
	          }
	          var xx = x / lobes;
	          return sin(x) * sin(xx) / x / xx;
	        };
	      }
	
	      function process(u) {
	        var v, i, weight, idx, a, red, green,
	            blue, alpha, fX, fY;
	        center.x = (u + 0.5) * ratioX;
	        icenter.x = floor(center.x);
	        for (v = 0; v < dH; v++) {
	          center.y = (v + 0.5) * ratioY;
	          icenter.y = floor(center.y);
	          a = 0; red = 0; green = 0; blue = 0; alpha = 0;
	          for (i = icenter.x - range2X; i <= icenter.x + range2X; i++) {
	            if (i < 0 || i >= oW) {
	              continue;
	            }
	            fX = floor(1000 * abs(i - center.x));
	            if (!cacheLanc[fX]) {
	              cacheLanc[fX] = { };
	            }
	            for (var j = icenter.y - range2Y; j <= icenter.y + range2Y; j++) {
	              if (j < 0 || j >= oH) {
	                continue;
	              }
	              fY = floor(1000 * abs(j - center.y));
	              if (!cacheLanc[fX][fY]) {
	                cacheLanc[fX][fY] = lanczos(sqrt(pow(fX * rcpRatioX, 2) + pow(fY * rcpRatioY, 2)) / 1000);
	              }
	              weight = cacheLanc[fX][fY];
	              if (weight > 0) {
	                idx = (j * oW + i) * 4;
	                a += weight;
	                red += weight * srcData[idx];
	                green += weight * srcData[idx + 1];
	                blue += weight * srcData[idx + 2];
	                alpha += weight * srcData[idx + 3];
	              }
	            }
	          }
	          idx = (v * dW + u) * 4;
	          destData[idx] = red / a;
	          destData[idx + 1] = green / a;
	          destData[idx + 2] = blue / a;
	          destData[idx + 3] = alpha / a;
	        }
	
	        if (++u < dW) {
	          return process(u);
	        }
	        else {
	          return destImg;
	        }
	      }
	
	      var context = canvasEl.getContext('2d'),
	          srcImg = context.getImageData(0, 0, oW, oH),
	          destImg = context.getImageData(0, 0, dW, dH),
	          srcData = srcImg.data, destData = destImg.data,
	          lanczos = lanczosCreate(this.lanczosLobes),
	          ratioX = this.rcpScaleX, ratioY = this.rcpScaleY,
	          rcpRatioX = 2 / this.rcpScaleX, rcpRatioY = 2 / this.rcpScaleY,
	          range2X = ceil(ratioX * this.lanczosLobes / 2),
	          range2Y = ceil(ratioY * this.lanczosLobes / 2),
	          cacheLanc = { }, center = { }, icenter = { };
	
	      return process(0);
	    },
	
	    /**
	     * bilinearFiltering
	     * @param {Object} canvasEl Canvas element to apply filter to
	     * @param {Number} oW Original Width
	     * @param {Number} oH Original Height
	     * @param {Number} dW Destination Width
	     * @param {Number} dH Destination Height
	     * @returns {ImageData}
	     */
	    bilinearFiltering: function(canvasEl, oW, oH, dW, dH) {
	      var a, b, c, d, x, y, i, j, xDiff, yDiff, chnl,
	          color, offset = 0, origPix, ratioX = this.rcpScaleX,
	          ratioY = this.rcpScaleY, context = canvasEl.getContext('2d'),
	          w4 = 4 * (oW - 1), img = context.getImageData(0, 0, oW, oH),
	          pixels = img.data, destImage = context.getImageData(0, 0, dW, dH),
	          destPixels = destImage.data;
	      for (i = 0; i < dH; i++) {
	        for (j = 0; j < dW; j++) {
	          x = floor(ratioX * j);
	          y = floor(ratioY * i);
	          xDiff = ratioX * j - x;
	          yDiff = ratioY * i - y;
	          origPix = 4 * (y * oW + x);
	
	          for (chnl = 0; chnl < 4; chnl++) {
	            a = pixels[origPix + chnl];
	            b = pixels[origPix + 4 + chnl];
	            c = pixels[origPix + w4 + chnl];
	            d = pixels[origPix + w4 + 4 + chnl];
	            color = a * (1 - xDiff) * (1 - yDiff) + b * xDiff * (1 - yDiff) +
	                    c * yDiff * (1 - xDiff) + d * xDiff * yDiff;
	            destPixels[offset++] = color;
	          }
	        }
	      }
	      return destImage;
	    },
	
	    /**
	     * hermiteFastResize
	     * @param {Object} canvasEl Canvas element to apply filter to
	     * @param {Number} oW Original Width
	     * @param {Number} oH Original Height
	     * @param {Number} dW Destination Width
	     * @param {Number} dH Destination Height
	     * @returns {ImageData}
	     */
	    hermiteFastResize: function(canvasEl, oW, oH, dW, dH) {
	      var ratioW = this.rcpScaleX, ratioH = this.rcpScaleY,
	          ratioWHalf = ceil(ratioW / 2),
	          ratioHHalf = ceil(ratioH / 2),
	          context = canvasEl.getContext('2d'),
	          img = context.getImageData(0, 0, oW, oH), data = img.data,
	          img2 = context.getImageData(0, 0, dW, dH), data2 = img2.data;
	      for (var j = 0; j < dH; j++) {
	        for (var i = 0; i < dW; i++) {
	          var x2 = (i + j * dW) * 4, weight = 0, weights = 0, weightsAlpha = 0,
	              gxR = 0, gxG = 0, gxB = 0, gxA = 0, centerY = (j + 0.5) * ratioH;
	          for (var yy = floor(j * ratioH); yy < (j + 1) * ratioH; yy++) {
	            var dy = abs(centerY - (yy + 0.5)) / ratioHHalf,
	                centerX = (i + 0.5) * ratioW, w0 = dy * dy;
	            for (var xx = floor(i * ratioW); xx < (i + 1) * ratioW; xx++) {
	              var dx = abs(centerX - (xx + 0.5)) / ratioWHalf,
	                  w = sqrt(w0 + dx * dx);
	              /* eslint-disable max-depth */
	              if (w > 1 && w < -1) {
	                continue;
	              }
	              //hermite filter
	              weight = 2 * w * w * w - 3 * w * w + 1;
	              if (weight > 0) {
	                dx = 4 * (xx + yy * oW);
	                //alpha
	                gxA += weight * data[dx + 3];
	                weightsAlpha += weight;
	                //colors
	                if (data[dx + 3] < 255) {
	                  weight = weight * data[dx + 3] / 250;
	                }
	                gxR += weight * data[dx];
	                gxG += weight * data[dx + 1];
	                gxB += weight * data[dx + 2];
	                weights += weight;
	              }
	              /* eslint-enable max-depth */
	            }
	          }
	          data2[x2] = gxR / weights;
	          data2[x2 + 1] = gxG / weights;
	          data2[x2 + 2] = gxB / weights;
	          data2[x2 + 3] = gxA / weightsAlpha;
	        }
	      }
	      return img2;
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return {
	        type: this.type,
	        scaleX: this.scaleX,
	        scaleY: this.scaleY,
	        resizeType: this.resizeType,
	        lanczosLobes: this.lanczosLobes
	      };
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @return {fabric.Image.filters.Resize} Instance of fabric.Image.filters.Resize
	   */
	  fabric.Image.filters.Resize.fromObject = function(object) {
	    return new fabric.Image.filters.Resize(object);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Color Matrix filter class
	   * @class fabric.Image.filters.ColorMatrix
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.ColorMatrix#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @see {@Link http://www.webwasp.co.uk/tutorials/219/Color_Matrix_Filter.php}
	   * @see {@Link http://phoboslab.org/log/2013/11/fast-image-filters-with-webgl}
	   * @example <caption>Kodachrome filter</caption>
	   * var filter = new fabric.Image.filters.ColorMatrix({
	   *  matrix: [
	       1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,
	       -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,
	       -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,
	       0, 0, 0, 1, 0
	      ]
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.ColorMatrix = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.ColorMatrix.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'ColorMatrix',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.ColorMatrix.prototype
	     * @param {Object} [options] Options object
	     * @param {Array} [options.matrix] Color Matrix to modify the image data with
	     */
	    initialize: function( options ) {
	      options || ( options = {} );
	      this.matrix = options.matrix || [
	        1, 0, 0, 0, 0,
	        0, 1, 0, 0, 0,
	        0, 0, 1, 0, 0,
	        0, 0, 0, 1, 0
	      ];
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function( canvasEl ) {
	      var context = canvasEl.getContext( '2d' ),
	          imageData = context.getImageData( 0, 0, canvasEl.width, canvasEl.height ),
	          data = imageData.data,
	          iLen = data.length,
	          i,
	          r,
	          g,
	          b,
	          a,
	          m = this.matrix;
	
	      for ( i = 0; i < iLen; i += 4 ) {
	        r = data[ i ];
	        g = data[ i + 1 ];
	        b = data[ i + 2 ];
	        a = data[ i + 3 ];
	
	        data[ i ] = r * m[ 0 ] + g * m[ 1 ] + b * m[ 2 ] + a * m[ 3 ] + m[ 4 ];
	        data[ i + 1 ] = r * m[ 5 ] + g * m[ 6 ] + b * m[ 7 ] + a * m[ 8 ] + m[ 9 ];
	        data[ i + 2 ] = r * m[ 10 ] + g * m[ 11 ] + b * m[ 12 ] + a * m[ 13 ] + m[ 14 ];
	        data[ i + 3 ] = r * m[ 15 ] + g * m[ 16 ] + b * m[ 17 ] + a * m[ 18 ] + m[ 19 ];
	      }
	
	      context.putImageData( imageData, 0, 0 );
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        type: this.type,
	        matrix: this.matrix
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.Image.filters.ColorMatrix} Instance of fabric.Image.filters.ColorMatrix
	   */
	  fabric.Image.filters.ColorMatrix.fromObject = function( object ) {
	    return new fabric.Image.filters.ColorMatrix( object );
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Contrast filter class
	   * @class fabric.Image.filters.Contrast
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.Contrast#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Contrast({
	   *   contrast: 40
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Contrast = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Contrast.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Contrast',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.Contrast.prototype
	     * @param {Object} [options] Options object
	     * @param {Number} [options.contrast=0] Value to contrast the image up (-255...255)
	     */
	    initialize: function(options) {
	      options = options || { };
	      this.contrast = options.contrast || 0;
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          contrastF = 259 * (this.contrast + 255) / (255 * (259 - this.contrast));
	
	      for (var i = 0, len = data.length; i < len; i += 4) {
	        data[i] = contrastF * (data[i] - 128) + 128;
	        data[i + 1] = contrastF * (data[i + 1] - 128) + 128;
	        data[i + 2] = contrastF * (data[i + 2] - 128) + 128;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        contrast: this.contrast
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.Image.filters.Contrast} Instance of fabric.Image.filters.Contrast
	   */
	  fabric.Image.filters.Contrast.fromObject = function(object) {
	    return new fabric.Image.filters.Contrast(object);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Saturate filter class
	   * @class fabric.Image.filters.Saturate
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.Saturate#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Saturate({
	   *   saturate: 100
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Saturate = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Saturate.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Saturate',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.Saturate.prototype
	     * @param {Object} [options] Options object
	     * @param {Number} [options.contrast=0] Value to saturate the image (-255...255)
	     */
	    initialize: function(options) {
	      options = options || { };
	      this.saturate = options.saturate || 0;
	      this.loadProgram();
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          max, adjust = -this.saturate * 0.01;
	
	      for (var i = 0, len = data.length; i < len; i += 4) {
	        max = Math.max(data[i], data[i + 1], data[i + 2]);
	        data[i] += max !== data[i] ? (max - data[i]) * adjust : 0;
	        data[i + 1] += max !== data[i + 1] ? (max - data[i + 1]) * adjust : 0;
	        data[i + 2] += max !== data[i + 2] ? (max - data[i + 2]) * adjust : 0;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        saturate: this.saturate
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.Image.filters.Saturate} Instance of fabric.Image.filters.Saturate
	   */
	  fabric.Image.filters.Saturate.fromObject = function(object) {
	    return new fabric.Image.filters.Saturate(object);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      clone = fabric.util.object.clone,
	      toFixed = fabric.util.toFixed,
	      NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
	      MIN_TEXT_WIDTH = 2;
	
	  if (fabric.Text) {
	    fabric.warn('fabric.Text is already defined');
	    return;
	  }
	
	  var stateProperties = fabric.Object.prototype.stateProperties.concat();
	  stateProperties.push(
	    'fontFamily',
	    'fontWeight',
	    'fontSize',
	    'text',
	    'textDecoration',
	    'textAlign',
	    'fontStyle',
	    'lineHeight',
	    'textBackgroundColor'
	  );
	
	  /**
	   * Text class
	   * @class fabric.Text
	   * @extends fabric.Object
	   * @return {fabric.Text} thisArg
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#text}
	   * @see {@link fabric.Text#initialize} for constructor definition
	   */
	  fabric.Text = fabric.util.createClass(fabric.Object, /** @lends fabric.Text.prototype */ {
	
	    /**
	     * Properties which when set cause object to change dimensions
	     * @type Object
	     * @private
	     */
	    _dimensionAffectingProps: {
	      fontSize: true,
	      fontWeight: true,
	      fontFamily: true,
	      fontStyle: true,
	      lineHeight: true,
	      text: true,
	      charSpacing: true,
	      textAlign: true,
	      strokeWidth: false,
	    },
	
	    /**
	     * @private
	     */
	    _reNewline: /\r?\n/,
	
	    /**
	     * Use this regular expression to filter for whitespace that is not a new line.
	     * Mostly used when text is 'justify' aligned.
	     * @private
	     */
	    _reSpacesAndTabs: /[ \t\r]+/g,
	
	    /**
	     * Retrieves object's fontSize
	     * @method getFontSize
	     * @memberOf fabric.Text.prototype
	     * @return {String} Font size (in pixels)
	     */
	
	    /**
	     * Sets object's fontSize
	     * Does not update the object .width and .height,
	     * call ._initDimensions() to update the values.
	     * @method setFontSize
	     * @memberOf fabric.Text.prototype
	     * @param {Number} fontSize Font size (in pixels)
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's fontWeight
	     * @method getFontWeight
	     * @memberOf fabric.Text.prototype
	     * @return {(String|Number)} Font weight
	     */
	
	    /**
	     * Sets object's fontWeight
	     * Does not update the object .width and .height,
	     * call ._initDimensions() to update the values.
	     * @method setFontWeight
	     * @memberOf fabric.Text.prototype
	     * @param {(Number|String)} fontWeight Font weight
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's fontFamily
	     * @method getFontFamily
	     * @memberOf fabric.Text.prototype
	     * @return {String} Font family
	     */
	
	    /**
	     * Sets object's fontFamily
	     * Does not update the object .width and .height,
	     * call ._initDimensions() to update the values.
	     * @method setFontFamily
	     * @memberOf fabric.Text.prototype
	     * @param {String} fontFamily Font family
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's text
	     * @method getText
	     * @memberOf fabric.Text.prototype
	     * @return {String} text
	     */
	
	    /**
	     * Sets object's text
	     * Does not update the object .width and .height,
	     * call ._initDimensions() to update the values.
	     * @method setText
	     * @memberOf fabric.Text.prototype
	     * @param {String} text Text
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's textDecoration
	     * @method getTextDecoration
	     * @memberOf fabric.Text.prototype
	     * @return {String} Text decoration
	     */
	
	    /**
	     * Sets object's textDecoration
	     * @method setTextDecoration
	     * @memberOf fabric.Text.prototype
	     * @param {String} textDecoration Text decoration
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's fontStyle
	     * @method getFontStyle
	     * @memberOf fabric.Text.prototype
	     * @return {String} Font style
	     */
	
	    /**
	     * Sets object's fontStyle
	     * Does not update the object .width and .height,
	     * call ._initDimensions() to update the values.
	     * @method setFontStyle
	     * @memberOf fabric.Text.prototype
	     * @param {String} fontStyle Font style
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's lineHeight
	     * @method getLineHeight
	     * @memberOf fabric.Text.prototype
	     * @return {Number} Line height
	     */
	
	    /**
	     * Sets object's lineHeight
	     * @method setLineHeight
	     * @memberOf fabric.Text.prototype
	     * @param {Number} lineHeight Line height
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's textAlign
	     * @method getTextAlign
	     * @memberOf fabric.Text.prototype
	     * @return {String} Text alignment
	     */
	
	    /**
	     * Sets object's textAlign
	     * @method setTextAlign
	     * @memberOf fabric.Text.prototype
	     * @param {String} textAlign Text alignment
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's textBackgroundColor
	     * @method getTextBackgroundColor
	     * @memberOf fabric.Text.prototype
	     * @return {String} Text background color
	     */
	
	    /**
	     * Sets object's textBackgroundColor
	     * @method setTextBackgroundColor
	     * @memberOf fabric.Text.prototype
	     * @param {String} textBackgroundColor Text background color
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type:                 'text',
	
	    /**
	     * Font size (in pixels)
	     * @type Number
	     * @default
	     */
	    fontSize:             40,
	
	    /**
	     * Font weight (e.g. bold, normal, 400, 600, 800)
	     * @type {(Number|String)}
	     * @default
	     */
	    fontWeight:           'normal',
	
	    /**
	     * Font family
	     * @type String
	     * @default
	     */
	    fontFamily:           'Times New Roman',
	
	    /**
	     * Text decoration Possible values: "", "underline", "overline" or "line-through".
	     * @type String
	     * @default
	     */
	    textDecoration:       '',
	
	    /**
	     * Text alignment. Possible values: "left", "center", "right" or "justify".
	     * @type String
	     * @default
	     */
	    textAlign:            'left',
	
	    /**
	     * Font style . Possible values: "", "normal", "italic" or "oblique".
	     * @type String
	     * @default
	     */
	    fontStyle:            '',
	
	    /**
	     * Line height
	     * @type Number
	     * @default
	     */
	    lineHeight:           1.16,
	
	    /**
	     * Background color of text lines
	     * @type String
	     * @default
	     */
	    textBackgroundColor:  '',
	
	    /**
	     * List of properties to consider when checking if
	     * state of an object is changed ({@link fabric.Object#hasStateChanged})
	     * as well as for history (undo/redo) purposes
	     * @type Array
	     */
	    stateProperties:      stateProperties,
	
	    /**
	     * When defined, an object is rendered via stroke and this property specifies its color.
	     * <b>Backwards incompatibility note:</b> This property was named "strokeStyle" until v1.1.6
	     * @type String
	     * @default
	     */
	    stroke:               null,
	
	    /**
	     * Shadow object representing shadow of this shape.
	     * <b>Backwards incompatibility note:</b> This property was named "textShadow" (String) until v1.2.11
	     * @type fabric.Shadow
	     * @default
	     */
	    shadow:               null,
	
	    /**
	     * @private
	     */
	    _fontSizeFraction: 0.25,
	
	    /**
	     * Text Line proportion to font Size (in pixels)
	     * @type Number
	     * @default
	     */
	    _fontSizeMult:             1.13,
	
	    /**
	     * additional space between characters
	     * expressed in thousands of em unit
	     * @type Number
	     * @default
	     */
	    charSpacing:             0,
	
	    /**
	     * Constructor
	     * @param {String} text Text string
	     * @param {Object} [options] Options object
	     * @return {fabric.Text} thisArg
	     */
	    initialize: function(text, options) {
	      options = options || { };
	      this.text = text;
	      this.__skipDimension = true;
	      this.setOptions(options);
	      this.__skipDimension = false;
	      this._initDimensions();
	    },
	
	    /**
	     * Initialize text dimensions. Render all text on given context
	     * or on a offscreen canvas to get the text width with measureText.
	     * Updates this.width and this.height with the proper values.
	     * Does not return dimensions.
	     * @param {CanvasRenderingContext2D} [ctx] Context to render on
	     * @private
	     */
	    _initDimensions: function(ctx) {
	      if (this.__skipDimension) {
	        return;
	      }
	      if (!ctx) {
	        ctx = fabric.util.createCanvasElement().getContext('2d');
	        this._setTextStyles(ctx);
	      }
	      this._textLines = this._splitTextIntoLines();
	      this._clearCache();
	      this.width = this._getTextWidth(ctx) || this.cursorWidth || MIN_TEXT_WIDTH;
	      this.height = this._getTextHeight(ctx);
	    },
	
	    /**
	     * Returns string representation of an instance
	     * @return {String} String representation of text object
	     */
	    toString: function() {
	      return '#<fabric.Text (' + this.complexity() +
	        '): { "text": "' + this.text + '", "fontFamily": "' + this.fontFamily + '" }>';
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _render: function(ctx) {
	      this.clipTo && fabric.util.clipContext(this, ctx);
	      this._setOpacity(ctx);
	      this._setShadow(ctx);
	      this._setupCompositeOperation(ctx);
	      this._renderTextBackground(ctx);
	      this._setStrokeStyles(ctx);
	      this._setFillStyles(ctx);
	      this._renderText(ctx);
	      this._renderTextDecoration(ctx);
	      this.clipTo && ctx.restore();
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderText: function(ctx) {
	      this._renderTextFill(ctx);
	      this._renderTextStroke(ctx);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _setTextStyles: function(ctx) {
	      ctx.textBaseline = 'alphabetic';
	      ctx.font = this._getFontDeclaration();
	    },
	
	    /**
	     * @private
	     * @return {Number} Height of fabric.Text object
	     */
	    _getTextHeight: function() {
	      return this._getHeightOfSingleLine() + (this._textLines.length - 1) * this._getHeightOfLine();
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @return {Number} Maximum width of fabric.Text object
	     */
	    _getTextWidth: function(ctx) {
	      var maxWidth = this._getLineWidth(ctx, 0);
	
	      for (var i = 1, len = this._textLines.length; i < len; i++) {
	        var currentLineWidth = this._getLineWidth(ctx, i);
	        if (currentLineWidth > maxWidth) {
	          maxWidth = currentLineWidth;
	        }
	      }
	      return maxWidth;
	    },
	
	    /*
	     * Calculate object dimensions from its properties
	     * @override
	     * @private
	     */
	    _getNonTransformedDimensions: function() {
	      return { x: this.width, y: this.height };
	    },
	
	    /**
	     * @private
	     * @param {String} method Method name ("fillText" or "strokeText")
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {String} chars Chars to render
	     * @param {Number} left Left position of text
	     * @param {Number} top Top position of text
	     */
	    _renderChars: function(method, ctx, chars, left, top) {
	      // remove Text word from method var
	      var shortM = method.slice(0, -4), char, width;
	      if (this[shortM].toLive) {
	        var offsetX = -this.width / 2 + this[shortM].offsetX || 0,
	            offsetY = -this.height / 2 + this[shortM].offsetY || 0;
	        ctx.save();
	        ctx.translate(offsetX, offsetY);
	        left -= offsetX;
	        top -= offsetY;
	      }
	      if (this.charSpacing !== 0) {
	        var additionalSpace = this._getWidthOfCharSpacing();
	        chars = chars.split('');
	        for (var i = 0, len = chars.length; i < len; i++) {
	          char = chars[i];
	          width = ctx.measureText(char).width + additionalSpace;
	          ctx[method](char, left, top);
	          left += width > 0 ? width : 0;
	        }
	      }
	      else {
	        ctx[method](chars, left, top);
	      }
	      this[shortM].toLive && ctx.restore();
	    },
	
	    /**
	     * @private
	     * @param {String} method Method name ("fillText" or "strokeText")
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {String} line Text to render
	     * @param {Number} left Left position of text
	     * @param {Number} top Top position of text
	     * @param {Number} lineIndex Index of a line in a text
	     */
	    _renderTextLine: function(method, ctx, line, left, top, lineIndex) {
	      // lift the line by quarter of fontSize
	      top -= this.fontSize * this._fontSizeFraction;
	
	      // short-circuit
	      var lineWidth = this._getLineWidth(ctx, lineIndex);
	      if (this.textAlign !== 'justify' || this.width < lineWidth) {
	        this._renderChars(method, ctx, line, left, top, lineIndex);
	        return;
	      }
	
	      // stretch the line
	      var words = line.split(/\s+/),
	          charOffset = 0,
	          wordsWidth = this._getWidthOfWords(ctx, words.join(''), lineIndex, 0),
	          widthDiff = this.width - wordsWidth,
	          numSpaces = words.length - 1,
	          spaceWidth = numSpaces > 0 ? widthDiff / numSpaces : 0,
	          leftOffset = 0, word;
	
	      for (var i = 0, len = words.length; i < len; i++) {
	        while (line[charOffset] === ' ' && charOffset < line.length) {
	          charOffset++;
	        }
	        word = words[i];
	        this._renderChars(method, ctx, word, left + leftOffset, top, lineIndex, charOffset);
	        leftOffset += this._getWidthOfWords(ctx, word, lineIndex, charOffset) + spaceWidth;
	        charOffset += word.length;
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {String} word
	     */
	    _getWidthOfWords: function (ctx, word) {
	      var width = ctx.measureText(word).width, charCount, additionalSpace;
	      if (this.charSpacing !== 0) {
	        charCount = word.split('').length;
	        additionalSpace = charCount * this._getWidthOfCharSpacing();
	        width += additionalSpace;
	      }
	      return width > 0 ? width : 0;
	    },
	
	    /**
	     * @private
	     * @return {Number} Left offset
	     */
	    _getLeftOffset: function() {
	      return -this.width / 2;
	    },
	
	    /**
	     * @private
	     * @return {Number} Top offset
	     */
	    _getTopOffset: function() {
	      return -this.height / 2;
	    },
	
	    /**
	     * Returns true because text has no style
	     */
	    isEmptyStyles: function() {
	      return true;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {String} method Method name ("fillText" or "strokeText")
	     */
	    _renderTextCommon: function(ctx, method) {
	
	      var lineHeights = 0, left = this._getLeftOffset(), top = this._getTopOffset();
	
	      for (var i = 0, len = this._textLines.length; i < len; i++) {
	        var heightOfLine = this._getHeightOfLine(ctx, i),
	            maxHeight = heightOfLine / this.lineHeight,
	            lineWidth = this._getLineWidth(ctx, i),
	            leftOffset = this._getLineLeftOffset(lineWidth);
	        this._renderTextLine(
	          method,
	          ctx,
	          this._textLines[i],
	          left + leftOffset,
	          top + lineHeights + maxHeight,
	          i
	        );
	        lineHeights += heightOfLine;
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderTextFill: function(ctx) {
	      if (!this.fill && this.isEmptyStyles()) {
	        return;
	      }
	
	      this._renderTextCommon(ctx, 'fillText');
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderTextStroke: function(ctx) {
	      if ((!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles()) {
	        return;
	      }
	
	      if (this.shadow && !this.shadow.affectStroke) {
	        this._removeShadow(ctx);
	      }
	
	      ctx.save();
	      this._setLineDash(ctx, this.strokedashArray);
	      ctx.beginPath();
	      this._renderTextCommon(ctx, 'strokeText');
	      ctx.closePath();
	      ctx.restore();
	    },
	
	    /**
	     * @private
	     * @return {Number} height of line
	     */
	    _getHeightOfLine: function() {
	      return this._getHeightOfSingleLine() * this.lineHeight;
	    },
	
	    /**
	     * @private
	     * @return {Number} height of line without lineHeight
	     */
	    _getHeightOfSingleLine: function() {
	      return this.fontSize * this._fontSizeMult;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderTextBackground: function(ctx) {
	      this._renderBackground(ctx);
	      this._renderTextLinesBackground(ctx);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderTextLinesBackground: function(ctx) {
	      if (!this.textBackgroundColor) {
	        return;
	      }
	      var lineTopOffset = 0, heightOfLine,
	          lineWidth, lineLeftOffset;
	
	      ctx.fillStyle = this.textBackgroundColor;
	      for (var i = 0, len = this._textLines.length; i < len; i++) {
	        heightOfLine = this._getHeightOfLine(ctx, i);
	        lineWidth = this._getLineWidth(ctx, i);
	        if (lineWidth > 0) {
	          lineLeftOffset = this._getLineLeftOffset(lineWidth);
	          ctx.fillRect(
	            this._getLeftOffset() + lineLeftOffset,
	            this._getTopOffset() + lineTopOffset,
	            lineWidth,
	            heightOfLine / this.lineHeight
	          );
	        }
	        lineTopOffset += heightOfLine;
	      }
	      // if there is text background color no
	      // other shadows should be casted
	      this._removeShadow(ctx);
	    },
	
	    /**
	     * @private
	     * @param {Number} lineWidth Width of text line
	     * @return {Number} Line left offset
	     */
	    _getLineLeftOffset: function(lineWidth) {
	      if (this.textAlign === 'center') {
	        return (this.width - lineWidth) / 2;
	      }
	      if (this.textAlign === 'right') {
	        return this.width - lineWidth;
	      }
	      return 0;
	    },
	
	    /**
	     * @private
	     */
	    _clearCache: function() {
	      this.__lineWidths = [];
	      this.__lineHeights = [];
	    },
	
	    /**
	     * @private
	     */
	    _shouldClearCache: function() {
	      var shouldClear = false;
	      if (this._forceClearCache) {
	        this._forceClearCache = false;
	        return true;
	      }
	      for (var prop in this._dimensionAffectingProps) {
	        if (this['__' + prop] !== this[prop]) {
	          this['__' + prop] = this[prop];
	          shouldClear = true;
	        }
	      }
	      return shouldClear;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Number} lineIndex line number
	     * @return {Number} Line width
	     */
	    _getLineWidth: function(ctx, lineIndex) {
	      if (this.__lineWidths[lineIndex]) {
	        return this.__lineWidths[lineIndex] === -1 ? this.width : this.__lineWidths[lineIndex];
	      }
	
	      var width, wordCount, line = this._textLines[lineIndex];
	
	      if (line === '') {
	        width = 0;
	      }
	      else {
	        width = this._measureLine(ctx, lineIndex);
	      }
	      this.__lineWidths[lineIndex] = width;
	
	      if (width && this.textAlign === 'justify') {
	        wordCount = line.split(/\s+/);
	        if (wordCount.length > 1) {
	          this.__lineWidths[lineIndex] = -1;
	        }
	      }
	      return width;
	    },
	
	    _getWidthOfCharSpacing: function() {
	      if (this.charSpacing !== 0) {
	        return this.fontSize * this.charSpacing / 1000;
	      }
	      return 0;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Number} lineIndex line number
	     * @return {Number} Line width
	     */
	    _measureLine: function(ctx, lineIndex) {
	      var line = this._textLines[lineIndex],
	          width = ctx.measureText(line).width,
	          additionalSpace = 0, charCount, finalWidth;
	      if (this.charSpacing !== 0) {
	        charCount = line.split('').length;
	        additionalSpace = (charCount - 1) * this._getWidthOfCharSpacing();
	      }
	      finalWidth = width + additionalSpace;
	      return finalWidth > 0 ? finalWidth : 0;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderTextDecoration: function(ctx) {
	      if (!this.textDecoration) {
	        return;
	      }
	      var halfOfVerticalBox = this.height / 2,
	          _this = this, offsets = [];
	
	      /** @ignore */
	      function renderLinesAtOffset(offsets) {
	        var i, lineHeight = 0, len, j, oLen, lineWidth,
	            lineLeftOffset, heightOfLine;
	
	        for (i = 0, len = _this._textLines.length; i < len; i++) {
	
	          lineWidth = _this._getLineWidth(ctx, i);
	          lineLeftOffset = _this._getLineLeftOffset(lineWidth);
	          heightOfLine = _this._getHeightOfLine(ctx, i);
	
	          for (j = 0, oLen = offsets.length; j < oLen; j++) {
	            ctx.fillRect(
	              _this._getLeftOffset() + lineLeftOffset,
	              lineHeight + (_this._fontSizeMult - 1 + offsets[j] ) * _this.fontSize - halfOfVerticalBox,
	              lineWidth,
	              _this.fontSize / 15);
	          }
	          lineHeight += heightOfLine;
	        }
	      }
	
	      if (this.textDecoration.indexOf('underline') > -1) {
	        offsets.push(0.85); // 1 - 3/16
	      }
	      if (this.textDecoration.indexOf('line-through') > -1) {
	        offsets.push(0.43);
	      }
	      if (this.textDecoration.indexOf('overline') > -1) {
	        offsets.push(-0.12);
	      }
	      if (offsets.length > 0) {
	        renderLinesAtOffset(offsets);
	      }
	    },
	
	    /**
	     * return font declaration string for canvas context
	     * @returns {String} font declaration formatted for canvas context.
	     */
	    _getFontDeclaration: function() {
	      return [
	        // node-canvas needs "weight style", while browsers need "style weight"
	        (fabric.isLikelyNode ? this.fontWeight : this.fontStyle),
	        (fabric.isLikelyNode ? this.fontStyle : this.fontWeight),
	        this.fontSize + 'px',
	        (fabric.isLikelyNode ? ('"' + this.fontFamily + '"') : this.fontFamily)
	      ].join(' ');
	    },
	
	    /**
	     * Renders text instance on a specified context
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} noTransform
	     */
	    render: function(ctx, noTransform) {
	      // do not render if object is not visible
	      if (!this.visible) {
	        return;
	      }
	
	      ctx.save();
	      this._setTextStyles(ctx);
	
	      if (this._shouldClearCache()) {
	        this._initDimensions(ctx);
	      }
	      this.drawSelectionBackground(ctx);
	      if (!noTransform) {
	        this.transform(ctx);
	      }
	      if (this.transformMatrix) {
	        ctx.transform.apply(ctx, this.transformMatrix);
	      }
	      if (this.group && this.group.type === 'path-group') {
	        ctx.translate(this.left, this.top);
	      }
	      this._render(ctx);
	      ctx.restore();
	    },
	
	    /**
	     * Returns the text as an array of lines.
	     * @returns {Array} Lines in the text
	     */
	    _splitTextIntoLines: function() {
	      return this.text.split(this._reNewline);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      var object = extend(this.callSuper('toObject', propertiesToInclude), {
	        text:                 this.text,
	        fontSize:             this.fontSize,
	        fontWeight:           this.fontWeight,
	        fontFamily:           this.fontFamily,
	        fontStyle:            this.fontStyle,
	        lineHeight:           this.lineHeight,
	        textDecoration:       this.textDecoration,
	        textAlign:            this.textAlign,
	        textBackgroundColor:  this.textBackgroundColor,
	        charSpacing:          this.charSpacing
	      });
	      if (!this.includeDefaultValues) {
	        this._removeDefaultValues(object);
	      }
	      return object;
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns SVG representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      if (!this.ctx) {
	        this.ctx = fabric.util.createCanvasElement().getContext('2d');
	      }
	      var markup = this._createBaseSVGMarkup(),
	          offsets = this._getSVGLeftTopOffsets(this.ctx),
	          textAndBg = this._getSVGTextAndBg(offsets.textTop, offsets.textLeft);
	      this._wrapSVGTextAndBg(markup, textAndBg);
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	
	    /**
	     * @private
	     */
	    _getSVGLeftTopOffsets: function(ctx) {
	      var lineTop = this._getHeightOfLine(ctx, 0),
	          textLeft = -this.width / 2,
	          textTop = 0;
	
	      return {
	        textLeft: textLeft + (this.group && this.group.type === 'path-group' ? this.left : 0),
	        textTop: textTop + (this.group && this.group.type === 'path-group' ? -this.top : 0),
	        lineTop: lineTop
	      };
	    },
	
	    /**
	     * @private
	     */
	    _wrapSVGTextAndBg: function(markup, textAndBg) {
	      var noShadow = true, filter = this.getSvgFilter(),
	          style = filter === '' ? '' : ' style="' + filter + '"';
	
	      markup.push(
	        '\t<g ', this.getSvgId(), 'transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '"',
	          style, '>\n',
	          textAndBg.textBgRects.join(''),
	          '\t\t<text ',
	            (this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, '\'') + '" ' : ''),
	            (this.fontSize ? 'font-size="' + this.fontSize + '" ' : ''),
	            (this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : ''),
	            (this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : ''),
	            (this.textDecoration ? 'text-decoration="' + this.textDecoration + '" ' : ''),
	            'style="', this.getSvgStyles(noShadow), '" >\n',
	            textAndBg.textSpans.join(''),
	          '\t\t</text>\n',
	        '\t</g>\n'
	      );
	    },
	
	    /**
	     * @private
	     * @param {Number} textTopOffset Text top offset
	     * @param {Number} textLeftOffset Text left offset
	     * @return {Object}
	     */
	    _getSVGTextAndBg: function(textTopOffset, textLeftOffset) {
	      var textSpans = [],
	          textBgRects = [],
	          height = 0;
	      // bounding-box background
	      this._setSVGBg(textBgRects);
	
	      // text and text-background
	      for (var i = 0, len = this._textLines.length; i < len; i++) {
	        if (this.textBackgroundColor) {
	          this._setSVGTextLineBg(textBgRects, i, textLeftOffset, textTopOffset, height);
	        }
	        this._setSVGTextLineText(i, textSpans, height, textLeftOffset, textTopOffset, textBgRects);
	        height += this._getHeightOfLine(this.ctx, i);
	      }
	
	      return {
	        textSpans: textSpans,
	        textBgRects: textBgRects
	      };
	    },
	
	    _setSVGTextLineText: function(i, textSpans, height, textLeftOffset, textTopOffset) {
	      var yPos = this.fontSize * (this._fontSizeMult - this._fontSizeFraction)
	        - textTopOffset + height - this.height / 2;
	      if (this.textAlign === 'justify') {
	        // i call from here to do not intefere with IText
	        this._setSVGTextLineJustifed(i, textSpans, yPos, textLeftOffset);
	        return;
	      }
	      textSpans.push(
	        '\t\t\t<tspan x="',
	          toFixed(textLeftOffset + this._getLineLeftOffset(this._getLineWidth(this.ctx, i)), NUM_FRACTION_DIGITS), '" ',
	          'y="',
	          toFixed(yPos, NUM_FRACTION_DIGITS),
	          '" ',
	          // doing this on <tspan> elements since setting opacity
	          // on containing <text> one doesn't work in Illustrator
	          this._getFillAttributes(this.fill), '>',
	          fabric.util.string.escapeXml(this._textLines[i]),
	        '</tspan>\n'
	      );
	    },
	
	    _setSVGTextLineJustifed: function(i, textSpans, yPos, textLeftOffset) {
	      var ctx = fabric.util.createCanvasElement().getContext('2d');
	
	      this._setTextStyles(ctx);
	
	      var line = this._textLines[i],
	          words = line.split(/\s+/),
	          wordsWidth = this._getWidthOfWords(ctx, words.join('')),
	          widthDiff = this.width - wordsWidth,
	          numSpaces = words.length - 1,
	          spaceWidth = numSpaces > 0 ? widthDiff / numSpaces : 0,
	          word, attributes = this._getFillAttributes(this.fill),
	          len;
	
	      textLeftOffset += this._getLineLeftOffset(this._getLineWidth(ctx, i));
	
	      for (i = 0, len = words.length; i < len; i++) {
	        word = words[i];
	        textSpans.push(
	          '\t\t\t<tspan x="',
	            toFixed(textLeftOffset, NUM_FRACTION_DIGITS), '" ',
	            'y="',
	            toFixed(yPos, NUM_FRACTION_DIGITS),
	            '" ',
	            // doing this on <tspan> elements since setting opacity
	            // on containing <text> one doesn't work in Illustrator
	            attributes, '>',
	            fabric.util.string.escapeXml(word),
	          '</tspan>\n'
	        );
	        textLeftOffset += this._getWidthOfWords(ctx, word) + spaceWidth;
	      }
	    },
	
	    _setSVGTextLineBg: function(textBgRects, i, textLeftOffset, textTopOffset, height) {
	      textBgRects.push(
	        '\t\t<rect ',
	          this._getFillAttributes(this.textBackgroundColor),
	          ' x="',
	          toFixed(textLeftOffset + this._getLineLeftOffset(this._getLineWidth(this.ctx, i)), NUM_FRACTION_DIGITS),
	          '" y="',
	          toFixed(height - this.height / 2, NUM_FRACTION_DIGITS),
	          '" width="',
	          toFixed(this._getLineWidth(this.ctx, i), NUM_FRACTION_DIGITS),
	          '" height="',
	          toFixed(this._getHeightOfLine(this.ctx, i) / this.lineHeight, NUM_FRACTION_DIGITS),
	        '"></rect>\n');
	    },
	
	    _setSVGBg: function(textBgRects) {
	      if (this.backgroundColor) {
	        textBgRects.push(
	          '\t\t<rect ',
	            this._getFillAttributes(this.backgroundColor),
	            ' x="',
	            toFixed(-this.width / 2, NUM_FRACTION_DIGITS),
	            '" y="',
	            toFixed(-this.height / 2, NUM_FRACTION_DIGITS),
	            '" width="',
	            toFixed(this.width, NUM_FRACTION_DIGITS),
	            '" height="',
	            toFixed(this.height, NUM_FRACTION_DIGITS),
	          '"></rect>\n');
	      }
	    },
	
	    /**
	     * Adobe Illustrator (at least CS5) is unable to render rgba()-based fill values
	     * we work around it by "moving" alpha channel into opacity attribute and setting fill's alpha to 1
	     *
	     * @private
	     * @param {*} value
	     * @return {String}
	     */
	    _getFillAttributes: function(value) {
	      var fillColor = (value && typeof value === 'string') ? new fabric.Color(value) : '';
	      if (!fillColor || !fillColor.getSource() || fillColor.getAlpha() === 1) {
	        return 'fill="' + value + '"';
	      }
	      return 'opacity="' + fillColor.getAlpha() + '" fill="' + fillColor.setAlpha(1).toRgb() + '"';
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Sets specified property to a specified value
	     * @param {String} key
	     * @param {*} value
	     * @return {fabric.Text} thisArg
	     * @chainable
	     */
	    _set: function(key, value) {
	      this.callSuper('_set', key, value);
	
	      if (key in this._dimensionAffectingProps) {
	        this._initDimensions();
	        this.setCoords();
	      }
	    },
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity
	     */
	    complexity: function() {
	      return 1;
	    }
	  });
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Text.fromElement})
	   * @static
	   * @memberOf fabric.Text
	   * @see: http://www.w3.org/TR/SVG/text.html#TextElement
	   */
	  fabric.Text.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(
	    'x y dx dy font-family font-style font-weight font-size text-decoration text-anchor'.split(' '));
	
	  /**
	   * Default SVG font size
	   * @static
	   * @memberOf fabric.Text
	   */
	  fabric.Text.DEFAULT_SVG_FONT_SIZE = 16;
	
	  /**
	   * Returns fabric.Text instance from an SVG element (<b>not yet implemented</b>)
	   * @static
	   * @memberOf fabric.Text
	   * @param {SVGElement} element Element to parse
	   * @param {Object} [options] Options object
	   * @return {fabric.Text} Instance of fabric.Text
	   */
	  fabric.Text.fromElement = function(element, options) {
	    if (!element) {
	      return null;
	    }
	
	    var parsedAttributes = fabric.parseAttributes(element, fabric.Text.ATTRIBUTE_NAMES);
	    options = fabric.util.object.extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes);
	
	    options.top = options.top || 0;
	    options.left = options.left || 0;
	    if ('dx' in parsedAttributes) {
	      options.left += parsedAttributes.dx;
	    }
	    if ('dy' in parsedAttributes) {
	      options.top += parsedAttributes.dy;
	    }
	    if (!('fontSize' in options)) {
	      options.fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;
	    }
	
	    if (!options.originX) {
	      options.originX = 'left';
	    }
	
	    var textContent = '';
	
	    // The XML is not properly parsed in IE9 so a workaround to get
	    // textContent is through firstChild.data. Another workaround would be
	    // to convert XML loaded from a file to be converted using DOMParser (same way loadSVGFromString() does)
	    if (!('textContent' in element)) {
	      if ('firstChild' in element && element.firstChild !== null) {
	        if ('data' in element.firstChild && element.firstChild.data !== null) {
	          textContent = element.firstChild.data;
	        }
	      }
	    }
	    else {
	      textContent = element.textContent;
	    }
	
	    textContent = textContent.replace(/^\s+|\s+$|\n+/g, '').replace(/\s+/g, ' ');
	
	    var text = new fabric.Text(textContent, options),
	        textHeightScaleFactor = text.getHeight() / text.height,
	        lineHeightDiff = (text.height + text.strokeWidth) * text.lineHeight - text.height,
	        scaledDiff = lineHeightDiff * textHeightScaleFactor,
	        textHeight = text.getHeight() + scaledDiff,
	        offX = 0;
	    /*
	      Adjust positioning:
	        x/y attributes in SVG correspond to the bottom-left corner of text bounding box
	        top/left properties in Fabric correspond to center point of text bounding box
	    */
	    if (text.originX === 'left') {
	      offX = text.getWidth() / 2;
	    }
	    if (text.originX === 'right') {
	      offX = -text.getWidth() / 2;
	    }
	    text.set({
	      left: text.getLeft() + offX,
	      top: text.getTop() - textHeight / 2 + text.fontSize * (0.18 + text._fontSizeFraction) / text.lineHeight /* 0.3 is the old lineHeight */
	    });
	
	    return text;
	  };
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Returns fabric.Text instance from an object representation
	   * @static
	   * @memberOf fabric.Text
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] Callback to invoke when an fabric.Text instance is created
	   * @return {fabric.Text} Instance of fabric.Text
	   */
	  fabric.Text.fromObject = function(object, callback) {
	    var text = new fabric.Text(object.text, clone(object));
	    callback && callback(text);
	    return text;
	  };
	
	  fabric.util.createAccessors(fabric.Text);
	
	})( true ? exports : this);
	
	
	(function() {
	
	  var clone = fabric.util.object.clone;
	
	  /**
	   * IText class (introduced in <b>v1.4</b>) Events are also fired with "text:"
	   * prefix when observing canvas.
	   * @class fabric.IText
	   * @extends fabric.Text
	   * @mixes fabric.Observable
	   *
	   * @fires changed
	   * @fires selection:changed
	   * @fires editing:entered
	   * @fires editing:exited
	   *
	   * @return {fabric.IText} thisArg
	   * @see {@link fabric.IText#initialize} for constructor definition
	   *
	   * <p>Supported key combinations:</p>
	   * <pre>
	   *   Move cursor:                    left, right, up, down
	   *   Select character:               shift + left, shift + right
	   *   Select text vertically:         shift + up, shift + down
	   *   Move cursor by word:            alt + left, alt + right
	   *   Select words:                   shift + alt + left, shift + alt + right
	   *   Move cursor to line start/end:  cmd + left, cmd + right or home, end
	   *   Select till start/end of line:  cmd + shift + left, cmd + shift + right or shift + home, shift + end
	   *   Jump to start/end of text:      cmd + up, cmd + down
	   *   Select till start/end of text:  cmd + shift + up, cmd + shift + down or shift + pgUp, shift + pgDown
	   *   Delete character:               backspace
	   *   Delete word:                    alt + backspace
	   *   Delete line:                    cmd + backspace
	   *   Forward delete:                 delete
	   *   Copy text:                      ctrl/cmd + c
	   *   Paste text:                     ctrl/cmd + v
	   *   Cut text:                       ctrl/cmd + x
	   *   Select entire text:             ctrl/cmd + a
	   *   Quit editing                    tab or esc
	   * </pre>
	   *
	   * <p>Supported mouse/touch combination</p>
	   * <pre>
	   *   Position cursor:                click/touch
	   *   Create selection:               click/touch & drag
	   *   Create selection:               click & shift + click
	   *   Select word:                    double click
	   *   Select line:                    triple click
	   * </pre>
	   */
	  fabric.IText = fabric.util.createClass(fabric.Text, fabric.Observable, /** @lends fabric.IText.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'i-text',
	
	    /**
	     * Index where text selection starts (or where cursor is when there is no selection)
	     * @type Number
	     * @default
	     */
	    selectionStart: 0,
	
	    /**
	     * Index where text selection ends
	     * @type Number
	     * @default
	     */
	    selectionEnd: 0,
	
	    /**
	     * Color of text selection
	     * @type String
	     * @default
	     */
	    selectionColor: 'rgba(17,119,255,0.3)',
	
	    /**
	     * Indicates whether text is in editing mode
	     * @type Boolean
	     * @default
	     */
	    isEditing: false,
	
	    /**
	     * Indicates whether a text can be edited
	     * @type Boolean
	     * @default
	     */
	    editable: true,
	
	    /**
	     * Border color of text object while it's in editing mode
	     * @type String
	     * @default
	     */
	    editingBorderColor: 'rgba(102,153,255,0.25)',
	
	    /**
	     * Width of cursor (in px)
	     * @type Number
	     * @default
	     */
	    cursorWidth: 2,
	
	    /**
	     * Color of default cursor (when not overwritten by character style)
	     * @type String
	     * @default
	     */
	    cursorColor: '#333',
	
	    /**
	     * Delay between cursor blink (in ms)
	     * @type Number
	     * @default
	     */
	    cursorDelay: 1000,
	
	    /**
	     * Duration of cursor fadein (in ms)
	     * @type Number
	     * @default
	     */
	    cursorDuration: 600,
	
	    /**
	     * Object containing character styles
	     * (where top-level properties corresponds to line number and 2nd-level properties -- to char number in a line)
	     * @type Object
	     * @default
	     */
	    styles: null,
	
	    /**
	     * Indicates whether internal text char widths can be cached
	     * @type Boolean
	     * @default
	     */
	    caching: true,
	
	    /**
	     * @private
	     */
	    _reSpace: /\s|\n/,
	
	    /**
	     * @private
	     */
	    _currentCursorOpacity: 0,
	
	    /**
	     * @private
	     */
	    _selectionDirection: null,
	
	    /**
	     * @private
	     */
	    _abortCursorAnimation: false,
	
	    /**
	     * @private
	     */
	    __widthOfSpace: [],
	
	    /**
	     * Constructor
	     * @param {String} text Text string
	     * @param {Object} [options] Options object
	     * @return {fabric.IText} thisArg
	     */
	    initialize: function(text, options) {
	      this.styles = options ? (options.styles || { }) : { };
	      this.callSuper('initialize', text, options);
	      this.initBehavior();
	    },
	
	    /**
	     * @private
	     */
	    _clearCache: function() {
	      this.callSuper('_clearCache');
	      this.__widthOfSpace = [];
	    },
	
	    /**
	     * Returns true if object has no styling
	     */
	    isEmptyStyles: function() {
	      if (!this.styles) {
	        return true;
	      }
	      var obj = this.styles;
	
	      for (var p1 in obj) {
	        for (var p2 in obj[p1]) {
	          // eslint-disable-next-line no-unused-vars
	          for (var p3 in obj[p1][p2]) {
	            return false;
	          }
	        }
	      }
	      return true;
	    },
	
	    /**
	     * Sets selection start (left boundary of a selection)
	     * @param {Number} index Index to set selection start to
	     */
	    setSelectionStart: function(index) {
	      index = Math.max(index, 0);
	      this._updateAndFire('selectionStart', index);
	    },
	
	    /**
	     * Sets selection end (right boundary of a selection)
	     * @param {Number} index Index to set selection end to
	     */
	    setSelectionEnd: function(index) {
	      index = Math.min(index, this.text.length);
	      this._updateAndFire('selectionEnd', index);
	    },
	
	    /**
	     * @private
	     * @param {String} property 'selectionStart' or 'selectionEnd'
	     * @param {Number} index new position of property
	     */
	    _updateAndFire: function(property, index) {
	      if (this[property] !== index) {
	        this._fireSelectionChanged();
	        this[property] = index;
	      }
	      this._updateTextarea();
	    },
	
	    /**
	     * Fires the even of selection changed
	     * @private
	     */
	    _fireSelectionChanged: function() {
	      this.fire('selection:changed');
	      this.canvas && this.canvas.fire('text:selection:changed', { target: this });
	    },
	
	    /**
	     * Gets style of a current selection/cursor (at the start position)
	     * @param {Number} [startIndex] Start index to get styles at
	     * @param {Number} [endIndex] End index to get styles at
	     * @return {Object} styles Style object at a specified (or current) index
	     */
	    getSelectionStyles: function(startIndex, endIndex) {
	
	      if (arguments.length === 2) {
	        var styles = [];
	        for (var i = startIndex; i < endIndex; i++) {
	          styles.push(this.getSelectionStyles(i));
	        }
	        return styles;
	      }
	
	      var loc = this.get2DCursorLocation(startIndex),
	          style = this._getStyleDeclaration(loc.lineIndex, loc.charIndex);
	
	      return style || {};
	    },
	
	    /**
	     * Sets style of a current selection
	     * @param {Object} [styles] Styles object
	     * @return {fabric.IText} thisArg
	     * @chainable
	     */
	    setSelectionStyles: function(styles) {
	      if (this.selectionStart === this.selectionEnd) {
	        this._extendStyles(this.selectionStart, styles);
	      }
	      else {
	        for (var i = this.selectionStart; i < this.selectionEnd; i++) {
	          this._extendStyles(i, styles);
	        }
	      }
	      /* not included in _extendStyles to avoid clearing cache more than once */
	      this._forceClearCache = true;
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _extendStyles: function(index, styles) {
	      var loc = this.get2DCursorLocation(index);
	
	      if (!this._getLineStyle(loc.lineIndex)) {
	        this._setLineStyle(loc.lineIndex, {});
	      }
	
	      if (!this._getStyleDeclaration(loc.lineIndex, loc.charIndex)) {
	        this._setStyleDeclaration(loc.lineIndex, loc.charIndex, {});
	      }
	
	      fabric.util.object.extend(this._getStyleDeclaration(loc.lineIndex, loc.charIndex), styles);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _render: function(ctx) {
	      this.oldWidth = this.width;
	      this.oldHeight = this.height;
	      this.callSuper('_render', ctx);
	      this.ctx = ctx;
	      // clear the cursorOffsetCache, so we ensure to calculate once per renderCursor
	      // the correct position but not at every cursor animation.
	      this.cursorOffsetCache = { };
	      this.renderCursorOrSelection();
	    },
	
	    /**
	     * Renders cursor or selection (depending on what exists)
	     */
	    renderCursorOrSelection: function() {
	      if (!this.active || !this.isEditing) {
	        return;
	      }
	      var chars = this.text.split(''),
	          boundaries, ctx;
	      if (this.canvas.contextTop) {
	        ctx = this.canvas.contextTop;
	        ctx.save();
	        ctx.transform.apply(ctx, this.canvas.viewportTransform);
	        this.transform(ctx);
	        this.transformMatrix && ctx.transform.apply(ctx, this.transformMatrix);
	        this._clearTextArea(ctx);
	      }
	      else {
	        ctx = this.ctx;
	        ctx.save();
	      }
	      if (this.selectionStart === this.selectionEnd) {
	        boundaries = this._getCursorBoundaries(chars, 'cursor');
	        this.renderCursor(boundaries, ctx);
	      }
	      else {
	        boundaries = this._getCursorBoundaries(chars, 'selection');
	        this.renderSelection(chars, boundaries, ctx);
	      }
	
	      ctx.restore();
	    },
	
	    _clearTextArea: function(ctx) {
	      // we add 4 pixel, to be sure to do not leave any pixel out
	      var width = this.oldWidth + 4, height = this.oldHeight + 4;
	      ctx.clearRect(-width / 2, -height / 2, width, height);
	    },
	    /**
	     * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start)
	     * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.
	     */
	    get2DCursorLocation: function(selectionStart) {
	      if (typeof selectionStart === 'undefined') {
	        selectionStart = this.selectionStart;
	      }
	      var len = this._textLines.length;
	      for (var i = 0; i < len; i++) {
	        if (selectionStart <= this._textLines[i].length) {
	          return {
	            lineIndex: i,
	            charIndex: selectionStart
	          };
	        }
	        selectionStart -= this._textLines[i].length + 1;
	      }
	      return {
	        lineIndex: i - 1,
	        charIndex: this._textLines[i - 1].length < selectionStart ? this._textLines[i - 1].length : selectionStart
	      };
	    },
	
	    /**
	     * Returns complete style of char at the current cursor
	     * @param {Number} lineIndex Line index
	     * @param {Number} charIndex Char index
	     * @return {Object} Character style
	     */
	    getCurrentCharStyle: function(lineIndex, charIndex) {
	      var style = this._getStyleDeclaration(lineIndex, charIndex === 0 ? 0 : charIndex - 1);
	
	      return {
	        fontSize: style && style.fontSize || this.fontSize,
	        fill: style && style.fill || this.fill,
	        textBackgroundColor: style && style.textBackgroundColor || this.textBackgroundColor,
	        textDecoration: style && style.textDecoration || this.textDecoration,
	        fontFamily: style && style.fontFamily || this.fontFamily,
	        fontWeight: style && style.fontWeight || this.fontWeight,
	        fontStyle: style && style.fontStyle || this.fontStyle,
	        stroke: style && style.stroke || this.stroke,
	        strokeWidth: style && style.strokeWidth || this.strokeWidth
	      };
	    },
	
	    /**
	     * Returns fontSize of char at the current cursor
	     * @param {Number} lineIndex Line index
	     * @param {Number} charIndex Char index
	     * @return {Number} Character font size
	     */
	    getCurrentCharFontSize: function(lineIndex, charIndex) {
	      var style = this._getStyleDeclaration(lineIndex, charIndex === 0 ? 0 : charIndex - 1);
	      return style && style.fontSize ? style.fontSize : this.fontSize;
	    },
	
	    /**
	     * Returns color (fill) of char at the current cursor
	     * @param {Number} lineIndex Line index
	     * @param {Number} charIndex Char index
	     * @return {String} Character color (fill)
	     */
	    getCurrentCharColor: function(lineIndex, charIndex) {
	      var style = this._getStyleDeclaration(lineIndex, charIndex === 0 ? 0 : charIndex - 1);
	      return style && style.fill ? style.fill : this.cursorColor;
	    },
	
	    /**
	     * Returns cursor boundaries (left, top, leftOffset, topOffset)
	     * @private
	     * @param {Array} chars Array of characters
	     * @param {String} typeOfBoundaries
	     */
	    _getCursorBoundaries: function(chars, typeOfBoundaries) {
	
	      // left/top are left/top of entire text box
	      // leftOffset/topOffset are offset from that left/top point of a text box
	
	      var left = Math.round(this._getLeftOffset()),
	          top = this._getTopOffset(),
	
	          offsets = this._getCursorBoundariesOffsets(
	                      chars, typeOfBoundaries);
	
	      return {
	        left: left,
	        top: top,
	        leftOffset: offsets.left + offsets.lineLeft,
	        topOffset: offsets.top
	      };
	    },
	
	    /**
	     * @private
	     */
	    _getCursorBoundariesOffsets: function(chars, typeOfBoundaries) {
	      if (this.cursorOffsetCache && 'top' in this.cursorOffsetCache) {
	        return this.cursorOffsetCache;
	      }
	      var lineLeftOffset = 0,
	          lineIndex = 0,
	          charIndex = 0,
	          topOffset = 0,
	          leftOffset = 0,
	          boundaries;
	
	      for (var i = 0; i < this.selectionStart; i++) {
	        if (chars[i] === '\n') {
	          leftOffset = 0;
	          topOffset += this._getHeightOfLine(this.ctx, lineIndex);
	
	          lineIndex++;
	          charIndex = 0;
	        }
	        else {
	          leftOffset += this._getWidthOfChar(this.ctx, chars[i], lineIndex, charIndex);
	          charIndex++;
	        }
	
	        lineLeftOffset = this._getLineLeftOffset(this._getLineWidth(this.ctx, lineIndex));
	      }
	      if (typeOfBoundaries === 'cursor') {
	        topOffset += (1 - this._fontSizeFraction) * this._getHeightOfLine(this.ctx, lineIndex) / this.lineHeight
	          - this.getCurrentCharFontSize(lineIndex, charIndex) * (1 - this._fontSizeFraction);
	      }
	      if (this.charSpacing !== 0 && charIndex === this._textLines[lineIndex].length) {
	        leftOffset -= this._getWidthOfCharSpacing();
	      }
	      boundaries = {
	        top: topOffset,
	        left: leftOffset > 0 ? leftOffset : 0,
	        lineLeft: lineLeftOffset
	      };
	      this.cursorOffsetCache = boundaries;
	      return this.cursorOffsetCache;
	    },
	
	    /**
	     * Renders cursor
	     * @param {Object} boundaries
	     * @param {CanvasRenderingContext2D} ctx transformed context to draw on
	     */
	    renderCursor: function(boundaries, ctx) {
	
	      var cursorLocation = this.get2DCursorLocation(),
	          lineIndex = cursorLocation.lineIndex,
	          charIndex = cursorLocation.charIndex,
	          charHeight = this.getCurrentCharFontSize(lineIndex, charIndex),
	          leftOffset = (lineIndex === 0 && charIndex === 0)
	                    ? this._getLineLeftOffset(this._getLineWidth(ctx, lineIndex))
	                    : boundaries.leftOffset,
	          multiplier = this.scaleX * this.canvas.getZoom(),
	          cursorWidth = this.cursorWidth / multiplier;
	
	      ctx.fillStyle = this.getCurrentCharColor(lineIndex, charIndex);
	      ctx.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity;
	
	      ctx.fillRect(
	        boundaries.left + leftOffset - cursorWidth / 2,
	        boundaries.top + boundaries.topOffset,
	        cursorWidth,
	        charHeight);
	    },
	
	    /**
	     * Renders text selection
	     * @param {Array} chars Array of characters
	     * @param {Object} boundaries Object with left/top/leftOffset/topOffset
	     * @param {CanvasRenderingContext2D} ctx transformed context to draw on
	     */
	    renderSelection: function(chars, boundaries, ctx) {
	
	      ctx.fillStyle = this.selectionColor;
	
	      var start = this.get2DCursorLocation(this.selectionStart),
	          end = this.get2DCursorLocation(this.selectionEnd),
	          startLine = start.lineIndex,
	          endLine = end.lineIndex;
	      for (var i = startLine; i <= endLine; i++) {
	        var lineOffset = this._getLineLeftOffset(this._getLineWidth(ctx, i)) || 0,
	            lineHeight = this._getHeightOfLine(this.ctx, i),
	            realLineHeight = 0, boxWidth = 0, line = this._textLines[i];
	
	        if (i === startLine) {
	          for (var j = 0, len = line.length; j < len; j++) {
	            if (j >= start.charIndex && (i !== endLine || j < end.charIndex)) {
	              boxWidth += this._getWidthOfChar(ctx, line[j], i, j);
	            }
	            if (j < start.charIndex) {
	              lineOffset += this._getWidthOfChar(ctx, line[j], i, j);
	            }
	          }
	          if (j === line.length) {
	            boxWidth -= this._getWidthOfCharSpacing();
	          }
	        }
	        else if (i > startLine && i < endLine) {
	          boxWidth += this._getLineWidth(ctx, i) || 5;
	        }
	        else if (i === endLine) {
	          for (var j2 = 0, j2len = end.charIndex; j2 < j2len; j2++) {
	            boxWidth += this._getWidthOfChar(ctx, line[j2], i, j2);
	          }
	          if (end.charIndex === line.length) {
	            boxWidth -= this._getWidthOfCharSpacing();
	          }
	        }
	        realLineHeight = lineHeight;
	        if (this.lineHeight < 1 || (i === endLine && this.lineHeight > 1)) {
	          lineHeight /= this.lineHeight;
	        }
	        ctx.fillRect(
	          boundaries.left + lineOffset,
	          boundaries.top + boundaries.topOffset,
	          boxWidth > 0 ? boxWidth : 0,
	          lineHeight);
	
	        boundaries.topOffset += realLineHeight;
	      }
	    },
	
	    /**
	     * @private
	     * @param {String} method
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {String} line Content of the line
	     * @param {Number} left
	     * @param {Number} top
	     * @param {Number} lineIndex
	     * @param {Number} charOffset
	     */
	    _renderChars: function(method, ctx, line, left, top, lineIndex, charOffset) {
	
	      if (this.isEmptyStyles()) {
	        return this._renderCharsFast(method, ctx, line, left, top);
	      }
	
	      charOffset = charOffset || 0;
	
	      // set proper line offset
	      var lineHeight = this._getHeightOfLine(ctx, lineIndex),
	          prevStyle,
	          thisStyle,
	          charsToRender = '';
	
	      ctx.save();
	      top -= lineHeight / this.lineHeight * this._fontSizeFraction;
	      for (var i = charOffset, len = line.length + charOffset; i <= len; i++) {
	        prevStyle = prevStyle || this.getCurrentCharStyle(lineIndex, i);
	        thisStyle = this.getCurrentCharStyle(lineIndex, i + 1);
	
	        if (this._hasStyleChanged(prevStyle, thisStyle) || i === len) {
	          this._renderChar(method, ctx, lineIndex, i - 1, charsToRender, left, top, lineHeight);
	          charsToRender = '';
	          prevStyle = thisStyle;
	        }
	        charsToRender += line[i - charOffset];
	      }
	      ctx.restore();
	    },
	
	    /**
	     * @private
	     * @param {String} method
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {String} line Content of the line
	     * @param {Number} left Left coordinate
	     * @param {Number} top Top coordinate
	     */
	    _renderCharsFast: function(method, ctx, line, left, top) {
	
	      if (method === 'fillText' && this.fill) {
	        this.callSuper('_renderChars', method, ctx, line, left, top);
	      }
	      if (method === 'strokeText' && ((this.stroke && this.strokeWidth > 0) || this.skipFillStrokeCheck)) {
	        this.callSuper('_renderChars', method, ctx, line, left, top);
	      }
	    },
	
	    /**
	     * @private
	     * @param {String} method
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Number} lineIndex
	     * @param {Number} i
	     * @param {String} _char
	     * @param {Number} left Left coordinate
	     * @param {Number} top Top coordinate
	     * @param {Number} lineHeight Height of the line
	     */
	    _renderChar: function(method, ctx, lineIndex, i, _char, left, top, lineHeight) {
	      var charWidth, charHeight, shouldFill, shouldStroke,
	          decl = this._getStyleDeclaration(lineIndex, i),
	          offset, textDecoration, chars, additionalSpace, _charWidth;
	
	      if (decl) {
	        charHeight = this._getHeightOfChar(ctx, _char, lineIndex, i);
	        shouldStroke = decl.stroke;
	        shouldFill = decl.fill;
	        textDecoration = decl.textDecoration;
	      }
	      else {
	        charHeight = this.fontSize;
	      }
	
	      shouldStroke = (shouldStroke || this.stroke) && method === 'strokeText';
	      shouldFill = (shouldFill || this.fill) && method === 'fillText';
	
	      decl && ctx.save();
	
	      charWidth = this._applyCharStylesGetWidth(ctx, _char, lineIndex, i, decl || null);
	      textDecoration = textDecoration || this.textDecoration;
	
	      if (decl && decl.textBackgroundColor) {
	        this._removeShadow(ctx);
	      }
	      if (this.charSpacing !== 0) {
	        additionalSpace = this._getWidthOfCharSpacing();
	        chars = _char.split('');
	        charWidth = 0;
	        for (var j = 0, len = chars.length, char; j < len; j++) {
	          char = chars[j];
	          shouldFill && ctx.fillText(char, left + charWidth, top);
	          shouldStroke && ctx.strokeText(char, left + charWidth, top);
	          _charWidth = ctx.measureText(char).width + additionalSpace;
	          charWidth += _charWidth > 0 ? _charWidth : 0;
	        }
	      }
	      else {
	        shouldFill && ctx.fillText(_char, left, top);
	        shouldStroke && ctx.strokeText(_char, left, top);
	      }
	
	      if (textDecoration || textDecoration !== '') {
	        offset = this._fontSizeFraction * lineHeight / this.lineHeight;
	        this._renderCharDecoration(ctx, textDecoration, left, top, offset, charWidth, charHeight);
	      }
	
	      decl && ctx.restore();
	      ctx.translate(charWidth, 0);
	    },
	
	    /**
	     * @private
	     * @param {Object} prevStyle
	     * @param {Object} thisStyle
	     */
	    _hasStyleChanged: function(prevStyle, thisStyle) {
	      return (prevStyle.fill !== thisStyle.fill ||
	              prevStyle.fontSize !== thisStyle.fontSize ||
	              prevStyle.textBackgroundColor !== thisStyle.textBackgroundColor ||
	              prevStyle.textDecoration !== thisStyle.textDecoration ||
	              prevStyle.fontFamily !== thisStyle.fontFamily ||
	              prevStyle.fontWeight !== thisStyle.fontWeight ||
	              prevStyle.fontStyle !== thisStyle.fontStyle ||
	              prevStyle.stroke !== thisStyle.stroke ||
	              prevStyle.strokeWidth !== thisStyle.strokeWidth
	      );
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderCharDecoration: function(ctx, textDecoration, left, top, offset, charWidth, charHeight) {
	
	      if (!textDecoration) {
	        return;
	      }
	
	      var decorationWeight = charHeight / 15,
	          positions = {
	            underline: top + charHeight / 10,
	            'line-through': top - charHeight * (this._fontSizeFraction + this._fontSizeMult - 1) + decorationWeight,
	            overline: top - (this._fontSizeMult - this._fontSizeFraction) * charHeight
	          },
	          decorations = ['underline', 'line-through', 'overline'], i, decoration;
	
	      for (i = 0; i < decorations.length; i++) {
	        decoration = decorations[i];
	        if (textDecoration.indexOf(decoration) > -1) {
	          ctx.fillRect(left, positions[decoration], charWidth , decorationWeight);
	        }
	      }
	    },
	
	    /**
	     * @private
	     * @param {String} method
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {String} line
	     * @param {Number} left
	     * @param {Number} top
	     * @param {Number} lineIndex
	     */
	    _renderTextLine: function(method, ctx, line, left, top, lineIndex) {
	      // to "cancel" this.fontSize subtraction in fabric.Text#_renderTextLine
	      // the adding 0.03 is just to align text with itext by overlap test
	      if (!this.isEmptyStyles()) {
	        top += this.fontSize * (this._fontSizeFraction + 0.03);
	      }
	      this.callSuper('_renderTextLine', method, ctx, line, left, top, lineIndex);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderTextDecoration: function(ctx) {
	      if (this.isEmptyStyles()) {
	        return this.callSuper('_renderTextDecoration', ctx);
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderTextLinesBackground: function(ctx) {
	      this.callSuper('_renderTextLinesBackground', ctx);
	
	      var lineTopOffset = 0, heightOfLine,
	          lineWidth, lineLeftOffset,
	          leftOffset = this._getLeftOffset(),
	          topOffset = this._getTopOffset(),
	          line, _char, style;
	
	      for (var i = 0, len = this._textLines.length; i < len; i++) {
	        heightOfLine = this._getHeightOfLine(ctx, i);
	        line = this._textLines[i];
	
	        if (line === '' || !this.styles || !this._getLineStyle(i)) {
	          lineTopOffset += heightOfLine;
	          continue;
	        }
	
	        lineWidth = this._getLineWidth(ctx, i);
	        lineLeftOffset = this._getLineLeftOffset(lineWidth);
	
	        for (var j = 0, jlen = line.length; j < jlen; j++) {
	          style = this._getStyleDeclaration(i, j);
	          if (!style || !style.textBackgroundColor) {
	            continue;
	          }
	          _char = line[j];
	
	          ctx.fillStyle = style.textBackgroundColor;
	
	          ctx.fillRect(
	            leftOffset + lineLeftOffset + this._getWidthOfCharsAt(ctx, i, j),
	            topOffset + lineTopOffset,
	            this._getWidthOfChar(ctx, _char, i, j) + 1,
	            heightOfLine / this.lineHeight
	          );
	        }
	        lineTopOffset += heightOfLine;
	      }
	    },
	
	    /**
	     * @private
	     */
	    _getCacheProp: function(_char, styleDeclaration) {
	      return _char +
	             styleDeclaration.fontSize +
	             styleDeclaration.fontWeight +
	             styleDeclaration.fontStyle;
	    },
	
	    /**
	     * @private
	     * @param {String} fontFamily name
	     * @return {Object} reference to cache
	     */
	    _getFontCache: function(fontFamily) {
	      if (!fabric.charWidthsCache[fontFamily]) {
	        fabric.charWidthsCache[fontFamily] = { };
	      }
	      return fabric.charWidthsCache[fontFamily];
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {String} _char
	     * @param {Number} lineIndex
	     * @param {Number} charIndex
	     * @param {Object} [decl]
	     */
	    _applyCharStylesGetWidth: function(ctx, _char, lineIndex, charIndex, decl) {
	      var charDecl = decl || this._getStyleDeclaration(lineIndex, charIndex),
	          styleDeclaration = clone(charDecl),
	          width, cacheProp, charWidthsCache;
	
	      this._applyFontStyles(styleDeclaration);
	      charWidthsCache = this._getFontCache(styleDeclaration.fontFamily);
	      cacheProp = this._getCacheProp(_char, styleDeclaration);
	
	      // short-circuit if no styles for this char
	      // global style from object is always applyed and handled by save and restore
	      if (!charDecl && charWidthsCache[cacheProp] && this.caching) {
	        return charWidthsCache[cacheProp];
	      }
	
	      if (typeof styleDeclaration.shadow === 'string') {
	        styleDeclaration.shadow = new fabric.Shadow(styleDeclaration.shadow);
	      }
	
	      var fill = styleDeclaration.fill || this.fill;
	      ctx.fillStyle = fill.toLive
	        ? fill.toLive(ctx, this)
	        : fill;
	
	      if (styleDeclaration.stroke) {
	        ctx.strokeStyle = (styleDeclaration.stroke && styleDeclaration.stroke.toLive)
	          ? styleDeclaration.stroke.toLive(ctx, this)
	          : styleDeclaration.stroke;
	      }
	
	      ctx.lineWidth = styleDeclaration.strokeWidth || this.strokeWidth;
	      ctx.font = this._getFontDeclaration.call(styleDeclaration);
	
	      //if we want this._setShadow.call to work with styleDeclarion
	      //we have to add those references
	      if (styleDeclaration.shadow) {
	        styleDeclaration.scaleX = this.scaleX;
	        styleDeclaration.scaleY = this.scaleY;
	        styleDeclaration.canvas = this.canvas;
	        styleDeclaration.getObjectScaling = this.getObjectScaling;
	        this._setShadow.call(styleDeclaration, ctx);
	      }
	
	      if (!this.caching || !charWidthsCache[cacheProp]) {
	        width = ctx.measureText(_char).width;
	        this.caching && (charWidthsCache[cacheProp] = width);
	        return width;
	      }
	
	      return charWidthsCache[cacheProp];
	    },
	
	    /**
	     * @private
	     * @param {Object} styleDeclaration
	     */
	    _applyFontStyles: function(styleDeclaration) {
	      if (!styleDeclaration.fontFamily) {
	        styleDeclaration.fontFamily = this.fontFamily;
	      }
	      if (!styleDeclaration.fontSize) {
	        styleDeclaration.fontSize = this.fontSize;
	      }
	      if (!styleDeclaration.fontWeight) {
	        styleDeclaration.fontWeight = this.fontWeight;
	      }
	      if (!styleDeclaration.fontStyle) {
	        styleDeclaration.fontStyle = this.fontStyle;
	      }
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @param {Number} charIndex
	     * @param {Boolean} [returnCloneOrEmpty=false]
	     * @private
	     */
	    _getStyleDeclaration: function(lineIndex, charIndex, returnCloneOrEmpty) {
	      if (returnCloneOrEmpty) {
	        return (this.styles[lineIndex] && this.styles[lineIndex][charIndex])
	          ? clone(this.styles[lineIndex][charIndex])
	          : { };
	      }
	
	      return this.styles[lineIndex] && this.styles[lineIndex][charIndex] ? this.styles[lineIndex][charIndex] : null;
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @param {Number} charIndex
	     * @param {Object} style
	     * @private
	     */
	    _setStyleDeclaration: function(lineIndex, charIndex, style) {
	      this.styles[lineIndex][charIndex] = style;
	    },
	
	    /**
	     *
	     * @param {Number} lineIndex
	     * @param {Number} charIndex
	     * @private
	     */
	    _deleteStyleDeclaration: function(lineIndex, charIndex) {
	      delete this.styles[lineIndex][charIndex];
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @private
	     */
	    _getLineStyle: function(lineIndex) {
	      return this.styles[lineIndex];
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @param {Object} style
	     * @private
	     */
	    _setLineStyle: function(lineIndex, style) {
	      this.styles[lineIndex] = style;
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @private
	     */
	    _deleteLineStyle: function(lineIndex) {
	      delete this.styles[lineIndex];
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _getWidthOfChar: function(ctx, _char, lineIndex, charIndex) {
	      if (!this._isMeasuring && this.textAlign === 'justify' && this._reSpacesAndTabs.test(_char)) {
	        return this._getWidthOfSpace(ctx, lineIndex);
	      }
	      ctx.save();
	      var width = this._applyCharStylesGetWidth(ctx, _char, lineIndex, charIndex);
	      if (this.charSpacing !== 0) {
	        width += this._getWidthOfCharSpacing();
	      }
	      ctx.restore();
	      return width > 0 ? width : 0
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Number} lineIndex
	     * @param {Number} charIndex
	     */
	    _getHeightOfChar: function(ctx, lineIndex, charIndex) {
	      var style = this._getStyleDeclaration(lineIndex, charIndex);
	      return style && style.fontSize ? style.fontSize : this.fontSize;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Number} lineIndex
	     * @param {Number} charIndex
	     */
	    _getWidthOfCharsAt: function(ctx, lineIndex, charIndex) {
	      var width = 0, i, _char;
	      for (i = 0; i < charIndex; i++) {
	        _char = this._textLines[lineIndex][i];
	        width += this._getWidthOfChar(ctx, _char, lineIndex, i);
	      }
	      return width;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Number} lineIndex line number
	     * @return {Number} Line width
	     */
	    _measureLine: function(ctx, lineIndex) {
	      this._isMeasuring = true;
	      var width = this._getWidthOfCharsAt(ctx, lineIndex, this._textLines[lineIndex].length);
	      if (this.charSpacing !== 0) {
	        width -= this._getWidthOfCharSpacing();
	      }
	      this._isMeasuring = false;
	      return width > 0 ? width : 0;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Number} lineIndex
	     */
	    _getWidthOfSpace: function (ctx, lineIndex) {
	      if (this.__widthOfSpace[lineIndex]) {
	        return this.__widthOfSpace[lineIndex];
	      }
	      var line = this._textLines[lineIndex],
	          wordsWidth = this._getWidthOfWords(ctx, line, lineIndex, 0),
	          widthDiff = this.width - wordsWidth,
	          numSpaces = line.length - line.replace(this._reSpacesAndTabs, '').length,
	          width = Math.max(widthDiff / numSpaces, ctx.measureText(' ').width);
	      this.__widthOfSpace[lineIndex] = width;
	      return width;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {String} line
	     * @param {Number} lineIndex
	     * @param {Number} charOffset
	     */
	    _getWidthOfWords: function (ctx, line, lineIndex, charOffset) {
	      var width = 0;
	
	      for (var charIndex = 0; charIndex < line.length; charIndex++) {
	        var _char = line[charIndex];
	
	        if (!_char.match(/\s/)) {
	          width += this._getWidthOfChar(ctx, _char, lineIndex, charIndex + charOffset);
	        }
	      }
	
	      return width;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _getHeightOfLine: function(ctx, lineIndex) {
	      if (this.__lineHeights[lineIndex]) {
	        return this.__lineHeights[lineIndex];
	      }
	
	      var line = this._textLines[lineIndex],
	          maxHeight = this._getHeightOfChar(ctx, lineIndex, 0);
	
	      for (var i = 1, len = line.length; i < len; i++) {
	        var currentCharHeight = this._getHeightOfChar(ctx, lineIndex, i);
	        if (currentCharHeight > maxHeight) {
	          maxHeight = currentCharHeight;
	        }
	      }
	      this.__lineHeights[lineIndex] = maxHeight * this.lineHeight * this._fontSizeMult;
	      return this.__lineHeights[lineIndex];
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _getTextHeight: function(ctx) {
	      var lineHeight, height = 0;
	      for (var i = 0, len = this._textLines.length; i < len; i++) {
	        lineHeight = this._getHeightOfLine(ctx, i);
	        height += (i === len - 1 ? lineHeight / this.lineHeight : lineHeight);
	      }
	      return height;
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @method toObject
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      var clonedStyles = { }, i, j, row;
	      for (i in this.styles) {
	        row = this.styles[i];
	        clonedStyles[i] = { };
	        for (j in row) {
	          clonedStyles[i][j] = clone(row[j]);
	        }
	      }
	      return fabric.util.object.extend(this.callSuper('toObject', propertiesToInclude), {
	        styles: clonedStyles
	      });
	    }
	  });
	
	  /**
	   * Returns fabric.IText instance from an object representation
	   * @static
	   * @memberOf fabric.IText
	   * @param {Object} object Object to create an instance from
	   * @param {function} [callback] invoked with new instance as argument
	   * @return {fabric.IText} instance of fabric.IText
	   */
	  fabric.IText.fromObject = function(object, callback) {
	    var iText = new fabric.IText(object.text, clone(object));
	    callback && callback(iText);
	    return iText;
	  };
	})();
	
	
	(function() {
	
	  var clone = fabric.util.object.clone;
	
	  fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {
	
	    /**
	     * Initializes all the interactive behavior of IText
	     */
	    initBehavior: function() {
	      this.initAddedHandler();
	      this.initRemovedHandler();
	      this.initCursorSelectionHandlers();
	      this.initDoubleClickSimulation();
	      this.mouseMoveHandler = this.mouseMoveHandler.bind(this);
	    },
	
	    /**
	     * Initializes "selected" event handler
	     */
	    initSelectedHandler: function() {
	      this.on('selected', function() {
	
	        var _this = this;
	        setTimeout(function() {
	          _this.selected = true;
	        }, 100);
	      });
	    },
	
	    /**
	     * Initializes "added" event handler
	     */
	    initAddedHandler: function() {
	      var _this = this;
	      this.on('added', function() {
	        var canvas = _this.canvas;
	        if (canvas) {
	          if (!canvas._hasITextHandlers) {
	            canvas._hasITextHandlers = true;
	            _this._initCanvasHandlers(canvas);
	          }
	          canvas._iTextInstances = canvas._iTextInstances || [];
	          canvas._iTextInstances.push(_this);
	        }
	      });
	    },
	
	    initRemovedHandler: function() {
	      var _this = this;
	      this.on('removed', function() {
	        var canvas = _this.canvas;
	        if (canvas) {
	          canvas._iTextInstances = canvas._iTextInstances || [];
	          fabric.util.removeFromArray(canvas._iTextInstances, _this);
	          if (canvas._iTextInstances.length === 0) {
	            canvas._hasITextHandlers = false;
	            _this._removeCanvasHandlers(canvas);
	          }
	        }
	      });
	    },
	
	    /**
	     * register canvas event to manage exiting on other instances
	     * @private
	     */
	    _initCanvasHandlers: function(canvas) {
	      canvas._canvasITextSelectionClearedHanlder = (function() {
	        fabric.IText.prototype.exitEditingOnOthers(canvas);
	      }).bind(this);
	      canvas._mouseUpITextHandler = (function() {
	        if (canvas._iTextInstances) {
	          canvas._iTextInstances.forEach(function(obj) {
	            obj.__isMousedown = false;
	          });
	        }
	      }).bind(this);
	      canvas.on('selection:cleared', canvas._canvasITextSelectionClearedHanlder);
	      canvas.on('object:selected', canvas._canvasITextSelectionClearedHanlder);
	      canvas.on('mouse:up', canvas._mouseUpITextHandler);
	    },
	
	    /**
	     * remove canvas event to manage exiting on other instances
	     * @private
	     */
	    _removeCanvasHandlers: function(canvas) {
	      canvas.off('selection:cleared', canvas._canvasITextSelectionClearedHanlder);
	      canvas.off('object:selected', canvas._canvasITextSelectionClearedHanlder);
	      canvas.off('mouse:up', canvas._mouseUpITextHandler);
	    },
	
	    /**
	     * @private
	     */
	    _tick: function() {
	      this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, '_onTickComplete');
	    },
	
	    /**
	     * @private
	     */
	    _animateCursor: function(obj, targetOpacity, duration, completeMethod) {
	
	      var tickState;
	
	      tickState = {
	        isAborted: false,
	        abort: function() {
	          this.isAborted = true;
	        },
	      };
	
	      obj.animate('_currentCursorOpacity', targetOpacity, {
	        duration: duration,
	        onComplete: function() {
	          if (!tickState.isAborted) {
	            obj[completeMethod]();
	          }
	        },
	        onChange: function() {
	          // we do not want to animate a selection, only cursor
	          if (obj.canvas && obj.selectionStart === obj.selectionEnd) {
	            obj.renderCursorOrSelection();
	          }
	        },
	        abort: function() {
	          return tickState.isAborted;
	        }
	      });
	      return tickState;
	    },
	
	    /**
	     * @private
	     */
	    _onTickComplete: function() {
	
	      var _this = this;
	
	      if (this._cursorTimeout1) {
	        clearTimeout(this._cursorTimeout1);
	      }
	      this._cursorTimeout1 = setTimeout(function() {
	        _this._currentTickCompleteState = _this._animateCursor(_this, 0, this.cursorDuration / 2, '_tick');
	      }, 100);
	    },
	
	    /**
	     * Initializes delayed cursor
	     */
	    initDelayedCursor: function(restart) {
	      var _this = this,
	          delay = restart ? 0 : this.cursorDelay;
	
	      this.abortCursorAnimation();
	      this._currentCursorOpacity = 1;
	      this._cursorTimeout2 = setTimeout(function() {
	        _this._tick();
	      }, delay);
	    },
	
	    /**
	     * Aborts cursor animation and clears all timeouts
	     */
	    abortCursorAnimation: function() {
	      var shouldClear = this._currentTickState || this._currentTickCompleteState;
	      this._currentTickState && this._currentTickState.abort();
	      this._currentTickCompleteState && this._currentTickCompleteState.abort();
	
	      clearTimeout(this._cursorTimeout1);
	      clearTimeout(this._cursorTimeout2);
	
	      this._currentCursorOpacity = 0;
	      // to clear just itext area we need to transform the context
	      // it may not be worth it
	      if (shouldClear) {
	        this.canvas && this.canvas.clearContext(this.canvas.contextTop || this.ctx);
	      }
	
	    },
	
	    /**
	     * Selects entire text
	     */
	    selectAll: function() {
	      this.selectionStart = 0;
	      this.selectionEnd = this.text.length;
	      this._fireSelectionChanged();
	      this._updateTextarea();
	    },
	
	    /**
	     * Returns selected text
	     * @return {String}
	     */
	    getSelectedText: function() {
	      return this.text.slice(this.selectionStart, this.selectionEnd);
	    },
	
	    /**
	     * Find new selection index representing start of current word according to current selection index
	     * @param {Number} startFrom Surrent selection index
	     * @return {Number} New selection index
	     */
	    findWordBoundaryLeft: function(startFrom) {
	      var offset = 0, index = startFrom - 1;
	
	      // remove space before cursor first
	      if (this._reSpace.test(this.text.charAt(index))) {
	        while (this._reSpace.test(this.text.charAt(index))) {
	          offset++;
	          index--;
	        }
	      }
	      while (/\S/.test(this.text.charAt(index)) && index > -1) {
	        offset++;
	        index--;
	      }
	
	      return startFrom - offset;
	    },
	
	    /**
	     * Find new selection index representing end of current word according to current selection index
	     * @param {Number} startFrom Current selection index
	     * @return {Number} New selection index
	     */
	    findWordBoundaryRight: function(startFrom) {
	      var offset = 0, index = startFrom;
	
	      // remove space after cursor first
	      if (this._reSpace.test(this.text.charAt(index))) {
	        while (this._reSpace.test(this.text.charAt(index))) {
	          offset++;
	          index++;
	        }
	      }
	      while (/\S/.test(this.text.charAt(index)) && index < this.text.length) {
	        offset++;
	        index++;
	      }
	
	      return startFrom + offset;
	    },
	
	    /**
	     * Find new selection index representing start of current line according to current selection index
	     * @param {Number} startFrom Current selection index
	     * @return {Number} New selection index
	     */
	    findLineBoundaryLeft: function(startFrom) {
	      var offset = 0, index = startFrom - 1;
	
	      while (!/\n/.test(this.text.charAt(index)) && index > -1) {
	        offset++;
	        index--;
	      }
	
	      return startFrom - offset;
	    },
	
	    /**
	     * Find new selection index representing end of current line according to current selection index
	     * @param {Number} startFrom Current selection index
	     * @return {Number} New selection index
	     */
	    findLineBoundaryRight: function(startFrom) {
	      var offset = 0, index = startFrom;
	
	      while (!/\n/.test(this.text.charAt(index)) && index < this.text.length) {
	        offset++;
	        index++;
	      }
	
	      return startFrom + offset;
	    },
	
	    /**
	     * Returns number of newlines in selected text
	     * @return {Number} Number of newlines in selected text
	     */
	    getNumNewLinesInSelectedText: function() {
	      var selectedText = this.getSelectedText(),
	          numNewLines  = 0;
	
	      for (var i = 0, len = selectedText.length; i < len; i++) {
	        if (selectedText[i] === '\n') {
	          numNewLines++;
	        }
	      }
	      return numNewLines;
	    },
	
	    /**
	     * Finds index corresponding to beginning or end of a word
	     * @param {Number} selectionStart Index of a character
	     * @param {Number} direction 1 or -1
	     * @return {Number} Index of the beginning or end of a word
	     */
	    searchWordBoundary: function(selectionStart, direction) {
	      var index     = this._reSpace.test(this.text.charAt(selectionStart)) ? selectionStart - 1 : selectionStart,
	          _char     = this.text.charAt(index),
	          reNonWord = /[ \n\.,;!\?\-]/;
	
	      while (!reNonWord.test(_char) && index > 0 && index < this.text.length) {
	        index += direction;
	        _char = this.text.charAt(index);
	      }
	      if (reNonWord.test(_char) && _char !== '\n') {
	        index += direction === 1 ? 0 : 1;
	      }
	      return index;
	    },
	
	    /**
	     * Selects a word based on the index
	     * @param {Number} selectionStart Index of a character
	     */
	    selectWord: function(selectionStart) {
	      selectionStart = selectionStart || this.selectionStart;
	      var newSelectionStart = this.searchWordBoundary(selectionStart, -1), /* search backwards */
	          newSelectionEnd = this.searchWordBoundary(selectionStart, 1); /* search forward */
	
	      this.selectionStart = newSelectionStart;
	      this.selectionEnd = newSelectionEnd;
	      this._fireSelectionChanged();
	      this._updateTextarea();
	      this.renderCursorOrSelection();
	    },
	
	    /**
	     * Selects a line based on the index
	     * @param {Number} selectionStart Index of a character
	     */
	    selectLine: function(selectionStart) {
	      selectionStart = selectionStart || this.selectionStart;
	      var newSelectionStart = this.findLineBoundaryLeft(selectionStart),
	          newSelectionEnd = this.findLineBoundaryRight(selectionStart);
	
	      this.selectionStart = newSelectionStart;
	      this.selectionEnd = newSelectionEnd;
	      this._fireSelectionChanged();
	      this._updateTextarea();
	    },
	
	    /**
	     * Enters editing state
	     * @return {fabric.IText} thisArg
	     * @chainable
	     */
	    enterEditing: function(e) {
	      if (this.isEditing || !this.editable) {
	        return;
	      }
	
	      if (this.canvas) {
	        this.exitEditingOnOthers(this.canvas);
	      }
	
	      this.isEditing = true;
	
	      this.initHiddenTextarea(e);
	      this.hiddenTextarea.focus();
	      this._updateTextarea();
	      this._saveEditingProps();
	      this._setEditingProps();
	      this._textBeforeEdit = this.text;
	
	      this._tick();
	      this.fire('editing:entered');
	
	      if (!this.canvas) {
	        return this;
	      }
	      this.canvas.fire('text:editing:entered', { target: this });
	      this.initMouseMoveHandler();
	      this.canvas.renderAll();
	      return this;
	    },
	
	    exitEditingOnOthers: function(canvas) {
	      if (canvas._iTextInstances) {
	        canvas._iTextInstances.forEach(function(obj) {
	          obj.selected = false;
	          if (obj.isEditing) {
	            obj.exitEditing();
	          }
	        });
	      }
	    },
	
	    /**
	     * Initializes "mousemove" event handler
	     */
	    initMouseMoveHandler: function() {
	      this.canvas.on('mouse:move', this.mouseMoveHandler);
	    },
	
	    /**
	     * @private
	     */
	    mouseMoveHandler: function(options) {
	      if (!this.__isMousedown || !this.isEditing) {
	        return;
	      }
	
	      var newSelectionStart = this.getSelectionStartFromPointer(options.e),
	          currentStart = this.selectionStart,
	          currentEnd = this.selectionEnd;
	      if (newSelectionStart === this.__selectionStartOnMouseDown) {
	        return;
	      }
	      if (newSelectionStart > this.__selectionStartOnMouseDown) {
	        this.selectionStart = this.__selectionStartOnMouseDown;
	        this.selectionEnd = newSelectionStart;
	      }
	      else {
	        this.selectionStart = newSelectionStart;
	        this.selectionEnd = this.__selectionStartOnMouseDown;
	      }
	      if (this.selectionStart !== currentStart || this.selectionEnd !== currentEnd) {
	        this._fireSelectionChanged();
	        this._updateTextarea();
	        this.renderCursorOrSelection();
	      }
	    },
	
	    /**
	     * @private
	     */
	    _setEditingProps: function() {
	      this.hoverCursor = 'text';
	
	      if (this.canvas) {
	        this.canvas.defaultCursor = this.canvas.moveCursor = 'text';
	      }
	
	      this.borderColor = this.editingBorderColor;
	
	      this.hasControls = this.selectable = false;
	      this.lockMovementX = this.lockMovementY = true;
	    },
	
	    /**
	     * @private
	     */
	    _updateTextarea: function() {
	      if (!this.hiddenTextarea || this.inCompositionMode) {
	        return;
	      }
	      this.cursorOffsetCache = { };
	      this.hiddenTextarea.value = this.text;
	      this.hiddenTextarea.selectionStart = this.selectionStart;
	      this.hiddenTextarea.selectionEnd = this.selectionEnd;
	      if (this.selectionStart === this.selectionEnd) {
	        var style = this._calcTextareaPosition();
	        this.hiddenTextarea.style.left = style.left;
	        this.hiddenTextarea.style.top = style.top;
	        this.hiddenTextarea.style.fontSize = style.fontSize;
	      }
	    },
	
	    /**
	     * @private
	     * @return {Object} style contains style for hiddenTextarea
	     */
	    _calcTextareaPosition: function() {
	      if (!this.canvas) {
	        return { x: 1, y: 1 };
	      }
	      var chars = this.text.split(''),
	          boundaries = this._getCursorBoundaries(chars, 'cursor'),
	          cursorLocation = this.get2DCursorLocation(),
	          lineIndex = cursorLocation.lineIndex,
	          charIndex = cursorLocation.charIndex,
	          charHeight = this.getCurrentCharFontSize(lineIndex, charIndex),
	          leftOffset = (lineIndex === 0 && charIndex === 0)
	                    ? this._getLineLeftOffset(this._getLineWidth(this.ctx, lineIndex))
	                    : boundaries.leftOffset,
	          m = this.calcTransformMatrix(),
	          p = {
	            x: boundaries.left + leftOffset,
	            y: boundaries.top + boundaries.topOffset + charHeight
	          },
	          upperCanvas = this.canvas.upperCanvasEl,
	          maxWidth = upperCanvas.width - charHeight,
	          maxHeight = upperCanvas.height - charHeight;
	
	      p = fabric.util.transformPoint(p, m);
	      p = fabric.util.transformPoint(p, this.canvas.viewportTransform);
	
	      if (p.x < 0) {
	        p.x = 0;
	      }
	      if (p.x > maxWidth) {
	        p.x = maxWidth;
	      }
	      if (p.y < 0) {
	        p.y = 0;
	      }
	      if (p.y > maxHeight) {
	        p.y = maxHeight;
	      }
	
	      // add canvas offset on document
	      p.x += this.canvas._offset.left;
	      p.y += this.canvas._offset.top;
	
	      return { left: p.x + 'px', top: p.y + 'px', fontSize: charHeight };
	    },
	
	    /**
	     * @private
	     */
	    _saveEditingProps: function() {
	      this._savedProps = {
	        hasControls: this.hasControls,
	        borderColor: this.borderColor,
	        lockMovementX: this.lockMovementX,
	        lockMovementY: this.lockMovementY,
	        hoverCursor: this.hoverCursor,
	        defaultCursor: this.canvas && this.canvas.defaultCursor,
	        moveCursor: this.canvas && this.canvas.moveCursor
	      };
	    },
	
	    /**
	     * @private
	     */
	    _restoreEditingProps: function() {
	      if (!this._savedProps) {
	        return;
	      }
	
	      this.hoverCursor = this._savedProps.overCursor;
	      this.hasControls = this._savedProps.hasControls;
	      this.borderColor = this._savedProps.borderColor;
	      this.lockMovementX = this._savedProps.lockMovementX;
	      this.lockMovementY = this._savedProps.lockMovementY;
	
	      if (this.canvas) {
	        this.canvas.defaultCursor = this._savedProps.defaultCursor;
	        this.canvas.moveCursor = this._savedProps.moveCursor;
	      }
	    },
	
	    /**
	     * Exits from editing state
	     * @return {fabric.IText} thisArg
	     * @chainable
	     */
	    exitEditing: function() {
	      var isTextChanged = (this._textBeforeEdit !== this.text);
	      this.selected = false;
	      this.isEditing = false;
	      this.selectable = true;
	
	      this.selectionEnd = this.selectionStart;
	      this.hiddenTextarea && this.canvas && this.hiddenTextarea.parentNode.removeChild(this.hiddenTextarea);
	      this.hiddenTextarea = null;
	
	      this.abortCursorAnimation();
	      this._restoreEditingProps();
	      this._currentCursorOpacity = 0;
	
	      this.fire('editing:exited');
	      isTextChanged && this.fire('modified');
	      if (this.canvas) {
	        this.canvas.off('mouse:move', this.mouseMoveHandler);
	        this.canvas.fire('text:editing:exited', { target: this });
	        isTextChanged && this.canvas.fire('object:modified', { target: this });
	      }
	
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _removeExtraneousStyles: function() {
	      for (var prop in this.styles) {
	        if (!this._textLines[prop]) {
	          delete this.styles[prop];
	        }
	      }
	    },
	
	    /**
	     * @private
	     */
	    _removeCharsFromTo: function(start, end) {
	      while (end !== start) {
	        this._removeSingleCharAndStyle(start + 1);
	        end--;
	      }
	      this.selectionStart = start;
	      this.selectionEnd = start;
	    },
	
	    _removeSingleCharAndStyle: function(index) {
	      var isBeginningOfLine = this.text[index - 1] === '\n',
	          indexStyle        = isBeginningOfLine ? index : index - 1;
	      this.removeStyleObject(isBeginningOfLine, indexStyle);
	      this.text = this.text.slice(0, index - 1) +
	        this.text.slice(index);
	
	      this._textLines = this._splitTextIntoLines();
	    },
	
	    /**
	     * Inserts characters where cursor is (replacing selection if one exists)
	     * @param {String} _chars Characters to insert
	     * @param {Boolean} useCopiedStyle use fabric.copiedTextStyle
	     */
	    insertChars: function(_chars, useCopiedStyle) {
	      var style;
	
	      if (this.selectionEnd - this.selectionStart > 1) {
	        this._removeCharsFromTo(this.selectionStart, this.selectionEnd);
	      }
	      //short circuit for block paste
	      if (!useCopiedStyle && this.isEmptyStyles()) {
	        this.insertChar(_chars, false);
	        return;
	      }
	      for (var i = 0, len = _chars.length; i < len; i++) {
	        if (useCopiedStyle) {
	          style = fabric.copiedTextStyle[i];
	        }
	        this.insertChar(_chars[i], i < len - 1, style);
	      }
	    },
	
	    /**
	     * Inserts a character where cursor is
	     * @param {String} _char Characters to insert
	     * @param {Boolean} skipUpdate trigger rendering and updates at the end of text insert
	     * @param {Object} styleObject Style to be inserted for the new char
	     */
	    insertChar: function(_char, skipUpdate, styleObject) {
	      var isEndOfLine = this.text[this.selectionStart] === '\n';
	      this.text = this.text.slice(0, this.selectionStart) +
	        _char + this.text.slice(this.selectionEnd);
	      this._textLines = this._splitTextIntoLines();
	      this.insertStyleObjects(_char, isEndOfLine, styleObject);
	      this.selectionStart += _char.length;
	      this.selectionEnd = this.selectionStart;
	      if (skipUpdate) {
	        return;
	      }
	      this._updateTextarea();
	      this.setCoords();
	      this._fireSelectionChanged();
	      this.fire('changed');
	      this.canvas && this.canvas.fire('text:changed', { target: this });
	      this.canvas && this.canvas.renderAll();
	    },
	
	    /**
	     * Inserts new style object
	     * @param {Number} lineIndex Index of a line
	     * @param {Number} charIndex Index of a char
	     * @param {Boolean} isEndOfLine True if it's end of line
	     */
	    insertNewlineStyleObject: function(lineIndex, charIndex, isEndOfLine) {
	
	      this.shiftLineStyles(lineIndex, +1);
	
	      if (!this.styles[lineIndex + 1]) {
	        this.styles[lineIndex + 1] = {};
	      }
	
	      var currentCharStyle = {},
	          newLineStyles    = {};
	
	      if (this.styles[lineIndex] && this.styles[lineIndex][charIndex - 1]) {
	        currentCharStyle = this.styles[lineIndex][charIndex - 1];
	      }
	
	      // if there's nothing after cursor,
	      // we clone current char style onto the next (otherwise empty) line
	      if (isEndOfLine) {
	        newLineStyles[0] = clone(currentCharStyle);
	        this.styles[lineIndex + 1] = newLineStyles;
	      }
	      // otherwise we clone styles of all chars
	      // after cursor onto the next line, from the beginning
	      else {
	        for (var index in this.styles[lineIndex]) {
	          if (parseInt(index, 10) >= charIndex) {
	            newLineStyles[parseInt(index, 10) - charIndex] = this.styles[lineIndex][index];
	            // remove lines from the previous line since they're on a new line now
	            delete this.styles[lineIndex][index];
	          }
	        }
	        this.styles[lineIndex + 1] = newLineStyles;
	      }
	      this._forceClearCache = true;
	    },
	
	    /**
	     * Inserts style object for a given line/char index
	     * @param {Number} lineIndex Index of a line
	     * @param {Number} charIndex Index of a char
	     * @param {Object} [style] Style object to insert, if given
	     */
	    insertCharStyleObject: function(lineIndex, charIndex, style) {
	
	      var currentLineStyles       = this.styles[lineIndex],
	          currentLineStylesCloned = clone(currentLineStyles);
	
	      if (charIndex === 0 && !style) {
	        charIndex = 1;
	      }
	
	      // shift all char styles by 1 forward
	      // 0,1,2,3 -> (charIndex=2) -> 0,1,3,4 -> (insert 2) -> 0,1,2,3,4
	      for (var index in currentLineStylesCloned) {
	        var numericIndex = parseInt(index, 10);
	
	        if (numericIndex >= charIndex) {
	          currentLineStyles[numericIndex + 1] = currentLineStylesCloned[numericIndex];
	
	          // only delete the style if there was nothing moved there
	          if (!currentLineStylesCloned[numericIndex - 1]) {
	            delete currentLineStyles[numericIndex];
	          }
	        }
	      }
	
	      this.styles[lineIndex][charIndex] =
	        style || clone(currentLineStyles[charIndex - 1]);
	      this._forceClearCache = true;
	    },
	
	    /**
	     * Inserts style object(s)
	     * @param {String} _chars Characters at the location where style is inserted
	     * @param {Boolean} isEndOfLine True if it's end of line
	     * @param {Object} [styleObject] Style to insert
	     */
	    insertStyleObjects: function(_chars, isEndOfLine, styleObject) {
	      // removed shortcircuit over isEmptyStyles
	
	      var cursorLocation = this.get2DCursorLocation(),
	          lineIndex      = cursorLocation.lineIndex,
	          charIndex      = cursorLocation.charIndex;
	
	      if (!this._getLineStyle(lineIndex)) {
	        this._setLineStyle(lineIndex, {});
	      }
	
	      if (_chars === '\n') {
	        this.insertNewlineStyleObject(lineIndex, charIndex, isEndOfLine);
	      }
	      else {
	        this.insertCharStyleObject(lineIndex, charIndex, styleObject);
	      }
	    },
	
	    /**
	     * Shifts line styles up or down
	     * @param {Number} lineIndex Index of a line
	     * @param {Number} offset Can be -1 or +1
	     */
	    shiftLineStyles: function(lineIndex, offset) {
	      // shift all line styles by 1 upward
	      var clonedStyles = clone(this.styles);
	      for (var line in this.styles) {
	        var numericLine = parseInt(line, 10);
	        if (numericLine > lineIndex) {
	          this.styles[numericLine + offset] = clonedStyles[numericLine];
	          if (!clonedStyles[numericLine - offset]) {
	            delete this.styles[numericLine];
	          }
	        }
	      }
	      //TODO: evaluate if delete old style lines with offset -1
	    },
	
	    /**
	     * Removes style object
	     * @param {Boolean} isBeginningOfLine True if cursor is at the beginning of line
	     * @param {Number} [index] Optional index. When not given, current selectionStart is used.
	     */
	    removeStyleObject: function(isBeginningOfLine, index) {
	
	      var cursorLocation = this.get2DCursorLocation(index),
	          lineIndex      = cursorLocation.lineIndex,
	          charIndex      = cursorLocation.charIndex;
	
	      this._removeStyleObject(isBeginningOfLine, cursorLocation, lineIndex, charIndex);
	    },
	
	    _getTextOnPreviousLine: function(lIndex) {
	      return this._textLines[lIndex - 1];
	    },
	
	    _removeStyleObject: function(isBeginningOfLine, cursorLocation, lineIndex, charIndex) {
	
	      if (isBeginningOfLine) {
	        var textOnPreviousLine     = this._getTextOnPreviousLine(cursorLocation.lineIndex),
	            newCharIndexOnPrevLine = textOnPreviousLine ? textOnPreviousLine.length : 0;
	
	        if (!this.styles[lineIndex - 1]) {
	          this.styles[lineIndex - 1] = {};
	        }
	        for (charIndex in this.styles[lineIndex]) {
	          this.styles[lineIndex - 1][parseInt(charIndex, 10) + newCharIndexOnPrevLine]
	            = this.styles[lineIndex][charIndex];
	        }
	        this.shiftLineStyles(cursorLocation.lineIndex, -1);
	      }
	      else {
	        var currentLineStyles = this.styles[lineIndex];
	
	        if (currentLineStyles) {
	          delete currentLineStyles[charIndex];
	        }
	        var currentLineStylesCloned = clone(currentLineStyles);
	        // shift all styles by 1 backwards
	        for (var i in currentLineStylesCloned) {
	          var numericIndex = parseInt(i, 10);
	          if (numericIndex >= charIndex && numericIndex !== 0) {
	            currentLineStyles[numericIndex - 1] = currentLineStylesCloned[numericIndex];
	            delete currentLineStyles[numericIndex];
	          }
	        }
	      }
	    },
	
	    /**
	     * Inserts new line
	     */
	    insertNewline: function() {
	      this.insertChars('\n');
	    },
	
	    /**
	     * Set the selectionStart and selectionEnd according to the ne postion of cursor
	     * mimic the key - mouse navigation when shift is pressed.
	     */
	    setSelectionStartEndWithShift: function(start, end, newSelection) {
	      if (newSelection <= start) {
	        if (end === start) {
	          this._selectionDirection = 'left';
	        }
	        else if (this._selectionDirection === 'right') {
	          this._selectionDirection = 'left';
	          this.selectionEnd = start;
	        }
	        this.selectionStart = newSelection;
	      }
	      else if (newSelection > start && newSelection < end) {
	        if (this._selectionDirection === 'right') {
	          this.selectionEnd = newSelection;
	        }
	        else {
	          this.selectionStart = newSelection;
	        }
	      }
	      else {
	        // newSelection is > selection start and end
	        if (end === start) {
	          this._selectionDirection = 'right';
	        }
	        else if (this._selectionDirection === 'left') {
	          this._selectionDirection = 'right';
	          this.selectionStart = end;
	        }
	        this.selectionEnd = newSelection;
	      }
	    },
	
	    setSelectionInBoundaries: function() {
	      var length = this.text.length;
	      if (this.selectionStart > length) {
	        this.selectionStart = length;
	      }
	      else if (this.selectionStart < 0) {
	        this.selectionStart = 0;
	      }
	      if (this.selectionEnd > length) {
	        this.selectionEnd = length;
	      }
	      else if (this.selectionEnd < 0) {
	        this.selectionEnd = 0;
	      }
	    }
	  });
	})();
	
	
	fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {
	  /**
	   * Initializes "dbclick" event handler
	   */
	  initDoubleClickSimulation: function() {
	
	    // for double click
	    this.__lastClickTime = +new Date();
	
	    // for triple click
	    this.__lastLastClickTime = +new Date();
	
	    this.__lastPointer = { };
	
	    this.on('mousedown', this.onMouseDown.bind(this));
	  },
	
	  onMouseDown: function(options) {
	
	    this.__newClickTime = +new Date();
	    var newPointer = this.canvas.getPointer(options.e);
	
	    if (this.isTripleClick(newPointer)) {
	      this.fire('tripleclick', options);
	      this._stopEvent(options.e);
	    }
	    else if (this.isDoubleClick(newPointer)) {
	      this.fire('dblclick', options);
	      this._stopEvent(options.e);
	    }
	
	    this.__lastLastClickTime = this.__lastClickTime;
	    this.__lastClickTime = this.__newClickTime;
	    this.__lastPointer = newPointer;
	    this.__lastIsEditing = this.isEditing;
	    this.__lastSelected = this.selected;
	  },
	
	  isDoubleClick: function(newPointer) {
	    return this.__newClickTime - this.__lastClickTime < 500 &&
	        this.__lastPointer.x === newPointer.x &&
	        this.__lastPointer.y === newPointer.y && this.__lastIsEditing;
	  },
	
	  isTripleClick: function(newPointer) {
	    return this.__newClickTime - this.__lastClickTime < 500 &&
	        this.__lastClickTime - this.__lastLastClickTime < 500 &&
	        this.__lastPointer.x === newPointer.x &&
	        this.__lastPointer.y === newPointer.y;
	  },
	
	  /**
	   * @private
	   */
	  _stopEvent: function(e) {
	    e.preventDefault && e.preventDefault();
	    e.stopPropagation && e.stopPropagation();
	  },
	
	  /**
	   * Initializes event handlers related to cursor or selection
	   */
	  initCursorSelectionHandlers: function() {
	    this.initSelectedHandler();
	    this.initMousedownHandler();
	    this.initMouseupHandler();
	    this.initClicks();
	  },
	
	  /**
	   * Initializes double and triple click event handlers
	   */
	  initClicks: function() {
	    this.on('dblclick', function(options) {
	      this.selectWord(this.getSelectionStartFromPointer(options.e));
	    });
	    this.on('tripleclick', function(options) {
	      this.selectLine(this.getSelectionStartFromPointer(options.e));
	    });
	  },
	
	  /**
	   * Initializes "mousedown" event handler
	   */
	  initMousedownHandler: function() {
	    this.on('mousedown', function(options) {
	      if (!this.editable) {
	        return;
	      }
	      var pointer = this.canvas.getPointer(options.e);
	
	      this.__mousedownX = pointer.x;
	      this.__mousedownY = pointer.y;
	      this.__isMousedown = true;
	
	      if (this.selected) {
	        this.setCursorByClick(options.e);
	      }
	
	      if (this.isEditing) {
	        this.__selectionStartOnMouseDown = this.selectionStart;
	        if (this.selectionStart === this.selectionEnd) {
	          this.abortCursorAnimation();
	        }
	        this.renderCursorOrSelection();
	      }
	    });
	  },
	
	  /**
	   * @private
	   */
	  _isObjectMoved: function(e) {
	    var pointer = this.canvas.getPointer(e);
	
	    return this.__mousedownX !== pointer.x ||
	           this.__mousedownY !== pointer.y;
	  },
	
	  /**
	   * Initializes "mouseup" event handler
	   */
	  initMouseupHandler: function() {
	    this.on('mouseup', function(options) {
	      this.__isMousedown = false;
	      if (!this.editable || this._isObjectMoved(options.e)) {
	        return;
	      }
	
	      if (this.__lastSelected && !this.__corner) {
	        this.enterEditing(options.e);
	        if (this.selectionStart === this.selectionEnd) {
	          this.initDelayedCursor(true);
	        }
	        else {
	          this.renderCursorOrSelection();
	        }
	      }
	      this.selected = true;
	    });
	  },
	
	  /**
	   * Changes cursor location in a text depending on passed pointer (x/y) object
	   * @param {Event} e Event object
	   */
	  setCursorByClick: function(e) {
	    var newSelection = this.getSelectionStartFromPointer(e),
	        start = this.selectionStart, end = this.selectionEnd;
	    if (e.shiftKey) {
	      this.setSelectionStartEndWithShift(start, end, newSelection);
	    }
	    else {
	      this.selectionStart = newSelection;
	      this.selectionEnd = newSelection;
	    }
	    this._fireSelectionChanged();
	    this._updateTextarea();
	  },
	
	  /**
	   * Returns index of a character corresponding to where an object was clicked
	   * @param {Event} e Event object
	   * @return {Number} Index of a character
	   */
	  getSelectionStartFromPointer: function(e) {
	    var mouseOffset = this.getLocalPointer(e),
	        prevWidth = 0,
	        width = 0,
	        height = 0,
	        charIndex = 0,
	        newSelectionStart,
	        line;
	
	    for (var i = 0, len = this._textLines.length; i < len; i++) {
	      line = this._textLines[i];
	      height += this._getHeightOfLine(this.ctx, i) * this.scaleY;
	
	      var widthOfLine = this._getLineWidth(this.ctx, i),
	          lineLeftOffset = this._getLineLeftOffset(widthOfLine);
	
	      width = lineLeftOffset * this.scaleX;
	
	      for (var j = 0, jlen = line.length; j < jlen; j++) {
	
	        prevWidth = width;
	
	        width += this._getWidthOfChar(this.ctx, line[j], i, this.flipX ? jlen - j : j) *
	                 this.scaleX;
	
	        if (height <= mouseOffset.y || width <= mouseOffset.x) {
	          charIndex++;
	          continue;
	        }
	
	        return this._getNewSelectionStartFromOffset(
	          mouseOffset, prevWidth, width, charIndex + i, jlen);
	      }
	
	      if (mouseOffset.y < height) {
	        //this happens just on end of lines.
	        return this._getNewSelectionStartFromOffset(
	          mouseOffset, prevWidth, width, charIndex + i - 1, jlen);
	      }
	    }
	
	    // clicked somewhere after all chars, so set at the end
	    if (typeof newSelectionStart === 'undefined') {
	      return this.text.length;
	    }
	  },
	
	  /**
	   * @private
	   */
	  _getNewSelectionStartFromOffset: function(mouseOffset, prevWidth, width, index, jlen) {
	
	    var distanceBtwLastCharAndCursor = mouseOffset.x - prevWidth,
	        distanceBtwNextCharAndCursor = width - mouseOffset.x,
	        offset = distanceBtwNextCharAndCursor > distanceBtwLastCharAndCursor ? 0 : 1,
	        newSelectionStart = index + offset;
	
	    // if object is horizontally flipped, mirror cursor location from the end
	    if (this.flipX) {
	      newSelectionStart = jlen - newSelectionStart;
	    }
	
	    if (newSelectionStart > this.text.length) {
	      newSelectionStart = this.text.length;
	    }
	
	    return newSelectionStart;
	  }
	});
	
	
	fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {
	
	  /**
	   * Initializes hidden textarea (needed to bring up keyboard in iOS)
	   */
	  initHiddenTextarea: function() {
	    this.hiddenTextarea = fabric.document.createElement('textarea');
	    this.hiddenTextarea.setAttribute('autocapitalize', 'off');
	    var style = this._calcTextareaPosition();
	    this.hiddenTextarea.style.cssText = 'position: absolute; top: ' + style.top + '; left: ' + style.left + ';'
	                                        + ' opacity: 0; width: 0px; height: 0px; z-index: -999;';
	    fabric.document.body.appendChild(this.hiddenTextarea);
	
	    fabric.util.addListener(this.hiddenTextarea, 'keydown', this.onKeyDown.bind(this));
	    fabric.util.addListener(this.hiddenTextarea, 'keyup', this.onKeyUp.bind(this));
	    fabric.util.addListener(this.hiddenTextarea, 'input', this.onInput.bind(this));
	    fabric.util.addListener(this.hiddenTextarea, 'copy', this.copy.bind(this));
	    fabric.util.addListener(this.hiddenTextarea, 'cut', this.cut.bind(this));
	    fabric.util.addListener(this.hiddenTextarea, 'paste', this.paste.bind(this));
	    fabric.util.addListener(this.hiddenTextarea, 'compositionstart', this.onCompositionStart.bind(this));
	    fabric.util.addListener(this.hiddenTextarea, 'compositionupdate', this.onCompositionUpdate.bind(this));
	    fabric.util.addListener(this.hiddenTextarea, 'compositionend', this.onCompositionEnd.bind(this));
	
	    if (!this._clickHandlerInitialized && this.canvas) {
	      fabric.util.addListener(this.canvas.upperCanvasEl, 'click', this.onClick.bind(this));
	      this._clickHandlerInitialized = true;
	    }
	  },
	
	  /**
	   * @private
	   */
	  _keysMap: {
	    8:  'removeChars',
	    9:  'exitEditing',
	    27: 'exitEditing',
	    13: 'insertNewline',
	    33: 'moveCursorUp',
	    34: 'moveCursorDown',
	    35: 'moveCursorRight',
	    36: 'moveCursorLeft',
	    37: 'moveCursorLeft',
	    38: 'moveCursorUp',
	    39: 'moveCursorRight',
	    40: 'moveCursorDown',
	    46: 'forwardDelete'
	  },
	
	  /**
	   * @private
	   */
	  _ctrlKeysMapUp: {
	    67: 'copy',
	    88: 'cut'
	  },
	
	  /**
	   * @private
	   */
	  _ctrlKeysMapDown: {
	    65: 'selectAll'
	  },
	
	  onClick: function() {
	    // No need to trigger click event here, focus is enough to have the keyboard appear on Android
	    this.hiddenTextarea && this.hiddenTextarea.focus();
	  },
	
	  /**
	   * Handles keyup event
	   * @param {Event} e Event object
	   */
	  onKeyDown: function(e) {
	    if (!this.isEditing) {
	      return;
	    }
	    if (e.keyCode in this._keysMap) {
	      this[this._keysMap[e.keyCode]](e);
	    }
	    else if ((e.keyCode in this._ctrlKeysMapDown) && (e.ctrlKey || e.metaKey)) {
	      this[this._ctrlKeysMapDown[e.keyCode]](e);
	    }
	    else {
	      return;
	    }
	    e.stopImmediatePropagation();
	    e.preventDefault();
	    this.canvas && this.canvas.renderAll();
	  },
	
	  /**
	   * Handles keyup event
	   * We handle KeyUp because ie11 and edge have difficulties copy/pasting
	   * if a copy/cut event fired, keyup is dismissed
	   * @param {Event} e Event object
	   */
	  onKeyUp: function(e) {
	    if (!this.isEditing || this._copyDone) {
	      this._copyDone = false;
	      return;
	    }
	    if ((e.keyCode in this._ctrlKeysMapUp) && (e.ctrlKey || e.metaKey)) {
	      this[this._ctrlKeysMapUp[e.keyCode]](e);
	    }
	    else {
	      return;
	    }
	    e.stopImmediatePropagation();
	    e.preventDefault();
	    this.canvas && this.canvas.renderAll();
	  },
	
	  /**
	   * Handles onInput event
	   * @param {Event} e Event object
	   */
	  onInput: function(e) {
	    if (!this.isEditing || this.inCompositionMode) {
	      return;
	    }
	    var offset = this.selectionStart || 0,
	        offsetEnd = this.selectionEnd || 0,
	        textLength = this.text.length,
	        newTextLength = this.hiddenTextarea.value.length,
	        diff, charsToInsert, start;
	    if (newTextLength > textLength) {
	      //we added some character
	      start = this._selectionDirection === 'left' ? offsetEnd : offset;
	      diff = newTextLength - textLength;
	      charsToInsert = this.hiddenTextarea.value.slice(start, start + diff);
	    }
	    else {
	      //we selected a portion of text and then input something else.
	      //Internet explorer does not trigger this else
	      diff = newTextLength - textLength + offsetEnd - offset;
	      charsToInsert = this.hiddenTextarea.value.slice(offset, offset + diff);
	    }
	    this.insertChars(charsToInsert);
	    e.stopPropagation();
	  },
	
	  /**
	   * Composition start
	   */
	  onCompositionStart: function() {
	    this.inCompositionMode = true;
	    this.prevCompositionLength = 0;
	    this.compositionStart = this.selectionStart;
	  },
	
	  /**
	   * Composition end
	   */
	  onCompositionEnd: function() {
	    this.inCompositionMode = false;
	  },
	
	  /**
	   * Composition update
	   */
	  onCompositionUpdate: function(e) {
	    var data = e.data;
	    this.selectionStart = this.compositionStart;
	    this.selectionEnd = this.selectionEnd === this.selectionStart ?
	      this.compositionStart + this.prevCompositionLength : this.selectionEnd;
	    this.insertChars(data, false);
	    this.prevCompositionLength = data.length;
	  },
	
	  /**
	   * Forward delete
	   */
	  forwardDelete: function(e) {
	    if (this.selectionStart === this.selectionEnd) {
	      if (this.selectionStart === this.text.length) {
	        return;
	      }
	      this.moveCursorRight(e);
	    }
	    this.removeChars(e);
	  },
	
	  /**
	   * Copies selected text
	   * @param {Event} e Event object
	   */
	  copy: function(e) {
	    if (this.selectionStart === this.selectionEnd) {
	      //do not cut-copy if no selection
	      return;
	    }
	    var selectedText = this.getSelectedText(),
	        clipboardData = this._getClipboardData(e);
	
	    // Check for backward compatibility with old browsers
	    if (clipboardData) {
	      clipboardData.setData('text', selectedText);
	    }
	
	    fabric.copiedText = selectedText;
	    fabric.copiedTextStyle = this.getSelectionStyles(
	                          this.selectionStart,
	                          this.selectionEnd);
	    e.stopImmediatePropagation();
	    e.preventDefault();
	    this._copyDone = true;
	  },
	
	  /**
	   * Pastes text
	   * @param {Event} e Event object
	   */
	  paste: function(e) {
	    var copiedText = null,
	        clipboardData = this._getClipboardData(e),
	        useCopiedStyle = true;
	
	    // Check for backward compatibility with old browsers
	    if (clipboardData) {
	      copiedText = clipboardData.getData('text').replace(/\r/g, '');
	      if (!fabric.copiedTextStyle || fabric.copiedText !== copiedText) {
	        useCopiedStyle = false;
	      }
	    }
	    else {
	      copiedText = fabric.copiedText;
	    }
	
	    if (copiedText) {
	      this.insertChars(copiedText, useCopiedStyle);
	    }
	    e.stopImmediatePropagation();
	    e.preventDefault();
	  },
	
	  /**
	   * Cuts text
	   * @param {Event} e Event object
	   */
	  cut: function(e) {
	    if (this.selectionStart === this.selectionEnd) {
	      return;
	    }
	
	    this.copy(e);
	    this.removeChars(e);
	  },
	
	  /**
	   * @private
	   * @param {Event} e Event object
	   * @return {Object} Clipboard data object
	   */
	  _getClipboardData: function(e) {
	    return (e && e.clipboardData) || fabric.window.clipboardData;
	  },
	
	  /**
	   * Finds the width in pixels before the cursor on the same line
	   * @private
	   * @param {Number} lineIndex
	   * @param {Number} charIndex
	   * @return {Number} widthBeforeCursor width before cursor
	   */
	  _getWidthBeforeCursor: function(lineIndex, charIndex) {
	    var textBeforeCursor = this._textLines[lineIndex].slice(0, charIndex),
	        widthOfLine = this._getLineWidth(this.ctx, lineIndex),
	        widthBeforeCursor = this._getLineLeftOffset(widthOfLine), _char;
	
	    for (var i = 0, len = textBeforeCursor.length; i < len; i++) {
	      _char = textBeforeCursor[i];
	      widthBeforeCursor += this._getWidthOfChar(this.ctx, _char, lineIndex, i);
	    }
	    return widthBeforeCursor;
	  },
	
	  /**
	   * Gets start offset of a selection
	   * @param {Event} e Event object
	   * @param {Boolean} isRight
	   * @return {Number}
	   */
	  getDownCursorOffset: function(e, isRight) {
	    var selectionProp = this._getSelectionForOffset(e, isRight),
	        cursorLocation = this.get2DCursorLocation(selectionProp),
	        lineIndex = cursorLocation.lineIndex;
	    // if on last line, down cursor goes to end of line
	    if (lineIndex === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) {
	      // move to the end of a text
	      return this.text.length - selectionProp;
	    }
	    var charIndex = cursorLocation.charIndex,
	        widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),
	        indexOnOtherLine = this._getIndexOnLine(lineIndex + 1, widthBeforeCursor),
	        textAfterCursor = this._textLines[lineIndex].slice(charIndex);
	
	    return textAfterCursor.length + indexOnOtherLine + 2;
	  },
	
	  /**
	   * private
	   * Helps finding if the offset should be counted from Start or End
	   * @param {Event} e Event object
	   * @param {Boolean} isRight
	   * @return {Number}
	   */
	  _getSelectionForOffset: function(e, isRight) {
	    if (e.shiftKey && this.selectionStart !== this.selectionEnd && isRight) {
	      return this.selectionEnd;
	    }
	    else {
	      return this.selectionStart;
	    }
	  },
	
	  /**
	   * @param {Event} e Event object
	   * @param {Boolean} isRight
	   * @return {Number}
	   */
	  getUpCursorOffset: function(e, isRight) {
	    var selectionProp = this._getSelectionForOffset(e, isRight),
	        cursorLocation = this.get2DCursorLocation(selectionProp),
	        lineIndex = cursorLocation.lineIndex;
	    if (lineIndex === 0 || e.metaKey || e.keyCode === 33) {
	      // if on first line, up cursor goes to start of line
	      return -selectionProp;
	    }
	    var charIndex = cursorLocation.charIndex,
	        widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),
	        indexOnOtherLine = this._getIndexOnLine(lineIndex - 1, widthBeforeCursor),
	        textBeforeCursor = this._textLines[lineIndex].slice(0, charIndex);
	    // return a negative offset
	    return -this._textLines[lineIndex - 1].length + indexOnOtherLine - textBeforeCursor.length;
	  },
	
	  /**
	   * find for a given width it founds the matching character.
	   * @private
	   */
	  _getIndexOnLine: function(lineIndex, width) {
	
	    var widthOfLine = this._getLineWidth(this.ctx, lineIndex),
	        textOnLine = this._textLines[lineIndex],
	        lineLeftOffset = this._getLineLeftOffset(widthOfLine),
	        widthOfCharsOnLine = lineLeftOffset,
	        indexOnLine = 0,
	        foundMatch;
	
	    for (var j = 0, jlen = textOnLine.length; j < jlen; j++) {
	
	      var _char = textOnLine[j],
	          widthOfChar = this._getWidthOfChar(this.ctx, _char, lineIndex, j);
	
	      widthOfCharsOnLine += widthOfChar;
	
	      if (widthOfCharsOnLine > width) {
	
	        foundMatch = true;
	
	        var leftEdge = widthOfCharsOnLine - widthOfChar,
	            rightEdge = widthOfCharsOnLine,
	            offsetFromLeftEdge = Math.abs(leftEdge - width),
	            offsetFromRightEdge = Math.abs(rightEdge - width);
	
	        indexOnLine = offsetFromRightEdge < offsetFromLeftEdge ? j : (j - 1);
	
	        break;
	      }
	    }
	
	    // reached end
	    if (!foundMatch) {
	      indexOnLine = textOnLine.length - 1;
	    }
	
	    return indexOnLine;
	  },
	
	
	  /**
	   * Moves cursor down
	   * @param {Event} e Event object
	   */
	  moveCursorDown: function(e) {
	    if (this.selectionStart >= this.text.length && this.selectionEnd >= this.text.length) {
	      return;
	    }
	    this._moveCursorUpOrDown('Down', e);
	  },
	
	  /**
	   * Moves cursor up
	   * @param {Event} e Event object
	   */
	  moveCursorUp: function(e) {
	    if (this.selectionStart === 0 && this.selectionEnd === 0) {
	      return;
	    }
	    this._moveCursorUpOrDown('Up', e);
	  },
	
	  /**
	   * Moves cursor up or down, fires the events
	   * @param {String} direction 'Up' or 'Down'
	   * @param {Event} e Event object
	   */
	  _moveCursorUpOrDown: function(direction, e) {
	    // getUpCursorOffset
	    // getDownCursorOffset
	    var action = 'get' + direction + 'CursorOffset',
	        offset = this[action](e, this._selectionDirection === 'right');
	    if (e.shiftKey) {
	      this.moveCursorWithShift(offset);
	    }
	    else {
	      this.moveCursorWithoutShift(offset);
	    }
	    if (offset !== 0) {
	      this.setSelectionInBoundaries();
	      this.abortCursorAnimation();
	      this._currentCursorOpacity = 1;
	      this.initDelayedCursor();
	      this._fireSelectionChanged();
	      this._updateTextarea();
	    }
	  },
	
	  /**
	   * Moves cursor with shift
	   * @param {Number} offset
	   */
	  moveCursorWithShift: function(offset) {
	    var newSelection = this._selectionDirection === 'left'
	    ? this.selectionStart + offset
	    : this.selectionEnd + offset;
	    this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, newSelection);
	    return offset !== 0;
	  },
	
	  /**
	   * Moves cursor up without shift
	   * @param {Number} offset
	   */
	  moveCursorWithoutShift: function(offset) {
	    if (offset < 0) {
	      this.selectionStart += offset;
	      this.selectionEnd = this.selectionStart;
	    }
	    else {
	      this.selectionEnd += offset;
	      this.selectionStart = this.selectionEnd;
	    }
	    return offset !== 0;
	  },
	
	  /**
	   * Moves cursor left
	   * @param {Event} e Event object
	   */
	  moveCursorLeft: function(e) {
	    if (this.selectionStart === 0 && this.selectionEnd === 0) {
	      return;
	    }
	    this._moveCursorLeftOrRight('Left', e);
	  },
	
	  /**
	   * @private
	   * @return {Boolean} true if a change happened
	   */
	  _move: function(e, prop, direction) {
	    var newValue;
	    if (e.altKey) {
	      newValue = this['findWordBoundary' + direction](this[prop]);
	    }
	    else if (e.metaKey || e.keyCode === 35 ||  e.keyCode === 36 ) {
	      newValue = this['findLineBoundary' + direction](this[prop]);
	    }
	    else {
	      this[prop] += direction === 'Left' ? -1 : 1;
	      return true;
	    }
	    if (typeof newValue !== undefined && this[prop] !== newValue) {
	      this[prop] = newValue;
	      return true;
	    }
	  },
	
	  /**
	   * @private
	   */
	  _moveLeft: function(e, prop) {
	    return this._move(e, prop, 'Left');
	  },
	
	  /**
	   * @private
	   */
	  _moveRight: function(e, prop) {
	    return this._move(e, prop, 'Right');
	  },
	
	  /**
	   * Moves cursor left without keeping selection
	   * @param {Event} e
	   */
	  moveCursorLeftWithoutShift: function(e) {
	    var change = true;
	    this._selectionDirection = 'left';
	
	    // only move cursor when there is no selection,
	    // otherwise we discard it, and leave cursor on same place
	    if (this.selectionEnd === this.selectionStart && this.selectionStart !== 0) {
	      change = this._moveLeft(e, 'selectionStart');
	
	    }
	    this.selectionEnd = this.selectionStart;
	    return change;
	  },
	
	  /**
	   * Moves cursor left while keeping selection
	   * @param {Event} e
	   */
	  moveCursorLeftWithShift: function(e) {
	    if (this._selectionDirection === 'right' && this.selectionStart !== this.selectionEnd) {
	      return this._moveLeft(e, 'selectionEnd');
	    }
	    else if (this.selectionStart !== 0){
	      this._selectionDirection = 'left';
	      return this._moveLeft(e, 'selectionStart');
	    }
	  },
	
	  /**
	   * Moves cursor right
	   * @param {Event} e Event object
	   */
	  moveCursorRight: function(e) {
	    if (this.selectionStart >= this.text.length && this.selectionEnd >= this.text.length) {
	      return;
	    }
	    this._moveCursorLeftOrRight('Right', e);
	  },
	
	  /**
	   * Moves cursor right or Left, fires event
	   * @param {String} direction 'Left', 'Right'
	   * @param {Event} e Event object
	   */
	  _moveCursorLeftOrRight: function(direction, e) {
	    var actionName = 'moveCursor' + direction + 'With';
	    this._currentCursorOpacity = 1;
	
	    if (e.shiftKey) {
	      actionName += 'Shift';
	    }
	    else {
	      actionName += 'outShift';
	    }
	    if (this[actionName](e)) {
	      this.abortCursorAnimation();
	      this.initDelayedCursor();
	      this._fireSelectionChanged();
	      this._updateTextarea();
	    }
	  },
	
	  /**
	   * Moves cursor right while keeping selection
	   * @param {Event} e
	   */
	  moveCursorRightWithShift: function(e) {
	    if (this._selectionDirection === 'left' && this.selectionStart !== this.selectionEnd) {
	      return this._moveRight(e, 'selectionStart');
	    }
	    else if (this.selectionEnd !== this.text.length) {
	      this._selectionDirection = 'right';
	      return this._moveRight(e, 'selectionEnd');
	    }
	  },
	
	  /**
	   * Moves cursor right without keeping selection
	   * @param {Event} e Event object
	   */
	  moveCursorRightWithoutShift: function(e) {
	    var changed = true;
	    this._selectionDirection = 'right';
	
	    if (this.selectionStart === this.selectionEnd) {
	      changed = this._moveRight(e, 'selectionStart');
	      this.selectionEnd = this.selectionStart;
	    }
	    else {
	      this.selectionStart = this.selectionEnd;
	    }
	    return changed;
	  },
	
	  /**
	   * Removes characters selected by selection
	   * @param {Event} e Event object
	   */
	  removeChars: function(e) {
	    if (this.selectionStart === this.selectionEnd) {
	      this._removeCharsNearCursor(e);
	    }
	    else {
	      this._removeCharsFromTo(this.selectionStart, this.selectionEnd);
	    }
	
	    this.setSelectionEnd(this.selectionStart);
	
	    this._removeExtraneousStyles();
	
	    this.canvas && this.canvas.renderAll();
	
	    this.setCoords();
	    this.fire('changed');
	    this.canvas && this.canvas.fire('text:changed', { target: this });
	  },
	
	  /**
	   * @private
	   * @param {Event} e Event object
	   */
	  _removeCharsNearCursor: function(e) {
	    if (this.selectionStart === 0) {
	      return;
	    }
	    if (e.metaKey) {
	      // remove all till the start of current line
	      var leftLineBoundary = this.findLineBoundaryLeft(this.selectionStart);
	
	      this._removeCharsFromTo(leftLineBoundary, this.selectionStart);
	      this.setSelectionStart(leftLineBoundary);
	    }
	    else if (e.altKey) {
	      // remove all till the start of current word
	      var leftWordBoundary = this.findWordBoundaryLeft(this.selectionStart);
	
	      this._removeCharsFromTo(leftWordBoundary, this.selectionStart);
	      this.setSelectionStart(leftWordBoundary);
	    }
	    else {
	      this._removeSingleCharAndStyle(this.selectionStart);
	      this.setSelectionStart(this.selectionStart - 1);
	    }
	  }
	});
	
	
	/* _TO_SVG_START_ */
	(function() {
	  var toFixed = fabric.util.toFixed,
	      NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
	
	  fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {
	
	    /**
	     * @private
	     */
	    _setSVGTextLineText: function(lineIndex, textSpans, height, textLeftOffset, textTopOffset, textBgRects) {
	      if (!this._getLineStyle(lineIndex)) {
	        fabric.Text.prototype._setSVGTextLineText.call(this,
	          lineIndex, textSpans, height, textLeftOffset, textTopOffset);
	      }
	      else {
	        this._setSVGTextLineChars(
	          lineIndex, textSpans, height, textLeftOffset, textBgRects);
	      }
	    },
	
	    /**
	     * @private
	     */
	    _setSVGTextLineChars: function(lineIndex, textSpans, height, textLeftOffset, textBgRects) {
	
	      var chars = this._textLines[lineIndex],
	          charOffset = 0,
	          lineLeftOffset = this._getLineLeftOffset(this._getLineWidth(this.ctx, lineIndex)) - this.width / 2,
	          lineOffset = this._getSVGLineTopOffset(lineIndex),
	          heightOfLine = this._getHeightOfLine(this.ctx, lineIndex);
	
	      for (var i = 0, len = chars.length; i < len; i++) {
	        var styleDecl = this._getStyleDeclaration(lineIndex, i) || { };
	
	        textSpans.push(
	          this._createTextCharSpan(
	            chars[i], styleDecl, lineLeftOffset, lineOffset.lineTop + lineOffset.offset, charOffset));
	
	        var charWidth = this._getWidthOfChar(this.ctx, chars[i], lineIndex, i);
	
	        if (styleDecl.textBackgroundColor) {
	          textBgRects.push(
	            this._createTextCharBg(
	              styleDecl, lineLeftOffset, lineOffset.lineTop, heightOfLine, charWidth, charOffset));
	        }
	
	        charOffset += charWidth;
	      }
	    },
	
	    /**
	     * @private
	     */
	    _getSVGLineTopOffset: function(lineIndex) {
	      var lineTopOffset = 0, lastHeight = 0;
	      for (var j = 0; j < lineIndex; j++) {
	        lineTopOffset += this._getHeightOfLine(this.ctx, j);
	      }
	      lastHeight = this._getHeightOfLine(this.ctx, j);
	      return {
	        lineTop: lineTopOffset,
	        offset: (this._fontSizeMult - this._fontSizeFraction) * lastHeight / (this.lineHeight * this._fontSizeMult)
	      };
	    },
	
	    /**
	     * @private
	     */
	    _createTextCharBg: function(styleDecl, lineLeftOffset, lineTopOffset, heightOfLine, charWidth, charOffset) {
	      return [
	        '\t\t<rect fill="', styleDecl.textBackgroundColor,
	        '" x="', toFixed(lineLeftOffset + charOffset, NUM_FRACTION_DIGITS),
	        '" y="', toFixed(lineTopOffset - this.height / 2, NUM_FRACTION_DIGITS),
	        '" width="', toFixed(charWidth, NUM_FRACTION_DIGITS),
	        '" height="', toFixed(heightOfLine / this.lineHeight, NUM_FRACTION_DIGITS),
	        '"></rect>\n'
	      ].join('');
	    },
	
	    /**
	     * @private
	     */
	    _createTextCharSpan: function(_char, styleDecl, lineLeftOffset, lineTopOffset, charOffset) {
	
	      var fillStyles = this.getSvgStyles.call(fabric.util.object.extend({
	        visible: true,
	        fill: this.fill,
	        stroke: this.stroke,
	        type: 'text',
	        getSvgFilter: fabric.Object.prototype.getSvgFilter
	      }, styleDecl));
	
	      return [
	        '\t\t\t<tspan x="', toFixed(lineLeftOffset + charOffset, NUM_FRACTION_DIGITS), '" y="',
	        toFixed(lineTopOffset - this.height / 2, NUM_FRACTION_DIGITS), '" ',
	          (styleDecl.fontFamily ? 'font-family="' + styleDecl.fontFamily.replace(/"/g, '\'') + '" ' : ''),
	          (styleDecl.fontSize ? 'font-size="' + styleDecl.fontSize + '" ' : ''),
	          (styleDecl.fontStyle ? 'font-style="' + styleDecl.fontStyle + '" ' : ''),
	          (styleDecl.fontWeight ? 'font-weight="' + styleDecl.fontWeight + '" ' : ''),
	          (styleDecl.textDecoration ? 'text-decoration="' + styleDecl.textDecoration + '" ' : ''),
	        'style="', fillStyles, '">',
	        fabric.util.string.escapeXml(_char),
	        '</tspan>\n'
	      ].join('');
	    }
	  });
	})();
	/* _TO_SVG_END_ */
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = {}),
	      clone  = fabric.util.object.clone;
	
	  /**
	   * Textbox class, based on IText, allows the user to resize the text rectangle
	   * and wraps lines automatically. Textboxes have their Y scaling locked, the
	   * user can only change width. Height is adjusted automatically based on the
	   * wrapping of lines.
	   * @class fabric.Textbox
	   * @extends fabric.IText
	   * @mixes fabric.Observable
	   * @return {fabric.Textbox} thisArg
	   * @see {@link fabric.Textbox#initialize} for constructor definition
	   */
	  fabric.Textbox = fabric.util.createClass(fabric.IText, fabric.Observable, {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'textbox',
	
	    /**
	     * Minimum width of textbox, in pixels.
	     * @type Number
	     * @default
	     */
	    minWidth: 20,
	
	    /**
	     * Minimum calculated width of a textbox, in pixels.
	     * fixed to 2 so that an empty textbox cannot go to 0
	     * and is still selectable without text.
	     * @type Number
	     * @default
	     */
	    dynamicMinWidth: 2,
	
	    /**
	     * Cached array of text wrapping.
	     * @type Array
	     */
	    __cachedLines: null,
	
	    /**
	     * Override standard Object class values
	     */
	    lockScalingY: true,
	
	    /**
	     * Override standard Object class values
	     */
	    lockScalingFlip: true,
	
	    /**
	     * Constructor. Some scaling related property values are forced. Visibility
	     * of controls is also fixed; only the rotation and width controls are
	     * made available.
	     * @param {String} text Text string
	     * @param {Object} [options] Options object
	     * @return {fabric.Textbox} thisArg
	     */
	    initialize: function(text, options) {
	      this.ctx = fabric.util.createCanvasElement().getContext('2d');
	      this.callSuper('initialize', text, options);
	      this.setControlsVisibility(fabric.Textbox.getTextboxControlVisibility());
	
	      // add width to this list of props that effect line wrapping.
	      this._dimensionAffectingProps.width = true;
	    },
	
	    /**
	     * Unlike superclass's version of this function, Textbox does not update
	     * its width.
	     * @param {CanvasRenderingContext2D} ctx Context to use for measurements
	     * @private
	     * @override
	     */
	    _initDimensions: function(ctx) {
	      if (this.__skipDimension) {
	        return;
	      }
	
	      if (!ctx) {
	        ctx = fabric.util.createCanvasElement().getContext('2d');
	        this._setTextStyles(ctx);
	      }
	
	      // clear dynamicMinWidth as it will be different after we re-wrap line
	      this.dynamicMinWidth = 0;
	
	      // wrap lines
	      this._textLines = this._splitTextIntoLines();
	      // if after wrapping, the width is smaller than dynamicMinWidth, change the width and re-wrap
	      if (this.dynamicMinWidth > this.width) {
	        this._set('width', this.dynamicMinWidth);
	      }
	
	      // clear cache and re-calculate height
	      this._clearCache();
	      this.height = this._getTextHeight(ctx);
	    },
	
	    /**
	     * Generate an object that translates the style object so that it is
	     * broken up by visual lines (new lines and automatic wrapping).
	     * The original text styles object is broken up by actual lines (new lines only),
	     * which is only sufficient for Text / IText
	     * @private
	     */
	    _generateStyleMap: function() {
	      var realLineCount     = 0,
	          realLineCharCount = 0,
	          charCount         = 0,
	          map               = {};
	
	      for (var i = 0; i < this._textLines.length; i++) {
	        if (this.text[charCount] === '\n' && i > 0) {
	          realLineCharCount = 0;
	          charCount++;
	          realLineCount++;
	        }
	        else if (this.text[charCount] === ' ' && i > 0) {
	          // this case deals with space's that are removed from end of lines when wrapping
	          realLineCharCount++;
	          charCount++;
	        }
	
	        map[i] = { line: realLineCount, offset: realLineCharCount };
	
	        charCount += this._textLines[i].length;
	        realLineCharCount += this._textLines[i].length;
	      }
	
	      return map;
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @param {Number} charIndex
	     * @param {Boolean} [returnCloneOrEmpty=false]
	     * @private
	     */
	    _getStyleDeclaration: function(lineIndex, charIndex, returnCloneOrEmpty) {
	      if (this._styleMap) {
	        var map = this._styleMap[lineIndex];
	        if (!map) {
	          return returnCloneOrEmpty ? { } : null;
	        }
	        lineIndex = map.line;
	        charIndex = map.offset + charIndex;
	      }
	      return this.callSuper('_getStyleDeclaration', lineIndex, charIndex, returnCloneOrEmpty);
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @param {Number} charIndex
	     * @param {Object} style
	     * @private
	     */
	    _setStyleDeclaration: function(lineIndex, charIndex, style) {
	      var map = this._styleMap[lineIndex];
	      lineIndex = map.line;
	      charIndex = map.offset + charIndex;
	
	      this.styles[lineIndex][charIndex] = style;
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @param {Number} charIndex
	     * @private
	     */
	    _deleteStyleDeclaration: function(lineIndex, charIndex) {
	      var map = this._styleMap[lineIndex];
	      lineIndex = map.line;
	      charIndex = map.offset + charIndex;
	
	      delete this.styles[lineIndex][charIndex];
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @private
	     */
	    _getLineStyle: function(lineIndex) {
	      var map = this._styleMap[lineIndex];
	      return this.styles[map.line];
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @param {Object} style
	     * @private
	     */
	    _setLineStyle: function(lineIndex, style) {
	      var map = this._styleMap[lineIndex];
	      this.styles[map.line] = style;
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @private
	     */
	    _deleteLineStyle: function(lineIndex) {
	      var map = this._styleMap[lineIndex];
	      delete this.styles[map.line];
	    },
	
	    /**
	     * Wraps text using the 'width' property of Textbox. First this function
	     * splits text on newlines, so we preserve newlines entered by the user.
	     * Then it wraps each line using the width of the Textbox by calling
	     * _wrapLine().
	     * @param {CanvasRenderingContext2D} ctx Context to use for measurements
	     * @param {String} text The string of text that is split into lines
	     * @returns {Array} Array of lines
	     */
	    _wrapText: function(ctx, text) {
	      var lines = text.split(this._reNewline), wrapped = [], i;
	
	      for (i = 0; i < lines.length; i++) {
	        wrapped = wrapped.concat(this._wrapLine(ctx, lines[i], i));
	      }
	
	      return wrapped;
	    },
	
	    /**
	     * Helper function to measure a string of text, given its lineIndex and charIndex offset
	     *
	     * @param {CanvasRenderingContext2D} ctx
	     * @param {String} text
	     * @param {number} lineIndex
	     * @param {number} charOffset
	     * @returns {number}
	     * @private
	     */
	    _measureText: function(ctx, text, lineIndex, charOffset) {
	      var width = 0;
	      charOffset = charOffset || 0;
	      for (var i = 0, len = text.length; i < len; i++) {
	        width += this._getWidthOfChar(ctx, text[i], lineIndex, i + charOffset);
	      }
	      return width;
	    },
	
	    /**
	     * Wraps a line of text using the width of the Textbox and a context.
	     * @param {CanvasRenderingContext2D} ctx Context to use for measurements
	     * @param {String} text The string of text to split into lines
	     * @param {Number} lineIndex
	     * @returns {Array} Array of line(s) into which the given text is wrapped
	     * to.
	     */
	    _wrapLine: function(ctx, text, lineIndex) {
	      var lineWidth        = 0,
	          lines            = [],
	          line             = '',
	          words            = text.split(' '),
	          word             = '',
	          offset           = 0,
	          infix            = ' ',
	          wordWidth        = 0,
	          infixWidth       = 0,
	          largestWordWidth = 0,
	          lineJustStarted = true,
	          additionalSpace = this._getWidthOfCharSpacing();
	
	      for (var i = 0; i < words.length; i++) {
	        word = words[i];
	        wordWidth = this._measureText(ctx, word, lineIndex, offset);
	
	        offset += word.length;
	
	        lineWidth += infixWidth + wordWidth - additionalSpace;
	
	        if (lineWidth >= this.width && !lineJustStarted) {
	          lines.push(line);
	          line = '';
	          lineWidth = wordWidth;
	          lineJustStarted = true;
	        }
	        else {
	          lineWidth += additionalSpace;
	        }
	
	        if (!lineJustStarted) {
	          line += infix;
	        }
	        line += word;
	
	        infixWidth = this._measureText(ctx, infix, lineIndex, offset);
	        offset++;
	        lineJustStarted = false;
	        // keep track of largest word
	        if (wordWidth > largestWordWidth) {
	          largestWordWidth = wordWidth;
	        }
	      }
	
	      i && lines.push(line);
	
	      if (largestWordWidth > this.dynamicMinWidth) {
	        this.dynamicMinWidth = largestWordWidth - additionalSpace;
	      }
	
	      return lines;
	    },
	    /**
	     * Gets lines of text to render in the Textbox. This function calculates
	     * text wrapping on the fly everytime it is called.
	     * @returns {Array} Array of lines in the Textbox.
	     * @override
	     */
	    _splitTextIntoLines: function() {
	      var originalAlign = this.textAlign;
	      this.ctx.save();
	      this._setTextStyles(this.ctx);
	      this.textAlign = 'left';
	      var lines = this._wrapText(this.ctx, this.text);
	      this.textAlign = originalAlign;
	      this.ctx.restore();
	      this._textLines = lines;
	      this._styleMap = this._generateStyleMap();
	      return lines;
	    },
	
	    /**
	     * When part of a group, we don't want the Textbox's scale to increase if
	     * the group's increases. That's why we reduce the scale of the Textbox by
	     * the amount that the group's increases. This is to maintain the effective
	     * scale of the Textbox at 1, so that font-size values make sense. Otherwise
	     * the same font-size value would result in different actual size depending
	     * on the value of the scale.
	     * @param {String} key
	     * @param {*} value
	     */
	    setOnGroup: function(key, value) {
	      if (key === 'scaleX') {
	        this.set('scaleX', Math.abs(1 / value));
	        this.set('width', (this.get('width') * value) /
	          (typeof this.__oldScaleX === 'undefined' ? 1 : this.__oldScaleX));
	        this.__oldScaleX = value;
	      }
	    },
	
	    /**
	     * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start).
	     * Overrides the superclass function to take into account text wrapping.
	     *
	     * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.
	     */
	    get2DCursorLocation: function(selectionStart) {
	      if (typeof selectionStart === 'undefined') {
	        selectionStart = this.selectionStart;
	      }
	
	      var numLines = this._textLines.length,
	          removed  = 0;
	
	      for (var i = 0; i < numLines; i++) {
	        var line    = this._textLines[i],
	            lineLen = line.length;
	
	        if (selectionStart <= removed + lineLen) {
	          return {
	            lineIndex: i,
	            charIndex: selectionStart - removed
	          };
	        }
	
	        removed += lineLen;
	
	        if (this.text[removed] === '\n' || this.text[removed] === ' ') {
	          removed++;
	        }
	      }
	
	      return {
	        lineIndex: numLines - 1,
	        charIndex: this._textLines[numLines - 1].length
	      };
	    },
	
	    /**
	     * Overrides superclass function and uses text wrapping data to get cursor
	     * boundary offsets instead of the array of chars.
	     * @param {Array} chars Unused
	     * @param {String} typeOfBoundaries Can be 'cursor' or 'selection'
	     * @returns {Object} Object with 'top', 'left', and 'lineLeft' properties set.
	     */
	    _getCursorBoundariesOffsets: function(chars, typeOfBoundaries) {
	      var topOffset      = 0,
	          leftOffset     = 0,
	          cursorLocation = this.get2DCursorLocation(),
	          lineChars      = this._textLines[cursorLocation.lineIndex].split(''),
	          lineLeftOffset = this._getLineLeftOffset(this._getLineWidth(this.ctx, cursorLocation.lineIndex));
	
	      for (var i = 0; i < cursorLocation.charIndex; i++) {
	        leftOffset += this._getWidthOfChar(this.ctx, lineChars[i], cursorLocation.lineIndex, i);
	      }
	
	      for (i = 0; i < cursorLocation.lineIndex; i++) {
	        topOffset += this._getHeightOfLine(this.ctx, i);
	      }
	
	      if (typeOfBoundaries === 'cursor') {
	        topOffset += (1 - this._fontSizeFraction) * this._getHeightOfLine(this.ctx, cursorLocation.lineIndex)
	          / this.lineHeight - this.getCurrentCharFontSize(cursorLocation.lineIndex, cursorLocation.charIndex)
	          * (1 - this._fontSizeFraction);
	      }
	
	      return {
	        top: topOffset,
	        left: leftOffset,
	        lineLeft: lineLeftOffset
	      };
	    },
	
	    getMinWidth: function() {
	      return Math.max(this.minWidth, this.dynamicMinWidth);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @method toObject
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      return fabric.util.object.extend(this.callSuper('toObject', propertiesToInclude), {
	        minWidth: this.minWidth
	      });
	    }
	  });
	  /**
	   * Returns fabric.Textbox instance from an object representation
	   * @static
	   * @memberOf fabric.Textbox
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] Callback to invoke when an fabric.Textbox instance is created
	   * @return {fabric.Textbox} instance of fabric.Textbox
	   */
	  fabric.Textbox.fromObject = function(object, callback) {
	    var textbox = new fabric.Textbox(object.text, clone(object));
	    callback && callback(textbox);
	    return textbox;
	  };
	  /**
	   * Returns the default controls visibility required for Textboxes.
	   * @returns {Object}
	   */
	  fabric.Textbox.getTextboxControlVisibility = function() {
	    return {
	      tl: false,
	      tr: false,
	      br: false,
	      bl: false,
	      ml: true,
	      mt: false,
	      mr: true,
	      mb: false,
	      mtr: true
	    };
	  };
	
	})( true ? exports : this);
	
	
	(function() {
	
	  /**
	   * Override _setObjectScale and add Textbox specific resizing behavior. Resizing
	   * a Textbox doesn't scale text, it only changes width and makes text wrap automatically.
	   */
	  var setObjectScaleOverridden = fabric.Canvas.prototype._setObjectScale;
	
	  fabric.Canvas.prototype._setObjectScale = function(localMouse, transform,
	                                                     lockScalingX, lockScalingY, by, lockScalingFlip, _dim) {
	
	    var t = transform.target;
	    if (t instanceof fabric.Textbox) {
	      var w = t.width * ((localMouse.x / transform.scaleX) / (t.width + t.strokeWidth));
	      if (w >= t.getMinWidth()) {
	        t.set('width', w);
	        return true;
	      }
	    }
	    else {
	      return setObjectScaleOverridden.call(fabric.Canvas.prototype, localMouse, transform,
	        lockScalingX, lockScalingY, by, lockScalingFlip, _dim);
	    }
	  };
	
	  /**
	   * Sets controls of this group to the Textbox's special configuration if
	   * one is present in the group. Deletes _controlsVisibility otherwise, so that
	   * it gets initialized to default value at runtime.
	   */
	  fabric.Group.prototype._refreshControlsVisibility = function() {
	    if (typeof fabric.Textbox === 'undefined') {
	      return;
	    }
	    for (var i = this._objects.length; i--;) {
	      if (this._objects[i] instanceof fabric.Textbox) {
	        this.setControlsVisibility(fabric.Textbox.getTextboxControlVisibility());
	        return;
	      }
	    }
	  };
	
	  var clone = fabric.util.object.clone;
	
	  fabric.util.object.extend(fabric.Textbox.prototype, /** @lends fabric.IText.prototype */ {
	    /**
	     * @private
	     */
	    _removeExtraneousStyles: function() {
	      for (var prop in this._styleMap) {
	        if (!this._textLines[prop]) {
	          delete this.styles[this._styleMap[prop].line];
	        }
	      }
	    },
	
	    /**
	     * Inserts style object for a given line/char index
	     * @param {Number} lineIndex Index of a line
	     * @param {Number} charIndex Index of a char
	     * @param {Object} [style] Style object to insert, if given
	     */
	    insertCharStyleObject: function(lineIndex, charIndex, style) {
	      // adjust lineIndex and charIndex
	      var map = this._styleMap[lineIndex];
	      lineIndex = map.line;
	      charIndex = map.offset + charIndex;
	
	      fabric.IText.prototype.insertCharStyleObject.apply(this, [lineIndex, charIndex, style]);
	    },
	
	    /**
	     * Inserts new style object
	     * @param {Number} lineIndex Index of a line
	     * @param {Number} charIndex Index of a char
	     * @param {Boolean} isEndOfLine True if it's end of line
	     */
	    insertNewlineStyleObject: function(lineIndex, charIndex, isEndOfLine) {
	      // adjust lineIndex and charIndex
	      var map = this._styleMap[lineIndex];
	      lineIndex = map.line;
	      charIndex = map.offset + charIndex;
	
	      fabric.IText.prototype.insertNewlineStyleObject.apply(this, [lineIndex, charIndex, isEndOfLine]);
	    },
	
	    /**
	     * Shifts line styles up or down. This function is slightly different than the one in
	     * itext_behaviour as it takes into account the styleMap.
	     *
	     * @param {Number} lineIndex Index of a line
	     * @param {Number} offset Can be -1 or +1
	     */
	    shiftLineStyles: function(lineIndex, offset) {
	      // shift all line styles by 1 upward
	      var clonedStyles = clone(this.styles),
	          map          = this._styleMap[lineIndex];
	
	      // adjust line index
	      lineIndex = map.line;
	
	      for (var line in this.styles) {
	        var numericLine = parseInt(line, 10);
	
	        if (numericLine > lineIndex) {
	          this.styles[numericLine + offset] = clonedStyles[numericLine];
	
	          if (!clonedStyles[numericLine - offset]) {
	            delete this.styles[numericLine];
	          }
	        }
	      }
	      //TODO: evaluate if delete old style lines with offset -1
	    },
	
	    /**
	     * Figure out programatically the text on previous actual line (actual = separated by \n);
	     *
	     * @param {Number} lIndex
	     * @returns {String}
	     * @private
	     */
	    _getTextOnPreviousLine: function(lIndex) {
	      var textOnPreviousLine = this._textLines[lIndex - 1];
	
	      while (this._styleMap[lIndex - 2] && this._styleMap[lIndex - 2].line === this._styleMap[lIndex - 1].line) {
	        textOnPreviousLine = this._textLines[lIndex - 2] + textOnPreviousLine;
	
	        lIndex--;
	      }
	
	      return textOnPreviousLine;
	    },
	
	    /**
	     * Removes style object
	     * @param {Boolean} isBeginningOfLine True if cursor is at the beginning of line
	     * @param {Number} [index] Optional index. When not given, current selectionStart is used.
	     */
	    removeStyleObject: function(isBeginningOfLine, index) {
	
	      var cursorLocation = this.get2DCursorLocation(index),
	          map            = this._styleMap[cursorLocation.lineIndex],
	          lineIndex      = map.line,
	          charIndex      = map.offset + cursorLocation.charIndex;
	      this._removeStyleObject(isBeginningOfLine, cursorLocation, lineIndex, charIndex);
	    }
	  });
	})();
	
	
	(function() {
	  var override = fabric.IText.prototype._getNewSelectionStartFromOffset;
	  /**
	   * Overrides the IText implementation and adjusts character index as there is not always a linebreak
	   *
	   * @param {Number} mouseOffset
	   * @param {Number} prevWidth
	   * @param {Number} width
	   * @param {Number} index
	   * @param {Number} jlen
	   * @returns {Number}
	   */
	  fabric.IText.prototype._getNewSelectionStartFromOffset = function(mouseOffset, prevWidth, width, index, jlen) {
	    index = override.call(this, mouseOffset, prevWidth, width, index, jlen);
	
	    // the index passed into the function is padded by the amount of lines from _textLines (to account for \n)
	    // we need to remove this padding, and pad it by actual lines, and / or spaces that are meant to be there
	    var tmp     = 0,
	        removed = 0;
	
	    // account for removed characters
	    for (var i = 0; i < this._textLines.length; i++) {
	      tmp += this._textLines[i].length;
	
	      if (tmp + removed >= index) {
	        break;
	      }
	
	      if (this.text[tmp + removed] === '\n' || this.text[tmp + removed] === ' ') {
	        removed++;
	      }
	    }
	
	    return index - i + removed;
	  };
	})();
	
	
	(function() {
	
	  if (typeof document !== 'undefined' && typeof window !== 'undefined') {
	    return;
	  }
	
	  var DOMParser = __webpack_require__(15).DOMParser,
	      URL = __webpack_require__(16),
	      HTTP = __webpack_require__(22),
	      HTTPS = __webpack_require__(46),
	
	      Canvas = __webpack_require__(14),
	      Image = __webpack_require__(14).Image;
	
	  /** @private */
	  function request(url, encoding, callback) {
	    var oURL = URL.parse(url);
	
	    // detect if http or https is used
	    if ( !oURL.port ) {
	      oURL.port = ( oURL.protocol.indexOf('https:') === 0 ) ? 443 : 80;
	    }
	
	    // assign request handler based on protocol
	    var reqHandler = (oURL.protocol.indexOf('https:') === 0 ) ? HTTPS : HTTP,
	        req = reqHandler.request({
	          hostname: oURL.hostname,
	          port: oURL.port,
	          path: oURL.path,
	          method: 'GET'
	        }, function(response) {
	          var body = '';
	          if (encoding) {
	            response.setEncoding(encoding);
	          }
	          response.on('end', function () {
	            callback(body);
	          });
	          response.on('data', function (chunk) {
	            if (response.statusCode === 200) {
	              body += chunk;
	            }
	          });
	        });
	
	    req.on('error', function(err) {
	      if (err.errno === process.ECONNREFUSED) {
	        fabric.log('ECONNREFUSED: connection refused to ' + oURL.hostname + ':' + oURL.port);
	      }
	      else {
	        fabric.log(err.message);
	      }
	      callback(null);
	    });
	
	    req.end();
	  }
	
	  /** @private */
	  function requestFs(path, callback) {
	    var fs = __webpack_require__(47);
	    fs.readFile(path, function (err, data) {
	      if (err) {
	        fabric.log(err);
	        throw err;
	      }
	      else {
	        callback(data);
	      }
	    });
	  }
	
	  fabric.util.loadImage = function(url, callback, context) {
	    function createImageAndCallBack(data) {
	      if (data) {
	        img.src = new Buffer(data, 'binary');
	        // preserving original url, which seems to be lost in node-canvas
	        img._src = url;
	        callback && callback.call(context, img);
	      }
	      else {
	        img = null;
	        callback && callback.call(context, null, true);
	      }
	    }
	    var img = new Image();
	    if (url && (url instanceof Buffer || url.indexOf('data') === 0)) {
	      img.src = img._src = url;
	      callback && callback.call(context, img);
	    }
	    else if (url && url.indexOf('http') !== 0) {
	      requestFs(url, createImageAndCallBack);
	    }
	    else if (url) {
	      request(url, 'binary', createImageAndCallBack);
	    }
	    else {
	      callback && callback.call(context, url);
	    }
	  };
	
	  fabric.loadSVGFromURL = function(url, callback, reviver) {
	    url = url.replace(/^\n\s*/, '').replace(/\?.*$/, '').trim();
	    if (url.indexOf('http') !== 0) {
	      requestFs(url, function(body) {
	        fabric.loadSVGFromString(body.toString(), callback, reviver);
	      });
	    }
	    else {
	      request(url, '', function(body) {
	        fabric.loadSVGFromString(body, callback, reviver);
	      });
	    }
	  };
	
	  fabric.loadSVGFromString = function(string, callback, reviver) {
	    var doc = new DOMParser().parseFromString(string);
	    fabric.parseSVGDocument(doc.documentElement, function(results, options) {
	      callback && callback(results, options);
	    }, reviver);
	  };
	
	  fabric.util.getScript = function(url, callback) {
	    request(url, '', function(body) {
	      // eslint-disable-next-line no-eval
	      eval(body);
	      callback && callback();
	    });
	  };
	
	  // fabric.util.createCanvasElement = function(_, width, height) {
	  //   return new Canvas(width, height);
	  // }
	
	  /**
	   * Only available when running fabric on node.js
	   * @param {Number} width Canvas width
	   * @param {Number} height Canvas height
	   * @param {Object} [options] Options to pass to FabricCanvas.
	   * @param {Object} [nodeCanvasOptions] Options to pass to NodeCanvas.
	   * @return {Object} wrapped canvas instance
	   */
	  fabric.createCanvasForNode = function(width, height, options, nodeCanvasOptions) {
	    nodeCanvasOptions = nodeCanvasOptions || options;
	
	    var canvasEl = fabric.document.createElement('canvas'),
	        nodeCanvas = new Canvas(width || 600, height || 600, nodeCanvasOptions),
	        nodeCacheCanvas = new Canvas(width || 600, height || 600, nodeCanvasOptions);
	
	    // jsdom doesn't create style on canvas element, so here be temp. workaround
	    canvasEl.style = { };
	
	    canvasEl.width = nodeCanvas.width;
	    canvasEl.height = nodeCanvas.height;
	    options = options || { };
	    options.nodeCanvas = nodeCanvas;
	    options.nodeCacheCanvas = nodeCacheCanvas;
	    var FabricCanvas = fabric.Canvas || fabric.StaticCanvas,
	        fabricCanvas = new FabricCanvas(canvasEl, options);
	    fabricCanvas.nodeCanvas = nodeCanvas;
	    fabricCanvas.nodeCacheCanvas = nodeCacheCanvas;
	    fabricCanvas.contextContainer = nodeCanvas.getContext('2d');
	    fabricCanvas.contextCache = nodeCacheCanvas.getContext('2d');
	    fabricCanvas.Font = Canvas.Font;
	    return fabricCanvas;
	  };
	
	  var originaInitStatic = fabric.StaticCanvas.prototype._initStatic;
	  fabric.StaticCanvas.prototype._initStatic = function(el, options) {
	    el = el || fabric.document.createElement('canvas');
	    this.nodeCanvas = new Canvas(el.width, el.height);
	    this.nodeCacheCanvas = new Canvas(el.width, el.height);
	    originaInitStatic.call(this, el, options);
	    this.contextContainer = this.nodeCanvas.getContext('2d');
	    this.contextCache = this.nodeCacheCanvas.getContext('2d');
	    this.Font = Canvas.Font;
	  }
	
	  /** @ignore */
	  fabric.StaticCanvas.prototype.createPNGStream = function() {
	    return this.nodeCanvas.createPNGStream();
	  };
	
	  fabric.StaticCanvas.prototype.createJPEGStream = function(opts) {
	    return this.nodeCanvas.createJPEGStream(opts);
	  };
	
	  fabric.StaticCanvas.prototype._initRetinaScaling = function() {
	    if (!this._isRetinaScaling()) {
	      return;
	    }
	
	    this.lowerCanvasEl.setAttribute('width', this.width * fabric.devicePixelRatio);
	    this.lowerCanvasEl.setAttribute('height', this.height * fabric.devicePixelRatio);
	    this.nodeCanvas.width = this.width * fabric.devicePixelRatio;
	    this.nodeCanvas.height = this.height * fabric.devicePixelRatio;
	    this.contextContainer.scale(fabric.devicePixelRatio, fabric.devicePixelRatio);
	    return this;
	  };
	  if (fabric.Canvas) {
	    fabric.Canvas.prototype._initRetinaScaling = fabric.StaticCanvas.prototype._initRetinaScaling;
	  }
	
	  var origSetBackstoreDimension = fabric.StaticCanvas.prototype._setBackstoreDimension;
	  fabric.StaticCanvas.prototype._setBackstoreDimension = function(prop, value) {
	    origSetBackstoreDimension.call(this, prop, value);
	    this.nodeCanvas[prop] = value;
	    return this;
	  };
	  if (fabric.Canvas) {
	    fabric.Canvas.prototype._setBackstoreDimension = fabric.StaticCanvas.prototype._setBackstoreDimension;
	  }
	
	})();
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8).Buffer, __webpack_require__(12)))

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(9)
	var ieee754 = __webpack_require__(10)
	var isArray = __webpack_require__(11)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()
	
	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length)
	    }
	    that.length = length
	  }
	
	  return that
	}
	
	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */
	
	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}
	
	Buffer.poolSize = 8192 // not used by this implementation
	
	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}
	
	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }
	
	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }
	
	  return fromObject(that, value)
	}
	
	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	}
	
	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}
	
	function alloc (that, size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}
	
	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	}
	
	function allocUnsafe (that, size) {
	  assertSize(size)
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }
	
	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }
	
	  var length = byteLength(string, encoding) | 0
	  that = createBuffer(that, length)
	
	  var actual = that.write(string, encoding)
	
	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual)
	  }
	
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0
	  that = createBuffer(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer
	
	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }
	
	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }
	
	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array)
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset)
	  } else {
	    array = new Uint8Array(array, byteOffset, length)
	  }
	
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array)
	  }
	  return that
	}
	
	function fromObject (that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    that = createBuffer(that, len)
	
	    if (that.length === 0) {
	      return that
	    }
	
	    obj.copy(that, 0, 0, len)
	    return that
	  }
	
	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }
	
	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }
	
	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }
	
	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }
	
	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}
	
	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.
	
	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }
	
	  if (end === undefined || end > this.length) {
	    end = this.length
	  }
	
	  if (end <= 0) {
	    return ''
	  }
	
	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0
	
	  if (end <= start) {
	    return ''
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true
	
	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}
	
	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}
	
	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}
	
	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7)
	    swap(this, i + 1, i + 6)
	    swap(this, i + 2, i + 5)
	    swap(this, i + 3, i + 4)
	  }
	  return this
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }
	
	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }
	
	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }
	
	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }
	
	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0
	
	  if (this === target) return 0
	
	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)
	
	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)
	
	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1
	
	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset = +byteOffset  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1)
	  }
	
	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0
	    else return -1
	  }
	
	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }
	
	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length
	
	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }
	
	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }
	
	  var i
	  if (dir) {
	    var foundIndex = -1
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex
	        foundIndex = -1
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false
	          break
	        }
	      }
	      if (found) return i
	    }
	  }
	
	  return -1
	}
	
	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}
	
	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function latin1Slice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }
	
	  return len
	}
	
	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }
	
	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }
	
	  if (end <= start) {
	    return this
	  }
	
	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0
	
	  if (!val) val = 0
	
	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString())
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8).Buffer, (function() { return this; }())))

/***/ },
/* 9 */
/***/ function(module, exports) {

	'use strict'
	
	exports.byteLength = byteLength
	exports.toByteArray = toByteArray
	exports.fromByteArray = fromByteArray
	
	var lookup = []
	var revLookup = []
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
	
	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i]
	  revLookup[code.charCodeAt(i)] = i
	}
	
	revLookup['-'.charCodeAt(0)] = 62
	revLookup['_'.charCodeAt(0)] = 63
	
	function placeHoldersCount (b64) {
	  var len = b64.length
	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }
	
	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
	}
	
	function byteLength (b64) {
	  // base64 is 4/3 + up to two characters of the original data
	  return b64.length * 3 / 4 - placeHoldersCount(b64)
	}
	
	function toByteArray (b64) {
	  var i, j, l, tmp, placeHolders, arr
	  var len = b64.length
	  placeHolders = placeHoldersCount(b64)
	
	  arr = new Arr(len * 3 / 4 - placeHolders)
	
	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len
	
	  var L = 0
	
	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
	    arr[L++] = (tmp >> 16) & 0xFF
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }
	
	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
	    arr[L++] = tmp & 0xFF
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }
	
	  return arr
	}
	
	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}
	
	function encodeChunk (uint8, start, end) {
	  var tmp
	  var output = []
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
	    output.push(tripletToBase64(tmp))
	  }
	  return output.join('')
	}
	
	function fromByteArray (uint8) {
	  var tmp
	  var len = uint8.length
	  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
	  var output = ''
	  var parts = []
	  var maxChunkLength = 16383 // must be multiple of 3
	
	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
	  }
	
	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1]
	    output += lookup[tmp >> 2]
	    output += lookup[(tmp << 4) & 0x3F]
	    output += '=='
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
	    output += lookup[tmp >> 10]
	    output += lookup[(tmp >> 4) & 0x3F]
	    output += lookup[(tmp << 2) & 0x3F]
	    output += '='
	  }
	
	  parts.push(output)
	
	  return parts.join('')
	}


/***/ },
/* 10 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 11 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 12 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 13 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 14 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 15 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var punycode = __webpack_require__(17);
	
	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;
	
	exports.Url = Url;
	
	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}
	
	// Reference: RFC 3986, RFC 1808, RFC 2396
	
	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,
	
	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
	
	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
	
	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = __webpack_require__(19);
	
	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && isObject(url) && url instanceof Url) return url;
	
	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}
	
	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }
	
	  var rest = url;
	
	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();
	
	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }
	
	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }
	
	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {
	
	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c
	
	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.
	
	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	
	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }
	
	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }
	
	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;
	
	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);
	
	    // pull out port.
	    this.parseHost();
	
	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';
	
	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';
	
	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }
	
	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }
	
	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a puny coded representation of "domain".
	      // It only converts the part of the domain name that
	      // has non ASCII characters. I.e. it dosent matter if
	      // you call it with a domain that already is in ASCII.
	      var domainArray = this.hostname.split('.');
	      var newOut = [];
	      for (var i = 0; i < domainArray.length; ++i) {
	        var s = domainArray[i];
	        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
	            'xn--' + punycode.encode(s) : s);
	      }
	      this.hostname = newOut.join('.');
	    }
	
	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;
	
	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }
	
	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {
	
	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }
	
	
	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }
	
	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }
	
	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};
	
	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}
	
	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }
	
	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';
	
	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }
	
	  if (this.query &&
	      isObject(this.query) &&
	      Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }
	
	  var search = this.search || (query && ('?' + query)) || '';
	
	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';
	
	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }
	
	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;
	
	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');
	
	  return protocol + host + pathname + search + hash;
	};
	
	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}
	
	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};
	
	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}
	
	Url.prototype.resolveObject = function(relative) {
	  if (isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }
	
	  var result = new Url();
	  Object.keys(this).forEach(function(k) {
	    result[k] = this[k];
	  }, this);
	
	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;
	
	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }
	
	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    Object.keys(relative).forEach(function(k) {
	      if (k !== 'protocol')
	        result[k] = relative[k];
	    });
	
	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }
	
	    result.href = result.format();
	    return result;
	  }
	
	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      Object.keys(relative).forEach(function(k) {
	        result[k] = relative[k];
	      });
	      result.href = result.format();
	      return result;
	    }
	
	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }
	
	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];
	
	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }
	
	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especialy happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!isNull(result.pathname) || !isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host) && (last === '.' || last === '..') ||
	      last === '');
	
	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last == '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }
	
	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }
	
	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }
	
	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');
	
	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especialy happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }
	
	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);
	
	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }
	
	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }
	
	  //to support request.http
	  if (!isNull(result.pathname) || !isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};
	
	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};
	
	function isString(arg) {
	  return typeof arg === "string";
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isNull(arg) {
	  return arg === null;
	}
	function isNullOrUndefined(arg) {
	  return  arg == null;
	}


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function(root) {
	
		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}
	
		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,
	
		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
	
		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'
	
		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
	
		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},
	
		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,
	
		/** Temporary variable */
		key;
	
		/*--------------------------------------------------------------------------*/
	
		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw RangeError(errors[type]);
		}
	
		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}
	
		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}
	
		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}
	
		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}
	
		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}
	
		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * http://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}
	
		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;
	
			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.
	
			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}
	
			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}
	
			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.
	
			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {
	
				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {
	
					if (index >= inputLength) {
						error('invalid-input');
					}
	
					digit = basicToDigit(input.charCodeAt(index++));
	
					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}
	
					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
	
					if (digit < t) {
						break;
					}
	
					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}
	
					w *= baseMinusT;
	
				}
	
				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);
	
				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}
	
				n += floor(i / out);
				i %= out;
	
				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);
	
			}
	
			return ucs2encode(output);
		}
	
		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;
	
			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);
	
			// Cache the length
			inputLength = input.length;
	
			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;
	
			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}
	
			handledCPCount = basicLength = output.length;
	
			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.
	
			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}
	
			// Main encoding loop:
			while (handledCPCount < inputLength) {
	
				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}
	
				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}
	
				delta += (m - n) * handledCPCountPlusOne;
				n = m;
	
				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];
	
					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}
	
					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}
	
						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}
	
				++delta;
				++n;
	
			}
			return output.join('');
		}
	
		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}
	
		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}
	
		/*--------------------------------------------------------------------------*/
	
		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};
	
		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.punycode = punycode;
		}
	
	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(18)(module), (function() { return this; }())))

/***/ },
/* 18 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.decode = exports.parse = __webpack_require__(20);
	exports.encode = exports.stringify = __webpack_require__(21);


/***/ },
/* 20 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};
	
	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }
	
	  var regexp = /\+/g;
	  qs = qs.split(sep);
	
	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }
	
	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }
	
	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;
	
	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }
	
	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);
	
	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }
	
	  return obj;
	};


/***/ },
/* 21 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;
	
	    case 'boolean':
	      return v ? 'true' : 'false';
	
	    case 'number':
	      return isFinite(v) ? v : '';
	
	    default:
	      return '';
	  }
	};
	
	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }
	
	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);
	
	  }
	
	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var http = module.exports;
	var EventEmitter = __webpack_require__(23).EventEmitter;
	var Request = __webpack_require__(24);
	var url = __webpack_require__(16)
	
	http.request = function (params, cb) {
	    if (typeof params === 'string') {
	        params = url.parse(params)
	    }
	    if (!params) params = {};
	    if (!params.host && !params.port) {
	        params.port = parseInt(window.location.port, 10);
	    }
	    if (!params.host && params.hostname) {
	        params.host = params.hostname;
	    }
	
	    if (!params.protocol) {
	        if (params.scheme) {
	            params.protocol = params.scheme + ':';
	        } else {
	            params.protocol = window.location.protocol;
	        }
	    }
	
	    if (!params.host) {
	        params.host = window.location.hostname || window.location.host;
	    }
	    if (/:/.test(params.host)) {
	        if (!params.port) {
	            params.port = params.host.split(':')[1];
	        }
	        params.host = params.host.split(':')[0];
	    }
	    if (!params.port) params.port = params.protocol == 'https:' ? 443 : 80;
	    
	    var req = new Request(new xhrHttp, params);
	    if (cb) req.on('response', cb);
	    return req;
	};
	
	http.get = function (params, cb) {
	    params.method = 'GET';
	    var req = http.request(params, cb);
	    req.end();
	    return req;
	};
	
	http.Agent = function () {};
	http.Agent.defaultMaxSockets = 4;
	
	var xhrHttp = (function () {
	    if (typeof window === 'undefined') {
	        throw new Error('no window object present');
	    }
	    else if (window.XMLHttpRequest) {
	        return window.XMLHttpRequest;
	    }
	    else if (window.ActiveXObject) {
	        var axs = [
	            'Msxml2.XMLHTTP.6.0',
	            'Msxml2.XMLHTTP.3.0',
	            'Microsoft.XMLHTTP'
	        ];
	        for (var i = 0; i < axs.length; i++) {
	            try {
	                var ax = new(window.ActiveXObject)(axs[i]);
	                return function () {
	                    if (ax) {
	                        var ax_ = ax;
	                        ax = null;
	                        return ax_;
	                    }
	                    else {
	                        return new(window.ActiveXObject)(axs[i]);
	                    }
	                };
	            }
	            catch (e) {}
	        }
	        throw new Error('ajax not supported in this browser')
	    }
	    else {
	        throw new Error('ajax not supported in this browser');
	    }
	})();
	
	http.STATUS_CODES = {
	    100 : 'Continue',
	    101 : 'Switching Protocols',
	    102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918
	    200 : 'OK',
	    201 : 'Created',
	    202 : 'Accepted',
	    203 : 'Non-Authoritative Information',
	    204 : 'No Content',
	    205 : 'Reset Content',
	    206 : 'Partial Content',
	    207 : 'Multi-Status',               // RFC 4918
	    300 : 'Multiple Choices',
	    301 : 'Moved Permanently',
	    302 : 'Moved Temporarily',
	    303 : 'See Other',
	    304 : 'Not Modified',
	    305 : 'Use Proxy',
	    307 : 'Temporary Redirect',
	    400 : 'Bad Request',
	    401 : 'Unauthorized',
	    402 : 'Payment Required',
	    403 : 'Forbidden',
	    404 : 'Not Found',
	    405 : 'Method Not Allowed',
	    406 : 'Not Acceptable',
	    407 : 'Proxy Authentication Required',
	    408 : 'Request Time-out',
	    409 : 'Conflict',
	    410 : 'Gone',
	    411 : 'Length Required',
	    412 : 'Precondition Failed',
	    413 : 'Request Entity Too Large',
	    414 : 'Request-URI Too Large',
	    415 : 'Unsupported Media Type',
	    416 : 'Requested Range Not Satisfiable',
	    417 : 'Expectation Failed',
	    418 : 'I\'m a teapot',              // RFC 2324
	    422 : 'Unprocessable Entity',       // RFC 4918
	    423 : 'Locked',                     // RFC 4918
	    424 : 'Failed Dependency',          // RFC 4918
	    425 : 'Unordered Collection',       // RFC 4918
	    426 : 'Upgrade Required',           // RFC 2817
	    428 : 'Precondition Required',      // RFC 6585
	    429 : 'Too Many Requests',          // RFC 6585
	    431 : 'Request Header Fields Too Large',// RFC 6585
	    500 : 'Internal Server Error',
	    501 : 'Not Implemented',
	    502 : 'Bad Gateway',
	    503 : 'Service Unavailable',
	    504 : 'Gateway Time-out',
	    505 : 'HTTP Version Not Supported',
	    506 : 'Variant Also Negotiates',    // RFC 2295
	    507 : 'Insufficient Storage',       // RFC 4918
	    509 : 'Bandwidth Limit Exceeded',
	    510 : 'Not Extended',               // RFC 2774
	    511 : 'Network Authentication Required' // RFC 6585
	};

/***/ },
/* 23 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var Stream = __webpack_require__(25);
	var Response = __webpack_require__(41);
	var Base64 = __webpack_require__(45);
	var inherits = __webpack_require__(26);
	
	var Request = module.exports = function (xhr, params) {
	    var self = this;
	    self.writable = true;
	    self.xhr = xhr;
	    self.body = [];
	    
	    self.uri = (params.protocol || 'http:') + '//'
	        + params.host
	        + (params.port ? ':' + params.port : '')
	        + (params.path || '/')
	    ;
	    
	    if (typeof params.withCredentials === 'undefined') {
	        params.withCredentials = true;
	    }
	
	    try { xhr.withCredentials = params.withCredentials }
	    catch (e) {}
	    
	    if (params.responseType) try { xhr.responseType = params.responseType }
	    catch (e) {}
	    
	    xhr.open(
	        params.method || 'GET',
	        self.uri,
	        true
	    );
	
	    xhr.onerror = function(event) {
	        self.emit('error', new Error('Network error'));
	    };
	
	    self._headers = {};
	    
	    if (params.headers) {
	        var keys = objectKeys(params.headers);
	        for (var i = 0; i < keys.length; i++) {
	            var key = keys[i];
	            if (!self.isSafeRequestHeader(key)) continue;
	            var value = params.headers[key];
	            self.setHeader(key, value);
	        }
	    }
	    
	    if (params.auth) {
	        //basic auth
	        this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));
	    }
	
	    var res = new Response;
	    res.on('close', function () {
	        self.emit('close');
	    });
	    
	    res.on('ready', function () {
	        self.emit('response', res);
	    });
	
	    res.on('error', function (err) {
	        self.emit('error', err);
	    });
	    
	    xhr.onreadystatechange = function () {
	        // Fix for IE9 bug
	        // SCRIPT575: Could not complete the operation due to error c00c023f
	        // It happens when a request is aborted, calling the success callback anyway with readyState === 4
	        if (xhr.__aborted) return;
	        res.handle(xhr);
	    };
	};
	
	inherits(Request, Stream);
	
	Request.prototype.setHeader = function (key, value) {
	    this._headers[key.toLowerCase()] = value
	};
	
	Request.prototype.getHeader = function (key) {
	    return this._headers[key.toLowerCase()]
	};
	
	Request.prototype.removeHeader = function (key) {
	    delete this._headers[key.toLowerCase()]
	};
	
	Request.prototype.write = function (s) {
	    this.body.push(s);
	};
	
	Request.prototype.destroy = function (s) {
	    this.xhr.__aborted = true;
	    this.xhr.abort();
	    this.emit('close');
	};
	
	Request.prototype.end = function (s) {
	    if (s !== undefined) this.body.push(s);
	
	    var keys = objectKeys(this._headers);
	    for (var i = 0; i < keys.length; i++) {
	        var key = keys[i];
	        var value = this._headers[key];
	        if (isArray(value)) {
	            for (var j = 0; j < value.length; j++) {
	                this.xhr.setRequestHeader(key, value[j]);
	            }
	        }
	        else this.xhr.setRequestHeader(key, value)
	    }
	
	    if (this.body.length === 0) {
	        this.xhr.send('');
	    }
	    else if (typeof this.body[0] === 'string') {
	        this.xhr.send(this.body.join(''));
	    }
	    else if (isArray(this.body[0])) {
	        var body = [];
	        for (var i = 0; i < this.body.length; i++) {
	            body.push.apply(body, this.body[i]);
	        }
	        this.xhr.send(body);
	    }
	    else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {
	        var len = 0;
	        for (var i = 0; i < this.body.length; i++) {
	            len += this.body[i].length;
	        }
	        var body = new(this.body[0].constructor)(len);
	        var k = 0;
	        
	        for (var i = 0; i < this.body.length; i++) {
	            var b = this.body[i];
	            for (var j = 0; j < b.length; j++) {
	                body[k++] = b[j];
	            }
	        }
	        this.xhr.send(body);
	    }
	    else if (isXHR2Compatible(this.body[0])) {
	        this.xhr.send(this.body[0]);
	    }
	    else {
	        var body = '';
	        for (var i = 0; i < this.body.length; i++) {
	            body += this.body[i].toString();
	        }
	        this.xhr.send(body);
	    }
	};
	
	// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
	Request.unsafeHeaders = [
	    "accept-charset",
	    "accept-encoding",
	    "access-control-request-headers",
	    "access-control-request-method",
	    "connection",
	    "content-length",
	    "cookie",
	    "cookie2",
	    "content-transfer-encoding",
	    "date",
	    "expect",
	    "host",
	    "keep-alive",
	    "origin",
	    "referer",
	    "te",
	    "trailer",
	    "transfer-encoding",
	    "upgrade",
	    "user-agent",
	    "via"
	];
	
	Request.prototype.isSafeRequestHeader = function (headerName) {
	    if (!headerName) return false;
	    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
	};
	
	var objectKeys = Object.keys || function (obj) {
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    return keys;
	};
	
	var isArray = Array.isArray || function (xs) {
	    return Object.prototype.toString.call(xs) === '[object Array]';
	};
	
	var indexOf = function (xs, x) {
	    if (xs.indexOf) return xs.indexOf(x);
	    for (var i = 0; i < xs.length; i++) {
	        if (xs[i] === x) return i;
	    }
	    return -1;
	};
	
	var isXHR2Compatible = function (obj) {
	    if (typeof Blob !== 'undefined' && obj instanceof Blob) return true;
	    if (typeof ArrayBuffer !== 'undefined' && obj instanceof ArrayBuffer) return true;
	    if (typeof FormData !== 'undefined' && obj instanceof FormData) return true;
	};


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	module.exports = Stream;
	
	var EE = __webpack_require__(23).EventEmitter;
	var inherits = __webpack_require__(26);
	
	inherits(Stream, EE);
	Stream.Readable = __webpack_require__(27);
	Stream.Writable = __webpack_require__(37);
	Stream.Duplex = __webpack_require__(38);
	Stream.Transform = __webpack_require__(39);
	Stream.PassThrough = __webpack_require__(40);
	
	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;
	
	
	
	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.
	
	function Stream() {
	  EE.call(this);
	}
	
	Stream.prototype.pipe = function(dest, options) {
	  var source = this;
	
	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }
	
	  source.on('data', ondata);
	
	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }
	
	  dest.on('drain', ondrain);
	
	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }
	
	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;
	
	    dest.end();
	  }
	
	
	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;
	
	    if (typeof dest.destroy === 'function') dest.destroy();
	  }
	
	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }
	
	  source.on('error', onerror);
	  dest.on('error', onerror);
	
	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);
	
	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);
	
	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);
	
	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);
	
	    dest.removeListener('close', cleanup);
	  }
	
	  source.on('end', cleanup);
	  source.on('close', cleanup);
	
	  dest.on('close', cleanup);
	
	  dest.emit('pipe', source);
	
	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};


/***/ },
/* 26 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {exports = module.exports = __webpack_require__(28);
	exports.Stream = __webpack_require__(25);
	exports.Readable = exports;
	exports.Writable = __webpack_require__(33);
	exports.Duplex = __webpack_require__(32);
	exports.Transform = __webpack_require__(35);
	exports.PassThrough = __webpack_require__(36);
	if (!process.browser && process.env.READABLE_STREAM === 'disable') {
	  module.exports = __webpack_require__(25);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	module.exports = Readable;
	
	/*<replacement>*/
	var isArray = __webpack_require__(29);
	/*</replacement>*/
	
	
	/*<replacement>*/
	var Buffer = __webpack_require__(8).Buffer;
	/*</replacement>*/
	
	Readable.ReadableState = ReadableState;
	
	var EE = __webpack_require__(23).EventEmitter;
	
	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/
	
	var Stream = __webpack_require__(25);
	
	/*<replacement>*/
	var util = __webpack_require__(30);
	util.inherits = __webpack_require__(26);
	/*</replacement>*/
	
	var StringDecoder;
	
	
	/*<replacement>*/
	var debug = __webpack_require__(31);
	if (debug && debug.debuglog) {
	  debug = debug.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/
	
	
	util.inherits(Readable, Stream);
	
	function ReadableState(options, stream) {
	  var Duplex = __webpack_require__(32);
	
	  options = options || {};
	
	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	
	
	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.readableObjectMode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;
	
	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;
	
	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(34).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	
	function Readable(options) {
	  var Duplex = __webpack_require__(32);
	
	  if (!(this instanceof Readable))
	    return new Readable(options);
	
	  this._readableState = new ReadableState(options, this);
	
	  // legacy
	  this.readable = true;
	
	  Stream.call(this);
	}
	
	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;
	
	  if (util.isString(chunk) && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }
	
	  return readableAddChunk(this, state, chunk, encoding, false);
	};
	
	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};
	
	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (util.isNullOrUndefined(chunk)) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);
	
	      if (!addToFront)
	        state.reading = false;
	
	      // if we want the data now, just emit it.
	      if (state.flowing && state.length === 0 && !state.sync) {
	        stream.emit('data', chunk);
	        stream.read(0);
	      } else {
	        // update the buffer info.
	        state.length += state.objectMode ? 1 : chunk.length;
	        if (addToFront)
	          state.buffer.unshift(chunk);
	        else
	          state.buffer.push(chunk);
	
	        if (state.needReadable)
	          emitReadable(stream);
	      }
	
	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }
	
	  return needMoreData(state);
	}
	
	
	
	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}
	
	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(34).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};
	
	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}
	
	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;
	
	  if (state.objectMode)
	    return n === 0 ? 0 : 1;
	
	  if (isNaN(n) || util.isNull(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }
	
	  if (n <= 0)
	    return 0;
	
	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);
	
	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }
	
	  return n;
	}
	
	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;
	
	  if (!util.isNumber(n) || n > 0)
	    state.emittedReadable = false;
	
	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended)
	      endReadable(this);
	    else
	      emitReadable(this);
	    return null;
	  }
	
	  n = howMuchToRead(n, state);
	
	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0)
	      endReadable(this);
	    return null;
	  }
	
	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.
	
	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);
	
	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }
	
	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }
	
	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }
	
	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);
	
	  var ret;
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;
	
	  if (util.isNull(ret)) {
	    state.needReadable = true;
	    n = 0;
	  }
	
	  state.length -= n;
	
	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;
	
	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0)
	    endReadable(this);
	
	  if (!util.isNull(ret))
	    this.emit('data', ret);
	
	  return ret;
	};
	
	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}
	
	
	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	
	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}
	
	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync)
	      process.nextTick(function() {
	        emitReadable_(stream);
	      });
	    else
	      emitReadable_(stream);
	  }
	}
	
	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}
	
	
	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}
	
	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}
	
	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};
	
	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;
	
	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);
	
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }
	
	  function onend() {
	    debug('onend');
	    dest.end();
	  }
	
	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);
	
	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain &&
	        (!dest._writableState || dest._writableState.needDrain))
	      ondrain();
	  }
	
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      debug('false write response, pause',
	            src._readableState.awaitDrain);
	      src._readableState.awaitDrain++;
	      src.pause();
	    }
	  }
	
	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];
	
	
	
	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }
	
	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);
	
	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	
	  return dest;
	};
	
	function pipeOnDrain(src) {
	  return function() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain)
	      state.awaitDrain--;
	    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}
	
	
	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;
	
	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;
	
	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;
	
	    if (!dest)
	      dest = state.pipes;
	
	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }
	
	  // slow case. multiple pipe destinations.
	
	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	
	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }
	
	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;
	
	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];
	
	  dest.emit('unpipe', this);
	
	  return this;
	};
	
	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	
	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }
	
	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        var self = this;
	        process.nextTick(function() {
	          debug('readable nexttick read 0');
	          self.read(0);
	        });
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }
	
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	
	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    if (!state.reading) {
	      debug('resume read 0');
	      this.read(0);
	    }
	    resume(this, state);
	  }
	  return this;
	};
	
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(function() {
	      resume_(stream, state);
	    });
	  }
	}
	
	function resume_(stream, state) {
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading)
	    stream.read(0);
	}
	
	Readable.prototype.pause = function() {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};
	
	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}
	
	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;
	
	  var self = this;
	  stream.on('end', function() {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }
	
	    self.push(null);
	  });
	
	  stream.on('data', function(chunk) {
	    debug('wrapped data');
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);
	    if (!chunk || !state.objectMode && !chunk.length)
	      return;
	
	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });
	
	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }
	
	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });
	
	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	
	  return self;
	};
	
	
	
	// exposed for testing purposes only.
	Readable._fromList = fromList;
	
	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;
	
	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;
	
	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);
	
	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);
	
	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);
	
	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();
	
	        c += cpy;
	      }
	    }
	  }
	
	  return ret;
	}
	
	function endReadable(stream) {
	  var state = stream._readableState;
	
	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');
	
	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}
	
	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

/***/ },
/* 29 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	
	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = Buffer.isBuffer;
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8).Buffer))

/***/ },
/* 31 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.
	
	module.exports = Duplex;
	
	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/
	
	
	/*<replacement>*/
	var util = __webpack_require__(30);
	util.inherits = __webpack_require__(26);
	/*</replacement>*/
	
	var Readable = __webpack_require__(28);
	var Writable = __webpack_require__(33);
	
	util.inherits(Duplex, Readable);
	
	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});
	
	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);
	
	  Readable.call(this, options);
	  Writable.call(this, options);
	
	  if (options && options.readable === false)
	    this.readable = false;
	
	  if (options && options.writable === false)
	    this.writable = false;
	
	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;
	
	  this.once('end', onend);
	}
	
	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;
	
	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}
	
	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.
	
	module.exports = Writable;
	
	/*<replacement>*/
	var Buffer = __webpack_require__(8).Buffer;
	/*</replacement>*/
	
	Writable.WritableState = WritableState;
	
	
	/*<replacement>*/
	var util = __webpack_require__(30);
	util.inherits = __webpack_require__(26);
	/*</replacement>*/
	
	var Stream = __webpack_require__(25);
	
	util.inherits(Writable, Stream);
	
	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}
	
	function WritableState(options, stream) {
	  var Duplex = __webpack_require__(32);
	
	  options = options || {};
	
	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
	
	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.writableObjectMode;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;
	
	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;
	
	  // a flag to see when we're in the middle of a write.
	  this.writing = false;
	
	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;
	
	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };
	
	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;
	
	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	
	  this.buffer = [];
	
	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;
	
	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;
	
	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}
	
	function Writable(options) {
	  var Duplex = __webpack_require__(32);
	
	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);
	
	  this._writableState = new WritableState(options, this);
	
	  // legacy.
	  this.writable = true;
	
	  Stream.call(this);
	}
	
	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};
	
	
	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}
	
	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}
	
	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	
	  if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;
	
	  if (!util.isFunction(cb))
	    cb = function() {};
	
	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }
	
	  return ret;
	};
	
	Writable.prototype.cork = function() {
	  var state = this._writableState;
	
	  state.corked++;
	};
	
	Writable.prototype.uncork = function() {
	  var state = this._writableState;
	
	  if (state.corked) {
	    state.corked--;
	
	    if (!state.writing &&
	        !state.corked &&
	        !state.finished &&
	        !state.bufferProcessing &&
	        state.buffer.length)
	      clearBuffer(this, state);
	  }
	};
	
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      util.isString(chunk)) {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}
	
	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;
	
	  state.length += len;
	
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;
	
	  if (state.writing || state.corked)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	
	  return ret;
	}
	
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev)
	    stream._writev(chunk, state.onwrite);
	  else
	    stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	
	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      state.pendingcb--;
	      cb(er);
	    });
	  else {
	    state.pendingcb--;
	    cb(er);
	  }
	
	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}
	
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	
	  onwriteStateUpdate(state);
	
	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);
	
	    if (!finished &&
	        !state.corked &&
	        !state.bufferProcessing &&
	        state.buffer.length) {
	      clearBuffer(stream, state);
	    }
	
	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}
	
	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}
	
	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}
	
	
	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	
	  if (stream._writev && state.buffer.length > 1) {
	    // Fast case, write everything using _writev()
	    var cbs = [];
	    for (var c = 0; c < state.buffer.length; c++)
	      cbs.push(state.buffer[c].callback);
	
	    // count the one we are adding, as well.
	    // TODO(isaacs) clean this up
	    state.pendingcb++;
	    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
	      for (var i = 0; i < cbs.length; i++) {
	        state.pendingcb--;
	        cbs[i](err);
	      }
	    });
	
	    // Clear buffer
	    state.buffer = [];
	  } else {
	    // Slow case, write chunks one-by-one
	    for (var c = 0; c < state.buffer.length; c++) {
	      var entry = state.buffer[c];
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;
	
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        c++;
	        break;
	      }
	    }
	
	    if (c < state.buffer.length)
	      state.buffer = state.buffer.slice(c);
	    else
	      state.buffer.length = 0;
	  }
	
	  state.bufferProcessing = false;
	}
	
	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	
	};
	
	Writable.prototype._writev = null;
	
	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;
	
	  if (util.isFunction(chunk)) {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (!util.isNullOrUndefined(chunk))
	    this.write(chunk, encoding);
	
	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }
	
	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};
	
	
	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}
	
	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}
	
	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else
	      prefinish(stream, state);
	  }
	  return need;
	}
	
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var Buffer = __webpack_require__(8).Buffer;
	
	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }
	
	
	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}
	
	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }
	
	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};
	
	
	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;
	
	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;
	
	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }
	
	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);
	
	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
	
	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;
	
	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }
	
	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);
	
	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }
	
	  charStr += buffer.toString(this.encoding, 0, end);
	
	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }
	
	  // or just emit the charStr
	  return charStr;
	};
	
	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;
	
	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];
	
	    // See http://en.wikipedia.org/wiki/UTF-8#Description
	
	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }
	
	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }
	
	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};
	
	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);
	
	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }
	
	  return res;
	};
	
	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}
	
	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}
	
	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	
	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.
	
	module.exports = Transform;
	
	var Duplex = __webpack_require__(32);
	
	/*<replacement>*/
	var util = __webpack_require__(30);
	util.inherits = __webpack_require__(26);
	/*</replacement>*/
	
	util.inherits(Transform, Duplex);
	
	
	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };
	
	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}
	
	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;
	
	  var cb = ts.writecb;
	
	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));
	
	  ts.writechunk = null;
	  ts.writecb = null;
	
	  if (!util.isNullOrUndefined(data))
	    stream.push(data);
	
	  if (cb)
	    cb(er);
	
	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}
	
	
	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);
	
	  Duplex.call(this, options);
	
	  this._transformState = new TransformState(options, this);
	
	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;
	
	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;
	
	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	
	  this.once('prefinish', function() {
	    if (util.isFunction(this._flush))
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}
	
	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};
	
	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};
	
	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};
	
	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;
	
	  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	
	
	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);
	
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;
	
	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');
	
	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');
	
	  return stream.push(null);
	}


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.
	
	module.exports = PassThrough;
	
	var Transform = __webpack_require__(35);
	
	/*<replacement>*/
	var util = __webpack_require__(30);
	util.inherits = __webpack_require__(26);
	/*</replacement>*/
	
	util.inherits(PassThrough, Transform);
	
	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);
	
	  Transform.call(this, options);
	}
	
	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(33)


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(32)


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(35)


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(36)


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var Stream = __webpack_require__(25);
	var util = __webpack_require__(42);
	
	var Response = module.exports = function (res) {
	    this.offset = 0;
	    this.readable = true;
	};
	
	util.inherits(Response, Stream);
	
	var capable = {
	    streaming : true,
	    status2 : true
	};
	
	function parseHeaders (res) {
	    var lines = res.getAllResponseHeaders().split(/\r?\n/);
	    var headers = {};
	    for (var i = 0; i < lines.length; i++) {
	        var line = lines[i];
	        if (line === '') continue;
	        
	        var m = line.match(/^([^:]+):\s*(.*)/);
	        if (m) {
	            var key = m[1].toLowerCase(), value = m[2];
	            
	            if (headers[key] !== undefined) {
	            
	                if (isArray(headers[key])) {
	                    headers[key].push(value);
	                }
	                else {
	                    headers[key] = [ headers[key], value ];
	                }
	            }
	            else {
	                headers[key] = value;
	            }
	        }
	        else {
	            headers[line] = true;
	        }
	    }
	    return headers;
	}
	
	Response.prototype.getResponse = function (xhr) {
	    var respType = String(xhr.responseType).toLowerCase();
	    if (respType === 'blob') return xhr.responseBlob || xhr.response;
	    if (respType === 'arraybuffer') return xhr.response;
	    return xhr.responseText;
	}
	
	Response.prototype.getHeader = function (key) {
	    return this.headers[key.toLowerCase()];
	};
	
	Response.prototype.handle = function (res) {
	    if (res.readyState === 2 && capable.status2) {
	        try {
	            this.statusCode = res.status;
	            this.headers = parseHeaders(res);
	        }
	        catch (err) {
	            capable.status2 = false;
	        }
	        
	        if (capable.status2) {
	            this.emit('ready');
	        }
	    }
	    else if (capable.streaming && res.readyState === 3) {
	        try {
	            if (!this.statusCode) {
	                this.statusCode = res.status;
	                this.headers = parseHeaders(res);
	                this.emit('ready');
	            }
	        }
	        catch (err) {}
	        
	        try {
	            this._emitData(res);
	        }
	        catch (err) {
	            capable.streaming = false;
	        }
	    }
	    else if (res.readyState === 4) {
	        if (!this.statusCode) {
	            this.statusCode = res.status;
	            this.emit('ready');
	        }
	        this._emitData(res);
	        
	        if (res.error) {
	            this.emit('error', this.getResponse(res));
	        }
	        else this.emit('end');
	        
	        this.emit('close');
	    }
	};
	
	Response.prototype._emitData = function (res) {
	    var respBody = this.getResponse(res);
	    if (respBody.toString().match(/ArrayBuffer/)) {
	        this.emit('data', new Uint8Array(respBody, this.offset));
	        this.offset = respBody.byteLength;
	        return;
	    }
	    if (respBody.length > this.offset) {
	        this.emit('data', respBody.slice(this.offset));
	        this.offset = respBody.length;
	    }
	};
	
	var isArray = Array.isArray || function (xs) {
	    return Object.prototype.toString.call(xs) === '[object Array]';
	};


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }
	
	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};
	
	
	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }
	
	  if (process.noDeprecation === true) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	};
	
	
	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};
	
	
	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;
	
	
	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};
	
	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};
	
	
	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];
	
	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}
	
	
	function stylizeNoColor(str, styleType) {
	  return str;
	}
	
	
	function arrayToHash(array) {
	  var hash = {};
	
	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });
	
	  return hash;
	}
	
	
	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }
	
	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }
	
	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);
	
	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }
	
	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }
	
	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }
	
	  var base = '', array = false, braces = ['{', '}'];
	
	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }
	
	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }
	
	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }
	
	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }
	
	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }
	
	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }
	
	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }
	
	  ctx.seen.push(value);
	
	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }
	
	  ctx.seen.pop();
	
	  return reduceToSingleString(output, base, braces);
	}
	
	
	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}
	
	
	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}
	
	
	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}
	
	
	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }
	
	  return name + ': ' + str;
	}
	
	
	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);
	
	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }
	
	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}
	
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = __webpack_require__(43);
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	
	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}
	
	
	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];
	
	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}
	
	
	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};
	
	
	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(44);
	
	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;
	
	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};
	
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(12)))

/***/ },
/* 43 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 44 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	;(function () {
	
	  var object =  true ? exports : this; // #8: web workers
	  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	
	  function InvalidCharacterError(message) {
	    this.message = message;
	  }
	  InvalidCharacterError.prototype = new Error;
	  InvalidCharacterError.prototype.name = 'InvalidCharacterError';
	
	  // encoder
	  // [https://gist.github.com/999166] by [https://github.com/nignag]
	  object.btoa || (
	  object.btoa = function (input) {
	    for (
	      // initialize result and counter
	      var block, charCode, idx = 0, map = chars, output = '';
	      // if the next input index does not exist:
	      //   change the mapping table to "="
	      //   check if d has no fractional digits
	      input.charAt(idx | 0) || (map = '=', idx % 1);
	      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
	      output += map.charAt(63 & block >> 8 - idx % 1 * 8)
	    ) {
	      charCode = input.charCodeAt(idx += 3/4);
	      if (charCode > 0xFF) {
	        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
	      }
	      block = block << 8 | charCode;
	    }
	    return output;
	  });
	
	  // decoder
	  // [https://gist.github.com/1020396] by [https://github.com/atk]
	  object.atob || (
	  object.atob = function (input) {
	    input = input.replace(/=+$/, '');
	    if (input.length % 4 == 1) {
	      throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
	    }
	    for (
	      // initialize result and counters
	      var bc = 0, bs, buffer, idx = 0, output = '';
	      // get next character
	      buffer = input.charAt(idx++);
	      // character found in table? initialize bit storage and add its ascii value;
	      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
	        // and if not first of each 4 characters,
	        // convert the first 8 bits to one ascii character
	        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
	    ) {
	      // try to find character in table (0-63, not found => -1)
	      buffer = chars.indexOf(buffer);
	    }
	    return output;
	  });
	
	}());


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	var http = __webpack_require__(22);
	
	var https = module.exports;
	
	for (var key in http) {
	    if (http.hasOwnProperty(key)) https[key] = http[key];
	};
	
	https.request = function (params, cb) {
	    if (!params) params = {};
	    params.scheme = 'https';
	    return http.request.call(this, params, cb);
	}


/***/ },
/* 47 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _fabric = __webpack_require__(7);
	
	var _DrawTool = __webpack_require__(1);
	
	var _DrawTool2 = _interopRequireDefault(_DrawTool);
	
	var _Side = __webpack_require__(49);
	
	var _Side2 = _interopRequireDefault(_Side);
	
	var _escapeJSON = __webpack_require__(4);
	
	var _escapeJSON2 = _interopRequireDefault(_escapeJSON);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Sides class
	 */
	var Sides = function () {
	  function Sides() {
	    _classCallCheck(this, Sides);
	
	    this._collection = [];
	    /**
	     * Currently selected side
	     * @default null
	     * @type {Side}
	     */
	    this.selected = null;
	  }
	
	  /**
	   * Adding a side
	   * @param id
	   * @return {Side}
	   */
	
	
	  _createClass(Sides, [{
	    key: 'addSide',
	    value: function addSide(id) {
	      var newSide = new _Side2.default(id);
	      this._collection.push(newSide);
	      return newSide;
	    }
	
	    /**
	     * Get side as plain JAvaScript object.
	     * @param id {String} Id of side
	     * @return sides {Object}
	     */
	
	  }, {
	    key: 'getSide',
	    value: function getSide(id) {
	      return this._collection.find(function (side) {
	        return side.id === id;
	      });
	    }
	
	    /**
	     * Select side
	     * @param id {String}
	     */
	
	  }, {
	    key: 'select',
	    value: function select(id) {
	
	      this.selected = this._collection.find(function (side) {
	        return side.id === id;
	      });
	
	      if (!this.selected) {
	        return false;
	      }
	
	      this._collection.forEach(function (side) {
	        return side.FabricCanvas.wrapperEl.style.display = 'none';
	      });
	      this.selected.FabricCanvas.wrapperEl.style.display = 'block';
	
	      return this.selected;
	    }
	
	    /**
	     * Getting whole collection as JSON
	     * @return {String}
	     */
	
	  }, {
	    key: 'toJSON',
	    value: function toJSON() {
	
	      var sides = [];
	
	      this._collection.forEach(function (side) {
	        sides.push(side.toObject());
	      });
	
	      return JSON.stringify(sides);
	    }
	
	    /**
	     * Remove side by id
	     * @param id
	     * @return {boolean}
	     */
	
	  }, {
	    key: 'removeSide',
	    value: function removeSide(id) {
	      var side = this._collection.find(function (side) {
	        return side.id === id;
	      });
	      var index = this._collection.findIndex(function (side) {
	        return side.id === id;
	      });
	
	      if (!side) return false;
	
	      side.FabricCanvas.clear();
	      side.FabricCanvas = undefined;
	      side.canvas.parentNode.removeChild(side.canvas);
	
	      this.selected = null;
	
	      this._collection.splice(index, 1);
	
	      return true;
	    }
	
	    /**
	     * Empty sides
	     * @return {Array}
	     */
	
	  }, {
	    key: 'empty',
	    value: function empty() {
	      var _this = this;
	
	      var collection = this._collection.map(function (side) {
	        return side.id;
	      });
	
	      collection.forEach(function (id) {
	        _this.removeSide(id);
	      });
	
	      return this._collection;
	    }
	  }]);
	
	  return Sides;
	}();
	
	exports.default = Sides;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _fabric = __webpack_require__(7);
	
	var _DrawTool = __webpack_require__(1);
	
	var _DrawTool2 = _interopRequireDefault(_DrawTool);
	
	var _Items = __webpack_require__(50);
	
	var _Items2 = _interopRequireDefault(_Items);
	
	var _Layers = __webpack_require__(52);
	
	var _Layers2 = _interopRequireDefault(_Layers);
	
	var _errors = __webpack_require__(3);
	
	var _errors2 = _interopRequireDefault(_errors);
	
	var _escapeJSON = __webpack_require__(4);
	
	var _escapeJSON2 = _interopRequireDefault(_escapeJSON);
	
	var _colorPicker = __webpack_require__(53);
	
	var _colorPicker2 = _interopRequireDefault(_colorPicker);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Side class
	 */
	var Side = function () {
	
	  /**
	   * Side constructor
	   * @param id {String}
	   */
	  function Side(id) {
	    _classCallCheck(this, Side);
	
	    var that = this;
	
	    /**
	     *
	     * @type {String}
	     */
	    this.id = id;
	
	    /**
	     *
	     * @type {HTMLElement}
	     */
	    this.container = document.createElement('div');
	
	    /**
	     *
	     * @type {HTMLElement}
	     */
	    this.canvas = document.createElement('canvas');
	
	    /**
	     * @type {Number}
	     */
	    this.padding = 10;
	
	    /**
	     * Canvas panning
	     * @default false
	     * @type {Boolean}
	     */
	    this._panning = false;
	
	    /**
	     * Backdrop image url
	     * @type {string}
	     */
	    this.imageUrl = null;
	
	    this.container.width = _DrawTool2.default.container.size.width || _DrawTool2.default.container.target.clientWidth;
	    this.container.height = _DrawTool2.default.container.size.height || _DrawTool2.default.container.target.clientHeight;
	    this.container.style.position = 'absolute';
	    this.container.style.top = '0';
	    this.container.style.left = '0';
	
	    this.canvas.width = _DrawTool2.default.container.size.width || _DrawTool2.default.container.target.clientWidth;
	    this.canvas.height = _DrawTool2.default.container.size.height || _DrawTool2.default.container.target.clientHeight;
	
	    this.container.appendChild(this.canvas);
	
	    _DrawTool2.default.container.target.appendChild(this.container);
	
	    this._initFabric();
	    this._initEvents();
	
	    this.items = new _Items2.default(this);
	
	    this.layers = new _Layers2.default(this);
	
	    this.currentBrush = 'PencilBrush';
	
	    this.colorPicker = new _colorPicker2.default(this);
	
	    return this;
	  }
	
	  _createClass(Side, [{
	    key: 'setImage',
	
	
	    /**
	     * Set side image
	     * @param {String} url
	     * @param size {Object} size
	     * @param size.width {Number} Width of image in centimeters
	     * @param size.height {Number} Height of image in centimeters
	     * @return {Promise}
	     */
	    value: function setImage(url, size) {
	      var _this = this;
	
	      this.image = _extends({}, size);
	
	      this.imageUrl = url;
	
	      var center = this.FabricCanvas.getCenter();
	
	      return new Promise(function (resolve, reject) {
	
	        _this.FabricCanvas.setBackgroundColor('#ffffff');
	
	        _this.FabricCanvas.setBackgroundImage(url, function (img) {
	
	          _this.backdrop = _this.FabricCanvas.backgroundImage;
	
	          _this.backdrop.excludeFromExport = true;
	
	          if (_this.FabricCanvas.width >= _this.FabricCanvas.height) {
	            _this.backdrop.scaleToWidth(_this.FabricCanvas.height - _this.padding * window.devicePixelRatio);
	          } else {
	            _this.backdrop.scaleToHeight(_this.FabricCanvas.width - _this.padding * window.devicePixelRatio);
	          }
	
	          _this.cmSize = _this._calculateSize();
	
	          _this._initGrid();
	          _this._initRuler();
	
	          _this.FabricCanvas.renderAll();
	
	          _DrawTool2.default.trigger('backdrop:loaded', { side: { id: _this.id } });
	
	          _DrawTool2.default.history.pushState(_this.id);
	          resolve({ side: { id: _this.id } });
	        }, {
	          top: center.top,
	          left: center.left,
	          originX: 'center',
	          originY: 'center',
	          opacity: 0.5,
	          crossOrigin: 'anonymous'
	        });
	      });
	    }
	
	    /**
	     * Update image size
	     * @param size
	     * @param size {Object} size
	     * @param size.width {Number} Width of image in centimeters
	     * @param size.height {Number} Height of image in centimeters
	     */
	
	  }, {
	    key: 'updateSize',
	    value: function updateSize(size) {
	
	      this.image = _extends({}, size);
	
	      this.cmSize = this._calculateSize();
	
	      this._initGrid();
	      this._initRuler();
	
	      if (this.FabricBorder) {
	        this._initWorkspaceGrid();
	        this._initWorkspaceRuler();
	      }
	
	      return this;
	    }
	
	    /**
	     * Remove image
	     */
	
	  }, {
	    key: 'removeImage',
	    value: function removeImage() {
	      this.FabricCanvas.remove(this.backdrop);
	      this.backdrop = undefined;
	      this.FabricCanvas.renderAll();
	      return this;
	    }
	
	    /**
	     *
	     * @param options {Object} options
	     * @param options.width {Number} Width of border
	     * @param options.height {Number} Height of border
	     * @param options.top {Number} Top position
	     * @param options.left {Number} Left position
	     */
	
	  }, {
	    key: 'setBorder',
	    value: function setBorder(options) {
	
	      if (!this.cmSize) {
	        throw new Error(JSON.stringify({ error: _errors2.default.sideNoSize }));
	        return false;
	      }
	
	      if (!options) {
	        return false;
	      }
	
	      if (this.FabricBorder) {
	        this.FabricBorder.remove();
	      }
	
	      this.border = options;
	
	      var _opts = {
	        strokeWidth: 1,
	        stroke: 'rgba(100,200,200,1)',
	        fill: '',
	        hasRotatingPoint: false,
	        lockRotation: true
	      };
	
	      var paddingTop = (this.FabricCanvas.height - this.backdrop.height * this.backdrop.scaleY) / 2;
	      var paddingLeft = (this.FabricCanvas.width - this.backdrop.width * this.backdrop.scaleX) / 2;
	
	      var _options = {
	        width: options.width * this.cmSize.width,
	        height: options.height * this.cmSize.height,
	        top: options.top * this.cmSize.height + paddingTop,
	        left: options.left * this.cmSize.width + paddingLeft
	      };
	
	      this.FabricBorder = new _fabric.fabric.Rect(_extends({}, _opts, _options));
	
	      this.FabricBorder.setCoords();
	      this.FabricBorder.id = 'FabricBorder';
	
	      this.FabricBorder.excludeFromExport = true;
	      this.FabricBorder.selectable = _DrawTool2.default.editable;
	      this.FabricBorder.hoverCursor = 'default';
	
	      this.FabricCanvas.add(this.FabricBorder);
	      this.center = this.FabricBorder.getCenterPoint();
	
	      this.FabricCanvas.renderAll();
	
	      this._initWorkspaceGrid();
	      this._initWorkspaceRuler();
	
	      return this;
	    }
	
	    /**
	     * Get border
	     * @return {{left: number, top: number, width: number, height: number}}
	     */
	
	  }, {
	    key: 'getBorder',
	    value: function getBorder() {
	
	      var paddingTop = (this.FabricCanvas.height - this.backdrop.height * this.backdrop.scaleY) / 2;
	      var paddingLeft = (this.FabricCanvas.width - this.backdrop.width * this.backdrop.scaleX) / 2;
	
	      var border = {
	        left: (this.FabricBorder.left - paddingLeft) / this.cmSize.width,
	        top: (this.FabricBorder.top - paddingTop) / this.cmSize.height,
	        width: this.FabricBorder.width * this.FabricBorder.scaleX / this.cmSize.width,
	        height: this.FabricBorder.height * this.FabricBorder.scaleY / this.cmSize.height,
	        _real: {
	          left: this.FabricBorder.left - paddingLeft,
	          top: this.FabricBorder.top - paddingTop,
	          width: this.FabricBorder.width * this.FabricBorder.scaleX,
	          height: this.FabricBorder.height * this.FabricBorder.scaleY
	        }
	      };
	
	      return border;
	    }
	  }, {
	    key: 'zoomToVal',
	    value: function zoomToVal(val) {
	      var center = this.FabricBorder.getCenterPoint();
	      this.FabricCanvas.zoomToPoint(center, val);
	      return this;
	    }
	
	    /**
	     * Zoom relative to border
	     * @return {Side}
	     */
	
	  }, {
	    key: 'zoomIn',
	    value: function zoomIn() {
	      var zoom = this.FabricCanvas.getZoom();
	      if (zoom <= 2) {
	        var center = this.FabricBorder.getCenterPoint();
	        this.FabricCanvas.zoomToPoint(center, zoom + 0.1);
	      }
	      return this;
	    }
	
	    /**
	     * Zoom relative to border
	     * @return {Side}
	     */
	
	  }, {
	    key: 'zoomOut',
	    value: function zoomOut() {
	      var zoom = this.FabricCanvas.getZoom();
	      if (zoom >= 0.2) {
	        var center = this.FabricBorder.getCenterPoint();
	        this.FabricCanvas.zoomToPoint(center, zoom - 0.1);
	      }
	      return this;
	    }
	
	    /**
	     * Zoom relative to viewport
	     * @return {Side}
	     */
	
	  }, {
	    key: 'zoomInVP',
	    value: function zoomInVP() {
	      var zoom = this.FabricCanvas.getZoom();
	      var center = this.FabricCanvas.getVpCenter();
	      this.FabricCanvas.zoomToPoint(center, zoom + 0.1);
	
	      return this;
	    }
	
	    /**
	     * Zoom relative to viewport
	     * @return {Side}
	     */
	
	  }, {
	    key: 'zoomOutVP',
	    value: function zoomOutVP() {
	      var zoom = this.FabricCanvas.getZoom();
	      var center = this.FabricCanvas.getVpCenter();
	      this.FabricCanvas.zoomToPoint(center, zoom - 0.1);
	
	      return this;
	    }
	
	    /**
	     * Get
	     * @return {Object}
	     */
	
	  }, {
	    key: 'toObject',
	    value: function toObject() {
	      var _this2 = this;
	
	      var _formattedSide = {
	        id: this.id,
	        imageUrl: this.imageUrl,
	        size: this.image,
	        canvas: this.FabricCanvas.toObject(['brush', 'editable', 'vertical'])
	      };
	
	      _formattedSide.canvas.objects.forEach(function (item) {
	        item.left = item.left - _this2.center.x;
	        item.top = item.top - _this2.center.y;
	
	        if (item.selected) {
	          item.selectable = false;
	        }
	      });
	
	      if (this.backdrop) {
	
	        _formattedSide.imageUrl = this.imageUrl;
	      }
	
	      if (this.FabricBorder) {
	
	        _formattedSide.border = this.getBorder();
	      }
	
	      return _formattedSide;
	    }
	
	    /**
	     * Get
	     * @return {String}
	     */
	
	  }, {
	    key: 'toJSON',
	    value: function toJSON() {
	      return JSON.stringify(this.toObject());
	    }
	
	    /**
	     *
	     * @param {String} json
	     */
	
	  }, {
	    key: 'fromJSON',
	    value: function fromJSON(json) {
	      var _this3 = this;
	
	      var data = JSON.parse((0, _escapeJSON2.default)(json));
	
	      this._removeEvents();
	
	      this.items._collection = [];
	
	      var canvasData = JSON.stringify({ objects: data.canvas.objects });
	
	      this.FabricCanvas.loadFromJSON(canvasData, function () {
	        _this3.setBorder(_this3.border);
	        _this3.FabricBorder.sendToBack();
	        _this3.FabricCanvas.renderAll.bind(_this3.FabricCanvas);
	        _this3._initEvents();
	      }, function (o, item) {
	
	        var diffW = _this3.FabricBorder.width / data.border._real.width;
	        var diffH = _this3.FabricBorder.height / data.border._real.height;
	        var diffX = _this3.FabricBorder.width / data.border._real.width;
	        var diffY = _this3.FabricBorder.height / data.border._real.height;
	
	        item.set({
	          left: _this3.center.x + item.left * diffX,
	          top: _this3.center.y + item.top * diffY,
	          width: item.width * diffW,
	          height: item.height * diffH
	        });
	
	        if (item.type === 'textbox') {
	          item.set({
	            scaleX: diffX,
	            scaleY: diffY
	          });
	        };
	
	        _this3.items._collection.push(item);
	      });
	    }
	
	    /**
	     *
	     */
	
	  }, {
	    key: 'toSVG',
	    value: function toSVG(callback) {
	      var _this4 = this;
	
	      if (!this.cmSize) {
	        throw new Error(JSON.stringify({ error: _errors2.default.sideNoSize }));
	        return false;
	      }
	
	      if (!this.FabricBorder) {
	        throw new Error(JSON.stringify({ error: _errors2.default.sideNoBorder }));
	        return false;
	      }
	
	      this.FabricCanvas.clone(function (clone) {
	
	        clone.forEachObject(function (item) {
	          if (item.type === 'textbox') {
	            item.clipTo = null;
	            var base64 = item.toDataURL({ enableRetina: true });
	            var image = new Image();
	            image.src = base64;
	            var fabricImage = new _fabric.fabric.Image(image, {
	              top: item.top,
	              left: item.left,
	              width: item.width,
	              height: item.height,
	              originX: 'center',
	              originY: 'center'
	            });
	            item = fabricImage;
	            fabricImage.setCoords();
	            clone.renderAll();
	          }
	        });
	
	        var svg = clone.toSVG({
	          suppressPreamble: true,
	          viewBox: {
	            x: _this4.FabricBorder.left,
	            y: _this4.FabricBorder.top,
	            width: _this4.FabricBorder.width,
	            height: _this4.FabricBorder.height
	          }
	        }, function (el) {
	          if (!el.includes(_this4.imageUrl)) {
	            return el;
	          }
	        });
	
	        var parser = new DOMParser();
	        var doc = parser.parseFromString(svg, "image/svg+xml");
	
	        var svgObj = doc.getElementsByTagName('svg')[0];
	
	        svgObj.setAttribute('width', _this4.FabricBorder.width);
	        svgObj.setAttribute('height', _this4.FabricBorder.height);
	
	        var container = document.createElement('div');
	
	        container.appendChild(svgObj);
	
	        callback && callback(container.innerHTML);
	      });
	    }
	
	    /**
	     *
	     * @return {String} Base 64 representation of canvas
	     */
	
	  }, {
	    key: 'getPreview',
	    value: function getPreview() {
	
	      this.FabricBorder.setVisible(false);
	
	      var preview = this.FabricCanvas.toDataURL({
	        multiplier: 0.5
	      });
	      this.FabricBorder.setVisible(true);
	
	      this.FabricCanvas.renderAll();
	
	      return preview;
	    }
	
	    /**
	     *
	     * @return {String} Base 64 representation of canvas
	     */
	
	  }, {
	    key: 'getImagePreview',
	    value: function getImagePreview() {
	
	      this.FabricBorder.setVisible(false);
	      this.backdrop.setVisible(false);
	
	      var preview = this.FabricCanvas.toDataURL({
	        multiplier: 0.5
	      });
	      this.FabricBorder.setVisible(true);
	      this.backdrop.setVisible(true);
	
	      this.FabricCanvas.renderAll();
	
	      return preview;
	    }
	  }, {
	    key: 'drawingMode',
	    value: function drawingMode(val) {
	      if (val === undefined) {
	        return this.FabricCanvas.isDrawingMode;
	      }
	
	      if (this.panning === true) {
	        return false;
	      }
	
	      this.FabricCanvas.isDrawingMode = val;
	      this.FabricCanvas.freeDrawingBrush = new _fabric.fabric.PencilBrushC(this.FabricCanvas, { color: '#000000' });
	      this.currentBrush = 'PencilBrush';
	    }
	
	    /**
	     * @private
	     */
	
	  }, {
	    key: '_initFabric',
	    value: function _initFabric() {
	
	      this.FabricCanvas = new _fabric.fabric.Canvas(this.canvas, {
	        selection: false,
	        enableRetinaScaling: true,
	        controlsAboveOverlay: true
	      });
	
	      this.FabricCanvas.wrapperEl.style.display = 'none';
	
	      this.FabricCanvas.upperCanvasEl.style['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
	      this.FabricCanvas.lowerCanvasEl.style['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
	    }
	
	    /**
	     * @private
	     */
	
	  }, {
	    key: '_initEvents',
	    value: function _initEvents() {
	      var _this5 = this;
	
	      this.FabricCanvas.on({
	        'object:added': function objectAdded(e) {
	          _DrawTool2.default.trigger('object:added', { side: { id: _this5.id } });
	        },
	        'selection:cleared': function selectionCleared(e) {
	          if (_this5.items.selected.item) {
	            _this5.items.selected.item.selected = false;
	          }
	          _this5.items.selected.item = null;
	          _DrawTool2.default.trigger('selection:cleared', e);
	        },
	        'selection:created': function selectionCreated(e) {
	          _DrawTool2.default.trigger('selection:created', e);
	        },
	        'object:selected': function objectSelected(e) {
	          if (e.target.id === 'FabricBorder') {
	            e.target.setCoords();
	            _this5.center = _this5.FabricBorder.getCenterPoint();
	          }
	          _this5.items.selected.item = e.target;
	          _this5.items.selected.item.selected = true;
	          _DrawTool2.default.trigger('object:selected', { side: { id: _this5.id }, isWorkSpaceBorder: e.target.id === 'FabricBorder' });
	        },
	        'object:modified': function objectModified(e) {
	          if (e.target.id === 'FabricBorder') {
	            e.target.setCoords();
	            _this5.center = _this5.FabricBorder.getCenterPoint();
	            _this5._initWorkspaceGrid();
	            _this5._initWorkspaceRuler();
	          }
	          _DrawTool2.default.trigger('object:modified', { side: { id: _this5.id }, isWorkSpaceBorder: e.target.id === 'FabricBorder' });
	          _DrawTool2.default.trigger('history:update', { side: { id: _this5.id } });
	        },
	        'object:removed': function objectRemoved() {
	          _DrawTool2.default.trigger('object:removed', { side: { id: _this5.id } });
	          _DrawTool2.default.trigger('history:update', { side: { id: _this5.id } });
	        },
	        'editing:exited': function editingExited() {
	          _DrawTool2.default.trigger('editing:exited', { side: { id: _this5.id } });
	        },
	        'editing:entered': function editingEntered() {
	          _DrawTool2.default.trigger('editing:entered', { side: { id: _this5.id } });
	        },
	        'mouse:up': function mouseUp(e) {
	          _this5._panningDown = false;
	        },
	        'mouse:down': function mouseDown(e) {
	          _this5._panningDown = true;
	
	          _this5._pan_x0 = e.e.layerX;
	          _this5._pan_y0 = e.e.layerY;
	
	          if (_this5.colorPicker.active) {
	            _this5.colorPicker.move(e);
	            _DrawTool2.default.trigger('colorpicker:update', _this5.colorPicker.color);
	          }
	        },
	        'mouse:move': function mouseMove(e) {
	          if (!!(_this5._panning && _this5._panningDown && e && e.e)) {
	
	            var x = e.e.layerX;
	            var y = e.e.layerY;
	            _this5.FabricCanvas.relativePan({ x: x - _this5._pan_x0, y: y - _this5._pan_y0 });
	            _this5._pan_x0 = e.e.layerX;
	            _this5._pan_y0 = e.e.layerY;
	            // var delta = new fabric.Point(e.e.movementX, e.e.movementY);
	            // this.FabricCanvas.relativePan(delta);
	          }
	          if (_this5.colorPicker.active) {
	            _this5.colorPicker.move(e);
	          }
	        },
	        'object:scaling': function objectScaling(e) {
	          var obj = e.target;
	
	          if (obj.type === 'path-group') {
	            return false;
	          }
	
	          var w = obj.width * obj.scaleX;
	          var h = obj.height * obj.scaleY;
	          var s = obj.strokeWidth;
	
	          obj.set({
	            'height': h,
	            'width': w,
	            'scaleX': 1,
	            'scaleY': 1
	          });
	        }
	      });
	    }
	  }, {
	    key: '_removeEvents',
	    value: function _removeEvents() {
	      this.FabricCanvas.off();
	    }
	
	    /**
	     *
	     * @private
	     */
	
	  }, {
	    key: '_initGrid',
	    value: function _initGrid() {
	
	      if (!this.cmSize) {
	        throw new Error(JSON.stringify({ error: _errors2.default.sideNoSize }));
	        return false;
	      }
	
	      var state;
	
	      if (this.grid) {
	        state = this.grid.visible;
	        this.grid.destroy();
	        this.FabricCanvas.remove(this.grid);
	      } else {
	        state = false;
	      }
	
	      var cm = this.cmSize;
	
	      var stepX = cm.width;
	      var stepY = cm.height;
	
	      this.grid = new _fabric.fabric.Group(null, {
	        excludeFromExport: true,
	        hasControls: false,
	        hoverCursor: 'default',
	        selectable: false
	      });
	
	      for (var x = 0; x <= this.FabricCanvas.width; x += stepX) {
	        this.grid.add(new _fabric.fabric.Line([x, 0, x, this.FabricCanvas.height], { stroke: 'rgba(150, 150, 150, 0.1)', selectable: false, hoverCursor: 'default' }));
	      }
	
	      for (var y = 0; y <= this.FabricCanvas.height; y += stepY) {
	        this.grid.add(new _fabric.fabric.Line([0, y, this.FabricCanvas.width, y], { stroke: 'rgba(150, 150, 150, 0.1)', selectable: false, hoverCursor: 'default' }));
	      }
	
	      this.FabricCanvas.add(this.grid);
	
	      this.grid.sendToBack();
	
	      this.grid.enable = function () {
	        var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	
	        this.setVisible(val);
	        this.canvas.renderAll();
	      };
	
	      this.grid.setVisible(state);
	      this.FabricCanvas.renderAll();
	    }
	
	    /**
	     *
	     * @private
	     */
	
	  }, {
	    key: '_initRuler',
	    value: function _initRuler() {
	
	      if (!this.cmSize) {
	        throw new Error(JSON.stringify({ error: _errors2.default.sideNoSize }));
	        return false;
	      }
	
	      var state;
	
	      if (this.ruler) {
	        state = this.ruler.visible;
	        this.ruler.destroy();
	        this.FabricCanvas.remove(this.ruler);
	      } else {
	        state = false;
	      }
	
	      var cm = this.cmSize;
	
	      var stepX = cm.width;
	      var stepY = cm.height;
	
	      this.ruler = new _fabric.fabric.Group(null, {
	        excludeFromExport: true,
	        hasControls: false,
	        hoverCursor: 'default',
	        selectable: false
	      });
	
	      for (var x = stepX * 2; x <= this.FabricCanvas.width; x += stepX) {
	        this.ruler.add(new _fabric.fabric.Line([x, 0, x, stepY * 2], { stroke: 'rgba(0, 0, 0, 0.2)', selectable: false, hoverCursor: 'default' }));
	      }
	
	      for (var y = stepY * 2; y <= this.FabricCanvas.height; y += stepY) {
	        this.ruler.add(new _fabric.fabric.Line([0, y, stepX * 2, y], { stroke: 'rgba(0, 0, 0, 0.2)', selectable: false, hoverCursor: 'default' }));
	      }
	
	      this.FabricCanvas.add(this.ruler);
	
	      this.ruler.enable = function () {
	        var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	
	        this.setVisible(val);
	        this.canvas.renderAll();
	      };
	
	      this.ruler.setVisible(state);
	      this.FabricCanvas.renderAll();
	    }
	
	    /**
	     *
	     * @private
	     */
	
	  }, {
	    key: '_initWorkspaceGrid',
	    value: function _initWorkspaceGrid() {
	
	      if (!this.cmSize) {
	        throw new Error(JSON.stringify({ error: _errors2.default.sideNoSize }));
	        return false;
	      }
	
	      var state;
	
	      if (this.workspaceGrid) {
	        state = this.workspaceGrid.visible;
	        this.workspaceGrid.destroy();
	        this.FabricCanvas.remove(this.workspaceGrid);
	      } else {
	        state = false;
	      }
	
	      var cm = this.cmSize;
	
	      this.workspaceGrid = new _fabric.fabric.Group(null, {
	        excludeFromExport: true,
	        hasControls: false,
	        hoverCursor: 'default',
	        selectable: false
	      });
	
	      for (var x = this.FabricBorder.left; x <= this.FabricBorder.left + this.FabricBorder.width; x += cm.width) {
	        this.workspaceGrid.add(new _fabric.fabric.Line([x, this.FabricBorder.top, x, this.FabricBorder.top + this.FabricBorder.height], { stroke: 'rgba(150, 150, 150, 0.2)', selectable: false, hoverCursor: 'default' }));
	      }
	
	      for (var y = this.FabricBorder.top; y <= this.FabricBorder.top + this.FabricBorder.height; y += cm.height) {
	        this.workspaceGrid.add(new _fabric.fabric.Line([this.FabricBorder.left, y, this.FabricBorder.left + this.FabricBorder.width, y], { stroke: 'rgba(150, 150, 150, 0.2)', selectable: false, hoverCursor: 'default' }));
	      }
	
	      this.FabricCanvas.add(this.workspaceGrid);
	
	      this.grid.sendToBack();
	
	      this.workspaceGrid.enable = function () {
	        var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	
	        this.setVisible(val);
	        this.canvas.renderAll();
	      };
	
	      this.workspaceGrid.setVisible(state);
	      this.FabricCanvas.renderAll();
	    }
	
	    /**
	     *
	     * @private
	     */
	
	  }, {
	    key: '_initWorkspaceRuler',
	    value: function _initWorkspaceRuler() {
	
	      if (!this.cmSize) {
	        throw new Error(JSON.stringify({ error: _errors2.default.sideNoSize }));
	        return false;
	      }
	
	      var state;
	
	      if (this.workspaceRuler) {
	        state = this.workspaceRuler.visible;
	        this.workspaceRuler.destroy();
	        this.FabricCanvas.remove(this.workspaceRuler);
	      } else {
	        state = false;
	      }
	
	      var cm = this.cmSize;
	
	      this.workspaceRuler = new _fabric.fabric.Group(null, {
	        excludeFromExport: true,
	        hasControls: false,
	        hoverCursor: 'default',
	        selectable: false
	      });
	
	      for (var x = this.FabricBorder.left; x <= this.FabricBorder.left + this.FabricBorder.width; x += cm.width) {
	        this.workspaceRuler.add(new _fabric.fabric.Line([x, cm.height, x, cm.height * 2], { stroke: 'rgba(0, 0, 0, 0.2)', selectable: false, hoverCursor: 'default' }));
	      }
	
	      for (var y = this.FabricBorder.top; y <= this.FabricBorder.top + this.FabricBorder.height; y += cm.height) {
	        this.workspaceRuler.add(new _fabric.fabric.Line([cm.width, y, cm.width * 2, y], { stroke: 'rgba(0, 0, 0, 0.2)', selectable: false, hoverCursor: 'default' }));
	      }
	
	      this.workspaceRuler.add(new _fabric.fabric.Line([this.FabricBorder.left, cm.height * 1.5, this.FabricBorder.left + this.FabricBorder.width, cm.height * 1.5], { stroke: 'rgba(0, 0, 0, 0.2)', selectable: false, hoverCursor: 'default' }));
	      this.workspaceRuler.add(new _fabric.fabric.Line([cm.width * 1.5, this.FabricBorder.top, cm.width * 1.5, this.FabricBorder.top + this.FabricBorder.height], { stroke: 'rgba(0, 0, 0, 0.2)', selectable: false, hoverCursor: 'default' }));
	
	      this.FabricCanvas.add(this.workspaceRuler);
	
	      this.workspaceRuler.enable = function () {
	        var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	
	        this.setVisible(val);
	        this.canvas.renderAll();
	      };
	
	      this.workspaceRuler.setVisible(state);
	      this.FabricCanvas.renderAll();
	    }
	
	    /**
	     * Calculate pixels in centimeter
	     * @return {Object} {width: Number, height: Number}
	     * @private
	     */
	
	  }, {
	    key: '_calculateSize',
	    value: function _calculateSize() {
	      this.cmSize = {
	        width: this.backdrop.width * this.backdrop.scaleX / this.image.width,
	        height: this.backdrop.height * this.backdrop.scaleY / this.image.height
	      };
	      return this.cmSize;
	    }
	  }, {
	    key: 'setPadding',
	    value: function setPadding(number) {
	      if (typeof number !== 'number') return false;
	
	      this.padding = number;
	
	      if (this.backdrop) {
	
	        if (this.backdrop.width >= this.backdrop.height) {
	          this.backdrop.scaleToWidth(this.FabricCanvas.width - this.padding * window.devicePixelRatio);
	        } else {
	          this.backdrop.scaleToHeight(this.FabricCanvas.height - this.padding * window.devicePixelRatio);
	        }
	
	        this._calculateSize();
	
	        this._initGrid();
	        this._initRuler();
	
	        if (this.FabricBorder) {
	          this._initWorkspaceGrid();
	          this._initWorkspaceRuler();
	
	          this.setBorder(this.border);
	        }
	
	        this.FabricCanvas.renderAll();
	      }
	    }
	  }, {
	    key: 'loadFromJSON',
	    value: function loadFromJSON(json) {
	      var _this6 = this;
	
	      this.FabricCanvas.loadFromJSON(json, function () {
	        return _this6._update();
	      });
	    }
	  }, {
	    key: '_update',
	    value: function _update() {
	      if (this.backdrop) {
	        this.FabricCanvas.backgroundImage.scaleX = this.backdrop.scaleX;
	        this.FabricCanvas.backgroundImage.scaleY = this.backdrop.scaleY;
	      }
	      if (this.FabricBorder) {
	        this.FabricCanvas.add(this.FabricBorder);
	        this.FabricBorder.sendToBack();
	      }
	      if (this.ruler) {
	        this.FabricCanvas.add(this.ruler);
	        this.ruler.setVisible(this.ruler.visible);
	      }
	      if (this.grid) {
	        this.FabricCanvas.add(this.grid);
	        this.grid.setVisible(this.grid.visible);
	      }
	
	      this.FabricCanvas.renderAll();
	    }
	  }, {
	    key: 'panning',
	    set: function set(val) {
	      if (Boolean(val) === true && this.FabricCanvas.isDrawingMode === true) {
	        return this._panning = false;
	      }
	      this.items.selected.deactivate();
	      this.items._collection.forEach(function (object) {
	        return object.selectable = !val;
	      });
	      return this._panning = val;
	    },
	    get: function get() {
	      return this._panning;
	    }
	  }]);
	
	  return Side;
	}();
	
	exports.default = Side;

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _fabric = __webpack_require__(7);
	
	var _DrawTool = __webpack_require__(1);
	
	var _DrawTool2 = _interopRequireDefault(_DrawTool);
	
	var _Item = __webpack_require__(51);
	
	var _Item2 = _interopRequireDefault(_Item);
	
	var _clip = __webpack_require__(5);
	
	var _clip2 = _interopRequireDefault(_clip);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Items collection
	 */
	var Items = function () {
	
	  /**
	   *
	   * @param side
	   */
	  function Items(side) {
	    _classCallCheck(this, Items);
	
	    this.side = side;
	    this._collection = [];
	
	    this.selected = new _Item2.default(this.side);
	  }
	
	  /**
	   * Load a SVG image and parse as FabricJS object
	   * @param {String} url
	   */
	
	
	  _createClass(Items, [{
	    key: 'addSVG',
	    value: function addSVG(url, fill) {
	      var _this = this;
	
	      _fabric.fabric.loadSVGFromURL(url, function (objects, options) {
	
	        var loadedObject = _fabric.fabric.util.groupSVGElements(objects, options);
	
	        loadedObject.set({
	          'left': _this.side.center.x,
	          'top': _this.side.center.y,
	          'originX': 'center',
	          'originY': 'center',
	          'fill': fill || '#000000',
	          clipTo: (0, _clip2.default)(_DrawTool2.default.sides.selected.FabricBorder)
	        });
	
	        if (loadedObject.width >= loadedObject.height) {
	          loadedObject.scaleToWidth(_this.side.FabricBorder.width);
	        } else {
	          loadedObject.scaleToHeight(_this.side.FabricBorder.height);
	        }
	
	        loadedObject.setCoords();
	
	        _this.side.FabricCanvas.add(loadedObject);
	
	        _this._collection.push(loadedObject);
	
	        _this.triggerCreated();
	
	        _this.side.FabricCanvas.renderAll();
	      });
	    }
	
	    /**
	     * Load a image and parse as FabricJS object
	     * @param url
	     */
	
	  }, {
	    key: 'addImage',
	    value: function addImage(url) {
	      var _this2 = this;
	
	      _fabric.fabric.Image.fromURL(url, function (oImg) {
	
	        oImg.set({
	          'left': _this2.side.center.x,
	          'top': _this2.side.center.y,
	          'originX': 'center',
	          'originY': 'center',
	          crossOrigin: 'anonymous',
	          clipTo: (0, _clip2.default)(_DrawTool2.default.sides.selected.FabricBorder)
	        });
	
	        if (oImg.width >= oImg.height) {
	          oImg.scaleToWidth(_this2.side.FabricBorder.width);
	        } else {
	          oImg.scaleToHeight(_this2.side.FabricBorder.height);
	        }
	
	        oImg.setCoords();
	
	        _this2.side.FabricCanvas.add(oImg);
	
	        _this2._collection.push(oImg);
	
	        _this2.triggerCreated();
	
	        _this2.side.FabricCanvas.renderAll();
	      }, {
	        crossOrigin: 'anonymous'
	      });
	    }
	
	    /**
	     *
	     * @param options
	     * @param options.fontSize {Number} Font size px
	     * @param options.fill {String} Font color: Rgb, hex
	     * @param options.fontFamily {String} Font family
	     * @param options.fontStyle {String} Font style. Possible values: "", "normal", "italic" or "oblique".
	     * @param options.fontWeight {String} Font weight (e.g. bold, normal, 400, 600, 800)
	     * @param options.textAlign {String} Text alignment. Possible values: "left", "center", "right" or "justify".
	     * @param options.editable {Boolean} Text can be edited by double click.
	     * @param txt {String} Text content
	     *
	     */
	
	  }, {
	    key: 'addText',
	    value: function addText(options, txt) {
	
	      var _options = Object.assign({
	        fontSize: 24,
	        fontFamily: 'serif',
	        fontStyle: 'normal',
	        fontWeight: 'normal',
	        fill: '#000000',
	        textAlign: 'center',
	        editable: true,
	        vertical: false
	      }, options);
	
	      var text = new _fabric.fabric.Textbox(txt || 'Text', _extends({
	        left: this.side.center.x,
	        top: this.side.center.y,
	        originX: 'center',
	        originY: 'center',
	        // width: this.side.FabricBorder.width,
	        editable: true,
	        clipTo: (0, _clip2.default)(_DrawTool2.default.sides.selected.FabricBorder)
	      }, _options));
	
	      this.side.FabricCanvas.add(text);
	
	      text.vertical = _options.vertical;
	
	      this._collection.push(text);
	
	      this.triggerCreated();
	
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.setActiveObject(text);
	
	      return text;
	    }
	
	    /**
	     * Remove items
	     */
	
	  }, {
	    key: 'empty',
	    value: function empty() {
	      this._collection.forEach(function (item) {
	        item.remove();
	      });
	
	      this.side.FabricCanvas.trigger('object:removed');
	      this._collection = [];
	
	      this.side.FabricCanvas.renderAll();
	    }
	  }, {
	    key: 'eraserEnable',
	    value: function eraserEnable() {
	      this.side.FabricCanvas.isDrawingMode = true;
	      this.side.FabricCanvas.freeDrawingBrush = new _fabric.fabric.Eraser(this.side.FabricCanvas);
	    }
	  }, {
	    key: 'eraserDisable',
	    value: function eraserDisable() {
	      this.side.FabricCanvas.freeDrawingBrush = new _fabric.fabric.PencilBrushC(this.side.FabricCanvas);
	      this.side.FabricCanvas.isDrawingMode = false;
	    }
	  }, {
	    key: 'pencilBrush',
	    value: function pencilBrush(options) {
	      this.side.FabricCanvas.freeDrawingBrush = new _fabric.fabric.PencilBrushC(this.side.FabricCanvas, options);
	      this.side.currentBrush = 'PencilBrush';
	    }
	  }, {
	    key: 'crayonBrush',
	    value: function crayonBrush(options) {
	      this.side.FabricCanvas.freeDrawingBrush = new _fabric.fabric.CrayonBrush(this.side.FabricCanvas, options);
	      this.side.currentBrush = 'CrayonBrush';
	    }
	  }, {
	    key: 'inkBrush',
	    value: function inkBrush(options) {
	      this.side.FabricCanvas.freeDrawingBrush = new _fabric.fabric.InkBrush(this.side.FabricCanvas, options);
	      this.side.currentBrush = 'InkBrush';
	    }
	  }, {
	    key: 'markerBrush',
	    value: function markerBrush(options) {
	      this.side.FabricCanvas.freeDrawingBrush = new _fabric.fabric.MarkerBrush(this.side.FabricCanvas, options);
	      this.side.currentBrush = 'MarkerBrush';
	    }
	  }, {
	    key: 'sprayBrush',
	    value: function sprayBrush(options) {
	      this.side.FabricCanvas.freeDrawingBrush = new _fabric.fabric.SprayBrush(this.side.FabricCanvas, options);
	      this.side.currentBrush = 'SprayBrush';
	    }
	  }, {
	    key: 'customBrush',
	    value: function customBrush(options) {
	      this.side.FabricCanvas.freeDrawingBrush = new _fabric.fabric.CustomBrush(this.side.FabricCanvas, options);
	      this.side.currentBrush = 'CustomBrush';
	    }
	  }, {
	    key: 'finalizeBrush',
	    value: function finalizeBrush() {
	      this.side.FabricCanvas.freeDrawingBrush.finalize();
	    }
	  }, {
	    key: 'brushOptions',
	    value: function brushOptions(options) {
	      var _o = {
	        color: this.side.FabricCanvas.freeDrawingBrush.color,
	        width: this.side.FabricCanvas.freeDrawingBrush.width,
	        opacity: this.side.FabricCanvas.freeDrawingBrush.opacity
	      };
	
	      if (options === undefined) {
	        return _o;
	      }
	
	      var o = _extends({}, _o, options);
	
	      this.side.FabricCanvas.freeDrawingBrush.changeColor(o.color);
	      this.side.FabricCanvas.freeDrawingBrush.changeOpacity(o.opacity);
	      this.side.FabricCanvas.freeDrawingBrush.width = o.width;
	    }
	  }, {
	    key: 'triggerCreated',
	    value: function triggerCreated() {
	      _DrawTool2.default.trigger('history:update', { side: { id: this.side.id } });
	    }
	  }]);
	
	  return Items;
	}();
	
	exports.default = Items;

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _fabric = __webpack_require__(7);
	
	var _DrawTool = __webpack_require__(1);
	
	var _DrawTool2 = _interopRequireDefault(_DrawTool);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Item = function () {
	  function Item(side) {
	    _classCallCheck(this, Item);
	
	    this.side = side;
	
	    this.item = null;
	  }
	
	  /**
	   *
	   * @return {{type: string, top: number, left: number, width: number, height: number}}
	   */
	
	
	  _createClass(Item, [{
	    key: 'toObject',
	    value: function toObject() {
	
	      if (!this.item) return false;
	
	      var data = {
	        type: this.item.type,
	        top: (this.item.top - this.side.FabricBorder.top) / this.side.cmSize.height,
	        left: (this.item.left - this.side.FabricBorder.left) / this.side.cmSize.width,
	        width: this.item.width / this.side.cmSize.width,
	        height: this.item.height / this.side.cmSize.height,
	        angle: this.item.angle,
	        scale: this.item.scaleX,
	        opacity: this.item.opacity
	      };
	
	      if (this.item.type === 'path') {
	        data.fill = this.item.fill;
	      }
	
	      if (this.item.type === 'textbox') {
	        data.fontFamily = this.item.fontFamily;
	        data.fontStyle = this.item.fontStyle;
	        data.fontWeight = this.item.fontWeight;
	        data.fontSize = this.item.fontSize;
	        data.textAlign = this.item.textAlign;
	        data.fill = this.item.fill;
	      }
	
	      if (this.item.brush) {
	        data.type = 'brush';
	        data.fill = this.item.color;
	      }
	
	      return data;
	    }
	
	    /**
	     * @return {String} JSON representation of toObject()
	     */
	
	  }, {
	    key: 'toJSON',
	    value: function toJSON() {
	      return JSON.stringify(this.toObject());
	    }
	  }, {
	    key: 'deactivate',
	    value: function deactivate() {
	      this.side.FabricCanvas.deactivateAll();
	      this.side.FabricCanvas.renderAll();
	      this.item = null;
	      _DrawTool2.default.trigger('selection:cleared');
	    }
	
	    /**
	     * Remove selected item
	     */
	
	  }, {
	    key: 'remove',
	    value: function remove() {
	      if (!this.item) return;
	
	      this.item.remove();
	      this.deactivate();
	    }
	
	    /**
	     * Get/set rotation angle of selected element
	     * @param val
	     * @return
	     */
	
	  }, {
	    key: 'rotation',
	    value: function rotation(val) {
	      if (!this.item) return;
	
	      if (val === undefined) {
	        return this.item.angle;
	      }
	
	      this.item.setAngle(parseInt(val));
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      return this.item;
	    }
	
	    /**
	     * Get/set position of selected element
	     * @param obj
	     * @return
	     */
	
	  }, {
	    key: 'position',
	    value: function position(obj) {
	
	      if (!this.item) return;
	
	      var position = {
	        top: (this.item.top - this.side.FabricBorder.top) / this.side.cmSize.height,
	        left: (this.item.left - this.side.FabricBorder.left) / this.side.cmSize.width
	      };
	
	      if (!obj) {
	        return position;
	      }
	
	      var _position = _extends({}, position, obj);
	
	      var top = this.side.FabricBorder.top + _position.top * this.side.cmSize.height;
	      var left = this.side.FabricBorder.left + _position.left * this.side.cmSize.width;
	
	      this.item.animate('top', top, {
	        onChange: this.side.FabricCanvas.renderAll.bind(this.side.FabricCanvas)
	      });
	      this.item.animate('left', left, {
	        onChange: this.side.FabricCanvas.renderAll.bind(this.side.FabricCanvas)
	      });
	
	      this.item.setCoords();
	
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      return this.item;
	    }
	  }, {
	    key: 'scale',
	    value: function scale(val) {
	
	      if (!this.item) return false;
	
	      if (val === undefined) {
	        return this.item.scaleX;
	      }
	
	      this.item.scale(parseInt(val));
	
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      return this.item;
	    }
	
	    /**
	     * Get set size of selected element
	     * @param obj
	     * @return
	     */
	
	  }, {
	    key: 'size',
	    value: function size(obj) {
	
	      if (!this.item) return;
	
	      var size = {
	        width: this.item.width / this.side.cmSize.width,
	        height: this.item.height / this.side.cmSize.height
	      };
	
	      if (!obj) {
	        return size;
	      }
	
	      var _size = _extends({}, size, obj);
	
	      this.item.animate('height', _size.height * this.side.cmSize.height, {
	        onChange: this.side.FabricCanvas.renderAll.bind(this.side.FabricCanvas)
	      });
	      this.item.animate('width', _size.width * this.side.cmSize.width, {
	        onChange: this.side.FabricCanvas.renderAll.bind(this.side.FabricCanvas)
	      });
	
	      this.item.setCoords();
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      return this.item;
	    }
	  }, {
	    key: 'fill',
	    value: function fill(color) {
	
	      if (!this.item) return false;
	
	      if (color === undefined) {
	        if (this.item.brush) {
	          return this.item.color;
	        }
	      }
	
	      if (this.item.brush) {
	        var filter = new _fabric.fabric.Image.filters.Tint({
	          color: color
	        });
	
	        this.item.filters.push(filter);
	        this.item.applyFilters(this.side.FabricCanvas.renderAll.bind(this.side.FabricCanvas));
	        this.item.color = color;
	      } else {
	        this.item.setColor(color);
	      }
	
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	
	      return this.item;
	    }
	  }, {
	    key: 'opacity',
	    value: function opacity(val) {
	      if (val === undefined) return this.item.opacity;
	      this.item.setOpacity(Number(val));
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      return this.item;
	    }
	
	    // TEXT OPTIONS
	
	    /**
	     *
	     * @param fontFamily {String}
	     */
	
	  }, {
	    key: 'fontFamily',
	    value: function fontFamily(_fontFamily) {
	
	      if (!this.item) return false;
	
	      if (this.item.type !== 'textbox') return false;
	      if (!_fontFamily) {
	        return this.item.getFontFamily();
	      }
	      this.item.setFontFamily(_fontFamily);
	      this.item._initDimensions();
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      return this.item;
	    }
	  }, {
	    key: 'fontStyle',
	    value: function fontStyle(_fontStyle) {
	
	      if (!this.item) return false;
	
	      if (this.item.type !== 'textbox') return false;
	      if (!_fontStyle) {
	        return this.item.getFontStyle();
	      }
	      this.item.setFontStyle(_fontStyle);
	      this.item._initDimensions();
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      return this.item;
	    }
	  }, {
	    key: 'fontWeight',
	    value: function fontWeight(_fontWeight) {
	      if (!this.item) return false;
	
	      if (this.item.type !== 'textbox') return false;
	      if (!_fontWeight) {
	        return this.item.getFontWeight();
	      }
	      this.item.setFontWeight(_fontWeight);
	      this.item._initDimensions();
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      return this.item;
	    }
	  }, {
	    key: 'fontSize',
	    value: function fontSize(_fontSize) {
	      if (!this.item) return false;
	
	      if (this.item.type !== 'textbox') return false;
	      if (_fontSize === undefined) {
	        return this.item.getFontSize();
	      }
	      this.item.setFontSize(_fontSize);
	      this.item._initDimensions();
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      return this.item;
	    }
	  }, {
	    key: 'textAlign',
	    value: function textAlign(_textAlign) {
	      if (!this.item) return false;
	
	      if (this.item.type !== 'textbox') return false;
	      if (!_textAlign) {
	        return this.item.getTextAlign();
	      }
	      this.item.setTextAlign(_textAlign);
	      this.item._initDimensions();
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      return this.item;
	    }
	  }, {
	    key: 'text',
	    value: function text(_text) {
	      if (!this.item) return false;
	
	      if (this.item.type !== 'textbox') return false;
	      if (_text === undefined) {
	        return this.item.getText();
	      }
	      this.item.setText(_text);
	      this.item._initDimensions();
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      return this.item;
	    }
	  }, {
	    key: 'removeColor',
	    value: function removeColor(color, distance) {
	      if (!this.item) return false;
	
	      if (this.item.type === 'textbox' || this.item.type === 'path') {
	        if (this.item.fill === color) {
	          this.fill('rgba(0, 0, 0, 0)');
	        }
	        return true;
	      }
	
	      var filter = new _fabric.fabric.Image.filters.RemoveColor({
	        color: color,
	        distance: distance
	      });
	
	      this.item.filters.push(filter);
	      this.item.applyFilters(this.side.FabricCanvas.renderAll.bind(this.side.FabricCanvas));
	    }
	  }, {
	    key: 'enterEditing',
	    value: function enterEditing() {
	      if (!this.item) return false;
	      if (this.item.type !== 'textbox') return false;
	      this.item.enterEditing();
	    }
	  }, {
	    key: 'exitEditing',
	    value: function exitEditing() {
	      if (!this.item) return false;
	      if (this.item.type !== 'textbox') return false;
	      this.item.exitEditing();
	    }
	  }, {
	    key: 'toVCenter',
	    value: function toVCenter() {
	      if (!this.item) return false;
	      this.item.set('top', this.side.FabricBorder.top + this.side.FabricBorder.height / 2);
	      this.side.FabricCanvas.renderAll();
	    }
	  }, {
	    key: 'toHCenter',
	    value: function toHCenter() {
	      if (!this.item) return false;
	      this.item.set('left', this.side.FabricBorder.left + this.side.FabricBorder.width / 2);
	      this.side.FabricCanvas.renderAll();
	    }
	  }, {
	    key: 'toLeft',
	    value: function toLeft() {
	      this.item.set('left', this.side.FabricBorder.left + this.item.width * this.item.scaleX / 2);
	      this.side.FabricCanvas.renderAll();
	    }
	  }, {
	    key: 'toRight',
	    value: function toRight() {
	      if (!this.item) return false;
	      this.item.set('left', this.side.FabricBorder.left + this.side.FabricBorder.width - this.item.width * this.item.scaleX / 2);
	      this.side.FabricCanvas.renderAll();
	    }
	  }, {
	    key: 'toTop',
	    value: function toTop() {
	      if (!this.item) return false;
	      this.item.set('top', this.side.FabricBorder.top + this.item.height * this.item.scaleY / 2);
	      this.side.FabricCanvas.renderAll();
	    }
	  }, {
	    key: 'toBottom',
	    value: function toBottom() {
	      if (!this.item) return false;
	      this.item.set('top', this.side.FabricBorder.top + this.side.FabricBorder.height - this.item.height * this.item.scaleY / 2);
	      this.side.FabricCanvas.renderAll();
	    }
	  }]);
	
	  return Item;
	}();
	
	exports.default = Item;

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _DrawTool = __webpack_require__(1);
	
	var _DrawTool2 = _interopRequireDefault(_DrawTool);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Layers = function () {
	  function Layers(side) {
	    _classCallCheck(this, Layers);
	
	    this.side = side;
	    this.list = null;
	    this.update();
	  }
	
	  _createClass(Layers, [{
	    key: 'update',
	    value: function update() {
	      var layers = [];
	
	      var opt = {
	        quality: 0.5,
	        enableRetina: false
	      };
	
	      this.side.FabricCanvas.forEachObject(function (obj) {
	        if (!obj.excludeFromExport) {
	          var clipto = obj.getClipTo();
	          obj.setClipTo(null);
	          layers.push({ index: obj.uuid, preview: obj.toDataURL(opt) });
	          obj.setClipTo(clipto);
	        }
	      });
	
	      this.list = layers;
	
	      return layers;
	    }
	  }, {
	    key: '_getItemsByIndex',
	    value: function _getItemsByIndex() {
	      for (var _len = arguments.length, indexes = Array(_len), _key = 0; _key < _len; _key++) {
	        indexes[_key] = arguments[_key];
	      }
	
	      var objects = this.side.FabricCanvas.getObjects().filter(function (obj) {
	        return indexes.includes(obj.uuid);
	      });
	      return objects;
	    }
	  }, {
	    key: 'bringToFront',
	    value: function bringToFront() {
	      var items = this._getItemsByIndex.apply(this, arguments);
	      items.forEach(function (item) {
	        return item.bringToFront();
	      });
	      _DrawTool2.default.trigger('history:update', { side: { id: _DrawTool2.default.sides.selected.id } });
	    }
	  }, {
	    key: 'bringForward',
	    value: function bringForward() {
	      var items = this._getItemsByIndex.apply(this, arguments);
	      items.forEach(function (item) {
	        return item.bringForward(true);
	      });
	      _DrawTool2.default.trigger('history:update', { side: { id: _DrawTool2.default.sides.selected.id } });
	    }
	  }, {
	    key: 'sendBackwards',
	    value: function sendBackwards() {
	      var items = this._getItemsByIndex.apply(this, arguments);
	      items.forEach(function (item) {
	        return item.sendBackwards(true);
	      });
	      _DrawTool2.default.trigger('history:update', { side: { id: _DrawTool2.default.sides.selected.id } });
	    }
	  }, {
	    key: 'sendToBack',
	    value: function sendToBack() {
	      var items = this._getItemsByIndex.apply(this, arguments);
	      items.forEach(function (item) {
	        return item.sendToBack();
	      });
	      _DrawTool2.default.trigger('history:update', { side: { id: _DrawTool2.default.sides.selected.id } });
	    }
	  }, {
	    key: 'toVCenter',
	    value: function toVCenter() {
	      var _this = this;
	
	      var items = this._getItemsByIndex.apply(this, arguments);
	
	      items.forEach(function (item) {
	        return item.set('top', _this.side.FabricBorder.top + _this.side.FabricBorder.height / 2);
	      });
	      this.side.FabricCanvas.renderAll();
	    }
	  }, {
	    key: 'toHCenter',
	    value: function toHCenter() {
	      var _this2 = this;
	
	      var items = this._getItemsByIndex.apply(this, arguments);
	
	      items.forEach(function (item) {
	        return item.set('left', _this2.side.FabricBorder.left + _this2.side.FabricBorder.width / 2);
	      });
	      this.side.FabricCanvas.renderAll();
	    }
	  }, {
	    key: 'toLeft',
	    value: function toLeft() {
	      var _this3 = this;
	
	      var items = this._getItemsByIndex.apply(this, arguments);
	
	      items.forEach(function (item) {
	        return item.set('left', _this3.side.FabricBorder.left + item.width * item.scaleX / 2);
	      });
	      this.side.FabricCanvas.renderAll();
	    }
	  }, {
	    key: 'toRight',
	    value: function toRight() {
	      var _this4 = this;
	
	      var items = this._getItemsByIndex.apply(this, arguments);
	
	      items.forEach(function (item) {
	        return item.set('left', _this4.side.FabricBorder.left + _this4.side.FabricBorder.width - item.width * item.scaleX / 2);
	      });
	      this.side.FabricCanvas.renderAll();
	    }
	  }, {
	    key: 'toTop',
	    value: function toTop() {
	      var _this5 = this;
	
	      var items = this._getItemsByIndex.apply(this, arguments);
	
	      items.forEach(function (item) {
	        return item.set('top', _this5.side.FabricBorder.top + item.height * item.scaleY / 2);
	      });
	      this.side.FabricCanvas.renderAll();
	    }
	  }, {
	    key: 'toBottom',
	    value: function toBottom() {
	      var _this6 = this;
	
	      var items = this._getItemsByIndex.apply(this, arguments);
	
	      items.forEach(function (item) {
	        return item.set('top', _this6.side.FabricBorder.top + _this6.side.FabricBorder.height - item.height * item.scaleY / 2);
	      });
	      this.side.FabricCanvas.renderAll();
	    }
	  }]);
	
	  return Layers;
	}();
	
	exports.default = Layers;

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _fabric = __webpack_require__(7);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var colorPicker = function () {
	  function colorPicker(side) {
	    _classCallCheck(this, colorPicker);
	
	    var that = this;
	
	    this.side = side;
	
	    this._active = false;
	
	    this._color = '#000000';
	
	    this.cursor = new _fabric.fabric.Circle({
	      left: 0,
	      top: 0,
	      radius: 20,
	      strokeWidth: 3,
	      stroke: '#ffffff',
	      originX: 'center',
	      originY: 'center',
	      selectable: false,
	      excludeFromExport: true,
	      evented: false,
	      shadow: new _fabric.fabric.Shadow('2px 2px 10px rgba(0,0,0,0.2)'),
	      lockUniScaling: true
	    });
	
	    return this;
	  }
	
	  _createClass(colorPicker, [{
	    key: 'move',
	    value: function move(e) {
	      var pointer = this.side.FabricCanvas.getPointer(e.e);
	
	      this.color = this.getColor(e.e.layerX * window.devicePixelRatio, e.e.layerY * window.devicePixelRatio);
	
	      this.side.FabricCanvas.remove(this.cursor);
	      this.side.FabricCanvas.add(this.cursor);
	      this.cursor.bringToFront();
	
	      if (e.e.layerX < 50 || e.e.layerY < 50) {
	        this.cursor.top = pointer.y + 30;
	        this.cursor.left = pointer.x + 30;
	      } else {
	        this.cursor.top = pointer.y - 30;
	        this.cursor.left = pointer.x - 30;
	      }
	
	      this.side.FabricCanvas.renderAll();
	    }
	  }, {
	    key: 'getColor',
	    value: function getColor(x, y) {
	
	      var px = this.side.FabricCanvas.contextContainer.getImageData(x, y, 1, 1).data;
	
	      return '#' + new _fabric.fabric.Color('rgb(' + px[0] + ', ' + px[1] + ', ' + px[2] + ')').toHex();
	    }
	  }, {
	    key: 'active',
	    set: function set(value) {
	      this._active = value;
	      if (value !== undefined && !value) {
	        this.side.FabricCanvas.remove(this.cursor);
	        this.side.items._collection.forEach(function (object) {
	          return object.selectable = !value;
	        });
	      } else if (value === true) {
	        this.side.items._collection.forEach(function (object) {
	          return object.selectable = !value;
	        });
	        this.side.items.selected.deactivate();
	      }
	    },
	    get: function get() {
	      return this._active;
	    }
	  }, {
	    key: 'color',
	    set: function set(color) {
	      if (color !== undefined && color) {
	        this._color = color;
	        this.cursor.setFill(color);
	      }
	    },
	    get: function get() {
	      return this._color;
	    }
	  }]);
	
	  return colorPicker;
	}();
	
	;
	
	exports.default = colorPicker;

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _DrawTool = __webpack_require__(1);
	
	var _DrawTool2 = _interopRequireDefault(_DrawTool);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var DrawHistory = function () {
	  function DrawHistory() {
	    _classCallCheck(this, DrawHistory);
	
	    this.history = {};
	  }
	
	  _createClass(DrawHistory, [{
	    key: 'pushState',
	    value: function pushState(id) {
	
	      if (typeof this.history[id] === 'undefined') {
	        this.history[id] = {
	          collection: [],
	          currentIndex: 0
	        };
	      }
	
	      var side = _DrawTool2.default.sides.getSide(id);
	      var state = JSON.stringify(side.FabricCanvas);
	
	      this.history[id].collection = this.history[id].collection.slice(0, this.history[id].currentIndex + 1);
	      this.history[id].collection.push(state);
	      this.history[id].currentIndex = this.history[id].collection.length - 1;
	    }
	  }, {
	    key: 'undo',
	    value: function undo(id) {
	
	      var side = _DrawTool2.default.sides.getSide(id);
	
	      if (!this.history[id].collection.length) {
	        this.history[id].currentIndex = 0;
	        return false;
	      }
	
	      if (this.history[id].currentIndex <= 0) {
	        this.history[id].currentIndex = 0;
	        return false;
	      }
	
	      var state = this.history[id].collection[this.history[id].currentIndex - 1];
	      this.history[id].currentIndex -= 1;
	
	      side.loadFromJSON(state);
	    }
	  }, {
	    key: 'redo',
	    value: function redo(id) {
	
	      var side = _DrawTool2.default.sides.getSide(id);
	
	      if (!this.history[id].collection.length) {
	        return false;
	      }
	
	      if (this.history[id].currentIndex >= this.history[id].collection.length - 1) {
	        return false;
	      }
	
	      var state = this.history[id].collection[this.history[id].currentIndex + 1];
	      this.history[id].currentIndex += 1;
	
	      side.loadFromJSON(state);
	    }
	  }]);
	
	  return DrawHistory;
	}();
	
	exports.default = DrawHistory;

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _fabric = __webpack_require__(7);
	
	_fabric.fabric.Eraser = _fabric.fabric.util.createClass(_fabric.fabric.BaseBrush, {
	
	  initialize: function initialize(canvas) {
	    this.canvas = canvas;
	  },
	
	  onMouseDown: function onMouseDown(pointer) {
	    this.remove(pointer);
	  },
	
	  onMouseMove: function onMouseMove(pointer) {
	    this.remove(pointer);
	  },
	
	  onMouseUp: function onMouseUp(pointer) {},
	
	  remove: function remove(pointer) {
	    var _this = this;
	
	    var targets = this.canvas.getObjects().filter(function (obj) {
	      return obj.containsPoint(pointer) && !_this.canvas.isTargetTransparent(obj, pointer.x, pointer.y);
	    });
	
	    targets.forEach(function (obj) {
	
	      if (obj.id !== 'FabricBorder') {
	        obj.remove();
	      }
	    });
	  }
	
	});

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _fabric = __webpack_require__(7);
	
	_fabric.fabric.util.getRandom = function (max, min) {
	  min = min ? min : 0;
	  return Math.random() * ((max ? max : 1) - min) + min;
	};
	
	_fabric.fabric.util.clamp = function (n, max, min) {
	  if (typeof min !== 'number') min = 0;
	  return n > max ? max : n < min ? min : n;
	};
	
	_fabric.fabric.util.trim = function (context) {
	  var copy = document.createElement('canvas').getContext('2d'),
	      pixels = context.getImageData(0, 0, context.canvas.width, context.canvas.height),
	      l = pixels.data.length,
	      i,
	      bound = {
	    top: null,
	    left: null,
	    right: null,
	    bottom: null
	  },
	      x,
	      y,
	      img;
	
	  for (i = 0; i < l; i += 4) {
	    if (pixels.data[i + 3] !== 0) {
	      x = i / 4 % context.canvas.width;
	      y = ~~(i / 4 / context.canvas.width);
	
	      if (bound.top === null) {
	        bound.top = y;
	      }
	
	      if (bound.left === null) {
	        bound.left = x;
	      } else if (x < bound.left) {
	        bound.left = x;
	      }
	
	      if (bound.right === null) {
	        bound.right = x;
	      } else if (bound.right < x) {
	        bound.right = x;
	      }
	
	      if (bound.bottom === null) {
	        bound.bottom = y;
	      } else if (bound.bottom < y) {
	        bound.bottom = y;
	      }
	    }
	  }
	
	  var trimHeight = bound.bottom - bound.top;
	  var trimWidth = bound.right - bound.left;
	  if (!trimHeight || !trimWidth) {
	    return false;
	  }
	  var trimmed = context.getImageData(bound.left, bound.top, trimWidth + 10, trimHeight + 10);
	
	  copy.canvas.width = trimWidth;
	  copy.canvas.height = trimHeight;
	  copy.putImageData(trimmed, 0, 0);
	  img = copy.canvas.toDataURL('image/png');
	
	  return {
	    img: img,
	    left: bound.left,
	    top: bound.top,
	    width: trimWidth,
	    height: trimHeight
	  };
	};

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _fabric = __webpack_require__(7);
	
	var _clip = __webpack_require__(5);
	
	var _clip2 = _interopRequireDefault(_clip);
	
	var _DrawTool = __webpack_require__(1);
	
	var _DrawTool2 = _interopRequireDefault(_DrawTool);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_fabric.fabric.BaseBrush.prototype.finalize = function () {
	  var _this = this;
	
	  if (!this.moved) return false;
	  var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;
	
	  var vt = this.canvas.viewportTransform;
	  var raster = _fabric.fabric.util.trim(this.canvas.contextTop);
	
	  _fabric.fabric.Image.fromURL(raster.img, function (oImg) {
	
	    _this.canvas.clearContext(_this.canvas.contextTop);
	    _this._resetShadow();
	
	    oImg.set({
	      top: raster.top / vt[0] - vt[5] / vt[0],
	      left: raster.left / vt[0] - vt[4] / vt[0],
	      width: oImg.width / vt[0],
	      height: oImg.height / vt[0],
	      brush: true,
	      color: _this.color
	    });
	
	    oImg.set({
	      originX: 'center',
	      originY: 'center',
	      top: oImg.top + oImg.height / 2,
	      left: oImg.left + oImg.width / 2,
	      clipTo: (0, _clip2.default)(_DrawTool2.default.sides.selected.FabricBorder)
	    });
	
	    _this.canvas.add(oImg);
	
	    _DrawTool2.default.sides.selected.items._collection.push(oImg);
	
	    _this.canvas.renderAll();
	
	    _DrawTool2.default.trigger('history:update', { side: { id: _DrawTool2.default.sides.selected.id } });
	
	    _this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
	
	    _this.moved = false;
	  }, {
	    crossOrigin: 'Anonymous'
	  });
	};

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _fabric = __webpack_require__(7);
	
	_fabric.fabric.Point.prototype.angleBetween = function (that) {
	  return Math.atan2(this.x - that.x, this.y - that.y);
	};
	
	_fabric.fabric.Point.prototype.normalize = function (thickness) {
	  if (null === thickness || undefined === thickness) {
	    thickness = 1;
	  }
	
	  var length = this.distanceFrom({ x: 0, y: 0 });
	
	  if (length > 0) {
	    this.x = this.x / length * thickness;
	    this.y = this.y / length * thickness;
	  }
	
	  return this;
	};

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _fabric = __webpack_require__(7);
	
	_fabric.fabric.Stroke = _fabric.fabric.util.createClass(_fabric.fabric.Object, {
	  color: null,
	  inkAmount: null,
	  lineWidth: null,
	  _point: null,
	  _lastPoint: null,
	  _currentLineWidth: null,
	
	  initialize: function initialize(ctx, pointer, range, color, lineWidth, inkAmount) {
	
	    var rx = _fabric.fabric.util.getRandom(range),
	        c = _fabric.fabric.util.getRandom(Math.PI * 2),
	        c0 = _fabric.fabric.util.getRandom(Math.PI * 2),
	        x0 = rx * Math.sin(c0),
	        y0 = rx / 2 * Math.cos(c0),
	        cos = Math.cos(c),
	        sin = Math.sin(c);
	
	    this.ctx = ctx;
	    this.color = color;
	    this._point = new _fabric.fabric.Point(pointer.x + x0 * cos - y0 * sin, pointer.y + x0 * sin + y0 * cos);
	    this.lineWidth = lineWidth;
	    this.inkAmount = inkAmount;
	    this._currentLineWidth = lineWidth;
	
	    ctx.lineCap = "round";
	  },
	
	  update: function update(pointer, subtractPoint, distance) {
	    this._lastPoint = _fabric.fabric.util.object.clone(this._point);
	    this._point = this._point.addEquals({ x: subtractPoint.x, y: subtractPoint.y });
	
	    var n = this.inkAmount / (distance + 1);
	    var per = n > 0.3 ? 0.2 : n < 0 ? 0 : n;
	    this._currentLineWidth = this.lineWidth * per;
	  },
	
	  draw: function draw() {
	    var ctx = this.ctx;
	    ctx.save();
	    this.line(ctx, this._lastPoint, this._point, this.color, this._currentLineWidth);
	    ctx.restore();
	  },
	
	  line: function line(ctx, point1, point2, color, lineWidth) {
	    ctx.strokeStyle = color;
	    ctx.lineWidth = lineWidth;
	    ctx.beginPath();
	    ctx.moveTo(point1.x, point1.y);
	    ctx.lineTo(point2.x, point2.y);
	
	    ctx.stroke();
	  }
	});

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _fabric = __webpack_require__(7);
	
	_fabric.fabric.PencilBrushC = _fabric.fabric.util.createClass(_fabric.fabric.BaseBrush, {
	
	  color: "#000000",
	  opacity: 1,
	  width: 1,
	
	  _baseWidth: 1,
	  _lastPoint: null,
	  _lineWidth: 1,
	  _point: null,
	  _size: 0,
	  moved: false,
	
	  initialize: function initialize(canvas) {
	    var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	
	    this.canvas = canvas;
	    this.width = opt.width || canvas.freeDrawingBrush.width;
	    this.color = opt.color || canvas.freeDrawingBrush.color;
	    this.opacity = opt.opacity || canvas.contextTop.globalAlpha;
	    this._point = new _fabric.fabric.Point();
	
	    this.canvas.contextTop.lineJoin = 'round';
	    this.canvas.contextTop.lineCap = 'round';
	  },
	
	  changeColor: function changeColor(color) {
	    this.color = color;
	  },
	
	  changeOpacity: function changeOpacity(value) {
	    this.opacity = value;
	    this.canvas.contextTop.globalAlpha = value;
	  },
	
	  _render: function _render(pointer) {
	    var ctx, lineWidthDiff, i, len;
	    var vt = this.canvas.viewportTransform;
	
	    ctx = this.canvas.contextTop;
	
	    ctx.save();
	
	    ctx.transform(vt[0], vt[1], vt[2], vt[3], vt[4], vt[5]);
	    ctx.beginPath();
	
	    ctx.globalAlpha = this.opacity;
	    for (i = 0, len = this._size / this._lineWidth / 2; i < len; i++) {
	      lineWidthDiff = (this._lineWidth - 1) * i;
	      ctx.moveTo(this._lastPoint.x + lineWidthDiff, this._lastPoint.y + lineWidthDiff);
	      ctx.lineTo(pointer.x + lineWidthDiff, pointer.y + lineWidthDiff);
	      ctx.stroke();
	    }
	
	    ctx.restore();
	
	    this._lastPoint = new _fabric.fabric.Point(pointer.x, pointer.y);
	  },
	
	  onMouseDown: function onMouseDown(pointer) {
	    this._lastPoint = pointer;
	    this.canvas.contextTop.strokeStyle = this.color;
	    this.canvas.contextTop.lineWidth = this._lineWidth;
	    this._size = this.width + this._baseWidth;
	    this.moved = false;
	  },
	
	  onMouseMove: function onMouseMove(pointer) {
	    if (this.canvas._isCurrentlyDrawing) {
	      this._render(pointer);
	    }
	    this.moved = true;
	  },
	
	  onMouseUp: function onMouseUp() {}
	});

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _fabric = __webpack_require__(7);
	
	_fabric.fabric.CrayonBrush = _fabric.fabric.util.createClass(_fabric.fabric.BaseBrush, {
	
	  color: "#000000",
	  opacity: 1,
	  width: 30,
	
	  _baseWidth: 20,
	  _inkAmount: 10,
	  _latestStrokeLength: 0,
	  _point: null,
	  _sep: 5,
	  _size: 0,
	  moved: false,
	
	  initialize: function initialize(canvas) {
	    var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	
	    this.canvas = canvas;
	    this.width = opt.width || canvas.freeDrawingBrush.width;
	    this.color = opt.color || canvas.freeDrawingBrush.color;
	    this.opacity = opt.opacity || canvas.contextTop.globalAlpha;
	    this._point = new _fabric.fabric.Point(0, 0);
	  },
	
	  changeColor: function changeColor(color) {
	    this.color = color;
	  },
	
	  changeOpacity: function changeOpacity(value) {
	    this.opacity = value;
	    this.canvas.contextTop.globalAlpha = value;
	  },
	
	  onMouseDown: function onMouseDown(pointer) {
	    this._size = this.width / 2 + this._baseWidth;
	    this.set(pointer);
	    this.moved = false;
	  },
	
	  onMouseMove: function onMouseMove(pointer) {
	    this.update(pointer);
	    this.render(this.canvas.contextTop);
	    this.moved = true;
	  },
	
	  onMouseUp: function onMouseUp(pointer) {},
	
	  set: function set(p) {
	    if (this._latest) {
	      this._latest.setFromPoint(this._point);
	    } else {
	      this._latest = new _fabric.fabric.Point(p.x, p.y);
	    }
	    _fabric.fabric.Point.prototype.setFromPoint.call(this._point, p);
	  },
	
	  update: function update(p) {
	    this.set(p);
	    this._latestStrokeLength = this._point.subtract(this._latest).distanceFrom({ x: 0, y: 0 });
	  },
	
	  render: function render() {
	    var ctx = this.canvas.contextTop;
	    var vt = this.canvas.viewportTransform;
	    var i, j, p, r, c, x, y, w, h, v, s, stepNum, dotSize, dotNum, range;
	    v = this._point.subtract(this._latest);
	    s = Math.ceil(this._size / 2);
	    stepNum = Math.floor(v.distanceFrom({ x: 0, y: 0 }) / s) + 1;
	    v.normalize(s);
	
	    dotSize = this._sep * _fabric.fabric.util.clamp(this._inkAmount / this._latestStrokeLength * 3, 1, 0.5);
	    dotNum = Math.ceil(this._size * this._sep);
	
	    range = this._size / 2;
	
	    ctx.save();
	    this.canvas.contextTop.globalAlpha = this.opacity;
	    ctx.transform(vt[0], vt[1], vt[2], vt[3], vt[4], vt[5]);
	    ctx.fillStyle = this.color;
	    ctx.beginPath();
	    for (i = 0; i < dotNum; i++) {
	      for (j = 0; j < stepNum; j++) {
	        p = this._latest.add(v.multiply(j));
	        r = _fabric.fabric.util.getRandom(range);
	        c = _fabric.fabric.util.getRandom(Math.PI * 2);
	        w = _fabric.fabric.util.getRandom(dotSize, dotSize / 2);
	        h = _fabric.fabric.util.getRandom(dotSize, dotSize / 2);
	        x = p.x + r * Math.sin(c) - w / 2;
	        y = p.y + r * Math.cos(c) - h / 2;
	        ctx.rect(x, y, w, h);
	      }
	    }
	
	    ctx.fill();
	    ctx.restore();
	  }
	
	});

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _fabric = __webpack_require__(7);
	
	_fabric.fabric.InkBrush = _fabric.fabric.util.createClass(_fabric.fabric.BaseBrush, {
	
	  color: "#000000",
	  opacity: 1,
	  width: 30,
	
	  _baseWidth: 20,
	  _inkAmount: 7,
	  _lastPoint: null,
	  _point: null,
	  _range: 10,
	  _strokeCount: 0,
	  _strokeId: null,
	  _strokeNum: 40,
	  _strokes: null,
	  moved: false,
	
	  initialize: function initialize(canvas) {
	    var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	
	    this.canvas = canvas;
	    this.width = opt.width || canvas.freeDrawingBrush.width;
	    this.color = opt.color || canvas.freeDrawingBrush.color;
	    this.opacity = opt.opacity || canvas.contextTop.globalAlpha;
	
	    this._point = new _fabric.fabric.Point();
	  },
	
	  changeColor: function changeColor(color) {
	    this.color = color;
	  },
	
	  changeOpacity: function changeOpacity(value) {
	    this.opacity = value;
	    this.canvas.contextTop.globalAlpha = value;
	  },
	
	  _render: function _render(pointer) {
	    var subtractPoint, distance, point, i, len, strokes, stroke;
	    this._strokeCount++;
	
	    var ctx = this.canvas.contextTop;
	    var vt = this.canvas.viewportTransform;
	
	    point = this.setPointer(pointer);
	    subtractPoint = point.subtract(this._lastPoint);
	    distance = point.distanceFrom(this._lastPoint);
	    strokes = this._strokes;
	
	    ctx.save();
	    ctx.transform(vt[0], vt[1], vt[2], vt[3], vt[4], vt[5]);
	    for (i = 0, len = strokes.length; i < len; i++) {
	      stroke = strokes[i];
	      stroke.update(point, subtractPoint, distance);
	      stroke.draw();
	    }
	
	    if (distance > 30) {
	      this.drawSplash(point, this._inkAmount);
	    }
	    ctx.restore();
	  },
	
	  onMouseDown: function onMouseDown(pointer) {
	    this._resetTip(pointer);
	    this._strokeId = +new Date();
	    this.moved = false;
	  },
	
	  onMouseMove: function onMouseMove(pointer) {
	    if (this.canvas._isCurrentlyDrawing) {
	      this._render(pointer);
	    }
	    this.moved = true;
	  },
	
	  onMouseUp: function onMouseUp() {
	    this._strokeCount = 0;
	    this._strokeId = null;
	  },
	
	  drawSplash: function drawSplash(pointer, maxSize) {
	    var c,
	        r,
	        i,
	        point,
	        ctx = this.canvas.contextTop,
	        num = _fabric.fabric.util.getRandom(12),
	        range = maxSize * 10,
	        color = this.color;
	
	    ctx.save();
	    ctx.globalAlpha = this.opacity;
	    for (i = 0; i < num; i++) {
	      r = _fabric.fabric.util.getRandom(range, 1);
	      c = _fabric.fabric.util.getRandom(Math.PI * 2);
	      point = new _fabric.fabric.Point(pointer.x + r * Math.sin(c), pointer.y + r * Math.cos(c));
	
	      ctx.fillStyle = color;
	      ctx.beginPath();
	      ctx.arc(point.x, point.y, _fabric.fabric.util.getRandom(maxSize) / 2, 0, Math.PI * 2, false);
	      ctx.fill();
	    }
	    ctx.restore();
	  },
	
	  setPointer: function setPointer(pointer) {
	    var point = new _fabric.fabric.Point(pointer.x, pointer.y);
	
	    this._lastPoint = _fabric.fabric.util.object.clone(this._point);
	    this._point = point;
	
	    return point;
	  },
	
	  _resetTip: function _resetTip(pointer) {
	    var strokes, point, len, i;
	
	    point = this.setPointer(pointer);
	    strokes = this._strokes = [];
	    this.size = this.width / 5 + this._baseWidth;
	    this._strokeNum = this.size;
	    this._range = this.size / 2;
	
	    for (i = 0, len = this._strokeNum; i < len; i++) {
	      strokes[i] = new _fabric.fabric.Stroke(this.canvas.contextTop, point, this._range, this.color, this.width, this._inkAmount);
	    }
	  }
	});

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _fabric = __webpack_require__(7);
	
	_fabric.fabric.SprayBrush = _fabric.fabric.util.createClass(_fabric.fabric.BaseBrush, {
	
	  color: "#000000",
	  opacity: 1,
	  width: 30,
	
	  _baseWidth: 40,
	  _drips: [],
	  _dripThreshold: 15,
	  _inkAmount: 0,
	  _interval: 20,
	  _lastPoint: null,
	  _point: null,
	  _strokeId: 0,
	  brush: null,
	  sprayBrushDataUrl: "data:image/png;base64,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",
	  moved: false,
	
	  initialize: function initialize(canvas) {
	    var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	    var context = this;
	
	    this.canvas = canvas;
	    this.width = opt.width || canvas.freeDrawingBrush.width;
	    this.opacity = opt.opacity || canvas.contextTop.globalAlpha;
	    this.color = opt.color || canvas.freeDrawingBrush.color;
	
	    this.canvas.contextTop.lineJoin = "round";
	    this.canvas.contextTop.lineCap = "round";
	
	    this._reset();
	
	    _fabric.fabric.Image.fromURL(this.sprayBrushDataUrl, function (brush) {
	      context.brush = brush;
	      context.brush.filters = [];
	      context.changeColor(context.color || this.color);
	    }, { crossOrigin: "anonymous" });
	  },
	
	  changeColor: function changeColor(color) {
	    this.color = color;
	    this.brush.filters[0] = new _fabric.fabric.Image.filters.Tint({ color: color });
	    this.brush.applyFilters(this.canvas.renderAll.bind(this.canvas));
	  },
	
	  changeOpacity: function changeOpacity(value) {
	    this.opacity = value;
	    this.canvas.contextTop.globalAlpha = value;
	  },
	
	  onMouseDown: function onMouseDown(pointer) {
	    this._point = new _fabric.fabric.Point(pointer.x, pointer.y);
	    this._lastPoint = this._point;
	
	    this.size = this.width + this._baseWidth;
	    this._strokeId = +new Date();
	    this._inkAmount = 0;
	
	    this.changeColor(this.color);
	    this._render();
	  },
	
	  onMouseMove: function onMouseMove(pointer) {
	    this.moved = true;
	    this._lastPoint = this._point;
	    this._point = new _fabric.fabric.Point(pointer.x, pointer.y);
	  },
	
	  onMouseUp: function onMouseUp(pointer) {},
	
	  _render: function _render() {
	    var context = this;
	
	    setTimeout(draw, this._interval);
	
	    function draw() {
	      var point, distance, angle, amount, x, y;
	
	      var ctx = context.canvas.contextTop;
	      var vt = context.canvas.viewportTransform;
	      ctx.save();
	      ctx.transform(vt[0], vt[1], vt[2], vt[3], vt[4], vt[5]);
	      ctx.globalAlpha = this.opacity;
	      point = new _fabric.fabric.Point(context._point.x || 0, context._point.y || 0);
	      distance = point.distanceFrom(context._lastPoint);
	      angle = point.angleBetween(context._lastPoint);
	      amount = 100 / context.size / (Math.pow(distance, 2) + 1);
	
	      context._inkAmount += amount;
	      context._inkAmount = Math.max(context._inkAmount - distance / 10, 0);
	
	      x = context._lastPoint.x + Math.sin(angle) - context.size / 2;
	      y = context._lastPoint.y + Math.cos(angle) - context.size / 2;
	      context.canvas.contextTop.drawImage(context.brush._element, x, y, context.size, context.size);
	
	      ctx.restore();
	
	      if (context.canvas._isCurrentlyDrawing) {
	        setTimeout(draw, context._interval);
	      } else {
	        context._reset();
	      }
	    }
	  },
	
	  _reset: function _reset() {
	    this._point = null;
	    this._lastPoint = null;
	  }
	});

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _fabric = __webpack_require__(7);
	
	_fabric.fabric.MarkerBrush = _fabric.fabric.util.createClass(_fabric.fabric.BaseBrush, {
	
	  color: "#000000",
	  opacity: 1,
	  width: 30,
	
	  _baseWidth: 10,
	  _lastPoint: null,
	  _lineWidth: 3,
	  _point: null,
	  _size: 0,
	  moved: false,
	
	  initialize: function initialize(canvas) {
	    var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	
	    this.canvas = canvas;
	    this.width = opt.width || canvas.freeDrawingBrush.width;
	    this.color = opt.color || canvas.freeDrawingBrush.color;
	    this.opacity = opt.opacity || canvas.contextTop.globalAlpha;
	    this._point = new _fabric.fabric.Point();
	
	    this.canvas.contextTop.lineJoin = 'round';
	    this.canvas.contextTop.lineCap = 'round';
	  },
	
	  changeColor: function changeColor(color) {
	    this.color = color;
	  },
	
	  changeOpacity: function changeOpacity(value) {
	    this.opacity = value;
	    this.canvas.contextTop.globalAlpha = value;
	  },
	
	  _render: function _render(pointer) {
	    var ctx, lineWidthDiff, i, len;
	    var vt = this.canvas.viewportTransform;
	
	    ctx = this.canvas.contextTop;
	
	    ctx.save();
	
	    ctx.transform(vt[0], vt[1], vt[2], vt[3], vt[4], vt[5]);
	    ctx.beginPath();
	
	    this.canvas.contextTop.globalAlpha = this.opacity;
	    for (i = 0, len = this._size / this._lineWidth / 2; i < len; i++) {
	      lineWidthDiff = (this._lineWidth - 1) * i;
	
	      ctx.globalAlpha = 0.8 * this.opacity;
	      ctx.moveTo(this._lastPoint.x + lineWidthDiff, this._lastPoint.y + lineWidthDiff);
	      ctx.lineTo(pointer.x + lineWidthDiff, pointer.y + lineWidthDiff);
	      ctx.stroke();
	    }
	
	    ctx.restore();
	
	    this._lastPoint = new _fabric.fabric.Point(pointer.x, pointer.y);
	  },
	
	  onMouseDown: function onMouseDown(pointer) {
	    this._lastPoint = pointer;
	    this.canvas.contextTop.strokeStyle = this.color;
	    this.canvas.contextTop.lineWidth = this._lineWidth;
	    this._size = this.width + this._baseWidth;
	    this.moved = false;
	  },
	
	  onMouseMove: function onMouseMove(pointer) {
	    if (this.canvas._isCurrentlyDrawing) {
	      this._render(pointer);
	    }
	    this.moved = true;
	  },
	
	  onMouseUp: function onMouseUp() {}
	});

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _fabric = __webpack_require__(7);
	
	_fabric.fabric.CustomBrush = _fabric.fabric.util.createClass(_fabric.fabric.BaseBrush, {
	
	  color: "#000000",
	  opacity: 1,
	  width: 30,
	
	  _baseWidth: 10,
	  _lastPoint: null,
	  _lineWidth: 3,
	  _point: null,
	  _size: 0,
	  sprayBrushDataUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAE0lEQVR42mNgwAF+AfEPvAJwAAB+vgPlDsQoGAAAAABJRU5ErkJggg==",
	  moved: false,
	
	  initialize: function initialize(canvas) {
	    var _this = this;
	
	    var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	
	    this.canvas = canvas;
	    this.width = opt.width || canvas.freeDrawingBrush.width;
	    this.color = opt.color || canvas.freeDrawingBrush.color;
	    this.opacity = opt.opacity || canvas.contextTop.globalAlpha;
	    this._point = new _fabric.fabric.Point();
	    this.sprayBrushDataUrl = opt.image || this.sprayBrushDataUrl;
	
	    this.canvas.contextTop.lineJoin = 'round';
	    this.canvas.contextTop.lineCap = 'round';
	
	    _fabric.fabric.Image.fromURL(this.sprayBrushDataUrl, function (brush) {
	      _this.brush = brush;
	      _this.brush.filters = [];
	      _this.changeColor(_this.color);
	    }, { crossOrigin: "anonymous" });
	  },
	
	  changeColor: function changeColor(color) {
	    this.color = color;
	    this.brush.filters[0] = new _fabric.fabric.Image.filters.Tint({ color: color });
	    this.brush.applyFilters(this.canvas.renderAll.bind(this.canvas));
	  },
	
	  changeOpacity: function changeOpacity(value) {
	    this.opacity = value;
	    this.canvas.contextTop.globalAlpha = value;
	  },
	
	  _render: function _render() {
	    var ctx, lineWidthDiff, i, len, x, y;
	    var vt = this.canvas.viewportTransform;
	
	    ctx = this.canvas.contextTop;
	
	    ctx.save();
	    ctx.transform(vt[0], vt[1], vt[2], vt[3], vt[4], vt[5]);
	
	    var dist = this._point.distanceFrom(this._lastPoint);
	    var angle = this._point.angleBetween(this._lastPoint);
	
	    ctx.globalAlpha = this.opacity;
	
	    for (var i = 0; i < dist; i++) {
	      x = this._lastPoint.x + Math.sin(angle) * i - this._size / 2;
	      y = this._lastPoint.y + Math.cos(angle) * i - this._size / 2;
	      this.canvas.contextTop.drawImage(this.brush._element, x, y, this._size, this._size);
	    }
	
	    ctx.restore();
	  },
	
	  onMouseDown: function onMouseDown(pointer) {
	    this._point = new _fabric.fabric.Point(pointer.x, pointer.y);
	    this._lastPoint = this._point;
	    this.canvas.contextTop.strokeStyle = this.color;
	    this.canvas.contextTop.lineWidth = this._lineWidth;
	    this._size = this.width + this._baseWidth;
	    this.moved = false;
	  },
	
	  onMouseMove: function onMouseMove(pointer) {
	    this._lastPoint = this._point;
	    this._point = new _fabric.fabric.Point(pointer.x, pointer.y);
	    if (this.canvas._isCurrentlyDrawing) {
	      this._render();
	    }
	    this.moved = true;
	  },
	
	  onMouseUp: function onMouseUp() {}
	});

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _fabric = __webpack_require__(7);
	
	var extend = _fabric.fabric.util.object.extend;
	var filters = _fabric.fabric.Image.filters;
	var createClass = _fabric.fabric.util.createClass;
	
	filters.RemoveColor = createClass(filters.BaseFilter, {
	
	  type: 'RemoveColor',
	
	  initialize: function initialize(options) {
	    options = options || {};
	
	    this.color = new _fabric.fabric.Color(options.color || '#ffffff');
	    this.distance = options.distance === undefined ? 1 : Number(options.distance);
	  },
	
	  applyTo: function applyTo(canvasEl) {
	    var context = canvasEl.getContext('2d'),
	        imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	        data = imageData.data,
	        color = this.color,
	        threshold = 60,
	        distance = this.distance,
	        limit = 255 - threshold,
	        r,
	        g,
	        b;
	
	    for (var i = 0, len = data.length; i < len; i += 4) {
	      r = data[i];
	      g = data[i + 1];
	      b = data[i + 2];
	
	      if (Math.abs(r - color._source[0]) < distance && Math.abs(g - color._source[1]) < distance && Math.abs(b - color._source[2]) < distance) {
	        data[i + 3] = 0;
	      }
	    }
	    context.putImageData(imageData, 0, 0);
	  },
	
	  toObject: function toObject() {
	    return extend(this.callSuper('toObject'), {
	      color: this.color
	    });
	  }
	});
	
	_fabric.fabric.Image.filters.RemoveColor.fromObject = function (object) {
	  return new _fabric.fabric.Image.filters.RemoveColor(object);
	};

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	__webpack_require__(68);
	
	__webpack_require__(359);
	
	__webpack_require__(360);
	
	if (global._babelPolyfill) {
	  throw new Error("only one instance of babel-polyfill is allowed");
	}
	global._babelPolyfill = true;
	
	var DEFINE_PROPERTY = "defineProperty";
	function define(O, key, value) {
	  O[key] || Object[DEFINE_PROPERTY](O, key, {
	    writable: true,
	    configurable: true,
	    value: value
	  });
	}
	
	define(String.prototype, "padLeft", "".padStart);
	define(String.prototype, "padRight", "".padEnd);
	
	"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
	  [][key] && define(Array, key, Function.call.bind([][key]));
	});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(69);
	__webpack_require__(118);
	__webpack_require__(119);
	__webpack_require__(120);
	__webpack_require__(121);
	__webpack_require__(123);
	__webpack_require__(126);
	__webpack_require__(127);
	__webpack_require__(128);
	__webpack_require__(129);
	__webpack_require__(130);
	__webpack_require__(131);
	__webpack_require__(132);
	__webpack_require__(133);
	__webpack_require__(134);
	__webpack_require__(136);
	__webpack_require__(138);
	__webpack_require__(140);
	__webpack_require__(142);
	__webpack_require__(145);
	__webpack_require__(146);
	__webpack_require__(147);
	__webpack_require__(151);
	__webpack_require__(153);
	__webpack_require__(155);
	__webpack_require__(158);
	__webpack_require__(159);
	__webpack_require__(160);
	__webpack_require__(161);
	__webpack_require__(163);
	__webpack_require__(164);
	__webpack_require__(165);
	__webpack_require__(166);
	__webpack_require__(167);
	__webpack_require__(168);
	__webpack_require__(169);
	__webpack_require__(171);
	__webpack_require__(172);
	__webpack_require__(173);
	__webpack_require__(175);
	__webpack_require__(176);
	__webpack_require__(177);
	__webpack_require__(179);
	__webpack_require__(180);
	__webpack_require__(181);
	__webpack_require__(182);
	__webpack_require__(183);
	__webpack_require__(184);
	__webpack_require__(185);
	__webpack_require__(186);
	__webpack_require__(187);
	__webpack_require__(188);
	__webpack_require__(189);
	__webpack_require__(190);
	__webpack_require__(191);
	__webpack_require__(192);
	__webpack_require__(197);
	__webpack_require__(198);
	__webpack_require__(202);
	__webpack_require__(203);
	__webpack_require__(204);
	__webpack_require__(205);
	__webpack_require__(207);
	__webpack_require__(208);
	__webpack_require__(209);
	__webpack_require__(210);
	__webpack_require__(211);
	__webpack_require__(212);
	__webpack_require__(213);
	__webpack_require__(214);
	__webpack_require__(215);
	__webpack_require__(216);
	__webpack_require__(217);
	__webpack_require__(218);
	__webpack_require__(219);
	__webpack_require__(220);
	__webpack_require__(221);
	__webpack_require__(222);
	__webpack_require__(223);
	__webpack_require__(225);
	__webpack_require__(226);
	__webpack_require__(232);
	__webpack_require__(233);
	__webpack_require__(235);
	__webpack_require__(236);
	__webpack_require__(237);
	__webpack_require__(241);
	__webpack_require__(242);
	__webpack_require__(243);
	__webpack_require__(244);
	__webpack_require__(245);
	__webpack_require__(247);
	__webpack_require__(248);
	__webpack_require__(249);
	__webpack_require__(250);
	__webpack_require__(253);
	__webpack_require__(255);
	__webpack_require__(256);
	__webpack_require__(257);
	__webpack_require__(259);
	__webpack_require__(261);
	__webpack_require__(263);
	__webpack_require__(264);
	__webpack_require__(265);
	__webpack_require__(267);
	__webpack_require__(268);
	__webpack_require__(269);
	__webpack_require__(270);
	__webpack_require__(277);
	__webpack_require__(280);
	__webpack_require__(281);
	__webpack_require__(283);
	__webpack_require__(284);
	__webpack_require__(287);
	__webpack_require__(288);
	__webpack_require__(290);
	__webpack_require__(291);
	__webpack_require__(292);
	__webpack_require__(293);
	__webpack_require__(294);
	__webpack_require__(295);
	__webpack_require__(296);
	__webpack_require__(297);
	__webpack_require__(298);
	__webpack_require__(299);
	__webpack_require__(300);
	__webpack_require__(301);
	__webpack_require__(302);
	__webpack_require__(303);
	__webpack_require__(304);
	__webpack_require__(305);
	__webpack_require__(306);
	__webpack_require__(307);
	__webpack_require__(308);
	__webpack_require__(310);
	__webpack_require__(311);
	__webpack_require__(312);
	__webpack_require__(313);
	__webpack_require__(314);
	__webpack_require__(315);
	__webpack_require__(317);
	__webpack_require__(318);
	__webpack_require__(319);
	__webpack_require__(320);
	__webpack_require__(321);
	__webpack_require__(322);
	__webpack_require__(323);
	__webpack_require__(324);
	__webpack_require__(326);
	__webpack_require__(327);
	__webpack_require__(329);
	__webpack_require__(330);
	__webpack_require__(331);
	__webpack_require__(332);
	__webpack_require__(335);
	__webpack_require__(336);
	__webpack_require__(337);
	__webpack_require__(338);
	__webpack_require__(339);
	__webpack_require__(340);
	__webpack_require__(341);
	__webpack_require__(342);
	__webpack_require__(344);
	__webpack_require__(345);
	__webpack_require__(346);
	__webpack_require__(347);
	__webpack_require__(348);
	__webpack_require__(349);
	__webpack_require__(350);
	__webpack_require__(351);
	__webpack_require__(352);
	__webpack_require__(353);
	__webpack_require__(354);
	__webpack_require__(357);
	__webpack_require__(358);
	module.exports = __webpack_require__(75);

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(70)
	  , has            = __webpack_require__(71)
	  , DESCRIPTORS    = __webpack_require__(72)
	  , $export        = __webpack_require__(74)
	  , redefine       = __webpack_require__(84)
	  , META           = __webpack_require__(88).KEY
	  , $fails         = __webpack_require__(73)
	  , shared         = __webpack_require__(89)
	  , setToStringTag = __webpack_require__(90)
	  , uid            = __webpack_require__(85)
	  , wks            = __webpack_require__(91)
	  , wksExt         = __webpack_require__(92)
	  , wksDefine      = __webpack_require__(93)
	  , keyOf          = __webpack_require__(95)
	  , enumKeys       = __webpack_require__(108)
	  , isArray        = __webpack_require__(111)
	  , anObject       = __webpack_require__(78)
	  , toIObject      = __webpack_require__(98)
	  , toPrimitive    = __webpack_require__(82)
	  , createDesc     = __webpack_require__(83)
	  , _create        = __webpack_require__(112)
	  , gOPNExt        = __webpack_require__(115)
	  , $GOPD          = __webpack_require__(117)
	  , $DP            = __webpack_require__(77)
	  , $keys          = __webpack_require__(96)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(116).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(110).f  = $propertyIsEnumerable;
	  __webpack_require__(109).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(94)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);
	
	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(76)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 70 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 71 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(73)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 73 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(70)
	  , core      = __webpack_require__(75)
	  , hide      = __webpack_require__(76)
	  , redefine  = __webpack_require__(84)
	  , ctx       = __webpack_require__(86)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
	    , key, own, out, exp;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // extend global
	    if(target)redefine(target, key, out, type & $export.U);
	    // export
	    if(exports[key] != out)hide(exports, key, exp);
	    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
	  }
	};
	global.core = core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 75 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(77)
	  , createDesc = __webpack_require__(83);
	module.exports = __webpack_require__(72) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(78)
	  , IE8_DOM_DEFINE = __webpack_require__(80)
	  , toPrimitive    = __webpack_require__(82)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(72) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(79);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 79 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(72) && !__webpack_require__(73)(function(){
	  return Object.defineProperty(__webpack_require__(81)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(79)
	  , document = __webpack_require__(70).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(79);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 83 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(70)
	  , hide      = __webpack_require__(76)
	  , has       = __webpack_require__(71)
	  , SRC       = __webpack_require__(85)('src')
	  , TO_STRING = 'toString'
	  , $toString = Function[TO_STRING]
	  , TPL       = ('' + $toString).split(TO_STRING);
	
	__webpack_require__(75).inspectSource = function(it){
	  return $toString.call(it);
	};
	
	(module.exports = function(O, key, val, safe){
	  var isFunction = typeof val == 'function';
	  if(isFunction)has(val, 'name') || hide(val, 'name', key);
	  if(O[key] === val)return;
	  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	  if(O === global){
	    O[key] = val;
	  } else {
	    if(!safe){
	      delete O[key];
	      hide(O, key, val);
	    } else {
	      if(O[key])O[key] = val;
	      else hide(O, key, val);
	    }
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString(){
	  return typeof this == 'function' && this[SRC] || $toString.call(this);
	});

/***/ },
/* 85 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(87);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 87 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(85)('meta')
	  , isObject = __webpack_require__(79)
	  , has      = __webpack_require__(71)
	  , setDesc  = __webpack_require__(77).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(73)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(70)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(77).f
	  , has = __webpack_require__(71)
	  , TAG = __webpack_require__(91)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(89)('wks')
	  , uid        = __webpack_require__(85)
	  , Symbol     = __webpack_require__(70).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(91);

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(70)
	  , core           = __webpack_require__(75)
	  , LIBRARY        = __webpack_require__(94)
	  , wksExt         = __webpack_require__(92)
	  , defineProperty = __webpack_require__(77).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 94 */
/***/ function(module, exports) {

	module.exports = false;

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(96)
	  , toIObject = __webpack_require__(98);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(97)
	  , enumBugKeys = __webpack_require__(107);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(71)
	  , toIObject    = __webpack_require__(98)
	  , arrayIndexOf = __webpack_require__(102)(false)
	  , IE_PROTO     = __webpack_require__(106)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(99)
	  , defined = __webpack_require__(101);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(100);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 100 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 101 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(98)
	  , toLength  = __webpack_require__(103)
	  , toIndex   = __webpack_require__(105);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(104)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 104 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(104)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(89)('keys')
	  , uid    = __webpack_require__(85);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 107 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(96)
	  , gOPS    = __webpack_require__(109)
	  , pIE     = __webpack_require__(110);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 109 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 110 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(100);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(78)
	  , dPs         = __webpack_require__(113)
	  , enumBugKeys = __webpack_require__(107)
	  , IE_PROTO    = __webpack_require__(106)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(81)('iframe')
	    , i      = enumBugKeys.length
	    , lt     = '<'
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(114).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(77)
	  , anObject = __webpack_require__(78)
	  , getKeys  = __webpack_require__(96);
	
	module.exports = __webpack_require__(72) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(70).document && document.documentElement;

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(98)
	  , gOPN      = __webpack_require__(116).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(97)
	  , hiddenKeys = __webpack_require__(107).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(110)
	  , createDesc     = __webpack_require__(83)
	  , toIObject      = __webpack_require__(98)
	  , toPrimitive    = __webpack_require__(82)
	  , has            = __webpack_require__(71)
	  , IE8_DOM_DEFINE = __webpack_require__(80)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(72) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(74)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(112)});

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(74);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(72), 'Object', {defineProperty: __webpack_require__(77).f});

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(74);
	// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
	$export($export.S + $export.F * !__webpack_require__(72), 'Object', {defineProperties: __webpack_require__(113)});

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	var toIObject                 = __webpack_require__(98)
	  , $getOwnPropertyDescriptor = __webpack_require__(117).f;
	
	__webpack_require__(122)('getOwnPropertyDescriptor', function(){
	  return function getOwnPropertyDescriptor(it, key){
	    return $getOwnPropertyDescriptor(toIObject(it), key);
	  };
	});

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(74)
	  , core    = __webpack_require__(75)
	  , fails   = __webpack_require__(73);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject        = __webpack_require__(124)
	  , $getPrototypeOf = __webpack_require__(125);
	
	__webpack_require__(122)('getPrototypeOf', function(){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(101);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(71)
	  , toObject    = __webpack_require__(124)
	  , IE_PROTO    = __webpack_require__(106)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(124)
	  , $keys    = __webpack_require__(96);
	
	__webpack_require__(122)('keys', function(){
	  return function keys(it){
	    return $keys(toObject(it));
	  };
	});

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 Object.getOwnPropertyNames(O)
	__webpack_require__(122)('getOwnPropertyNames', function(){
	  return __webpack_require__(115).f;
	});

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.5 Object.freeze(O)
	var isObject = __webpack_require__(79)
	  , meta     = __webpack_require__(88).onFreeze;
	
	__webpack_require__(122)('freeze', function($freeze){
	  return function freeze(it){
	    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
	  };
	});

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.17 Object.seal(O)
	var isObject = __webpack_require__(79)
	  , meta     = __webpack_require__(88).onFreeze;
	
	__webpack_require__(122)('seal', function($seal){
	  return function seal(it){
	    return $seal && isObject(it) ? $seal(meta(it)) : it;
	  };
	});

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.15 Object.preventExtensions(O)
	var isObject = __webpack_require__(79)
	  , meta     = __webpack_require__(88).onFreeze;
	
	__webpack_require__(122)('preventExtensions', function($preventExtensions){
	  return function preventExtensions(it){
	    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
	  };
	});

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.12 Object.isFrozen(O)
	var isObject = __webpack_require__(79);
	
	__webpack_require__(122)('isFrozen', function($isFrozen){
	  return function isFrozen(it){
	    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
	  };
	});

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.13 Object.isSealed(O)
	var isObject = __webpack_require__(79);
	
	__webpack_require__(122)('isSealed', function($isSealed){
	  return function isSealed(it){
	    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
	  };
	});

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.11 Object.isExtensible(O)
	var isObject = __webpack_require__(79);
	
	__webpack_require__(122)('isExtensible', function($isExtensible){
	  return function isExtensible(it){
	    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
	  };
	});

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(74);
	
	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(135)});

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(96)
	  , gOPS     = __webpack_require__(109)
	  , pIE      = __webpack_require__(110)
	  , toObject = __webpack_require__(124)
	  , IObject  = __webpack_require__(99)
	  , $assign  = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(73)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.10 Object.is(value1, value2)
	var $export = __webpack_require__(74);
	$export($export.S, 'Object', {is: __webpack_require__(137)});

/***/ },
/* 137 */
/***/ function(module, exports) {

	// 7.2.9 SameValue(x, y)
	module.exports = Object.is || function is(x, y){
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(74);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(139).set});

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(79)
	  , anObject = __webpack_require__(78);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(86)(Function.call, __webpack_require__(117).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.3.6 Object.prototype.toString()
	var classof = __webpack_require__(141)
	  , test    = {};
	test[__webpack_require__(91)('toStringTag')] = 'z';
	if(test + '' != '[object z]'){
	  __webpack_require__(84)(Object.prototype, 'toString', function toString(){
	    return '[object ' + classof(this) + ']';
	  }, true);
	}

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(100)
	  , TAG = __webpack_require__(91)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
	var $export = __webpack_require__(74);
	
	$export($export.P, 'Function', {bind: __webpack_require__(143)});

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var aFunction  = __webpack_require__(87)
	  , isObject   = __webpack_require__(79)
	  , invoke     = __webpack_require__(144)
	  , arraySlice = [].slice
	  , factories  = {};
	
	var construct = function(F, len, args){
	  if(!(len in factories)){
	    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
	    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
	  } return factories[len](F, args);
	};
	
	module.exports = Function.bind || function bind(that /*, args... */){
	  var fn       = aFunction(this)
	    , partArgs = arraySlice.call(arguments, 1);
	  var bound = function(/* args... */){
	    var args = partArgs.concat(arraySlice.call(arguments));
	    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
	  };
	  if(isObject(fn.prototype))bound.prototype = fn.prototype;
	  return bound;
	};

/***/ },
/* 144 */
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(77).f
	  , createDesc = __webpack_require__(83)
	  , has        = __webpack_require__(71)
	  , FProto     = Function.prototype
	  , nameRE     = /^\s*function ([^ (]*)/
	  , NAME       = 'name';
	
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	
	// 19.2.4.2 name
	NAME in FProto || __webpack_require__(72) && dP(FProto, NAME, {
	  configurable: true,
	  get: function(){
	    try {
	      var that = this
	        , name = ('' + that).match(nameRE)[1];
	      has(that, NAME) || !isExtensible(that) || dP(that, NAME, createDesc(5, name));
	      return name;
	    } catch(e){
	      return '';
	    }
	  }
	});

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var isObject       = __webpack_require__(79)
	  , getPrototypeOf = __webpack_require__(125)
	  , HAS_INSTANCE   = __webpack_require__(91)('hasInstance')
	  , FunctionProto  = Function.prototype;
	// 19.2.3.6 Function.prototype[@@hasInstance](V)
	if(!(HAS_INSTANCE in FunctionProto))__webpack_require__(77).f(FunctionProto, HAS_INSTANCE, {value: function(O){
	  if(typeof this != 'function' || !isObject(O))return false;
	  if(!isObject(this.prototype))return O instanceof this;
	  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	  while(O = getPrototypeOf(O))if(this.prototype === O)return true;
	  return false;
	}});

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(74)
	  , $parseInt = __webpack_require__(148);
	// 18.2.5 parseInt(string, radix)
	$export($export.G + $export.F * (parseInt != $parseInt), {parseInt: $parseInt});

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	var $parseInt = __webpack_require__(70).parseInt
	  , $trim     = __webpack_require__(149).trim
	  , ws        = __webpack_require__(150)
	  , hex       = /^[\-+]?0[xX]/;
	
	module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix){
	  var string = $trim(String(str), 3);
	  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
	} : $parseInt;

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(74)
	  , defined = __webpack_require__(101)
	  , fails   = __webpack_require__(73)
	  , spaces  = __webpack_require__(150)
	  , space   = '[' + spaces + ']'
	  , non     = '\u200b\u0085'
	  , ltrim   = RegExp('^' + space + space + '*')
	  , rtrim   = RegExp(space + space + '*$');
	
	var exporter = function(KEY, exec, ALIAS){
	  var exp   = {};
	  var FORCE = fails(function(){
	    return !!spaces[KEY]() || non[KEY]() != non;
	  });
	  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
	  if(ALIAS)exp[ALIAS] = fn;
	  $export($export.P + $export.F * FORCE, 'String', exp);
	};
	
	// 1 -> String#trimLeft
	// 2 -> String#trimRight
	// 3 -> String#trim
	var trim = exporter.trim = function(string, TYPE){
	  string = String(defined(string));
	  if(TYPE & 1)string = string.replace(ltrim, '');
	  if(TYPE & 2)string = string.replace(rtrim, '');
	  return string;
	};
	
	module.exports = exporter;

/***/ },
/* 150 */
/***/ function(module, exports) {

	module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	var $export     = __webpack_require__(74)
	  , $parseFloat = __webpack_require__(152);
	// 18.2.4 parseFloat(string)
	$export($export.G + $export.F * (parseFloat != $parseFloat), {parseFloat: $parseFloat});

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	var $parseFloat = __webpack_require__(70).parseFloat
	  , $trim       = __webpack_require__(149).trim;
	
	module.exports = 1 / $parseFloat(__webpack_require__(150) + '-0') !== -Infinity ? function parseFloat(str){
	  var string = $trim(String(str), 3)
	    , result = $parseFloat(string);
	  return result === 0 && string.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global            = __webpack_require__(70)
	  , has               = __webpack_require__(71)
	  , cof               = __webpack_require__(100)
	  , inheritIfRequired = __webpack_require__(154)
	  , toPrimitive       = __webpack_require__(82)
	  , fails             = __webpack_require__(73)
	  , gOPN              = __webpack_require__(116).f
	  , gOPD              = __webpack_require__(117).f
	  , dP                = __webpack_require__(77).f
	  , $trim             = __webpack_require__(149).trim
	  , NUMBER            = 'Number'
	  , $Number           = global[NUMBER]
	  , Base              = $Number
	  , proto             = $Number.prototype
	  // Opera ~12 has broken Object#toString
	  , BROKEN_COF        = cof(__webpack_require__(112)(proto)) == NUMBER
	  , TRIM              = 'trim' in String.prototype;
	
	// 7.1.3 ToNumber(argument)
	var toNumber = function(argument){
	  var it = toPrimitive(argument, false);
	  if(typeof it == 'string' && it.length > 2){
	    it = TRIM ? it.trim() : $trim(it, 3);
	    var first = it.charCodeAt(0)
	      , third, radix, maxCode;
	    if(first === 43 || first === 45){
	      third = it.charCodeAt(2);
	      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if(first === 48){
	      switch(it.charCodeAt(1)){
	        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
	        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
	        default : return +it;
	      }
	      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){
	        code = digits.charCodeAt(i);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if(code < 48 || code > maxCode)return NaN;
	      } return parseInt(digits, radix);
	    }
	  } return +it;
	};
	
	if(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){
	  $Number = function Number(value){
	    var it = arguments.length < 1 ? 0 : value
	      , that = this;
	    return that instanceof $Number
	      // check on 1..constructor(foo) case
	      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)
	        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
	  };
	  for(var keys = __webpack_require__(72) ? gOPN(Base) : (
	    // ES3:
	    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	    // ES6 (in case, if modules with ES6 Number statics required before):
	    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
	    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
	  ).split(','), j = 0, key; keys.length > j; j++){
	    if(has(Base, key = keys[j]) && !has($Number, key)){
	      dP($Number, key, gOPD(Base, key));
	    }
	  }
	  $Number.prototype = proto;
	  proto.constructor = $Number;
	  __webpack_require__(84)(global, NUMBER, $Number);
	}

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	var isObject       = __webpack_require__(79)
	  , setPrototypeOf = __webpack_require__(139).set;
	module.exports = function(that, target, C){
	  var P, S = target.constructor;
	  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){
	    setPrototypeOf(that, P);
	  } return that;
	};

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(74)
	  , toInteger    = __webpack_require__(104)
	  , aNumberValue = __webpack_require__(156)
	  , repeat       = __webpack_require__(157)
	  , $toFixed     = 1..toFixed
	  , floor        = Math.floor
	  , data         = [0, 0, 0, 0, 0, 0]
	  , ERROR        = 'Number.toFixed: incorrect invocation!'
	  , ZERO         = '0';
	
	var multiply = function(n, c){
	  var i  = -1
	    , c2 = c;
	  while(++i < 6){
	    c2 += n * data[i];
	    data[i] = c2 % 1e7;
	    c2 = floor(c2 / 1e7);
	  }
	};
	var divide = function(n){
	  var i = 6
	    , c = 0;
	  while(--i >= 0){
	    c += data[i];
	    data[i] = floor(c / n);
	    c = (c % n) * 1e7;
	  }
	};
	var numToString = function(){
	  var i = 6
	    , s = '';
	  while(--i >= 0){
	    if(s !== '' || i === 0 || data[i] !== 0){
	      var t = String(data[i]);
	      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
	    }
	  } return s;
	};
	var pow = function(x, n, acc){
	  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
	};
	var log = function(x){
	  var n  = 0
	    , x2 = x;
	  while(x2 >= 4096){
	    n += 12;
	    x2 /= 4096;
	  }
	  while(x2 >= 2){
	    n  += 1;
	    x2 /= 2;
	  } return n;
	};
	
	$export($export.P + $export.F * (!!$toFixed && (
	  0.00008.toFixed(3) !== '0.000' ||
	  0.9.toFixed(0) !== '1' ||
	  1.255.toFixed(2) !== '1.25' ||
	  1000000000000000128..toFixed(0) !== '1000000000000000128'
	) || !__webpack_require__(73)(function(){
	  // V8 ~ Android 4.3-
	  $toFixed.call({});
	})), 'Number', {
	  toFixed: function toFixed(fractionDigits){
	    var x = aNumberValue(this, ERROR)
	      , f = toInteger(fractionDigits)
	      , s = ''
	      , m = ZERO
	      , e, z, j, k;
	    if(f < 0 || f > 20)throw RangeError(ERROR);
	    if(x != x)return 'NaN';
	    if(x <= -1e21 || x >= 1e21)return String(x);
	    if(x < 0){
	      s = '-';
	      x = -x;
	    }
	    if(x > 1e-21){
	      e = log(x * pow(2, 69, 1)) - 69;
	      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;
	      if(e > 0){
	        multiply(0, z);
	        j = f;
	        while(j >= 7){
	          multiply(1e7, 0);
	          j -= 7;
	        }
	        multiply(pow(10, j, 1), 0);
	        j = e - 1;
	        while(j >= 23){
	          divide(1 << 23);
	          j -= 23;
	        }
	        divide(1 << j);
	        multiply(1, 1);
	        divide(2);
	        m = numToString();
	      } else {
	        multiply(0, z);
	        multiply(1 << -e, 0);
	        m = numToString() + repeat.call(ZERO, f);
	      }
	    }
	    if(f > 0){
	      k = m.length;
	      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
	    } else {
	      m = s + m;
	    } return m;
	  }
	});

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	var cof = __webpack_require__(100);
	module.exports = function(it, msg){
	  if(typeof it != 'number' && cof(it) != 'Number')throw TypeError(msg);
	  return +it;
	};

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var toInteger = __webpack_require__(104)
	  , defined   = __webpack_require__(101);
	
	module.exports = function repeat(count){
	  var str = String(defined(this))
	    , res = ''
	    , n   = toInteger(count);
	  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
	  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
	  return res;
	};

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(74)
	  , $fails       = __webpack_require__(73)
	  , aNumberValue = __webpack_require__(156)
	  , $toPrecision = 1..toPrecision;
	
	$export($export.P + $export.F * ($fails(function(){
	  // IE7-
	  return $toPrecision.call(1, undefined) !== '1';
	}) || !$fails(function(){
	  // V8 ~ Android 4.3-
	  $toPrecision.call({});
	})), 'Number', {
	  toPrecision: function toPrecision(precision){
	    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
	    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision); 
	  }
	});

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.1 Number.EPSILON
	var $export = __webpack_require__(74);
	
	$export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.2 Number.isFinite(number)
	var $export   = __webpack_require__(74)
	  , _isFinite = __webpack_require__(70).isFinite;
	
	$export($export.S, 'Number', {
	  isFinite: function isFinite(it){
	    return typeof it == 'number' && _isFinite(it);
	  }
	});

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var $export = __webpack_require__(74);
	
	$export($export.S, 'Number', {isInteger: __webpack_require__(162)});

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var isObject = __webpack_require__(79)
	  , floor    = Math.floor;
	module.exports = function isInteger(it){
	  return !isObject(it) && isFinite(it) && floor(it) === it;
	};

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.4 Number.isNaN(number)
	var $export = __webpack_require__(74);
	
	$export($export.S, 'Number', {
	  isNaN: function isNaN(number){
	    return number != number;
	  }
	});

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.5 Number.isSafeInteger(number)
	var $export   = __webpack_require__(74)
	  , isInteger = __webpack_require__(162)
	  , abs       = Math.abs;
	
	$export($export.S, 'Number', {
	  isSafeInteger: function isSafeInteger(number){
	    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
	  }
	});

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.6 Number.MAX_SAFE_INTEGER
	var $export = __webpack_require__(74);
	
	$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.10 Number.MIN_SAFE_INTEGER
	var $export = __webpack_require__(74);
	
	$export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	var $export     = __webpack_require__(74)
	  , $parseFloat = __webpack_require__(152);
	// 20.1.2.12 Number.parseFloat(string)
	$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {parseFloat: $parseFloat});

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(74)
	  , $parseInt = __webpack_require__(148);
	// 20.1.2.13 Number.parseInt(string, radix)
	$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {parseInt: $parseInt});

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.3 Math.acosh(x)
	var $export = __webpack_require__(74)
	  , log1p   = __webpack_require__(170)
	  , sqrt    = Math.sqrt
	  , $acosh  = Math.acosh;
	
	$export($export.S + $export.F * !($acosh
	  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
	  && Math.floor($acosh(Number.MAX_VALUE)) == 710
	  // Tor Browser bug: Math.acosh(Infinity) -> NaN 
	  && $acosh(Infinity) == Infinity
	), 'Math', {
	  acosh: function acosh(x){
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156
	      ? Math.log(x) + Math.LN2
	      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
	  }
	});

/***/ },
/* 170 */
/***/ function(module, exports) {

	// 20.2.2.20 Math.log1p(x)
	module.exports = Math.log1p || function log1p(x){
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
	};

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.5 Math.asinh(x)
	var $export = __webpack_require__(74)
	  , $asinh  = Math.asinh;
	
	function asinh(x){
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
	}
	
	// Tor Browser bug: Math.asinh(0) -> -0 
	$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {asinh: asinh});

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.7 Math.atanh(x)
	var $export = __webpack_require__(74)
	  , $atanh  = Math.atanh;
	
	// Tor Browser bug: Math.atanh(-0) -> 0 
	$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
	  atanh: function atanh(x){
	    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
	  }
	});

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.9 Math.cbrt(x)
	var $export = __webpack_require__(74)
	  , sign    = __webpack_require__(174);
	
	$export($export.S, 'Math', {
	  cbrt: function cbrt(x){
	    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
	  }
	});

/***/ },
/* 174 */
/***/ function(module, exports) {

	// 20.2.2.28 Math.sign(x)
	module.exports = Math.sign || function sign(x){
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.11 Math.clz32(x)
	var $export = __webpack_require__(74);
	
	$export($export.S, 'Math', {
	  clz32: function clz32(x){
	    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
	  }
	});

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.12 Math.cosh(x)
	var $export = __webpack_require__(74)
	  , exp     = Math.exp;
	
	$export($export.S, 'Math', {
	  cosh: function cosh(x){
	    return (exp(x = +x) + exp(-x)) / 2;
	  }
	});

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.14 Math.expm1(x)
	var $export = __webpack_require__(74)
	  , $expm1  = __webpack_require__(178);
	
	$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {expm1: $expm1});

/***/ },
/* 178 */
/***/ function(module, exports) {

	// 20.2.2.14 Math.expm1(x)
	var $expm1 = Math.expm1;
	module.exports = (!$expm1
	  // Old FF bug
	  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
	  // Tor Browser bug
	  || $expm1(-2e-17) != -2e-17
	) ? function expm1(x){
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
	} : $expm1;

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.16 Math.fround(x)
	var $export   = __webpack_require__(74)
	  , sign      = __webpack_require__(174)
	  , pow       = Math.pow
	  , EPSILON   = pow(2, -52)
	  , EPSILON32 = pow(2, -23)
	  , MAX32     = pow(2, 127) * (2 - EPSILON32)
	  , MIN32     = pow(2, -126);
	
	var roundTiesToEven = function(n){
	  return n + 1 / EPSILON - 1 / EPSILON;
	};
	
	
	$export($export.S, 'Math', {
	  fround: function fround(x){
	    var $abs  = Math.abs(x)
	      , $sign = sign(x)
	      , a, result;
	    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	    a = (1 + EPSILON32 / EPSILON) * $abs;
	    result = a - (a - $abs);
	    if(result > MAX32 || result != result)return $sign * Infinity;
	    return $sign * result;
	  }
	});

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
	var $export = __webpack_require__(74)
	  , abs     = Math.abs;
	
	$export($export.S, 'Math', {
	  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
	    var sum  = 0
	      , i    = 0
	      , aLen = arguments.length
	      , larg = 0
	      , arg, div;
	    while(i < aLen){
	      arg = abs(arguments[i++]);
	      if(larg < arg){
	        div  = larg / arg;
	        sum  = sum * div * div + 1;
	        larg = arg;
	      } else if(arg > 0){
	        div  = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }
	    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
	  }
	});

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.18 Math.imul(x, y)
	var $export = __webpack_require__(74)
	  , $imul   = Math.imul;
	
	// some WebKit versions fails with big numbers, some has wrong arity
	$export($export.S + $export.F * __webpack_require__(73)(function(){
	  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
	}), 'Math', {
	  imul: function imul(x, y){
	    var UINT16 = 0xffff
	      , xn = +x
	      , yn = +y
	      , xl = UINT16 & xn
	      , yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.21 Math.log10(x)
	var $export = __webpack_require__(74);
	
	$export($export.S, 'Math', {
	  log10: function log10(x){
	    return Math.log(x) / Math.LN10;
	  }
	});

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.20 Math.log1p(x)
	var $export = __webpack_require__(74);
	
	$export($export.S, 'Math', {log1p: __webpack_require__(170)});

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.22 Math.log2(x)
	var $export = __webpack_require__(74);
	
	$export($export.S, 'Math', {
	  log2: function log2(x){
	    return Math.log(x) / Math.LN2;
	  }
	});

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.28 Math.sign(x)
	var $export = __webpack_require__(74);
	
	$export($export.S, 'Math', {sign: __webpack_require__(174)});

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.30 Math.sinh(x)
	var $export = __webpack_require__(74)
	  , expm1   = __webpack_require__(178)
	  , exp     = Math.exp;
	
	// V8 near Chromium 38 has a problem with very small numbers
	$export($export.S + $export.F * __webpack_require__(73)(function(){
	  return !Math.sinh(-2e-17) != -2e-17;
	}), 'Math', {
	  sinh: function sinh(x){
	    return Math.abs(x = +x) < 1
	      ? (expm1(x) - expm1(-x)) / 2
	      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
	  }
	});

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.33 Math.tanh(x)
	var $export = __webpack_require__(74)
	  , expm1   = __webpack_require__(178)
	  , exp     = Math.exp;
	
	$export($export.S, 'Math', {
	  tanh: function tanh(x){
	    var a = expm1(x = +x)
	      , b = expm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
	  }
	});

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.34 Math.trunc(x)
	var $export = __webpack_require__(74);
	
	$export($export.S, 'Math', {
	  trunc: function trunc(it){
	    return (it > 0 ? Math.floor : Math.ceil)(it);
	  }
	});

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	var $export        = __webpack_require__(74)
	  , toIndex        = __webpack_require__(105)
	  , fromCharCode   = String.fromCharCode
	  , $fromCodePoint = String.fromCodePoint;
	
	// length should be 1, old FF problem
	$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
	    var res  = []
	      , aLen = arguments.length
	      , i    = 0
	      , code;
	    while(aLen > i){
	      code = +arguments[i++];
	      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
	      res.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
	      );
	    } return res.join('');
	  }
	});

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(74)
	  , toIObject = __webpack_require__(98)
	  , toLength  = __webpack_require__(103);
	
	$export($export.S, 'String', {
	  // 21.1.2.4 String.raw(callSite, ...substitutions)
	  raw: function raw(callSite){
	    var tpl  = toIObject(callSite.raw)
	      , len  = toLength(tpl.length)
	      , aLen = arguments.length
	      , res  = []
	      , i    = 0;
	    while(len > i){
	      res.push(String(tpl[i++]));
	      if(i < aLen)res.push(String(arguments[i]));
	    } return res.join('');
	  }
	});

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 21.1.3.25 String.prototype.trim()
	__webpack_require__(149)('trim', function($trim){
	  return function trim(){
	    return $trim(this, 3);
	  };
	});

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(193)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(194)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(104)
	  , defined   = __webpack_require__(101);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(94)
	  , $export        = __webpack_require__(74)
	  , redefine       = __webpack_require__(84)
	  , hide           = __webpack_require__(76)
	  , has            = __webpack_require__(71)
	  , Iterators      = __webpack_require__(195)
	  , $iterCreate    = __webpack_require__(196)
	  , setToStringTag = __webpack_require__(90)
	  , getPrototypeOf = __webpack_require__(125)
	  , ITERATOR       = __webpack_require__(91)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 195 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(112)
	  , descriptor     = __webpack_require__(83)
	  , setToStringTag = __webpack_require__(90)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(76)(IteratorPrototype, __webpack_require__(91)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(74)
	  , $at     = __webpack_require__(193)(false);
	$export($export.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
	'use strict';
	var $export   = __webpack_require__(74)
	  , toLength  = __webpack_require__(103)
	  , context   = __webpack_require__(199)
	  , ENDS_WITH = 'endsWith'
	  , $endsWith = ''[ENDS_WITH];
	
	$export($export.P + $export.F * __webpack_require__(201)(ENDS_WITH), 'String', {
	  endsWith: function endsWith(searchString /*, endPosition = @length */){
	    var that = context(this, searchString, ENDS_WITH)
	      , endPosition = arguments.length > 1 ? arguments[1] : undefined
	      , len    = toLength(that.length)
	      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)
	      , search = String(searchString);
	    return $endsWith
	      ? $endsWith.call(that, search, end)
	      : that.slice(end - search.length, end) === search;
	  }
	});

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	// helper for String#{startsWith, endsWith, includes}
	var isRegExp = __webpack_require__(200)
	  , defined  = __webpack_require__(101);
	
	module.exports = function(that, searchString, NAME){
	  if(isRegExp(searchString))throw TypeError('String#' + NAME + " doesn't accept regex!");
	  return String(defined(that));
	};

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.8 IsRegExp(argument)
	var isObject = __webpack_require__(79)
	  , cof      = __webpack_require__(100)
	  , MATCH    = __webpack_require__(91)('match');
	module.exports = function(it){
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
	};

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	var MATCH = __webpack_require__(91)('match');
	module.exports = function(KEY){
	  var re = /./;
	  try {
	    '/./'[KEY](re);
	  } catch(e){
	    try {
	      re[MATCH] = false;
	      return !'/./'[KEY](re);
	    } catch(f){ /* empty */ }
	  } return true;
	};

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.7 String.prototype.includes(searchString, position = 0)
	'use strict';
	var $export  = __webpack_require__(74)
	  , context  = __webpack_require__(199)
	  , INCLUDES = 'includes';
	
	$export($export.P + $export.F * __webpack_require__(201)(INCLUDES), 'String', {
	  includes: function includes(searchString /*, position = 0 */){
	    return !!~context(this, searchString, INCLUDES)
	      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(74);
	
	$export($export.P, 'String', {
	  // 21.1.3.13 String.prototype.repeat(count)
	  repeat: __webpack_require__(157)
	});

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
	'use strict';
	var $export     = __webpack_require__(74)
	  , toLength    = __webpack_require__(103)
	  , context     = __webpack_require__(199)
	  , STARTS_WITH = 'startsWith'
	  , $startsWith = ''[STARTS_WITH];
	
	$export($export.P + $export.F * __webpack_require__(201)(STARTS_WITH), 'String', {
	  startsWith: function startsWith(searchString /*, position = 0 */){
	    var that   = context(this, searchString, STARTS_WITH)
	      , index  = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length))
	      , search = String(searchString);
	    return $startsWith
	      ? $startsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.2 String.prototype.anchor(name)
	__webpack_require__(206)('anchor', function(createHTML){
	  return function anchor(name){
	    return createHTML(this, 'a', 'name', name);
	  }
	});

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(74)
	  , fails   = __webpack_require__(73)
	  , defined = __webpack_require__(101)
	  , quot    = /"/g;
	// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
	var createHTML = function(string, tag, attribute, value) {
	  var S  = String(defined(string))
	    , p1 = '<' + tag;
	  if(attribute !== '')p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
	  return p1 + '>' + S + '</' + tag + '>';
	};
	module.exports = function(NAME, exec){
	  var O = {};
	  O[NAME] = exec(createHTML);
	  $export($export.P + $export.F * fails(function(){
	    var test = ''[NAME]('"');
	    return test !== test.toLowerCase() || test.split('"').length > 3;
	  }), 'String', O);
	};

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.3 String.prototype.big()
	__webpack_require__(206)('big', function(createHTML){
	  return function big(){
	    return createHTML(this, 'big', '', '');
	  }
	});

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.4 String.prototype.blink()
	__webpack_require__(206)('blink', function(createHTML){
	  return function blink(){
	    return createHTML(this, 'blink', '', '');
	  }
	});

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.5 String.prototype.bold()
	__webpack_require__(206)('bold', function(createHTML){
	  return function bold(){
	    return createHTML(this, 'b', '', '');
	  }
	});

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.6 String.prototype.fixed()
	__webpack_require__(206)('fixed', function(createHTML){
	  return function fixed(){
	    return createHTML(this, 'tt', '', '');
	  }
	});

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.7 String.prototype.fontcolor(color)
	__webpack_require__(206)('fontcolor', function(createHTML){
	  return function fontcolor(color){
	    return createHTML(this, 'font', 'color', color);
	  }
	});

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.8 String.prototype.fontsize(size)
	__webpack_require__(206)('fontsize', function(createHTML){
	  return function fontsize(size){
	    return createHTML(this, 'font', 'size', size);
	  }
	});

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.9 String.prototype.italics()
	__webpack_require__(206)('italics', function(createHTML){
	  return function italics(){
	    return createHTML(this, 'i', '', '');
	  }
	});

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.10 String.prototype.link(url)
	__webpack_require__(206)('link', function(createHTML){
	  return function link(url){
	    return createHTML(this, 'a', 'href', url);
	  }
	});

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.11 String.prototype.small()
	__webpack_require__(206)('small', function(createHTML){
	  return function small(){
	    return createHTML(this, 'small', '', '');
	  }
	});

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.12 String.prototype.strike()
	__webpack_require__(206)('strike', function(createHTML){
	  return function strike(){
	    return createHTML(this, 'strike', '', '');
	  }
	});

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.13 String.prototype.sub()
	__webpack_require__(206)('sub', function(createHTML){
	  return function sub(){
	    return createHTML(this, 'sub', '', '');
	  }
	});

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.14 String.prototype.sup()
	__webpack_require__(206)('sup', function(createHTML){
	  return function sup(){
	    return createHTML(this, 'sup', '', '');
	  }
	});

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	// 20.3.3.1 / 15.9.4.4 Date.now()
	var $export = __webpack_require__(74);
	
	$export($export.S, 'Date', {now: function(){ return new Date().getTime(); }});

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export     = __webpack_require__(74)
	  , toObject    = __webpack_require__(124)
	  , toPrimitive = __webpack_require__(82);
	
	$export($export.P + $export.F * __webpack_require__(73)(function(){
	  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({toISOString: function(){ return 1; }}) !== 1;
	}), 'Date', {
	  toJSON: function toJSON(key){
	    var O  = toObject(this)
	      , pv = toPrimitive(O);
	    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
	  }
	});

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
	var $export = __webpack_require__(74)
	  , fails   = __webpack_require__(73)
	  , getTime = Date.prototype.getTime;
	
	var lz = function(num){
	  return num > 9 ? num : '0' + num;
	};
	
	// PhantomJS / old WebKit has a broken implementations
	$export($export.P + $export.F * (fails(function(){
	  return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';
	}) || !fails(function(){
	  new Date(NaN).toISOString();
	})), 'Date', {
	  toISOString: function toISOString(){
	    if(!isFinite(getTime.call(this)))throw RangeError('Invalid time value');
	    var d = this
	      , y = d.getUTCFullYear()
	      , m = d.getUTCMilliseconds()
	      , s = y < 0 ? '-' : y > 9999 ? '+' : '';
	    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
	      '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
	      'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
	      ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
	  }
	});

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	var DateProto    = Date.prototype
	  , INVALID_DATE = 'Invalid Date'
	  , TO_STRING    = 'toString'
	  , $toString    = DateProto[TO_STRING]
	  , getTime      = DateProto.getTime;
	if(new Date(NaN) + '' != INVALID_DATE){
	  __webpack_require__(84)(DateProto, TO_STRING, function toString(){
	    var value = getTime.call(this);
	    return value === value ? $toString.call(this) : INVALID_DATE;
	  });
	}

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	var TO_PRIMITIVE = __webpack_require__(91)('toPrimitive')
	  , proto        = Date.prototype;
	
	if(!(TO_PRIMITIVE in proto))__webpack_require__(76)(proto, TO_PRIMITIVE, __webpack_require__(224));

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var anObject    = __webpack_require__(78)
	  , toPrimitive = __webpack_require__(82)
	  , NUMBER      = 'number';
	
	module.exports = function(hint){
	  if(hint !== 'string' && hint !== NUMBER && hint !== 'default')throw TypeError('Incorrect hint');
	  return toPrimitive(anObject(this), hint != NUMBER);
	};

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
	var $export = __webpack_require__(74);
	
	$export($export.S, 'Array', {isArray: __webpack_require__(111)});

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx            = __webpack_require__(86)
	  , $export        = __webpack_require__(74)
	  , toObject       = __webpack_require__(124)
	  , call           = __webpack_require__(227)
	  , isArrayIter    = __webpack_require__(228)
	  , toLength       = __webpack_require__(103)
	  , createProperty = __webpack_require__(229)
	  , getIterFn      = __webpack_require__(230);
	
	$export($export.S + $export.F * !__webpack_require__(231)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(78);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(195)
	  , ITERATOR   = __webpack_require__(91)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(77)
	  , createDesc      = __webpack_require__(83);
	
	module.exports = function(object, index, value){
	  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(141)
	  , ITERATOR  = __webpack_require__(91)('iterator')
	  , Iterators = __webpack_require__(195);
	module.exports = __webpack_require__(75).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(91)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export        = __webpack_require__(74)
	  , createProperty = __webpack_require__(229);
	
	// WebKit Array.of isn't generic
	$export($export.S + $export.F * __webpack_require__(73)(function(){
	  function F(){}
	  return !(Array.of.call(F) instanceof F);
	}), 'Array', {
	  // 22.1.2.3 Array.of( ...items)
	  of: function of(/* ...args */){
	    var index  = 0
	      , aLen   = arguments.length
	      , result = new (typeof this == 'function' ? this : Array)(aLen);
	    while(aLen > index)createProperty(result, index, arguments[index++]);
	    result.length = aLen;
	    return result;
	  }
	});

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.13 Array.prototype.join(separator)
	var $export   = __webpack_require__(74)
	  , toIObject = __webpack_require__(98)
	  , arrayJoin = [].join;
	
	// fallback for not array-like strings
	$export($export.P + $export.F * (__webpack_require__(99) != Object || !__webpack_require__(234)(arrayJoin)), 'Array', {
	  join: function join(separator){
	    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
	  }
	});

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	var fails = __webpack_require__(73);
	
	module.exports = function(method, arg){
	  return !!method && fails(function(){
	    arg ? method.call(null, function(){}, 1) : method.call(null);
	  });
	};

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export    = __webpack_require__(74)
	  , html       = __webpack_require__(114)
	  , cof        = __webpack_require__(100)
	  , toIndex    = __webpack_require__(105)
	  , toLength   = __webpack_require__(103)
	  , arraySlice = [].slice;
	
	// fallback for not array-like ES3 strings and DOM objects
	$export($export.P + $export.F * __webpack_require__(73)(function(){
	  if(html)arraySlice.call(html);
	}), 'Array', {
	  slice: function slice(begin, end){
	    var len   = toLength(this.length)
	      , klass = cof(this);
	    end = end === undefined ? len : end;
	    if(klass == 'Array')return arraySlice.call(this, begin, end);
	    var start  = toIndex(begin, len)
	      , upTo   = toIndex(end, len)
	      , size   = toLength(upTo - start)
	      , cloned = Array(size)
	      , i      = 0;
	    for(; i < size; i++)cloned[i] = klass == 'String'
	      ? this.charAt(start + i)
	      : this[start + i];
	    return cloned;
	  }
	});

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export   = __webpack_require__(74)
	  , aFunction = __webpack_require__(87)
	  , toObject  = __webpack_require__(124)
	  , fails     = __webpack_require__(73)
	  , $sort     = [].sort
	  , test      = [1, 2, 3];
	
	$export($export.P + $export.F * (fails(function(){
	  // IE8-
	  test.sort(undefined);
	}) || !fails(function(){
	  // V8 bug
	  test.sort(null);
	  // Old WebKit
	}) || !__webpack_require__(234)($sort)), 'Array', {
	  // 22.1.3.25 Array.prototype.sort(comparefn)
	  sort: function sort(comparefn){
	    return comparefn === undefined
	      ? $sort.call(toObject(this))
	      : $sort.call(toObject(this), aFunction(comparefn));
	  }
	});

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export  = __webpack_require__(74)
	  , $forEach = __webpack_require__(238)(0)
	  , STRICT   = __webpack_require__(234)([].forEach, true);
	
	$export($export.P + $export.F * !STRICT, 'Array', {
	  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
	  forEach: function forEach(callbackfn /* , thisArg */){
	    return $forEach(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(86)
	  , IObject  = __webpack_require__(99)
	  , toObject = __webpack_require__(124)
	  , toLength = __webpack_require__(103)
	  , asc      = __webpack_require__(239);
	module.exports = function(TYPE, $create){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
	    , create        = $create || asc;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(240);
	
	module.exports = function(original, length){
	  return new (speciesConstructor(original))(length);
	};

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(79)
	  , isArray  = __webpack_require__(111)
	  , SPECIES  = __webpack_require__(91)('species');
	
	module.exports = function(original){
	  var C;
	  if(isArray(original)){
	    C = original.constructor;
	    // cross-realm fallback
	    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
	    if(isObject(C)){
	      C = C[SPECIES];
	      if(C === null)C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(74)
	  , $map    = __webpack_require__(238)(1);
	
	$export($export.P + $export.F * !__webpack_require__(234)([].map, true), 'Array', {
	  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
	  map: function map(callbackfn /* , thisArg */){
	    return $map(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(74)
	  , $filter = __webpack_require__(238)(2);
	
	$export($export.P + $export.F * !__webpack_require__(234)([].filter, true), 'Array', {
	  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
	  filter: function filter(callbackfn /* , thisArg */){
	    return $filter(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(74)
	  , $some   = __webpack_require__(238)(3);
	
	$export($export.P + $export.F * !__webpack_require__(234)([].some, true), 'Array', {
	  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
	  some: function some(callbackfn /* , thisArg */){
	    return $some(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(74)
	  , $every  = __webpack_require__(238)(4);
	
	$export($export.P + $export.F * !__webpack_require__(234)([].every, true), 'Array', {
	  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
	  every: function every(callbackfn /* , thisArg */){
	    return $every(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(74)
	  , $reduce = __webpack_require__(246);
	
	$export($export.P + $export.F * !__webpack_require__(234)([].reduce, true), 'Array', {
	  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
	  reduce: function reduce(callbackfn /* , initialValue */){
	    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
	  }
	});

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	var aFunction = __webpack_require__(87)
	  , toObject  = __webpack_require__(124)
	  , IObject   = __webpack_require__(99)
	  , toLength  = __webpack_require__(103);
	
	module.exports = function(that, callbackfn, aLen, memo, isRight){
	  aFunction(callbackfn);
	  var O      = toObject(that)
	    , self   = IObject(O)
	    , length = toLength(O.length)
	    , index  = isRight ? length - 1 : 0
	    , i      = isRight ? -1 : 1;
	  if(aLen < 2)for(;;){
	    if(index in self){
	      memo = self[index];
	      index += i;
	      break;
	    }
	    index += i;
	    if(isRight ? index < 0 : length <= index){
	      throw TypeError('Reduce of empty array with no initial value');
	    }
	  }
	  for(;isRight ? index >= 0 : length > index; index += i)if(index in self){
	    memo = callbackfn(memo, self[index], index, O);
	  }
	  return memo;
	};

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(74)
	  , $reduce = __webpack_require__(246);
	
	$export($export.P + $export.F * !__webpack_require__(234)([].reduceRight, true), 'Array', {
	  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
	  reduceRight: function reduceRight(callbackfn /* , initialValue */){
	    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
	  }
	});

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export       = __webpack_require__(74)
	  , $indexOf      = __webpack_require__(102)(false)
	  , $native       = [].indexOf
	  , NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
	
	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(234)($native)), 'Array', {
	  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
	  indexOf: function indexOf(searchElement /*, fromIndex = 0 */){
	    return NEGATIVE_ZERO
	      // convert -0 to +0
	      ? $native.apply(this, arguments) || 0
	      : $indexOf(this, searchElement, arguments[1]);
	  }
	});

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export       = __webpack_require__(74)
	  , toIObject     = __webpack_require__(98)
	  , toInteger     = __webpack_require__(104)
	  , toLength      = __webpack_require__(103)
	  , $native       = [].lastIndexOf
	  , NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;
	
	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(234)($native)), 'Array', {
	  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
	  lastIndexOf: function lastIndexOf(searchElement /*, fromIndex = @[*-1] */){
	    // convert -0 to +0
	    if(NEGATIVE_ZERO)return $native.apply(this, arguments) || 0;
	    var O      = toIObject(this)
	      , length = toLength(O.length)
	      , index  = length - 1;
	    if(arguments.length > 1)index = Math.min(index, toInteger(arguments[1]));
	    if(index < 0)index = length + index;
	    for(;index >= 0; index--)if(index in O)if(O[index] === searchElement)return index || 0;
	    return -1;
	  }
	});

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	var $export = __webpack_require__(74);
	
	$export($export.P, 'Array', {copyWithin: __webpack_require__(251)});
	
	__webpack_require__(252)('copyWithin');

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	'use strict';
	var toObject = __webpack_require__(124)
	  , toIndex  = __webpack_require__(105)
	  , toLength = __webpack_require__(103);
	
	module.exports = [].copyWithin || function copyWithin(target/*= 0*/, start/*= 0, end = @length*/){
	  var O     = toObject(this)
	    , len   = toLength(O.length)
	    , to    = toIndex(target, len)
	    , from  = toIndex(start, len)
	    , end   = arguments.length > 2 ? arguments[2] : undefined
	    , count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to)
	    , inc   = 1;
	  if(from < to && to < from + count){
	    inc  = -1;
	    from += count - 1;
	    to   += count - 1;
	  }
	  while(count-- > 0){
	    if(from in O)O[to] = O[from];
	    else delete O[to];
	    to   += inc;
	    from += inc;
	  } return O;
	};

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = __webpack_require__(91)('unscopables')
	  , ArrayProto  = Array.prototype;
	if(ArrayProto[UNSCOPABLES] == undefined)__webpack_require__(76)(ArrayProto, UNSCOPABLES, {});
	module.exports = function(key){
	  ArrayProto[UNSCOPABLES][key] = true;
	};

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	var $export = __webpack_require__(74);
	
	$export($export.P, 'Array', {fill: __webpack_require__(254)});
	
	__webpack_require__(252)('fill');

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	'use strict';
	var toObject = __webpack_require__(124)
	  , toIndex  = __webpack_require__(105)
	  , toLength = __webpack_require__(103);
	module.exports = function fill(value /*, start = 0, end = @length */){
	  var O      = toObject(this)
	    , length = toLength(O.length)
	    , aLen   = arguments.length
	    , index  = toIndex(aLen > 1 ? arguments[1] : undefined, length)
	    , end    = aLen > 2 ? arguments[2] : undefined
	    , endPos = end === undefined ? length : toIndex(end, length);
	  while(endPos > index)O[index++] = value;
	  return O;
	};

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
	var $export = __webpack_require__(74)
	  , $find   = __webpack_require__(238)(5)
	  , KEY     = 'find'
	  , forced  = true;
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  find: function find(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(252)(KEY);

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
	var $export = __webpack_require__(74)
	  , $find   = __webpack_require__(238)(6)
	  , KEY     = 'findIndex'
	  , forced  = true;
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  findIndex: function findIndex(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(252)(KEY);

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(258)('Array');

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(70)
	  , dP          = __webpack_require__(77)
	  , DESCRIPTORS = __webpack_require__(72)
	  , SPECIES     = __webpack_require__(91)('species');
	
	module.exports = function(KEY){
	  var C = global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(252)
	  , step             = __webpack_require__(260)
	  , Iterators        = __webpack_require__(195)
	  , toIObject        = __webpack_require__(98);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(194)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 260 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	var global            = __webpack_require__(70)
	  , inheritIfRequired = __webpack_require__(154)
	  , dP                = __webpack_require__(77).f
	  , gOPN              = __webpack_require__(116).f
	  , isRegExp          = __webpack_require__(200)
	  , $flags            = __webpack_require__(262)
	  , $RegExp           = global.RegExp
	  , Base              = $RegExp
	  , proto             = $RegExp.prototype
	  , re1               = /a/g
	  , re2               = /a/g
	  // "new" creates a new object, old webkit buggy here
	  , CORRECT_NEW       = new $RegExp(re1) !== re1;
	
	if(__webpack_require__(72) && (!CORRECT_NEW || __webpack_require__(73)(function(){
	  re2[__webpack_require__(91)('match')] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
	}))){
	  $RegExp = function RegExp(p, f){
	    var tiRE = this instanceof $RegExp
	      , piRE = isRegExp(p)
	      , fiU  = f === undefined;
	    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
	      : inheritIfRequired(CORRECT_NEW
	        ? new Base(piRE && !fiU ? p.source : p, f)
	        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
	      , tiRE ? this : proto, $RegExp);
	  };
	  var proxy = function(key){
	    key in $RegExp || dP($RegExp, key, {
	      configurable: true,
	      get: function(){ return Base[key]; },
	      set: function(it){ Base[key] = it; }
	    });
	  };
	  for(var keys = gOPN(Base), i = 0; keys.length > i; )proxy(keys[i++]);
	  proto.constructor = $RegExp;
	  $RegExp.prototype = proto;
	  __webpack_require__(84)(global, 'RegExp', $RegExp);
	}
	
	__webpack_require__(258)('RegExp');

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 21.2.5.3 get RegExp.prototype.flags
	var anObject = __webpack_require__(78);
	module.exports = function(){
	  var that   = anObject(this)
	    , result = '';
	  if(that.global)     result += 'g';
	  if(that.ignoreCase) result += 'i';
	  if(that.multiline)  result += 'm';
	  if(that.unicode)    result += 'u';
	  if(that.sticky)     result += 'y';
	  return result;
	};

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	__webpack_require__(264);
	var anObject    = __webpack_require__(78)
	  , $flags      = __webpack_require__(262)
	  , DESCRIPTORS = __webpack_require__(72)
	  , TO_STRING   = 'toString'
	  , $toString   = /./[TO_STRING];
	
	var define = function(fn){
	  __webpack_require__(84)(RegExp.prototype, TO_STRING, fn, true);
	};
	
	// 21.2.5.14 RegExp.prototype.toString()
	if(__webpack_require__(73)(function(){ return $toString.call({source: 'a', flags: 'b'}) != '/a/b'; })){
	  define(function toString(){
	    var R = anObject(this);
	    return '/'.concat(R.source, '/',
	      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
	  });
	// FF44- RegExp#toString has a wrong name
	} else if($toString.name != TO_STRING){
	  define(function toString(){
	    return $toString.call(this);
	  });
	}

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	// 21.2.5.3 get RegExp.prototype.flags()
	if(__webpack_require__(72) && /./g.flags != 'g')__webpack_require__(77).f(RegExp.prototype, 'flags', {
	  configurable: true,
	  get: __webpack_require__(262)
	});

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	// @@match logic
	__webpack_require__(266)('match', 1, function(defined, MATCH, $match){
	  // 21.1.3.11 String.prototype.match(regexp)
	  return [function match(regexp){
	    'use strict';
	    var O  = defined(this)
	      , fn = regexp == undefined ? undefined : regexp[MATCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	  }, $match];
	});

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var hide     = __webpack_require__(76)
	  , redefine = __webpack_require__(84)
	  , fails    = __webpack_require__(73)
	  , defined  = __webpack_require__(101)
	  , wks      = __webpack_require__(91);
	
	module.exports = function(KEY, length, exec){
	  var SYMBOL   = wks(KEY)
	    , fns      = exec(defined, SYMBOL, ''[KEY])
	    , strfn    = fns[0]
	    , rxfn     = fns[1];
	  if(fails(function(){
	    var O = {};
	    O[SYMBOL] = function(){ return 7; };
	    return ''[KEY](O) != 7;
	  })){
	    redefine(String.prototype, KEY, strfn);
	    hide(RegExp.prototype, SYMBOL, length == 2
	      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	      ? function(string, arg){ return rxfn.call(string, this, arg); }
	      // 21.2.5.6 RegExp.prototype[@@match](string)
	      // 21.2.5.9 RegExp.prototype[@@search](string)
	      : function(string){ return rxfn.call(string, this); }
	    );
	  }
	};

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	// @@replace logic
	__webpack_require__(266)('replace', 2, function(defined, REPLACE, $replace){
	  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
	  return [function replace(searchValue, replaceValue){
	    'use strict';
	    var O  = defined(this)
	      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	    return fn !== undefined
	      ? fn.call(searchValue, O, replaceValue)
	      : $replace.call(String(O), searchValue, replaceValue);
	  }, $replace];
	});

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	// @@search logic
	__webpack_require__(266)('search', 1, function(defined, SEARCH, $search){
	  // 21.1.3.15 String.prototype.search(regexp)
	  return [function search(regexp){
	    'use strict';
	    var O  = defined(this)
	      , fn = regexp == undefined ? undefined : regexp[SEARCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	  }, $search];
	});

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	// @@split logic
	__webpack_require__(266)('split', 2, function(defined, SPLIT, $split){
	  'use strict';
	  var isRegExp   = __webpack_require__(200)
	    , _split     = $split
	    , $push      = [].push
	    , $SPLIT     = 'split'
	    , LENGTH     = 'length'
	    , LAST_INDEX = 'lastIndex';
	  if(
	    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
	    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
	    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
	    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
	    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
	    ''[$SPLIT](/.?/)[LENGTH]
	  ){
	    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
	    // based on es5-shim implementation, need to rework it
	    $split = function(separator, limit){
	      var string = String(this);
	      if(separator === undefined && limit === 0)return [];
	      // If `separator` is not a regex, use native split
	      if(!isRegExp(separator))return _split.call(string, separator, limit);
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') +
	                  (separator.multiline ? 'm' : '') +
	                  (separator.unicode ? 'u' : '') +
	                  (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var separator2, match, lastIndex, lastLength, i;
	      // Doesn't need flags gy, but they don't hurt
	      if(!NPCG)separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
	      while(match = separatorCopy.exec(string)){
	        // `separatorCopy.lastIndex` is not reliable cross-browser
	        lastIndex = match.index + match[0][LENGTH];
	        if(lastIndex > lastLastIndex){
	          output.push(string.slice(lastLastIndex, match.index));
	          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
	          if(!NPCG && match[LENGTH] > 1)match[0].replace(separator2, function(){
	            for(i = 1; i < arguments[LENGTH] - 2; i++)if(arguments[i] === undefined)match[i] = undefined;
	          });
	          if(match[LENGTH] > 1 && match.index < string[LENGTH])$push.apply(output, match.slice(1));
	          lastLength = match[0][LENGTH];
	          lastLastIndex = lastIndex;
	          if(output[LENGTH] >= splitLimit)break;
	        }
	        if(separatorCopy[LAST_INDEX] === match.index)separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
	      }
	      if(lastLastIndex === string[LENGTH]){
	        if(lastLength || !separatorCopy.test(''))output.push('');
	      } else output.push(string.slice(lastLastIndex));
	      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
	    };
	  // Chakra, V8
	  } else if('0'[$SPLIT](undefined, 0)[LENGTH]){
	    $split = function(separator, limit){
	      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
	    };
	  }
	  // 21.1.3.17 String.prototype.split(separator, limit)
	  return [function split(separator, limit){
	    var O  = defined(this)
	      , fn = separator == undefined ? undefined : separator[SPLIT];
	    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
	  }, $split];
	});

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(94)
	  , global             = __webpack_require__(70)
	  , ctx                = __webpack_require__(86)
	  , classof            = __webpack_require__(141)
	  , $export            = __webpack_require__(74)
	  , isObject           = __webpack_require__(79)
	  , aFunction          = __webpack_require__(87)
	  , anInstance         = __webpack_require__(271)
	  , forOf              = __webpack_require__(272)
	  , speciesConstructor = __webpack_require__(273)
	  , task               = __webpack_require__(274).set
	  , microtask          = __webpack_require__(275)()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;
	
	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(91)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();
	
	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};
	
	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(276)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(90)($Promise, PROMISE);
	__webpack_require__(258)(PROMISE);
	Wrapper = __webpack_require__(75)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(231)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 271 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(86)
	  , call        = __webpack_require__(227)
	  , isArrayIter = __webpack_require__(228)
	  , anObject    = __webpack_require__(78)
	  , toLength    = __webpack_require__(103)
	  , getIterFn   = __webpack_require__(230)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(78)
	  , aFunction = __webpack_require__(87)
	  , SPECIES   = __webpack_require__(91)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(86)
	  , invoke             = __webpack_require__(144)
	  , html               = __webpack_require__(114)
	  , cel                = __webpack_require__(81)
	  , global             = __webpack_require__(70)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(100)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(70)
	  , macrotask = __webpack_require__(274).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(100)(process) == 'process';
	
	module.exports = function(){
	  var head, last, notify;
	
	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };
	
	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }
	
	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	var redefine = __webpack_require__(84);
	module.exports = function(target, src, safe){
	  for(var key in src)redefine(target, key, src[key], safe);
	  return target;
	};

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(278);
	
	// 23.1 Map Objects
	module.exports = __webpack_require__(279)('Map', function(get){
	  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key){
	    var entry = strong.getEntry(this, key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value){
	    return strong.def(this, key === 0 ? 0 : key, value);
	  }
	}, strong, true);

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var dP          = __webpack_require__(77).f
	  , create      = __webpack_require__(112)
	  , redefineAll = __webpack_require__(276)
	  , ctx         = __webpack_require__(86)
	  , anInstance  = __webpack_require__(271)
	  , defined     = __webpack_require__(101)
	  , forOf       = __webpack_require__(272)
	  , $iterDefine = __webpack_require__(194)
	  , step        = __webpack_require__(260)
	  , setSpecies  = __webpack_require__(258)
	  , DESCRIPTORS = __webpack_require__(72)
	  , fastKey     = __webpack_require__(88).fastKey
	  , SIZE        = DESCRIPTORS ? '_s' : 'size';
	
	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        anInstance(this, C, 'forEach');
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)dP(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global            = __webpack_require__(70)
	  , $export           = __webpack_require__(74)
	  , redefine          = __webpack_require__(84)
	  , redefineAll       = __webpack_require__(276)
	  , meta              = __webpack_require__(88)
	  , forOf             = __webpack_require__(272)
	  , anInstance        = __webpack_require__(271)
	  , isObject          = __webpack_require__(79)
	  , fails             = __webpack_require__(73)
	  , $iterDetect       = __webpack_require__(231)
	  , setToStringTag    = __webpack_require__(90)
	  , inheritIfRequired = __webpack_require__(154);
	
	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  var fixMethod = function(KEY){
	    var fn = proto[KEY];
	    redefine(proto, KEY,
	      KEY == 'delete' ? function(a){
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'has' ? function has(a){
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'get' ? function get(a){
	        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
	        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
	    );
	  };
	  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    var instance             = new C
	      // early implementations not supports chaining
	      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance
	      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
	      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })
	      // most early implementations doesn't supports iterables, most modern - not close it correctly
	      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new
	      // for early implementations -0 and +0 not the same
	      , BUGGY_ZERO = !IS_WEAK && fails(function(){
	        // V8 ~ Chromium 42- fails only with 5+ elements
	        var $instance = new C()
	          , index     = 5;
	        while(index--)$instance[ADDER](index, index);
	        return !$instance.has(-0);
	      });
	    if(!ACCEPT_ITERABLES){ 
	      C = wrapper(function(target, iterable){
	        anInstance(target, C, NAME);
	        var that = inheritIfRequired(new Base, target, C);
	        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	        return that;
	      });
	      C.prototype = proto;
	      proto.constructor = C;
	    }
	    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);
	    // weak collections should not contains .clear method
	    if(IS_WEAK && proto.clear)delete proto.clear;
	  }
	
	  setToStringTag(C, NAME);
	
	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F * (C != Base), O);
	
	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(278);
	
	// 23.2 Set Objects
	module.exports = __webpack_require__(279)('Set', function(get){
	  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var each         = __webpack_require__(238)(0)
	  , redefine     = __webpack_require__(84)
	  , meta         = __webpack_require__(88)
	  , assign       = __webpack_require__(135)
	  , weak         = __webpack_require__(282)
	  , isObject     = __webpack_require__(79)
	  , getWeak      = meta.getWeak
	  , isExtensible = Object.isExtensible
	  , uncaughtFrozenStore = weak.ufstore
	  , tmp          = {}
	  , InternalMap;
	
	var wrapper = function(get){
	  return function WeakMap(){
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	};
	
	var methods = {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key){
	    if(isObject(key)){
	      var data = getWeak(key);
	      if(data === true)return uncaughtFrozenStore(this).get(key);
	      return data ? data[this._i] : undefined;
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value){
	    return weak.def(this, key, value);
	  }
	};
	
	// 23.3 WeakMap Objects
	var $WeakMap = module.exports = __webpack_require__(279)('WeakMap', wrapper, methods, weak, true, true);
	
	// IE11 WeakMap frozen keys fix
	if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
	  InternalMap = weak.getConstructor(wrapper);
	  assign(InternalMap.prototype, methods);
	  meta.NEED = true;
	  each(['delete', 'has', 'get', 'set'], function(key){
	    var proto  = $WeakMap.prototype
	      , method = proto[key];
	    redefine(proto, key, function(a, b){
	      // store frozen objects on internal weakmap shim
	      if(isObject(a) && !isExtensible(a)){
	        if(!this._f)this._f = new InternalMap;
	        var result = this._f[key](a, b);
	        return key == 'set' ? this : result;
	      // store all the rest on native weakmap
	      } return method.call(this, a, b);
	    });
	  });
	}

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var redefineAll       = __webpack_require__(276)
	  , getWeak           = __webpack_require__(88).getWeak
	  , anObject          = __webpack_require__(78)
	  , isObject          = __webpack_require__(79)
	  , anInstance        = __webpack_require__(271)
	  , forOf             = __webpack_require__(272)
	  , createArrayMethod = __webpack_require__(238)
	  , $has              = __webpack_require__(71)
	  , arrayFind         = createArrayMethod(5)
	  , arrayFindIndex    = createArrayMethod(6)
	  , id                = 0;
	
	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function(that){
	  return that._l || (that._l = new UncaughtFrozenStore);
	};
	var UncaughtFrozenStore = function(){
	  this.a = [];
	};
	var findUncaughtFrozen = function(store, key){
	  return arrayFind(store.a, function(it){
	    return it[0] === key;
	  });
	};
	UncaughtFrozenStore.prototype = {
	  get: function(key){
	    var entry = findUncaughtFrozen(this, key);
	    if(entry)return entry[1];
	  },
	  has: function(key){
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function(key, value){
	    var entry = findUncaughtFrozen(this, key);
	    if(entry)entry[1] = value;
	    else this.a.push([key, value]);
	  },
	  'delete': function(key){
	    var index = arrayFindIndex(this.a, function(it){
	      return it[0] === key;
	    });
	    if(~index)this.a.splice(index, 1);
	    return !!~index;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = id++;      // collection id
	      that._l = undefined; // leak store for uncaught frozen objects
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function(key){
	        if(!isObject(key))return false;
	        var data = getWeak(key);
	        if(data === true)return uncaughtFrozenStore(this)['delete'](key);
	        return data && $has(data, this._i) && delete data[this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has(key){
	        if(!isObject(key))return false;
	        var data = getWeak(key);
	        if(data === true)return uncaughtFrozenStore(this).has(key);
	        return data && $has(data, this._i);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var data = getWeak(anObject(key), true);
	    if(data === true)uncaughtFrozenStore(that).set(key, value);
	    else data[that._i] = value;
	    return that;
	  },
	  ufstore: uncaughtFrozenStore
	};

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var weak = __webpack_require__(282);
	
	// 23.4 WeakSet Objects
	__webpack_require__(279)('WeakSet', function(get){
	  return function WeakSet(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.4.3.1 WeakSet.prototype.add(value)
	  add: function add(value){
	    return weak.def(this, value, true);
	  }
	}, weak, false, true);

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(74)
	  , $typed       = __webpack_require__(285)
	  , buffer       = __webpack_require__(286)
	  , anObject     = __webpack_require__(78)
	  , toIndex      = __webpack_require__(105)
	  , toLength     = __webpack_require__(103)
	  , isObject     = __webpack_require__(79)
	  , ArrayBuffer  = __webpack_require__(70).ArrayBuffer
	  , speciesConstructor = __webpack_require__(273)
	  , $ArrayBuffer = buffer.ArrayBuffer
	  , $DataView    = buffer.DataView
	  , $isView      = $typed.ABV && ArrayBuffer.isView
	  , $slice       = $ArrayBuffer.prototype.slice
	  , VIEW         = $typed.VIEW
	  , ARRAY_BUFFER = 'ArrayBuffer';
	
	$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {ArrayBuffer: $ArrayBuffer});
	
	$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
	  // 24.1.3.1 ArrayBuffer.isView(arg)
	  isView: function isView(it){
	    return $isView && $isView(it) || isObject(it) && VIEW in it;
	  }
	});
	
	$export($export.P + $export.U + $export.F * __webpack_require__(73)(function(){
	  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
	}), ARRAY_BUFFER, {
	  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
	  slice: function slice(start, end){
	    if($slice !== undefined && end === undefined)return $slice.call(anObject(this), start); // FF fix
	    var len    = anObject(this).byteLength
	      , first  = toIndex(start, len)
	      , final  = toIndex(end === undefined ? len : end, len)
	      , result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first))
	      , viewS  = new $DataView(this)
	      , viewT  = new $DataView(result)
	      , index  = 0;
	    while(first < final){
	      viewT.setUint8(index++, viewS.getUint8(first++));
	    } return result;
	  }
	});
	
	__webpack_require__(258)(ARRAY_BUFFER);

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(70)
	  , hide   = __webpack_require__(76)
	  , uid    = __webpack_require__(85)
	  , TYPED  = uid('typed_array')
	  , VIEW   = uid('view')
	  , ABV    = !!(global.ArrayBuffer && global.DataView)
	  , CONSTR = ABV
	  , i = 0, l = 9, Typed;
	
	var TypedArrayConstructors = (
	  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
	).split(',');
	
	while(i < l){
	  if(Typed = global[TypedArrayConstructors[i++]]){
	    hide(Typed.prototype, TYPED, true);
	    hide(Typed.prototype, VIEW, true);
	  } else CONSTR = false;
	}
	
	module.exports = {
	  ABV:    ABV,
	  CONSTR: CONSTR,
	  TYPED:  TYPED,
	  VIEW:   VIEW
	};

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global         = __webpack_require__(70)
	  , DESCRIPTORS    = __webpack_require__(72)
	  , LIBRARY        = __webpack_require__(94)
	  , $typed         = __webpack_require__(285)
	  , hide           = __webpack_require__(76)
	  , redefineAll    = __webpack_require__(276)
	  , fails          = __webpack_require__(73)
	  , anInstance     = __webpack_require__(271)
	  , toInteger      = __webpack_require__(104)
	  , toLength       = __webpack_require__(103)
	  , gOPN           = __webpack_require__(116).f
	  , dP             = __webpack_require__(77).f
	  , arrayFill      = __webpack_require__(254)
	  , setToStringTag = __webpack_require__(90)
	  , ARRAY_BUFFER   = 'ArrayBuffer'
	  , DATA_VIEW      = 'DataView'
	  , PROTOTYPE      = 'prototype'
	  , WRONG_LENGTH   = 'Wrong length!'
	  , WRONG_INDEX    = 'Wrong index!'
	  , $ArrayBuffer   = global[ARRAY_BUFFER]
	  , $DataView      = global[DATA_VIEW]
	  , Math           = global.Math
	  , RangeError     = global.RangeError
	  , Infinity       = global.Infinity
	  , BaseBuffer     = $ArrayBuffer
	  , abs            = Math.abs
	  , pow            = Math.pow
	  , floor          = Math.floor
	  , log            = Math.log
	  , LN2            = Math.LN2
	  , BUFFER         = 'buffer'
	  , BYTE_LENGTH    = 'byteLength'
	  , BYTE_OFFSET    = 'byteOffset'
	  , $BUFFER        = DESCRIPTORS ? '_b' : BUFFER
	  , $LENGTH        = DESCRIPTORS ? '_l' : BYTE_LENGTH
	  , $OFFSET        = DESCRIPTORS ? '_o' : BYTE_OFFSET;
	
	// IEEE754 conversions based on https://github.com/feross/ieee754
	var packIEEE754 = function(value, mLen, nBytes){
	  var buffer = Array(nBytes)
	    , eLen   = nBytes * 8 - mLen - 1
	    , eMax   = (1 << eLen) - 1
	    , eBias  = eMax >> 1
	    , rt     = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0
	    , i      = 0
	    , s      = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0
	    , e, m, c;
	  value = abs(value)
	  if(value != value || value === Infinity){
	    m = value != value ? 1 : 0;
	    e = eMax;
	  } else {
	    e = floor(log(value) / LN2);
	    if(value * (c = pow(2, -e)) < 1){
	      e--;
	      c *= 2;
	    }
	    if(e + eBias >= 1){
	      value += rt / c;
	    } else {
	      value += rt * pow(2, 1 - eBias);
	    }
	    if(value * c >= 2){
	      e++;
	      c /= 2;
	    }
	    if(e + eBias >= eMax){
	      m = 0;
	      e = eMax;
	    } else if(e + eBias >= 1){
	      m = (value * c - 1) * pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * pow(2, eBias - 1) * pow(2, mLen);
	      e = 0;
	    }
	  }
	  for(; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
	  e = e << mLen | m;
	  eLen += mLen;
	  for(; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
	  buffer[--i] |= s * 128;
	  return buffer;
	};
	var unpackIEEE754 = function(buffer, mLen, nBytes){
	  var eLen  = nBytes * 8 - mLen - 1
	    , eMax  = (1 << eLen) - 1
	    , eBias = eMax >> 1
	    , nBits = eLen - 7
	    , i     = nBytes - 1
	    , s     = buffer[i--]
	    , e     = s & 127
	    , m;
	  s >>= 7;
	  for(; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
	  m = e & (1 << -nBits) - 1;
	  e >>= -nBits;
	  nBits += mLen;
	  for(; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
	  if(e === 0){
	    e = 1 - eBias;
	  } else if(e === eMax){
	    return m ? NaN : s ? -Infinity : Infinity;
	  } else {
	    m = m + pow(2, mLen);
	    e = e - eBias;
	  } return (s ? -1 : 1) * m * pow(2, e - mLen);
	};
	
	var unpackI32 = function(bytes){
	  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
	};
	var packI8 = function(it){
	  return [it & 0xff];
	};
	var packI16 = function(it){
	  return [it & 0xff, it >> 8 & 0xff];
	};
	var packI32 = function(it){
	  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
	};
	var packF64 = function(it){
	  return packIEEE754(it, 52, 8);
	};
	var packF32 = function(it){
	  return packIEEE754(it, 23, 4);
	};
	
	var addGetter = function(C, key, internal){
	  dP(C[PROTOTYPE], key, {get: function(){ return this[internal]; }});
	};
	
	var get = function(view, bytes, index, isLittleEndian){
	  var numIndex = +index
	    , intIndex = toInteger(numIndex);
	  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b
	    , start = intIndex + view[$OFFSET]
	    , pack  = store.slice(start, start + bytes);
	  return isLittleEndian ? pack : pack.reverse();
	};
	var set = function(view, bytes, index, conversion, value, isLittleEndian){
	  var numIndex = +index
	    , intIndex = toInteger(numIndex);
	  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b
	    , start = intIndex + view[$OFFSET]
	    , pack  = conversion(+value);
	  for(var i = 0; i < bytes; i++)store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
	};
	
	var validateArrayBufferArguments = function(that, length){
	  anInstance(that, $ArrayBuffer, ARRAY_BUFFER);
	  var numberLength = +length
	    , byteLength   = toLength(numberLength);
	  if(numberLength != byteLength)throw RangeError(WRONG_LENGTH);
	  return byteLength;
	};
	
	if(!$typed.ABV){
	  $ArrayBuffer = function ArrayBuffer(length){
	    var byteLength = validateArrayBufferArguments(this, length);
	    this._b       = arrayFill.call(Array(byteLength), 0);
	    this[$LENGTH] = byteLength;
	  };
	
	  $DataView = function DataView(buffer, byteOffset, byteLength){
	    anInstance(this, $DataView, DATA_VIEW);
	    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
	    var bufferLength = buffer[$LENGTH]
	      , offset       = toInteger(byteOffset);
	    if(offset < 0 || offset > bufferLength)throw RangeError('Wrong offset!');
	    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	    if(offset + byteLength > bufferLength)throw RangeError(WRONG_LENGTH);
	    this[$BUFFER] = buffer;
	    this[$OFFSET] = offset;
	    this[$LENGTH] = byteLength;
	  };
	
	  if(DESCRIPTORS){
	    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
	    addGetter($DataView, BUFFER, '_b');
	    addGetter($DataView, BYTE_LENGTH, '_l');
	    addGetter($DataView, BYTE_OFFSET, '_o');
	  }
	
	  redefineAll($DataView[PROTOTYPE], {
	    getInt8: function getInt8(byteOffset){
	      return get(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset){
	      return get(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset /*, littleEndian */){
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset /*, littleEndian */){
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset /*, littleEndian */){
	      return unpackI32(get(this, 4, byteOffset, arguments[1]));
	    },
	    getUint32: function getUint32(byteOffset /*, littleEndian */){
	      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset /*, littleEndian */){
	      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
	    },
	    getFloat64: function getFloat64(byteOffset /*, littleEndian */){
	      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
	    },
	    setInt8: function setInt8(byteOffset, value){
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setUint8: function setUint8(byteOffset, value){
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setInt16: function setInt16(byteOffset, value /*, littleEndian */){
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setUint16: function setUint16(byteOffset, value /*, littleEndian */){
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setInt32: function setInt32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setUint32: function setUint32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setFloat32: function setFloat32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packF32, value, arguments[2]);
	    },
	    setFloat64: function setFloat64(byteOffset, value /*, littleEndian */){
	      set(this, 8, byteOffset, packF64, value, arguments[2]);
	    }
	  });
	} else {
	  if(!fails(function(){
	    new $ArrayBuffer;     // eslint-disable-line no-new
	  }) || !fails(function(){
	    new $ArrayBuffer(.5); // eslint-disable-line no-new
	  })){
	    $ArrayBuffer = function ArrayBuffer(length){
	      return new BaseBuffer(validateArrayBufferArguments(this, length));
	    };
	    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
	    for(var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j; ){
	      if(!((key = keys[j++]) in $ArrayBuffer))hide($ArrayBuffer, key, BaseBuffer[key]);
	    };
	    if(!LIBRARY)ArrayBufferProto.constructor = $ArrayBuffer;
	  }
	  // iOS Safari 7.x bug
	  var view = new $DataView(new $ArrayBuffer(2))
	    , $setInt8 = $DataView[PROTOTYPE].setInt8;
	  view.setInt8(0, 2147483648);
	  view.setInt8(1, 2147483649);
	  if(view.getInt8(0) || !view.getInt8(1))redefineAll($DataView[PROTOTYPE], {
	    setInt8: function setInt8(byteOffset, value){
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value){
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    }
	  }, true);
	}
	setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	setToStringTag($DataView, DATA_VIEW);
	hide($DataView[PROTOTYPE], $typed.VIEW, true);
	exports[ARRAY_BUFFER] = $ArrayBuffer;
	exports[DATA_VIEW] = $DataView;

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(74);
	$export($export.G + $export.W + $export.F * !__webpack_require__(285).ABV, {
	  DataView: __webpack_require__(286).DataView
	});

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(289)('Int8', 1, function(init){
	  return function Int8Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	if(__webpack_require__(72)){
	  var LIBRARY             = __webpack_require__(94)
	    , global              = __webpack_require__(70)
	    , fails               = __webpack_require__(73)
	    , $export             = __webpack_require__(74)
	    , $typed              = __webpack_require__(285)
	    , $buffer             = __webpack_require__(286)
	    , ctx                 = __webpack_require__(86)
	    , anInstance          = __webpack_require__(271)
	    , propertyDesc        = __webpack_require__(83)
	    , hide                = __webpack_require__(76)
	    , redefineAll         = __webpack_require__(276)
	    , toInteger           = __webpack_require__(104)
	    , toLength            = __webpack_require__(103)
	    , toIndex             = __webpack_require__(105)
	    , toPrimitive         = __webpack_require__(82)
	    , has                 = __webpack_require__(71)
	    , same                = __webpack_require__(137)
	    , classof             = __webpack_require__(141)
	    , isObject            = __webpack_require__(79)
	    , toObject            = __webpack_require__(124)
	    , isArrayIter         = __webpack_require__(228)
	    , create              = __webpack_require__(112)
	    , getPrototypeOf      = __webpack_require__(125)
	    , gOPN                = __webpack_require__(116).f
	    , getIterFn           = __webpack_require__(230)
	    , uid                 = __webpack_require__(85)
	    , wks                 = __webpack_require__(91)
	    , createArrayMethod   = __webpack_require__(238)
	    , createArrayIncludes = __webpack_require__(102)
	    , speciesConstructor  = __webpack_require__(273)
	    , ArrayIterators      = __webpack_require__(259)
	    , Iterators           = __webpack_require__(195)
	    , $iterDetect         = __webpack_require__(231)
	    , setSpecies          = __webpack_require__(258)
	    , arrayFill           = __webpack_require__(254)
	    , arrayCopyWithin     = __webpack_require__(251)
	    , $DP                 = __webpack_require__(77)
	    , $GOPD               = __webpack_require__(117)
	    , dP                  = $DP.f
	    , gOPD                = $GOPD.f
	    , RangeError          = global.RangeError
	    , TypeError           = global.TypeError
	    , Uint8Array          = global.Uint8Array
	    , ARRAY_BUFFER        = 'ArrayBuffer'
	    , SHARED_BUFFER       = 'Shared' + ARRAY_BUFFER
	    , BYTES_PER_ELEMENT   = 'BYTES_PER_ELEMENT'
	    , PROTOTYPE           = 'prototype'
	    , ArrayProto          = Array[PROTOTYPE]
	    , $ArrayBuffer        = $buffer.ArrayBuffer
	    , $DataView           = $buffer.DataView
	    , arrayForEach        = createArrayMethod(0)
	    , arrayFilter         = createArrayMethod(2)
	    , arraySome           = createArrayMethod(3)
	    , arrayEvery          = createArrayMethod(4)
	    , arrayFind           = createArrayMethod(5)
	    , arrayFindIndex      = createArrayMethod(6)
	    , arrayIncludes       = createArrayIncludes(true)
	    , arrayIndexOf        = createArrayIncludes(false)
	    , arrayValues         = ArrayIterators.values
	    , arrayKeys           = ArrayIterators.keys
	    , arrayEntries        = ArrayIterators.entries
	    , arrayLastIndexOf    = ArrayProto.lastIndexOf
	    , arrayReduce         = ArrayProto.reduce
	    , arrayReduceRight    = ArrayProto.reduceRight
	    , arrayJoin           = ArrayProto.join
	    , arraySort           = ArrayProto.sort
	    , arraySlice          = ArrayProto.slice
	    , arrayToString       = ArrayProto.toString
	    , arrayToLocaleString = ArrayProto.toLocaleString
	    , ITERATOR            = wks('iterator')
	    , TAG                 = wks('toStringTag')
	    , TYPED_CONSTRUCTOR   = uid('typed_constructor')
	    , DEF_CONSTRUCTOR     = uid('def_constructor')
	    , ALL_CONSTRUCTORS    = $typed.CONSTR
	    , TYPED_ARRAY         = $typed.TYPED
	    , VIEW                = $typed.VIEW
	    , WRONG_LENGTH        = 'Wrong length!';
	
	  var $map = createArrayMethod(1, function(O, length){
	    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
	  });
	
	  var LITTLE_ENDIAN = fails(function(){
	    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
	  });
	
	  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function(){
	    new Uint8Array(1).set({});
	  });
	
	  var strictToLength = function(it, SAME){
	    if(it === undefined)throw TypeError(WRONG_LENGTH);
	    var number = +it
	      , length = toLength(it);
	    if(SAME && !same(number, length))throw RangeError(WRONG_LENGTH);
	    return length;
	  };
	
	  var toOffset = function(it, BYTES){
	    var offset = toInteger(it);
	    if(offset < 0 || offset % BYTES)throw RangeError('Wrong offset!');
	    return offset;
	  };
	
	  var validate = function(it){
	    if(isObject(it) && TYPED_ARRAY in it)return it;
	    throw TypeError(it + ' is not a typed array!');
	  };
	
	  var allocate = function(C, length){
	    if(!(isObject(C) && TYPED_CONSTRUCTOR in C)){
	      throw TypeError('It is not a typed array constructor!');
	    } return new C(length);
	  };
	
	  var speciesFromList = function(O, list){
	    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
	  };
	
	  var fromList = function(C, list){
	    var index  = 0
	      , length = list.length
	      , result = allocate(C, length);
	    while(length > index)result[index] = list[index++];
	    return result;
	  };
	
	  var addGetter = function(it, key, internal){
	    dP(it, key, {get: function(){ return this._d[internal]; }});
	  };
	
	  var $from = function from(source /*, mapfn, thisArg */){
	    var O       = toObject(source)
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , iterFn  = getIterFn(O)
	      , i, length, values, result, step, iterator;
	    if(iterFn != undefined && !isArrayIter(iterFn)){
	      for(iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++){
	        values.push(step.value);
	      } O = values;
	    }
	    if(mapping && aLen > 2)mapfn = ctx(mapfn, arguments[2], 2);
	    for(i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++){
	      result[i] = mapping ? mapfn(O[i], i) : O[i];
	    }
	    return result;
	  };
	
	  var $of = function of(/*...items*/){
	    var index  = 0
	      , length = arguments.length
	      , result = allocate(this, length);
	    while(length > index)result[index] = arguments[index++];
	    return result;
	  };
	
	  // iOS Safari 6.x fails here
	  var TO_LOCALE_BUG = !!Uint8Array && fails(function(){ arrayToLocaleString.call(new Uint8Array(1)); });
	
	  var $toLocaleString = function toLocaleString(){
	    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
	  };
	
	  var proto = {
	    copyWithin: function copyWithin(target, start /*, end */){
	      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    every: function every(callbackfn /*, thisArg */){
	      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    fill: function fill(value /*, start, end */){ // eslint-disable-line no-unused-vars
	      return arrayFill.apply(validate(this), arguments);
	    },
	    filter: function filter(callbackfn /*, thisArg */){
	      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
	        arguments.length > 1 ? arguments[1] : undefined));
	    },
	    find: function find(predicate /*, thisArg */){
	      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    findIndex: function findIndex(predicate /*, thisArg */){
	      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    forEach: function forEach(callbackfn /*, thisArg */){
	      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    indexOf: function indexOf(searchElement /*, fromIndex */){
	      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    includes: function includes(searchElement /*, fromIndex */){
	      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    join: function join(separator){ // eslint-disable-line no-unused-vars
	      return arrayJoin.apply(validate(this), arguments);
	    },
	    lastIndexOf: function lastIndexOf(searchElement /*, fromIndex */){ // eslint-disable-line no-unused-vars
	      return arrayLastIndexOf.apply(validate(this), arguments);
	    },
	    map: function map(mapfn /*, thisArg */){
	      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    reduce: function reduce(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
	      return arrayReduce.apply(validate(this), arguments);
	    },
	    reduceRight: function reduceRight(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
	      return arrayReduceRight.apply(validate(this), arguments);
	    },
	    reverse: function reverse(){
	      var that   = this
	        , length = validate(that).length
	        , middle = Math.floor(length / 2)
	        , index  = 0
	        , value;
	      while(index < middle){
	        value         = that[index];
	        that[index++] = that[--length];
	        that[length]  = value;
	      } return that;
	    },
	    some: function some(callbackfn /*, thisArg */){
	      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    sort: function sort(comparefn){
	      return arraySort.call(validate(this), comparefn);
	    },
	    subarray: function subarray(begin, end){
	      var O      = validate(this)
	        , length = O.length
	        , $begin = toIndex(begin, length);
	      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
	        O.buffer,
	        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
	        toLength((end === undefined ? length : toIndex(end, length)) - $begin)
	      );
	    }
	  };
	
	  var $slice = function slice(start, end){
	    return speciesFromList(this, arraySlice.call(validate(this), start, end));
	  };
	
	  var $set = function set(arrayLike /*, offset */){
	    validate(this);
	    var offset = toOffset(arguments[1], 1)
	      , length = this.length
	      , src    = toObject(arrayLike)
	      , len    = toLength(src.length)
	      , index  = 0;
	    if(len + offset > length)throw RangeError(WRONG_LENGTH);
	    while(index < len)this[offset + index] = src[index++];
	  };
	
	  var $iterators = {
	    entries: function entries(){
	      return arrayEntries.call(validate(this));
	    },
	    keys: function keys(){
	      return arrayKeys.call(validate(this));
	    },
	    values: function values(){
	      return arrayValues.call(validate(this));
	    }
	  };
	
	  var isTAIndex = function(target, key){
	    return isObject(target)
	      && target[TYPED_ARRAY]
	      && typeof key != 'symbol'
	      && key in target
	      && String(+key) == String(key);
	  };
	  var $getDesc = function getOwnPropertyDescriptor(target, key){
	    return isTAIndex(target, key = toPrimitive(key, true))
	      ? propertyDesc(2, target[key])
	      : gOPD(target, key);
	  };
	  var $setDesc = function defineProperty(target, key, desc){
	    if(isTAIndex(target, key = toPrimitive(key, true))
	      && isObject(desc)
	      && has(desc, 'value')
	      && !has(desc, 'get')
	      && !has(desc, 'set')
	      // TODO: add validation descriptor w/o calling accessors
	      && !desc.configurable
	      && (!has(desc, 'writable') || desc.writable)
	      && (!has(desc, 'enumerable') || desc.enumerable)
	    ){
	      target[key] = desc.value;
	      return target;
	    } else return dP(target, key, desc);
	  };
	
	  if(!ALL_CONSTRUCTORS){
	    $GOPD.f = $getDesc;
	    $DP.f   = $setDesc;
	  }
	
	  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
	    getOwnPropertyDescriptor: $getDesc,
	    defineProperty:           $setDesc
	  });
	
	  if(fails(function(){ arrayToString.call({}); })){
	    arrayToString = arrayToLocaleString = function toString(){
	      return arrayJoin.call(this);
	    }
	  }
	
	  var $TypedArrayPrototype$ = redefineAll({}, proto);
	  redefineAll($TypedArrayPrototype$, $iterators);
	  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
	  redefineAll($TypedArrayPrototype$, {
	    slice:          $slice,
	    set:            $set,
	    constructor:    function(){ /* noop */ },
	    toString:       arrayToString,
	    toLocaleString: $toLocaleString
	  });
	  addGetter($TypedArrayPrototype$, 'buffer', 'b');
	  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
	  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
	  addGetter($TypedArrayPrototype$, 'length', 'e');
	  dP($TypedArrayPrototype$, TAG, {
	    get: function(){ return this[TYPED_ARRAY]; }
	  });
	
	  module.exports = function(KEY, BYTES, wrapper, CLAMPED){
	    CLAMPED = !!CLAMPED;
	    var NAME       = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'
	      , ISNT_UINT8 = NAME != 'Uint8Array'
	      , GETTER     = 'get' + KEY
	      , SETTER     = 'set' + KEY
	      , TypedArray = global[NAME]
	      , Base       = TypedArray || {}
	      , TAC        = TypedArray && getPrototypeOf(TypedArray)
	      , FORCED     = !TypedArray || !$typed.ABV
	      , O          = {}
	      , TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
	    var getter = function(that, index){
	      var data = that._d;
	      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
	    };
	    var setter = function(that, index, value){
	      var data = that._d;
	      if(CLAMPED)value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
	      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
	    };
	    var addElement = function(that, index){
	      dP(that, index, {
	        get: function(){
	          return getter(this, index);
	        },
	        set: function(value){
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };
	    if(FORCED){
	      TypedArray = wrapper(function(that, data, $offset, $length){
	        anInstance(that, TypedArray, NAME, '_d');
	        var index  = 0
	          , offset = 0
	          , buffer, byteLength, length, klass;
	        if(!isObject(data)){
	          length     = strictToLength(data, true)
	          byteLength = length * BYTES;
	          buffer     = new $ArrayBuffer(byteLength);
	        } else if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
	          buffer = data;
	          offset = toOffset($offset, BYTES);
	          var $len = data.byteLength;
	          if($length === undefined){
	            if($len % BYTES)throw RangeError(WRONG_LENGTH);
	            byteLength = $len - offset;
	            if(byteLength < 0)throw RangeError(WRONG_LENGTH);
	          } else {
	            byteLength = toLength($length) * BYTES;
	            if(byteLength + offset > $len)throw RangeError(WRONG_LENGTH);
	          }
	          length = byteLength / BYTES;
	        } else if(TYPED_ARRAY in data){
	          return fromList(TypedArray, data);
	        } else {
	          return $from.call(TypedArray, data);
	        }
	        hide(that, '_d', {
	          b: buffer,
	          o: offset,
	          l: byteLength,
	          e: length,
	          v: new $DataView(buffer)
	        });
	        while(index < length)addElement(that, index++);
	      });
	      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
	      hide(TypedArrayPrototype, 'constructor', TypedArray);
	    } else if(!$iterDetect(function(iter){
	      // V8 works with iterators, but fails in many other cases
	      // https://code.google.com/p/v8/issues/detail?id=4552
	      new TypedArray(null); // eslint-disable-line no-new
	      new TypedArray(iter); // eslint-disable-line no-new
	    }, true)){
	      TypedArray = wrapper(function(that, data, $offset, $length){
	        anInstance(that, TypedArray, NAME);
	        var klass;
	        // `ws` module bug, temporarily remove validation length for Uint8Array
	        // https://github.com/websockets/ws/pull/645
	        if(!isObject(data))return new Base(strictToLength(data, ISNT_UINT8));
	        if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
	          return $length !== undefined
	            ? new Base(data, toOffset($offset, BYTES), $length)
	            : $offset !== undefined
	              ? new Base(data, toOffset($offset, BYTES))
	              : new Base(data);
	        }
	        if(TYPED_ARRAY in data)return fromList(TypedArray, data);
	        return $from.call(TypedArray, data);
	      });
	      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key){
	        if(!(key in TypedArray))hide(TypedArray, key, Base[key]);
	      });
	      TypedArray[PROTOTYPE] = TypedArrayPrototype;
	      if(!LIBRARY)TypedArrayPrototype.constructor = TypedArray;
	    }
	    var $nativeIterator   = TypedArrayPrototype[ITERATOR]
	      , CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined)
	      , $iterator         = $iterators.values;
	    hide(TypedArray, TYPED_CONSTRUCTOR, true);
	    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
	    hide(TypedArrayPrototype, VIEW, true);
	    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);
	
	    if(CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)){
	      dP(TypedArrayPrototype, TAG, {
	        get: function(){ return NAME; }
	      });
	    }
	
	    O[NAME] = TypedArray;
	
	    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
	
	    $export($export.S, NAME, {
	      BYTES_PER_ELEMENT: BYTES,
	      from: $from,
	      of: $of
	    });
	
	    if(!(BYTES_PER_ELEMENT in TypedArrayPrototype))hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
	
	    $export($export.P, NAME, proto);
	
	    setSpecies(NAME);
	
	    $export($export.P + $export.F * FORCED_SET, NAME, {set: $set});
	
	    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
	
	    $export($export.P + $export.F * (TypedArrayPrototype.toString != arrayToString), NAME, {toString: arrayToString});
	
	    $export($export.P + $export.F * fails(function(){
	      new TypedArray(1).slice();
	    }), NAME, {slice: $slice});
	
	    $export($export.P + $export.F * (fails(function(){
	      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()
	    }) || !fails(function(){
	      TypedArrayPrototype.toLocaleString.call([1, 2]);
	    })), NAME, {toLocaleString: $toLocaleString});
	
	    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
	    if(!LIBRARY && !CORRECT_ITER_NAME)hide(TypedArrayPrototype, ITERATOR, $iterator);
	  };
	} else module.exports = function(){ /* empty */ };

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(289)('Uint8', 1, function(init){
	  return function Uint8Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(289)('Uint8', 1, function(init){
	  return function Uint8ClampedArray(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	}, true);

/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(289)('Int16', 2, function(init){
	  return function Int16Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(289)('Uint16', 2, function(init){
	  return function Uint16Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(289)('Int32', 4, function(init){
	  return function Int32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(289)('Uint32', 4, function(init){
	  return function Uint32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(289)('Float32', 4, function(init){
	  return function Float32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(289)('Float64', 8, function(init){
	  return function Float64Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
	var $export   = __webpack_require__(74)
	  , aFunction = __webpack_require__(87)
	  , anObject  = __webpack_require__(78)
	  , rApply    = (__webpack_require__(70).Reflect || {}).apply
	  , fApply    = Function.apply;
	// MS Edge argumentsList argument is optional
	$export($export.S + $export.F * !__webpack_require__(73)(function(){
	  rApply(function(){});
	}), 'Reflect', {
	  apply: function apply(target, thisArgument, argumentsList){
	    var T = aFunction(target)
	      , L = anObject(argumentsList);
	    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
	  }
	});

/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
	var $export    = __webpack_require__(74)
	  , create     = __webpack_require__(112)
	  , aFunction  = __webpack_require__(87)
	  , anObject   = __webpack_require__(78)
	  , isObject   = __webpack_require__(79)
	  , fails      = __webpack_require__(73)
	  , bind       = __webpack_require__(143)
	  , rConstruct = (__webpack_require__(70).Reflect || {}).construct;
	
	// MS Edge supports only 2 arguments and argumentsList argument is optional
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	var NEW_TARGET_BUG = fails(function(){
	  function F(){}
	  return !(rConstruct(function(){}, [], F) instanceof F);
	});
	var ARGS_BUG = !fails(function(){
	  rConstruct(function(){});
	});
	
	$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
	  construct: function construct(Target, args /*, newTarget*/){
	    aFunction(Target);
	    anObject(args);
	    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
	    if(ARGS_BUG && !NEW_TARGET_BUG)return rConstruct(Target, args, newTarget);
	    if(Target == newTarget){
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch(args.length){
	        case 0: return new Target;
	        case 1: return new Target(args[0]);
	        case 2: return new Target(args[0], args[1]);
	        case 3: return new Target(args[0], args[1], args[2]);
	        case 4: return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (bind.apply(Target, $args));
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto    = newTarget.prototype
	      , instance = create(isObject(proto) ? proto : Object.prototype)
	      , result   = Function.apply.call(Target, instance, args);
	    return isObject(result) ? result : instance;
	  }
	});

/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
	var dP          = __webpack_require__(77)
	  , $export     = __webpack_require__(74)
	  , anObject    = __webpack_require__(78)
	  , toPrimitive = __webpack_require__(82);
	
	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
	$export($export.S + $export.F * __webpack_require__(73)(function(){
	  Reflect.defineProperty(dP.f({}, 1, {value: 1}), 1, {value: 2});
	}), 'Reflect', {
	  defineProperty: function defineProperty(target, propertyKey, attributes){
	    anObject(target);
	    propertyKey = toPrimitive(propertyKey, true);
	    anObject(attributes);
	    try {
	      dP.f(target, propertyKey, attributes);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.4 Reflect.deleteProperty(target, propertyKey)
	var $export  = __webpack_require__(74)
	  , gOPD     = __webpack_require__(117).f
	  , anObject = __webpack_require__(78);
	
	$export($export.S, 'Reflect', {
	  deleteProperty: function deleteProperty(target, propertyKey){
	    var desc = gOPD(anObject(target), propertyKey);
	    return desc && !desc.configurable ? false : delete target[propertyKey];
	  }
	});

/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 26.1.5 Reflect.enumerate(target)
	var $export  = __webpack_require__(74)
	  , anObject = __webpack_require__(78);
	var Enumerate = function(iterated){
	  this._t = anObject(iterated); // target
	  this._i = 0;                  // next index
	  var keys = this._k = []       // keys
	    , key;
	  for(key in iterated)keys.push(key);
	};
	__webpack_require__(196)(Enumerate, 'Object', function(){
	  var that = this
	    , keys = that._k
	    , key;
	  do {
	    if(that._i >= keys.length)return {value: undefined, done: true};
	  } while(!((key = keys[that._i++]) in that._t));
	  return {value: key, done: false};
	});
	
	$export($export.S, 'Reflect', {
	  enumerate: function enumerate(target){
	    return new Enumerate(target);
	  }
	});

/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.6 Reflect.get(target, propertyKey [, receiver])
	var gOPD           = __webpack_require__(117)
	  , getPrototypeOf = __webpack_require__(125)
	  , has            = __webpack_require__(71)
	  , $export        = __webpack_require__(74)
	  , isObject       = __webpack_require__(79)
	  , anObject       = __webpack_require__(78);
	
	function get(target, propertyKey/*, receiver*/){
	  var receiver = arguments.length < 3 ? target : arguments[2]
	    , desc, proto;
	  if(anObject(target) === receiver)return target[propertyKey];
	  if(desc = gOPD.f(target, propertyKey))return has(desc, 'value')
	    ? desc.value
	    : desc.get !== undefined
	      ? desc.get.call(receiver)
	      : undefined;
	  if(isObject(proto = getPrototypeOf(target)))return get(proto, propertyKey, receiver);
	}
	
	$export($export.S, 'Reflect', {get: get});

/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
	var gOPD     = __webpack_require__(117)
	  , $export  = __webpack_require__(74)
	  , anObject = __webpack_require__(78);
	
	$export($export.S, 'Reflect', {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
	    return gOPD.f(anObject(target), propertyKey);
	  }
	});

/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.8 Reflect.getPrototypeOf(target)
	var $export  = __webpack_require__(74)
	  , getProto = __webpack_require__(125)
	  , anObject = __webpack_require__(78);
	
	$export($export.S, 'Reflect', {
	  getPrototypeOf: function getPrototypeOf(target){
	    return getProto(anObject(target));
	  }
	});

/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.9 Reflect.has(target, propertyKey)
	var $export = __webpack_require__(74);
	
	$export($export.S, 'Reflect', {
	  has: function has(target, propertyKey){
	    return propertyKey in target;
	  }
	});

/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.10 Reflect.isExtensible(target)
	var $export       = __webpack_require__(74)
	  , anObject      = __webpack_require__(78)
	  , $isExtensible = Object.isExtensible;
	
	$export($export.S, 'Reflect', {
	  isExtensible: function isExtensible(target){
	    anObject(target);
	    return $isExtensible ? $isExtensible(target) : true;
	  }
	});

/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.11 Reflect.ownKeys(target)
	var $export = __webpack_require__(74);
	
	$export($export.S, 'Reflect', {ownKeys: __webpack_require__(309)});

/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	// all object keys, includes non-enumerable and symbols
	var gOPN     = __webpack_require__(116)
	  , gOPS     = __webpack_require__(109)
	  , anObject = __webpack_require__(78)
	  , Reflect  = __webpack_require__(70).Reflect;
	module.exports = Reflect && Reflect.ownKeys || function ownKeys(it){
	  var keys       = gOPN.f(anObject(it))
	    , getSymbols = gOPS.f;
	  return getSymbols ? keys.concat(getSymbols(it)) : keys;
	};

/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.12 Reflect.preventExtensions(target)
	var $export            = __webpack_require__(74)
	  , anObject           = __webpack_require__(78)
	  , $preventExtensions = Object.preventExtensions;
	
	$export($export.S, 'Reflect', {
	  preventExtensions: function preventExtensions(target){
	    anObject(target);
	    try {
	      if($preventExtensions)$preventExtensions(target);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
	var dP             = __webpack_require__(77)
	  , gOPD           = __webpack_require__(117)
	  , getPrototypeOf = __webpack_require__(125)
	  , has            = __webpack_require__(71)
	  , $export        = __webpack_require__(74)
	  , createDesc     = __webpack_require__(83)
	  , anObject       = __webpack_require__(78)
	  , isObject       = __webpack_require__(79);
	
	function set(target, propertyKey, V/*, receiver*/){
	  var receiver = arguments.length < 4 ? target : arguments[3]
	    , ownDesc  = gOPD.f(anObject(target), propertyKey)
	    , existingDescriptor, proto;
	  if(!ownDesc){
	    if(isObject(proto = getPrototypeOf(target))){
	      return set(proto, propertyKey, V, receiver);
	    }
	    ownDesc = createDesc(0);
	  }
	  if(has(ownDesc, 'value')){
	    if(ownDesc.writable === false || !isObject(receiver))return false;
	    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
	    existingDescriptor.value = V;
	    dP.f(receiver, propertyKey, existingDescriptor);
	    return true;
	  }
	  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
	}
	
	$export($export.S, 'Reflect', {set: set});

/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.14 Reflect.setPrototypeOf(target, proto)
	var $export  = __webpack_require__(74)
	  , setProto = __webpack_require__(139);
	
	if(setProto)$export($export.S, 'Reflect', {
	  setPrototypeOf: function setPrototypeOf(target, proto){
	    setProto.check(target, proto);
	    try {
	      setProto.set(target, proto);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/Array.prototype.includes
	var $export   = __webpack_require__(74)
	  , $includes = __webpack_require__(102)(true);
	
	$export($export.P, 'Array', {
	  includes: function includes(el /*, fromIndex = 0 */){
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	
	__webpack_require__(252)('includes');

/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/mathiasbynens/String.prototype.at
	var $export = __webpack_require__(74)
	  , $at     = __webpack_require__(193)(true);
	
	$export($export.P, 'String', {
	  at: function at(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(74)
	  , $pad    = __webpack_require__(316);
	
	$export($export.P, 'String', {
	  padStart: function padStart(maxLength /*, fillString = ' ' */){
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
	  }
	});

/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-string-pad-start-end
	var toLength = __webpack_require__(103)
	  , repeat   = __webpack_require__(157)
	  , defined  = __webpack_require__(101);
	
	module.exports = function(that, maxLength, fillString, left){
	  var S            = String(defined(that))
	    , stringLength = S.length
	    , fillStr      = fillString === undefined ? ' ' : String(fillString)
	    , intMaxLength = toLength(maxLength);
	  if(intMaxLength <= stringLength || fillStr == '')return S;
	  var fillLen = intMaxLength - stringLength
	    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
	  if(stringFiller.length > fillLen)stringFiller = stringFiller.slice(0, fillLen);
	  return left ? stringFiller + S : S + stringFiller;
	};


/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(74)
	  , $pad    = __webpack_require__(316);
	
	$export($export.P, 'String', {
	  padEnd: function padEnd(maxLength /*, fillString = ' ' */){
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
	  }
	});

/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(149)('trimLeft', function($trim){
	  return function trimLeft(){
	    return $trim(this, 1);
	  };
	}, 'trimStart');

/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(149)('trimRight', function($trim){
	  return function trimRight(){
	    return $trim(this, 2);
	  };
	}, 'trimEnd');

/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/String.prototype.matchAll/
	var $export     = __webpack_require__(74)
	  , defined     = __webpack_require__(101)
	  , toLength    = __webpack_require__(103)
	  , isRegExp    = __webpack_require__(200)
	  , getFlags    = __webpack_require__(262)
	  , RegExpProto = RegExp.prototype;
	
	var $RegExpStringIterator = function(regexp, string){
	  this._r = regexp;
	  this._s = string;
	};
	
	__webpack_require__(196)($RegExpStringIterator, 'RegExp String', function next(){
	  var match = this._r.exec(this._s);
	  return {value: match, done: match === null};
	});
	
	$export($export.P, 'String', {
	  matchAll: function matchAll(regexp){
	    defined(this);
	    if(!isRegExp(regexp))throw TypeError(regexp + ' is not a regexp!');
	    var S     = String(this)
	      , flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp)
	      , rx    = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
	    rx.lastIndex = toLength(regexp.lastIndex);
	    return new $RegExpStringIterator(rx, S);
	  }
	});

/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(93)('asyncIterator');

/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(93)('observable');

/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-getownpropertydescriptors
	var $export        = __webpack_require__(74)
	  , ownKeys        = __webpack_require__(309)
	  , toIObject      = __webpack_require__(98)
	  , gOPD           = __webpack_require__(117)
	  , createProperty = __webpack_require__(229);
	
	$export($export.S, 'Object', {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
	    var O       = toIObject(object)
	      , getDesc = gOPD.f
	      , keys    = ownKeys(O)
	      , result  = {}
	      , i       = 0
	      , key;
	    while(keys.length > i)createProperty(result, key = keys[i++], getDesc(O, key));
	    return result;
	  }
	});

/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export = __webpack_require__(74)
	  , $values = __webpack_require__(325)(false);
	
	$export($export.S, 'Object', {
	  values: function values(it){
	    return $values(it);
	  }
	});

/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(96)
	  , toIObject = __webpack_require__(98)
	  , isEnum    = __webpack_require__(110).f;
	module.exports = function(isEntries){
	  return function(it){
	    var O      = toIObject(it)
	      , keys   = getKeys(O)
	      , length = keys.length
	      , i      = 0
	      , result = []
	      , key;
	    while(length > i)if(isEnum.call(O, key = keys[i++])){
	      result.push(isEntries ? [key, O[key]] : O[key]);
	    } return result;
	  };
	};

/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export  = __webpack_require__(74)
	  , $entries = __webpack_require__(325)(true);
	
	$export($export.S, 'Object', {
	  entries: function entries(it){
	    return $entries(it);
	  }
	});

/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export         = __webpack_require__(74)
	  , toObject        = __webpack_require__(124)
	  , aFunction       = __webpack_require__(87)
	  , $defineProperty = __webpack_require__(77);
	
	// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
	__webpack_require__(72) && $export($export.P + __webpack_require__(328), 'Object', {
	  __defineGetter__: function __defineGetter__(P, getter){
	    $defineProperty.f(toObject(this), P, {get: aFunction(getter), enumerable: true, configurable: true});
	  }
	});

/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	// Forced replacement prototype accessors methods
	module.exports = __webpack_require__(94)|| !__webpack_require__(73)(function(){
	  var K = Math.random();
	  // In FF throws only define methods
	  __defineSetter__.call(null, K, function(){ /* empty */});
	  delete __webpack_require__(70)[K];
	});

/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export         = __webpack_require__(74)
	  , toObject        = __webpack_require__(124)
	  , aFunction       = __webpack_require__(87)
	  , $defineProperty = __webpack_require__(77);
	
	// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
	__webpack_require__(72) && $export($export.P + __webpack_require__(328), 'Object', {
	  __defineSetter__: function __defineSetter__(P, setter){
	    $defineProperty.f(toObject(this), P, {set: aFunction(setter), enumerable: true, configurable: true});
	  }
	});

/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export                  = __webpack_require__(74)
	  , toObject                 = __webpack_require__(124)
	  , toPrimitive              = __webpack_require__(82)
	  , getPrototypeOf           = __webpack_require__(125)
	  , getOwnPropertyDescriptor = __webpack_require__(117).f;
	
	// B.2.2.4 Object.prototype.__lookupGetter__(P)
	__webpack_require__(72) && $export($export.P + __webpack_require__(328), 'Object', {
	  __lookupGetter__: function __lookupGetter__(P){
	    var O = toObject(this)
	      , K = toPrimitive(P, true)
	      , D;
	    do {
	      if(D = getOwnPropertyDescriptor(O, K))return D.get;
	    } while(O = getPrototypeOf(O));
	  }
	});

/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export                  = __webpack_require__(74)
	  , toObject                 = __webpack_require__(124)
	  , toPrimitive              = __webpack_require__(82)
	  , getPrototypeOf           = __webpack_require__(125)
	  , getOwnPropertyDescriptor = __webpack_require__(117).f;
	
	// B.2.2.5 Object.prototype.__lookupSetter__(P)
	__webpack_require__(72) && $export($export.P + __webpack_require__(328), 'Object', {
	  __lookupSetter__: function __lookupSetter__(P){
	    var O = toObject(this)
	      , K = toPrimitive(P, true)
	      , D;
	    do {
	      if(D = getOwnPropertyDescriptor(O, K))return D.set;
	    } while(O = getPrototypeOf(O));
	  }
	});

/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(74);
	
	$export($export.P + $export.R, 'Map', {toJSON: __webpack_require__(333)('Map')});

/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(141)
	  , from    = __webpack_require__(334);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};

/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(272);
	
	module.exports = function(iter, ITERATOR){
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(74);
	
	$export($export.P + $export.R, 'Set', {toJSON: __webpack_require__(333)('Set')});

/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-global
	var $export = __webpack_require__(74);
	
	$export($export.S, 'System', {global: __webpack_require__(70)});

/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-is-error
	var $export = __webpack_require__(74)
	  , cof     = __webpack_require__(100);
	
	$export($export.S, 'Error', {
	  isError: function isError(it){
	    return cof(it) === 'Error';
	  }
	});

/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(74);
	
	$export($export.S, 'Math', {
	  iaddh: function iaddh(x0, x1, y0, y1){
	    var $x0 = x0 >>> 0
	      , $x1 = x1 >>> 0
	      , $y0 = y0 >>> 0;
	    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
	  }
	});

/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(74);
	
	$export($export.S, 'Math', {
	  isubh: function isubh(x0, x1, y0, y1){
	    var $x0 = x0 >>> 0
	      , $x1 = x1 >>> 0
	      , $y0 = y0 >>> 0;
	    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
	  }
	});

/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(74);
	
	$export($export.S, 'Math', {
	  imulh: function imulh(u, v){
	    var UINT16 = 0xffff
	      , $u = +u
	      , $v = +v
	      , u0 = $u & UINT16
	      , v0 = $v & UINT16
	      , u1 = $u >> 16
	      , v1 = $v >> 16
	      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
	  }
	});

/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(74);
	
	$export($export.S, 'Math', {
	  umulh: function umulh(u, v){
	    var UINT16 = 0xffff
	      , $u = +u
	      , $v = +v
	      , u0 = $u & UINT16
	      , v0 = $v & UINT16
	      , u1 = $u >>> 16
	      , v1 = $v >>> 16
	      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
	  }
	});

/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                  = __webpack_require__(343)
	  , anObject                  = __webpack_require__(78)
	  , toMetaKey                 = metadata.key
	  , ordinaryDefineOwnMetadata = metadata.set;
	
	metadata.exp({defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey){
	  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
	}});

/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	var Map     = __webpack_require__(277)
	  , $export = __webpack_require__(74)
	  , shared  = __webpack_require__(89)('metadata')
	  , store   = shared.store || (shared.store = new (__webpack_require__(281)));
	
	var getOrCreateMetadataMap = function(target, targetKey, create){
	  var targetMetadata = store.get(target);
	  if(!targetMetadata){
	    if(!create)return undefined;
	    store.set(target, targetMetadata = new Map);
	  }
	  var keyMetadata = targetMetadata.get(targetKey);
	  if(!keyMetadata){
	    if(!create)return undefined;
	    targetMetadata.set(targetKey, keyMetadata = new Map);
	  } return keyMetadata;
	};
	var ordinaryHasOwnMetadata = function(MetadataKey, O, P){
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
	};
	var ordinaryGetOwnMetadata = function(MetadataKey, O, P){
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
	};
	var ordinaryDefineOwnMetadata = function(MetadataKey, MetadataValue, O, P){
	  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
	};
	var ordinaryOwnMetadataKeys = function(target, targetKey){
	  var metadataMap = getOrCreateMetadataMap(target, targetKey, false)
	    , keys        = [];
	  if(metadataMap)metadataMap.forEach(function(_, key){ keys.push(key); });
	  return keys;
	};
	var toMetaKey = function(it){
	  return it === undefined || typeof it == 'symbol' ? it : String(it);
	};
	var exp = function(O){
	  $export($export.S, 'Reflect', O);
	};
	
	module.exports = {
	  store: store,
	  map: getOrCreateMetadataMap,
	  has: ordinaryHasOwnMetadata,
	  get: ordinaryGetOwnMetadata,
	  set: ordinaryDefineOwnMetadata,
	  keys: ordinaryOwnMetadataKeys,
	  key: toMetaKey,
	  exp: exp
	};

/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(343)
	  , anObject               = __webpack_require__(78)
	  , toMetaKey              = metadata.key
	  , getOrCreateMetadataMap = metadata.map
	  , store                  = metadata.store;
	
	metadata.exp({deleteMetadata: function deleteMetadata(metadataKey, target /*, targetKey */){
	  var targetKey   = arguments.length < 3 ? undefined : toMetaKey(arguments[2])
	    , metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
	  if(metadataMap === undefined || !metadataMap['delete'](metadataKey))return false;
	  if(metadataMap.size)return true;
	  var targetMetadata = store.get(target);
	  targetMetadata['delete'](targetKey);
	  return !!targetMetadata.size || store['delete'](target);
	}});

/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(343)
	  , anObject               = __webpack_require__(78)
	  , getPrototypeOf         = __webpack_require__(125)
	  , ordinaryHasOwnMetadata = metadata.has
	  , ordinaryGetOwnMetadata = metadata.get
	  , toMetaKey              = metadata.key;
	
	var ordinaryGetMetadata = function(MetadataKey, O, P){
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if(hasOwn)return ordinaryGetOwnMetadata(MetadataKey, O, P);
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
	};
	
	metadata.exp({getMetadata: function getMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	var Set                     = __webpack_require__(280)
	  , from                    = __webpack_require__(334)
	  , metadata                = __webpack_require__(343)
	  , anObject                = __webpack_require__(78)
	  , getPrototypeOf          = __webpack_require__(125)
	  , ordinaryOwnMetadataKeys = metadata.keys
	  , toMetaKey               = metadata.key;
	
	var ordinaryMetadataKeys = function(O, P){
	  var oKeys  = ordinaryOwnMetadataKeys(O, P)
	    , parent = getPrototypeOf(O);
	  if(parent === null)return oKeys;
	  var pKeys  = ordinaryMetadataKeys(parent, P);
	  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
	};
	
	metadata.exp({getMetadataKeys: function getMetadataKeys(target /*, targetKey */){
	  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	}});

/***/ },
/* 347 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(343)
	  , anObject               = __webpack_require__(78)
	  , ordinaryGetOwnMetadata = metadata.get
	  , toMetaKey              = metadata.key;
	
	metadata.exp({getOwnMetadata: function getOwnMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                = __webpack_require__(343)
	  , anObject                = __webpack_require__(78)
	  , ordinaryOwnMetadataKeys = metadata.keys
	  , toMetaKey               = metadata.key;
	
	metadata.exp({getOwnMetadataKeys: function getOwnMetadataKeys(target /*, targetKey */){
	  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	}});

/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(343)
	  , anObject               = __webpack_require__(78)
	  , getPrototypeOf         = __webpack_require__(125)
	  , ordinaryHasOwnMetadata = metadata.has
	  , toMetaKey              = metadata.key;
	
	var ordinaryHasMetadata = function(MetadataKey, O, P){
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if(hasOwn)return true;
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
	};
	
	metadata.exp({hasMetadata: function hasMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(343)
	  , anObject               = __webpack_require__(78)
	  , ordinaryHasOwnMetadata = metadata.has
	  , toMetaKey              = metadata.key;
	
	metadata.exp({hasOwnMetadata: function hasOwnMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                  = __webpack_require__(343)
	  , anObject                  = __webpack_require__(78)
	  , aFunction                 = __webpack_require__(87)
	  , toMetaKey                 = metadata.key
	  , ordinaryDefineOwnMetadata = metadata.set;
	
	metadata.exp({metadata: function metadata(metadataKey, metadataValue){
	  return function decorator(target, targetKey){
	    ordinaryDefineOwnMetadata(
	      metadataKey, metadataValue,
	      (targetKey !== undefined ? anObject : aFunction)(target),
	      toMetaKey(targetKey)
	    );
	  };
	}});

/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
	var $export   = __webpack_require__(74)
	  , microtask = __webpack_require__(275)()
	  , process   = __webpack_require__(70).process
	  , isNode    = __webpack_require__(100)(process) == 'process';
	
	$export($export.G, {
	  asap: function asap(fn){
	    var domain = isNode && process.domain;
	    microtask(domain ? domain.bind(fn) : fn);
	  }
	});

/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/zenparsing/es-observable
	var $export     = __webpack_require__(74)
	  , global      = __webpack_require__(70)
	  , core        = __webpack_require__(75)
	  , microtask   = __webpack_require__(275)()
	  , OBSERVABLE  = __webpack_require__(91)('observable')
	  , aFunction   = __webpack_require__(87)
	  , anObject    = __webpack_require__(78)
	  , anInstance  = __webpack_require__(271)
	  , redefineAll = __webpack_require__(276)
	  , hide        = __webpack_require__(76)
	  , forOf       = __webpack_require__(272)
	  , RETURN      = forOf.RETURN;
	
	var getMethod = function(fn){
	  return fn == null ? undefined : aFunction(fn);
	};
	
	var cleanupSubscription = function(subscription){
	  var cleanup = subscription._c;
	  if(cleanup){
	    subscription._c = undefined;
	    cleanup();
	  }
	};
	
	var subscriptionClosed = function(subscription){
	  return subscription._o === undefined;
	};
	
	var closeSubscription = function(subscription){
	  if(!subscriptionClosed(subscription)){
	    subscription._o = undefined;
	    cleanupSubscription(subscription);
	  }
	};
	
	var Subscription = function(observer, subscriber){
	  anObject(observer);
	  this._c = undefined;
	  this._o = observer;
	  observer = new SubscriptionObserver(this);
	  try {
	    var cleanup      = subscriber(observer)
	      , subscription = cleanup;
	    if(cleanup != null){
	      if(typeof cleanup.unsubscribe === 'function')cleanup = function(){ subscription.unsubscribe(); };
	      else aFunction(cleanup);
	      this._c = cleanup;
	    }
	  } catch(e){
	    observer.error(e);
	    return;
	  } if(subscriptionClosed(this))cleanupSubscription(this);
	};
	
	Subscription.prototype = redefineAll({}, {
	  unsubscribe: function unsubscribe(){ closeSubscription(this); }
	});
	
	var SubscriptionObserver = function(subscription){
	  this._s = subscription;
	};
	
	SubscriptionObserver.prototype = redefineAll({}, {
	  next: function next(value){
	    var subscription = this._s;
	    if(!subscriptionClosed(subscription)){
	      var observer = subscription._o;
	      try {
	        var m = getMethod(observer.next);
	        if(m)return m.call(observer, value);
	      } catch(e){
	        try {
	          closeSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      }
	    }
	  },
	  error: function error(value){
	    var subscription = this._s;
	    if(subscriptionClosed(subscription))throw value;
	    var observer = subscription._o;
	    subscription._o = undefined;
	    try {
	      var m = getMethod(observer.error);
	      if(!m)throw value;
	      value = m.call(observer, value);
	    } catch(e){
	      try {
	        cleanupSubscription(subscription);
	      } finally {
	        throw e;
	      }
	    } cleanupSubscription(subscription);
	    return value;
	  },
	  complete: function complete(value){
	    var subscription = this._s;
	    if(!subscriptionClosed(subscription)){
	      var observer = subscription._o;
	      subscription._o = undefined;
	      try {
	        var m = getMethod(observer.complete);
	        value = m ? m.call(observer, value) : undefined;
	      } catch(e){
	        try {
	          cleanupSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      } cleanupSubscription(subscription);
	      return value;
	    }
	  }
	});
	
	var $Observable = function Observable(subscriber){
	  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
	};
	
	redefineAll($Observable.prototype, {
	  subscribe: function subscribe(observer){
	    return new Subscription(observer, this._f);
	  },
	  forEach: function forEach(fn){
	    var that = this;
	    return new (core.Promise || global.Promise)(function(resolve, reject){
	      aFunction(fn);
	      var subscription = that.subscribe({
	        next : function(value){
	          try {
	            return fn(value);
	          } catch(e){
	            reject(e);
	            subscription.unsubscribe();
	          }
	        },
	        error: reject,
	        complete: resolve
	      });
	    });
	  }
	});
	
	redefineAll($Observable, {
	  from: function from(x){
	    var C = typeof this === 'function' ? this : $Observable;
	    var method = getMethod(anObject(x)[OBSERVABLE]);
	    if(method){
	      var observable = anObject(method.call(x));
	      return observable.constructor === C ? observable : new C(function(observer){
	        return observable.subscribe(observer);
	      });
	    }
	    return new C(function(observer){
	      var done = false;
	      microtask(function(){
	        if(!done){
	          try {
	            if(forOf(x, false, function(it){
	              observer.next(it);
	              if(done)return RETURN;
	            }) === RETURN)return;
	          } catch(e){
	            if(done)throw e;
	            observer.error(e);
	            return;
	          } observer.complete();
	        }
	      });
	      return function(){ done = true; };
	    });
	  },
	  of: function of(){
	    for(var i = 0, l = arguments.length, items = Array(l); i < l;)items[i] = arguments[i++];
	    return new (typeof this === 'function' ? this : $Observable)(function(observer){
	      var done = false;
	      microtask(function(){
	        if(!done){
	          for(var i = 0; i < items.length; ++i){
	            observer.next(items[i]);
	            if(done)return;
	          } observer.complete();
	        }
	      });
	      return function(){ done = true; };
	    });
	  }
	});
	
	hide($Observable.prototype, OBSERVABLE, function(){ return this; });
	
	$export($export.G, {Observable: $Observable});
	
	__webpack_require__(258)('Observable');

/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	// ie9- setTimeout & setInterval additional parameters fix
	var global     = __webpack_require__(70)
	  , $export    = __webpack_require__(74)
	  , invoke     = __webpack_require__(144)
	  , partial    = __webpack_require__(355)
	  , navigator  = global.navigator
	  , MSIE       = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
	var wrap = function(set){
	  return MSIE ? function(fn, time /*, ...args */){
	    return set(invoke(
	      partial,
	      [].slice.call(arguments, 2),
	      typeof fn == 'function' ? fn : Function(fn)
	    ), time);
	  } : set;
	};
	$export($export.G + $export.B + $export.F * MSIE, {
	  setTimeout:  wrap(global.setTimeout),
	  setInterval: wrap(global.setInterval)
	});

/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var path      = __webpack_require__(356)
	  , invoke    = __webpack_require__(144)
	  , aFunction = __webpack_require__(87);
	module.exports = function(/* ...pargs */){
	  var fn     = aFunction(this)
	    , length = arguments.length
	    , pargs  = Array(length)
	    , i      = 0
	    , _      = path._
	    , holder = false;
	  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
	  return function(/* ...args */){
	    var that = this
	      , aLen = arguments.length
	      , j = 0, k = 0, args;
	    if(!holder && !aLen)return invoke(fn, pargs, that);
	    args = pargs.slice();
	    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
	    while(aLen > k)args.push(arguments[k++]);
	    return invoke(fn, args, that);
	  };
	};

/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(70);

/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(74)
	  , $task   = __webpack_require__(274);
	$export($export.G + $export.B, {
	  setImmediate:   $task.set,
	  clearImmediate: $task.clear
	});

/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	var $iterators    = __webpack_require__(259)
	  , redefine      = __webpack_require__(84)
	  , global        = __webpack_require__(70)
	  , hide          = __webpack_require__(76)
	  , Iterators     = __webpack_require__(195)
	  , wks           = __webpack_require__(91)
	  , ITERATOR      = wks('iterator')
	  , TO_STRING_TAG = wks('toStringTag')
	  , ArrayValues   = Iterators.Array;
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype
	    , key;
	  if(proto){
	    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);
	    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	    Iterators[NAME] = ArrayValues;
	    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);
	  }
	}

/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided, then outerFn.prototype instanceof Generator.
	    var generator = Object.create((outerFn || Generator).prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function(arg) {
	    return new AwaitArgument(arg);
	  };
	
	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }
	
	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value instanceof AwaitArgument) {
	          return Promise.resolve(value.arg).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	
	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" ||
	              (method === "throw" && delegate.iterator[method] === undefined)) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;
	
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }
	
	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }
	
	          var record = tryCatch(
	            delegate.iterator[method],
	            delegate.iterator,
	            arg
	          );
	
	          if (record.type === "throw") {
	            context.delegate = null;
	
	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }
	
	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;
	
	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }
	
	          context.delegate = null;
	        }
	
	        if (method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = arg;
	
	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }
	
	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }
	
	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          var info = {
	            value: record.arg,
	            done: context.done
	          };
	
	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };
	
	  Gp[toStringTagSymbol] = "Generator";
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }
	
	      return ContinueSentinel;
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(12)))

/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(361);
	module.exports = __webpack_require__(75).RegExp.escape;

/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/benjamingr/RexExp.escape
	var $export = __webpack_require__(74)
	  , $re     = __webpack_require__(362)(/[\\^$*+?.()|[\]{}]/g, '\\$&');
	
	$export($export.S, 'RegExp', {escape: function escape(it){ return $re(it); }});


/***/ },
/* 362 */
/***/ function(module, exports) {

	module.exports = function(regExp, replace){
	  var replacer = replace === Object(replace) ? function(part){
	    return replace[part];
	  } : replace;
	  return function(it){
	    return String(it).replace(regExp, replacer);
	  };
	};

/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA3OWMxOTRhMWYwZDU0NGMwMWM4ZSIsIndlYnBhY2s6Ly8vLi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9kcmF3VG9vbC9EcmF3VG9vbC5qcyIsIndlYnBhY2s6Ly8vLi9kcmF3VG9vbC91dGlscy9mb250TG9hZGVyLmpzIiwid2VicGFjazovLy8uL2RyYXdUb29sL3V0aWxzL2Vycm9ycy5qcyIsIndlYnBhY2s6Ly8vLi9kcmF3VG9vbC91dGlscy9lc2NhcGVKU09OLmpzIiwid2VicGFjazovLy8uL2RyYXdUb29sL3V0aWxzL2NsaXAuanMiLCJ3ZWJwYWNrOi8vLy4vZHJhd1Rvb2wvdXRpbHMvZmFicmljLnV1aWQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vZmFicmljL2Rpc3QvZmFicmljLmpzIiwid2VicGFjazovLy8uLi9+L2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vanNkb20gKGlnbm9yZWQpIiwid2VicGFjazovLy9jYW52YXMgKGlnbm9yZWQpIiwid2VicGFjazovLy94bWxkb20gKGlnbm9yZWQpIiwid2VicGFjazovLy8uLi9+L3VybC91cmwuanMiLCJ3ZWJwYWNrOi8vLy4uL34vdXJsL34vcHVueWNvZGUvcHVueWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vd2VicGFjay9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9xdWVyeXN0cmluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9xdWVyeXN0cmluZy9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcXVlcnlzdHJpbmcvZW5jb2RlLmpzIiwid2VicGFjazovLy8uLi9+L2h0dHAtYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uLi9+L2h0dHAtYnJvd3NlcmlmeS9saWIvcmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy8uLi9+L3N0cmVhbS1icm93c2VyaWZ5L34vcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzIiwid2VicGFjazovLy8uLi9+L3N0cmVhbS1icm93c2VyaWZ5L34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwid2VicGFjazovLy8uLi9+L3N0cmVhbS1icm93c2VyaWZ5L34vaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vL3V0aWwgKGlnbm9yZWQpIiwid2VicGFjazovLy8uLi9+L3N0cmVhbS1icm93c2VyaWZ5L34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9zdHJlYW0tYnJvd3NlcmlmeS9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9zdHJpbmdfZGVjb2Rlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9zdHJlYW0tYnJvd3NlcmlmeS9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vLy4uL34vc3RyZWFtLWJyb3dzZXJpZnkvfi9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJ3ZWJwYWNrOi8vLy4uL34vc3RyZWFtLWJyb3dzZXJpZnkvfi9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vc3RyZWFtLWJyb3dzZXJpZnkvfi9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzIiwid2VicGFjazovLy8uLi9+L3N0cmVhbS1icm93c2VyaWZ5L34vcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9zdHJlYW0tYnJvd3NlcmlmeS9+L3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9odHRwLWJyb3dzZXJpZnkvbGliL3Jlc3BvbnNlLmpzIiwid2VicGFjazovLy8uLi9+L3V0aWwvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi4vfi91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwid2VicGFjazovLy8uLi9+L3V0aWwvfi9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy8uLi9+L0Jhc2U2NC9iYXNlNjQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vaHR0cHMtYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vZnMgKGlnbm9yZWQpIiwid2VicGFjazovLy8uL2RyYXdUb29sL1NpZGVzLmpzIiwid2VicGFjazovLy8uL2RyYXdUb29sL1NpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vZHJhd1Rvb2wvSXRlbXMuanMiLCJ3ZWJwYWNrOi8vLy4vZHJhd1Rvb2wvSXRlbS5qcyIsIndlYnBhY2s6Ly8vLi9kcmF3VG9vbC9MYXllcnMuanMiLCJ3ZWJwYWNrOi8vLy4vZHJhd1Rvb2wvdXRpbHMvY29sb3JQaWNrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZHJhd1Rvb2wvRHJhd0hpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vZHJhd1Rvb2wvRXJhc2VyLmpzIiwid2VicGFjazovLy8uL2RyYXdUb29sL2JydXNoZXMvdXRpbC91dGlsLmV4dGVuZC5qcyIsIndlYnBhY2s6Ly8vLi9kcmF3VG9vbC9icnVzaGVzL3V0aWwvYmFzZUJydXNoLmV4dGVuZC5qcyIsIndlYnBhY2s6Ly8vLi9kcmF3VG9vbC9icnVzaGVzL3V0aWwvcG9pbnQuZXh0ZW5kLmpzIiwid2VicGFjazovLy8uL2RyYXdUb29sL2JydXNoZXMvYnJ1c2hlcy9zdHJva2UuanMiLCJ3ZWJwYWNrOi8vLy4vZHJhd1Rvb2wvYnJ1c2hlcy9icnVzaGVzL3BlbmNpbEJydXNoLmpzIiwid2VicGFjazovLy8uL2RyYXdUb29sL2JydXNoZXMvYnJ1c2hlcy9jcmF5b25CcnVzaC5qcyIsIndlYnBhY2s6Ly8vLi9kcmF3VG9vbC9icnVzaGVzL2JydXNoZXMvaW5rQnJ1c2guanMiLCJ3ZWJwYWNrOi8vLy4vZHJhd1Rvb2wvYnJ1c2hlcy9icnVzaGVzL3NwcmF5QnJ1c2guanMiLCJ3ZWJwYWNrOi8vLy4vZHJhd1Rvb2wvYnJ1c2hlcy9icnVzaGVzL21hcmtlckJydXNoLmpzIiwid2VicGFjazovLy8uL2RyYXdUb29sL2JydXNoZXMvYnJ1c2hlcy9jdXN0b21CcnVzaC5qcyIsIndlYnBhY2s6Ly8vLi9kcmF3VG9vbC91dGlscy9yZW1vdmVDb2xvci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1wb2x5ZmlsbC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9zaGltLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19mYWlscy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fY3R4LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX21ldGEuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3drcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3drcy1leHQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fbGlicmFyeS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2tleW9mLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3Qtc2FwLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL190by1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2VhbC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLXNlYWxlZC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1leHRlbnNpYmxlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19zYW1lLXZhbHVlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19zZXQtcHJvdG8uanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19iaW5kLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9faW52b2tlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWludC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWludC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy10cmltLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXdzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucGFyc2UtZmxvYXQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19wYXJzZS1mbG9hdC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2luaGVyaXQtaWYtcmVxdWlyZWQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIudG8tZml4ZWQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19hLW51bWJlci12YWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1yZXBlYXQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIudG8tcHJlY2lzaW9uLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24uanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtZmluaXRlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19pcy1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYWNvc2guanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19tYXRoLWxvZzFwLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hc2luaC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXRhbmguanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNicnQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19tYXRoLXNpZ24uanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNsejMyLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jb3NoLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5leHBtMS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX21hdGgtZXhwbTEuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmZyb3VuZC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmltdWwuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxcC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2luaC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudGFuaC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudHJ1bmMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJhdy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy50cmltLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1jb250ZXh0LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtcmVnZXhwLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fZmFpbHMtaXMtcmVnZXhwLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5hbmNob3IuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctaHRtbC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5iaWcuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYmxpbmsuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYm9sZC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250Y29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udHNpemUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5saW5rLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnNtYWxsLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0cmlrZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdWIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3VwLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS5ub3cuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24uanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm9mLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuam9pbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmljdC1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zbGljZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvcnQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5tYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb21lLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZXZlcnkuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UtcmlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pbmRleC1vZi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWNvcHktd2l0aGluLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNwZWNpZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1zdGVwLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAudG8tc3RyaW5nLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLm1hdGNoLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnByb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19hbi1pbnN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2Zvci1vZi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL190YXNrLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fbWljcm90YXNrLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWFwLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc2V0LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1tYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXdlYWsuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLXNldC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYnVmZmVyLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZGF0YS12aWV3LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLWFycmF5LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQzMi1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5hcHBseS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuY29uc3RydWN0LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlbGV0ZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZW51bWVyYXRlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuaGFzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5pcy1leHRlbnNpYmxlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5vd24ta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX293bi1rZXlzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLmF0LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1wYWQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5tYXRjaC1hbGwuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LnZhbHVlcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC10by1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1nZXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZm9yY2VkLXBhbS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtc2V0dGVyLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLXNldHRlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC50by1qc29uLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi10by1qc29uLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LmVycm9yLmlzLWVycm9yLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pYWRkaC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaXN1YmguanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmltdWxoLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC51bXVsaC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlbGV0ZS1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS1rZXlzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1vd24tbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lm1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuYXNhcC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL3dlYi50aW1lcnMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19wYXJ0aWFsLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fcGF0aC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9mbi9yZWdleHAvZXNjYXBlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9jb3JlLnJlZ2V4cC5lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19yZXBsYWNlci5qcyJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiZ2xvYmFsIiwiX2JhYmVsUG9seWZpbGwiLCJyZXF1aXJlIiwiRHJhd1Rvb2wiLCJlZGl0YWJsZSIsImNvbnRhaW5lciIsInRhcmdldCIsImRvY3VtZW50IiwiYm9keSIsInNpemUiLCJ3aWR0aCIsImhlaWdodCIsImdyaWRTdGVwIiwiX2NhbGxiYWNrcyIsInNpZGVzIiwiaW5pdGlhbGl6ZSIsIkhUTUxFbGVtZW50IiwiRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwiZXJyb3IiLCJIVE1MRWxlbWVudFVuZGVmaW5lZCIsIl90YXJnZXQiLCJ3aW5kb3ciLCJoYXNPd25Qcm9wZXJ0eSIsImpRdWVyeSIsIl9zaXplIiwidGV4dENvbnRlbnQiLCJzdHlsZSIsInBvc2l0aW9uIiwiaGlzdG9yeSIsInNldEVkaXRhYmxlIiwidmFsIiwiX2NvbGxlY3Rpb24iLCJmb3JFYWNoIiwic2lkZSIsIkZhYnJpY0JvcmRlciIsInNldCIsIkZhYnJpY0NhbnZhcyIsImRlYWN0aXZhdGVBbGwiLCJyZW5kZXJBbGwiLCJvbiIsImV2ZW50IiwiaGFuZGxlciIsInB1c2giLCJvZmYiLCJkZWxldGUiLCJ0cmlnZ2VyIiwiZGF0YSIsInB1c2hTdGF0ZSIsImlkIiwiZ2V0U2lkZSIsImxheWVycyIsInVwZGF0ZSIsImNiIiwiZXhwb3J0SlNPTiIsIm1hcCIsInRvT2JqZWN0IiwiaW1wb3J0SlNPTiIsImpzb24iLCJpbml0aWFsWm9vbSIsImVtcHR5IiwicGFyc2UiLCJfc2lkZSIsImFkZFNpZGUiLCJzZXRJbWFnZSIsImltYWdlVXJsIiwidGhlbiIsInNldEJvcmRlciIsImJvcmRlciIsInpvb21Ub1ZhbCIsImJpbmQiLCJmb250TG9hZGVyIiwidGl0bGUiLCJ1cmxzIiwiZm9udEZhY2UiLCJlb3QiLCJ3b2ZmMiIsIndvZmYiLCJ0dGYiLCJzdmciLCJjcmVhdGVFbGVtZW50IiwiaW5uZXJUZXh0IiwiaGVhZCIsImFwcGVuZENoaWxkIiwiZm9yY2VDYWxsIiwiZm9udEZhbWlseSIsInRleHRJbmRlbnQiLCJ6SW5kZXgiLCJsZWZ0IiwidG9wIiwiZXJyb3JzIiwic2lkZU5vU2l6ZSIsImNvZGUiLCJtZXNzYWdlIiwic2lkZU5vQm9yZGVyIiwiZXNjYXBlSlNPTiIsInN0cmluZyIsInN0ciIsInJlcGxhY2UiLCJyZWN0IiwiT2JqZWN0IiwiYXNzaWduIiwic3Ryb2tlV2lkdGgiLCJnZW5lcmF0ZSIsIkZ1bmN0aW9uIiwidXVpZCIsImMiLCJyIiwiTWF0aCIsInJhbmRvbSIsInYiLCJ0b1N0cmluZyIsInByb3RvdHlwZSIsInNldE9wdGlvbnMiLCJvcHRpb25zIiwiYXBwbHkiLCJwcm9wZXJ0aWVzVG9JbmNsdWRlIiwiY29uY2F0IiwiU2lkZXMiLCJzZWxlY3RlZCIsIm5ld1NpZGUiLCJmaW5kIiwid3JhcHBlckVsIiwiZGlzcGxheSIsImluZGV4IiwiZmluZEluZGV4IiwiY2xlYXIiLCJ1bmRlZmluZWQiLCJjYW52YXMiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJzcGxpY2UiLCJjb2xsZWN0aW9uIiwicmVtb3ZlU2lkZSIsIlNpZGUiLCJ0aGF0IiwicGFkZGluZyIsIl9wYW5uaW5nIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJfaW5pdEZhYnJpYyIsIl9pbml0RXZlbnRzIiwiaXRlbXMiLCJjdXJyZW50QnJ1c2giLCJjb2xvclBpY2tlciIsInVybCIsImltYWdlIiwiY2VudGVyIiwiZ2V0Q2VudGVyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJzZXRCYWNrZ3JvdW5kQ29sb3IiLCJzZXRCYWNrZ3JvdW5kSW1hZ2UiLCJiYWNrZHJvcCIsImJhY2tncm91bmRJbWFnZSIsImV4Y2x1ZGVGcm9tRXhwb3J0Iiwic2NhbGVUb1dpZHRoIiwiZGV2aWNlUGl4ZWxSYXRpbyIsInNjYWxlVG9IZWlnaHQiLCJjbVNpemUiLCJfY2FsY3VsYXRlU2l6ZSIsIl9pbml0R3JpZCIsIl9pbml0UnVsZXIiLCJvcmlnaW5YIiwib3JpZ2luWSIsIm9wYWNpdHkiLCJjcm9zc09yaWdpbiIsIl9pbml0V29ya3NwYWNlR3JpZCIsIl9pbml0V29ya3NwYWNlUnVsZXIiLCJyZW1vdmUiLCJfb3B0cyIsInN0cm9rZSIsImZpbGwiLCJoYXNSb3RhdGluZ1BvaW50IiwibG9ja1JvdGF0aW9uIiwicGFkZGluZ1RvcCIsInNjYWxlWSIsInBhZGRpbmdMZWZ0Iiwic2NhbGVYIiwiX29wdGlvbnMiLCJSZWN0Iiwic2V0Q29vcmRzIiwic2VsZWN0YWJsZSIsImhvdmVyQ3Vyc29yIiwiYWRkIiwiZ2V0Q2VudGVyUG9pbnQiLCJfcmVhbCIsInpvb21Ub1BvaW50Iiwiem9vbSIsImdldFpvb20iLCJnZXRWcENlbnRlciIsIl9mb3JtYXR0ZWRTaWRlIiwib2JqZWN0cyIsIml0ZW0iLCJ4IiwieSIsImdldEJvcmRlciIsIl9yZW1vdmVFdmVudHMiLCJjYW52YXNEYXRhIiwibG9hZEZyb21KU09OIiwic2VuZFRvQmFjayIsIm8iLCJkaWZmVyIsImRpZmZIIiwiZGlmZlgiLCJkaWZmWSIsInR5cGUiLCJjYWxsYmFjayIsImNsb25lIiwiZm9yRWFjaE9iamVjdCIsImNsaXBUbyIsImJhc2U2NCIsInRvRGF0YVVSTCIsImVuYWJsZVJldGluYSIsIkltYWdlIiwic3JjIiwiZmFicmljSW1hZ2UiLCJ0b1NWRyIsInN1cHByZXNzUHJlYW1ibGUiLCJ2aWV3Qm94IiwiZWwiLCJpbmNsdWRlcyIsInBhcnNlciIsIkRPTVBhcnNlciIsImRvYyIsInBhcnNlRnJvbVN0cmluZyIsInN2Z09iaiIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwic2V0QXR0cmlidXRlIiwiaW5uZXJIVE1MIiwic2V0VmlzaWJsZSIsInByZXZpZXciLCJtdWx0aXBsaWVyIiwiaXNEcmF3aW5nTW9kZSIsInBhbm5pbmciLCJmcmVlRHJhd2luZ0JydXNoIiwiUGVuY2lsQnJ1c2hDIiwiY29sb3IiLCJDYW52YXMiLCJzZWxlY3Rpb24iLCJlbmFibGVSZXRpbmFTY2FsaW5nIiwiY29udHJvbHNBYm92ZU92ZXJsYXkiLCJ1cHBlckNhbnZhc0VsIiwibG93ZXJDYW52YXNFbCIsImUiLCJpc1dvcmtTcGFjZUJvcmRlciIsIl9wYW5uaW5nRG93biIsIl9wYW5feDAiLCJsYXllclgiLCJfcGFuX3kwIiwibGF5ZXJZIiwiYWN0aXZlIiwibW92ZSIsInJlbGF0aXZlUGFuIiwib2JqIiwidyIsImgiLCJzIiwic3RhdGUiLCJncmlkIiwidmlzaWJsZSIsImRlc3Ryb3kiLCJjbSIsInN0ZXBYIiwic3RlcFkiLCJHcm91cCIsImhhc0NvbnRyb2xzIiwiTGluZSIsImVuYWJsZSIsInJ1bGVyIiwid29ya3NwYWNlR3JpZCIsIndvcmtzcGFjZVJ1bGVyIiwibnVtYmVyIiwiX3VwZGF0ZSIsIkJvb2xlYW4iLCJkZWFjdGl2YXRlIiwib2JqZWN0IiwiSXRlbXMiLCJsb2FkU1ZHRnJvbVVSTCIsImxvYWRlZE9iamVjdCIsInV0aWwiLCJncm91cFNWR0VsZW1lbnRzIiwidHJpZ2dlckNyZWF0ZWQiLCJmcm9tVVJMIiwib0ltZyIsInR4dCIsImZvbnRTaXplIiwiZm9udFN0eWxlIiwiZm9udFdlaWdodCIsInRleHRBbGlnbiIsInZlcnRpY2FsIiwidGV4dCIsIlRleHRib3giLCJzZXRBY3RpdmVPYmplY3QiLCJFcmFzZXIiLCJDcmF5b25CcnVzaCIsIklua0JydXNoIiwiTWFya2VyQnJ1c2giLCJTcHJheUJydXNoIiwiQ3VzdG9tQnJ1c2giLCJmaW5hbGl6ZSIsIl9vIiwiY2hhbmdlQ29sb3IiLCJjaGFuZ2VPcGFjaXR5IiwiSXRlbSIsImFuZ2xlIiwic2NhbGUiLCJicnVzaCIsInNldEFuZ2xlIiwicGFyc2VJbnQiLCJfcG9zaXRpb24iLCJhbmltYXRlIiwib25DaGFuZ2UiLCJmaWx0ZXIiLCJmaWx0ZXJzIiwiVGludCIsImFwcGx5RmlsdGVycyIsInNldENvbG9yIiwic2V0T3BhY2l0eSIsIk51bWJlciIsImdldEZvbnRGYW1pbHkiLCJzZXRGb250RmFtaWx5IiwiX2luaXREaW1lbnNpb25zIiwiZ2V0Rm9udFN0eWxlIiwic2V0Rm9udFN0eWxlIiwiZ2V0Rm9udFdlaWdodCIsInNldEZvbnRXZWlnaHQiLCJnZXRGb250U2l6ZSIsInNldEZvbnRTaXplIiwiZ2V0VGV4dEFsaWduIiwic2V0VGV4dEFsaWduIiwiZ2V0VGV4dCIsInNldFRleHQiLCJkaXN0YW5jZSIsIlJlbW92ZUNvbG9yIiwiZW50ZXJFZGl0aW5nIiwiZXhpdEVkaXRpbmciLCJMYXllcnMiLCJsaXN0Iiwib3B0IiwicXVhbGl0eSIsImNsaXB0byIsImdldENsaXBUbyIsInNldENsaXBUbyIsImluZGV4ZXMiLCJnZXRPYmplY3RzIiwiX2dldEl0ZW1zQnlJbmRleCIsImJyaW5nVG9Gcm9udCIsImJyaW5nRm9yd2FyZCIsInNlbmRCYWNrd2FyZHMiLCJfYWN0aXZlIiwiX2NvbG9yIiwiY3Vyc29yIiwiQ2lyY2xlIiwicmFkaXVzIiwiZXZlbnRlZCIsInNoYWRvdyIsIlNoYWRvdyIsImxvY2tVbmlTY2FsaW5nIiwicG9pbnRlciIsImdldFBvaW50ZXIiLCJnZXRDb2xvciIsInB4IiwiY29udGV4dENvbnRhaW5lciIsImdldEltYWdlRGF0YSIsIkNvbG9yIiwidG9IZXgiLCJ2YWx1ZSIsInNldEZpbGwiLCJEcmF3SGlzdG9yeSIsImN1cnJlbnRJbmRleCIsInNsaWNlIiwibGVuZ3RoIiwiY3JlYXRlQ2xhc3MiLCJCYXNlQnJ1c2giLCJvbk1vdXNlRG93biIsIm9uTW91c2VNb3ZlIiwib25Nb3VzZVVwIiwidGFyZ2V0cyIsImNvbnRhaW5zUG9pbnQiLCJpc1RhcmdldFRyYW5zcGFyZW50IiwiZ2V0UmFuZG9tIiwibWF4IiwibWluIiwiY2xhbXAiLCJuIiwidHJpbSIsImNvbnRleHQiLCJjb3B5IiwiZ2V0Q29udGV4dCIsInBpeGVscyIsImwiLCJpIiwiYm91bmQiLCJyaWdodCIsImJvdHRvbSIsImltZyIsInRyaW1IZWlnaHQiLCJ0cmltV2lkdGgiLCJ0cmltbWVkIiwicHV0SW1hZ2VEYXRhIiwibW92ZWQiLCJvcmlnaW5hbFJlbmRlck9uQWRkUmVtb3ZlIiwicmVuZGVyT25BZGRSZW1vdmUiLCJ2dCIsInZpZXdwb3J0VHJhbnNmb3JtIiwicmFzdGVyIiwiY29udGV4dFRvcCIsImNsZWFyQ29udGV4dCIsIl9yZXNldFNoYWRvdyIsIlBvaW50IiwiYW5nbGVCZXR3ZWVuIiwiYXRhbjIiLCJub3JtYWxpemUiLCJ0aGlja25lc3MiLCJkaXN0YW5jZUZyb20iLCJTdHJva2UiLCJpbmtBbW91bnQiLCJsaW5lV2lkdGgiLCJfcG9pbnQiLCJfbGFzdFBvaW50IiwiX2N1cnJlbnRMaW5lV2lkdGgiLCJjdHgiLCJyYW5nZSIsInJ4IiwiUEkiLCJjMCIsIngwIiwic2luIiwieTAiLCJjb3MiLCJsaW5lQ2FwIiwic3VidHJhY3RQb2ludCIsImFkZEVxdWFscyIsInBlciIsImRyYXciLCJzYXZlIiwibGluZSIsInJlc3RvcmUiLCJwb2ludDEiLCJwb2ludDIiLCJzdHJva2VTdHlsZSIsImJlZ2luUGF0aCIsIm1vdmVUbyIsImxpbmVUbyIsIl9iYXNlV2lkdGgiLCJfbGluZVdpZHRoIiwiZ2xvYmFsQWxwaGEiLCJsaW5lSm9pbiIsIl9yZW5kZXIiLCJsaW5lV2lkdGhEaWZmIiwibGVuIiwidHJhbnNmb3JtIiwiX2lzQ3VycmVudGx5RHJhd2luZyIsIl9pbmtBbW91bnQiLCJfbGF0ZXN0U3Ryb2tlTGVuZ3RoIiwiX3NlcCIsInJlbmRlciIsInAiLCJfbGF0ZXN0Iiwic2V0RnJvbVBvaW50IiwiY2FsbCIsInN1YnRyYWN0IiwiaiIsInN0ZXBOdW0iLCJkb3RTaXplIiwiZG90TnVtIiwiY2VpbCIsImZsb29yIiwiZmlsbFN0eWxlIiwibXVsdGlwbHkiLCJfcmFuZ2UiLCJfc3Ryb2tlQ291bnQiLCJfc3Ryb2tlSWQiLCJfc3Ryb2tlTnVtIiwiX3N0cm9rZXMiLCJwb2ludCIsInN0cm9rZXMiLCJzZXRQb2ludGVyIiwiZHJhd1NwbGFzaCIsIl9yZXNldFRpcCIsIkRhdGUiLCJtYXhTaXplIiwibnVtIiwiYXJjIiwiX2RyaXBzIiwiX2RyaXBUaHJlc2hvbGQiLCJfaW50ZXJ2YWwiLCJzcHJheUJydXNoRGF0YVVybCIsIl9yZXNldCIsInNldFRpbWVvdXQiLCJhbW91bnQiLCJwb3ciLCJkcmF3SW1hZ2UiLCJfZWxlbWVudCIsImRpc3QiLCJleHRlbmQiLCJCYXNlRmlsdGVyIiwiYXBwbHlUbyIsImNhbnZhc0VsIiwiaW1hZ2VEYXRhIiwidGhyZXNob2xkIiwibGltaXQiLCJnIiwiYiIsImFicyIsIl9zb3VyY2UiLCJjYWxsU3VwZXIiLCJmcm9tT2JqZWN0Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7OztBQ3RDQTs7Ozs7O0FBRUFBLFFBQU9DLE9BQVAsc0I7Ozs7Ozs7Ozs7OztBQ0VBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7O0FBRUE7Ozs7QUFDQTs7OztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOzs7O0FBMUJBLEtBQUksQ0FBQ0MsT0FBT0MsY0FBWixFQUE0QjtBQUN6QkMsR0FBQSxtQkFBQUEsQ0FBUSxFQUFSO0FBQ0Y7O0FBMEJEOzs7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QUNBLFFBQU87QUFDUCxNQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFNBQVM7QUFDdEIsY0FBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUM7OztBQUdEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFrRCxFQUFFO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBcUI7QUFDckIsMEJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGVBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixtQkFBbUI7QUFDdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUMsS0FBSztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhEQUE2RCxPQUFPO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyREFBMEQsT0FBTztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQixFQUFF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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUscUJBQXFCLFFBQVE7QUFDNUMsZ0JBQWUsT0FBTztBQUN0QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0EsOEJBQTZCLEVBQUU7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBc0QsWUFBWTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxpQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0EsaUJBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWdCLFFBQVE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTs7QUFFQTtBQUNBLDZIQUE0SDtBQUM1SDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtIQUE4SDtBQUM5SDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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QTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxpQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZSx5QkFBeUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUseUJBQXlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxjQUFhLHFEQUFxRDtBQUNsRSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxzQkFBc0I7QUFDbEU7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLFNBQVM7QUFDeEIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDREQUEyRCxTQUFTO0FBQ3BFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhDQUE2QyxVQUFVO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0RBQXFELFVBQVU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQTZDLFNBQVM7O0FBRXREOztBQUVBLDhCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEIsY0FBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFdBQVc7QUFDeEIsY0FBYSxTQUFTO0FBQ3RCLGNBQWEsT0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGVBQWM7QUFDZCxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFpRCxlQUFlO0FBQ2hFLCtEQUE4RCxlQUFlO0FBQzdFOztBQUVBO0FBQ0Es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O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEwQjs7QUFFMUI7QUFDQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYSxNQUFNO0FBQ25CLGVBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWlELFNBQVM7QUFDMUQ7QUFDQTs7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSx5QkFBd0IsUUFBUTtBQUNoQztBQUNBLHNCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsZ0JBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQSxTQUFRLFVBQVU7O0FBRWxCO0FBQ0E7Ozs7Ozs7QUNuRkEsa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7Ozs7Ozs7QUNKQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QixVQUFVOzs7Ozs7O0FDbkx0QyxnQjs7Ozs7O0FDQUEsZ0I7Ozs7OztBQ0FBLGdCOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWdCLEtBQUs7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQztBQUNyQztBQUNBO0FBQ0EsMkNBQTBDLEtBQUs7QUFDL0MsMENBQXlDLEtBQUs7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFDQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVUsTUFBTTtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Ozs7OztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7OztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakIsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHO0FBQ0gscUJBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM3U0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFTO0FBQ1Q7O0FBRUEsbUNBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXVCLHNCQUFzQjtBQUM3QztBQUNBLDRCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQWtDO0FBQ2xDO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXNDLGdCQUFnQjtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLGlDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3Q3QkE7QUFDQTtBQUNBOzs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDMUdBLGdCOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHlCQUF5QjtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0Esb0JBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM1ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVEsT0FBTztBQUNmOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzVOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQyxZQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNoTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDN0NBOzs7Ozs7O0FDQUE7Ozs7Ozs7QUNBQTs7Ozs7OztBQ0FBOzs7Ozs7O0FDQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsd0JBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTRDLEtBQUs7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxvQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsMERBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYLFVBQVM7QUFDVDtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ2hCRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUNQRDtBQUNBOztBQUVBLDZCQUE0QixnQ0FBZ0MsRTs7Ozs7O0FDSDVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ1BEO0FBQ0E7O0FBRUEsNkJBQTRCLCtCQUE4QixFOzs7Ozs7QUNIMUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ2REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDWEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDUEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxFQUFDLEU7Ozs7OztBQ3RCRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEVBQUMsRTs7Ozs7O0FDakJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDTkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCLGVBQWM7QUFDZDtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0I7QUFDL0I7QUFDQTtBQUNBLFdBQVU7QUFDVixFQUFDLEU7Ozs7OztBQ2hCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEVBQUM7O0FBRUQsd0M7Ozs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPLFdBQVc7QUFDbEI7QUFDQTtBQUNBLFFBQU8sVUFBVTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU8sV0FBVztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxRQUFPLFdBQVc7QUFDbEI7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7O0FBRUE7QUFDQSx3REFBdUQsNkNBQTZDLEVBQUU7O0FBRXRHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTCxrREFBaUQ7QUFDakQ7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTCxvQ0FBbUM7QUFDbkM7QUFDQSxNQUFLO0FBQ0wsdUVBQXNFO0FBQ3RFO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsNkRBQTREO0FBQzVEO0FBQ0EsTUFBSztBQUNMLHVFQUFzRTtBQUN0RTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUgsdUJBQXNCLHNCQUFzQixFQUFFLEVBQUU7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUErQixTQUFTLEU7Ozs7OztBQzlCeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ2REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRCxzQzs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ1REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUNURDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ1REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsZTs7Ozs7O0FDTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxhOzs7Ozs7QUNORDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1YsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDN0JELDBDOzs7Ozs7QUNBQSx1Qzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxF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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EseUNBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFF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QUV2RCwrQkFBOEIsNEJBQTRCLGdCQUFnQixHQUFHOzs7Ozs7O0FDSjdFO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHIiwiZmlsZSI6ImRyYXd0b29sLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiRHJhd1Rvb2xcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiRHJhd1Rvb2xcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiBcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb25cbiAqKi8iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIDc5YzE5NGExZjBkNTQ0YzAxYzhlXG4gKiovIiwiaW1wb3J0IERyYXdUb29sIGZyb20gJy4vZHJhd1Rvb2wvRHJhd1Rvb2wnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERyYXdUb29sO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaW5kZXguanNcbiAqKi8iLCJpZiAoIWdsb2JhbC5fYmFiZWxQb2x5ZmlsbCkge1xuICAgcmVxdWlyZSgnYmFiZWwtcG9seWZpbGwnKTtcbn1cblxuaW1wb3J0IGZvbnRMb2FkZXIgZnJvbSAnLi91dGlscy9mb250TG9hZGVyJztcbmltcG9ydCBlcnJvcnMgZnJvbSAnLi91dGlscy9lcnJvcnMnO1xuaW1wb3J0IGVzY2FwZUpTT04gZnJvbSAnLi91dGlscy9lc2NhcGVKU09OJztcbmltcG9ydCBjbGlwIGZyb20gJy4vdXRpbHMvY2xpcCc7XG5cbmltcG9ydCAnLi91dGlscy9mYWJyaWMudXVpZCc7XG5cbmltcG9ydCBTaWRlcyBmcm9tICcuL1NpZGVzJztcbmltcG9ydCBEcmF3SGlzdG9yeSBmcm9tICcuL0RyYXdIaXN0b3J5JztcblxuaW1wb3J0ICcuL0VyYXNlcic7XG5pbXBvcnQgJy4vYnJ1c2hlcy91dGlsL3V0aWwuZXh0ZW5kJztcbmltcG9ydCAnLi9icnVzaGVzL3V0aWwvYmFzZUJydXNoLmV4dGVuZCc7XG5pbXBvcnQgJy4vYnJ1c2hlcy91dGlsL3BvaW50LmV4dGVuZCc7XG5pbXBvcnQgJy4vYnJ1c2hlcy9icnVzaGVzL3N0cm9rZSc7XG5pbXBvcnQgJy4vYnJ1c2hlcy9icnVzaGVzL3BlbmNpbEJydXNoJztcbmltcG9ydCAnLi9icnVzaGVzL2JydXNoZXMvY3JheW9uQnJ1c2gnO1xuaW1wb3J0ICcuL2JydXNoZXMvYnJ1c2hlcy9pbmtCcnVzaCc7XG5pbXBvcnQgJy4vYnJ1c2hlcy9icnVzaGVzL3NwcmF5QnJ1c2gnO1xuaW1wb3J0ICcuL2JydXNoZXMvYnJ1c2hlcy9tYXJrZXJCcnVzaCc7XG5pbXBvcnQgJy4vYnJ1c2hlcy9icnVzaGVzL2N1c3RvbUJydXNoJztcblxuaW1wb3J0ICcuL3V0aWxzL3JlbW92ZUNvbG9yJztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIERyYXdUb29sXG4gKi9cbmxldCBEcmF3VG9vbCA9IHtcblxuICAvKipcbiAgICogQHByb3BlcnR5IGVkaXRhYmxlXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEBtZW1iZXJPZiBEcmF3VG9vbFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGVkaXRhYmxlOiBmYWxzZSxcblxuICAvKipcbiAgICogQHByb3BlcnR5IENvbnRhaW5lclxuICAgKiBAZGVmYXVsdCBjb250YWluZXI6IHt0YXJnZXQ6IGRvY3VtZW50LmJvZHksIHNpemU6IHt3aWR0aDogZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCwgaGVpZ2h0OiBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodH19XG4gICAqIEBtZW1iZXJPZiBEcmF3VG9vbFxuICAgKiBAdHlwZSB7e3RhcmdldDogSFRNTEVsZW1lbnQsIHNpemU6IHt3aWR0aDogTnVtYmVyLCBoZWlnaHQ6IE51bWJlcn19fVxuICAgKi9cbiAgY29udGFpbmVyOiB7XG4gICAgdGFyZ2V0OiBkb2N1bWVudC5ib2R5LFxuICAgIHNpemU6IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgR3JpZCBTdGVwXG4gICAqIEBkZWZhdWx0IDEwXG4gICAqIEBtZW1iZXJPZiBEcmF3VG9vbFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ3JpZFN0ZXA6IDEwLFxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgQ2FsbGJhY2tzXG4gICAqIEBkZWZhdWx0IHt9XG4gICAqIEBtZW1iZXJPZiBEcmF3VG9vbFxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NhbGxiYWNrczoge30sXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBTaWRlc1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBtZW1iZXJPZiBEcmF3VG9vbFxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc2lkZXM6IG51bGwsXG4gIC8qKlxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJPZiBEcmF3VG9vbFxuICAgKiBAcGFyYW0gdGFyZ2V0IHtIVE1MRWxlbWVudH0gdGFyZ2V0IGNvbnRhaW5lclxuICAgKiBAcGFyYW0gc2l6ZSB7T2JqZWN0fSBTaXplIG9mIGNhbnZhc1xuICAgKiBAcGFyYW0gc2l6ZS53aWR0aCB7TnVtYmVyfSBXaWR0aCBvZiBjYW52YXNcbiAgICogQHBhcmFtIHNpemUuaGVpZ2h0IHtOdW1iZXJ9IGhlaWdodCBvZiBjYW52YXNcbiAgICovXG4gIGluaXRpYWxpemUodGFyZ2V0LCBzaXplKSB7XG5cbiAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgIHRocm93ICggbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KHtlcnJvcjogZXJyb3JzLkhUTUxFbGVtZW50VW5kZWZpbmVkfSkpICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IF90YXJnZXQgPSB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ2pRdWVyeScpICYmIHRhcmdldCBpbnN0YW5jZW9mIGpRdWVyeSA/IHRhcmdldFswXSA6IHRhcmdldDtcblxuICAgIGxldCBfc2l6ZSA9IHNpemUgfHwge307XG5cbiAgICB0aGlzLmNvbnRhaW5lciA9IHtcbiAgICAgIHRhcmdldDogX3RhcmdldCxcbiAgICAgIHNpemU6IF9zaXplXG4gICAgfTtcblxuICAgIHRoaXMuY29udGFpbmVyLnRhcmdldC50ZXh0Q29udGVudCA9ICcnO1xuICAgIHRoaXMuY29udGFpbmVyLnRhcmdldC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG5cbiAgICB0aGlzLnNpZGVzID0gbmV3IFNpZGVzKCk7XG5cbiAgICB0aGlzLmhpc3RvcnkgPSBuZXcgRHJhd0hpc3RvcnkoKTtcblxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgc2lkZXMgZWRpdGFibGVcbiAgICogQG1lbWJlck9mIERyYXdUb29sXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHZhbCB7Qm9vbGVhbn0gZGVmYXVsdDogdHJ1ZVxuICAgKi9cbiAgc2V0RWRpdGFibGUodmFsID0gdHJ1ZSkge1xuICAgIHRoaXMuZWRpdGFibGUgPSB2YWw7XG5cbiAgICB0aGlzLnNpZGVzLl9jb2xsZWN0aW9uLmZvckVhY2goKHNpZGUpID0+IHtcbiAgICAgIGlmKHNpZGUuRmFicmljQm9yZGVyKSB7XG4gICAgICAgIHNpZGUuRmFicmljQm9yZGVyLnNldCgnc2VsZWN0YWJsZScsIHRoaXMuZWRpdGFibGUpO1xuICAgICAgICBzaWRlLkZhYnJpY0NhbnZhcy5kZWFjdGl2YXRlQWxsKCkucmVuZGVyQWxsKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZCBldmVudCBoYW5kbGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBldmVudCBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgSGFuZGxlciBmdW5jdGlvblxuICAgKi9cbiAgb24oZXZlbnQsIGhhbmRsZXIpe1xuICAgIHRoaXMuX2NhbGxiYWNrc1tldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdO1xuICAgIHRoaXMuX2NhbGxiYWNrc1tldmVudF0ucHVzaChoYW5kbGVyKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGV2ZW50IGhhbmRsZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IGV2ZW50IG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBIYW5kbGVyIGZ1bmN0aW9uXG4gICAqL1xuICBvZmYoZXZlbnQsIGhhbmRsZXIpe1xuICAgIHRoaXMuX2NhbGxiYWNrc1tldmVudF0uZGVsZXRlKGhhbmRsZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGV2ZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBldmVudCBuYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqL1xuICB0cmlnZ2VyKGV2ZW50LCBkYXRhKXtcblxuICAgIGlmKGV2ZW50ID09PSAnaGlzdG9yeTp1cGRhdGUnKXtcbiAgICAgIHRoaXMuaGlzdG9yeS5wdXNoU3RhdGUoZGF0YS5zaWRlLmlkKTtcbiAgICAgIHRoaXMuc2lkZXMuZ2V0U2lkZShkYXRhLnNpZGUuaWQpLmxheWVycy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBpZih0eXBlb2YgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSAhPT0gJ3VuZGVmaW5lZCcpIHtcblxuICAgICAgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XS5mb3JFYWNoKGNiID0+IGNiKEpTT04uc3RyaW5naWZ5KGRhdGEpKSk7XG5cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4cG9ydCBwcm9kdWN0IGRhdGFcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgZXhwb3J0SlNPTigpe1xuICAgIGxldCBkYXRhID0gdGhpcy5zaWRlcy5fY29sbGVjdGlvbi5tYXAoc2lkZSA9PiBzaWRlLnRvT2JqZWN0KCkpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgfSxcblxuICAvKipcbiAgICogSW1wb3J0IHByb2R1Y3QgZGF0YVxuICAgKiBAcGFyYW0ge1N0cmluZ30ganNvblxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5pdGlhbFpvb21cbiAgICovXG4gIGltcG9ydEpTT04oanNvbiwgaW5pdGlhbFpvb20pe1xuXG4gICAgaWYodGhpcy5zaWRlcykge1xuICAgICAgdGhpcy5zaWRlcy5lbXB0eSgpO1xuICAgIH1cblxuICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZShlc2NhcGVKU09OKGpzb24pKTtcblxuICAgIGRhdGEuZm9yRWFjaChzaWRlID0+IHtcblxuICAgICAgbGV0IF9zaWRlID0gdGhpcy5zaWRlcy5hZGRTaWRlKHNpZGUuaWQpO1xuICAgICAgX3NpZGUuc2V0SW1hZ2Uoc2lkZS5pbWFnZVVybCwgc2lkZS5zaXplKVxuICAgICAgICAudGhlbigoaWQpID0+IHtcblxuICAgICAgICAgIF9zaWRlLnNldEJvcmRlcihzaWRlLmJvcmRlcik7XG5cbiAgICAgICAgICBpZiAoaW5pdGlhbFpvb20pe1xuICAgICAgICAgICAgX3NpZGUuem9vbVRvVmFsKGluaXRpYWxab29tKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsLmJpbmQoX3NpZGUuRmFicmljQ2FudmFzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgZm9udExvYWRlcjogZm9udExvYWRlcixcblxufTtcblxuZXhwb3J0IGRlZmF1bHQgRHJhd1Rvb2w7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2RyYXdUb29sL0RyYXdUb29sLmpzXG4gKiovIiwiLyoqXG4gKlxuICogQHBhcmFtIHRpdGxlIHtTdHJpbmd9XG4gKiBAcGFyYW0gdXJscyB7T2JqZWN0fVxuICogQHBhcmFtIHVybHMuZW90IHtTdHJpbmd9XG4gKiBAcGFyYW0gdXJscy50dGYge1N0cmluZ31cbiAqIEBwYXJhbSB1cmxzLndvZmYge1N0cmluZ31cbiAqIEBwYXJhbSB1cmxzLndvZmYyIHtTdHJpbmd9XG4gKiBAcGFyYW0gdXJscy5zdmcge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZm9udExvYWRlcih0aXRsZSwgdXJscyl7XG5cbiAgbGV0IGZvbnRGYWNlID0gYEBmb250LWZhY2Uge2ZvbnQtZmFtaWx5OiAnJHt0aXRsZX0nO1xuICAgIHNyYzogdXJsKCcke3VybHMuZW90IHx8ICcnfScpO1xuICAgIHNyYzogdXJsKCcke3VybHMuZW90IHx8ICcnfT8jaWVmaXgnKSBmb3JtYXQoJ2VtYmVkZGVkLW9wZW50eXBlJyksXG4gICAgICB1cmwoJyR7dXJscy53b2ZmMiB8fCAnJ30nKSBmb3JtYXQoJ3dvZmYyJyksXG4gICAgICB1cmwoJyR7dXJscy53b2ZmIHx8ICcnfScpIGZvcm1hdCgnd29mZicpLFxuICAgICAgdXJsKCcke3VybHMudHRmIHx8ICcnfScpIGZvcm1hdCgndHJ1ZXR5cGUnKSxcbiAgICAgIHVybCgnJHt1cmxzLnN2ZyB8fCAnJ30nKSBmb3JtYXQoJ3N2ZycpO1xuICAgIGZvbnQtd2VpZ2h0OiBub3JtYWw7XG4gICAgZm9udC1zdHlsZTogbm9ybWFsO1xuICB9YDtcblxuICBsZXQgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICBzdHlsZS5pbm5lclRleHQgPSBmb250RmFjZTtcbiAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cbiAgbGV0IGZvcmNlQ2FsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgZm9yY2VDYWxsLmlubmVyVGV4dCA9ICcmbmJzcDsnO1xuICBmb3JjZUNhbGwuc3R5bGUuZm9udEZhbWlseSA9IHRpdGxlO1xuICBmb3JjZUNhbGwuc3R5bGUudGV4dEluZGVudCA9ICctOTk5OTlweCc7XG4gIGZvcmNlQ2FsbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSdcbiAgZm9yY2VDYWxsLnN0eWxlLnpJbmRleCA9ICcwJztcbiAgZm9yY2VDYWxsLnN0eWxlLmxlZnQgPSAnLTk5OTlweCc7XG4gIGZvcmNlQ2FsbC5zdHlsZS50b3AgPSAnLTk5OTlweCc7XG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JjZUNhbGwpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmb250TG9hZGVyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZHJhd1Rvb2wvdXRpbHMvZm9udExvYWRlci5qc1xuICoqLyIsImNvbnN0IGVycm9ycyA9IHtcbiAgc2lkZU5vU2l6ZToge1xuICAgIGNvZGU6IDEsXG4gICAgbWVzc2FnZTogJ1NpZGUgaGFzIG5vIHNpemUnXG4gIH0sXG4gIHNpZGVOb0JvcmRlcjoge1xuICAgIGNvZGU6IDIsXG4gICAgbWVzc2FnZTogJ1NpZGUgaGFzIG5vIHdvcmsgYXJlYSdcbiAgfSxcbiAgSFRNTEVsZW1lbnRVbmRlZmluZWQ6IHtcbiAgICBjb2RlOiAzLFxuICAgIG1lc3NhZ2U6ICdEcmF3VG9vbDogVGFyZ2V0IHNob3VsZCBiZSBhIEhUTUxFbGVtZW50J1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGVycm9ycztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2RyYXdUb29sL3V0aWxzL2Vycm9ycy5qc1xuICoqLyIsImZ1bmN0aW9uIGVzY2FwZUpTT04oc3RyaW5nKXtcblxuICBsZXQgc3RyID0gc3RyaW5nLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpXG4gICAgLnJlcGxhY2UoL1xcci9nLCBcIlxcXFxyXCIpXG4gICAgLnJlcGxhY2UoL1xcdC9nLCBcIlxcXFx0XCIpO1xuXG4gIHJldHVybiBzdHI7XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgZXNjYXBlSlNPTjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2RyYXdUb29sL3V0aWxzL2VzY2FwZUpTT04uanNcbiAqKi8iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihib3JkZXIpIHtcblxuICBjb25zdCByZWN0ID0gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgIGxlZnQ6IGJvcmRlci5sZWZ0LFxuICAgIHRvcDpib3JkZXIudG9wLFxuICAgIHdpZHRoOiBib3JkZXIud2lkdGgsXG4gICAgaGVpZ2h0OiBib3JkZXIuaGVpZ2h0LFxuICAgIHN0cm9rZVdpZHRoOiBib3JkZXIuc3Ryb2tlV2lkdGgsXG4gICAgc3Ryb2tlV2lkdGg6IGJvcmRlci5zdHJva2VXaWR0aCxcbiAgfSk7XG5cbiAgY29uc3QgZ2VuZXJhdGUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIGxldCBjbGlwUmVjdCA9ICR7SlNPTi5zdHJpbmdpZnkocmVjdCl9O1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHZhciBtID0gdGhpcy5jYWxjVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgICB2YXIgaU0gPSBmYWJyaWMudXRpbC5pbnZlcnRUcmFuc2Zvcm0obSk7XG4gICAgICBjdHgudHJhbnNmb3JtLmFwcGx5KGN0eCwgaU0pO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICBjdHgucmVjdChcbiAgICAgICAgY2xpcFJlY3QubGVmdCxcbiAgICAgICAgY2xpcFJlY3QudG9wLFxuICAgICAgICBjbGlwUmVjdC53aWR0aCAtIGNsaXBSZWN0LnN0cm9rZVdpZHRoLFxuICAgICAgICBjbGlwUmVjdC5oZWlnaHQgLSBjbGlwUmVjdC5zdHJva2VXaWR0aFxuICAgICAgKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7YFxuICB9XG5cbiAgcmV0dXJuIG5ldyBGdW5jdGlvbignY3R4JywgZ2VuZXJhdGUoKSk7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kcmF3VG9vbC91dGlscy9jbGlwLmpzXG4gKiovIiwiaW1wb3J0IHtmYWJyaWN9IGZyb20gJ2ZhYnJpYyc7XG5cbmZ1bmN0aW9uIHV1aWQoKSB7XG4gIHJldHVybiAneHh4eHh4eHh4eHh4NHh4eHl4eHh4eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDAsIHYgPSBjID09ICd4JyA/IHIgOiAociAmIDB4MyB8IDB4OCk7XG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICB9KTtcbn1cblxuZmFicmljLk9iamVjdC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IChmdW5jdGlvbiAoc2V0T3B0aW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBzZXRPcHRpb25zLmFwcGx5KHRoaXMsIFtvcHRpb25zXSk7XG4gICAgdGhpcy51dWlkID0gdGhpcy51dWlkIHx8IHV1aWQoKTtcbiAgfTtcbn0pKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnNldE9wdGlvbnMpO1xuXG5mYWJyaWMuT2JqZWN0LnByb3RvdHlwZS50b09iamVjdCA9IChmdW5jdGlvbiAodG9PYmplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgcHJvcGVydGllc1RvSW5jbHVkZSA9IChwcm9wZXJ0aWVzVG9JbmNsdWRlIHx8IFtdKS5jb25jYXQoWyd1dWlkJ10pO1xuICAgIHJldHVybiB0b09iamVjdC5hcHBseSh0aGlzLCBbcHJvcGVydGllc1RvSW5jbHVkZV0pO1xuICB9O1xufSkoZmFicmljLk9iamVjdC5wcm90b3R5cGUudG9PYmplY3QpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZHJhd1Rvb2wvdXRpbHMvZmFicmljLnV1aWQuanNcbiAqKi8iLCIvKiBidWlsZDogYG5vZGUgYnVpbGQuanMgbW9kdWxlcz1BTEwgZXhjbHVkZT1qc29uLGdlc3R1cmVzIG1pbmlmaWVyPXVnbGlmeWpzYCAqL1xuLyohIEZhYnJpYy5qcyBDb3B5cmlnaHQgMjAwOC0yMDE1LCBQcmludGlvIChKdXJpeSBaYXl0c2V2LCBNYXhpbSBDaGVybnlhaykgKi9cblxudmFyIGZhYnJpYyA9IGZhYnJpYyB8fCB7IHZlcnNpb246IFwiMS42LjZcIiB9O1xuaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICBleHBvcnRzLmZhYnJpYyA9IGZhYnJpYztcbn1cblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZmFicmljLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gIGZhYnJpYy53aW5kb3cgPSB3aW5kb3c7XG4gIC8vIGVuc3VyZSBnbG9iYWxpdHkgZXZlbiBpZiBlbnRpcmUgbGlicmFyeSB3ZXJlIGZ1bmN0aW9uIHdyYXBwZWQgKGFzIGluIE1ldGVvci5qcyBwYWNrYWdpbmcgc3lzdGVtKVxuICB3aW5kb3cuZmFicmljID0gZmFicmljO1xufVxuZWxzZSB7XG4gIC8vIGFzc3VtZSB3ZSdyZSBydW5uaW5nIHVuZGVyIG5vZGUuanMgd2hlbiBkb2N1bWVudC93aW5kb3cgYXJlIG5vdCBwcmVzZW50XG4gIGZhYnJpYy5kb2N1bWVudCA9IHJlcXVpcmUoXCJqc2RvbVwiKVxuICAgIC5qc2RvbShcIjwhRE9DVFlQRSBodG1sPjxodG1sPjxoZWFkPjwvaGVhZD48Ym9keT48L2JvZHk+PC9odG1sPlwiKTtcblxuICBpZiAoZmFicmljLmRvY3VtZW50LmNyZWF0ZVdpbmRvdykge1xuICAgIGZhYnJpYy53aW5kb3cgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlV2luZG93KCk7XG4gIH0gZWxzZSB7XG4gICAgZmFicmljLndpbmRvdyA9IGZhYnJpYy5kb2N1bWVudC5wYXJlbnRXaW5kb3c7XG4gIH1cbn1cblxuLyoqXG4gKiBUcnVlIHdoZW4gaW4gZW52aXJvbm1lbnQgdGhhdCBzdXBwb3J0cyB0b3VjaCBldmVudHNcbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xuZmFicmljLmlzVG91Y2hTdXBwb3J0ZWQgPSBcIm9udG91Y2hzdGFydFwiIGluIGZhYnJpYy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbi8qKlxuICogVHJ1ZSB3aGVuIGluIGVudmlyb25tZW50IHRoYXQncyBwcm9iYWJseSBOb2RlLmpzXG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbmZhYnJpYy5pc0xpa2VseU5vZGUgPSB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuXG4vKiBfRlJPTV9TVkdfU1RBUlRfICovXG4vKipcbiAqIEF0dHJpYnV0ZXMgcGFyc2VkIGZyb20gYWxsIFNWRyBlbGVtZW50c1xuICogQHR5cGUgYXJyYXlcbiAqL1xuZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTID0gW1xuICBcImRpc3BsYXlcIixcbiAgXCJ0cmFuc2Zvcm1cIixcbiAgXCJmaWxsXCIsIFwiZmlsbC1vcGFjaXR5XCIsIFwiZmlsbC1ydWxlXCIsXG4gIFwib3BhY2l0eVwiLFxuICBcInN0cm9rZVwiLCBcInN0cm9rZS1kYXNoYXJyYXlcIiwgXCJzdHJva2UtbGluZWNhcFwiLFxuICBcInN0cm9rZS1saW5lam9pblwiLCBcInN0cm9rZS1taXRlcmxpbWl0XCIsXG4gIFwic3Ryb2tlLW9wYWNpdHlcIiwgXCJzdHJva2Utd2lkdGhcIixcbiAgXCJpZFwiXG5dO1xuLyogX0ZST01fU1ZHX0VORF8gKi9cblxuLyoqXG4gKiBQaXhlbCBwZXIgSW5jaCBhcyBhIGRlZmF1bHQgdmFsdWUgc2V0IHRvIDk2LiBDYW4gYmUgY2hhbmdlZCBmb3IgbW9yZSByZWFsaXN0aWMgY29udmVyc2lvbi5cbiAqL1xuZmFicmljLkRQSSA9IDk2O1xuZmFicmljLnJlTnVtID0gJyg/OlstK10/KD86XFxcXGQrfFxcXFxkKlxcXFwuXFxcXGQrKSg/OmVbLStdP1xcXFxkKyk/KSc7XG5mYWJyaWMuZm9udFBhdGhzID0geyB9O1xuXG4vKipcbiAqIENhY2hlIE9iamVjdCBmb3Igd2lkdGhzIG9mIGNoYXJzIGluIHRleHQgcmVuZGVyaW5nLlxuICovXG5mYWJyaWMuY2hhcldpZHRoc0NhY2hlID0geyB9O1xuXG4vKipcbiAqIERldmljZSBQaXhlbCBSYXRpb1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vbGlicmFyeS9zYWZhcmkvZG9jdW1lbnRhdGlvbi9BdWRpb1ZpZGVvL0NvbmNlcHR1YWwvSFRNTC1jYW52YXMtZ3VpZGUvU2V0dGluZ1VwdGhlQ2FudmFzL1NldHRpbmdVcHRoZUNhbnZhcy5odG1sXG4gKi9cbmZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvID0gZmFicmljLndpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhYnJpYy53aW5kb3cud2Via2l0RGV2aWNlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93Lm1vekRldmljZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZnVuY3Rpb24gX3JlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgaWYgKCF0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZXZlbnRMaXN0ZW5lciA9IHRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdO1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBldmVudExpc3RlbmVyW2V2ZW50TGlzdGVuZXIuaW5kZXhPZihoYW5kbGVyKV0gPSBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmYWJyaWMudXRpbC5hcnJheS5maWxsKGV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT2JzZXJ2ZXMgc3BlY2lmaWVkIGV2ZW50XG4gICAqIEBkZXByZWNhdGVkIGBvYnNlcnZlYCBkZXByZWNhdGVkIHNpbmNlIDAuOC4zNCAodXNlIGBvbmAgaW5zdGVhZClcbiAgICogQG1lbWJlck9mIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEBhbGlhcyBvblxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGV2ZW50TmFtZSBFdmVudCBuYW1lIChlZy4gJ2FmdGVyOnJlbmRlcicpIG9yIG9iamVjdCB3aXRoIGtleS92YWx1ZSBwYWlycyAoZWcuIHsnYWZ0ZXI6cmVuZGVyJzogaGFuZGxlciwgJ3NlbGVjdGlvbjpjbGVhcmVkJzogaGFuZGxlcn0pXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgRnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhIG5vdGlmaWNhdGlvbiB3aGVuIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvY2N1cnNcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmdW5jdGlvbiBvYnNlcnZlKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIGlmICghdGhpcy5fX2V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9fZXZlbnRMaXN0ZW5lcnMgPSB7IH07XG4gICAgfVxuICAgIC8vIG9uZSBvYmplY3Qgd2l0aCBrZXkvdmFsdWUgcGFpcnMgd2FzIHBhc3NlZFxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIGV2ZW50TmFtZSkge1xuICAgICAgICB0aGlzLm9uKHByb3AsIGV2ZW50TmFtZVtwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXSkge1xuICAgICAgICB0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXSA9IFtdO1xuICAgICAgfVxuICAgICAgdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0ucHVzaChoYW5kbGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgZXZlbnQgb2JzZXJ2aW5nIGZvciBhIHBhcnRpY3VsYXIgZXZlbnQgaGFuZGxlci4gQ2FsbGluZyB0aGlzIG1ldGhvZFxuICAgKiB3aXRob3V0IGFyZ3VtZW50cyByZW1vdmVzIGFsbCBoYW5kbGVycyBmb3IgYWxsIGV2ZW50c1xuICAgKiBAZGVwcmVjYXRlZCBgc3RvcE9ic2VydmluZ2AgZGVwcmVjYXRlZCBzaW5jZSAwLjguMzQgKHVzZSBgb2ZmYCBpbnN0ZWFkKVxuICAgKiBAbWVtYmVyT2YgZmFicmljLk9ic2VydmFibGVcbiAgICogQGFsaWFzIG9mZlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGV2ZW50TmFtZSBFdmVudCBuYW1lIChlZy4gJ2FmdGVyOnJlbmRlcicpIG9yIG9iamVjdCB3aXRoIGtleS92YWx1ZSBwYWlycyAoZWcuIHsnYWZ0ZXI6cmVuZGVyJzogaGFuZGxlciwgJ3NlbGVjdGlvbjpjbGVhcmVkJzogaGFuZGxlcn0pXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgRnVuY3Rpb24gdG8gYmUgZGVsZXRlZCBmcm9tIEV2ZW50TGlzdGVuZXJzXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZnVuY3Rpb24gc3RvcE9ic2VydmluZyhldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICBpZiAoIXRoaXMuX19ldmVudExpc3RlbmVycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBhbGwga2V5L3ZhbHVlIHBhaXJzIChldmVudCBuYW1lIC0+IGV2ZW50IGhhbmRsZXIpXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGZvciAoZXZlbnROYW1lIGluIHRoaXMuX19ldmVudExpc3RlbmVycykge1xuICAgICAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG9uZSBvYmplY3Qgd2l0aCBrZXkvdmFsdWUgcGFpcnMgd2FzIHBhc3NlZFxuICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gZXZlbnROYW1lKSB7XG4gICAgICAgIF9yZW1vdmVFdmVudExpc3RlbmVyLmNhbGwodGhpcywgcHJvcCwgZXZlbnROYW1lW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIGV2ZW50IHdpdGggYW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3RcbiAgICogQGRlcHJlY2F0ZWQgYGZpcmVgIGRlcHJlY2F0ZWQgc2luY2UgMS4wLjcgKHVzZSBgdHJpZ2dlcmAgaW5zdGVhZClcbiAgICogQG1lbWJlck9mIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEBhbGlhcyB0cmlnZ2VyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZSB0byBmaXJlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmdW5jdGlvbiBmaXJlKGV2ZW50TmFtZSwgb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5fX2V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVyc0ZvckV2ZW50ID0gdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgaWYgKCFsaXN0ZW5lcnNGb3JFdmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnNGb3JFdmVudC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbGlzdGVuZXJzRm9yRXZlbnRbaV0gJiYgbGlzdGVuZXJzRm9yRXZlbnRbaV0uY2FsbCh0aGlzLCBvcHRpb25zIHx8IHsgfSk7XG4gICAgfVxuICAgIHRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdID0gbGlzdGVuZXJzRm9yRXZlbnQuZmlsdGVyKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT09IGZhbHNlO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2UgZmFicmljLk9ic2VydmFibGVcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTIjZXZlbnRzfVxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2V2ZW50c3xFdmVudHMgZGVtb31cbiAgICovXG4gIGZhYnJpYy5PYnNlcnZhYmxlID0ge1xuICAgIG9ic2VydmU6IG9ic2VydmUsXG4gICAgc3RvcE9ic2VydmluZzogc3RvcE9ic2VydmluZyxcbiAgICBmaXJlOiBmaXJlLFxuXG4gICAgb246IG9ic2VydmUsXG4gICAgb2ZmOiBzdG9wT2JzZXJ2aW5nLFxuICAgIHRyaWdnZXI6IGZpcmVcbiAgfTtcbn0pKCk7XG5cblxuLyoqXG4gKiBAbmFtZXNwYWNlIGZhYnJpYy5Db2xsZWN0aW9uXG4gKi9cbmZhYnJpYy5Db2xsZWN0aW9uID0ge1xuXG4gIF9vYmplY3RzOiBbXSxcblxuICAvKipcbiAgICogQWRkcyBvYmplY3RzIHRvIGNvbGxlY3Rpb24sIENhbnZhcyBvciBHcm91cCwgdGhlbiByZW5kZXJzIGNhbnZhc1xuICAgKiAoaWYgYHJlbmRlck9uQWRkUmVtb3ZlYCBpcyBub3QgYGZhbHNlYCkuXG4gICAqIGluIGNhc2Ugb2YgR3JvdXAgbm8gY2hhbmdlcyB0byBib3VuZGluZyBib3ggYXJlIG1hZGUuXG4gICAqIE9iamVjdHMgc2hvdWxkIGJlIGluc3RhbmNlcyBvZiAob3IgaW5oZXJpdCBmcm9tKSBmYWJyaWMuT2JqZWN0XG4gICAqIEBwYXJhbSB7Li4uZmFicmljLk9iamVjdH0gb2JqZWN0IFplcm8gb3IgbW9yZSBmYWJyaWMgaW5zdGFuY2VzXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgYWRkOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fb2JqZWN0cy5wdXNoLmFwcGx5KHRoaXMuX29iamVjdHMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHRoaXMuX29uT2JqZWN0QWRkZWQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fb25PYmplY3RBZGRlZChhcmd1bWVudHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVuZGVyQWxsKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluc2VydHMgYW4gb2JqZWN0IGludG8gY29sbGVjdGlvbiBhdCBzcGVjaWZpZWQgaW5kZXgsIHRoZW4gcmVuZGVycyBjYW52YXMgKGlmIGByZW5kZXJPbkFkZFJlbW92ZWAgaXMgbm90IGBmYWxzZWApXG4gICAqIEFuIG9iamVjdCBzaG91bGQgYmUgYW4gaW5zdGFuY2Ugb2YgKG9yIGluaGVyaXQgZnJvbSkgZmFicmljLk9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBpbnNlcnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IEluZGV4IHRvIGluc2VydCBvYmplY3QgYXRcbiAgICogQHBhcmFtIHtCb29sZWFufSBub25TcGxpY2luZyBXaGVuIGB0cnVlYCwgbm8gc3BsaWNpbmcgKHNoaWZ0aW5nKSBvZiBvYmplY3RzIG9jY3Vyc1xuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGluc2VydEF0OiBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgbm9uU3BsaWNpbmcpIHtcbiAgICB2YXIgb2JqZWN0cyA9IHRoaXMuZ2V0T2JqZWN0cygpO1xuICAgIGlmIChub25TcGxpY2luZykge1xuICAgICAgb2JqZWN0c1tpbmRleF0gPSBvYmplY3Q7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgb2JqZWN0cy5zcGxpY2UoaW5kZXgsIDAsIG9iamVjdCk7XG4gICAgfVxuICAgIHRoaXMuX29uT2JqZWN0QWRkZWQgJiYgdGhpcy5fb25PYmplY3RBZGRlZChvYmplY3QpO1xuICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZW5kZXJBbGwoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBvYmplY3RzIGZyb20gYSBjb2xsZWN0aW9uLCB0aGVuIHJlbmRlcnMgY2FudmFzIChpZiBgcmVuZGVyT25BZGRSZW1vdmVgIGlzIG5vdCBgZmFsc2VgKVxuICAgKiBAcGFyYW0gey4uLmZhYnJpYy5PYmplY3R9IG9iamVjdCBaZXJvIG9yIG1vcmUgZmFicmljIGluc3RhbmNlc1xuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9iamVjdHMgPSB0aGlzLmdldE9iamVjdHMoKSxcbiAgICAgICAgaW5kZXgsIHNvbWV0aGluZ1JlbW92ZWQgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGluZGV4ID0gb2JqZWN0cy5pbmRleE9mKGFyZ3VtZW50c1tpXSk7XG5cbiAgICAgIC8vIG9ubHkgY2FsbCBvbk9iamVjdFJlbW92ZWQgaWYgYW4gb2JqZWN0IHdhcyBhY3R1YWxseSByZW1vdmVkXG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHNvbWV0aGluZ1JlbW92ZWQgPSB0cnVlO1xuICAgICAgICBvYmplY3RzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHRoaXMuX29uT2JqZWN0UmVtb3ZlZCAmJiB0aGlzLl9vbk9iamVjdFJlbW92ZWQoYXJndW1lbnRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHNvbWV0aGluZ1JlbW92ZWQgJiYgdGhpcy5yZW5kZXJBbGwoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogRXhlY3V0ZXMgZ2l2ZW4gZnVuY3Rpb24gZm9yIGVhY2ggb2JqZWN0IGluIHRoaXMgZ3JvdXBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogICAgICAgICAgICAgICAgICAgQ2FsbGJhY2sgaW52b2tlZCB3aXRoIGN1cnJlbnQgb2JqZWN0IGFzIGZpcnN0IGFyZ3VtZW50LFxuICAgKiAgICAgICAgICAgICAgICAgICBpbmRleCAtIGFzIHNlY29uZCBhbmQgYW4gYXJyYXkgb2YgYWxsIG9iamVjdHMgLSBhcyB0aGlyZC5cbiAgICogICAgICAgICAgICAgICAgICAgQ2FsbGJhY2sgaXMgaW52b2tlZCBpbiBhIGNvbnRleHQgb2YgR2xvYmFsIE9iamVjdCAoZS5nLiBgd2luZG93YClcbiAgICogICAgICAgICAgICAgICAgICAgd2hlbiBubyBgY29udGV4dGAgYXJndW1lbnQgaXMgZ2l2ZW5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgQ29udGV4dCAoYWthIHRoaXNPYmplY3QpXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZm9yRWFjaE9iamVjdDogZnVuY3Rpb24oY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB2YXIgb2JqZWN0cyA9IHRoaXMuZ2V0T2JqZWN0cygpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIG9iamVjdHNbaV0sIGksIG9iamVjdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBjaGlsZHJlbiBvYmplY3RzIG9mIHRoaXMgaW5zdGFuY2VcbiAgICogVHlwZSBwYXJhbWV0ZXIgaW50cm9kdWNlZCBpbiAxLjMuMTBcbiAgICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSBXaGVuIHNwZWNpZmllZCwgb25seSBvYmplY3RzIG9mIHRoaXMgdHlwZSBhcmUgcmV0dXJuZWRcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBnZXRPYmplY3RzOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRoaXMuX29iamVjdHM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9vYmplY3RzLmZpbHRlcihmdW5jdGlvbihvKSB7XG4gICAgICByZXR1cm4gby50eXBlID09PSB0eXBlO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG9iamVjdCBhdCBzcGVjaWZpZWQgaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICovXG4gIGl0ZW06IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmdldE9iamVjdHMoKVtpbmRleF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBjb2xsZWN0aW9uIGNvbnRhaW5zIG5vIG9iamVjdHNcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBjb2xsZWN0aW9uIGlzIGVtcHR5XG4gICAqL1xuICBpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0cygpLmxlbmd0aCA9PT0gMDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHNpemUgb2YgYSBjb2xsZWN0aW9uIChpLmU6IGxlbmd0aCBvZiBhbiBhcnJheSBjb250YWluaW5nIGl0cyBvYmplY3RzKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IENvbGxlY3Rpb24gc2l6ZVxuICAgKi9cbiAgc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0cygpLmxlbmd0aDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGNvbGxlY3Rpb24gY29udGFpbnMgYW4gb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNoZWNrIGFnYWluc3RcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGNvbGxlY3Rpb24gY29udGFpbnMgYW4gb2JqZWN0XG4gICAqL1xuICBjb250YWluczogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0cygpLmluZGV4T2Yob2JqZWN0KSA+IC0xO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG51bWJlciByZXByZXNlbnRhdGlvbiBvZiBhIGNvbGxlY3Rpb24gY29tcGxleGl0eVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHlcbiAgICovXG4gIGNvbXBsZXhpdHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RzKCkucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBjdXJyZW50KSB7XG4gICAgICBtZW1vICs9IGN1cnJlbnQuY29tcGxleGl0eSA/IGN1cnJlbnQuY29tcGxleGl0eSgpIDogMDtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIDApO1xuICB9XG59O1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICB2YXIgc3FydCA9IE1hdGguc3FydCxcbiAgICAgIGF0YW4yID0gTWF0aC5hdGFuMixcbiAgICAgIHBvdyA9IE1hdGgucG93LFxuICAgICAgYWJzID0gTWF0aC5hYnMsXG4gICAgICBQaUJ5MTgwID0gTWF0aC5QSSAvIDE4MDtcblxuICAvKipcbiAgICogQG5hbWVzcGFjZSBmYWJyaWMudXRpbFxuICAgKi9cbiAgZmFicmljLnV0aWwgPSB7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHZhbHVlIGZyb20gYW4gYXJyYXkuXG4gICAgICogUHJlc2VuY2Ugb2YgdmFsdWUgKGFuZCBpdHMgcG9zaXRpb24gaW4gYW4gYXJyYXkpIGlzIGRldGVybWluZWQgdmlhIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmBcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7QXJyYXl9IG9yaWdpbmFsIGFycmF5XG4gICAgICovXG4gICAgcmVtb3ZlRnJvbUFycmF5OiBmdW5jdGlvbihhcnJheSwgdmFsdWUpIHtcbiAgICAgIHZhciBpZHggPSBhcnJheS5pbmRleE9mKHZhbHVlKTtcbiAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgIGFycmF5LnNwbGljZShpZHgsIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHJhbmRvbSBudW1iZXIgYmV0d2VlbiAyIHNwZWNpZmllZCBvbmVzLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWluIGxvd2VyIGxpbWl0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heCB1cHBlciBsaW1pdFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gcmFuZG9tIHZhbHVlIChiZXR3ZWVuIG1pbiBhbmQgbWF4KVxuICAgICAqL1xuICAgIGdldFJhbmRvbUludDogZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGRlZ3JlZXMgdG8gcmFkaWFucy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlZ3JlZXMgdmFsdWUgaW4gZGVncmVlc1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gdmFsdWUgaW4gcmFkaWFuc1xuICAgICAqL1xuICAgIGRlZ3JlZXNUb1JhZGlhbnM6IGZ1bmN0aW9uKGRlZ3JlZXMpIHtcbiAgICAgIHJldHVybiBkZWdyZWVzICogUGlCeTE4MDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyByYWRpYW5zIHRvIGRlZ3JlZXMuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpYW5zIHZhbHVlIGluIHJhZGlhbnNcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHZhbHVlIGluIGRlZ3JlZXNcbiAgICAgKi9cbiAgICByYWRpYW5zVG9EZWdyZWVzOiBmdW5jdGlvbihyYWRpYW5zKSB7XG4gICAgICByZXR1cm4gcmFkaWFucyAvIFBpQnkxODA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgYHBvaW50YCBhcm91bmQgYG9yaWdpbmAgd2l0aCBgcmFkaWFuc2BcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFRoZSBwb2ludCB0byByb3RhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gb3JpZ2luIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGlhbnMgVGhlIHJhZGlhbnMgb2YgdGhlIGFuZ2xlIGZvciB0aGUgcm90YXRpb25cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IFRoZSBuZXcgcm90YXRlZCBwb2ludFxuICAgICAqL1xuICAgIHJvdGF0ZVBvaW50OiBmdW5jdGlvbihwb2ludCwgb3JpZ2luLCByYWRpYW5zKSB7XG4gICAgICBwb2ludC5zdWJ0cmFjdEVxdWFscyhvcmlnaW4pO1xuICAgICAgdmFyIHYgPSBmYWJyaWMudXRpbC5yb3RhdGVWZWN0b3IocG9pbnQsIHJhZGlhbnMpO1xuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuUG9pbnQodi54LCB2LnkpLmFkZEVxdWFscyhvcmlnaW4pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIGB2ZWN0b3JgIHdpdGggYHJhZGlhbnNgXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZWN0b3IgVGhlIHZlY3RvciB0byByb3RhdGUgKHggYW5kIHkpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGlhbnMgVGhlIHJhZGlhbnMgb2YgdGhlIGFuZ2xlIGZvciB0aGUgcm90YXRpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgcm90YXRlZCBwb2ludFxuICAgICAqL1xuICAgIHJvdGF0ZVZlY3RvcjogZnVuY3Rpb24odmVjdG9yLCByYWRpYW5zKSB7XG4gICAgICB2YXIgc2luID0gTWF0aC5zaW4ocmFkaWFucyksXG4gICAgICAgICAgY29zID0gTWF0aC5jb3MocmFkaWFucyksXG4gICAgICAgICAgcnggPSB2ZWN0b3IueCAqIGNvcyAtIHZlY3Rvci55ICogc2luLFxuICAgICAgICAgIHJ5ID0gdmVjdG9yLnggKiBzaW4gKyB2ZWN0b3IueSAqIGNvcztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJ4LFxuICAgICAgICB5OiByeVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdHJhbnNmb3JtIHQgdG8gcG9pbnQgcFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0gIHtmYWJyaWMuUG9pbnR9IHAgVGhlIHBvaW50IHRvIHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSAge0FycmF5fSB0IFRoZSB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbaWdub3JlT2Zmc2V0XSBJbmRpY2F0ZXMgdGhhdCB0aGUgb2Zmc2V0IHNob3VsZCBub3QgYmUgYXBwbGllZFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gVGhlIHRyYW5zZm9ybWVkIHBvaW50XG4gICAgICovXG4gICAgdHJhbnNmb3JtUG9pbnQ6IGZ1bmN0aW9uKHAsIHQsIGlnbm9yZU9mZnNldCkge1xuICAgICAgaWYgKGlnbm9yZU9mZnNldCkge1xuICAgICAgICByZXR1cm4gbmV3IGZhYnJpYy5Qb2ludChcbiAgICAgICAgICB0WzBdICogcC54ICsgdFsyXSAqIHAueSxcbiAgICAgICAgICB0WzFdICogcC54ICsgdFszXSAqIHAueVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuUG9pbnQoXG4gICAgICAgIHRbMF0gKiBwLnggKyB0WzJdICogcC55ICsgdFs0XSxcbiAgICAgICAgdFsxXSAqIHAueCArIHRbM10gKiBwLnkgKyB0WzVdXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvb3JkaW5hdGVzIG9mIHBvaW50cydzIGJvdW5kaW5nIHJlY3RhbmdsZSAobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyA0IHBvaW50cyBhcnJheVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHdpdGggbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBtYWtlQm91bmRpbmdCb3hGcm9tUG9pbnRzOiBmdW5jdGlvbihwb2ludHMpIHtcbiAgICAgIHZhciB4UG9pbnRzID0gW3BvaW50c1swXS54LCBwb2ludHNbMV0ueCwgcG9pbnRzWzJdLngsIHBvaW50c1szXS54XSxcbiAgICAgICAgICBtaW5YID0gZmFicmljLnV0aWwuYXJyYXkubWluKHhQb2ludHMpLFxuICAgICAgICAgIG1heFggPSBmYWJyaWMudXRpbC5hcnJheS5tYXgoeFBvaW50cyksXG4gICAgICAgICAgd2lkdGggPSBNYXRoLmFicyhtaW5YIC0gbWF4WCksXG4gICAgICAgICAgeVBvaW50cyA9IFtwb2ludHNbMF0ueSwgcG9pbnRzWzFdLnksIHBvaW50c1syXS55LCBwb2ludHNbM10ueV0sXG4gICAgICAgICAgbWluWSA9IGZhYnJpYy51dGlsLmFycmF5Lm1pbih5UG9pbnRzKSxcbiAgICAgICAgICBtYXhZID0gZmFicmljLnV0aWwuYXJyYXkubWF4KHlQb2ludHMpLFxuICAgICAgICAgIGhlaWdodCA9IE1hdGguYWJzKG1pblkgLSBtYXhZKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogbWluWCxcbiAgICAgICAgdG9wOiBtaW5ZLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnZlcnQgdHJhbnNmb3JtYXRpb24gdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0IFRoZSB0cmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGludmVydGVkIHRyYW5zZm9ybVxuICAgICAqL1xuICAgIGludmVydFRyYW5zZm9ybTogZnVuY3Rpb24odCkge1xuICAgICAgdmFyIGEgPSAxIC8gKHRbMF0gKiB0WzNdIC0gdFsxXSAqIHRbMl0pLFxuICAgICAgICAgIHIgPSBbYSAqIHRbM10sIC1hICogdFsxXSwgLWEgKiB0WzJdLCBhICogdFswXV0sXG4gICAgICAgICAgbyA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHsgeDogdFs0XSwgeTogdFs1XSB9LCByLCB0cnVlKTtcbiAgICAgIHJbNF0gPSAtby54O1xuICAgICAgcls1XSA9IC1vLnk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB3cmFwcGVyIGFyb3VuZCBOdW1iZXIjdG9GaXhlZCwgd2hpY2ggY29udHJhcnkgdG8gbmF0aXZlIG1ldGhvZCByZXR1cm5zIG51bWJlciwgbm90IHN0cmluZy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBudW1iZXIgbnVtYmVyIHRvIG9wZXJhdGUgb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZnJhY3Rpb25EaWdpdHMgbnVtYmVyIG9mIGZyYWN0aW9uIGRpZ2l0cyB0byBcImxlYXZlXCJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdG9GaXhlZDogZnVuY3Rpb24obnVtYmVyLCBmcmFjdGlvbkRpZ2l0cykge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoTnVtYmVyKG51bWJlcikudG9GaXhlZChmcmFjdGlvbkRpZ2l0cykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBmcm9tIGF0dHJpYnV0ZSB2YWx1ZSB0byBwaXhlbCB2YWx1ZSBpZiBhcHBsaWNhYmxlLlxuICAgICAqIFJldHVybnMgY29udmVydGVkIHBpeGVscyBvciBvcmlnaW5hbCB2YWx1ZSBub3QgY29udmVydGVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWUgbnVtYmVyIHRvIG9wZXJhdGUgb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZm9udFNpemVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfVxuICAgICAqL1xuICAgIHBhcnNlVW5pdDogZnVuY3Rpb24odmFsdWUsIGZvbnRTaXplKSB7XG4gICAgICB2YXIgdW5pdCA9IC9cXER7MCwyfSQvLmV4ZWModmFsdWUpLFxuICAgICAgICAgIG51bWJlciA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgaWYgKCFmb250U2l6ZSkge1xuICAgICAgICBmb250U2l6ZSA9IGZhYnJpYy5UZXh0LkRFRkFVTFRfU1ZHX0ZPTlRfU0laRTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodW5pdFswXSkge1xuICAgICAgICBjYXNlICdtbSc6XG4gICAgICAgICAgcmV0dXJuIG51bWJlciAqIGZhYnJpYy5EUEkgLyAyNS40O1xuXG4gICAgICAgIGNhc2UgJ2NtJzpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyICogZmFicmljLkRQSSAvIDIuNTQ7XG5cbiAgICAgICAgY2FzZSAnaW4nOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmYWJyaWMuRFBJO1xuXG4gICAgICAgIGNhc2UgJ3B0JzpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyICogZmFicmljLkRQSSAvIDcyOyAvLyBvciAqIDQgLyAzXG5cbiAgICAgICAgY2FzZSAncGMnOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmYWJyaWMuRFBJIC8gNzIgKiAxMjsgLy8gb3IgKiAxNlxuXG4gICAgICAgIGNhc2UgJ2VtJzpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyICogZm9udFNpemU7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB3aGljaCBhbHdheXMgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZhbHNlRnVuY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGtsYXNzIFwiQ2xhc3NcIiBvYmplY3Qgb2YgZ2l2ZW4gbmFtZXNwYWNlXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSBvZiBvYmplY3QgKGVnLiAnY2lyY2xlJylcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIE5hbWVzcGFjZSB0byBnZXQga2xhc3MgXCJDbGFzc1wiIG9iamVjdCBmcm9tXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBrbGFzcyBcIkNsYXNzXCJcbiAgICAgKi9cbiAgICBnZXRLbGFzczogZnVuY3Rpb24odHlwZSwgbmFtZXNwYWNlKSB7XG4gICAgICAvLyBjYXBpdGFsaXplIGZpcnN0IGxldHRlciBvbmx5XG4gICAgICB0eXBlID0gZmFicmljLnV0aWwuc3RyaW5nLmNhbWVsaXplKHR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0eXBlLnNsaWNlKDEpKTtcbiAgICAgIHJldHVybiBmYWJyaWMudXRpbC5yZXNvbHZlTmFtZXNwYWNlKG5hbWVzcGFjZSlbdHlwZV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IG9mIGdpdmVuIG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgTmFtZXNwYWNlIHN0cmluZyBlLmcuICdmYWJyaWMuSW1hZ2UuZmlsdGVyJyBvciAnZmFicmljJ1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IGZvciBnaXZlbiBuYW1lc3BhY2UgKGRlZmF1bHQgZmFicmljKVxuICAgICAqL1xuICAgIHJlc29sdmVOYW1lc3BhY2U6IGZ1bmN0aW9uKG5hbWVzcGFjZSkge1xuICAgICAgaWYgKCFuYW1lc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuIGZhYnJpYztcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcnRzID0gbmFtZXNwYWNlLnNwbGl0KCcuJyksXG4gICAgICAgICAgbGVuID0gcGFydHMubGVuZ3RoLCBpLFxuICAgICAgICAgIG9iaiA9IGdsb2JhbCB8fCBmYWJyaWMud2luZG93O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgb2JqID0gb2JqW3BhcnRzW2ldXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgaW1hZ2UgZWxlbWVudCBmcm9tIGdpdmVuIHVybCBhbmQgcGFzc2VzIGl0IHRvIGEgY2FsbGJhY2tcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFVSTCByZXByZXNlbnRpbmcgYW4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjazsgaW52b2tlZCB3aXRoIGxvYWRlZCBpbWFnZVxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdIENvbnRleHQgdG8gaW52b2tlIGNhbGxiYWNrIGluXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjcm9zc09yaWdpbl0gY3Jvc3NPcmlnaW4gdmFsdWUgdG8gc2V0IGltYWdlIGVsZW1lbnQgdG9cbiAgICAgKi9cbiAgICBsb2FkSW1hZ2U6IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2ssIGNvbnRleHQsIGNyb3NzT3JpZ2luKSB7XG4gICAgICBpZiAoIXVybCkge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGNvbnRleHQsIHVybCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGltZyA9IGZhYnJpYy51dGlsLmNyZWF0ZUltYWdlKCk7XG5cbiAgICAgIC8qKiBAaWdub3JlICovXG4gICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGltZyk7XG4gICAgICAgIGltZyA9IGltZy5vbmxvYWQgPSBpbWcub25lcnJvciA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICAvKiogQGlnbm9yZSAqL1xuICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZmFicmljLmxvZygnRXJyb3IgbG9hZGluZyAnICsgaW1nLnNyYyk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgIGltZyA9IGltZy5vbmxvYWQgPSBpbWcub25lcnJvciA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICAvLyBkYXRhLXVybHMgYXBwZWFyIHRvIGJlIGJ1Z2d5IHdpdGggY3Jvc3NPcmlnaW5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9rYW5nYXgvZmFicmljLmpzL2NvbW1pdC9kMGFiYjkwZjFjZDVjNWVmOWQyYTk0ZDNmYjIxYTIyMzMwZGEzZTBhI2NvbW1pdGNvbW1lbnQtNDUxMzc2N1xuICAgICAgLy8gc2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zMTUxNTJcbiAgICAgIC8vICAgICBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD05MzUwNjlcbiAgICAgIGlmICh1cmwuaW5kZXhPZignZGF0YScpICE9PSAwICYmIGNyb3NzT3JpZ2luKSB7XG4gICAgICAgIGltZy5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuICAgICAgfVxuXG4gICAgICBpbWcuc3JjID0gdXJsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGNvcnJlc3BvbmRpbmcgZmFicmljIGluc3RhbmNlcyBmcm9tIHRoZWlyIG9iamVjdCByZXByZXNlbnRhdGlvbnNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqZWN0cyBPYmplY3RzIHRvIGVubGl2ZW5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbGwgb2JqZWN0cyBhcmUgY3JlYXRlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgTmFtZXNwYWNlIHRvIGdldCBrbGFzcyBcIkNsYXNzXCIgb2JqZWN0IGZyb21cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXZpdmVyIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIG9iamVjdCBlbGVtZW50cyxcbiAgICAgKiBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAgICovXG4gICAgZW5saXZlbk9iamVjdHM6IGZ1bmN0aW9uKG9iamVjdHMsIGNhbGxiYWNrLCBuYW1lc3BhY2UsIHJldml2ZXIpIHtcbiAgICAgIG9iamVjdHMgPSBvYmplY3RzIHx8IFtdO1xuXG4gICAgICBmdW5jdGlvbiBvbkxvYWRlZCgpIHtcbiAgICAgICAgaWYgKCsrbnVtTG9hZGVkT2JqZWN0cyA9PT0gbnVtVG90YWxPYmplY3RzKSB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZW5saXZlbmVkT2JqZWN0cyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGVubGl2ZW5lZE9iamVjdHMgPSBbXSxcbiAgICAgICAgICBudW1Mb2FkZWRPYmplY3RzID0gMCxcbiAgICAgICAgICBudW1Ub3RhbE9iamVjdHMgPSBvYmplY3RzLmxlbmd0aDtcblxuICAgICAgaWYgKCFudW1Ub3RhbE9iamVjdHMpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZW5saXZlbmVkT2JqZWN0cyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChvLCBpbmRleCkge1xuICAgICAgICAvLyBpZiBzcGFyc2UgYXJyYXlcbiAgICAgICAgaWYgKCFvIHx8ICFvLnR5cGUpIHtcbiAgICAgICAgICBvbkxvYWRlZCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2xhc3MgPSBmYWJyaWMudXRpbC5nZXRLbGFzcyhvLnR5cGUsIG5hbWVzcGFjZSk7XG4gICAgICAgIGlmIChrbGFzcy5hc3luYykge1xuICAgICAgICAgIGtsYXNzLmZyb21PYmplY3QobywgZnVuY3Rpb24gKG9iaiwgZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgZW5saXZlbmVkT2JqZWN0c1tpbmRleF0gPSBvYmo7XG4gICAgICAgICAgICAgIHJldml2ZXIgJiYgcmV2aXZlcihvLCBlbmxpdmVuZWRPYmplY3RzW2luZGV4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbkxvYWRlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGVubGl2ZW5lZE9iamVjdHNbaW5kZXhdID0ga2xhc3MuZnJvbU9iamVjdChvKTtcbiAgICAgICAgICByZXZpdmVyICYmIHJldml2ZXIobywgZW5saXZlbmVkT2JqZWN0c1tpbmRleF0pO1xuICAgICAgICAgIG9uTG9hZGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHcm91cHMgU1ZHIGVsZW1lbnRzICh1c3VhbGx5IHRob3NlIHJldHJpZXZlZCBmcm9tIFNWRyBkb2N1bWVudClcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gZWxlbWVudHMgU1ZHIGVsZW1lbnRzIHRvIGdyb3VwXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFZhbHVlIHRvIHNldCBzb3VyY2VQYXRoIHRvXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdHxmYWJyaWMuUGF0aEdyb3VwfVxuICAgICAqL1xuICAgIGdyb3VwU1ZHRWxlbWVudHM6IGZ1bmN0aW9uKGVsZW1lbnRzLCBvcHRpb25zLCBwYXRoKSB7XG4gICAgICB2YXIgb2JqZWN0O1xuXG4gICAgICBvYmplY3QgPSBuZXcgZmFicmljLlBhdGhHcm91cChlbGVtZW50cywgb3B0aW9ucyk7XG5cbiAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb2JqZWN0LnNldFNvdXJjZVBhdGgocGF0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQb3B1bGF0ZXMgYW4gb2JqZWN0IHdpdGggcHJvcGVydGllcyBvZiBhbm90aGVyIG9iamVjdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFNvdXJjZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVzdGluYXRpb24gRGVzdGluYXRpb24gb2JqZWN0XG4gICAgICogQHJldHVybiB7QXJyYXl9IHByb3BlcnRpZXMgUHJvcGVydGllIG5hbWVzIHRvIGluY2x1ZGVcbiAgICAgKi9cbiAgICBwb3B1bGF0ZVdpdGhQcm9wZXJ0aWVzOiBmdW5jdGlvbihzb3VyY2UsIGRlc3RpbmF0aW9uLCBwcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAocHJvcGVydGllcyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJvcGVydGllcykgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAocHJvcGVydGllc1tpXSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnRpZXNbaV1dID0gc291cmNlW3Byb3BlcnRpZXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIGRhc2hlZCBsaW5lIGJldHdlZW4gdHdvIHBvaW50c1xuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBkcmF3IGRhc2hlZCBsaW5lIGFyb3VuZCBzZWxlY3Rpb24gYXJlYS5cbiAgICAgKiBTZWUgPGEgaHJlZj1cImh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDU3NjcyNC9kb3R0ZWQtc3Ryb2tlLWluLWNhbnZhc1wiPmRvdHRlZCBzdHJva2UgaW4gY2FudmFzPC9hPlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggIHN0YXJ0IHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHN0YXJ0IHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4MiBlbmQgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkyIGVuZCB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYSBkYXNoIGFycmF5IHBhdHRlcm5cbiAgICAgKi9cbiAgICBkcmF3RGFzaGVkTGluZTogZnVuY3Rpb24oY3R4LCB4LCB5LCB4MiwgeTIsIGRhKSB7XG4gICAgICB2YXIgZHggPSB4MiAtIHgsXG4gICAgICAgICAgZHkgPSB5MiAtIHksXG4gICAgICAgICAgbGVuID0gc3FydChkeCAqIGR4ICsgZHkgKiBkeSksXG4gICAgICAgICAgcm90ID0gYXRhbjIoZHksIGR4KSxcbiAgICAgICAgICBkYyA9IGRhLmxlbmd0aCxcbiAgICAgICAgICBkaSA9IDAsXG4gICAgICAgICAgZHJhdyA9IHRydWU7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgY3R4Lm1vdmVUbygwLCAwKTtcbiAgICAgIGN0eC5yb3RhdGUocm90KTtcblxuICAgICAgeCA9IDA7XG4gICAgICB3aGlsZSAobGVuID4geCkge1xuICAgICAgICB4ICs9IGRhW2RpKysgJSBkY107XG4gICAgICAgIGlmICh4ID4gbGVuKSB7XG4gICAgICAgICAgeCA9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBjdHhbZHJhdyA/ICdsaW5lVG8nIDogJ21vdmVUbyddKHgsIDApO1xuICAgICAgICBkcmF3ID0gIWRyYXc7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgY2FudmFzIGVsZW1lbnQgYW5kIGluaXRpYWxpemVzIGl0IHZpYSBleGNhbnZhcyBpZiBuZWNlc3NhcnlcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtDYW52YXNFbGVtZW50fSBbY2FudmFzRWxdIG9wdGlvbmFsIGNhbnZhcyBlbGVtZW50IHRvIGluaXRpYWxpemU7XG4gICAgICogd2hlbiBub3QgZ2l2ZW4sIGVsZW1lbnQgaXMgY3JlYXRlZCBpbXBsaWNpdGx5XG4gICAgICogQHJldHVybiB7Q2FudmFzRWxlbWVudH0gaW5pdGlhbGl6ZWQgY2FudmFzIGVsZW1lbnRcbiAgICAgKi9cbiAgICBjcmVhdGVDYW52YXNFbGVtZW50OiBmdW5jdGlvbihjYW52YXNFbCkge1xuICAgICAgY2FudmFzRWwgfHwgKGNhbnZhc0VsID0gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpKTtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICAgICAgaWYgKCFjYW52YXNFbC5nZXRDb250ZXh0ICYmIHR5cGVvZiBHX3ZtbENhbnZhc01hbmFnZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIEdfdm1sQ2FudmFzTWFuYWdlci5pbml0RWxlbWVudChjYW52YXNFbCk7XG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuICAgICAgcmV0dXJuIGNhbnZhc0VsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGltYWdlIGVsZW1lbnQgKHdvcmtzIG9uIGNsaWVudCBhbmQgbm9kZSlcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gSFRNTCBpbWFnZSBlbGVtZW50XG4gICAgICovXG4gICAgY3JlYXRlSW1hZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhYnJpYy5pc0xpa2VseU5vZGVcbiAgICAgICAgPyBuZXcgKHJlcXVpcmUoJ2NhbnZhcycpLkltYWdlKSgpXG4gICAgICAgIDogZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFjY2Vzc29ycyAoZ2V0WFhYLCBzZXRYWFgpIGZvciBhIFwiY2xhc3NcIiwgYmFzZWQgb24gXCJzdGF0ZVByb3BlcnRpZXNcIiBhcnJheVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0ga2xhc3MgXCJDbGFzc1wiIHRvIGNyZWF0ZSBhY2Nlc3NvcnMgZm9yXG4gICAgICovXG4gICAgY3JlYXRlQWNjZXNzb3JzOiBmdW5jdGlvbihrbGFzcykge1xuICAgICAgdmFyIHByb3RvID0ga2xhc3MucHJvdG90eXBlLCBpLCBwcm9wTmFtZSxcbiAgICAgICAgICBjYXBpdGFsaXplZFByb3BOYW1lLCBzZXR0ZXJOYW1lLCBnZXR0ZXJOYW1lO1xuXG4gICAgICBmb3IgKGkgPSBwcm90by5zdGF0ZVByb3BlcnRpZXMubGVuZ3RoOyBpLS07ICkge1xuXG4gICAgICAgIHByb3BOYW1lID0gcHJvdG8uc3RhdGVQcm9wZXJ0aWVzW2ldO1xuICAgICAgICBjYXBpdGFsaXplZFByb3BOYW1lID0gcHJvcE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wTmFtZS5zbGljZSgxKTtcbiAgICAgICAgc2V0dGVyTmFtZSA9ICdzZXQnICsgY2FwaXRhbGl6ZWRQcm9wTmFtZTtcbiAgICAgICAgZ2V0dGVyTmFtZSA9ICdnZXQnICsgY2FwaXRhbGl6ZWRQcm9wTmFtZTtcblxuICAgICAgICAvLyB1c2luZyBgbmV3IEZ1bmN0aW9uYCBmb3IgYmV0dGVyIGludHJvc3BlY3Rpb25cbiAgICAgICAgaWYgKCFwcm90b1tnZXR0ZXJOYW1lXSkge1xuICAgICAgICAgIHByb3RvW2dldHRlck5hbWVdID0gKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcy5nZXQoXCInICsgcHJvcGVydHkgKyAnXCIpJyk7XG4gICAgICAgICAgfSkocHJvcE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJvdG9bc2V0dGVyTmFtZV0pIHtcbiAgICAgICAgICBwcm90b1tzZXR0ZXJOYW1lXSA9IChmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbigndmFsdWUnLCAncmV0dXJuIHRoaXMuc2V0KFwiJyArIHByb3BlcnR5ICsgJ1wiLCB2YWx1ZSknKTtcbiAgICAgICAgICB9KShwcm9wTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gcmVjZWl2ZXIgT2JqZWN0IGltcGxlbWVudGluZyBgY2xpcFRvYCBtZXRob2RcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gY2xpcFxuICAgICAqL1xuICAgIGNsaXBDb250ZXh0OiBmdW5jdGlvbihyZWNlaXZlciwgY3R4KSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgcmVjZWl2ZXIuY2xpcFRvKGN0eCk7XG4gICAgICBjdHguY2xpcCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBseSBtYXRyaXggQSBieSBtYXRyaXggQiB0byBuZXN0IHRyYW5zZm9ybWF0aW9uc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYSBGaXJzdCB0cmFuc2Zvcm1NYXRyaXhcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYiBTZWNvbmQgdHJhbnNmb3JtTWF0cml4XG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gaXMyeDIgZmxhZyB0byBtdWx0aXBseSBtYXRyaWNlcyBhcyAyeDIgbWF0cmljZXNcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIHByb2R1Y3Qgb2YgdGhlIHR3byB0cmFuc2Zvcm0gbWF0cmljZXNcbiAgICAgKi9cbiAgICBtdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzOiBmdW5jdGlvbihhLCBiLCBpczJ4Mikge1xuICAgICAgLy8gTWF0cml4IG11bHRpcGx5IGEgKiBiXG4gICAgICByZXR1cm4gW1xuICAgICAgICBhWzBdICogYlswXSArIGFbMl0gKiBiWzFdLFxuICAgICAgICBhWzFdICogYlswXSArIGFbM10gKiBiWzFdLFxuICAgICAgICBhWzBdICogYlsyXSArIGFbMl0gKiBiWzNdLFxuICAgICAgICBhWzFdICogYlsyXSArIGFbM10gKiBiWzNdLFxuICAgICAgICBpczJ4MiA/IDAgOiBhWzBdICogYls0XSArIGFbMl0gKiBiWzVdICsgYVs0XSxcbiAgICAgICAgaXMyeDIgPyAwIDogYVsxXSAqIGJbNF0gKyBhWzNdICogYls1XSArIGFbNV1cbiAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY29tcG9zZXMgc3RhbmRhcmQgMngyIG1hdHJpeCBpbnRvIHRyYW5zZm9ybSBjb21wb25lbnRlc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYSB0cmFuc2Zvcm1NYXRyaXhcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IENvbXBvbmVudHMgb2YgdHJhbnNmb3JtXG4gICAgICovXG4gICAgcXJEZWNvbXBvc2U6IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHZhciBhbmdsZSA9IGF0YW4yKGFbMV0sIGFbMF0pLFxuICAgICAgICAgIGRlbm9tID0gcG93KGFbMF0sIDIpICsgcG93KGFbMV0sIDIpLFxuICAgICAgICAgIHNjYWxlWCA9IHNxcnQoZGVub20pLFxuICAgICAgICAgIHNjYWxlWSA9IChhWzBdICogYVszXSAtIGFbMl0gKiBhIFsxXSkgLyBzY2FsZVgsXG4gICAgICAgICAgc2tld1ggPSBhdGFuMihhWzBdICogYVsyXSArIGFbMV0gKiBhIFszXSwgZGVub20pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYW5nbGU6IGFuZ2xlICAvIFBpQnkxODAsXG4gICAgICAgIHNjYWxlWDogc2NhbGVYLFxuICAgICAgICBzY2FsZVk6IHNjYWxlWSxcbiAgICAgICAgc2tld1g6IHNrZXdYIC8gUGlCeTE4MCxcbiAgICAgICAgc2tld1k6IDAsXG4gICAgICAgIHRyYW5zbGF0ZVg6IGFbNF0sXG4gICAgICAgIHRyYW5zbGF0ZVk6IGFbNV1cbiAgICAgIH07XG4gICAgfSxcblxuICAgIGN1c3RvbVRyYW5zZm9ybU1hdHJpeDogZnVuY3Rpb24oc2NhbGVYLCBzY2FsZVksIHNrZXdYKSB7XG4gICAgICB2YXIgc2tld01hdHJpeFggPSBbMSwgMCwgYWJzKE1hdGgudGFuKHNrZXdYICogUGlCeTE4MCkpLCAxXSxcbiAgICAgICAgICBzY2FsZU1hdHJpeCA9IFthYnMoc2NhbGVYKSwgMCwgMCwgYWJzKHNjYWxlWSldO1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMoc2NhbGVNYXRyaXgsIHNrZXdNYXRyaXhYLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgcmVzZXRPYmplY3RUcmFuc2Zvcm06IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHRhcmdldC5zY2FsZVggPSAxO1xuICAgICAgdGFyZ2V0LnNjYWxlWSA9IDE7XG4gICAgICB0YXJnZXQuc2tld1ggPSAwO1xuICAgICAgdGFyZ2V0LnNrZXdZID0gMDtcbiAgICAgIHRhcmdldC5mbGlwWCA9IGZhbHNlO1xuICAgICAgdGFyZ2V0LmZsaXBZID0gZmFsc2U7XG4gICAgICB0YXJnZXQuc2V0QW5nbGUoMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGZ1bmN0aW9uIGJvZHlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBnZXQgYm9keSBvZlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gRnVuY3Rpb24gYm9keVxuICAgICAqL1xuICAgIGdldEZ1bmN0aW9uQm9keTogZnVuY3Rpb24oZm4pIHtcbiAgICAgIHJldHVybiAoU3RyaW5nKGZuKS5tYXRjaCgvZnVuY3Rpb25bXntdKlxceyhbXFxzXFxTXSopXFx9LykgfHwge30pWzFdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgY29udGV4dCBoYXMgdHJhbnNwYXJlbnQgcGl4ZWxcbiAgICAgKiBhdCBzcGVjaWZpZWQgbG9jYXRpb24gKHRha2luZyB0b2xlcmFuY2UgaW50byBhY2NvdW50KVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggY29udGV4dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b2xlcmFuY2UgVG9sZXJhbmNlXG4gICAgICovXG4gICAgaXNUcmFuc3BhcmVudDogZnVuY3Rpb24oY3R4LCB4LCB5LCB0b2xlcmFuY2UpIHtcblxuICAgICAgLy8gSWYgdG9sZXJhbmNlIGlzID4gMCBhZGp1c3Qgc3RhcnQgY29vcmRzIHRvIHRha2UgaW50byBhY2NvdW50LlxuICAgICAgLy8gSWYgbW92ZXMgb2ZmIENhbnZhcyBmaXggdG8gMFxuICAgICAgaWYgKHRvbGVyYW5jZSA+IDApIHtcbiAgICAgICAgaWYgKHggPiB0b2xlcmFuY2UpIHtcbiAgICAgICAgICB4IC09IHRvbGVyYW5jZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA+IHRvbGVyYW5jZSkge1xuICAgICAgICAgIHkgLT0gdG9sZXJhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHkgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXNUcmFuc3BhcmVudCA9IHRydWUsIGksIHRlbXAsXG4gICAgICAgICAgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSh4LCB5LCAodG9sZXJhbmNlICogMikgfHwgMSwgKHRvbGVyYW5jZSAqIDIpIHx8IDEpLFxuICAgICAgICAgIGwgPSBpbWFnZURhdGEuZGF0YS5sZW5ndGg7XG5cbiAgICAgIC8vIFNwbGl0IGltYWdlIGRhdGEgLSBmb3IgdG9sZXJhbmNlID4gMSwgcGl4ZWxEYXRhU2l6ZSA9IDQ7XG4gICAgICBmb3IgKGkgPSAzOyBpIDwgbDsgaSArPSA0KSB7XG4gICAgICAgIHRlbXAgPSBpbWFnZURhdGEuZGF0YVtpXTtcbiAgICAgICAgX2lzVHJhbnNwYXJlbnQgPSB0ZW1wIDw9IDA7XG4gICAgICAgIGlmIChfaXNUcmFuc3BhcmVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhazsgLy8gU3RvcCBpZiBjb2xvdXIgZm91bmRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbWFnZURhdGEgPSBudWxsO1xuXG4gICAgICByZXR1cm4gX2lzVHJhbnNwYXJlbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHByZXNlcnZlQXNwZWN0UmF0aW8gYXR0cmlidXRlIGZyb20gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgdG8gYmUgcGFyc2VkXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBhbiBvYmplY3QgY29udGFpbmluZyBhbGlnbiBhbmQgbWVldE9yU2xpY2UgYXR0cmlidXRlXG4gICAgICovXG4gICAgcGFyc2VQcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0cmlidXRlOiBmdW5jdGlvbihhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBtZWV0T3JTbGljZSA9ICdtZWV0JywgYWxpZ25YID0gJ01pZCcsIGFsaWduWSA9ICdNaWQnLFxuICAgICAgICAgIGFzcGVjdFJhdGlvQXR0cnMgPSBhdHRyaWJ1dGUuc3BsaXQoJyAnKSwgYWxpZ247XG5cbiAgICAgIGlmIChhc3BlY3RSYXRpb0F0dHJzICYmIGFzcGVjdFJhdGlvQXR0cnMubGVuZ3RoKSB7XG4gICAgICAgIG1lZXRPclNsaWNlID0gYXNwZWN0UmF0aW9BdHRycy5wb3AoKTtcbiAgICAgICAgaWYgKG1lZXRPclNsaWNlICE9PSAnbWVldCcgJiYgbWVldE9yU2xpY2UgIT09ICdzbGljZScpIHtcbiAgICAgICAgICBhbGlnbiA9IG1lZXRPclNsaWNlO1xuICAgICAgICAgIG1lZXRPclNsaWNlID0gJ21lZXQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzcGVjdFJhdGlvQXR0cnMubGVuZ3RoKSB7XG4gICAgICAgICAgYWxpZ24gPSBhc3BlY3RSYXRpb0F0dHJzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL2RpdmlkZSBhbGlnbiBpbiBhbGlnblggYW5kIGFsaWduWVxuICAgICAgYWxpZ25YID0gYWxpZ24gIT09ICdub25lJyA/IGFsaWduLnNsaWNlKDEsIDQpIDogJ25vbmUnO1xuICAgICAgYWxpZ25ZID0gYWxpZ24gIT09ICdub25lJyA/IGFsaWduLnNsaWNlKDUsIDgpIDogJ25vbmUnO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWVldE9yU2xpY2U6IG1lZXRPclNsaWNlLFxuICAgICAgICBhbGlnblg6IGFsaWduWCxcbiAgICAgICAgYWxpZ25ZOiBhbGlnbllcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFyIGNoYXIgd2lkdGhzIGNhY2hlIGZvciBhIGZvbnQgZmFtaWx5LlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZm9udEZhbWlseV0gZm9udCBmYW1pbHkgdG8gY2xlYXJcbiAgICAgKi9cbiAgICBjbGVhckZhYnJpY0ZvbnRDYWNoZTogZnVuY3Rpb24oZm9udEZhbWlseSkge1xuICAgICAgaWYgKCFmb250RmFtaWx5KSB7XG4gICAgICAgIGZhYnJpYy5jaGFyV2lkdGhzQ2FjaGUgPSB7IH07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmYWJyaWMuY2hhcldpZHRoc0NhY2hlW2ZvbnRGYW1pbHldKSB7XG4gICAgICAgIGRlbGV0ZSBmYWJyaWMuY2hhcldpZHRoc0NhY2hlW2ZvbnRGYW1pbHldO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgYXJjVG9TZWdtZW50c0NhY2hlID0geyB9LFxuICAgICAgc2VnbWVudFRvQmV6aWVyQ2FjaGUgPSB7IH0sXG4gICAgICBib3VuZHNPZkN1cnZlQ2FjaGUgPSB7IH0sXG4gICAgICBfam9pbiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xuXG4gIC8qIEFkYXB0ZWQgZnJvbSBodHRwOi8vZHhyLm1vemlsbGEub3JnL21vemlsbGEtY2VudHJhbC9zb3VyY2UvY29udGVudC9zdmcvY29udGVudC9zcmMvbnNTVkdQYXRoRGF0YVBhcnNlci5jcHBcbiAgICogYnkgQW5kcmVhIEJvZ2F6emkgY29kZSBpcyB1bmRlciBNUEwuIGlmIHlvdSBkb24ndCBoYXZlIGEgY29weSBvZiB0aGUgbGljZW5zZSB5b3UgY2FuIHRha2UgaXQgaGVyZVxuICAgKiBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC9cbiAgICovXG4gIGZ1bmN0aW9uIGFyY1RvU2VnbWVudHModG9YLCB0b1ksIHJ4LCByeSwgbGFyZ2UsIHN3ZWVwLCByb3RhdGVYKSB7XG4gICAgdmFyIGFyZ3NTdHJpbmcgPSBfam9pbi5jYWxsKGFyZ3VtZW50cyk7XG4gICAgaWYgKGFyY1RvU2VnbWVudHNDYWNoZVthcmdzU3RyaW5nXSkge1xuICAgICAgcmV0dXJuIGFyY1RvU2VnbWVudHNDYWNoZVthcmdzU3RyaW5nXTtcbiAgICB9XG5cbiAgICB2YXIgUEkgPSBNYXRoLlBJLCB0aCA9IHJvdGF0ZVggKiBQSSAvIDE4MCxcbiAgICAgICAgc2luVGggPSBNYXRoLnNpbih0aCksXG4gICAgICAgIGNvc1RoID0gTWF0aC5jb3ModGgpLFxuICAgICAgICBmcm9tWCA9IDAsIGZyb21ZID0gMDtcblxuICAgIHJ4ID0gTWF0aC5hYnMocngpO1xuICAgIHJ5ID0gTWF0aC5hYnMocnkpO1xuXG4gICAgdmFyIHB4ID0gLWNvc1RoICogdG9YICogMC41IC0gc2luVGggKiB0b1kgKiAwLjUsXG4gICAgICAgIHB5ID0gLWNvc1RoICogdG9ZICogMC41ICsgc2luVGggKiB0b1ggKiAwLjUsXG4gICAgICAgIHJ4MiA9IHJ4ICogcngsIHJ5MiA9IHJ5ICogcnksIHB5MiA9IHB5ICogcHksIHB4MiA9IHB4ICogcHgsXG4gICAgICAgIHBsID0gcngyICogcnkyIC0gcngyICogcHkyIC0gcnkyICogcHgyLFxuICAgICAgICByb290ID0gMDtcblxuICAgIGlmIChwbCA8IDApIHtcbiAgICAgIHZhciBzID0gTWF0aC5zcXJ0KDEgLSBwbCAvIChyeDIgKiByeTIpKTtcbiAgICAgIHJ4ICo9IHM7XG4gICAgICByeSAqPSBzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJvb3QgPSAobGFyZ2UgPT09IHN3ZWVwID8gLTEuMCA6IDEuMCkgKlxuICAgICAgICAgICAgICBNYXRoLnNxcnQoIHBsIC8gKHJ4MiAqIHB5MiArIHJ5MiAqIHB4MikpO1xuICAgIH1cblxuICAgIHZhciBjeCA9IHJvb3QgKiByeCAqIHB5IC8gcnksXG4gICAgICAgIGN5ID0gLXJvb3QgKiByeSAqIHB4IC8gcngsXG4gICAgICAgIGN4MSA9IGNvc1RoICogY3ggLSBzaW5UaCAqIGN5ICsgdG9YICogMC41LFxuICAgICAgICBjeTEgPSBzaW5UaCAqIGN4ICsgY29zVGggKiBjeSArIHRvWSAqIDAuNSxcbiAgICAgICAgbVRoZXRhID0gY2FsY1ZlY3RvckFuZ2xlKDEsIDAsIChweCAtIGN4KSAvIHJ4LCAocHkgLSBjeSkgLyByeSksXG4gICAgICAgIGR0aGV0YSA9IGNhbGNWZWN0b3JBbmdsZSgocHggLSBjeCkgLyByeCwgKHB5IC0gY3kpIC8gcnksICgtcHggLSBjeCkgLyByeCwgKC1weSAtIGN5KSAvIHJ5KTtcblxuICAgIGlmIChzd2VlcCA9PT0gMCAmJiBkdGhldGEgPiAwKSB7XG4gICAgICBkdGhldGEgLT0gMiAqIFBJO1xuICAgIH1cbiAgICBlbHNlIGlmIChzd2VlcCA9PT0gMSAmJiBkdGhldGEgPCAwKSB7XG4gICAgICBkdGhldGEgKz0gMiAqIFBJO1xuICAgIH1cblxuICAgIC8vIENvbnZlcnQgaW50byBjdWJpYyBiZXppZXIgc2VnbWVudHMgPD0gOTBkZWdcbiAgICB2YXIgc2VnbWVudHMgPSBNYXRoLmNlaWwoTWF0aC5hYnMoZHRoZXRhIC8gUEkgKiAyKSksXG4gICAgICAgIHJlc3VsdCA9IFtdLCBtRGVsdGEgPSBkdGhldGEgLyBzZWdtZW50cyxcbiAgICAgICAgbVQgPSA4IC8gMyAqIE1hdGguc2luKG1EZWx0YSAvIDQpICogTWF0aC5zaW4obURlbHRhIC8gNCkgLyBNYXRoLnNpbihtRGVsdGEgLyAyKSxcbiAgICAgICAgdGgzID0gbVRoZXRhICsgbURlbHRhO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50czsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBzZWdtZW50VG9CZXppZXIobVRoZXRhLCB0aDMsIGNvc1RoLCBzaW5UaCwgcngsIHJ5LCBjeDEsIGN5MSwgbVQsIGZyb21YLCBmcm9tWSk7XG4gICAgICBmcm9tWCA9IHJlc3VsdFtpXVs0XTtcbiAgICAgIGZyb21ZID0gcmVzdWx0W2ldWzVdO1xuICAgICAgbVRoZXRhID0gdGgzO1xuICAgICAgdGgzICs9IG1EZWx0YTtcbiAgICB9XG4gICAgYXJjVG9TZWdtZW50c0NhY2hlW2FyZ3NTdHJpbmddID0gcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzZWdtZW50VG9CZXppZXIodGgyLCB0aDMsIGNvc1RoLCBzaW5UaCwgcngsIHJ5LCBjeDEsIGN5MSwgbVQsIGZyb21YLCBmcm9tWSkge1xuICAgIHZhciBhcmdzU3RyaW5nMiA9IF9qb2luLmNhbGwoYXJndW1lbnRzKTtcbiAgICBpZiAoc2VnbWVudFRvQmV6aWVyQ2FjaGVbYXJnc1N0cmluZzJdKSB7XG4gICAgICByZXR1cm4gc2VnbWVudFRvQmV6aWVyQ2FjaGVbYXJnc1N0cmluZzJdO1xuICAgIH1cblxuICAgIHZhciBjb3N0aDIgPSBNYXRoLmNvcyh0aDIpLFxuICAgICAgICBzaW50aDIgPSBNYXRoLnNpbih0aDIpLFxuICAgICAgICBjb3N0aDMgPSBNYXRoLmNvcyh0aDMpLFxuICAgICAgICBzaW50aDMgPSBNYXRoLnNpbih0aDMpLFxuICAgICAgICB0b1ggPSBjb3NUaCAqIHJ4ICogY29zdGgzIC0gc2luVGggKiByeSAqIHNpbnRoMyArIGN4MSxcbiAgICAgICAgdG9ZID0gc2luVGggKiByeCAqIGNvc3RoMyArIGNvc1RoICogcnkgKiBzaW50aDMgKyBjeTEsXG4gICAgICAgIGNwMVggPSBmcm9tWCArIG1UICogKCAtY29zVGggKiByeCAqIHNpbnRoMiAtIHNpblRoICogcnkgKiBjb3N0aDIpLFxuICAgICAgICBjcDFZID0gZnJvbVkgKyBtVCAqICggLXNpblRoICogcnggKiBzaW50aDIgKyBjb3NUaCAqIHJ5ICogY29zdGgyKSxcbiAgICAgICAgY3AyWCA9IHRvWCArIG1UICogKCBjb3NUaCAqIHJ4ICogc2ludGgzICsgc2luVGggKiByeSAqIGNvc3RoMyksXG4gICAgICAgIGNwMlkgPSB0b1kgKyBtVCAqICggc2luVGggKiByeCAqIHNpbnRoMyAtIGNvc1RoICogcnkgKiBjb3N0aDMpO1xuXG4gICAgc2VnbWVudFRvQmV6aWVyQ2FjaGVbYXJnc1N0cmluZzJdID0gW1xuICAgICAgY3AxWCwgY3AxWSxcbiAgICAgIGNwMlgsIGNwMlksXG4gICAgICB0b1gsIHRvWVxuICAgIF07XG4gICAgcmV0dXJuIHNlZ21lbnRUb0JlemllckNhY2hlW2FyZ3NTdHJpbmcyXTtcbiAgfVxuXG4gIC8qXG4gICAqIFByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNhbGNWZWN0b3JBbmdsZSh1eCwgdXksIHZ4LCB2eSkge1xuICAgIHZhciB0YSA9IE1hdGguYXRhbjIodXksIHV4KSxcbiAgICAgICAgdGIgPSBNYXRoLmF0YW4yKHZ5LCB2eCk7XG4gICAgaWYgKHRiID49IHRhKSB7XG4gICAgICByZXR1cm4gdGIgLSB0YTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gMiAqIE1hdGguUEkgLSAodGEgLSB0Yik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERyYXdzIGFyY1xuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmeFxuICAgKiBAcGFyYW0ge051bWJlcn0gZnlcbiAgICogQHBhcmFtIHtBcnJheX0gY29vcmRzXG4gICAqL1xuICBmYWJyaWMudXRpbC5kcmF3QXJjID0gZnVuY3Rpb24oY3R4LCBmeCwgZnksIGNvb3Jkcykge1xuICAgIHZhciByeCA9IGNvb3Jkc1swXSxcbiAgICAgICAgcnkgPSBjb29yZHNbMV0sXG4gICAgICAgIHJvdCA9IGNvb3Jkc1syXSxcbiAgICAgICAgbGFyZ2UgPSBjb29yZHNbM10sXG4gICAgICAgIHN3ZWVwID0gY29vcmRzWzRdLFxuICAgICAgICB0eCA9IGNvb3Jkc1s1XSxcbiAgICAgICAgdHkgPSBjb29yZHNbNl0sXG4gICAgICAgIHNlZ3MgPSBbW10sIFtdLCBbXSwgW11dLFxuICAgICAgICBzZWdzTm9ybSA9IGFyY1RvU2VnbWVudHModHggLSBmeCwgdHkgLSBmeSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2Vnc05vcm0ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNlZ3NbaV1bMF0gPSBzZWdzTm9ybVtpXVswXSArIGZ4O1xuICAgICAgc2Vnc1tpXVsxXSA9IHNlZ3NOb3JtW2ldWzFdICsgZnk7XG4gICAgICBzZWdzW2ldWzJdID0gc2Vnc05vcm1baV1bMl0gKyBmeDtcbiAgICAgIHNlZ3NbaV1bM10gPSBzZWdzTm9ybVtpXVszXSArIGZ5O1xuICAgICAgc2Vnc1tpXVs0XSA9IHNlZ3NOb3JtW2ldWzRdICsgZng7XG4gICAgICBzZWdzW2ldWzVdID0gc2Vnc05vcm1baV1bNV0gKyBmeTtcbiAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvLmFwcGx5KGN0eCwgc2Vnc1tpXSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgYm91bmRpbmcgYm94IG9mIGEgZWxsaXB0aWMtYXJjXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmeCBzdGFydCBwb2ludCBvZiBhcmNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZ5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSByeCBob3Jpem9udGFsIHJhZGl1c1xuICAgKiBAcGFyYW0ge051bWJlcn0gcnkgdmVydGljYWwgcmFkaXVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByb3QgYW5nbGUgb2YgaG9yaXpvbnRhbCBheGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxhcmdlIDEgb3IgMCwgd2hhdGV2ZXIgdGhlIGFyYyBpcyB0aGUgYmlnIG9yIHRoZSBzbWFsbCBvbiB0aGUgMiBwb2ludHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN3ZWVwIDEgb3IgMCwgMSBjbG9ja3dpc2Ugb3IgY291bnRlcmNsb2Nrd2lzZSBkaXJlY3Rpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHR4IGVuZCBwb2ludCBvZiBhcmNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHR5XG4gICAqL1xuICBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkFyYyA9IGZ1bmN0aW9uKGZ4LCBmeSwgcngsIHJ5LCByb3QsIGxhcmdlLCBzd2VlcCwgdHgsIHR5KSB7XG5cbiAgICB2YXIgZnJvbVggPSAwLCBmcm9tWSA9IDAsIGJvdW5kLCBib3VuZHMgPSBbXSxcbiAgICAgICAgc2VncyA9IGFyY1RvU2VnbWVudHModHggLSBmeCwgdHkgLSBmeSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2Vncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYm91bmQgPSBnZXRCb3VuZHNPZkN1cnZlKGZyb21YLCBmcm9tWSwgc2Vnc1tpXVswXSwgc2Vnc1tpXVsxXSwgc2Vnc1tpXVsyXSwgc2Vnc1tpXVszXSwgc2Vnc1tpXVs0XSwgc2Vnc1tpXVs1XSk7XG4gICAgICBib3VuZHMucHVzaCh7IHg6IGJvdW5kWzBdLnggKyBmeCwgeTogYm91bmRbMF0ueSArIGZ5IH0pO1xuICAgICAgYm91bmRzLnB1c2goeyB4OiBib3VuZFsxXS54ICsgZngsIHk6IGJvdW5kWzFdLnkgKyBmeSB9KTtcbiAgICAgIGZyb21YID0gc2Vnc1tpXVs0XTtcbiAgICAgIGZyb21ZID0gc2Vnc1tpXVs1XTtcbiAgICB9XG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGJvdW5kaW5nIGJveCBvZiBhIGJlemllcmN1cnZlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MCBzdGFydGluZyBwb2ludFxuICAgKiBAcGFyYW0ge051bWJlcn0geTBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgxIGZpcnN0IGNvbnRyb2wgcG9pbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkxXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MiBzZWNvbmRvIGNvbnRyb2wgcG9pbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MyBlbmQgb2YgYmVpemVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5M1xuICAgKi9cbiAgLy8gdGFrZW4gZnJvbSBodHRwOi8vanNiaW4uY29tL2l2b21pcS81Ni9lZGl0ICBubyBjcmVkaXRzIGF2YWlsYWJsZSBmb3IgdGhhdC5cbiAgZnVuY3Rpb24gZ2V0Qm91bmRzT2ZDdXJ2ZSh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICB2YXIgYXJnc1N0cmluZyA9IF9qb2luLmNhbGwoYXJndW1lbnRzKTtcbiAgICBpZiAoYm91bmRzT2ZDdXJ2ZUNhY2hlW2FyZ3NTdHJpbmddKSB7XG4gICAgICByZXR1cm4gYm91bmRzT2ZDdXJ2ZUNhY2hlW2FyZ3NTdHJpbmddO1xuICAgIH1cblxuICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0LFxuICAgICAgICBtaW4gPSBNYXRoLm1pbiwgbWF4ID0gTWF0aC5tYXgsXG4gICAgICAgIGFicyA9IE1hdGguYWJzLCB0dmFsdWVzID0gW10sXG4gICAgICAgIGJvdW5kcyA9IFtbXSwgW11dLFxuICAgICAgICBhLCBiLCBjLCB0LCB0MSwgdDIsIGIyYWMsIHNxcnRiMmFjO1xuXG4gICAgYiA9IDYgKiB4MCAtIDEyICogeDEgKyA2ICogeDI7XG4gICAgYSA9IC0zICogeDAgKyA5ICogeDEgLSA5ICogeDIgKyAzICogeDM7XG4gICAgYyA9IDMgKiB4MSAtIDMgKiB4MDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgKytpKSB7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgYiA9IDYgKiB5MCAtIDEyICogeTEgKyA2ICogeTI7XG4gICAgICAgIGEgPSAtMyAqIHkwICsgOSAqIHkxIC0gOSAqIHkyICsgMyAqIHkzO1xuICAgICAgICBjID0gMyAqIHkxIC0gMyAqIHkwO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWJzKGEpIDwgMWUtMTIpIHtcbiAgICAgICAgaWYgKGFicyhiKSA8IDFlLTEyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdCA9IC1jIC8gYjtcbiAgICAgICAgaWYgKDAgPCB0ICYmIHQgPCAxKSB7XG4gICAgICAgICAgdHZhbHVlcy5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYjJhYyA9IGIgKiBiIC0gNCAqIGMgKiBhO1xuICAgICAgaWYgKGIyYWMgPCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc3FydGIyYWMgPSBzcXJ0KGIyYWMpO1xuICAgICAgdDEgPSAoLWIgKyBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgICAgaWYgKDAgPCB0MSAmJiB0MSA8IDEpIHtcbiAgICAgICAgdHZhbHVlcy5wdXNoKHQxKTtcbiAgICAgIH1cbiAgICAgIHQyID0gKC1iIC0gc3FydGIyYWMpIC8gKDIgKiBhKTtcbiAgICAgIGlmICgwIDwgdDIgJiYgdDIgPCAxKSB7XG4gICAgICAgIHR2YWx1ZXMucHVzaCh0Mik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHgsIHksIGogPSB0dmFsdWVzLmxlbmd0aCwgamxlbiA9IGosIG10O1xuICAgIHdoaWxlIChqLS0pIHtcbiAgICAgIHQgPSB0dmFsdWVzW2pdO1xuICAgICAgbXQgPSAxIC0gdDtcbiAgICAgIHggPSAobXQgKiBtdCAqIG10ICogeDApICsgKDMgKiBtdCAqIG10ICogdCAqIHgxKSArICgzICogbXQgKiB0ICogdCAqIHgyKSArICh0ICogdCAqIHQgKiB4Myk7XG4gICAgICBib3VuZHNbMF1bal0gPSB4O1xuXG4gICAgICB5ID0gKG10ICogbXQgKiBtdCAqIHkwKSArICgzICogbXQgKiBtdCAqIHQgKiB5MSkgKyAoMyAqIG10ICogdCAqIHQgKiB5MikgKyAodCAqIHQgKiB0ICogeTMpO1xuICAgICAgYm91bmRzWzFdW2pdID0geTtcbiAgICB9XG5cbiAgICBib3VuZHNbMF1bamxlbl0gPSB4MDtcbiAgICBib3VuZHNbMV1bamxlbl0gPSB5MDtcbiAgICBib3VuZHNbMF1bamxlbiArIDFdID0geDM7XG4gICAgYm91bmRzWzFdW2psZW4gKyAxXSA9IHkzO1xuICAgIHZhciByZXN1bHQgPSBbXG4gICAgICB7XG4gICAgICAgIHg6IG1pbi5hcHBseShudWxsLCBib3VuZHNbMF0pLFxuICAgICAgICB5OiBtaW4uYXBwbHkobnVsbCwgYm91bmRzWzFdKVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgeDogbWF4LmFwcGx5KG51bGwsIGJvdW5kc1swXSksXG4gICAgICAgIHk6IG1heC5hcHBseShudWxsLCBib3VuZHNbMV0pXG4gICAgICB9XG4gICAgXTtcbiAgICBib3VuZHNPZkN1cnZlQ2FjaGVbYXJnc1N0cmluZ10gPSByZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLmdldEJvdW5kc09mQ3VydmUgPSBnZXRCb3VuZHNPZkN1cnZlO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLyogX0VTNV9DT01QQVRfU1RBUlRfICovXG5cbiAgaWYgKCFBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgIC8qKlxuICAgICAqIEZpbmRzIGluZGV4IG9mIGFuIGVsZW1lbnQgaW4gYW4gYXJyYXlcbiAgICAgKiBAcGFyYW0geyp9IHNlYXJjaEVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ICovICkge1xuICAgICAgaWYgKHRoaXMgPT09IHZvaWQgMCB8fCB0aGlzID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpLCBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcbiAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIG4gPSAwO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG4gPSBOdW1iZXIoYXJndW1lbnRzWzFdKTtcbiAgICAgICAgaWYgKG4gIT09IG4pIHsgLy8gc2hvcnRjdXQgZm9yIHZlcmlmeWluZyBpZiBpdCdzIE5hTlxuICAgICAgICAgIG4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG4gIT09IDAgJiYgbiAhPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZICYmIG4gIT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSkge1xuICAgICAgICAgIG4gPSAobiA+IDAgfHwgLTEpICogTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChuID49IGxlbikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgayA9IG4gPj0gMCA/IG4gOiBNYXRoLm1heChsZW4gLSBNYXRoLmFicyhuKSwgMCk7XG4gICAgICBmb3IgKDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgIGlmIChrIGluIHQgJiYgdFtrXSA9PT0gc2VhcmNoRWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiBrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIGlmICghQXJyYXkucHJvdG90eXBlLmZvckVhY2gpIHtcbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBhbiBhcnJheSwgaW52b2tpbmcgY2FsbGJhY2sgZm9yIGVhY2ggZWxlbWVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIENhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0IHRvIGludm9rZSBjYWxsYmFjayBpblxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oZm4sIGNvbnRleHQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmxlbmd0aCA+Pj4gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChpIGluIHRoaXMpIHtcbiAgICAgICAgICBmbi5jYWxsKGNvbnRleHQsIHRoaXNbaV0sIGksIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGlmICghQXJyYXkucHJvdG90eXBlLm1hcCkge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZXN1bHQgb2YgaXRlcmF0aW5nIG92ZXIgYW4gYXJyYXksIGludm9raW5nIGNhbGxiYWNrIGZvciBlYWNoIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBDYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gQ29udGV4dCB0byBpbnZva2UgY2FsbGJhY2sgaW5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBBcnJheS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24oZm4sIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmxlbmd0aCA+Pj4gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChpIGluIHRoaXMpIHtcbiAgICAgICAgICByZXN1bHRbaV0gPSBmbi5jYWxsKGNvbnRleHQsIHRoaXNbaV0sIGksIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cblxuICBpZiAoIUFycmF5LnByb3RvdHlwZS5ldmVyeSkge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhIGNhbGxiYWNrIHJldHVybnMgdHJ1dGh5IHZhbHVlIGZvciBhbGwgZWxlbWVudHMgaW4gYW4gYXJyYXlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBDYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gQ29udGV4dCB0byBpbnZva2UgY2FsbGJhY2sgaW5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIEFycmF5LnByb3RvdHlwZS5ldmVyeSA9IGZ1bmN0aW9uKGZuLCBjb250ZXh0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5sZW5ndGggPj4+IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaSBpbiB0aGlzICYmICFmbi5jYWxsKGNvbnRleHQsIHRoaXNbaV0sIGksIHRoaXMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhIGNhbGxiYWNrIHJldHVybnMgdHJ1dGh5IHZhbHVlIGZvciBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiBhbiBhcnJheVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIENhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0IHRvIGludm9rZSBjYWxsYmFjayBpblxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgQXJyYXkucHJvdG90eXBlLnNvbWUgPSBmdW5jdGlvbihmbiwgY29udGV4dCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMubGVuZ3RoID4+PiAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGkgaW4gdGhpcyAmJiBmbi5jYWxsKGNvbnRleHQsIHRoaXNbaV0sIGksIHRoaXMpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFBcnJheS5wcm90b3R5cGUuZmlsdGVyKSB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGl0ZXJhdGluZyBvdmVyIGVsZW1lbnRzIGluIGFuIGFycmF5XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQ2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIENvbnRleHQgdG8gaW52b2tlIGNhbGxiYWNrIGluXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgQXJyYXkucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uKGZuLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sIHZhbDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmxlbmd0aCA+Pj4gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChpIGluIHRoaXMpIHtcbiAgICAgICAgICB2YWwgPSB0aGlzW2ldOyAvLyBpbiBjYXNlIGZuIG11dGF0ZXMgdGhpc1xuICAgICAgICAgIGlmIChmbi5jYWxsKGNvbnRleHQsIHZhbCwgaSwgdGhpcykpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cblxuICBpZiAoIUFycmF5LnByb3RvdHlwZS5yZWR1Y2UpIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFwiZm9sZGVkXCIgKHJlZHVjZWQpIHJlc3VsdCBvZiBpdGVyYXRpbmcgb3ZlciBlbGVtZW50cyBpbiBhbiBhcnJheVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIENhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBlbGVtZW50XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKi9cbiAgICBBcnJheS5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24oZm4gLyosIGluaXRpYWwqLykge1xuICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoID4+PiAwLFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIHJ2O1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcnYgPSBhcmd1bWVudHNbMV07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGlmIChpIGluIHRoaXMpIHtcbiAgICAgICAgICAgIHJ2ID0gdGhpc1tpKytdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGlmIGFycmF5IGNvbnRhaW5zIG5vIHZhbHVlcywgbm8gaW5pdGlhbCB2YWx1ZSB0byByZXR1cm5cbiAgICAgICAgICBpZiAoKytpID49IGxlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodHJ1ZSk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChpIGluIHRoaXMpIHtcbiAgICAgICAgICBydiA9IGZuLmNhbGwobnVsbCwgcnYsIHRoaXNbaV0sIGksIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcnY7XG4gICAgfTtcbiAgfVxuXG4gIC8qIF9FUzVfQ09NUEFUX0VORF8gKi9cblxuICAvKipcbiAgICogSW52b2tlcyBtZXRob2Qgb24gYWxsIGl0ZW1zIGluIGEgZ2l2ZW4gYXJyYXlcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIGl0ZXJhdGUgb3ZlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIE5hbWUgb2YgYSBtZXRob2QgdG8gaW52b2tlXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZnVuY3Rpb24gaW52b2tlKGFycmF5LCBtZXRob2QpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSwgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBhcmdzLmxlbmd0aCA/IGFycmF5W2ldW21ldGhvZF0uYXBwbHkoYXJyYXlbaV0sIGFyZ3MpIDogYXJyYXlbaV1bbWV0aG9kXS5jYWxsKGFycmF5W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBtYXhpbXVtIHZhbHVlIGluIGFycmF5IChub3QgbmVjZXNzYXJpbHkgXCJmaXJzdFwiIG9uZSlcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIGl0ZXJhdGUgb3ZlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gYnlQcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZnVuY3Rpb24gbWF4KGFycmF5LCBieVByb3BlcnR5KSB7XG4gICAgcmV0dXJuIGZpbmQoYXJyYXksIGJ5UHJvcGVydHksIGZ1bmN0aW9uKHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgICByZXR1cm4gdmFsdWUxID49IHZhbHVlMjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBtaW5pbXVtIHZhbHVlIGluIGFycmF5IChub3QgbmVjZXNzYXJpbHkgXCJmaXJzdFwiIG9uZSlcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIGl0ZXJhdGUgb3ZlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gYnlQcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZnVuY3Rpb24gbWluKGFycmF5LCBieVByb3BlcnR5KSB7XG4gICAgcmV0dXJuIGZpbmQoYXJyYXksIGJ5UHJvcGVydHksIGZ1bmN0aW9uKHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgICByZXR1cm4gdmFsdWUxIDwgdmFsdWUyO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaWxsKGFycmF5LCB2YWx1ZSkge1xuICAgIHZhciBrID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChrLS0pIHtcbiAgICAgIGFycmF5W2tdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmluZChhcnJheSwgYnlQcm9wZXJ0eSwgY29uZGl0aW9uKSB7XG4gICAgaWYgKCFhcnJheSB8fCBhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaSA9IGFycmF5Lmxlbmd0aCAtIDEsXG4gICAgICAgIHJlc3VsdCA9IGJ5UHJvcGVydHkgPyBhcnJheVtpXVtieVByb3BlcnR5XSA6IGFycmF5W2ldO1xuICAgIGlmIChieVByb3BlcnR5KSB7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmIChjb25kaXRpb24oYXJyYXlbaV1bYnlQcm9wZXJ0eV0sIHJlc3VsdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBhcnJheVtpXVtieVByb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbihhcnJheVtpXSwgcmVzdWx0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGFycmF5W2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWVzcGFjZSBmYWJyaWMudXRpbC5hcnJheVxuICAgKi9cbiAgZmFicmljLnV0aWwuYXJyYXkgPSB7XG4gICAgZmlsbDogZmlsbCxcbiAgICBpbnZva2U6IGludm9rZSxcbiAgICBtaW46IG1pbixcbiAgICBtYXg6IG1heFxuICB9O1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIENvcGllcyBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIG9uZSBvYmplY3QgdG8gYW5vdGhlclxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwub2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0aW5hdGlvbiBXaGVyZSB0byBjb3B5IHRvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgV2hlcmUgdG8gY29weSBmcm9tXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cbiAgZnVuY3Rpb24gZXh0ZW5kKGRlc3RpbmF0aW9uLCBzb3VyY2UsIGRlZXApIHtcbiAgICAvLyBKU2NyaXB0IERvbnRFbnVtIGJ1ZyBpcyBub3QgdGFrZW4gY2FyZSBvZlxuICAgIC8vIHRoZSBkZWVwIGNsb25lIGlzIGZvciBpbnRlcm5hbCB1c2UsIGlzIG5vdCBtZWFudCB0byBhdm9pZFxuICAgIC8vIGphdmFzY3JpcHQgdHJhcHMgb3IgY2xvbmluZyBodG1sIGVsZW1lbnQgb3Igc2VsZiByZWZlcmVuY2VkIG9iamVjdHMuXG4gICAgaWYgKGRlZXApIHtcbiAgICAgIGlmICghZmFicmljLmlzTGlrZWx5Tm9kZSAmJiBzb3VyY2UgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgIC8vIGF2b2lkIGNsb25pbmcgZGVlcCBpbWFnZXMsIGNhbnZhc2VzLFxuICAgICAgICBkZXN0aW5hdGlvbiA9IHNvdXJjZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGRlc3RpbmF0aW9uID0gc291cmNlLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGNsb25lKHYsIGRlZXApXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc291cmNlKSB7XG4gICAgICAgICAgZGVzdGluYXRpb25bcHJvcGVydHldID0gY2xvbmUoc291cmNlW3Byb3BlcnR5XSwgZGVlcClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHRoaXMgc291bmRzIG9kZCBmb3IgYW4gZXh0ZW5kIGJ1dCBpcyBvayBmb3IgcmVjdXJzaXZlIHVzZVxuICAgICAgICBkZXN0aW5hdGlvbiA9IHNvdXJjZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzb3VyY2UpIHtcbiAgICAgICAgZGVzdGluYXRpb25bcHJvcGVydHldID0gc291cmNlW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gZW1wdHkgb2JqZWN0IGFuZCBjb3BpZXMgYWxsIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbm90aGVyIG9iamVjdCB0byBpdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwub2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNsb25lXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGZ1bmN0aW9uIGNsb25lKG9iamVjdCwgZGVlcCkge1xuICAgIHJldHVybiBleHRlbmQoeyB9LCBvYmplY3QsIGRlZXApO1xuICB9XG5cbiAgLyoqIEBuYW1lc3BhY2UgZmFicmljLnV0aWwub2JqZWN0ICovXG4gIGZhYnJpYy51dGlsLm9iamVjdCA9IHtcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBjbG9uZTogY2xvbmVcbiAgfTtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLyogX0VTNV9DT01QQVRfU1RBUlRfICovXG4gIGlmICghU3RyaW5nLnByb3RvdHlwZS50cmltKSB7XG4gICAgLyoqXG4gICAgICogVHJpbXMgYSBzdHJpbmcgKHJlbW92aW5nIHdoaXRlc3BhY2UgZnJvbSB0aGUgYmVnaW5uaW5nIGFuZCB0aGUgZW5kKVxuICAgICAqIEBmdW5jdGlvbiBleHRlcm5hbDpTdHJpbmcjdHJpbVxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9UcmltXCI+U3RyaW5nI3RyaW0gb24gTUROPC9hPlxuICAgICAqL1xuICAgIFN0cmluZy5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHRoaXMgdHJpbSBpcyBub3QgZnVsbHkgRVMzIG9yIEVTNSBjb21wbGlhbnQsIGJ1dCBpdCBzaG91bGQgY292ZXIgbW9zdCBjYXNlcyBmb3Igbm93XG4gICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKC9eW1xcc1xceEEwXSsvLCAnJykucmVwbGFjZSgvW1xcc1xceEEwXSskLywgJycpO1xuICAgIH07XG4gIH1cbiAgLyogX0VTNV9DT01QQVRfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBDYW1lbGl6ZXMgYSBzdHJpbmdcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLnN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFN0cmluZyB0byBjYW1lbGl6ZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IENhbWVsaXplZCB2ZXJzaW9uIG9mIGEgc3RyaW5nXG4gICAqL1xuICBmdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLy0rKC4pPy9nLCBmdW5jdGlvbihtYXRjaCwgY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gY2hhcmFjdGVyID8gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXBpdGFsaXplcyBhIHN0cmluZ1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgU3RyaW5nIHRvIGNhcGl0YWxpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZmlyc3RMZXR0ZXJPbmx5XSBJZiB0cnVlIG9ubHkgZmlyc3QgbGV0dGVyIGlzIGNhcGl0YWxpemVkXG4gICAqIGFuZCBvdGhlciBsZXR0ZXJzIHN0YXkgdW50b3VjaGVkLCBpZiBmYWxzZSBmaXJzdCBsZXR0ZXIgaXMgY2FwaXRhbGl6ZWRcbiAgICogYW5kIG90aGVyIGxldHRlcnMgYXJlIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gQ2FwaXRhbGl6ZWQgdmVyc2lvbiBvZiBhIHN0cmluZ1xuICAgKi9cbiAgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcsIGZpcnN0TGV0dGVyT25seSkge1xuICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgK1xuICAgICAgKGZpcnN0TGV0dGVyT25seSA/IHN0cmluZy5zbGljZSgxKSA6IHN0cmluZy5zbGljZSgxKS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFc2NhcGVzIFhNTCBpbiBhIHN0cmluZ1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgU3RyaW5nIHRvIGVzY2FwZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IEVzY2FwZWQgdmVyc2lvbiBvZiBhIHN0cmluZ1xuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlWG1sKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcbiAgICAgICAucmVwbGFjZSgvJy9nLCAnJmFwb3M7JylcbiAgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHJpbmcgdXRpbGl0aWVzXG4gICAqIEBuYW1lc3BhY2UgZmFicmljLnV0aWwuc3RyaW5nXG4gICAqL1xuICBmYWJyaWMudXRpbC5zdHJpbmcgPSB7XG4gICAgY2FtZWxpemU6IGNhbWVsaXplLFxuICAgIGNhcGl0YWxpemU6IGNhcGl0YWxpemUsXG4gICAgZXNjYXBlWG1sOiBlc2NhcGVYbWxcbiAgfTtcbn0pKCk7XG5cblxuLyogX0VTNV9DT01QQVRfU1RBUlRfICovXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuICAgICAgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHksXG4gICAgICBEdW1teSA9IGZ1bmN0aW9uKCkgeyB9O1xuXG4gIGlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcbiAgICAvKipcbiAgICAgKiBDcm9zcy1icm93c2VyIGFwcHJveGltYXRpb24gb2YgRVM1IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIChub3QgZnVsbHkgc3BlYyBjb25mb3JtaW5nKVxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2JpbmRcIj5GdW5jdGlvbiNiaW5kIG9uIE1ETjwvYT5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBPYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICAgICAqIEBwYXJhbSB7QW55W119IFZhbHVlcyB0byBwYXNzIHRvIGEgYm91bmQgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKHRoaXNBcmcpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIGJvdW5kO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGFwcGx5LmNhbGwoX3RoaXMsIHRoaXMgaW5zdGFuY2VvZiBEdW1teSA/IHRoaXMgOiB0aGlzQXJnLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvKiogQGlnbm9yZSAqL1xuICAgICAgICBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhcHBseS5jYWxsKF90aGlzLCB0aGlzIGluc3RhbmNlb2YgRHVtbXkgPyB0aGlzIDogdGhpc0FyZywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIER1bW15LnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IER1bW15KCk7XG5cbiAgICAgIHJldHVybiBib3VuZDtcbiAgICB9O1xuICB9XG5cbn0pKCk7XG4vKiBfRVM1X0NPTVBBVF9FTkRfICovXG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSwgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uKCkgeyB9LFxuXG4gICAgICBJU19ET05URU5VTV9CVUdHWSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiB7IHRvU3RyaW5nOiAxIH0pIHtcbiAgICAgICAgICBpZiAocCA9PT0gJ3RvU3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pKCksXG5cbiAgICAgIC8qKiBAaWdub3JlICovXG4gICAgICBhZGRNZXRob2RzID0gZnVuY3Rpb24oa2xhc3MsIHNvdXJjZSwgcGFyZW50KSB7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHNvdXJjZSkge1xuXG4gICAgICAgICAgaWYgKHByb3BlcnR5IGluIGtsYXNzLnByb3RvdHlwZSAmJlxuICAgICAgICAgICAgICB0eXBlb2Yga2xhc3MucHJvdG90eXBlW3Byb3BlcnR5XSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAoc291cmNlW3Byb3BlcnR5XSArICcnKS5pbmRleE9mKCdjYWxsU3VwZXInKSA+IC0xKSB7XG5cbiAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZVtwcm9wZXJ0eV0gPSAoZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHN1cGVyY2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3M7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3MgPSBzdXBlcmNsYXNzO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5ICE9PSAnaW5pdGlhbGl6ZScpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KShwcm9wZXJ0eSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAga2xhc3MucHJvdG90eXBlW3Byb3BlcnR5XSA9IHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKElTX0RPTlRFTlVNX0JVR0dZKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSB7XG4gICAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS50b1N0cmluZyA9IHNvdXJjZS50b1N0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3VyY2UudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSB7XG4gICAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS52YWx1ZU9mID0gc291cmNlLnZhbHVlT2Y7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gIGZ1bmN0aW9uIFN1YmNsYXNzKCkgeyB9XG5cbiAgZnVuY3Rpb24gY2FsbFN1cGVyKG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgZm4gPSB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdO1xuICAgIHJldHVybiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpXG4gICAgICA/IGZuLmFwcGx5KHRoaXMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSlcbiAgICAgIDogZm4uY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZm9yIGNyZWF0aW9uIG9mIFwiY2xhc3Nlc1wiLlxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3BhcmVudF0gb3B0aW9uYWwgXCJDbGFzc1wiIHRvIGluaGVyaXQgZnJvbVxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgc2hhcmVkIGJ5IGFsbCBpbnN0YW5jZXMgb2YgdGhpcyBjbGFzc1xuICAgKiAgICAgICAgICAgICAgICAgIChiZSBjYXJlZnVsIG1vZGlmeWluZyBvYmplY3RzIGRlZmluZWQgaGVyZSBhcyB0aGlzIHdvdWxkIGFmZmVjdCBhbGwgaW5zdGFuY2VzKVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQ2xhc3MoKSB7XG4gICAgdmFyIHBhcmVudCA9IG51bGwsXG4gICAgICAgIHByb3BlcnRpZXMgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICBpZiAodHlwZW9mIHByb3BlcnRpZXNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBhcmVudCA9IHByb3BlcnRpZXMuc2hpZnQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24ga2xhc3MoKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBrbGFzcy5zdXBlcmNsYXNzID0gcGFyZW50O1xuICAgIGtsYXNzLnN1YmNsYXNzZXMgPSBbXTtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIFN1YmNsYXNzLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgICBrbGFzcy5wcm90b3R5cGUgPSBuZXcgU3ViY2xhc3MoKTtcbiAgICAgIHBhcmVudC5zdWJjbGFzc2VzLnB1c2goa2xhc3MpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYWRkTWV0aG9kcyhrbGFzcywgcHJvcGVydGllc1tpXSwgcGFyZW50KTtcbiAgICB9XG4gICAgaWYgKCFrbGFzcy5wcm90b3R5cGUuaW5pdGlhbGl6ZSkge1xuICAgICAga2xhc3MucHJvdG90eXBlLmluaXRpYWxpemUgPSBlbXB0eUZ1bmN0aW9uO1xuICAgIH1cbiAgICBrbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBrbGFzcztcbiAgICBrbGFzcy5wcm90b3R5cGUuY2FsbFN1cGVyID0gY2FsbFN1cGVyO1xuICAgIHJldHVybiBrbGFzcztcbiAgfVxuXG4gIGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzID0gY3JlYXRlQ2xhc3M7XG59KSgpO1xuXG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHVua25vd24gPSAndW5rbm93bic7XG5cbiAgLyogRVZFTlQgSEFORExJTkcgKi9cblxuICBmdW5jdGlvbiBhcmVIb3N0TWV0aG9kcyhvYmplY3QpIHtcbiAgICB2YXIgbWV0aG9kTmFtZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICB0LCBpLCBsZW4gPSBtZXRob2ROYW1lcy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0ID0gdHlwZW9mIG9iamVjdFttZXRob2ROYW1lc1tpXV07XG4gICAgICBpZiAoISgvXig/OmZ1bmN0aW9ufG9iamVjdHx1bmtub3duKSQvKS50ZXN0KHQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogQGlnbm9yZSAqL1xuICB2YXIgZ2V0RWxlbWVudCxcbiAgICAgIHNldEVsZW1lbnQsXG4gICAgICBnZXRVbmlxdWVJZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1aWQgPSAwO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudC5fX3VuaXF1ZUlEIHx8IChlbGVtZW50Ll9fdW5pcXVlSUQgPSAndW5pcXVlSURfXycgKyB1aWQrKyk7XG4gICAgICAgIH07XG4gICAgICB9KSgpO1xuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsZW1lbnRzID0geyB9O1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgZ2V0RWxlbWVudCA9IGZ1bmN0aW9uICh1aWQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50c1t1aWRdO1xuICAgIH07XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICBzZXRFbGVtZW50ID0gZnVuY3Rpb24gKHVpZCwgZWxlbWVudCkge1xuICAgICAgZWxlbWVudHNbdWlkXSA9IGVsZW1lbnQ7XG4gICAgfTtcbiAgfSkoKTtcblxuICBmdW5jdGlvbiBjcmVhdGVMaXN0ZW5lcih1aWQsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgIHdyYXBwZWRIYW5kbGVyOiBjcmVhdGVXcmFwcGVkSGFuZGxlcih1aWQsIGhhbmRsZXIpXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVdyYXBwZWRIYW5kbGVyKHVpZCwgaGFuZGxlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgaGFuZGxlci5jYWxsKGdldEVsZW1lbnQodWlkKSwgZSB8fCBmYWJyaWMud2luZG93LmV2ZW50KTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRGlzcGF0Y2hlcih1aWQsIGV2ZW50TmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGhhbmRsZXJzW3VpZF0gJiYgaGFuZGxlcnNbdWlkXVtldmVudE5hbWVdKSB7XG4gICAgICAgIHZhciBoYW5kbGVyc0ZvckV2ZW50ID0gaGFuZGxlcnNbdWlkXVtldmVudE5hbWVdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaGFuZGxlcnNGb3JFdmVudC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGhhbmRsZXJzRm9yRXZlbnRbaV0uY2FsbCh0aGlzLCBlIHx8IGZhYnJpYy53aW5kb3cuZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBzaG91bGRVc2VBZGRMaXN0ZW5lclJlbW92ZUxpc3RlbmVyID0gKFxuICAgICAgICBhcmVIb3N0TWV0aG9kcyhmYWJyaWMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnYWRkRXZlbnRMaXN0ZW5lcicsICdyZW1vdmVFdmVudExpc3RlbmVyJykgJiZcbiAgICAgICAgYXJlSG9zdE1ldGhvZHMoZmFicmljLndpbmRvdywgJ2FkZEV2ZW50TGlzdGVuZXInLCAncmVtb3ZlRXZlbnRMaXN0ZW5lcicpKSxcblxuICAgICAgc2hvdWxkVXNlQXR0YWNoRXZlbnREZXRhY2hFdmVudCA9IChcbiAgICAgICAgYXJlSG9zdE1ldGhvZHMoZmFicmljLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJ2F0dGFjaEV2ZW50JywgJ2RldGFjaEV2ZW50JykgJiZcbiAgICAgICAgYXJlSG9zdE1ldGhvZHMoZmFicmljLndpbmRvdywgJ2F0dGFjaEV2ZW50JywgJ2RldGFjaEV2ZW50JykpLFxuXG4gICAgICAvLyBJRSBicmFuY2hcbiAgICAgIGxpc3RlbmVycyA9IHsgfSxcblxuICAgICAgLy8gRE9NIEwwIGJyYW5jaFxuICAgICAgaGFuZGxlcnMgPSB7IH0sXG5cbiAgICAgIGFkZExpc3RlbmVyLCByZW1vdmVMaXN0ZW5lcjtcblxuICBpZiAoc2hvdWxkVXNlQWRkTGlzdGVuZXJSZW1vdmVMaXN0ZW5lcikge1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfTtcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIHJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgIH07XG4gIH1cblxuICBlbHNlIGlmIChzaG91bGRVc2VBdHRhY2hFdmVudERldGFjaEV2ZW50KSB7XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICBhZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIHZhciB1aWQgPSBnZXRVbmlxdWVJZChlbGVtZW50KTtcbiAgICAgIHNldEVsZW1lbnQodWlkLCBlbGVtZW50KTtcbiAgICAgIGlmICghbGlzdGVuZXJzW3VpZF0pIHtcbiAgICAgICAgbGlzdGVuZXJzW3VpZF0gPSB7IH07XG4gICAgICB9XG4gICAgICBpZiAoIWxpc3RlbmVyc1t1aWRdW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgbGlzdGVuZXJzW3VpZF1bZXZlbnROYW1lXSA9IFtdO1xuXG4gICAgICB9XG4gICAgICB2YXIgbGlzdGVuZXIgPSBjcmVhdGVMaXN0ZW5lcih1aWQsIGhhbmRsZXIpO1xuICAgICAgbGlzdGVuZXJzW3VpZF1bZXZlbnROYW1lXS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50TmFtZSwgbGlzdGVuZXIud3JhcHBlZEhhbmRsZXIpO1xuICAgIH07XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICByZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIHZhciB1aWQgPSBnZXRVbmlxdWVJZChlbGVtZW50KSwgbGlzdGVuZXI7XG4gICAgICBpZiAobGlzdGVuZXJzW3VpZF0gJiYgbGlzdGVuZXJzW3VpZF1bZXZlbnROYW1lXSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzW3VpZF1bZXZlbnROYW1lXS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXJzW3VpZF1bZXZlbnROYW1lXVtpXTtcbiAgICAgICAgICBpZiAobGlzdGVuZXIgJiYgbGlzdGVuZXIuaGFuZGxlciA9PT0gaGFuZGxlcikge1xuICAgICAgICAgICAgZWxlbWVudC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnROYW1lLCBsaXN0ZW5lci53cmFwcGVkSGFuZGxlcik7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbdWlkXVtldmVudE5hbWVdW2ldID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGVsc2Uge1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICB2YXIgdWlkID0gZ2V0VW5pcXVlSWQoZWxlbWVudCk7XG4gICAgICBpZiAoIWhhbmRsZXJzW3VpZF0pIHtcbiAgICAgICAgaGFuZGxlcnNbdWlkXSA9IHsgfTtcbiAgICAgIH1cbiAgICAgIGlmICghaGFuZGxlcnNbdWlkXVtldmVudE5hbWVdKSB7XG4gICAgICAgIGhhbmRsZXJzW3VpZF1bZXZlbnROYW1lXSA9IFtdO1xuICAgICAgICB2YXIgZXhpc3RpbmdIYW5kbGVyID0gZWxlbWVudFsnb24nICsgZXZlbnROYW1lXTtcbiAgICAgICAgaWYgKGV4aXN0aW5nSGFuZGxlcikge1xuICAgICAgICAgIGhhbmRsZXJzW3VpZF1bZXZlbnROYW1lXS5wdXNoKGV4aXN0aW5nSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudFsnb24nICsgZXZlbnROYW1lXSA9IGNyZWF0ZURpc3BhdGNoZXIodWlkLCBldmVudE5hbWUpO1xuICAgICAgfVxuICAgICAgaGFuZGxlcnNbdWlkXVtldmVudE5hbWVdLnB1c2goaGFuZGxlcik7XG4gICAgfTtcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIHJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgdmFyIHVpZCA9IGdldFVuaXF1ZUlkKGVsZW1lbnQpO1xuICAgICAgaWYgKGhhbmRsZXJzW3VpZF0gJiYgaGFuZGxlcnNbdWlkXVtldmVudE5hbWVdKSB7XG4gICAgICAgIHZhciBoYW5kbGVyc0ZvckV2ZW50ID0gaGFuZGxlcnNbdWlkXVtldmVudE5hbWVdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaGFuZGxlcnNGb3JFdmVudC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmIChoYW5kbGVyc0ZvckV2ZW50W2ldID09PSBoYW5kbGVyKSB7XG4gICAgICAgICAgICBoYW5kbGVyc0ZvckV2ZW50LnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gYW4gZWxlbWVudFxuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lciA9IGFkZExpc3RlbmVyO1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gYW4gZWxlbWVudFxuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBmYWJyaWMudXRpbC5yZW1vdmVMaXN0ZW5lciA9IHJlbW92ZUxpc3RlbmVyO1xuXG4gIC8qKlxuICAgKiBDcm9zcy1icm93c2VyIHdyYXBwZXIgZm9yIGdldHRpbmcgZXZlbnQncyBjb29yZGluYXRlc1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBmdW5jdGlvbiBnZXRQb2ludGVyKGV2ZW50KSB7XG4gICAgZXZlbnQgfHwgKGV2ZW50ID0gZmFicmljLndpbmRvdy5ldmVudCk7XG5cbiAgICB2YXIgZWxlbWVudCA9IGV2ZW50LnRhcmdldCB8fFxuICAgICAgICAgICAgICAgICAgKHR5cGVvZiBldmVudC5zcmNFbGVtZW50ICE9PSB1bmtub3duID8gZXZlbnQuc3JjRWxlbWVudCA6IG51bGwpLFxuXG4gICAgICAgIHNjcm9sbCA9IGZhYnJpYy51dGlsLmdldFNjcm9sbExlZnRUb3AoZWxlbWVudCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogcG9pbnRlclgoZXZlbnQpICsgc2Nyb2xsLmxlZnQsXG4gICAgICB5OiBwb2ludGVyWShldmVudCkgKyBzY3JvbGwudG9wXG4gICAgfTtcbiAgfVxuXG4gIHZhciBwb2ludGVyWCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgLy8gbG9va3MgbGlrZSBpbiBJRSAoPDkpIGNsaWVudFggYXQgY2VydGFpbiBwb2ludCAoYXBwYXJlbnRseSB3aGVuIG1vdXNldXAgZmlyZXMgb24gVk1MIGVsZW1lbnQpXG4gICAgLy8gaXMgcmVwcmVzZW50ZWQgYXMgQ09NIG9iamVjdCwgd2l0aCBhbGwgdGhlIGNvbnNlcXVlbmNlcywgbGlrZSBcInVua25vd25cIiB0eXBlIGFuZCBlcnJvciBvbiBbW0dldF1dXG4gICAgLy8gbmVlZCB0byBpbnZlc3RpZ2F0ZSBsYXRlclxuICAgICAgICByZXR1cm4gKHR5cGVvZiBldmVudC5jbGllbnRYICE9PSB1bmtub3duID8gZXZlbnQuY2xpZW50WCA6IDApO1xuICAgICAgfSxcblxuICAgICAgcG9pbnRlclkgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBldmVudC5jbGllbnRZICE9PSB1bmtub3duID8gZXZlbnQuY2xpZW50WSA6IDApO1xuICAgICAgfTtcblxuICBmdW5jdGlvbiBfZ2V0UG9pbnRlcihldmVudCwgcGFnZVByb3AsIGNsaWVudFByb3ApIHtcbiAgICB2YXIgdG91Y2hQcm9wID0gZXZlbnQudHlwZSA9PT0gJ3RvdWNoZW5kJyA/ICdjaGFuZ2VkVG91Y2hlcycgOiAndG91Y2hlcyc7XG5cbiAgICByZXR1cm4gKGV2ZW50W3RvdWNoUHJvcF0gJiYgZXZlbnRbdG91Y2hQcm9wXVswXVxuICAgICAgPyAoZXZlbnRbdG91Y2hQcm9wXVswXVtwYWdlUHJvcF0gLSAoZXZlbnRbdG91Y2hQcm9wXVswXVtwYWdlUHJvcF0gLSBldmVudFt0b3VjaFByb3BdWzBdW2NsaWVudFByb3BdKSlcbiAgICAgICAgfHwgZXZlbnRbY2xpZW50UHJvcF1cbiAgICAgIDogZXZlbnRbY2xpZW50UHJvcF0pO1xuICB9XG5cbiAgaWYgKGZhYnJpYy5pc1RvdWNoU3VwcG9ydGVkKSB7XG4gICAgcG9pbnRlclggPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgcmV0dXJuIF9nZXRQb2ludGVyKGV2ZW50LCAncGFnZVgnLCAnY2xpZW50WCcpO1xuICAgIH07XG4gICAgcG9pbnRlclkgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgcmV0dXJuIF9nZXRQb2ludGVyKGV2ZW50LCAncGFnZVknLCAnY2xpZW50WScpO1xuICAgIH07XG4gIH1cblxuICBmYWJyaWMudXRpbC5nZXRQb2ludGVyID0gZ2V0UG9pbnRlcjtcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy51dGlsLCBmYWJyaWMuT2JzZXJ2YWJsZSk7XG5cbn0pKCk7XG5cblxuKGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogQ3Jvc3MtYnJvd3NlciB3cmFwcGVyIGZvciBzZXR0aW5nIGVsZW1lbnQncyBzdHlsZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBFbGVtZW50IHRoYXQgd2FzIHBhc3NlZCBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAqL1xuICBmdW5jdGlvbiBzZXRTdHlsZShlbGVtZW50LCBzdHlsZXMpIHtcbiAgICB2YXIgZWxlbWVudFN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgICBpZiAoIWVsZW1lbnRTdHlsZSkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ICs9ICc7JyArIHN0eWxlcztcbiAgICAgIHJldHVybiBzdHlsZXMuaW5kZXhPZignb3BhY2l0eScpID4gLTFcbiAgICAgICAgPyBzZXRPcGFjaXR5KGVsZW1lbnQsIHN0eWxlcy5tYXRjaCgvb3BhY2l0eTpcXHMqKFxcZD9cXC4/XFxkKikvKVsxXSlcbiAgICAgICAgOiBlbGVtZW50O1xuICAgIH1cbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ29wYWNpdHknKSB7XG4gICAgICAgIHNldE9wYWNpdHkoZWxlbWVudCwgc3R5bGVzW3Byb3BlcnR5XSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRQcm9wZXJ0eSA9IChwcm9wZXJ0eSA9PT0gJ2Zsb2F0JyB8fCBwcm9wZXJ0eSA9PT0gJ2Nzc0Zsb2F0JylcbiAgICAgICAgICA/ICh0eXBlb2YgZWxlbWVudFN0eWxlLnN0eWxlRmxvYXQgPT09ICd1bmRlZmluZWQnID8gJ2Nzc0Zsb2F0JyA6ICdzdHlsZUZsb2F0JylcbiAgICAgICAgICA6IHByb3BlcnR5O1xuICAgICAgICBlbGVtZW50U3R5bGVbbm9ybWFsaXplZFByb3BlcnR5XSA9IHN0eWxlc1twcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgdmFyIHBhcnNlRWwgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICBzdXBwb3J0c09wYWNpdHkgPSB0eXBlb2YgcGFyc2VFbC5zdHlsZS5vcGFjaXR5ID09PSAnc3RyaW5nJyxcbiAgICAgIHN1cHBvcnRzRmlsdGVycyA9IHR5cGVvZiBwYXJzZUVsLnN0eWxlLmZpbHRlciA9PT0gJ3N0cmluZycsXG4gICAgICByZU9wYWNpdHkgPSAvYWxwaGFcXHMqXFwoXFxzKm9wYWNpdHlcXHMqPVxccyooW15cXCldKylcXCkvLFxuXG4gICAgICAvKiogQGlnbm9yZSAqL1xuICAgICAgc2V0T3BhY2l0eSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBlbGVtZW50OyB9O1xuXG4gIGlmIChzdXBwb3J0c09wYWNpdHkpIHtcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIHNldE9wYWNpdHkgPSBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZSkge1xuICAgICAgZWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gdmFsdWU7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9O1xuICB9XG4gIGVsc2UgaWYgKHN1cHBvcnRzRmlsdGVycykge1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgc2V0T3BhY2l0eSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgICB2YXIgZXMgPSBlbGVtZW50LnN0eWxlO1xuICAgICAgaWYgKGVsZW1lbnQuY3VycmVudFN0eWxlICYmICFlbGVtZW50LmN1cnJlbnRTdHlsZS5oYXNMYXlvdXQpIHtcbiAgICAgICAgZXMuem9vbSA9IDE7XG4gICAgICB9XG4gICAgICBpZiAocmVPcGFjaXR5LnRlc3QoZXMuZmlsdGVyKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID49IDAuOTk5OSA/ICcnIDogKCdhbHBoYShvcGFjaXR5PScgKyAodmFsdWUgKiAxMDApICsgJyknKTtcbiAgICAgICAgZXMuZmlsdGVyID0gZXMuZmlsdGVyLnJlcGxhY2UocmVPcGFjaXR5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZXMuZmlsdGVyICs9ICcgYWxwaGEob3BhY2l0eT0nICsgKHZhbHVlICogMTAwKSArICcpJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG4gIH1cblxuICBmYWJyaWMudXRpbC5zZXRTdHlsZSA9IHNldFN0eWxlO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgX3NsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIC8qKlxuICAgKiBUYWtlcyBpZCBhbmQgcmV0dXJucyBhbiBlbGVtZW50IHdpdGggdGhhdCBpZCAoaWYgb25lIGV4aXN0cyBpbiBhIGRvY3VtZW50KVxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGlkXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRCeUlkKGlkKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgPyBmYWJyaWMuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogaWQ7XG4gIH1cblxuICB2YXIgc2xpY2VDYW5Db252ZXJ0Tm9kZWxpc3RzLFxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZXJ0cyBhbiBhcnJheS1saWtlIG9iamVjdCAoZS5nLiBhcmd1bWVudHMgb3IgTm9kZUxpc3QpIHRvIGFuIGFycmF5XG4gICAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcnJheUxpa2VcbiAgICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgICovXG4gICAgICB0b0FycmF5ID0gZnVuY3Rpb24oYXJyYXlMaWtlKSB7XG4gICAgICAgIHJldHVybiBfc2xpY2UuY2FsbChhcnJheUxpa2UsIDApO1xuICAgICAgfTtcblxuICB0cnkge1xuICAgIHNsaWNlQ2FuQ29udmVydE5vZGVsaXN0cyA9IHRvQXJyYXkoZmFicmljLmRvY3VtZW50LmNoaWxkTm9kZXMpIGluc3RhbmNlb2YgQXJyYXk7XG4gIH1cbiAgY2F0Y2ggKGVycikgeyB9XG5cbiAgaWYgKCFzbGljZUNhbkNvbnZlcnROb2RlbGlzdHMpIHtcbiAgICB0b0FycmF5ID0gZnVuY3Rpb24oYXJyYXlMaWtlKSB7XG4gICAgICB2YXIgYXJyID0gbmV3IEFycmF5KGFycmF5TGlrZS5sZW5ndGgpLCBpID0gYXJyYXlMaWtlLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgYXJyW2ldID0gYXJyYXlMaWtlW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgc3BlY2lmaWVkIGVsZW1lbnQgd2l0aCBzcGVjaWZpZWQgYXR0cmlidXRlc1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRhZ05hbWUgVHlwZSBvZiBhbiBlbGVtZW50IHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdIEF0dHJpYnV0ZXMgdG8gc2V0IG9uIGFuIGVsZW1lbnRcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IE5ld2x5IGNyZWF0ZWQgZWxlbWVudFxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZUVsZW1lbnQodGFnTmFtZSwgYXR0cmlidXRlcykge1xuICAgIHZhciBlbCA9IGZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIGZvciAodmFyIHByb3AgaW4gYXR0cmlidXRlcykge1xuICAgICAgaWYgKHByb3AgPT09ICdjbGFzcycpIHtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gYXR0cmlidXRlc1twcm9wXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHByb3AgPT09ICdmb3InKSB7XG4gICAgICAgIGVsLmh0bWxGb3IgPSBhdHRyaWJ1dGVzW3Byb3BdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShwcm9wLCBhdHRyaWJ1dGVzW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgY2xhc3MgdG8gYW4gZWxlbWVudFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGFkZCBjbGFzcyB0b1xuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lIENsYXNzIHRvIGFkZCB0byBhbiBlbGVtZW50XG4gICAqL1xuICBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICBpZiAoZWxlbWVudCAmJiAoJyAnICsgZWxlbWVudC5jbGFzc05hbWUgKyAnICcpLmluZGV4T2YoJyAnICsgY2xhc3NOYW1lICsgJyAnKSA9PT0gLTEpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lICs9IChlbGVtZW50LmNsYXNzTmFtZSA/ICcgJyA6ICcnKSArIGNsYXNzTmFtZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgZWxlbWVudCB3aXRoIGFub3RoZXIgZWxlbWVudFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHdyYXBcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxTdHJpbmd9IHdyYXBwZXIgRWxlbWVudCB0byB3cmFwIHdpdGhcbiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzXSBBdHRyaWJ1dGVzIHRvIHNldCBvbiBhIHdyYXBwZXJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IHdyYXBwZXJcbiAgICovXG4gIGZ1bmN0aW9uIHdyYXBFbGVtZW50KGVsZW1lbnQsIHdyYXBwZXIsIGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAodHlwZW9mIHdyYXBwZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICB3cmFwcGVyID0gbWFrZUVsZW1lbnQod3JhcHBlciwgYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQod3JhcHBlciwgZWxlbWVudCk7XG4gICAgfVxuICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgcmV0dXJuIHdyYXBwZXI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBlbGVtZW50IHNjcm9sbCBvZmZzZXRzXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gb3BlcmF0ZSBvblxuICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIGxlZnQvdG9wIHZhbHVlc1xuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U2Nyb2xsTGVmdFRvcChlbGVtZW50KSB7XG5cbiAgICB2YXIgbGVmdCA9IDAsXG4gICAgICAgIHRvcCA9IDAsXG4gICAgICAgIGRvY0VsZW1lbnQgPSBmYWJyaWMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICBib2R5ID0gZmFicmljLmRvY3VtZW50LmJvZHkgfHwge1xuICAgICAgICAgIHNjcm9sbExlZnQ6IDAsIHNjcm9sbFRvcDogMFxuICAgICAgICB9O1xuXG4gICAgLy8gV2hpbGUgbG9vcCBjaGVja3MgKGFuZCB0aGVuIHNldHMgZWxlbWVudCB0bykgLnBhcmVudE5vZGUgT1IgLmhvc3RcbiAgICAvLyAgdG8gYWNjb3VudCBmb3IgU2hhZG93RE9NLiBXZSBzdGlsbCB3YW50IHRvIHRyYXZlcnNlIHVwIG91dCBvZiBTaGFkb3dET00sXG4gICAgLy8gIGJ1dCB0aGUgLnBhcmVudE5vZGUgb2YgYSByb290IFNoYWRvd0RPTSBub2RlIHdpbGwgYWx3YXlzIGJlIG51bGwsIGluc3RlYWRcbiAgICAvLyAgaXQgc2hvdWxkIGJlIGFjY2Vzc2VkIHRocm91Z2ggLmhvc3QuIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNDc2NTUyOC80MzgzOTM4XG4gICAgd2hpbGUgKGVsZW1lbnQgJiYgKGVsZW1lbnQucGFyZW50Tm9kZSB8fCBlbGVtZW50Lmhvc3QpKSB7XG5cbiAgICAgIC8vIFNldCBlbGVtZW50IHRvIGVsZW1lbnQgcGFyZW50LCBvciAnaG9zdCcgaW4gY2FzZSBvZiBTaGFkb3dET01cbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGUgfHwgZWxlbWVudC5ob3N0O1xuXG4gICAgICBpZiAoZWxlbWVudCA9PT0gZmFicmljLmRvY3VtZW50KSB7XG4gICAgICAgIGxlZnQgPSBib2R5LnNjcm9sbExlZnQgfHwgZG9jRWxlbWVudC5zY3JvbGxMZWZ0IHx8IDA7XG4gICAgICAgIHRvcCA9IGJvZHkuc2Nyb2xsVG9wIHx8ICBkb2NFbGVtZW50LnNjcm9sbFRvcCB8fCAwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxlZnQgKz0gZWxlbWVudC5zY3JvbGxMZWZ0IHx8IDA7XG4gICAgICAgIHRvcCArPSBlbGVtZW50LnNjcm9sbFRvcCB8fCAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gMSAmJlxuICAgICAgICAgIGZhYnJpYy51dGlsLmdldEVsZW1lbnRTdHlsZShlbGVtZW50LCAncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBsZWZ0OiBsZWZ0LCB0b3A6IHRvcCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgb2Zmc2V0IGZvciBhIGdpdmVuIGVsZW1lbnRcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gZ2V0IG9mZnNldCBmb3JcbiAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBcImxlZnRcIiBhbmQgXCJ0b3BcIiBwcm9wZXJ0aWVzXG4gICAqL1xuICBmdW5jdGlvbiBnZXRFbGVtZW50T2Zmc2V0KGVsZW1lbnQpIHtcbiAgICB2YXIgZG9jRWxlbSxcbiAgICAgICAgZG9jID0gZWxlbWVudCAmJiBlbGVtZW50Lm93bmVyRG9jdW1lbnQsXG4gICAgICAgIGJveCA9IHsgbGVmdDogMCwgdG9wOiAwIH0sXG4gICAgICAgIG9mZnNldCA9IHsgbGVmdDogMCwgdG9wOiAwIH0sXG4gICAgICAgIHNjcm9sbExlZnRUb3AsXG4gICAgICAgIG9mZnNldEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgYm9yZGVyTGVmdFdpZHRoOiAnbGVmdCcsXG4gICAgICAgICAgYm9yZGVyVG9wV2lkdGg6ICAndG9wJyxcbiAgICAgICAgICBwYWRkaW5nTGVmdDogICAgICdsZWZ0JyxcbiAgICAgICAgICBwYWRkaW5nVG9wOiAgICAgICd0b3AnXG4gICAgICAgIH07XG5cbiAgICBpZiAoIWRvYykge1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBhdHRyIGluIG9mZnNldEF0dHJpYnV0ZXMpIHtcbiAgICAgIG9mZnNldFtvZmZzZXRBdHRyaWJ1dGVzW2F0dHJdXSArPSBwYXJzZUludChnZXRFbGVtZW50U3R5bGUoZWxlbWVudCwgYXR0ciksIDEwKSB8fCAwO1xuICAgIH1cblxuICAgIGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIGlmICggdHlwZW9mIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICE9PSAndW5kZWZpbmVkJyApIHtcbiAgICAgIGJveCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuXG4gICAgc2Nyb2xsTGVmdFRvcCA9IGdldFNjcm9sbExlZnRUb3AoZWxlbWVudCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogYm94LmxlZnQgKyBzY3JvbGxMZWZ0VG9wLmxlZnQgLSAoZG9jRWxlbS5jbGllbnRMZWZ0IHx8IDApICsgb2Zmc2V0LmxlZnQsXG4gICAgICB0b3A6IGJveC50b3AgKyBzY3JvbGxMZWZ0VG9wLnRvcCAtIChkb2NFbGVtLmNsaWVudFRvcCB8fCAwKSAgKyBvZmZzZXQudG9wXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHN0eWxlIGF0dHJpYnV0ZSB2YWx1ZSBvZiBhIGdpdmVuIGVsZW1lbnRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBnZXQgc3R5bGUgYXR0cmlidXRlIGZvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciBTdHlsZSBhdHRyaWJ1dGUgdG8gZ2V0IGZvciBlbGVtZW50XG4gICAqIEByZXR1cm4ge1N0cmluZ30gU3R5bGUgYXR0cmlidXRlIHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKi9cbiAgdmFyIGdldEVsZW1lbnRTdHlsZTtcbiAgaWYgKGZhYnJpYy5kb2N1bWVudC5kZWZhdWx0VmlldyAmJiBmYWJyaWMuZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgIGdldEVsZW1lbnRTdHlsZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHIpIHtcbiAgICAgIHZhciBzdHlsZSA9IGZhYnJpYy5kb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuICAgICAgcmV0dXJuIHN0eWxlID8gc3R5bGVbYXR0cl0gOiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgfVxuICBlbHNlIHtcbiAgICBnZXRFbGVtZW50U3R5bGUgPSBmdW5jdGlvbihlbGVtZW50LCBhdHRyKSB7XG4gICAgICB2YXIgdmFsdWUgPSBlbGVtZW50LnN0eWxlW2F0dHJdO1xuICAgICAgaWYgKCF2YWx1ZSAmJiBlbGVtZW50LmN1cnJlbnRTdHlsZSkge1xuICAgICAgICB2YWx1ZSA9IGVsZW1lbnQuY3VycmVudFN0eWxlW2F0dHJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH1cblxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHlsZSA9IGZhYnJpYy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUsXG4gICAgICAgIHNlbGVjdFByb3AgPSAndXNlclNlbGVjdCcgaW4gc3R5bGVcbiAgICAgICAgICA/ICd1c2VyU2VsZWN0J1xuICAgICAgICAgIDogJ01velVzZXJTZWxlY3QnIGluIHN0eWxlXG4gICAgICAgICAgICA/ICdNb3pVc2VyU2VsZWN0J1xuICAgICAgICAgICAgOiAnV2Via2l0VXNlclNlbGVjdCcgaW4gc3R5bGVcbiAgICAgICAgICAgICAgPyAnV2Via2l0VXNlclNlbGVjdCdcbiAgICAgICAgICAgICAgOiAnS2h0bWxVc2VyU2VsZWN0JyBpbiBzdHlsZVxuICAgICAgICAgICAgICAgID8gJ0todG1sVXNlclNlbGVjdCdcbiAgICAgICAgICAgICAgICA6ICcnO1xuXG4gICAgLyoqXG4gICAgICogTWFrZXMgZWxlbWVudCB1bnNlbGVjdGFibGVcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gbWFrZSB1bnNlbGVjdGFibGVcbiAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gRWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgaW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlRWxlbWVudFVuc2VsZWN0YWJsZShlbGVtZW50KSB7XG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQub25zZWxlY3RzdGFydCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZWxlbWVudC5vbnNlbGVjdHN0YXJ0ID0gZmFicmljLnV0aWwuZmFsc2VGdW5jdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3RQcm9wKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbc2VsZWN0UHJvcF0gPSAnbm9uZSc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC51bnNlbGVjdGFibGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVsZW1lbnQudW5zZWxlY3RhYmxlID0gJ29uJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ha2VzIGVsZW1lbnQgc2VsZWN0YWJsZVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBtYWtlIHNlbGVjdGFibGVcbiAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gRWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgaW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlRWxlbWVudFNlbGVjdGFibGUoZWxlbWVudCkge1xuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50Lm9uc2VsZWN0c3RhcnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGVsZW1lbnQub25zZWxlY3RzdGFydCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0UHJvcCkge1xuICAgICAgICBlbGVtZW50LnN0eWxlW3NlbGVjdFByb3BdID0gJyc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC51bnNlbGVjdGFibGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVsZW1lbnQudW5zZWxlY3RhYmxlID0gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBmYWJyaWMudXRpbC5tYWtlRWxlbWVudFVuc2VsZWN0YWJsZSA9IG1ha2VFbGVtZW50VW5zZWxlY3RhYmxlO1xuICAgIGZhYnJpYy51dGlsLm1ha2VFbGVtZW50U2VsZWN0YWJsZSA9IG1ha2VFbGVtZW50U2VsZWN0YWJsZTtcbiAgfSkoKTtcblxuICAoZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgc2NyaXB0IGVsZW1lbnQgd2l0aCBhIGdpdmVuIHVybCBpbnRvIGEgZG9jdW1lbnQ7IGludm9rZXMgY2FsbGJhY2ssIHdoZW4gdGhhdCBzY3JpcHQgaXMgZmluaXNoZWQgbG9hZGluZ1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVVJMIG9mIGEgc2NyaXB0IHRvIGxvYWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBleGVjdXRlIHdoZW4gc2NyaXB0IGlzIGZpbmlzaGVkIGxvYWRpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTY3JpcHQodXJsLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGhlYWRFbCA9IGZhYnJpYy5kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLFxuICAgICAgICAgIHNjcmlwdEVsID0gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpLFxuICAgICAgICAgIGxvYWRpbmcgPSB0cnVlO1xuXG4gICAgICAvKiogQGlnbm9yZSAqL1xuICAgICAgc2NyaXB0RWwub25sb2FkID0gLyoqIEBpZ25vcmUgKi8gc2NyaXB0RWwub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAobG9hZGluZykge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5yZWFkeVN0YXRlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgIT09ICdsb2FkZWQnICYmXG4gICAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZSAhPT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgY2FsbGJhY2soZSB8fCBmYWJyaWMud2luZG93LmV2ZW50KTtcbiAgICAgICAgICBzY3JpcHRFbCA9IHNjcmlwdEVsLm9ubG9hZCA9IHNjcmlwdEVsLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzY3JpcHRFbC5zcmMgPSB1cmw7XG4gICAgICBoZWFkRWwuYXBwZW5kQ2hpbGQoc2NyaXB0RWwpO1xuICAgICAgLy8gY2F1c2VzIGlzc3VlIGluIE9wZXJhXG4gICAgICAvLyBoZWFkRWwucmVtb3ZlQ2hpbGQoc2NyaXB0RWwpO1xuICAgIH1cblxuICAgIGZhYnJpYy51dGlsLmdldFNjcmlwdCA9IGdldFNjcmlwdDtcbiAgfSkoKTtcblxuICBmYWJyaWMudXRpbC5nZXRCeUlkID0gZ2V0QnlJZDtcbiAgZmFicmljLnV0aWwudG9BcnJheSA9IHRvQXJyYXk7XG4gIGZhYnJpYy51dGlsLm1ha2VFbGVtZW50ID0gbWFrZUVsZW1lbnQ7XG4gIGZhYnJpYy51dGlsLmFkZENsYXNzID0gYWRkQ2xhc3M7XG4gIGZhYnJpYy51dGlsLndyYXBFbGVtZW50ID0gd3JhcEVsZW1lbnQ7XG4gIGZhYnJpYy51dGlsLmdldFNjcm9sbExlZnRUb3AgPSBnZXRTY3JvbGxMZWZ0VG9wO1xuICBmYWJyaWMudXRpbC5nZXRFbGVtZW50T2Zmc2V0ID0gZ2V0RWxlbWVudE9mZnNldDtcbiAgZmFicmljLnV0aWwuZ2V0RWxlbWVudFN0eWxlID0gZ2V0RWxlbWVudFN0eWxlO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICBmdW5jdGlvbiBhZGRQYXJhbVRvVXJsKHVybCwgcGFyYW0pIHtcbiAgICByZXR1cm4gdXJsICsgKC9cXD8vLnRlc3QodXJsKSA/ICcmJyA6ICc/JykgKyBwYXJhbTtcbiAgfVxuXG4gIHZhciBtYWtlWEhSID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBmYWN0b3JpZXMgPSBbXG4gICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpOyB9LFxuICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAnKTsgfSxcbiAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQLjMuMCcpOyB9LFxuICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTsgfVxuICAgIF07XG4gICAgZm9yICh2YXIgaSA9IGZhY3Rvcmllcy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVxID0gZmFjdG9yaWVzW2ldKCk7XG4gICAgICAgIGlmIChyZXEpIHtcbiAgICAgICAgICByZXR1cm4gZmFjdG9yaWVzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYXRjaCAoZXJyKSB7IH1cbiAgICB9XG4gIH0pKCk7XG5cbiAgZnVuY3Rpb24gZW1wdHlGbigpIHsgfVxuXG4gIC8qKlxuICAgKiBDcm9zcy1icm93c2VyIGFic3RyYWN0aW9uIGZvciBzZW5kaW5nIFhNTEh0dHBSZXF1ZXN0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFVSTCB0byBzZW5kIFhNTEh0dHBSZXF1ZXN0IHRvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1ldGhvZD1cIkdFVFwiXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGFyYW1ldGVyc10gcGFyYW1ldGVycyB0byBhcHBlbmQgdG8gdXJsIGluIEdFVCBvciBpbiBib2R5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5ib2R5XSBib2R5IHRvIHNlbmQgd2l0aCBQT1NUIG9yIFBVVCByZXF1ZXN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25Db21wbGV0ZSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiByZXF1ZXN0IGlzIGNvbXBsZXRlZFxuICAgKiBAcmV0dXJuIHtYTUxIdHRwUmVxdWVzdH0gcmVxdWVzdFxuICAgKi9cbiAgZnVuY3Rpb24gcmVxdWVzdCh1cmwsIG9wdGlvbnMpIHtcblxuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgdmFyIG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kID8gb3B0aW9ucy5tZXRob2QudG9VcHBlckNhc2UoKSA6ICdHRVQnLFxuICAgICAgICBvbkNvbXBsZXRlID0gb3B0aW9ucy5vbkNvbXBsZXRlIHx8IGZ1bmN0aW9uKCkgeyB9LFxuICAgICAgICB4aHIgPSBtYWtlWEhSKCksXG4gICAgICAgIGJvZHkgPSBvcHRpb25zLmJvZHkgfHwgb3B0aW9ucy5wYXJhbWV0ZXJzO1xuXG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgb25Db21wbGV0ZSh4aHIpO1xuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHlGbjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgIGJvZHkgPSBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnBhcmFtZXRlcnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHVybCA9IGFkZFBhcmFtVG9VcmwodXJsLCBvcHRpb25zLnBhcmFtZXRlcnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcblxuICAgIGlmIChtZXRob2QgPT09ICdQT1NUJyB8fCBtZXRob2QgPT09ICdQVVQnKSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpO1xuICAgIH1cblxuICAgIHhoci5zZW5kKGJvZHkpO1xuICAgIHJldHVybiB4aHI7XG4gIH1cblxuICBmYWJyaWMudXRpbC5yZXF1ZXN0ID0gcmVxdWVzdDtcbn0pKCk7XG5cblxuLyoqXG4gKiBXcmFwcGVyIGFyb3VuZCBgY29uc29sZS5sb2dgICh3aGVuIGF2YWlsYWJsZSlcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlc10gVmFsdWVzIHRvIGxvZ1xuICovXG5mYWJyaWMubG9nID0gZnVuY3Rpb24oKSB7IH07XG5cbi8qKlxuICogV3JhcHBlciBhcm91bmQgYGNvbnNvbGUud2FybmAgKHdoZW4gYXZhaWxhYmxlKVxuICogQHBhcmFtIHsqfSBbdmFsdWVzXSBWYWx1ZXMgdG8gbG9nIGFzIGEgd2FybmluZ1xuICovXG5mYWJyaWMud2FybiA9IGZ1bmN0aW9uKCkgeyB9O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuXG4gIFsnbG9nJywgJ3dhcm4nXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcblxuICAgIGlmICh0eXBlb2YgY29uc29sZVttZXRob2ROYW1lXSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIGNvbnNvbGVbbWV0aG9kTmFtZV0uYXBwbHkgPT09ICdmdW5jdGlvbicpIHtcblxuICAgICAgZmFicmljW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlW21ldGhvZE5hbWVdLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIHZhbHVlIGZyb20gb25lIHRvIGFub3RoZXIgd2l0aGluIGNlcnRhaW4gcGVyaW9kIG9mIHRpbWUsIGludm9raW5nIGNhbGxiYWNrcyBhcyB2YWx1ZSBpcyBiZWluZyBjaGFuZ2VkLlxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbmltYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkNoYW5nZV0gQ2FsbGJhY2s7IGludm9rZWQgb24gZXZlcnkgdmFsdWUgY2hhbmdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uQ29tcGxldGVdIENhbGxiYWNrOyBpbnZva2VkIHdoZW4gdmFsdWUgY2hhbmdlIGlzIGNvbXBsZXRlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3RhcnRWYWx1ZT0wXSBTdGFydGluZyB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZW5kVmFsdWU9MTAwXSBFbmRpbmcgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJ5VmFsdWU9MTAwXSBWYWx1ZSB0byBtb2RpZnkgdGhlIHByb3BlcnR5IGJ5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmVhc2luZ10gRWFzaW5nIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdXJhdGlvbj01MDBdIER1cmF0aW9uIG9mIGNoYW5nZSAoaW4gbXMpXG4gICAqL1xuICBmdW5jdGlvbiBhbmltYXRlKG9wdGlvbnMpIHtcblxuICAgIHJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24odGltZXN0YW1wKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdmFyIHN0YXJ0ID0gdGltZXN0YW1wIHx8ICtuZXcgRGF0ZSgpLFxuICAgICAgICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiB8fCA1MDAsXG4gICAgICAgICAgZmluaXNoID0gc3RhcnQgKyBkdXJhdGlvbiwgdGltZSxcbiAgICAgICAgICBvbkNoYW5nZSA9IG9wdGlvbnMub25DaGFuZ2UgfHwgZnVuY3Rpb24oKSB7IH0sXG4gICAgICAgICAgYWJvcnQgPSBvcHRpb25zLmFib3J0IHx8IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgZWFzaW5nID0gb3B0aW9ucy5lYXNpbmcgfHwgZnVuY3Rpb24odCwgYiwgYywgZCkge3JldHVybiAtYyAqIE1hdGguY29zKHQgLyBkICogKE1hdGguUEkgLyAyKSkgKyBjICsgYjt9LFxuICAgICAgICAgIHN0YXJ0VmFsdWUgPSAnc3RhcnRWYWx1ZScgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhcnRWYWx1ZSA6IDAsXG4gICAgICAgICAgZW5kVmFsdWUgPSAnZW5kVmFsdWUnIGluIG9wdGlvbnMgPyBvcHRpb25zLmVuZFZhbHVlIDogMTAwLFxuICAgICAgICAgIGJ5VmFsdWUgPSBvcHRpb25zLmJ5VmFsdWUgfHwgZW5kVmFsdWUgLSBzdGFydFZhbHVlO1xuXG4gICAgICBvcHRpb25zLm9uU3RhcnQgJiYgb3B0aW9ucy5vblN0YXJ0KCk7XG5cbiAgICAgIChmdW5jdGlvbiB0aWNrKHRpY2t0aW1lKSB7XG4gICAgICAgIHRpbWUgPSB0aWNrdGltZSB8fCArbmV3IERhdGUoKTtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gdGltZSA+IGZpbmlzaCA/IGR1cmF0aW9uIDogKHRpbWUgLSBzdGFydCk7XG4gICAgICAgIGlmIChhYm9ydCgpKSB7XG4gICAgICAgICAgb3B0aW9ucy5vbkNvbXBsZXRlICYmIG9wdGlvbnMub25Db21wbGV0ZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvbkNoYW5nZShlYXNpbmcoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGJ5VmFsdWUsIGR1cmF0aW9uKSk7XG4gICAgICAgIGlmICh0aW1lID4gZmluaXNoKSB7XG4gICAgICAgICAgb3B0aW9ucy5vbkNvbXBsZXRlICYmIG9wdGlvbnMub25Db21wbGV0ZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0QW5pbUZyYW1lKHRpY2spO1xuICAgICAgfSkoc3RhcnQpO1xuICAgIH0pO1xuXG4gIH1cblxuICB2YXIgX3JlcXVlc3RBbmltRnJhbWUgPSBmYWJyaWMud2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhYnJpYy53aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAvKipcbiAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHBvbHlmaWxsIGJhc2VkIG9uIGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXG4gICAqIEluIG9yZGVyIHRvIGdldCBhIHByZWNpc2Ugc3RhcnQgdGltZSwgYHJlcXVlc3RBbmltRnJhbWVgIHNob3VsZCBiZSBjYWxsZWQgYXMgYW4gZW50cnkgaW50byB0aGUgbWV0aG9kXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2VcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IG9wdGlvbmFsIEVsZW1lbnQgdG8gYXNzb2NpYXRlIHdpdGggYW5pbWF0aW9uXG4gICAqL1xuICBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKCkge1xuICAgIHJldHVybiBfcmVxdWVzdEFuaW1GcmFtZS5hcHBseShmYWJyaWMud2luZG93LCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZmFicmljLnV0aWwuYW5pbWF0ZSA9IGFuaW1hdGU7XG4gIGZhYnJpYy51dGlsLnJlcXVlc3RBbmltRnJhbWUgPSByZXF1ZXN0QW5pbUZyYW1lO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICBmdW5jdGlvbiBub3JtYWxpemUoYSwgYywgcCwgcykge1xuICAgIGlmIChhIDwgTWF0aC5hYnMoYykpIHtcbiAgICAgIGEgPSBjO1xuICAgICAgcyA9IHAgLyA0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vaGFuZGxlIHRoZSAwLzAgY2FzZTpcbiAgICAgIGlmIChjID09PSAwICYmIGEgPT09IDApIHtcbiAgICAgICAgcyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKDEpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbihjIC8gYSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGE6IGEsIGM6IGMsIHA6IHAsIHM6IHMgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVsYXN0aWMob3B0cywgdCwgZCkge1xuICAgIHJldHVybiBvcHRzLmEgKlxuICAgICAgTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKlxuICAgICAgTWF0aC5zaW4oICh0ICogZCAtIG9wdHMucykgKiAoMiAqIE1hdGguUEkpIC8gb3B0cy5wICk7XG4gIH1cblxuICAvKipcbiAgICogQ3ViaWMgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dEN1YmljKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogdCArIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdWJpYyBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0Q3ViaWModCwgYiwgYywgZCkge1xuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gYyAvIDIgKiB0ICogdCAqIHQgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogdCArIDIpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWFydGljIGVhc2luZyBpblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluUXVhcnQodCwgYiwgYywgZCkge1xuICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogdCAqIHQgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1YXJ0aWMgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dFF1YXJ0KHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gLWMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqIHQgKiB0IC0gMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1YXJ0aWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dFF1YXJ0KHQsIGIsIGMsIGQpIHtcbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKiB0ICogdCArIGI7XG4gICAgfVxuICAgIHJldHVybiAtYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgLSAyKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogUXVpbnRpYyBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJblF1aW50KHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqIHQgKiB0ICogdCArIGI7XG4gIH1cblxuICAvKipcbiAgICogUXVpbnRpYyBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0UXVpbnQodCwgYiwgYywgZCkge1xuICAgIHJldHVybiBjICogKCh0ID0gdCAvIGQgLSAxKSAqIHQgKiB0ICogdCAqIHQgKyAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogUXVpbnRpYyBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0UXVpbnQodCwgYiwgYywgZCkge1xuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gYyAvIDIgKiB0ICogdCAqIHQgKiB0ICogdCArIGI7XG4gICAgfVxuICAgIHJldHVybiBjIC8gMiAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogU2ludXNvaWRhbCBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJblNpbmUodCwgYiwgYywgZCkge1xuICAgIHJldHVybiAtYyAqIE1hdGguY29zKHQgLyBkICogKE1hdGguUEkgLyAyKSkgKyBjICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW51c29pZGFsIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRTaW5lKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqIE1hdGguc2luKHQgLyBkICogKE1hdGguUEkgLyAyKSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbnVzb2lkYWwgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dFNpbmUodCwgYiwgYywgZCkge1xuICAgIHJldHVybiAtYyAvIDIgKiAoTWF0aC5jb3MoTWF0aC5QSSAqIHQgLyBkKSAtIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvbmVudGlhbCBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbkV4cG8odCwgYiwgYywgZCkge1xuICAgIHJldHVybiAodCA9PT0gMCkgPyBiIDogYyAqIE1hdGgucG93KDIsIDEwICogKHQgLyBkIC0gMSkpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvbmVudGlhbCBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0RXhwbyh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuICh0ID09PSBkKSA/IGIgKyBjIDogYyAqICgtTWF0aC5wb3coMiwgLTEwICogdCAvIGQpICsgMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9uZW50aWFsIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRFeHBvKHQsIGIsIGMsIGQpIHtcbiAgICBpZiAodCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIGlmICh0ID09PSBkKSB7XG4gICAgICByZXR1cm4gYiArIGM7XG4gICAgfVxuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gYyAvIDIgKiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIGMgLyAyICogKC1NYXRoLnBvdygyLCAtMTAgKiAtLXQpICsgMikgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIENpcmN1bGFyIGVhc2luZyBpblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluQ2lyYyh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIC1jICogKE1hdGguc3FydCgxIC0gKHQgLz0gZCkgKiB0KSAtIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaXJjdWxhciBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0Q2lyYyh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiBNYXRoLnNxcnQoMSAtICh0ID0gdCAvIGQgLSAxKSAqIHQpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaXJjdWxhciBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0Q2lyYyh0LCBiLCBjLCBkKSB7XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA8IDEpIHtcbiAgICAgIHJldHVybiAtYyAvIDIgKiAoTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKSArIGI7XG4gICAgfVxuICAgIHJldHVybiBjIC8gMiAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogRWxhc3RpYyBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbkVsYXN0aWModCwgYiwgYywgZCkge1xuICAgIHZhciBzID0gMS43MDE1OCwgcCA9IDAsIGEgPSBjO1xuICAgIGlmICh0ID09PSAwKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgdCAvPSBkO1xuICAgIGlmICh0ID09PSAxKSB7XG4gICAgICByZXR1cm4gYiArIGM7XG4gICAgfVxuICAgIGlmICghcCkge1xuICAgICAgcCA9IGQgKiAwLjM7XG4gICAgfVxuICAgIHZhciBvcHRzID0gbm9ybWFsaXplKGEsIGMsIHAsIHMpO1xuICAgIHJldHVybiAtZWxhc3RpYyhvcHRzLCB0LCBkKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogRWxhc3RpYyBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0RWxhc3RpYyh0LCBiLCBjLCBkKSB7XG4gICAgdmFyIHMgPSAxLjcwMTU4LCBwID0gMCwgYSA9IGM7XG4gICAgaWYgKHQgPT09IDApIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICB0IC89IGQ7XG4gICAgaWYgKHQgPT09IDEpIHtcbiAgICAgIHJldHVybiBiICsgYztcbiAgICB9XG4gICAgaWYgKCFwKSB7XG4gICAgICBwID0gZCAqIDAuMztcbiAgICB9XG4gICAgdmFyIG9wdHMgPSBub3JtYWxpemUoYSwgYywgcCwgcyk7XG4gICAgcmV0dXJuIG9wdHMuYSAqIE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgKiBkIC0gb3B0cy5zKSAqICgyICogTWF0aC5QSSkgLyBvcHRzLnAgKSArIG9wdHMuYyArIGI7XG4gIH1cblxuICAvKipcbiAgICogRWxhc3RpYyBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0RWxhc3RpYyh0LCBiLCBjLCBkKSB7XG4gICAgdmFyIHMgPSAxLjcwMTU4LCBwID0gMCwgYSA9IGM7XG4gICAgaWYgKHQgPT09IDApIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0ID09PSAyKSB7XG4gICAgICByZXR1cm4gYiArIGM7XG4gICAgfVxuICAgIGlmICghcCkge1xuICAgICAgcCA9IGQgKiAoMC4zICogMS41KTtcbiAgICB9XG4gICAgdmFyIG9wdHMgPSBub3JtYWxpemUoYSwgYywgcCwgcyk7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gLTAuNSAqIGVsYXN0aWMob3B0cywgdCwgZCkgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gb3B0cy5hICogTWF0aC5wb3coMiwgLTEwICogKHQgLT0gMSkpICpcbiAgICAgIE1hdGguc2luKCh0ICogZCAtIG9wdHMucykgKiAoMiAqIE1hdGguUEkpIC8gb3B0cy5wICkgKiAwLjUgKyBvcHRzLmMgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhY2t3YXJkcyBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbkJhY2sodCwgYiwgYywgZCwgcykge1xuICAgIGlmIChzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHMgPSAxLjcwMTU4O1xuICAgIH1cbiAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqICgocyArIDEpICogdCAtIHMpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYWNrd2FyZHMgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dEJhY2sodCwgYiwgYywgZCwgcykge1xuICAgIGlmIChzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHMgPSAxLjcwMTU4O1xuICAgIH1cbiAgICByZXR1cm4gYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQmFja3dhcmRzIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRCYWNrKHQsIGIsIGMsIGQsIHMpIHtcbiAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzID0gMS43MDE1ODtcbiAgICB9XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA8IDEpIHtcbiAgICAgIHJldHVybiBjIC8gMiAqICh0ICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgLSBzKSkgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCArIHMpICsgMikgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEJvdW5jaW5nIGVhc2luZyBpblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluQm91bmNlKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAtIGVhc2VPdXRCb3VuY2UgKGQgLSB0LCAwLCBjLCBkKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQm91bmNpbmcgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dEJvdW5jZSh0LCBiLCBjLCBkKSB7XG4gICAgaWYgKCh0IC89IGQpIDwgKDEgLyAyLjc1KSkge1xuICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogdCAqIHQpICsgYjtcbiAgICB9XG4gICAgZWxzZSBpZiAodCA8ICgyIC8gMi43NSkpIHtcbiAgICAgIHJldHVybiBjICogKDcuNTYyNSAqICh0IC09ICgxLjUgLyAyLjc1KSkgKiB0ICsgMC43NSkgKyBiO1xuICAgIH1cbiAgICBlbHNlIGlmICh0IDwgKDIuNSAvIDIuNzUpKSB7XG4gICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiAodCAtPSAoMi4yNSAvIDIuNzUpKSAqIHQgKyAwLjkzNzUpICsgYjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiAodCAtPSAoMi42MjUgLyAyLjc1KSkgKiB0ICsgMC45ODQzNzUpICsgYjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQm91bmNpbmcgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dEJvdW5jZSh0LCBiLCBjLCBkKSB7XG4gICAgaWYgKHQgPCBkIC8gMikge1xuICAgICAgcmV0dXJuIGVhc2VJbkJvdW5jZSAodCAqIDIsIDAsIGMsIGQpICogMC41ICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIGVhc2VPdXRCb3VuY2UodCAqIDIgLSBkLCAwLCBjLCBkKSAqIDAuNSArIGMgKiAwLjUgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEVhc2luZyBmdW5jdGlvbnNcbiAgICogU2VlIDxhIGhyZWY9XCJodHRwOi8vZ2l6bWEuY29tL2Vhc2luZy9cIj5FYXNpbmcgRXF1YXRpb25zIGJ5IFJvYmVydCBQZW5uZXI8L2E+XG4gICAqIEBuYW1lc3BhY2UgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZmFicmljLnV0aWwuZWFzZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFF1YWRyYXRpYyBlYXNpbmcgaW5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgICAqL1xuICAgIGVhc2VJblF1YWQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUXVhZHJhdGljIGVhc2luZyBvdXRcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgICAqL1xuICAgIGVhc2VPdXRRdWFkOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICByZXR1cm4gLWMgKiAodCAvPSBkKSAqICh0IC0gMikgKyBiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBRdWFkcmF0aWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgICAqL1xuICAgIGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIHQgLz0gKGQgLyAyKTtcbiAgICAgIGlmICh0IDwgMSkge1xuICAgICAgICByZXR1cm4gYyAvIDIgKiB0ICogdCArIGI7XG4gICAgICB9XG4gICAgICByZXR1cm4gLWMgLyAyICogKCgtLXQpICogKHQgLSAyKSAtIDEpICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3ViaWMgZWFzaW5nIGluXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICAgKi9cbiAgICBlYXNlSW5DdWJpYzogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiB0ICsgYjtcbiAgICB9LFxuXG4gICAgZWFzZU91dEN1YmljOiBlYXNlT3V0Q3ViaWMsXG4gICAgZWFzZUluT3V0Q3ViaWM6IGVhc2VJbk91dEN1YmljLFxuICAgIGVhc2VJblF1YXJ0OiBlYXNlSW5RdWFydCxcbiAgICBlYXNlT3V0UXVhcnQ6IGVhc2VPdXRRdWFydCxcbiAgICBlYXNlSW5PdXRRdWFydDogZWFzZUluT3V0UXVhcnQsXG4gICAgZWFzZUluUXVpbnQ6IGVhc2VJblF1aW50LFxuICAgIGVhc2VPdXRRdWludDogZWFzZU91dFF1aW50LFxuICAgIGVhc2VJbk91dFF1aW50OiBlYXNlSW5PdXRRdWludCxcbiAgICBlYXNlSW5TaW5lOiBlYXNlSW5TaW5lLFxuICAgIGVhc2VPdXRTaW5lOiBlYXNlT3V0U2luZSxcbiAgICBlYXNlSW5PdXRTaW5lOiBlYXNlSW5PdXRTaW5lLFxuICAgIGVhc2VJbkV4cG86IGVhc2VJbkV4cG8sXG4gICAgZWFzZU91dEV4cG86IGVhc2VPdXRFeHBvLFxuICAgIGVhc2VJbk91dEV4cG86IGVhc2VJbk91dEV4cG8sXG4gICAgZWFzZUluQ2lyYzogZWFzZUluQ2lyYyxcbiAgICBlYXNlT3V0Q2lyYzogZWFzZU91dENpcmMsXG4gICAgZWFzZUluT3V0Q2lyYzogZWFzZUluT3V0Q2lyYyxcbiAgICBlYXNlSW5FbGFzdGljOiBlYXNlSW5FbGFzdGljLFxuICAgIGVhc2VPdXRFbGFzdGljOiBlYXNlT3V0RWxhc3RpYyxcbiAgICBlYXNlSW5PdXRFbGFzdGljOiBlYXNlSW5PdXRFbGFzdGljLFxuICAgIGVhc2VJbkJhY2s6IGVhc2VJbkJhY2ssXG4gICAgZWFzZU91dEJhY2s6IGVhc2VPdXRCYWNrLFxuICAgIGVhc2VJbk91dEJhY2s6IGVhc2VJbk91dEJhY2ssXG4gICAgZWFzZUluQm91bmNlOiBlYXNlSW5Cb3VuY2UsXG4gICAgZWFzZU91dEJvdW5jZTogZWFzZU91dEJvdW5jZSxcbiAgICBlYXNlSW5PdXRCb3VuY2U6IGVhc2VJbk91dEJvdW5jZVxuICB9O1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIEBuYW1lIGZhYnJpY1xuICAgKiBAbmFtZXNwYWNlXG4gICAqL1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBjYXBpdGFsaXplID0gZmFicmljLnV0aWwuc3RyaW5nLmNhcGl0YWxpemUsXG4gICAgICBjbG9uZSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZSxcbiAgICAgIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkLFxuICAgICAgcGFyc2VVbml0ID0gZmFicmljLnV0aWwucGFyc2VVbml0LFxuICAgICAgbXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyA9IGZhYnJpYy51dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMsXG5cbiAgICAgIHJlQWxsb3dlZFNWR1RhZ05hbWVzID0gL14ocGF0aHxjaXJjbGV8cG9seWdvbnxwb2x5bGluZXxlbGxpcHNlfHJlY3R8bGluZXxpbWFnZXx0ZXh0KSQvaSxcbiAgICAgIHJlVmlld0JveFRhZ05hbWVzID0gL14oc3ltYm9sfGltYWdlfG1hcmtlcnxwYXR0ZXJufHZpZXd8c3ZnKSQvaSxcbiAgICAgIHJlTm90QWxsb3dlZEFuY2VzdG9ycyA9IC9eKD86cGF0dGVybnxkZWZzfHN5bWJvbHxtZXRhZGF0YSkkL2ksXG4gICAgICByZUFsbG93ZWRQYXJlbnRzID0gL14oc3ltYm9sfGd8YXxzdmcpJC9pLFxuXG4gICAgICBhdHRyaWJ1dGVzTWFwID0ge1xuICAgICAgICBjeDogICAgICAgICAgICAgICAgICAgJ2xlZnQnLFxuICAgICAgICB4OiAgICAgICAgICAgICAgICAgICAgJ2xlZnQnLFxuICAgICAgICByOiAgICAgICAgICAgICAgICAgICAgJ3JhZGl1cycsXG4gICAgICAgIGN5OiAgICAgICAgICAgICAgICAgICAndG9wJyxcbiAgICAgICAgeTogICAgICAgICAgICAgICAgICAgICd0b3AnLFxuICAgICAgICBkaXNwbGF5OiAgICAgICAgICAgICAgJ3Zpc2libGUnLFxuICAgICAgICB2aXNpYmlsaXR5OiAgICAgICAgICAgJ3Zpc2libGUnLFxuICAgICAgICB0cmFuc2Zvcm06ICAgICAgICAgICAgJ3RyYW5zZm9ybU1hdHJpeCcsXG4gICAgICAgICdmaWxsLW9wYWNpdHknOiAgICAgICAnZmlsbE9wYWNpdHknLFxuICAgICAgICAnZmlsbC1ydWxlJzogICAgICAgICAgJ2ZpbGxSdWxlJyxcbiAgICAgICAgJ2ZvbnQtZmFtaWx5JzogICAgICAgICdmb250RmFtaWx5JyxcbiAgICAgICAgJ2ZvbnQtc2l6ZSc6ICAgICAgICAgICdmb250U2l6ZScsXG4gICAgICAgICdmb250LXN0eWxlJzogICAgICAgICAnZm9udFN0eWxlJyxcbiAgICAgICAgJ2ZvbnQtd2VpZ2h0JzogICAgICAgICdmb250V2VpZ2h0JyxcbiAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiAgICdzdHJva2VEYXNoQXJyYXknLFxuICAgICAgICAnc3Ryb2tlLWxpbmVjYXAnOiAgICAgJ3N0cm9rZUxpbmVDYXAnLFxuICAgICAgICAnc3Ryb2tlLWxpbmVqb2luJzogICAgJ3N0cm9rZUxpbmVKb2luJyxcbiAgICAgICAgJ3N0cm9rZS1taXRlcmxpbWl0JzogICdzdHJva2VNaXRlckxpbWl0JyxcbiAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogICAgICdzdHJva2VPcGFjaXR5JyxcbiAgICAgICAgJ3N0cm9rZS13aWR0aCc6ICAgICAgICdzdHJva2VXaWR0aCcsXG4gICAgICAgICd0ZXh0LWRlY29yYXRpb24nOiAgICAndGV4dERlY29yYXRpb24nLFxuICAgICAgICAndGV4dC1hbmNob3InOiAgICAgICAgJ29yaWdpblgnXG4gICAgICB9LFxuXG4gICAgICBjb2xvckF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIHN0cm9rZTogJ3N0cm9rZU9wYWNpdHknLFxuICAgICAgICBmaWxsOiAgICdmaWxsT3BhY2l0eSdcbiAgICAgIH07XG5cbiAgZmFicmljLmNzc1J1bGVzID0geyB9O1xuICBmYWJyaWMuZ3JhZGllbnREZWZzID0geyB9O1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUF0dHIoYXR0cikge1xuICAgIC8vIHRyYW5zZm9ybSBhdHRyaWJ1dGUgbmFtZXNcbiAgICBpZiAoYXR0ciBpbiBhdHRyaWJ1dGVzTWFwKSB7XG4gICAgICByZXR1cm4gYXR0cmlidXRlc01hcFthdHRyXTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHI7XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZShhdHRyLCB2YWx1ZSwgcGFyZW50QXR0cmlidXRlcywgZm9udFNpemUpIHtcbiAgICB2YXIgaXNBcnJheSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICAgIHBhcnNlZDtcblxuICAgIGlmICgoYXR0ciA9PT0gJ2ZpbGwnIHx8IGF0dHIgPT09ICdzdHJva2UnKSAmJiB2YWx1ZSA9PT0gJ25vbmUnKSB7XG4gICAgICB2YWx1ZSA9ICcnO1xuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAnc3Ryb2tlRGFzaEFycmF5Jykge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8sL2csICcgJykuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChuKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAndHJhbnNmb3JtTWF0cml4Jykge1xuICAgICAgaWYgKHBhcmVudEF0dHJpYnV0ZXMgJiYgcGFyZW50QXR0cmlidXRlcy50cmFuc2Zvcm1NYXRyaXgpIHtcbiAgICAgICAgdmFsdWUgPSBtdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKFxuICAgICAgICAgIHBhcmVudEF0dHJpYnV0ZXMudHJhbnNmb3JtTWF0cml4LCBmYWJyaWMucGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGZhYnJpYy5wYXJzZVRyYW5zZm9ybUF0dHJpYnV0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICd2aXNpYmxlJykge1xuICAgICAgdmFsdWUgPSAodmFsdWUgPT09ICdub25lJyB8fCB2YWx1ZSA9PT0gJ2hpZGRlbicpID8gZmFsc2UgOiB0cnVlO1xuICAgICAgLy8gZGlzcGxheT1ub25lIG9uIHBhcmVudCBlbGVtZW50IGFsd2F5cyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgY2hpbGQgZWxlbWVudFxuICAgICAgaWYgKHBhcmVudEF0dHJpYnV0ZXMgJiYgcGFyZW50QXR0cmlidXRlcy52aXNpYmxlID09PSBmYWxzZSkge1xuICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAnb3JpZ2luWCcgLyogdGV4dC1hbmNob3IgKi8pIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgPT09ICdzdGFydCcgPyAnbGVmdCcgOiB2YWx1ZSA9PT0gJ2VuZCcgPyAncmlnaHQnIDogJ2NlbnRlcic7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcGFyc2VkID0gaXNBcnJheSA/IHZhbHVlLm1hcChwYXJzZVVuaXQpIDogcGFyc2VVbml0KHZhbHVlLCBmb250U2l6ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICghaXNBcnJheSAmJiBpc05hTihwYXJzZWQpID8gdmFsdWUgOiBwYXJzZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzIEFycmF5IG9mIGF0dHJpYnV0ZXMgdG8gcGFyc2VcbiAgICovXG4gIGZ1bmN0aW9uIF9zZXRTdHJva2VGaWxsT3BhY2l0eShhdHRyaWJ1dGVzKSB7XG4gICAgZm9yICh2YXIgYXR0ciBpbiBjb2xvckF0dHJpYnV0ZXMpIHtcblxuICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzW2NvbG9yQXR0cmlidXRlc1thdHRyXV0gPT09ICd1bmRlZmluZWQnIHx8IGF0dHJpYnV0ZXNbYXR0cl0gPT09ICcnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXNbYXR0cl0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICghZmFicmljLk9iamVjdC5wcm90b3R5cGVbYXR0cl0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBhdHRyaWJ1dGVzW2F0dHJdID0gZmFicmljLk9iamVjdC5wcm90b3R5cGVbYXR0cl07XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRyaWJ1dGVzW2F0dHJdLmluZGV4T2YoJ3VybCgnKSA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcihhdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICAgIGF0dHJpYnV0ZXNbYXR0cl0gPSBjb2xvci5zZXRBbHBoYSh0b0ZpeGVkKGNvbG9yLmdldEFscGhhKCkgKiBhdHRyaWJ1dGVzW2NvbG9yQXR0cmlidXRlc1thdHRyXV0sIDIpKS50b1JnYmEoKTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9nZXRNdWx0aXBsZU5vZGVzKGRvYywgbm9kZU5hbWVzKSB7XG4gICAgdmFyIG5vZGVOYW1lLCBub2RlQXJyYXkgPSBbXSwgbm9kZUxpc3Q7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGVOYW1lID0gbm9kZU5hbWVzW2ldO1xuICAgICAgbm9kZUxpc3QgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUobm9kZU5hbWUpO1xuICAgICAgbm9kZUFycmF5ID0gbm9kZUFycmF5LmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChub2RlTGlzdCkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZUFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBcInRyYW5zZm9ybVwiIGF0dHJpYnV0ZSwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHZhbHVlc1xuICAgKiBAc3RhdGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVWYWx1ZSBTdHJpbmcgY29udGFpbmluZyBhdHRyaWJ1dGUgdmFsdWVcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIDYgZWxlbWVudHMgcmVwcmVzZW50aW5nIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuICAgKi9cbiAgZmFicmljLnBhcnNlVHJhbnNmb3JtQXR0cmlidXRlID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIHJvdGF0ZU1hdHJpeChtYXRyaXgsIGFyZ3MpIHtcbiAgICAgIHZhciBhbmdsZSA9IGFyZ3NbMF0sXG4gICAgICAgICAgeCA9IChhcmdzLmxlbmd0aCA9PT0gMykgPyBhcmdzWzFdIDogMCxcbiAgICAgICAgICB5ID0gKGFyZ3MubGVuZ3RoID09PSAzKSA/IGFyZ3NbMl0gOiAwO1xuXG4gICAgICBtYXRyaXhbMF0gPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICBtYXRyaXhbMV0gPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgICBtYXRyaXhbMl0gPSAtTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgbWF0cml4WzNdID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgbWF0cml4WzRdID0geCAtIChtYXRyaXhbMF0gKiB4ICsgbWF0cml4WzJdICogeSk7XG4gICAgICBtYXRyaXhbNV0gPSB5IC0gKG1hdHJpeFsxXSAqIHggKyBtYXRyaXhbM10gKiB5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FsZU1hdHJpeChtYXRyaXgsIGFyZ3MpIHtcbiAgICAgIHZhciBtdWx0aXBsaWVyWCA9IGFyZ3NbMF0sXG4gICAgICAgICAgbXVsdGlwbGllclkgPSAoYXJncy5sZW5ndGggPT09IDIpID8gYXJnc1sxXSA6IGFyZ3NbMF07XG5cbiAgICAgIG1hdHJpeFswXSA9IG11bHRpcGxpZXJYO1xuICAgICAgbWF0cml4WzNdID0gbXVsdGlwbGllclk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2tld1hNYXRyaXgobWF0cml4LCBhcmdzKSB7XG4gICAgICBtYXRyaXhbMl0gPSBNYXRoLnRhbihmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKGFyZ3NbMF0pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBza2V3WU1hdHJpeChtYXRyaXgsIGFyZ3MpIHtcbiAgICAgIG1hdHJpeFsxXSA9IE1hdGgudGFuKGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMoYXJnc1swXSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZU1hdHJpeChtYXRyaXgsIGFyZ3MpIHtcbiAgICAgIG1hdHJpeFs0XSA9IGFyZ3NbMF07XG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgbWF0cml4WzVdID0gYXJnc1sxXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZGVudGl0eSBtYXRyaXhcbiAgICB2YXIgaU1hdHJpeCA9IFtcbiAgICAgICAgICAxLCAvLyBhXG4gICAgICAgICAgMCwgLy8gYlxuICAgICAgICAgIDAsIC8vIGNcbiAgICAgICAgICAxLCAvLyBkXG4gICAgICAgICAgMCwgLy8gZVxuICAgICAgICAgIDAgIC8vIGZcbiAgICAgICAgXSxcblxuICAgICAgICAvLyA9PSBiZWdpbiB0cmFuc2Zvcm0gcmVnZXhwXG4gICAgICAgIG51bWJlciA9IGZhYnJpYy5yZU51bSxcblxuICAgICAgICBjb21tYVdzcCA9ICcoPzpcXFxccyssP1xcXFxzKnwsXFxcXHMqKScsXG5cbiAgICAgICAgc2tld1ggPSAnKD86KHNrZXdYKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgc2tld1kgPSAnKD86KHNrZXdZKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgcm90YXRlID0gJyg/Oihyb3RhdGUpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciArICcpKD86JyArXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hV3NwICsgJygnICsgbnVtYmVyICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFXc3AgKyAnKCcgKyBudW1iZXIgKyAnKSk/XFxcXHMqXFxcXCkpJyxcblxuICAgICAgICBzY2FsZSA9ICcoPzooc2NhbGUpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciArICcpKD86JyArXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hV3NwICsgJygnICsgbnVtYmVyICsgJykpP1xcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgdHJhbnNsYXRlID0gJyg/Oih0cmFuc2xhdGUpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciArICcpKD86JyArXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hV3NwICsgJygnICsgbnVtYmVyICsgJykpP1xcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgbWF0cml4ID0gJyg/OihtYXRyaXgpXFxcXHMqXFxcXChcXFxccyonICtcbiAgICAgICAgICAgICAgICAgICcoJyArIG51bWJlciArICcpJyArIGNvbW1hV3NwICtcbiAgICAgICAgICAgICAgICAgICcoJyArIG51bWJlciArICcpJyArIGNvbW1hV3NwICtcbiAgICAgICAgICAgICAgICAgICcoJyArIG51bWJlciArICcpJyArIGNvbW1hV3NwICtcbiAgICAgICAgICAgICAgICAgICcoJyArIG51bWJlciArICcpJyArIGNvbW1hV3NwICtcbiAgICAgICAgICAgICAgICAgICcoJyArIG51bWJlciArICcpJyArIGNvbW1hV3NwICtcbiAgICAgICAgICAgICAgICAgICcoJyArIG51bWJlciArICcpJyArXG4gICAgICAgICAgICAgICAgICAnXFxcXHMqXFxcXCkpJyxcblxuICAgICAgICB0cmFuc2Zvcm0gPSAnKD86JyArXG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeCArICd8JyArXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZSArICd8JyArXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlICsgJ3wnICtcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlICsgJ3wnICtcbiAgICAgICAgICAgICAgICAgICAgc2tld1ggKyAnfCcgK1xuICAgICAgICAgICAgICAgICAgICBza2V3WSArXG4gICAgICAgICAgICAgICAgICAgICcpJyxcblxuICAgICAgICB0cmFuc2Zvcm1zID0gJyg/OicgKyB0cmFuc2Zvcm0gKyAnKD86JyArIGNvbW1hV3NwICsgJyonICsgdHJhbnNmb3JtICsgJykqJyArICcpJyxcblxuICAgICAgICB0cmFuc2Zvcm1MaXN0ID0gJ15cXFxccyooPzonICsgdHJhbnNmb3JtcyArICc/KVxcXFxzKiQnLFxuXG4gICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9jb29yZHMuaHRtbCNUcmFuc2Zvcm1BdHRyaWJ1dGVcbiAgICAgICAgcmVUcmFuc2Zvcm1MaXN0ID0gbmV3IFJlZ0V4cCh0cmFuc2Zvcm1MaXN0KSxcbiAgICAgICAgLy8gPT0gZW5kIHRyYW5zZm9ybSByZWdleHBcblxuICAgICAgICByZVRyYW5zZm9ybSA9IG5ldyBSZWdFeHAodHJhbnNmb3JtLCAnZycpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGF0dHJpYnV0ZVZhbHVlKSB7XG5cbiAgICAgIC8vIHN0YXJ0IHdpdGggaWRlbnRpdHkgbWF0cml4XG4gICAgICB2YXIgbWF0cml4ID0gaU1hdHJpeC5jb25jYXQoKSxcbiAgICAgICAgICBtYXRyaWNlcyA9IFtdO1xuXG4gICAgICAvLyByZXR1cm4gaWYgbm8gYXJndW1lbnQgd2FzIGdpdmVuIG9yXG4gICAgICAvLyBhbiBhcmd1bWVudCBkb2VzIG5vdCBtYXRjaCB0cmFuc2Zvcm0gYXR0cmlidXRlIHJlZ2V4cFxuICAgICAgaWYgKCFhdHRyaWJ1dGVWYWx1ZSB8fCAoYXR0cmlidXRlVmFsdWUgJiYgIXJlVHJhbnNmb3JtTGlzdC50ZXN0KGF0dHJpYnV0ZVZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICAgIH1cblxuICAgICAgYXR0cmlidXRlVmFsdWUucmVwbGFjZShyZVRyYW5zZm9ybSwgZnVuY3Rpb24obWF0Y2gpIHtcblxuICAgICAgICB2YXIgbSA9IG5ldyBSZWdFeHAodHJhbnNmb3JtKS5leGVjKG1hdGNoKS5maWx0ZXIoZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgIC8vIG1hdGNoICE9PSAnJyAmJiBtYXRjaCAhPSBudWxsXG4gICAgICAgICAgICAgIHJldHVybiAoISFtYXRjaCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IG1bMV0sXG4gICAgICAgICAgICBhcmdzID0gbS5zbGljZSgyKS5tYXAocGFyc2VGbG9hdCk7XG5cbiAgICAgICAgc3dpdGNoIChvcGVyYXRpb24pIHtcbiAgICAgICAgICBjYXNlICd0cmFuc2xhdGUnOlxuICAgICAgICAgICAgdHJhbnNsYXRlTWF0cml4KG1hdHJpeCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyb3RhdGUnOlxuICAgICAgICAgICAgYXJnc1swXSA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMoYXJnc1swXSk7XG4gICAgICAgICAgICByb3RhdGVNYXRyaXgobWF0cml4LCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NjYWxlJzpcbiAgICAgICAgICAgIHNjYWxlTWF0cml4KG1hdHJpeCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdza2V3WCc6XG4gICAgICAgICAgICBza2V3WE1hdHJpeChtYXRyaXgsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2tld1knOlxuICAgICAgICAgICAgc2tld1lNYXRyaXgobWF0cml4LCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ21hdHJpeCc6XG4gICAgICAgICAgICBtYXRyaXggPSBhcmdzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzbmFwc2hvdCBjdXJyZW50IG1hdHJpeCBpbnRvIG1hdHJpY2VzIGFycmF5XG4gICAgICAgIG1hdHJpY2VzLnB1c2gobWF0cml4LmNvbmNhdCgpKTtcbiAgICAgICAgLy8gcmVzZXRcbiAgICAgICAgbWF0cml4ID0gaU1hdHJpeC5jb25jYXQoKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgY29tYmluZWRNYXRyaXggPSBtYXRyaWNlc1swXTtcbiAgICAgIHdoaWxlIChtYXRyaWNlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIG1hdHJpY2VzLnNoaWZ0KCk7XG4gICAgICAgIGNvbWJpbmVkTWF0cml4ID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyhjb21iaW5lZE1hdHJpeCwgbWF0cmljZXNbMF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbWJpbmVkTWF0cml4O1xuICAgIH07XG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVN0eWxlU3RyaW5nKHN0eWxlLCBvU3R5bGUpIHtcbiAgICB2YXIgYXR0ciwgdmFsdWU7XG4gICAgc3R5bGUucmVwbGFjZSgvO1xccyokLywgJycpLnNwbGl0KCc7JykuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHZhciBwYWlyID0gY2h1bmsuc3BsaXQoJzonKTtcblxuICAgICAgYXR0ciA9IG5vcm1hbGl6ZUF0dHIocGFpclswXS50cmltKCkudG9Mb3dlckNhc2UoKSk7XG4gICAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKGF0dHIsIHBhaXJbMV0udHJpbSgpKTtcblxuICAgICAgb1N0eWxlW2F0dHJdID0gdmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlU3R5bGVPYmplY3Qoc3R5bGUsIG9TdHlsZSkge1xuICAgIHZhciBhdHRyLCB2YWx1ZTtcbiAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgICBpZiAodHlwZW9mIHN0eWxlW3Byb3BdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYXR0ciA9IG5vcm1hbGl6ZUF0dHIocHJvcC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUoYXR0ciwgc3R5bGVbcHJvcF0pO1xuXG4gICAgICBvU3R5bGVbYXR0cl0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGdldEdsb2JhbFN0eWxlc0ZvckVsZW1lbnQoZWxlbWVudCwgc3ZnVWlkKSB7XG4gICAgdmFyIHN0eWxlcyA9IHsgfTtcbiAgICBmb3IgKHZhciBydWxlIGluIGZhYnJpYy5jc3NSdWxlc1tzdmdVaWRdKSB7XG4gICAgICBpZiAoZWxlbWVudE1hdGNoZXNSdWxlKGVsZW1lbnQsIHJ1bGUuc3BsaXQoJyAnKSkpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gZmFicmljLmNzc1J1bGVzW3N2Z1VpZF1bcnVsZV0pIHtcbiAgICAgICAgICBzdHlsZXNbcHJvcGVydHldID0gZmFicmljLmNzc1J1bGVzW3N2Z1VpZF1bcnVsZV1bcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHlsZXM7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVzUnVsZShlbGVtZW50LCBzZWxlY3RvcnMpIHtcbiAgICB2YXIgZmlyc3RNYXRjaGluZywgcGFyZW50TWF0Y2hpbmcgPSB0cnVlO1xuICAgIC8vc3RhcnQgZnJvbSByaWdodG1vc3Qgc2VsZWN0b3IuXG4gICAgZmlyc3RNYXRjaGluZyA9IHNlbGVjdG9yTWF0Y2hlcyhlbGVtZW50LCBzZWxlY3RvcnMucG9wKCkpO1xuICAgIGlmIChmaXJzdE1hdGNoaW5nICYmIHNlbGVjdG9ycy5sZW5ndGgpIHtcbiAgICAgIHBhcmVudE1hdGNoaW5nID0gZG9lc1NvbWVQYXJlbnRNYXRjaChlbGVtZW50LCBzZWxlY3RvcnMpO1xuICAgIH1cbiAgICByZXR1cm4gZmlyc3RNYXRjaGluZyAmJiBwYXJlbnRNYXRjaGluZyAmJiAoc2VsZWN0b3JzLmxlbmd0aCA9PT0gMCk7XG4gIH1cblxuICBmdW5jdGlvbiBkb2VzU29tZVBhcmVudE1hdGNoKGVsZW1lbnQsIHNlbGVjdG9ycykge1xuICAgIHZhciBzZWxlY3RvciwgcGFyZW50TWF0Y2hpbmcgPSB0cnVlO1xuICAgIHdoaWxlIChlbGVtZW50LnBhcmVudE5vZGUgJiYgZWxlbWVudC5wYXJlbnROb2RlLm5vZGVUeXBlID09PSAxICYmIHNlbGVjdG9ycy5sZW5ndGgpIHtcbiAgICAgIGlmIChwYXJlbnRNYXRjaGluZykge1xuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9ycy5wb3AoKTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICBwYXJlbnRNYXRjaGluZyA9IHNlbGVjdG9yTWF0Y2hlcyhlbGVtZW50LCBzZWxlY3Rvcik7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RvcnMubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBzZWxlY3Rvck1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLFxuICAgICAgICBjbGFzc05hbWVzID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJyksXG4gICAgICAgIGlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lkJyksIG1hdGNoZXI7XG4gICAgLy8gaSBjaGVjayBpZiBhIHNlbGVjdG9yIG1hdGNoZXMgc2xpY2luZyBhd2F5IHBhcnQgZnJvbSBpdC5cbiAgICAvLyBpZiBpIGdldCBlbXB0eSBzdHJpbmcgaSBzaG91bGQgbWF0Y2hcbiAgICBtYXRjaGVyID0gbmV3IFJlZ0V4cCgnXicgKyBub2RlTmFtZSwgJ2knKTtcbiAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UobWF0Y2hlciwgJycpO1xuICAgIGlmIChpZCAmJiBzZWxlY3Rvci5sZW5ndGgpIHtcbiAgICAgIG1hdGNoZXIgPSBuZXcgUmVnRXhwKCcjJyArIGlkICsgJyg/IVthLXpBLVpcXFxcLV0rKScsICdpJyk7XG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UobWF0Y2hlciwgJycpO1xuICAgIH1cbiAgICBpZiAoY2xhc3NOYW1lcyAmJiBzZWxlY3Rvci5sZW5ndGgpIHtcbiAgICAgIGNsYXNzTmFtZXMgPSBjbGFzc05hbWVzLnNwbGl0KCcgJyk7XG4gICAgICBmb3IgKHZhciBpID0gY2xhc3NOYW1lcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgbWF0Y2hlciA9IG5ldyBSZWdFeHAoJ1xcXFwuJyArIGNsYXNzTmFtZXNbaV0gKyAnKD8hW2EtekEtWlxcXFwtXSspJywgJ2knKTtcbiAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKG1hdGNoZXIsICcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdG9yLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiB0byBzdXBwb3J0IElFOCBtaXNzaW5nIGdldEVsZW1lbnRCeUlkIG9uIFNWR2RvY3VtZW50XG4gICAqL1xuICBmdW5jdGlvbiBlbGVtZW50QnlJZChkb2MsIGlkKSB7XG4gICAgdmFyIGVsO1xuICAgIGRvYy5nZXRFbGVtZW50QnlJZCAmJiAoZWwgPSBkb2MuZ2V0RWxlbWVudEJ5SWQoaWQpKTtcbiAgICBpZiAoZWwpIHtcbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gICAgdmFyIG5vZGUsIGksIG5vZGVsaXN0ID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJyk7XG4gICAgZm9yIChpID0gMDsgaSA8IG5vZGVsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlID0gbm9kZWxpc3RbaV07XG4gICAgICBpZiAoaWQgPT09IG5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VVc2VEaXJlY3RpdmVzKGRvYykge1xuICAgIHZhciBub2RlbGlzdCA9IF9nZXRNdWx0aXBsZU5vZGVzKGRvYywgWyd1c2UnLCAnc3ZnOnVzZSddKSwgaSA9IDA7XG5cbiAgICB3aGlsZSAobm9kZWxpc3QubGVuZ3RoICYmIGkgPCBub2RlbGlzdC5sZW5ndGgpIHtcbiAgICAgIHZhciBlbCA9IG5vZGVsaXN0W2ldLFxuICAgICAgICAgIHhsaW5rID0gZWwuZ2V0QXR0cmlidXRlKCd4bGluazpocmVmJykuc3Vic3RyKDEpLFxuICAgICAgICAgIHggPSBlbC5nZXRBdHRyaWJ1dGUoJ3gnKSB8fCAwLFxuICAgICAgICAgIHkgPSBlbC5nZXRBdHRyaWJ1dGUoJ3knKSB8fCAwLFxuICAgICAgICAgIGVsMiA9IGVsZW1lbnRCeUlkKGRvYywgeGxpbmspLmNsb25lTm9kZSh0cnVlKSxcbiAgICAgICAgICBjdXJyZW50VHJhbnMgPSAoZWwyLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJykgfHwgJycpICsgJyB0cmFuc2xhdGUoJyArIHggKyAnLCAnICsgeSArICcpJyxcbiAgICAgICAgICBwYXJlbnROb2RlLCBvbGRMZW5ndGggPSBub2RlbGlzdC5sZW5ndGgsIGF0dHIsIGosIGF0dHJzLCBsO1xuXG4gICAgICBhcHBseVZpZXdib3hUcmFuc2Zvcm0oZWwyKTtcbiAgICAgIGlmICgvXnN2ZyQvaS50ZXN0KGVsMi5ub2RlTmFtZSkpIHtcbiAgICAgICAgdmFyIGVsMyA9IGVsMi5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2cnKTtcbiAgICAgICAgZm9yIChqID0gMCwgYXR0cnMgPSBlbDIuYXR0cmlidXRlcywgbCA9IGF0dHJzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgICAgIGF0dHIgPSBhdHRycy5pdGVtKGopO1xuICAgICAgICAgIGVsMy5zZXRBdHRyaWJ1dGUoYXR0ci5ub2RlTmFtZSwgYXR0ci5ub2RlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVsMi5maXJzdENoaWxkICE9IG51bGxcbiAgICAgICAgd2hpbGUgKGVsMi5maXJzdENoaWxkKSB7XG4gICAgICAgICAgZWwzLmFwcGVuZENoaWxkKGVsMi5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBlbDIgPSBlbDM7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaiA9IDAsIGF0dHJzID0gZWwuYXR0cmlidXRlcywgbCA9IGF0dHJzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgICBhdHRyID0gYXR0cnMuaXRlbShqKTtcbiAgICAgICAgaWYgKGF0dHIubm9kZU5hbWUgPT09ICd4JyB8fCBhdHRyLm5vZGVOYW1lID09PSAneScgfHwgYXR0ci5ub2RlTmFtZSA9PT0gJ3hsaW5rOmhyZWYnKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXR0ci5ub2RlTmFtZSA9PT0gJ3RyYW5zZm9ybScpIHtcbiAgICAgICAgICBjdXJyZW50VHJhbnMgPSBhdHRyLm5vZGVWYWx1ZSArICcgJyArIGN1cnJlbnRUcmFucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBlbDIuc2V0QXR0cmlidXRlKGF0dHIubm9kZU5hbWUsIGF0dHIubm9kZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbDIuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBjdXJyZW50VHJhbnMpO1xuICAgICAgZWwyLnNldEF0dHJpYnV0ZSgnaW5zdGFudGlhdGVkX2J5X3VzZScsICcxJyk7XG4gICAgICBlbDIucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xuICAgICAgcGFyZW50Tm9kZSA9IGVsLnBhcmVudE5vZGU7XG4gICAgICBwYXJlbnROb2RlLnJlcGxhY2VDaGlsZChlbDIsIGVsKTtcbiAgICAgIC8vIHNvbWUgYnJvd3NlcnMgZG8gbm90IHNob3J0ZW4gbm9kZWxpc3QgYWZ0ZXIgcmVwbGFjZUNoaWxkIChJRTgpXG4gICAgICBpZiAobm9kZWxpc3QubGVuZ3RoID09PSBvbGRMZW5ndGgpIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9jb29yZHMuaHRtbCNWaWV3Qm94QXR0cmlidXRlXG4gIC8vIG1hdGNoZXMsIGUuZy46ICsxNC41NmUtMTIsIGV0Yy5cbiAgdmFyIHJlVmlld0JveEF0dHJWYWx1ZSA9IG5ldyBSZWdFeHAoXG4gICAgJ14nICtcbiAgICAnXFxcXHMqKCcgKyBmYWJyaWMucmVOdW0gKyAnKylcXFxccyosPycgK1xuICAgICdcXFxccyooJyArIGZhYnJpYy5yZU51bSArICcrKVxcXFxzKiw/JyArXG4gICAgJ1xcXFxzKignICsgZmFicmljLnJlTnVtICsgJyspXFxcXHMqLD8nICtcbiAgICAnXFxcXHMqKCcgKyBmYWJyaWMucmVOdW0gKyAnKylcXFxccyonICtcbiAgICAnJCdcbiAgKTtcblxuICAvKipcbiAgICogQWRkIGEgPGc+IGVsZW1lbnQgdGhhdCBlbnZlbG9wIGFsbCBjaGlsZCBlbGVtZW50cyBhbmQgbWFrZXMgdGhlIHZpZXdib3ggdHJhbnNmb3JtTWF0cml4IGRlc2NlbmQgb24gYWxsIGVsZW1lbnRzXG4gICAqL1xuICBmdW5jdGlvbiBhcHBseVZpZXdib3hUcmFuc2Zvcm0oZWxlbWVudCkge1xuXG4gICAgdmFyIHZpZXdCb3hBdHRyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKSxcbiAgICAgICAgc2NhbGVYID0gMSxcbiAgICAgICAgc2NhbGVZID0gMSxcbiAgICAgICAgbWluWCA9IDAsXG4gICAgICAgIG1pblkgPSAwLFxuICAgICAgICB2aWV3Qm94V2lkdGgsIHZpZXdCb3hIZWlnaHQsIG1hdHJpeCwgZWwsXG4gICAgICAgIHdpZHRoQXR0ciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd3aWR0aCcpLFxuICAgICAgICBoZWlnaHRBdHRyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpLFxuICAgICAgICB4ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3gnKSB8fCAwLFxuICAgICAgICB5ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3knKSB8fCAwLFxuICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKSB8fCAnJyxcbiAgICAgICAgbWlzc2luZ1ZpZXdCb3ggPSAoIXZpZXdCb3hBdHRyIHx8ICFyZVZpZXdCb3hUYWdOYW1lcy50ZXN0KGVsZW1lbnQubm9kZU5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAhKHZpZXdCb3hBdHRyID0gdmlld0JveEF0dHIubWF0Y2gocmVWaWV3Qm94QXR0clZhbHVlKSkpLFxuICAgICAgICBtaXNzaW5nRGltQXR0ciA9ICghd2lkdGhBdHRyIHx8ICFoZWlnaHRBdHRyIHx8IHdpZHRoQXR0ciA9PT0gJzEwMCUnIHx8IGhlaWdodEF0dHIgPT09ICcxMDAlJyksXG4gICAgICAgIHRvQmVQYXJzZWQgPSBtaXNzaW5nVmlld0JveCAmJiBtaXNzaW5nRGltQXR0cixcbiAgICAgICAgcGFyc2VkRGltID0geyB9LCB0cmFuc2xhdGVNYXRyaXggPSAnJztcblxuICAgIHBhcnNlZERpbS53aWR0aCA9IDA7XG4gICAgcGFyc2VkRGltLmhlaWdodCA9IDA7XG4gICAgcGFyc2VkRGltLnRvQmVQYXJzZWQgPSB0b0JlUGFyc2VkO1xuXG4gICAgaWYgKHRvQmVQYXJzZWQpIHtcbiAgICAgIHJldHVybiBwYXJzZWREaW07XG4gICAgfVxuXG4gICAgaWYgKG1pc3NpbmdWaWV3Qm94KSB7XG4gICAgICBwYXJzZWREaW0ud2lkdGggPSBwYXJzZVVuaXQod2lkdGhBdHRyKTtcbiAgICAgIHBhcnNlZERpbS5oZWlnaHQgPSBwYXJzZVVuaXQoaGVpZ2h0QXR0cik7XG4gICAgICByZXR1cm4gcGFyc2VkRGltO1xuICAgIH1cblxuICAgIG1pblggPSAtcGFyc2VGbG9hdCh2aWV3Qm94QXR0clsxXSk7XG4gICAgbWluWSA9IC1wYXJzZUZsb2F0KHZpZXdCb3hBdHRyWzJdKTtcbiAgICB2aWV3Qm94V2lkdGggPSBwYXJzZUZsb2F0KHZpZXdCb3hBdHRyWzNdKTtcbiAgICB2aWV3Qm94SGVpZ2h0ID0gcGFyc2VGbG9hdCh2aWV3Qm94QXR0cls0XSk7XG5cbiAgICBpZiAoIW1pc3NpbmdEaW1BdHRyKSB7XG4gICAgICBwYXJzZWREaW0ud2lkdGggPSBwYXJzZVVuaXQod2lkdGhBdHRyKTtcbiAgICAgIHBhcnNlZERpbS5oZWlnaHQgPSBwYXJzZVVuaXQoaGVpZ2h0QXR0cik7XG4gICAgICBzY2FsZVggPSBwYXJzZWREaW0ud2lkdGggLyB2aWV3Qm94V2lkdGg7XG4gICAgICBzY2FsZVkgPSBwYXJzZWREaW0uaGVpZ2h0IC8gdmlld0JveEhlaWdodDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBwYXJzZWREaW0ud2lkdGggPSB2aWV3Qm94V2lkdGg7XG4gICAgICBwYXJzZWREaW0uaGVpZ2h0ID0gdmlld0JveEhlaWdodDtcbiAgICB9XG5cbiAgICAvLyBkZWZhdWx0IGlzIHRvIHByZXNlcnZlIGFzcGVjdCByYXRpb1xuICAgIHByZXNlcnZlQXNwZWN0UmF0aW8gPSBmYWJyaWMudXRpbC5wYXJzZVByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGUocHJlc2VydmVBc3BlY3RSYXRpbyk7XG4gICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW8uYWxpZ25YICE9PSAnbm9uZScpIHtcbiAgICAgIC8vdHJhbnNsYXRlIGFsbCBjb250YWluZXIgZm9yIHRoZSBlZmZlY3Qgb2YgTWlkLCBNaW4sIE1heFxuICAgICAgc2NhbGVZID0gc2NhbGVYID0gKHNjYWxlWCA+IHNjYWxlWSA/IHNjYWxlWSA6IHNjYWxlWCk7XG4gICAgfVxuXG4gICAgaWYgKHNjYWxlWCA9PT0gMSAmJiBzY2FsZVkgPT09IDEgJiYgbWluWCA9PT0gMCAmJiBtaW5ZID09PSAwICYmIHggPT09IDAgJiYgeSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHBhcnNlZERpbTtcbiAgICB9XG5cbiAgICBpZiAoeCB8fCB5KSB7XG4gICAgICB0cmFuc2xhdGVNYXRyaXggPSAnIHRyYW5zbGF0ZSgnICsgcGFyc2VVbml0KHgpICsgJyAnICsgcGFyc2VVbml0KHkpICsgJykgJztcbiAgICB9XG5cbiAgICBtYXRyaXggPSB0cmFuc2xhdGVNYXRyaXggKyAnIG1hdHJpeCgnICsgc2NhbGVYICtcbiAgICAgICAgICAgICAgICAgICcgMCcgK1xuICAgICAgICAgICAgICAgICAgJyAwICcgK1xuICAgICAgICAgICAgICAgICAgc2NhbGVZICsgJyAnICtcbiAgICAgICAgICAgICAgICAgIChtaW5YICogc2NhbGVYKSArICcgJyArXG4gICAgICAgICAgICAgICAgICAobWluWSAqIHNjYWxlWSkgKyAnKSAnO1xuXG4gICAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICdzdmcnKSB7XG4gICAgICBlbCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdnJyk7XG4gICAgICAvLyBlbGVtZW50LmZpcnN0Q2hpbGQgIT0gbnVsbFxuICAgICAgd2hpbGUgKGVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICBlbC5hcHBlbmRDaGlsZChlbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChlbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZWwgPSBlbGVtZW50O1xuICAgICAgbWF0cml4ID0gZWwuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKSArIG1hdHJpeDtcbiAgICB9XG5cbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIG1hdHJpeCk7XG4gICAgcmV0dXJuIHBhcnNlZERpbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gU1ZHIGRvY3VtZW50LCBjb252ZXJ0cyBpdCB0byBhbiBhcnJheSBvZiBjb3JyZXNwb25kaW5nIGZhYnJpYy4qIGluc3RhbmNlcyBhbmQgcGFzc2VzIHRoZW0gdG8gYSBjYWxsYmFja1xuICAgKiBAc3RhdGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAqIEBwYXJhbSB7U1ZHRG9jdW1lbnR9IGRvYyBTVkcgZG9jdW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gY2FsbCB3aGVuIHBhcnNpbmcgaXMgZmluaXNoZWQ7XG4gICAqIEl0J3MgYmVpbmcgcGFzc2VkIGFuIGFycmF5IG9mIGVsZW1lbnRzIChwYXJzZWQgZnJvbSBhIGRvY3VtZW50KS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIFNWRyBlbGVtZW50cywgY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjcmVhdGVkLlxuICAgKi9cbiAgZmFicmljLnBhcnNlU1ZHRG9jdW1lbnQgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICBmdW5jdGlvbiBoYXNBbmNlc3RvcldpdGhOb2RlTmFtZShlbGVtZW50LCBub2RlTmFtZSkge1xuICAgICAgd2hpbGUgKGVsZW1lbnQgJiYgKGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGUpKSB7XG4gICAgICAgIGlmIChlbGVtZW50Lm5vZGVOYW1lICYmIG5vZGVOYW1lLnRlc3QoZWxlbWVudC5ub2RlTmFtZS5yZXBsYWNlKCdzdmc6JywgJycpKVxuICAgICAgICAgICYmICFlbGVtZW50LmdldEF0dHJpYnV0ZSgnaW5zdGFudGlhdGVkX2J5X3VzZScpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oZG9jLCBjYWxsYmFjaywgcmV2aXZlcikge1xuICAgICAgaWYgKCFkb2MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwYXJzZVVzZURpcmVjdGl2ZXMoZG9jKTtcblxuICAgICAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCksXG4gICAgICAgICAgc3ZnVWlkID0gIGZhYnJpYy5PYmplY3QuX191aWQrKyxcbiAgICAgICAgICBvcHRpb25zID0gYXBwbHlWaWV3Ym94VHJhbnNmb3JtKGRvYyksXG4gICAgICAgICAgZGVzY2VuZGFudHMgPSBmYWJyaWMudXRpbC50b0FycmF5KGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpKTtcblxuICAgICAgb3B0aW9ucy5zdmdVaWQgPSBzdmdVaWQ7XG5cbiAgICAgIGlmIChkZXNjZW5kYW50cy5sZW5ndGggPT09IDAgJiYgZmFicmljLmlzTGlrZWx5Tm9kZSkge1xuICAgICAgICAvLyB3ZSdyZSBsaWtlbHkgaW4gbm9kZSwgd2hlcmUgXCJvMy14bWxcIiBsaWJyYXJ5IGZhaWxzIHRvIGdFQlROKFwiKlwiKVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYWpheG9yZy9ub2RlLW8zLXhtbC9pc3N1ZXMvMjFcbiAgICAgICAgZGVzY2VuZGFudHMgPSBkb2Muc2VsZWN0Tm9kZXMoJy8vKltuYW1lKC4pIT1cInN2Z1wiXScpO1xuICAgICAgICB2YXIgYXJyID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkZXNjZW5kYW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGFycltpXSA9IGRlc2NlbmRhbnRzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGRlc2NlbmRhbnRzID0gYXJyO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudHMgPSBkZXNjZW5kYW50cy5maWx0ZXIoZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgYXBwbHlWaWV3Ym94VHJhbnNmb3JtKGVsKTtcbiAgICAgICAgcmV0dXJuIHJlQWxsb3dlZFNWR1RhZ05hbWVzLnRlc3QoZWwubm9kZU5hbWUucmVwbGFjZSgnc3ZnOicsICcnKSkgJiZcbiAgICAgICAgICAgICAgIWhhc0FuY2VzdG9yV2l0aE5vZGVOYW1lKGVsLCByZU5vdEFsbG93ZWRBbmNlc3RvcnMpOyAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc3RydWN0Lmh0bWwjRGVmc0VsZW1lbnRcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWVsZW1lbnRzIHx8IChlbGVtZW50cyAmJiAhZWxlbWVudHMubGVuZ3RoKSkge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhbXSwge30pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZhYnJpYy5ncmFkaWVudERlZnNbc3ZnVWlkXSA9IGZhYnJpYy5nZXRHcmFkaWVudERlZnMoZG9jKTtcbiAgICAgIGZhYnJpYy5jc3NSdWxlc1tzdmdVaWRdID0gZmFicmljLmdldENTU1J1bGVzKGRvYyk7XG4gICAgICAvLyBQcmVjZWRlbmNlIG9mIHJ1bGVzOiAgIHN0eWxlID4gY2xhc3MgPiBhdHRyaWJ1dGVcbiAgICAgIGZhYnJpYy5wYXJzZUVsZW1lbnRzKGVsZW1lbnRzLCBmdW5jdGlvbihpbnN0YW5jZXMpIHtcbiAgICAgICAgZmFicmljLmRvY3VtZW50UGFyc2luZ1RpbWUgPSBuZXcgRGF0ZSgpIC0gc3RhcnRUaW1lO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhpbnN0YW5jZXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9LCBjbG9uZShvcHRpb25zKSwgcmV2aXZlcik7XG4gICAgfTtcbiAgfSkoKTtcblxuICAvKipcbiAgICogVXNlZCBmb3IgY2FjaGluZyBTVkcgZG9jdW1lbnRzIChsb2FkZWQgdmlhIGBmYWJyaWMuQ2FudmFzI2xvYWRTVkdGcm9tVVJMYClcbiAgICogQG5hbWVzcGFjZVxuICAgKi9cbiAgdmFyIHN2Z0NhY2hlID0ge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIGhhczogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayhmYWxzZSk7XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgLyogTk9PUCAqL1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qIE5PT1AgKi9cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfZW5saXZlbkNhY2hlZE9iamVjdChjYWNoZWRPYmplY3QpIHtcblxuICAgIHZhciBvYmplY3RzID0gY2FjaGVkT2JqZWN0Lm9iamVjdHMsXG4gICAgICAgIG9wdGlvbnMgPSBjYWNoZWRPYmplY3Qub3B0aW9ucztcblxuICAgIG9iamVjdHMgPSBvYmplY3RzLm1hcChmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIGZhYnJpY1tjYXBpdGFsaXplKG8udHlwZSldLmZyb21PYmplY3Qobyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gKHsgb2JqZWN0czogb2JqZWN0cywgb3B0aW9uczogb3B0aW9ucyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2NyZWF0ZVNWR1BhdHRlcm4obWFya3VwLCBjYW52YXMsIHByb3BlcnR5KSB7XG4gICAgaWYgKGNhbnZhc1twcm9wZXJ0eV0gJiYgY2FudmFzW3Byb3BlcnR5XS50b1NWRykge1xuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICdcXHQ8cGF0dGVybiB4PVwiMFwiIHk9XCIwXCIgaWQ9XCInLCBwcm9wZXJ0eSwgJ1BhdHRlcm5cIiAnLFxuICAgICAgICAgICd3aWR0aD1cIicsIGNhbnZhc1twcm9wZXJ0eV0uc291cmNlLndpZHRoLFxuICAgICAgICAgICdcIiBoZWlnaHQ9XCInLCBjYW52YXNbcHJvcGVydHldLnNvdXJjZS5oZWlnaHQsXG4gICAgICAgICAgJ1wiIHBhdHRlcm5Vbml0cz1cInVzZXJTcGFjZU9uVXNlXCI+XFxuJyxcbiAgICAgICAgJ1xcdFxcdDxpbWFnZSB4PVwiMFwiIHk9XCIwXCIgJyxcbiAgICAgICAgJ3dpZHRoPVwiJywgY2FudmFzW3Byb3BlcnR5XS5zb3VyY2Uud2lkdGgsXG4gICAgICAgICdcIiBoZWlnaHQ9XCInLCBjYW52YXNbcHJvcGVydHldLnNvdXJjZS5oZWlnaHQsXG4gICAgICAgICdcIiB4bGluazpocmVmPVwiJywgY2FudmFzW3Byb3BlcnR5XS5zb3VyY2Uuc3JjLFxuICAgICAgICAnXCI+PC9pbWFnZT5cXG5cXHQ8L3BhdHRlcm4+XFxuJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVGb250RGVjbGFyYXRpb24gPSBuZXcgUmVnRXhwKFxuICAgICcobm9ybWFsfGl0YWxpYyk/XFxcXHMqKG5vcm1hbHxzbWFsbC1jYXBzKT9cXFxccyonICtcbiAgICAnKG5vcm1hbHxib2xkfGJvbGRlcnxsaWdodGVyfDEwMHwyMDB8MzAwfDQwMHw1MDB8NjAwfDcwMHw4MDB8OTAwKT9cXFxccyooJyArXG4gICAgICBmYWJyaWMucmVOdW0gK1xuICAgICcoPzpweHxjbXxtbXxlbXxwdHxwY3xpbikqKSg/OlxcXFwvKG5vcm1hbHwnICsgZmFicmljLnJlTnVtICsgJykpP1xcXFxzKyguKiknKTtcblxuICBleHRlbmQoZmFicmljLCB7XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgc2hvcnQgZm9udCBkZWNsYXJhdGlvbiwgYnVpbGRpbmcgYWRkaW5nIGl0cyBwcm9wZXJ0aWVzIHRvIGEgc3R5bGUgb2JqZWN0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgZm9udCBkZWNsYXJhdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvU3R5bGUgZGVmaW5pdGlvblxuICAgICAqL1xuICAgIHBhcnNlRm9udERlY2xhcmF0aW9uOiBmdW5jdGlvbih2YWx1ZSwgb1N0eWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaChyZUZvbnREZWNsYXJhdGlvbik7XG5cbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGZvbnRTdHlsZSA9IG1hdGNoWzFdLFxuICAgICAgICAgIC8vIGZvbnQgdmFyaWFudCBpcyBub3QgdXNlZFxuICAgICAgICAgIC8vIGZvbnRWYXJpYW50ID0gbWF0Y2hbMl0sXG4gICAgICAgICAgZm9udFdlaWdodCA9IG1hdGNoWzNdLFxuICAgICAgICAgIGZvbnRTaXplID0gbWF0Y2hbNF0sXG4gICAgICAgICAgbGluZUhlaWdodCA9IG1hdGNoWzVdLFxuICAgICAgICAgIGZvbnRGYW1pbHkgPSBtYXRjaFs2XTtcblxuICAgICAgaWYgKGZvbnRTdHlsZSkge1xuICAgICAgICBvU3R5bGUuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgICAgfVxuICAgICAgaWYgKGZvbnRXZWlnaHQpIHtcbiAgICAgICAgb1N0eWxlLmZvbnRXZWlnaHQgPSBpc05hTihwYXJzZUZsb2F0KGZvbnRXZWlnaHQpKSA/IGZvbnRXZWlnaHQgOiBwYXJzZUZsb2F0KGZvbnRXZWlnaHQpO1xuICAgICAgfVxuICAgICAgaWYgKGZvbnRTaXplKSB7XG4gICAgICAgIG9TdHlsZS5mb250U2l6ZSA9IHBhcnNlVW5pdChmb250U2l6ZSk7XG4gICAgICB9XG4gICAgICBpZiAoZm9udEZhbWlseSkge1xuICAgICAgICBvU3R5bGUuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICB9XG4gICAgICBpZiAobGluZUhlaWdodCkge1xuICAgICAgICBvU3R5bGUubGluZUhlaWdodCA9IGxpbmVIZWlnaHQgPT09ICdub3JtYWwnID8gMSA6IGxpbmVIZWlnaHQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhbiBTVkcgZG9jdW1lbnQsIHJldHVybmluZyBhbGwgb2YgdGhlIGdyYWRpZW50IGRlY2xhcmF0aW9ucyBmb3VuZCBpbiBpdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTVkdEb2N1bWVudH0gZG9jIFNWRyBkb2N1bWVudCB0byBwYXJzZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gR3JhZGllbnQgZGVmaW5pdGlvbnM7IGtleSBjb3JyZXNwb25kcyB0byBlbGVtZW50IGlkLCB2YWx1ZSAtLSB0byBncmFkaWVudCBkZWZpbml0aW9uIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXRHcmFkaWVudERlZnM6IGZ1bmN0aW9uKGRvYykge1xuICAgICAgdmFyIHRhZ0FycmF5ID0gW1xuICAgICAgICAgICAgJ2xpbmVhckdyYWRpZW50JyxcbiAgICAgICAgICAgICdyYWRpYWxHcmFkaWVudCcsXG4gICAgICAgICAgICAnc3ZnOmxpbmVhckdyYWRpZW50JyxcbiAgICAgICAgICAgICdzdmc6cmFkaWFsR3JhZGllbnQnXSxcbiAgICAgICAgICBlbExpc3QgPSBfZ2V0TXVsdGlwbGVOb2Rlcyhkb2MsIHRhZ0FycmF5KSxcbiAgICAgICAgICBlbCwgaiA9IDAsIGlkLCB4bGluayxcbiAgICAgICAgICBncmFkaWVudERlZnMgPSB7IH0sIGlkc1RvWGxpbmtNYXAgPSB7IH07XG5cbiAgICAgIGogPSBlbExpc3QubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgIGVsID0gZWxMaXN0W2pdO1xuICAgICAgICB4bGluayA9IGVsLmdldEF0dHJpYnV0ZSgneGxpbms6aHJlZicpO1xuICAgICAgICBpZCA9IGVsLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgaWYgKHhsaW5rKSB7XG4gICAgICAgICAgaWRzVG9YbGlua01hcFtpZF0gPSB4bGluay5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JhZGllbnREZWZzW2lkXSA9IGVsO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGlkIGluIGlkc1RvWGxpbmtNYXApIHtcbiAgICAgICAgdmFyIGVsMiA9IGdyYWRpZW50RGVmc1tpZHNUb1hsaW5rTWFwW2lkXV0uY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICBlbCA9IGdyYWRpZW50RGVmc1tpZF07XG4gICAgICAgIHdoaWxlIChlbDIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGVsMi5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGdyYWRpZW50RGVmcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYmplY3Qgb2YgYXR0cmlidXRlcycgbmFtZS92YWx1ZSwgZ2l2ZW4gZWxlbWVudCBhbmQgYW4gYXJyYXkgb2YgYXR0cmlidXRlIG5hbWVzO1xuICAgICAqIFBhcnNlcyBwYXJlbnQgXCJnXCIgbm9kZXMgcmVjdXJzaXZlbHkgdXB3YXJkcy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXR0cmlidXRlcyBBcnJheSBvZiBhdHRyaWJ1dGVzIHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyBwYXJzZWQgYXR0cmlidXRlcycgbmFtZXMvdmFsdWVzXG4gICAgICovXG4gICAgcGFyc2VBdHRyaWJ1dGVzOiBmdW5jdGlvbihlbGVtZW50LCBhdHRyaWJ1dGVzLCBzdmdVaWQpIHtcblxuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlLFxuICAgICAgICAgIHBhcmVudEF0dHJpYnV0ZXMgPSB7IH0sXG4gICAgICAgICAgZm9udFNpemU7XG5cbiAgICAgIGlmICh0eXBlb2Ygc3ZnVWlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzdmdVaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3ZnVWlkJyk7XG4gICAgICB9XG4gICAgICAvLyBpZiB0aGVyZSdzIGEgcGFyZW50IGNvbnRhaW5lciAoYGdgIG9yIGBhYCBvciBgc3ltYm9sYCBub2RlKSwgcGFyc2UgaXRzIGF0dHJpYnV0ZXMgcmVjdXJzaXZlbHkgdXB3YXJkc1xuICAgICAgaWYgKGVsZW1lbnQucGFyZW50Tm9kZSAmJiByZUFsbG93ZWRQYXJlbnRzLnRlc3QoZWxlbWVudC5wYXJlbnROb2RlLm5vZGVOYW1lKSkge1xuICAgICAgICBwYXJlbnRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LnBhcmVudE5vZGUsIGF0dHJpYnV0ZXMsIHN2Z1VpZCk7XG4gICAgICB9XG4gICAgICBmb250U2l6ZSA9IChwYXJlbnRBdHRyaWJ1dGVzICYmIHBhcmVudEF0dHJpYnV0ZXMuZm9udFNpemUgKSB8fFxuICAgICAgICAgICAgICAgICBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZm9udC1zaXplJykgfHwgZmFicmljLlRleHQuREVGQVVMVF9TVkdfRk9OVF9TSVpFO1xuXG4gICAgICB2YXIgb3duQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMucmVkdWNlKGZ1bmN0aW9uKG1lbW8sIGF0dHIpIHtcbiAgICAgICAgdmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgYXR0ciA9IG5vcm1hbGl6ZUF0dHIoYXR0cik7XG4gICAgICAgICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZShhdHRyLCB2YWx1ZSwgcGFyZW50QXR0cmlidXRlcywgZm9udFNpemUpO1xuXG4gICAgICAgICAgbWVtb1thdHRyXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgfSwgeyB9KTtcblxuICAgICAgLy8gYWRkIHZhbHVlcyBwYXJzZWQgZnJvbSBzdHlsZSwgd2hpY2ggdGFrZSBwcmVjZWRlbmNlIG92ZXIgYXR0cmlidXRlc1xuICAgICAgLy8gKHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3N0eWxpbmcuaHRtbCNVc2luZ1ByZXNlbnRhdGlvbkF0dHJpYnV0ZXMpXG4gICAgICBvd25BdHRyaWJ1dGVzID0gZXh0ZW5kKG93bkF0dHJpYnV0ZXMsXG4gICAgICAgIGV4dGVuZChnZXRHbG9iYWxTdHlsZXNGb3JFbGVtZW50KGVsZW1lbnQsIHN2Z1VpZCksIGZhYnJpYy5wYXJzZVN0eWxlQXR0cmlidXRlKGVsZW1lbnQpKSk7XG4gICAgICBpZiAob3duQXR0cmlidXRlcy5mb250KSB7XG4gICAgICAgIGZhYnJpYy5wYXJzZUZvbnREZWNsYXJhdGlvbihvd25BdHRyaWJ1dGVzLmZvbnQsIG93bkF0dHJpYnV0ZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9zZXRTdHJva2VGaWxsT3BhY2l0eShleHRlbmQocGFyZW50QXR0cmlidXRlcywgb3duQXR0cmlidXRlcykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGFuIGFycmF5IG9mIHN2ZyBlbGVtZW50cyB0byBjb3JyZXNwb25kaW5nIGZhYnJpYy4qIGluc3RhbmNlc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtBcnJheX0gZWxlbWVudHMgQXJyYXkgb2YgZWxlbWVudHMgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBCZWluZyBwYXNzZWQgYW4gYXJyYXkgb2YgZmFicmljIGluc3RhbmNlcyAodHJhbnNmb3JtZWQgZnJvbSBTVkcgZWxlbWVudHMpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBTVkcgZWxlbWVudHMsIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBwYXJzZUVsZW1lbnRzOiBmdW5jdGlvbihlbGVtZW50cywgY2FsbGJhY2ssIG9wdGlvbnMsIHJldml2ZXIpIHtcbiAgICAgIG5ldyBmYWJyaWMuRWxlbWVudHNQYXJzZXIoZWxlbWVudHMsIGNhbGxiYWNrLCBvcHRpb25zLCByZXZpdmVyKS5wYXJzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgXCJzdHlsZVwiIGF0dHJpYnV0ZSwgcmV0dW5pbmcgYW4gb2JqZWN0IHdpdGggdmFsdWVzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0cyB3aXRoIHZhbHVlcyBwYXJzZWQgZnJvbSBzdHlsZSBhdHRyaWJ1dGUgb2YgYW4gZWxlbWVudFxuICAgICAqL1xuICAgIHBhcnNlU3R5bGVBdHRyaWJ1dGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvU3R5bGUgPSB7IH0sXG4gICAgICAgICAgc3R5bGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcblxuICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICByZXR1cm4gb1N0eWxlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXJzZVN0eWxlU3RyaW5nKHN0eWxlLCBvU3R5bGUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHBhcnNlU3R5bGVPYmplY3Qoc3R5bGUsIG9TdHlsZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvU3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBcInBvaW50c1wiIGF0dHJpYnV0ZSwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHZhbHVlc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBvaW50cyBwb2ludHMgYXR0cmlidXRlIHN0cmluZ1xuICAgICAqIEByZXR1cm4ge0FycmF5fSBhcnJheSBvZiBwb2ludHNcbiAgICAgKi9cbiAgICBwYXJzZVBvaW50c0F0dHJpYnV0ZTogZnVuY3Rpb24ocG9pbnRzKSB7XG5cbiAgICAgIC8vIHBvaW50cyBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgYW5kIG11c3Qgbm90IGJlIGVtcHR5XG4gICAgICBpZiAoIXBvaW50cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gcmVwbGFjZSBjb21tYXMgd2l0aCB3aGl0ZXNwYWNlIGFuZCByZW1vdmUgYm9va2VuZGluZyB3aGl0ZXNwYWNlXG4gICAgICBwb2ludHMgPSBwb2ludHMucmVwbGFjZSgvLC9nLCAnICcpLnRyaW0oKTtcblxuICAgICAgcG9pbnRzID0gcG9pbnRzLnNwbGl0KC9cXHMrLyk7XG4gICAgICB2YXIgcGFyc2VkUG9pbnRzID0gW10sIGksIGxlbjtcblxuICAgICAgaSA9IDA7XG4gICAgICBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgZm9yICg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICBwYXJzZWRQb2ludHMucHVzaCh7XG4gICAgICAgICAgeDogcGFyc2VGbG9hdChwb2ludHNbaV0pLFxuICAgICAgICAgIHk6IHBhcnNlRmxvYXQocG9pbnRzW2kgKyAxXSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIG9kZCBudW1iZXIgb2YgcG9pbnRzIGlzIGFuIGVycm9yXG4gICAgICAvLyBpZiAocGFyc2VkUG9pbnRzLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgIC8vICAgcmV0dXJuIG51bGw7XG4gICAgICAvLyB9XG5cbiAgICAgIHJldHVybiBwYXJzZWRQb2ludHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgQ1NTIHJ1bGVzIGZvciBhIGdpdmVuIFNWRyBkb2N1bWVudFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTVkdEb2N1bWVudH0gZG9jIFNWRyBkb2N1bWVudCB0byBwYXJzZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ1NTIHJ1bGVzIG9mIHRoaXMgZG9jdW1lbnRcbiAgICAgKi9cbiAgICBnZXRDU1NSdWxlczogZnVuY3Rpb24oZG9jKSB7XG4gICAgICB2YXIgc3R5bGVzID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzdHlsZScpLFxuICAgICAgICAgIGFsbFJ1bGVzID0geyB9LCBydWxlcztcblxuICAgICAgLy8gdmVyeSBjcnVkZSBwYXJzaW5nIG9mIHN0eWxlIGNvbnRlbnRzXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3R5bGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIElFOSBkb2Vzbid0IHN1cHBvcnQgdGV4dENvbnRlbnQsIGJ1dCBwcm92aWRlcyB0ZXh0IGluc3RlYWQuXG4gICAgICAgIHZhciBzdHlsZUNvbnRlbnRzID0gc3R5bGVzW2ldLnRleHRDb250ZW50IHx8IHN0eWxlc1tpXS50ZXh0O1xuXG4gICAgICAgIC8vIHJlbW92ZSBjb21tZW50c1xuICAgICAgICBzdHlsZUNvbnRlbnRzID0gc3R5bGVDb250ZW50cy5yZXBsYWNlKC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvL2csICcnKTtcbiAgICAgICAgaWYgKHN0eWxlQ29udGVudHMudHJpbSgpID09PSAnJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJ1bGVzID0gc3R5bGVDb250ZW50cy5tYXRjaCgvW157XSpcXHtbXFxzXFxTXSo/XFx9L2cpO1xuICAgICAgICBydWxlcyA9IHJ1bGVzLm1hcChmdW5jdGlvbihydWxlKSB7IHJldHVybiBydWxlLnRyaW0oKTsgfSk7XG4gICAgICAgIHJ1bGVzLmZvckVhY2goZnVuY3Rpb24ocnVsZSkge1xuXG4gICAgICAgICAgdmFyIG1hdGNoID0gcnVsZS5tYXRjaCgvKFtcXHNcXFNdKj8pXFxzKlxceyhbXn1dKilcXH0vKSxcbiAgICAgICAgICAgICAgcnVsZU9iaiA9IHsgfSwgZGVjbGFyYXRpb24gPSBtYXRjaFsyXS50cmltKCksXG4gICAgICAgICAgICAgIHByb3BlcnR5VmFsdWVQYWlycyA9IGRlY2xhcmF0aW9uLnJlcGxhY2UoLzskLywgJycpLnNwbGl0KC9cXHMqO1xccyovKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm9wZXJ0eVZhbHVlUGFpcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYWlyID0gcHJvcGVydHlWYWx1ZVBhaXJzW2ldLnNwbGl0KC9cXHMqOlxccyovKSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IG5vcm1hbGl6ZUF0dHIocGFpclswXSksXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZShwcm9wZXJ0eSwgcGFpclsxXSwgcGFpclswXSk7XG4gICAgICAgICAgICBydWxlT2JqW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBydWxlID0gbWF0Y2hbMV07XG4gICAgICAgICAgcnVsZS5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24oX3J1bGUpIHtcbiAgICAgICAgICAgIF9ydWxlID0gX3J1bGUucmVwbGFjZSgvXnN2Zy9pLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgaWYgKF9ydWxlID09PSAnJykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxsUnVsZXNbX3J1bGVdKSB7XG4gICAgICAgICAgICAgIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoYWxsUnVsZXNbX3J1bGVdLCBydWxlT2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBhbGxSdWxlc1tfcnVsZV0gPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUocnVsZU9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFsbFJ1bGVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyB1cmwgY29ycmVzcG9uZGluZyB0byBhbiBTVkcgZG9jdW1lbnQsIGFuZCBwYXJzZXMgaXQgaW50byBhIHNldCBvZiBmYWJyaWMgb2JqZWN0cy5cbiAgICAgKiBOb3RlIHRoYXQgU1ZHIGlzIGZldGNoZWQgdmlhIFhNTEh0dHBSZXF1ZXN0LCBzbyBpdCBuZWVkcyB0byBjb25mb3JtIHRvIFNPUCAoU2FtZSBPcmlnaW4gUG9saWN5KVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgU1ZHIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAgICovXG4gICAgbG9hZFNWR0Zyb21VUkw6IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2ssIHJldml2ZXIpIHtcblxuICAgICAgdXJsID0gdXJsLnJlcGxhY2UoL15cXG5cXHMqLywgJycpLnRyaW0oKTtcbiAgICAgIHN2Z0NhY2hlLmhhcyh1cmwsIGZ1bmN0aW9uIChoYXNVcmwpIHtcbiAgICAgICAgaWYgKGhhc1VybCkge1xuICAgICAgICAgIHN2Z0NhY2hlLmdldCh1cmwsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGVubGl2ZWRSZWNvcmQgPSBfZW5saXZlbkNhY2hlZE9iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICBjYWxsYmFjayhlbmxpdmVkUmVjb3JkLm9iamVjdHMsIGVubGl2ZWRSZWNvcmQub3B0aW9ucyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbmV3IGZhYnJpYy51dGlsLnJlcXVlc3QodXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdnZXQnLFxuICAgICAgICAgICAgb25Db21wbGV0ZTogb25Db21wbGV0ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gb25Db21wbGV0ZShyKSB7XG5cbiAgICAgICAgdmFyIHhtbCA9IHIucmVzcG9uc2VYTUw7XG4gICAgICAgIGlmICh4bWwgJiYgIXhtbC5kb2N1bWVudEVsZW1lbnQgJiYgZmFicmljLndpbmRvdy5BY3RpdmVYT2JqZWN0ICYmIHIucmVzcG9uc2VUZXh0KSB7XG4gICAgICAgICAgeG1sID0gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxET00nKTtcbiAgICAgICAgICB4bWwuYXN5bmMgPSAnZmFsc2UnO1xuICAgICAgICAgIC8vSUUgY2hva2VzIG9uIERPQ1RZUEVcbiAgICAgICAgICB4bWwubG9hZFhNTChyLnJlc3BvbnNlVGV4dC5yZXBsYWNlKC88IURPQ1RZUEVbXFxzXFxTXSo/KFxcW1tcXHNcXFNdKlxcXSkqPz4vaSwgJycpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXhtbCB8fCAheG1sLmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmFicmljLnBhcnNlU1ZHRG9jdW1lbnQoeG1sLmRvY3VtZW50RWxlbWVudCwgZnVuY3Rpb24gKHJlc3VsdHMsIG9wdGlvbnMpIHtcbiAgICAgICAgICBzdmdDYWNoZS5zZXQodXJsLCB7XG4gICAgICAgICAgICBvYmplY3RzOiBmYWJyaWMudXRpbC5hcnJheS5pbnZva2UocmVzdWx0cywgJ3RvT2JqZWN0JyksXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVzdWx0cywgb3B0aW9ucyk7XG4gICAgICAgIH0sIHJldml2ZXIpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBzdHJpbmcgY29ycmVzcG9uZGluZyB0byBhbiBTVkcgZG9jdW1lbnQsIGFuZCBwYXJzZXMgaXQgaW50byBhIHNldCBvZiBmYWJyaWMgb2JqZWN0c1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgU1ZHIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAgICovXG4gICAgbG9hZFNWR0Zyb21TdHJpbmc6IGZ1bmN0aW9uKHN0cmluZywgY2FsbGJhY2ssIHJldml2ZXIpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZy50cmltKCk7XG4gICAgICB2YXIgZG9jO1xuICAgICAgaWYgKHR5cGVvZiBET01QYXJzZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgIGlmIChwYXJzZXIgJiYgcGFyc2VyLnBhcnNlRnJvbVN0cmluZykge1xuICAgICAgICAgIGRvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoc3RyaW5nLCAndGV4dC94bWwnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmFicmljLndpbmRvdy5BY3RpdmVYT2JqZWN0KSB7XG4gICAgICAgIGRvYyA9IG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MRE9NJyk7XG4gICAgICAgIGRvYy5hc3luYyA9ICdmYWxzZSc7XG4gICAgICAgIC8vIElFIGNob2tlcyBvbiBET0NUWVBFXG4gICAgICAgIGRvYy5sb2FkWE1MKHN0cmluZy5yZXBsYWNlKC88IURPQ1RZUEVbXFxzXFxTXSo/KFxcW1tcXHNcXFNdKlxcXSkqPz4vaSwgJycpKTtcbiAgICAgIH1cblxuICAgICAgZmFicmljLnBhcnNlU1ZHRG9jdW1lbnQoZG9jLmRvY3VtZW50RWxlbWVudCwgZnVuY3Rpb24gKHJlc3VsdHMsIG9wdGlvbnMpIHtcbiAgICAgICAgY2FsbGJhY2socmVzdWx0cywgb3B0aW9ucyk7XG4gICAgICB9LCByZXZpdmVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBtYXJrdXAgY29udGFpbmluZyBTVkcgZm9udCBmYWNlcyxcbiAgICAgKiBmb250IFVSTHMgZm9yIGZvbnQgZmFjZXMgbXVzdCBiZSBjb2xsZWN0ZWQgYnkgZGV2ZWxvcGVyc1xuICAgICAqIGFuZCBhcmUgbm90IGV4dHJhY3RlZCBmcm9tIHRoZSBET00gYnkgZmFicmljanNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzIEFycmF5IG9mIGZhYnJpYyBvYmplY3RzXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNyZWF0ZVNWR0ZvbnRGYWNlc01hcmt1cDogZnVuY3Rpb24ob2JqZWN0cykge1xuICAgICAgdmFyIG1hcmt1cCA9ICcnLCBmb250TGlzdCA9IHsgfSwgb2JqLCBmb250RmFtaWx5LFxuICAgICAgICAgIHN0eWxlLCByb3csIHJvd0luZGV4LCBfY2hhciwgY2hhckluZGV4LFxuICAgICAgICAgIGZvbnRQYXRocyA9IGZhYnJpYy5mb250UGF0aHM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG9iaiA9IG9iamVjdHNbaV07XG4gICAgICAgIGZvbnRGYW1pbHkgPSBvYmouZm9udEZhbWlseTtcbiAgICAgICAgaWYgKG9iai50eXBlLmluZGV4T2YoJ3RleHQnKSA9PT0gLTEgfHwgZm9udExpc3RbZm9udEZhbWlseV0gfHwgIWZvbnRQYXRoc1tmb250RmFtaWx5XSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvbnRMaXN0W2ZvbnRGYW1pbHldID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFvYmouc3R5bGVzKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGUgPSBvYmouc3R5bGVzO1xuICAgICAgICBmb3IgKHJvd0luZGV4IGluIHN0eWxlKSB7XG4gICAgICAgICAgcm93ID0gc3R5bGVbcm93SW5kZXhdO1xuICAgICAgICAgIGZvciAoY2hhckluZGV4IGluIHJvdykge1xuICAgICAgICAgICAgX2NoYXIgPSByb3dbY2hhckluZGV4XTtcbiAgICAgICAgICAgIGZvbnRGYW1pbHkgPSBfY2hhci5mb250RmFtaWx5O1xuICAgICAgICAgICAgaWYgKCFmb250TGlzdFtmb250RmFtaWx5XSAmJiBmb250UGF0aHNbZm9udEZhbWlseV0pIHtcbiAgICAgICAgICAgICAgZm9udExpc3RbZm9udEZhbWlseV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqIGluIGZvbnRMaXN0KSB7XG4gICAgICAgIG1hcmt1cCArPSBbXG4gICAgICAgICAgJ1xcdFxcdEBmb250LWZhY2Uge1xcbicsXG4gICAgICAgICAgJ1xcdFxcdFxcdGZvbnQtZmFtaWx5OiBcXCcnLCBqLCAnXFwnO1xcbicsXG4gICAgICAgICAgJ1xcdFxcdFxcdHNyYzogdXJsKFxcJycsIGZvbnRQYXRoc1tqXSwgJ1xcJyk7XFxuJyxcbiAgICAgICAgICAnXFx0XFx0fVxcbidcbiAgICAgICAgXS5qb2luKCcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hcmt1cCkge1xuICAgICAgICBtYXJrdXAgPSBbXG4gICAgICAgICAgJ1xcdDxzdHlsZSB0eXBlPVwidGV4dC9jc3NcIj4nLFxuICAgICAgICAgICc8IVtDREFUQVtcXG4nLFxuICAgICAgICAgIG1hcmt1cCxcbiAgICAgICAgICAnXV0+JyxcbiAgICAgICAgICAnPC9zdHlsZT5cXG4nXG4gICAgICAgIF0uam9pbignJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXJrdXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbWFya3VwIGNvbnRhaW5pbmcgU1ZHIHJlZmVyZW5jZWQgZWxlbWVudHMgbGlrZSBwYXR0ZXJucywgZ3JhZGllbnRzIGV0Yy5cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5DYW52YXN9IGNhbnZhcyBpbnN0YW5jZSBvZiBmYWJyaWMuQ2FudmFzXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNyZWF0ZVNWR1JlZkVsZW1lbnRzTWFya3VwOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgIHZhciBtYXJrdXAgPSBbXTtcblxuICAgICAgX2NyZWF0ZVNWR1BhdHRlcm4obWFya3VwLCBjYW52YXMsICdiYWNrZ3JvdW5kQ29sb3InKTtcbiAgICAgIF9jcmVhdGVTVkdQYXR0ZXJuKG1hcmt1cCwgY2FudmFzLCAnb3ZlcmxheUNvbG9yJyk7XG5cbiAgICAgIHJldHVybiBtYXJrdXAuam9pbignJyk7XG4gICAgfVxuICB9KTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbmZhYnJpYy5FbGVtZW50c1BhcnNlciA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBjYWxsYmFjaywgb3B0aW9ucywgcmV2aXZlcikge1xuICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5yZXZpdmVyID0gcmV2aXZlcjtcbiAgdGhpcy5zdmdVaWQgPSAob3B0aW9ucyAmJiBvcHRpb25zLnN2Z1VpZCkgfHwgMDtcbn07XG5cbmZhYnJpYy5FbGVtZW50c1BhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pbnN0YW5jZXMgPSBuZXcgQXJyYXkodGhpcy5lbGVtZW50cy5sZW5ndGgpO1xuICB0aGlzLm51bUVsZW1lbnRzID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG5cbiAgdGhpcy5jcmVhdGVPYmplY3RzKCk7XG59O1xuXG5mYWJyaWMuRWxlbWVudHNQYXJzZXIucHJvdG90eXBlLmNyZWF0ZU9iamVjdHMgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB0aGlzLmVsZW1lbnRzW2ldLnNldEF0dHJpYnV0ZSgnc3ZnVWlkJywgdGhpcy5zdmdVaWQpO1xuICAgIChmdW5jdGlvbihfb2JqLCBpKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBfb2JqLmNyZWF0ZU9iamVjdChfb2JqLmVsZW1lbnRzW2ldLCBpKTtcbiAgICAgIH0sIDApO1xuICAgIH0pKHRoaXMsIGkpO1xuICB9XG59O1xuXG5mYWJyaWMuRWxlbWVudHNQYXJzZXIucHJvdG90eXBlLmNyZWF0ZU9iamVjdCA9IGZ1bmN0aW9uKGVsLCBpbmRleCkge1xuICB2YXIga2xhc3MgPSBmYWJyaWNbZmFicmljLnV0aWwuc3RyaW5nLmNhcGl0YWxpemUoZWwudGFnTmFtZS5yZXBsYWNlKCdzdmc6JywgJycpKV07XG4gIGlmIChrbGFzcyAmJiBrbGFzcy5mcm9tRWxlbWVudCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9jcmVhdGVPYmplY3Qoa2xhc3MsIGVsLCBpbmRleCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgIGZhYnJpYy5sb2coZXJyKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5jaGVja0lmRG9uZSgpO1xuICB9XG59O1xuXG5mYWJyaWMuRWxlbWVudHNQYXJzZXIucHJvdG90eXBlLl9jcmVhdGVPYmplY3QgPSBmdW5jdGlvbihrbGFzcywgZWwsIGluZGV4KSB7XG4gIGlmIChrbGFzcy5hc3luYykge1xuICAgIGtsYXNzLmZyb21FbGVtZW50KGVsLCB0aGlzLmNyZWF0ZUNhbGxiYWNrKGluZGV4LCBlbCksIHRoaXMub3B0aW9ucyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIG9iaiA9IGtsYXNzLmZyb21FbGVtZW50KGVsLCB0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMucmVzb2x2ZUdyYWRpZW50KG9iaiwgJ2ZpbGwnKTtcbiAgICB0aGlzLnJlc29sdmVHcmFkaWVudChvYmosICdzdHJva2UnKTtcbiAgICB0aGlzLnJldml2ZXIgJiYgdGhpcy5yZXZpdmVyKGVsLCBvYmopO1xuICAgIHRoaXMuaW5zdGFuY2VzW2luZGV4XSA9IG9iajtcbiAgICB0aGlzLmNoZWNrSWZEb25lKCk7XG4gIH1cbn07XG5cbmZhYnJpYy5FbGVtZW50c1BhcnNlci5wcm90b3R5cGUuY3JlYXRlQ2FsbGJhY2sgPSBmdW5jdGlvbihpbmRleCwgZWwpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgIF90aGlzLnJlc29sdmVHcmFkaWVudChvYmosICdmaWxsJyk7XG4gICAgX3RoaXMucmVzb2x2ZUdyYWRpZW50KG9iaiwgJ3N0cm9rZScpO1xuICAgIF90aGlzLnJldml2ZXIgJiYgX3RoaXMucmV2aXZlcihlbCwgb2JqKTtcbiAgICBfdGhpcy5pbnN0YW5jZXNbaW5kZXhdID0gb2JqO1xuICAgIF90aGlzLmNoZWNrSWZEb25lKCk7XG4gIH07XG59O1xuXG5mYWJyaWMuRWxlbWVudHNQYXJzZXIucHJvdG90eXBlLnJlc29sdmVHcmFkaWVudCA9IGZ1bmN0aW9uKG9iaiwgcHJvcGVydHkpIHtcblxuICB2YXIgaW5zdGFuY2VGaWxsVmFsdWUgPSBvYmouZ2V0KHByb3BlcnR5KTtcbiAgaWYgKCEoL151cmxcXCgvKS50ZXN0KGluc3RhbmNlRmlsbFZhbHVlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZ3JhZGllbnRJZCA9IGluc3RhbmNlRmlsbFZhbHVlLnNsaWNlKDUsIGluc3RhbmNlRmlsbFZhbHVlLmxlbmd0aCAtIDEpO1xuICBpZiAoZmFicmljLmdyYWRpZW50RGVmc1t0aGlzLnN2Z1VpZF1bZ3JhZGllbnRJZF0pIHtcbiAgICBvYmouc2V0KHByb3BlcnR5LFxuICAgICAgZmFicmljLkdyYWRpZW50LmZyb21FbGVtZW50KGZhYnJpYy5ncmFkaWVudERlZnNbdGhpcy5zdmdVaWRdW2dyYWRpZW50SWRdLCBvYmopKTtcbiAgfVxufTtcblxuZmFicmljLkVsZW1lbnRzUGFyc2VyLnByb3RvdHlwZS5jaGVja0lmRG9uZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoLS10aGlzLm51bUVsZW1lbnRzID09PSAwKSB7XG4gICAgdGhpcy5pbnN0YW5jZXMgPSB0aGlzLmluc3RhbmNlcy5maWx0ZXIoZnVuY3Rpb24oZWwpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLCBlcWVxZXFcbiAgICAgIHJldHVybiBlbCAhPSBudWxsO1xuICAgIH0pO1xuICAgIHRoaXMuY2FsbGJhY2sodGhpcy5pbnN0YW5jZXMpO1xuICB9XG59O1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyogQWRhcHRhdGlvbiBvZiB3b3JrIG9mIEtldmluIExpbmRzZXkgKGtldmluQGtldmxpbmRldi5jb20pICovXG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGlmIChmYWJyaWMuUG9pbnQpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlBvaW50IGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZhYnJpYy5Qb2ludCA9IFBvaW50O1xuXG4gIC8qKlxuICAgKiBQb2ludCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlBvaW50XG4gICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdGhpc0FyZ1xuICAgKi9cbiAgZnVuY3Rpb24gUG9pbnQoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxuXG4gIFBvaW50LnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgZmFicmljLlBvaW50LnByb3RvdHlwZSAqLyB7XG5cbiAgICB0eXBlOiAncG9pbnQnLFxuXG4gICAgY29uc3RydWN0b3I6IFBvaW50LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbm90aGVyIHBvaW50IHRvIHRoaXMgb25lIGFuZCByZXR1cm5zIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IG5ldyBQb2ludCBpbnN0YW5jZSB3aXRoIGFkZGVkIHZhbHVlc1xuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICsgdGhhdC54LCB0aGlzLnkgKyB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFub3RoZXIgcG9pbnQgdG8gdGhpcyBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBhZGRFcXVhbHM6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICB0aGlzLnggKz0gdGhhdC54O1xuICAgICAgdGhpcy55ICs9IHRoYXQueTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHZhbHVlIHRvIHRoaXMgcG9pbnQgYW5kIHJldHVybnMgYSBuZXcgb25lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gbmV3IFBvaW50IHdpdGggYWRkZWQgdmFsdWVcbiAgICAgKi9cbiAgICBzY2FsYXJBZGQ6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICsgc2NhbGFyLCB0aGlzLnkgKyBzY2FsYXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHZhbHVlIHRvIHRoaXMgcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNjYWxhckFkZEVxdWFsczogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgdGhpcy54ICs9IHNjYWxhcjtcbiAgICAgIHRoaXMueSArPSBzY2FsYXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIGFub3RoZXIgcG9pbnQgZnJvbSB0aGlzIHBvaW50IGFuZCByZXR1cm5zIGEgbmV3IG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSBuZXcgUG9pbnQgb2JqZWN0IHdpdGggc3VidHJhY3RlZCB2YWx1ZXNcbiAgICAgKi9cbiAgICBzdWJ0cmFjdDogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54IC0gdGhhdC54LCB0aGlzLnkgLSB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgYW5vdGhlciBwb2ludCBmcm9tIHRoaXMgcG9pbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzdWJ0cmFjdEVxdWFsczogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHRoaXMueCAtPSB0aGF0Lng7XG4gICAgICB0aGlzLnkgLT0gdGhhdC55O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB2YWx1ZSBmcm9tIHRoaXMgcG9pbnQgYW5kIHJldHVybnMgYSBuZXcgb25lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBzY2FsYXJTdWJ0cmFjdDogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLSBzY2FsYXIsIHRoaXMueSAtIHNjYWxhcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB2YWx1ZSBmcm9tIHRoaXMgcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNjYWxhclN1YnRyYWN0RXF1YWxzOiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICB0aGlzLnggLT0gc2NhbGFyO1xuICAgICAgdGhpcy55IC09IHNjYWxhcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNaWx0aXBsaWVzIHRoaXMgcG9pbnQgYnkgYSB2YWx1ZSBhbmQgcmV0dXJucyBhIG5ldyBvbmVcbiAgICAgKiBUT0RPOiByZW5hbWUgaW4gc2NhbGFyTXVsdGlwbHkgaW4gMi4wXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBtdWx0aXBseTogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKiBzY2FsYXIsIHRoaXMueSAqIHNjYWxhcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1pbHRpcGxpZXMgdGhpcyBwb2ludCBieSBhIHZhbHVlXG4gICAgICogVE9ETzogcmVuYW1lIGluIHNjYWxhck11bHRpcGx5RXF1YWxzIGluIDIuMFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgbXVsdGlwbHlFcXVhbHM6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHRoaXMueCAqPSBzY2FsYXI7XG4gICAgICB0aGlzLnkgKj0gc2NhbGFyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgdGhpcyBwb2ludCBieSBhIHZhbHVlIGFuZCByZXR1cm5zIGEgbmV3IG9uZVxuICAgICAqIFRPRE86IHJlbmFtZSBpbiBzY2FsYXJEaXZpZGUgaW4gMi4wXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBkaXZpZGU6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54IC8gc2NhbGFyLCB0aGlzLnkgLyBzY2FsYXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIHRoaXMgcG9pbnQgYnkgYSB2YWx1ZVxuICAgICAqIFRPRE86IHJlbmFtZSBpbiBzY2FsYXJEaXZpZGVFcXVhbHMgaW4gMi4wXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkaXZpZGVFcXVhbHM6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHRoaXMueCAvPSBzY2FsYXI7XG4gICAgICB0aGlzLnkgLz0gc2NhbGFyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHBvaW50IGlzIGVxdWFsIHRvIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGVxOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuICh0aGlzLnggPT09IHRoYXQueCAmJiB0aGlzLnkgPT09IHRoYXQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHBvaW50IGlzIGxlc3MgdGhhbiBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBsdDogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiAodGhpcy54IDwgdGhhdC54ICYmIHRoaXMueSA8IHRoYXQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHBvaW50IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBsdGU6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gKHRoaXMueCA8PSB0aGF0LnggJiYgdGhpcy55IDw9IHRoYXQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgZ3JlYXRlciBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBndDogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiAodGhpcy54ID4gdGhhdC54ICYmIHRoaXMueSA+IHRoYXQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHBvaW50IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBndGU6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gKHRoaXMueCA+PSB0aGF0LnggJiYgdGhpcy55ID49IHRoYXQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbmV3IHBvaW50IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgbGluZWFyIGludGVycG9sYXRpb24gd2l0aCB0aGlzIG9uZSBhbmQgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0ICwgcG9zaXRpb24gb2YgaW50ZXJwb2xhdGlvbiwgYmV0d2VlbiAwIGFuZCAxIGRlZmF1bHQgMC41XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIGxlcnA6IGZ1bmN0aW9uICh0aGF0LCB0KSB7XG4gICAgICBpZiAodHlwZW9mIHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHQgPSAwLjU7XG4gICAgICB9XG4gICAgICB0ID0gTWF0aC5tYXgoTWF0aC5taW4oMSwgdCksIDApO1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyAodGhhdC54IC0gdGhpcy54KSAqIHQsIHRoaXMueSArICh0aGF0LnkgLSB0aGlzLnkpICogdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGlzdGFuY2UgZnJvbSB0aGlzIHBvaW50IGFuZCBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGRpc3RhbmNlRnJvbTogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHZhciBkeCA9IHRoaXMueCAtIHRoYXQueCxcbiAgICAgICAgICBkeSA9IHRoaXMueSAtIHRoYXQueTtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb2ludCBiZXR3ZWVuIHRoaXMgcG9pbnQgYW5kIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgbWlkUG9pbnRGcm9tOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVycCh0aGF0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBwb2ludCB3aGljaCBpcyB0aGUgbWluIG9mIHRoaXMgYW5kIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgbWluOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludChNYXRoLm1pbih0aGlzLngsIHRoYXQueCksIE1hdGgubWluKHRoaXMueSwgdGhhdC55KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgcG9pbnQgd2hpY2ggaXMgdGhlIG1heCBvZiB0aGlzIGFuZCBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIG1heDogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQoTWF0aC5tYXgodGhpcy54LCB0aGF0LngpLCBNYXRoLm1heCh0aGlzLnksIHRoYXQueSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHBvaW50XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy54ICsgJywnICsgdGhpcy55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHgveSBvZiB0aGlzIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRYWTogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgeCBvZiB0aGlzIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0WDogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB5IG9mIHRoaXMgcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRZOiBmdW5jdGlvbiAoeSkge1xuICAgICAgdGhpcy55ID0geTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHgveSBvZiB0aGlzIHBvaW50IGZyb20gYW5vdGhlciBwb2ludFxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldEZyb21Qb2ludDogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHRoaXMueCA9IHRoYXQueDtcbiAgICAgIHRoaXMueSA9IHRoYXQueTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTd2FwcyB4L3kgb2YgdGhpcyBwb2ludCBhbmQgYW5vdGhlciBwb2ludFxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICovXG4gICAgc3dhcDogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHZhciB4ID0gdGhpcy54LFxuICAgICAgICAgIHkgPSB0aGlzLnk7XG4gICAgICB0aGlzLnggPSB0aGF0Lng7XG4gICAgICB0aGlzLnkgPSB0aGF0Lnk7XG4gICAgICB0aGF0LnggPSB4O1xuICAgICAgdGhhdC55ID0geTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGEgY2xvbmVkIGluc3RhbmNlIG9mIHRoZSBwb2ludFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKiBBZGFwdGF0aW9uIG9mIHdvcmsgb2YgS2V2aW4gTGluZHNleSAoa2V2aW5Aa2V2bGluZGV2LmNvbSkgKi9cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGlmIChmYWJyaWMuSW50ZXJzZWN0aW9uKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5JbnRlcnNlY3Rpb24gaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVyc2VjdGlvbiBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkludGVyc2VjdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gSW50ZXJzZWN0aW9uKHN0YXR1cykge1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMucG9pbnRzID0gW107XG4gIH1cblxuICBmYWJyaWMuSW50ZXJzZWN0aW9uID0gSW50ZXJzZWN0aW9uO1xuXG4gIGZhYnJpYy5JbnRlcnNlY3Rpb24ucHJvdG90eXBlID0gLyoqIEBsZW5kcyBmYWJyaWMuSW50ZXJzZWN0aW9uLnByb3RvdHlwZSAqLyB7XG5cbiAgICBjb25zdHJ1Y3RvcjogSW50ZXJzZWN0aW9uLFxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kcyBhIHBvaW50IHRvIGludGVyc2VjdGlvblxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JbnRlcnNlY3Rpb259IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYXBwZW5kUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgdGhpcy5wb2ludHMucHVzaChwb2ludCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kcyBwb2ludHMgdG8gaW50ZXJzZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzXG4gICAgICogQHJldHVybiB7ZmFicmljLkludGVyc2VjdGlvbn0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBhcHBlbmRQb2ludHM6IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICAgIHRoaXMucG9pbnRzID0gdGhpcy5wb2ludHMuY29uY2F0KHBvaW50cyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBvbmUgbGluZSBpbnRlcnNlY3RzIGFub3RoZXJcbiAgICogVE9ETzogcmVuYW1lIGluIGludGVyc2VjdFNlZ21lbnRTZWdtZW50XG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGExXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBhMlxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gYjFcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGIyXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbnRlcnNlY3Rpb259XG4gICAqL1xuICBmYWJyaWMuSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVMaW5lID0gZnVuY3Rpb24gKGExLCBhMiwgYjEsIGIyKSB7XG4gICAgdmFyIHJlc3VsdCxcbiAgICAgICAgdWFUID0gKGIyLnggLSBiMS54KSAqIChhMS55IC0gYjEueSkgLSAoYjIueSAtIGIxLnkpICogKGExLnggLSBiMS54KSxcbiAgICAgICAgdWJUID0gKGEyLnggLSBhMS54KSAqIChhMS55IC0gYjEueSkgLSAoYTIueSAtIGExLnkpICogKGExLnggLSBiMS54KSxcbiAgICAgICAgdUIgPSAoYjIueSAtIGIxLnkpICogKGEyLnggLSBhMS54KSAtIChiMi54IC0gYjEueCkgKiAoYTIueSAtIGExLnkpO1xuICAgIGlmICh1QiAhPT0gMCkge1xuICAgICAgdmFyIHVhID0gdWFUIC8gdUIsXG4gICAgICAgICAgdWIgPSB1YlQgLyB1QjtcbiAgICAgIGlmICgwIDw9IHVhICYmIHVhIDw9IDEgJiYgMCA8PSB1YiAmJiB1YiA8PSAxKSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oJ0ludGVyc2VjdGlvbicpO1xuICAgICAgICByZXN1bHQuYXBwZW5kUG9pbnQobmV3IGZhYnJpYy5Qb2ludChhMS54ICsgdWEgKiAoYTIueCAtIGExLngpLCBhMS55ICsgdWEgKiAoYTIueSAtIGExLnkpKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmICh1YVQgPT09IDAgfHwgdWJUID09PSAwKSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oJ0NvaW5jaWRlbnQnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCdQYXJhbGxlbCcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgbGluZSBpbnRlcnNlY3RzIHBvbHlnb25cbiAgICogVE9ETzogcmVuYW1lIGluIGludGVyc2VjdFNlZ21lbnRQb2x5Z29uXG4gICAqIGZpeCBkZXRlY3Rpb24gb2YgY29pbmNpZGVudFxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBhMVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gYTJcbiAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbnRlcnNlY3Rpb259XG4gICAqL1xuICBmYWJyaWMuSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uID0gZnVuY3Rpb24oYTEsIGEyLCBwb2ludHMpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbigpLFxuICAgICAgICBsZW5ndGggPSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBiMSwgYjIsIGludGVyO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYjEgPSBwb2ludHNbaV07XG4gICAgICBiMiA9IHBvaW50c1soaSArIDEpICUgbGVuZ3RoXTtcbiAgICAgIGludGVyID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVMaW5lKGExLCBhMiwgYjEsIGIyKTtcblxuICAgICAgcmVzdWx0LmFwcGVuZFBvaW50cyhpbnRlci5wb2ludHMpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LnBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQuc3RhdHVzID0gJ0ludGVyc2VjdGlvbic7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBwb2x5Z29uIGludGVyc2VjdHMgYW5vdGhlciBwb2x5Z29uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzMVxuICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMyXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbnRlcnNlY3Rpb259XG4gICAqL1xuICBmYWJyaWMuSW50ZXJzZWN0aW9uLmludGVyc2VjdFBvbHlnb25Qb2x5Z29uID0gZnVuY3Rpb24gKHBvaW50czEsIHBvaW50czIpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbigpLFxuICAgICAgICBsZW5ndGggPSBwb2ludHMxLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhMSA9IHBvaW50czFbaV0sXG4gICAgICAgICAgYTIgPSBwb2ludHMxWyhpICsgMSkgJSBsZW5ndGhdLFxuICAgICAgICAgIGludGVyID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uKGExLCBhMiwgcG9pbnRzMik7XG5cbiAgICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXIucG9pbnRzKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5wb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnN0YXR1cyA9ICdJbnRlcnNlY3Rpb24nO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgcG9seWdvbiBpbnRlcnNlY3RzIHJlY3RhbmdsZVxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50c1xuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcjFcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHIyXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbnRlcnNlY3Rpb259XG4gICAqL1xuICBmYWJyaWMuSW50ZXJzZWN0aW9uLmludGVyc2VjdFBvbHlnb25SZWN0YW5nbGUgPSBmdW5jdGlvbiAocG9pbnRzLCByMSwgcjIpIHtcbiAgICB2YXIgbWluID0gcjEubWluKHIyKSxcbiAgICAgICAgbWF4ID0gcjEubWF4KHIyKSxcbiAgICAgICAgdG9wUmlnaHQgPSBuZXcgZmFicmljLlBvaW50KG1heC54LCBtaW4ueSksXG4gICAgICAgIGJvdHRvbUxlZnQgPSBuZXcgZmFicmljLlBvaW50KG1pbi54LCBtYXgueSksXG4gICAgICAgIGludGVyMSA9IEludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lUG9seWdvbihtaW4sIHRvcFJpZ2h0LCBwb2ludHMpLFxuICAgICAgICBpbnRlcjIgPSBJbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZVBvbHlnb24odG9wUmlnaHQsIG1heCwgcG9pbnRzKSxcbiAgICAgICAgaW50ZXIzID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uKG1heCwgYm90dG9tTGVmdCwgcG9pbnRzKSxcbiAgICAgICAgaW50ZXI0ID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uKGJvdHRvbUxlZnQsIG1pbiwgcG9pbnRzKSxcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbigpO1xuXG4gICAgcmVzdWx0LmFwcGVuZFBvaW50cyhpbnRlcjEucG9pbnRzKTtcbiAgICByZXN1bHQuYXBwZW5kUG9pbnRzKGludGVyMi5wb2ludHMpO1xuICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXIzLnBvaW50cyk7XG4gICAgcmVzdWx0LmFwcGVuZFBvaW50cyhpbnRlcjQucG9pbnRzKTtcblxuICAgIGlmIChyZXN1bHQucG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlc3VsdC5zdGF0dXMgPSAnSW50ZXJzZWN0aW9uJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGlmIChmYWJyaWMuQ29sb3IpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkNvbG9yIGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogQ29sb3IgY2xhc3NcbiAgICogVGhlIHB1cnBvc2Ugb2Yge0BsaW5rIGZhYnJpYy5Db2xvcn0gaXMgdG8gYWJzdHJhY3QgYW5kIGVuY2Fwc3VsYXRlIGNvbW1vbiBjb2xvciBvcGVyYXRpb25zO1xuICAgKiB7QGxpbmsgZmFicmljLkNvbG9yfSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBjcmVhdGVzIGluc3RhbmNlcyBvZiB7QGxpbmsgZmFicmljLkNvbG9yfSBvYmplY3RzLlxuICAgKlxuICAgKiBAY2xhc3MgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBvcHRpb25hbCBpbiBoZXggb3IgcmdiKGEpIG9yIGhzbCBmb3JtYXQgb3IgZnJvbSBrbm93biBjb2xvciBsaXN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn0gdGhpc0FyZ1xuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMi8jY29sb3JzfVxuICAgKi9cbiAgZnVuY3Rpb24gQ29sb3IoY29sb3IpIHtcbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICB0aGlzLnNldFNvdXJjZShbMCwgMCwgMCwgMV0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX3RyeVBhcnNpbmdDb2xvcihjb2xvcik7XG4gICAgfVxuICB9XG5cbiAgZmFicmljLkNvbG9yID0gQ29sb3I7XG5cbiAgZmFicmljLkNvbG9yLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgZmFicmljLkNvbG9yLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBjb2xvciBDb2xvciB2YWx1ZSB0byBwYXJzZVxuICAgICAqL1xuICAgIF90cnlQYXJzaW5nQ29sb3I6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICB2YXIgc291cmNlO1xuXG4gICAgICBpZiAoY29sb3IgaW4gQ29sb3IuY29sb3JOYW1lTWFwKSB7XG4gICAgICAgIGNvbG9yID0gQ29sb3IuY29sb3JOYW1lTWFwW2NvbG9yXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgIHNvdXJjZSA9IFsyNTUsIDI1NSwgMjU1LCAwXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgc291cmNlID0gQ29sb3Iuc291cmNlRnJvbUhleChjb2xvcik7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBzb3VyY2UgPSBDb2xvci5zb3VyY2VGcm9tUmdiKGNvbG9yKTtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHNvdXJjZSA9IENvbG9yLnNvdXJjZUZyb21Ic2woY29sb3IpO1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgLy9pZiBjb2xvciBpcyBub3QgcmVjb2duaXplIGxldCdzIG1ha2UgYmxhY2sgYXMgY2FudmFzIGRvZXNcbiAgICAgICAgc291cmNlID0gWzAsIDAsIDAsIDFdO1xuICAgICAgfVxuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICB0aGlzLnNldFNvdXJjZShzb3VyY2UpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGFwdGVkIGZyb20gPGEgaHJlZj1cImh0dHBzOi8vcmF3Z2l0aHViLmNvbS9tamlqYWNrc29uL21qaWphY2tzb24uZ2l0aHViLmNvbS9tYXN0ZXIvMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0Lmh0bWxcIj5odHRwczovL2dpdGh1Yi5jb20vbWppamFja3NvbjwvYT5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByIFJlZCBjb2xvciB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBnIEdyZWVuIGNvbG9yIHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgQmx1ZSBjb2xvciB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBIc2wgY29sb3JcbiAgICAgKi9cbiAgICBfcmdiVG9Ic2w6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcbiAgICAgIHIgLz0gMjU1OyBnIC89IDI1NTsgYiAvPSAyNTU7XG5cbiAgICAgIHZhciBoLCBzLCBsLFxuICAgICAgICAgIG1heCA9IGZhYnJpYy51dGlsLmFycmF5Lm1heChbciwgZywgYl0pLFxuICAgICAgICAgIG1pbiA9IGZhYnJpYy51dGlsLmFycmF5Lm1pbihbciwgZywgYl0pO1xuXG4gICAgICBsID0gKG1heCArIG1pbikgLyAyO1xuXG4gICAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgICAgaCA9IHMgPSAwOyAvLyBhY2hyb21hdGljXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGQgPSBtYXggLSBtaW47XG4gICAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICAgICAgc3dpdGNoIChtYXgpIHtcbiAgICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgICBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGc6XG4gICAgICAgICAgICBoID0gKGIgLSByKSAvIGQgKyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBiOlxuICAgICAgICAgICAgaCA9IChyIC0gZykgLyBkICsgNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGggLz0gNjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgTWF0aC5yb3VuZChoICogMzYwKSxcbiAgICAgICAgTWF0aC5yb3VuZChzICogMTAwKSxcbiAgICAgICAgTWF0aC5yb3VuZChsICogMTAwKVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzb3VyY2Ugb2YgdGhpcyBjb2xvciAod2hlcmUgc291cmNlIGlzIGFuIGFycmF5IHJlcHJlc2VudGF0aW9uOyBleDogWzIwMCwgMjAwLCAxMDAsIDFdKVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGdldFNvdXJjZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc291cmNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNvdXJjZSBvZiB0aGlzIGNvbG9yICh3aGVyZSBzb3VyY2UgaXMgYW4gYXJyYXkgcmVwcmVzZW50YXRpb247IGV4OiBbMjAwLCAyMDAsIDEwMCwgMV0pXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlXG4gICAgICovXG4gICAgc2V0U291cmNlOiBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xvciByZXByZXNlbmF0aW9uIGluIFJHQiBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiByZ2IoMC0yNTUsMC0yNTUsMC0yNTUpXG4gICAgICovXG4gICAgdG9SZ2I6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCk7XG4gICAgICByZXR1cm4gJ3JnYignICsgc291cmNlWzBdICsgJywnICsgc291cmNlWzFdICsgJywnICsgc291cmNlWzJdICsgJyknO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbG9yIHJlcHJlc2VuYXRpb24gaW4gUkdCQSBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiByZ2JhKDAtMjU1LDAtMjU1LDAtMjU1LDAtMSlcbiAgICAgKi9cbiAgICB0b1JnYmE6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCk7XG4gICAgICByZXR1cm4gJ3JnYmEoJyArIHNvdXJjZVswXSArICcsJyArIHNvdXJjZVsxXSArICcsJyArIHNvdXJjZVsyXSArICcsJyArIHNvdXJjZVszXSArICcpJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xvciByZXByZXNlbmF0aW9uIGluIEhTTCBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiBoc2woMC0zNjAsMCUtMTAwJSwwJS0xMDAlKVxuICAgICAqL1xuICAgIHRvSHNsOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGhzbCA9IHRoaXMuX3JnYlRvSHNsKHNvdXJjZVswXSwgc291cmNlWzFdLCBzb3VyY2VbMl0pO1xuXG4gICAgICByZXR1cm4gJ2hzbCgnICsgaHNsWzBdICsgJywnICsgaHNsWzFdICsgJyUsJyArIGhzbFsyXSArICclKSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29sb3IgcmVwcmVzZW5hdGlvbiBpbiBIU0xBIGZvcm1hdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZXg6IGhzbGEoMC0zNjAsMCUtMTAwJSwwJS0xMDAlLDAtMSlcbiAgICAgKi9cbiAgICB0b0hzbGE6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCksXG4gICAgICAgICAgaHNsID0gdGhpcy5fcmdiVG9Ic2woc291cmNlWzBdLCBzb3VyY2VbMV0sIHNvdXJjZVsyXSk7XG5cbiAgICAgIHJldHVybiAnaHNsYSgnICsgaHNsWzBdICsgJywnICsgaHNsWzFdICsgJyUsJyArIGhzbFsyXSArICclLCcgKyBzb3VyY2VbM10gKyAnKSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29sb3IgcmVwcmVzZW5hdGlvbiBpbiBIRVggZm9ybWF0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBleDogRkY1NTU1XG4gICAgICovXG4gICAgdG9IZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCksIHIsIGcsIGI7XG5cbiAgICAgIHIgPSBzb3VyY2VbMF0udG9TdHJpbmcoMTYpO1xuICAgICAgciA9IChyLmxlbmd0aCA9PT0gMSkgPyAoJzAnICsgcikgOiByO1xuXG4gICAgICBnID0gc291cmNlWzFdLnRvU3RyaW5nKDE2KTtcbiAgICAgIGcgPSAoZy5sZW5ndGggPT09IDEpID8gKCcwJyArIGcpIDogZztcblxuICAgICAgYiA9IHNvdXJjZVsyXS50b1N0cmluZygxNik7XG4gICAgICBiID0gKGIubGVuZ3RoID09PSAxKSA/ICgnMCcgKyBiKSA6IGI7XG5cbiAgICAgIHJldHVybiByLnRvVXBwZXJDYXNlKCkgKyBnLnRvVXBwZXJDYXNlKCkgKyBiLnRvVXBwZXJDYXNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdmFsdWUgb2YgYWxwaGEgY2hhbm5lbCBmb3IgdGhpcyBjb2xvclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gMC0xXG4gICAgICovXG4gICAgZ2V0QWxwaGE6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U291cmNlKClbM107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdmFsdWUgb2YgYWxwaGEgY2hhbm5lbCBmb3IgdGhpcyBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbHBoYSBBbHBoYSB2YWx1ZSAwLTFcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBzZXRBbHBoYTogZnVuY3Rpb24oYWxwaGEpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpO1xuICAgICAgc291cmNlWzNdID0gYWxwaGE7XG4gICAgICB0aGlzLnNldFNvdXJjZShzb3VyY2UpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgY29sb3IgdG8gaXRzIGdyYXlzY2FsZSByZXByZXNlbnRhdGlvblxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHRvR3JheXNjYWxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGF2ZXJhZ2UgPSBwYXJzZUludCgoc291cmNlWzBdICogMC4zICsgc291cmNlWzFdICogMC41OSArIHNvdXJjZVsyXSAqIDAuMTEpLnRvRml4ZWQoMCksIDEwKSxcbiAgICAgICAgICBjdXJyZW50QWxwaGEgPSBzb3VyY2VbM107XG4gICAgICB0aGlzLnNldFNvdXJjZShbYXZlcmFnZSwgYXZlcmFnZSwgYXZlcmFnZSwgY3VycmVudEFscGhhXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBjb2xvciB0byBpdHMgYmxhY2sgYW5kIHdoaXRlIHJlcHJlc2VudGF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRocmVzaG9sZFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHRvQmxhY2tXaGl0ZTogZnVuY3Rpb24odGhyZXNob2xkKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKSxcbiAgICAgICAgICBhdmVyYWdlID0gKHNvdXJjZVswXSAqIDAuMyArIHNvdXJjZVsxXSAqIDAuNTkgKyBzb3VyY2VbMl0gKiAwLjExKS50b0ZpeGVkKDApLFxuICAgICAgICAgIGN1cnJlbnRBbHBoYSA9IHNvdXJjZVszXTtcblxuICAgICAgdGhyZXNob2xkID0gdGhyZXNob2xkIHx8IDEyNztcblxuICAgICAgYXZlcmFnZSA9IChOdW1iZXIoYXZlcmFnZSkgPCBOdW1iZXIodGhyZXNob2xkKSkgPyAwIDogMjU1O1xuICAgICAgdGhpcy5zZXRTb3VyY2UoW2F2ZXJhZ2UsIGF2ZXJhZ2UsIGF2ZXJhZ2UsIGN1cnJlbnRBbHBoYV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE92ZXJsYXlzIGNvbG9yIHdpdGggYW5vdGhlciBjb2xvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfGZhYnJpYy5Db2xvcn0gb3RoZXJDb2xvclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn0gdGhpc0FyZ1xuICAgICAqL1xuICAgIG92ZXJsYXlXaXRoOiBmdW5jdGlvbihvdGhlckNvbG9yKSB7XG4gICAgICBpZiAoIShvdGhlckNvbG9yIGluc3RhbmNlb2YgQ29sb3IpKSB7XG4gICAgICAgIG90aGVyQ29sb3IgPSBuZXcgQ29sb3Iob3RoZXJDb2xvcik7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBhbHBoYSA9IHRoaXMuZ2V0QWxwaGEoKSxcbiAgICAgICAgICBvdGhlckFscGhhID0gMC41LFxuICAgICAgICAgIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCksXG4gICAgICAgICAgb3RoZXJTb3VyY2UgPSBvdGhlckNvbG9yLmdldFNvdXJjZSgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChNYXRoLnJvdW5kKChzb3VyY2VbaV0gKiAoMSAtIG90aGVyQWxwaGEpKSArIChvdGhlclNvdXJjZVtpXSAqIG90aGVyQWxwaGEpKSk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdFszXSA9IGFscGhhO1xuICAgICAgdGhpcy5zZXRTb3VyY2UocmVzdWx0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVnZXggbWF0Y2hpbmcgY29sb3IgaW4gUkdCIG9yIFJHQkEgZm9ybWF0cyAoZXg6IHJnYigwLCAwLCAwKSwgcmdiYSgyNTUsIDEwMCwgMTAsIDAuNSksIHJnYmEoIDI1NSAsIDEwMCAsIDEwICwgMC41ICksIHJnYigxLDEsMSksIHJnYmEoMTAwJSwgNjAlLCAxMCUsIDAuNSkpXG4gICAqIEBzdGF0aWNcbiAgICogQGZpZWxkXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICovXG4gICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICBmYWJyaWMuQ29sb3IucmVSR0JhID0gL15yZ2JhP1xcKFxccyooXFxkezEsM30oPzpcXC5cXGQrKT9cXCU/KVxccyosXFxzKihcXGR7MSwzfSg/OlxcLlxcZCspP1xcJT8pXFxzKixcXHMqKFxcZHsxLDN9KD86XFwuXFxkKyk/XFwlPylcXHMqKD86XFxzKixcXHMqKFxcZCsoPzpcXC5cXGQrKT8pXFxzKik/XFwpJC87XG5cbiAgLyoqXG4gICAqIFJlZ2V4IG1hdGNoaW5nIGNvbG9yIGluIEhTTCBvciBIU0xBIGZvcm1hdHMgKGV4OiBoc2woMjAwLCA4MCUsIDEwJSksIGhzbGEoMzAwLCA1MCUsIDgwJSwgMC41KSwgaHNsYSggMzAwICwgNTAlICwgODAlICwgMC41ICkpXG4gICAqIEBzdGF0aWNcbiAgICogQGZpZWxkXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICovXG4gIGZhYnJpYy5Db2xvci5yZUhTTGEgPSAvXmhzbGE/XFwoXFxzKihcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM31cXCUpXFxzKixcXHMqKFxcZHsxLDN9XFwlKVxccyooPzpcXHMqLFxccyooXFxkKyg/OlxcLlxcZCspPylcXHMqKT9cXCkkLztcblxuICAvKipcbiAgICogUmVnZXggbWF0Y2hpbmcgY29sb3IgaW4gSEVYIGZvcm1hdCAoZXg6ICNGRjU1NDRDQywgI0ZGNTU1NSwgMDEwMTU1LCBhZmYpXG4gICAqIEBzdGF0aWNcbiAgICogQGZpZWxkXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICovXG4gIGZhYnJpYy5Db2xvci5yZUhleCA9IC9eIz8oWzAtOWEtZl17OH18WzAtOWEtZl17Nn18WzAtOWEtZl17NH18WzAtOWEtZl17M30pJC9pO1xuXG4gIC8qKlxuICAgKiBNYXAgb2YgdGhlIDE3IGJhc2ljIGNvbG9yIG5hbWVzIHdpdGggSEVYIGNvZGVcbiAgICogQHN0YXRpY1xuICAgKiBAZmllbGRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAc2VlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyL3N5bmRhdGEuaHRtbCNjb2xvci11bml0c1xuICAgKi9cbiAgZmFicmljLkNvbG9yLmNvbG9yTmFtZU1hcCA9IHtcbiAgICBhcXVhOiAgICAnIzAwRkZGRicsXG4gICAgYmxhY2s6ICAgJyMwMDAwMDAnLFxuICAgIGJsdWU6ICAgICcjMDAwMEZGJyxcbiAgICBmdWNoc2lhOiAnI0ZGMDBGRicsXG4gICAgZ3JheTogICAgJyM4MDgwODAnLFxuICAgIGdyZXk6ICAgICcjODA4MDgwJyxcbiAgICBncmVlbjogICAnIzAwODAwMCcsXG4gICAgbGltZTogICAgJyMwMEZGMDAnLFxuICAgIG1hcm9vbjogICcjODAwMDAwJyxcbiAgICBuYXZ5OiAgICAnIzAwMDA4MCcsXG4gICAgb2xpdmU6ICAgJyM4MDgwMDAnLFxuICAgIG9yYW5nZTogICcjRkZBNTAwJyxcbiAgICBwdXJwbGU6ICAnIzgwMDA4MCcsXG4gICAgcmVkOiAgICAgJyNGRjAwMDAnLFxuICAgIHNpbHZlcjogICcjQzBDMEMwJyxcbiAgICB0ZWFsOiAgICAnIzAwODA4MCcsXG4gICAgd2hpdGU6ICAgJyNGRkZGRkYnLFxuICAgIHllbGxvdzogICcjRkZGRjAwJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcFxuICAgKiBAcGFyYW0ge051bWJlcn0gcVxuICAgKiBAcGFyYW0ge051bWJlcn0gdFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgICBpZiAodCA8IDApIHtcbiAgICAgIHQgKz0gMTtcbiAgICB9XG4gICAgaWYgKHQgPiAxKSB7XG4gICAgICB0IC09IDE7XG4gICAgfVxuICAgIGlmICh0IDwgMSAvIDYpIHtcbiAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgIH1cbiAgICBpZiAodCA8IDEgLyAyKSB7XG4gICAgICByZXR1cm4gcTtcbiAgICB9XG4gICAgaWYgKHQgPCAyIC8gMykge1xuICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gYSBjb2xvciBpbiBSR0IgZm9ybWF0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIENvbG9yIHZhbHVlIGV4OiByZ2IoMC0yNTUsMC0yNTUsMC0yNTUpXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn1cbiAgICovXG4gIGZhYnJpYy5Db2xvci5mcm9tUmdiID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICByZXR1cm4gQ29sb3IuZnJvbVNvdXJjZShDb2xvci5zb3VyY2VGcm9tUmdiKGNvbG9yKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYXJyYXkgcmVwcmVzZW50YXRpb24gKGV4OiBbMTAwLCAxMDAsIDIwMCwgMV0pIG9mIGEgY29sb3IgdGhhdCdzIGluIFJHQiBvciBSR0JBIGZvcm1hdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciB2YWx1ZSBleDogcmdiKDAtMjU1LDAtMjU1LDAtMjU1KSwgcmdiKDAlLTEwMCUsMCUtMTAwJSwwJS0xMDAlKVxuICAgKiBAcmV0dXJuIHtBcnJheX0gc291cmNlXG4gICAqL1xuICBmYWJyaWMuQ29sb3Iuc291cmNlRnJvbVJnYiA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgdmFyIG1hdGNoID0gY29sb3IubWF0Y2goQ29sb3IucmVSR0JhKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciByID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKSAvICgvJSQvLnRlc3QobWF0Y2hbMV0pID8gMTAwIDogMSkgKiAoLyUkLy50ZXN0KG1hdGNoWzFdKSA/IDI1NSA6IDEpLFxuICAgICAgICAgIGcgPSBwYXJzZUludChtYXRjaFsyXSwgMTApIC8gKC8lJC8udGVzdChtYXRjaFsyXSkgPyAxMDAgOiAxKSAqICgvJSQvLnRlc3QobWF0Y2hbMl0pID8gMjU1IDogMSksXG4gICAgICAgICAgYiA9IHBhcnNlSW50KG1hdGNoWzNdLCAxMCkgLyAoLyUkLy50ZXN0KG1hdGNoWzNdKSA/IDEwMCA6IDEpICogKC8lJC8udGVzdChtYXRjaFszXSkgPyAyNTUgOiAxKTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgcGFyc2VJbnQociwgMTApLFxuICAgICAgICBwYXJzZUludChnLCAxMCksXG4gICAgICAgIHBhcnNlSW50KGIsIDEwKSxcbiAgICAgICAgbWF0Y2hbNF0gPyBwYXJzZUZsb2F0KG1hdGNoWzRdKSA6IDFcbiAgICAgIF07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gYSBjb2xvciBpbiBSR0JBIGZvcm1hdFxuICAgKiBAc3RhdGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvclxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbVJnYmEgPSBDb2xvci5mcm9tUmdiO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gYSBjb2xvciBpbiBIU0wgZm9ybWF0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciB2YWx1ZSBleDogaHNsKDAtMjYwLDAlLTEwMCUsMCUtMTAwJSlcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbUhzbCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIENvbG9yLmZyb21Tb3VyY2UoQ29sb3Iuc291cmNlRnJvbUhzbChjb2xvcikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFycmF5IHJlcHJlc2VudGF0aW9uIChleDogWzEwMCwgMTAwLCAyMDAsIDFdKSBvZiBhIGNvbG9yIHRoYXQncyBpbiBIU0wgb3IgSFNMQSBmb3JtYXQuXG4gICAqIEFkYXB0ZWQgZnJvbSA8YSBocmVmPVwiaHR0cHM6Ly9yYXdnaXRodWIuY29tL21qaWphY2tzb24vbWppamFja3Nvbi5naXRodWIuY29tL21hc3Rlci8yMDA4LzAyL3JnYi10by1oc2wtYW5kLXJnYi10by1oc3YtY29sb3ItbW9kZWwtY29udmVyc2lvbi1hbGdvcml0aG1zLWluLWphdmFzY3JpcHQuaHRtbFwiPmh0dHBzOi8vZ2l0aHViLmNvbS9tamlqYWNrc29uPC9hPlxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciB2YWx1ZSBleDogaHNsKDAtMzYwLDAlLTEwMCUsMCUtMTAwJSkgb3IgaHNsYSgwLTM2MCwwJS0xMDAlLDAlLTEwMCUsIDAtMSlcbiAgICogQHJldHVybiB7QXJyYXl9IHNvdXJjZVxuICAgKiBAc2VlIGh0dHA6Ly9odHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNoc2wtY29sb3JcbiAgICovXG4gIGZhYnJpYy5Db2xvci5zb3VyY2VGcm9tSHNsID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICB2YXIgbWF0Y2ggPSBjb2xvci5tYXRjaChDb2xvci5yZUhTTGEpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaCA9ICgoKHBhcnNlRmxvYXQobWF0Y2hbMV0pICUgMzYwKSArIDM2MCkgJSAzNjApIC8gMzYwLFxuICAgICAgICBzID0gcGFyc2VGbG9hdChtYXRjaFsyXSkgLyAoLyUkLy50ZXN0KG1hdGNoWzJdKSA/IDEwMCA6IDEpLFxuICAgICAgICBsID0gcGFyc2VGbG9hdChtYXRjaFszXSkgLyAoLyUkLy50ZXN0KG1hdGNoWzNdKSA/IDEwMCA6IDEpLFxuICAgICAgICByLCBnLCBiO1xuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIHIgPSBnID0gYiA9IGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHEgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcyxcbiAgICAgICAgICBwID0gbCAqIDIgLSBxO1xuXG4gICAgICByID0gaHVlMnJnYihwLCBxLCBoICsgMSAvIDMpO1xuICAgICAgZyA9IGh1ZTJyZ2IocCwgcSwgaCk7XG4gICAgICBiID0gaHVlMnJnYihwLCBxLCBoIC0gMSAvIDMpO1xuICAgIH1cblxuICAgIHJldHVybiBbXG4gICAgICBNYXRoLnJvdW5kKHIgKiAyNTUpLFxuICAgICAgTWF0aC5yb3VuZChnICogMjU1KSxcbiAgICAgIE1hdGgucm91bmQoYiAqIDI1NSksXG4gICAgICBtYXRjaFs0XSA/IHBhcnNlRmxvYXQobWF0Y2hbNF0pIDogMVxuICAgIF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbmV3IGNvbG9yIG9iamVjdCwgd2hlbiBnaXZlbiBhIGNvbG9yIGluIEhTTEEgZm9ybWF0XG4gICAqIEBzdGF0aWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn1cbiAgICovXG4gIGZhYnJpYy5Db2xvci5mcm9tSHNsYSA9IENvbG9yLmZyb21Ic2w7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbmV3IGNvbG9yIG9iamVjdCwgd2hlbiBnaXZlbiBhIGNvbG9yIGluIEhFWCBmb3JtYXRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciB2YWx1ZSBleDogRkY1NTU1XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn1cbiAgICovXG4gIGZhYnJpYy5Db2xvci5mcm9tSGV4ID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICByZXR1cm4gQ29sb3IuZnJvbVNvdXJjZShDb2xvci5zb3VyY2VGcm9tSGV4KGNvbG9yKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYXJyYXkgcmVwcmVzZW50YXRpb24gKGV4OiBbMTAwLCAxMDAsIDIwMCwgMV0pIG9mIGEgY29sb3IgdGhhdCdzIGluIEhFWCBmb3JtYXRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBleDogRkY1NTU1IG9yIEZGNTU0NENDIChSR0JhKVxuICAgKiBAcmV0dXJuIHtBcnJheX0gc291cmNlXG4gICAqL1xuICBmYWJyaWMuQ29sb3Iuc291cmNlRnJvbUhleCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgaWYgKGNvbG9yLm1hdGNoKENvbG9yLnJlSGV4KSkge1xuICAgICAgdmFyIHZhbHVlID0gY29sb3Iuc2xpY2UoY29sb3IuaW5kZXhPZignIycpICsgMSksXG4gICAgICAgICAgaXNTaG9ydE5vdGF0aW9uID0gKHZhbHVlLmxlbmd0aCA9PT0gMyB8fCB2YWx1ZS5sZW5ndGggPT09IDQpLFxuICAgICAgICAgIGlzUkdCYSA9ICh2YWx1ZS5sZW5ndGggPT09IDggfHwgdmFsdWUubGVuZ3RoID09PSA0KSxcbiAgICAgICAgICByID0gaXNTaG9ydE5vdGF0aW9uID8gKHZhbHVlLmNoYXJBdCgwKSArIHZhbHVlLmNoYXJBdCgwKSkgOiB2YWx1ZS5zdWJzdHJpbmcoMCwgMiksXG4gICAgICAgICAgZyA9IGlzU2hvcnROb3RhdGlvbiA/ICh2YWx1ZS5jaGFyQXQoMSkgKyB2YWx1ZS5jaGFyQXQoMSkpIDogdmFsdWUuc3Vic3RyaW5nKDIsIDQpLFxuICAgICAgICAgIGIgPSBpc1Nob3J0Tm90YXRpb24gPyAodmFsdWUuY2hhckF0KDIpICsgdmFsdWUuY2hhckF0KDIpKSA6IHZhbHVlLnN1YnN0cmluZyg0LCA2KSxcbiAgICAgICAgICBhID0gaXNSR0JhID8gKGlzU2hvcnROb3RhdGlvbiA/ICh2YWx1ZS5jaGFyQXQoMykgKyB2YWx1ZS5jaGFyQXQoMykpIDogdmFsdWUuc3Vic3RyaW5nKDYsIDgpKSA6ICdGRic7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHBhcnNlSW50KHIsIDE2KSxcbiAgICAgICAgcGFyc2VJbnQoZywgMTYpLFxuICAgICAgICBwYXJzZUludChiLCAxNiksXG4gICAgICAgIHBhcnNlRmxvYXQoKHBhcnNlSW50KGEsIDE2KSAvIDI1NSkudG9GaXhlZCgyKSlcbiAgICAgIF07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gY29sb3IgaW4gYXJyYXkgcmVwcmVzZW50YXRpb24gKGV4OiBbMjAwLCAxMDAsIDEwMCwgMC41XSlcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbVNvdXJjZSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgIHZhciBvQ29sb3IgPSBuZXcgQ29sb3IoKTtcbiAgICBvQ29sb3Iuc2V0U291cmNlKHNvdXJjZSk7XG4gICAgcmV0dXJuIG9Db2xvcjtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIGZ1bmN0aW9uIGdldENvbG9yU3RvcChlbCkge1xuICAgIHZhciBzdHlsZSA9IGVsLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSxcbiAgICAgICAgb2Zmc2V0ID0gZWwuZ2V0QXR0cmlidXRlKCdvZmZzZXQnKSB8fCAwLFxuICAgICAgICBjb2xvciwgY29sb3JBbHBoYSwgb3BhY2l0eTtcblxuICAgIC8vIGNvbnZlcnQgcGVyY2VudHMgdG8gYWJzb2x1dGUgdmFsdWVzXG4gICAgb2Zmc2V0ID0gcGFyc2VGbG9hdChvZmZzZXQpIC8gKC8lJC8udGVzdChvZmZzZXQpID8gMTAwIDogMSk7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IDwgMCA/IDAgOiBvZmZzZXQgPiAxID8gMSA6IG9mZnNldDtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIHZhciBrZXlWYWx1ZVBhaXJzID0gc3R5bGUuc3BsaXQoL1xccyo7XFxzKi8pO1xuXG4gICAgICBpZiAoa2V5VmFsdWVQYWlyc1trZXlWYWx1ZVBhaXJzLmxlbmd0aCAtIDFdID09PSAnJykge1xuICAgICAgICBrZXlWYWx1ZVBhaXJzLnBvcCgpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0ga2V5VmFsdWVQYWlycy5sZW5ndGg7IGktLTsgKSB7XG5cbiAgICAgICAgdmFyIHNwbGl0ID0ga2V5VmFsdWVQYWlyc1tpXS5zcGxpdCgvXFxzKjpcXHMqLyksXG4gICAgICAgICAgICBrZXkgPSBzcGxpdFswXS50cmltKCksXG4gICAgICAgICAgICB2YWx1ZSA9IHNwbGl0WzFdLnRyaW0oKTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnc3RvcC1jb2xvcicpIHtcbiAgICAgICAgICBjb2xvciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3N0b3Atb3BhY2l0eScpIHtcbiAgICAgICAgICBvcGFjaXR5ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICBjb2xvciA9IGVsLmdldEF0dHJpYnV0ZSgnc3RvcC1jb2xvcicpIHx8ICdyZ2IoMCwwLDApJztcbiAgICB9XG4gICAgaWYgKCFvcGFjaXR5KSB7XG4gICAgICBvcGFjaXR5ID0gZWwuZ2V0QXR0cmlidXRlKCdzdG9wLW9wYWNpdHknKTtcbiAgICB9XG5cbiAgICBjb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IoY29sb3IpO1xuICAgIGNvbG9yQWxwaGEgPSBjb2xvci5nZXRBbHBoYSgpO1xuICAgIG9wYWNpdHkgPSBpc05hTihwYXJzZUZsb2F0KG9wYWNpdHkpKSA/IDEgOiBwYXJzZUZsb2F0KG9wYWNpdHkpO1xuICAgIG9wYWNpdHkgKj0gY29sb3JBbHBoYTtcblxuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgIGNvbG9yOiBjb2xvci50b1JnYigpLFxuICAgICAgb3BhY2l0eTogb3BhY2l0eVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMaW5lYXJDb29yZHMoZWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IGVsLmdldEF0dHJpYnV0ZSgneDEnKSB8fCAwLFxuICAgICAgeTE6IGVsLmdldEF0dHJpYnV0ZSgneTEnKSB8fCAwLFxuICAgICAgeDI6IGVsLmdldEF0dHJpYnV0ZSgneDInKSB8fCAnMTAwJScsXG4gICAgICB5MjogZWwuZ2V0QXR0cmlidXRlKCd5MicpIHx8IDBcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UmFkaWFsQ29vcmRzKGVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiBlbC5nZXRBdHRyaWJ1dGUoJ2Z4JykgfHwgZWwuZ2V0QXR0cmlidXRlKCdjeCcpIHx8ICc1MCUnLFxuICAgICAgeTE6IGVsLmdldEF0dHJpYnV0ZSgnZnknKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ2N5JykgfHwgJzUwJScsXG4gICAgICByMTogMCxcbiAgICAgIHgyOiBlbC5nZXRBdHRyaWJ1dGUoJ2N4JykgfHwgJzUwJScsXG4gICAgICB5MjogZWwuZ2V0QXR0cmlidXRlKCdjeScpIHx8ICc1MCUnLFxuICAgICAgcjI6IGVsLmdldEF0dHJpYnV0ZSgncicpIHx8ICc1MCUnXG4gICAgfTtcbiAgfVxuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBHcmFkaWVudCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkdyYWRpZW50XG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0yI2dyYWRpZW50c31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkdyYWRpZW50I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuR3JhZGllbnQgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcygvKiogQGxlbmRzIGZhYnJpYy5HcmFkaWVudC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogSG9yaXpvbnRhbCBvZmZzZXQgZm9yIGFsaWduaW5nIGdyYWRpZW50cyBjb21pbmcgZnJvbSBTVkcgd2hlbiBvdXRzaWRlIHBhdGhncm91cHNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgb2Zmc2V0WDogMCxcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2FsIG9mZnNldCBmb3IgYWxpZ25pbmcgZ3JhZGllbnRzIGNvbWluZyBmcm9tIFNWRyB3aGVuIG91dHNpZGUgcGF0aGdyb3Vwc1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBvZmZzZXRZOiAwLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0IHdpdGggdHlwZSwgY29vcmRzLCBncmFkaWVudFVuaXRzIGFuZCBjb2xvclN0b3BzXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyYWRpZW50fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHZhciBjb29yZHMgPSB7IH07XG5cbiAgICAgIHRoaXMuaWQgPSBmYWJyaWMuT2JqZWN0Ll9fdWlkKys7XG4gICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGUgfHwgJ2xpbmVhcic7XG5cbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDE6IG9wdGlvbnMuY29vcmRzLngxIHx8IDAsXG4gICAgICAgIHkxOiBvcHRpb25zLmNvb3Jkcy55MSB8fCAwLFxuICAgICAgICB4Mjogb3B0aW9ucy5jb29yZHMueDIgfHwgMCxcbiAgICAgICAgeTI6IG9wdGlvbnMuY29vcmRzLnkyIHx8IDBcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdyYWRpYWwnKSB7XG4gICAgICAgIGNvb3Jkcy5yMSA9IG9wdGlvbnMuY29vcmRzLnIxIHx8IDA7XG4gICAgICAgIGNvb3Jkcy5yMiA9IG9wdGlvbnMuY29vcmRzLnIyIHx8IDA7XG4gICAgICB9XG4gICAgICB0aGlzLmNvb3JkcyA9IGNvb3JkcztcbiAgICAgIHRoaXMuY29sb3JTdG9wcyA9IG9wdGlvbnMuY29sb3JTdG9wcy5zbGljZSgpO1xuICAgICAgaWYgKG9wdGlvbnMuZ3JhZGllbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgdGhpcy5ncmFkaWVudFRyYW5zZm9ybSA9IG9wdGlvbnMuZ3JhZGllbnRUcmFuc2Zvcm07XG4gICAgICB9XG4gICAgICB0aGlzLm9mZnNldFggPSBvcHRpb25zLm9mZnNldFggfHwgdGhpcy5vZmZzZXRYO1xuICAgICAgdGhpcy5vZmZzZXRZID0gb3B0aW9ucy5vZmZzZXRZIHx8IHRoaXMub2Zmc2V0WTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbm90aGVyIGNvbG9yU3RvcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb2xvclN0b3AgT2JqZWN0IHdpdGggb2Zmc2V0IGFuZCBjb2xvclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5HcmFkaWVudH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGFkZENvbG9yU3RvcDogZnVuY3Rpb24oY29sb3JTdG9wKSB7XG4gICAgICBmb3IgKHZhciBwb3NpdGlvbiBpbiBjb2xvclN0b3ApIHtcbiAgICAgICAgdmFyIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcihjb2xvclN0b3BbcG9zaXRpb25dKTtcbiAgICAgICAgdGhpcy5jb2xvclN0b3BzLnB1c2goe1xuICAgICAgICAgIG9mZnNldDogcG9zaXRpb24sXG4gICAgICAgICAgY29sb3I6IGNvbG9yLnRvUmdiKCksXG4gICAgICAgICAgb3BhY2l0eTogY29sb3IuZ2V0QWxwaGEoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIGdyYWRpZW50XG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgY29vcmRzOiB0aGlzLmNvb3JkcyxcbiAgICAgICAgY29sb3JTdG9wczogdGhpcy5jb2xvclN0b3BzLFxuICAgICAgICBvZmZzZXRYOiB0aGlzLm9mZnNldFgsXG4gICAgICAgIG9mZnNldFk6IHRoaXMub2Zmc2V0WSxcbiAgICAgICAgZ3JhZGllbnRUcmFuc2Zvcm06IHRoaXMuZ3JhZGllbnRUcmFuc2Zvcm0gPyB0aGlzLmdyYWRpZW50VHJhbnNmb3JtLmNvbmNhdCgpIDogdGhpcy5ncmFkaWVudFRyYW5zZm9ybVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhbiBncmFkaWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhIGdyYWRpZW50IGZvclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGFuIGdyYWRpZW50IChsaW5lYXIvcmFkaWFsKVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBjb29yZHMgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUodGhpcy5jb29yZHMpLFxuICAgICAgICAgIG1hcmt1cCwgY29tbW9uQXR0cmlidXRlcztcblxuICAgICAgLy8gY29sb3JTdG9wcyBtdXN0IGJlIHNvcnRlZCBhc2NlbmRpbmdcbiAgICAgIHRoaXMuY29sb3JTdG9wcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEub2Zmc2V0IC0gYi5vZmZzZXQ7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCEob2JqZWN0Lmdyb3VwICYmIG9iamVjdC5ncm91cC50eXBlID09PSAncGF0aC1ncm91cCcpKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gY29vcmRzKSB7XG4gICAgICAgICAgaWYgKHByb3AgPT09ICd4MScgfHwgcHJvcCA9PT0gJ3gyJyB8fCBwcm9wID09PSAncjInKSB7XG4gICAgICAgICAgICBjb29yZHNbcHJvcF0gKz0gdGhpcy5vZmZzZXRYIC0gb2JqZWN0LndpZHRoIC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAocHJvcCA9PT0gJ3kxJyB8fCBwcm9wID09PSAneTInKSB7XG4gICAgICAgICAgICBjb29yZHNbcHJvcF0gKz0gdGhpcy5vZmZzZXRZIC0gb2JqZWN0LmhlaWdodCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbW1vbkF0dHJpYnV0ZXMgPSAnaWQ9XCJTVkdJRF8nICsgdGhpcy5pZCArXG4gICAgICAgICAgICAgICAgICAgICAnXCIgZ3JhZGllbnRVbml0cz1cInVzZXJTcGFjZU9uVXNlXCInO1xuICAgICAgaWYgKHRoaXMuZ3JhZGllbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgY29tbW9uQXR0cmlidXRlcyArPSAnIGdyYWRpZW50VHJhbnNmb3JtPVwibWF0cml4KCcgKyB0aGlzLmdyYWRpZW50VHJhbnNmb3JtLmpvaW4oJyAnKSArICcpXCIgJztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgIG1hcmt1cCA9IFtcbiAgICAgICAgICAnPGxpbmVhckdyYWRpZW50ICcsXG4gICAgICAgICAgY29tbW9uQXR0cmlidXRlcyxcbiAgICAgICAgICAnIHgxPVwiJywgY29vcmRzLngxLFxuICAgICAgICAgICdcIiB5MT1cIicsIGNvb3Jkcy55MSxcbiAgICAgICAgICAnXCIgeDI9XCInLCBjb29yZHMueDIsXG4gICAgICAgICAgJ1wiIHkyPVwiJywgY29vcmRzLnkyLFxuICAgICAgICAgICdcIj5cXG4nXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdyYWRpYWwnKSB7XG4gICAgICAgIG1hcmt1cCA9IFtcbiAgICAgICAgICAnPHJhZGlhbEdyYWRpZW50ICcsXG4gICAgICAgICAgY29tbW9uQXR0cmlidXRlcyxcbiAgICAgICAgICAnIGN4PVwiJywgY29vcmRzLngyLFxuICAgICAgICAgICdcIiBjeT1cIicsIGNvb3Jkcy55MixcbiAgICAgICAgICAnXCIgcj1cIicsIGNvb3Jkcy5yMixcbiAgICAgICAgICAnXCIgZng9XCInLCBjb29yZHMueDEsXG4gICAgICAgICAgJ1wiIGZ5PVwiJywgY29vcmRzLnkxLFxuICAgICAgICAgICdcIj5cXG4nXG4gICAgICAgIF07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb2xvclN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAgICc8c3RvcCAnLFxuICAgICAgICAgICAgJ29mZnNldD1cIicsICh0aGlzLmNvbG9yU3RvcHNbaV0ub2Zmc2V0ICogMTAwKSArICclJyxcbiAgICAgICAgICAgICdcIiBzdHlsZT1cInN0b3AtY29sb3I6JywgdGhpcy5jb2xvclN0b3BzW2ldLmNvbG9yLFxuICAgICAgICAgICAgKHRoaXMuY29sb3JTdG9wc1tpXS5vcGFjaXR5ICE9PSBudWxsID8gJztzdG9wLW9wYWNpdHk6ICcgKyB0aGlzLmNvbG9yU3RvcHNbaV0ub3BhY2l0eSA6ICc7JyksXG4gICAgICAgICAgJ1wiLz5cXG4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIG1hcmt1cC5wdXNoKCh0aGlzLnR5cGUgPT09ICdsaW5lYXInID8gJzwvbGluZWFyR3JhZGllbnQ+XFxuJyA6ICc8L3JhZGlhbEdyYWRpZW50PlxcbicpKTtcblxuICAgICAgcmV0dXJuIG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBDYW52YXNHcmFkaWVudFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7Q2FudmFzR3JhZGllbnR9XG4gICAgICovXG4gICAgdG9MaXZlOiBmdW5jdGlvbihjdHgsIG9iamVjdCkge1xuICAgICAgdmFyIGdyYWRpZW50LCBwcm9wLCBjb29yZHMgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUodGhpcy5jb29yZHMpO1xuXG4gICAgICBpZiAoIXRoaXMudHlwZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmplY3QuZ3JvdXAgJiYgb2JqZWN0Lmdyb3VwLnR5cGUgPT09ICdwYXRoLWdyb3VwJykge1xuICAgICAgICBmb3IgKHByb3AgaW4gY29vcmRzKSB7XG4gICAgICAgICAgaWYgKHByb3AgPT09ICd4MScgfHwgcHJvcCA9PT0gJ3gyJykge1xuICAgICAgICAgICAgY29vcmRzW3Byb3BdICs9IC10aGlzLm9mZnNldFggKyBvYmplY3Qud2lkdGggLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChwcm9wID09PSAneTEnIHx8IHByb3AgPT09ICd5MicpIHtcbiAgICAgICAgICAgIGNvb3Jkc1twcm9wXSArPSAtdGhpcy5vZmZzZXRZICsgb2JqZWN0LmhlaWdodCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgIGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KFxuICAgICAgICAgIGNvb3Jkcy54MSwgY29vcmRzLnkxLCBjb29yZHMueDIsIGNvb3Jkcy55Mik7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdyYWRpYWwnKSB7XG4gICAgICAgIGdyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KFxuICAgICAgICAgIGNvb3Jkcy54MSwgY29vcmRzLnkxLCBjb29yZHMucjEsIGNvb3Jkcy54MiwgY29vcmRzLnkyLCBjb29yZHMucjIpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb2xvclN0b3BzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjb2xvciA9IHRoaXMuY29sb3JTdG9wc1tpXS5jb2xvcixcbiAgICAgICAgICAgIG9wYWNpdHkgPSB0aGlzLmNvbG9yU3RvcHNbaV0ub3BhY2l0eSxcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuY29sb3JTdG9wc1tpXS5vZmZzZXQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcGFjaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcihjb2xvcikuc2V0QWxwaGEob3BhY2l0eSkudG9SZ2JhKCk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKHBhcnNlRmxvYXQob2Zmc2V0KSwgY29sb3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ3JhZGllbnQ7XG4gICAgfVxuICB9KTtcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5HcmFkaWVudCwge1xuXG4gICAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5HcmFkaWVudH0gaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkdyYWRpZW50XG4gICAgICogQHBhcmFtIHtTVkdHcmFkaWVudEVsZW1lbnR9IGVsIFNWRyBncmFkaWVudCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5HcmFkaWVudH0gR3JhZGllbnQgaW5zdGFuY2VcbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wc2VydmVycy5odG1sI0xpbmVhckdyYWRpZW50RWxlbWVudFxuICAgICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BzZXJ2ZXJzLmh0bWwjUmFkaWFsR3JhZGllbnRFbGVtZW50XG4gICAgICovXG4gICAgZnJvbUVsZW1lbnQ6IGZ1bmN0aW9uKGVsLCBpbnN0YW5jZSkge1xuXG4gICAgICAvKipcbiAgICAgICAqICBAZXhhbXBsZTpcbiAgICAgICAqXG4gICAgICAgKiAgPGxpbmVhckdyYWRpZW50IGlkPVwibGluZWFyR3JhZDFcIj5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjAlXCIgc3RvcC1jb2xvcj1cIndoaXRlXCIvPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMTAwJVwiIHN0b3AtY29sb3I9XCJibGFja1wiLz5cbiAgICAgICAqICA8L2xpbmVhckdyYWRpZW50PlxuICAgICAgICpcbiAgICAgICAqICBPUlxuICAgICAgICpcbiAgICAgICAqICA8bGluZWFyR3JhZGllbnQgaWQ9XCJsaW5lYXJHcmFkMlwiPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMFwiIHN0eWxlPVwic3RvcC1jb2xvcjpyZ2IoMjU1LDI1NSwyNTUpXCIvPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMVwiIHN0eWxlPVwic3RvcC1jb2xvcjpyZ2IoMCwwLDApXCIvPlxuICAgICAgICogIDwvbGluZWFyR3JhZGllbnQ+XG4gICAgICAgKlxuICAgICAgICogIE9SXG4gICAgICAgKlxuICAgICAgICogIDxyYWRpYWxHcmFkaWVudCBpZD1cInJhZGlhbEdyYWQxXCI+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIwJVwiIHN0b3AtY29sb3I9XCJ3aGl0ZVwiIHN0b3Atb3BhY2l0eT1cIjFcIiAvPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiNTAlXCIgc3RvcC1jb2xvcj1cImJsYWNrXCIgc3RvcC1vcGFjaXR5PVwiMC41XCIgLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjEwMCVcIiBzdG9wLWNvbG9yPVwid2hpdGVcIiBzdG9wLW9wYWNpdHk9XCIxXCIgLz5cbiAgICAgICAqICA8L3JhZGlhbEdyYWRpZW50PlxuICAgICAgICpcbiAgICAgICAqICBPUlxuICAgICAgICpcbiAgICAgICAqICA8cmFkaWFsR3JhZGllbnQgaWQ9XCJyYWRpYWxHcmFkMlwiPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMFwiIHN0b3AtY29sb3I9XCJyZ2IoMjU1LDI1NSwyNTUpXCIgLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjAuNVwiIHN0b3AtY29sb3I9XCJyZ2IoMCwwLDApXCIgLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjFcIiBzdG9wLWNvbG9yPVwicmdiKDI1NSwyNTUsMjU1KVwiIC8+XG4gICAgICAgKiAgPC9yYWRpYWxHcmFkaWVudD5cbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgICAgdmFyIGNvbG9yU3RvcEVscyA9IGVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzdG9wJyksXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBncmFkaWVudFVuaXRzID0gZWwuZ2V0QXR0cmlidXRlKCdncmFkaWVudFVuaXRzJykgfHwgJ29iamVjdEJvdW5kaW5nQm94JyxcbiAgICAgICAgICBncmFkaWVudFRyYW5zZm9ybSA9IGVsLmdldEF0dHJpYnV0ZSgnZ3JhZGllbnRUcmFuc2Zvcm0nKSxcbiAgICAgICAgICBjb2xvclN0b3BzID0gW10sXG4gICAgICAgICAgY29vcmRzLCBlbGxpcHNlTWF0cml4O1xuXG4gICAgICBpZiAoZWwubm9kZU5hbWUgPT09ICdsaW5lYXJHcmFkaWVudCcgfHwgZWwubm9kZU5hbWUgPT09ICdMSU5FQVJHUkFESUVOVCcpIHtcbiAgICAgICAgdHlwZSA9ICdsaW5lYXInO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHR5cGUgPSAncmFkaWFsJztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgIGNvb3JkcyA9IGdldExpbmVhckNvb3JkcyhlbCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlID09PSAncmFkaWFsJykge1xuICAgICAgICBjb29yZHMgPSBnZXRSYWRpYWxDb29yZHMoZWwpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gY29sb3JTdG9wRWxzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgY29sb3JTdG9wcy5wdXNoKGdldENvbG9yU3RvcChjb2xvclN0b3BFbHNbaV0pKTtcbiAgICAgIH1cblxuICAgICAgZWxsaXBzZU1hdHJpeCA9IF9jb252ZXJ0UGVyY2VudFVuaXRzVG9WYWx1ZXMoaW5zdGFuY2UsIGNvb3JkcywgZ3JhZGllbnRVbml0cyk7XG5cbiAgICAgIHZhciBncmFkaWVudCA9IG5ldyBmYWJyaWMuR3JhZGllbnQoe1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBjb29yZHM6IGNvb3JkcyxcbiAgICAgICAgY29sb3JTdG9wczogY29sb3JTdG9wcyxcbiAgICAgICAgb2Zmc2V0WDogLWluc3RhbmNlLmxlZnQsXG4gICAgICAgIG9mZnNldFk6IC1pbnN0YW5jZS50b3BcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZ3JhZGllbnRUcmFuc2Zvcm0gfHwgZWxsaXBzZU1hdHJpeCAhPT0gJycpIHtcbiAgICAgICAgZ3JhZGllbnQuZ3JhZGllbnRUcmFuc2Zvcm0gPSBmYWJyaWMucGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUoKGdyYWRpZW50VHJhbnNmb3JtIHx8ICcnKSArIGVsbGlwc2VNYXRyaXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyYWRpZW50O1xuICAgIH0sXG4gICAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5HcmFkaWVudH0gaW5zdGFuY2UgZnJvbSBpdHMgb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuR3JhZGllbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGZvck9iamVjdDogZnVuY3Rpb24ob2JqLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIF9jb252ZXJ0UGVyY2VudFVuaXRzVG9WYWx1ZXMob2JqLCBvcHRpb25zLmNvb3JkcywgJ3VzZXJTcGFjZU9uVXNlJyk7XG4gICAgICByZXR1cm4gbmV3IGZhYnJpYy5HcmFkaWVudChvcHRpb25zKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2NvbnZlcnRQZXJjZW50VW5pdHNUb1ZhbHVlcyhvYmplY3QsIG9wdGlvbnMsIGdyYWRpZW50VW5pdHMpIHtcbiAgICB2YXIgcHJvcFZhbHVlLCBhZGRGYWN0b3IgPSAwLCBtdWx0RmFjdG9yID0gMSwgZWxsaXBzZU1hdHJpeCA9ICcnO1xuICAgIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnNbcHJvcF0gPT09ICdJbmZpbml0eScpIHtcbiAgICAgICAgb3B0aW9uc1twcm9wXSA9IDE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcHRpb25zW3Byb3BdID09PSAnLUluZmluaXR5Jykge1xuICAgICAgICBvcHRpb25zW3Byb3BdID0gMDtcbiAgICAgIH1cbiAgICAgIHByb3BWYWx1ZSA9IHBhcnNlRmxvYXQob3B0aW9uc1twcm9wXSwgMTApO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zW3Byb3BdID09PSAnc3RyaW5nJyAmJiAvXlxcZCslJC8udGVzdChvcHRpb25zW3Byb3BdKSkge1xuICAgICAgICBtdWx0RmFjdG9yID0gMC4wMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtdWx0RmFjdG9yID0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wID09PSAneDEnIHx8IHByb3AgPT09ICd4MicgfHwgcHJvcCA9PT0gJ3IyJykge1xuICAgICAgICBtdWx0RmFjdG9yICo9IGdyYWRpZW50VW5pdHMgPT09ICdvYmplY3RCb3VuZGluZ0JveCcgPyBvYmplY3Qud2lkdGggOiAxO1xuICAgICAgICBhZGRGYWN0b3IgPSBncmFkaWVudFVuaXRzID09PSAnb2JqZWN0Qm91bmRpbmdCb3gnID8gb2JqZWN0LmxlZnQgfHwgMCA6IDA7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChwcm9wID09PSAneTEnIHx8IHByb3AgPT09ICd5MicpIHtcbiAgICAgICAgbXVsdEZhY3RvciAqPSBncmFkaWVudFVuaXRzID09PSAnb2JqZWN0Qm91bmRpbmdCb3gnID8gb2JqZWN0LmhlaWdodCA6IDE7XG4gICAgICAgIGFkZEZhY3RvciA9IGdyYWRpZW50VW5pdHMgPT09ICdvYmplY3RCb3VuZGluZ0JveCcgPyBvYmplY3QudG9wIHx8IDAgOiAwO1xuICAgICAgfVxuICAgICAgb3B0aW9uc1twcm9wXSA9IHByb3BWYWx1ZSAqIG11bHRGYWN0b3IgKyBhZGRGYWN0b3I7XG4gICAgfVxuICAgIGlmIChvYmplY3QudHlwZSA9PT0gJ2VsbGlwc2UnICYmXG4gICAgICAgIG9wdGlvbnMucjIgIT09IG51bGwgJiZcbiAgICAgICAgZ3JhZGllbnRVbml0cyA9PT0gJ29iamVjdEJvdW5kaW5nQm94JyAmJlxuICAgICAgICBvYmplY3QucnggIT09IG9iamVjdC5yeSkge1xuXG4gICAgICB2YXIgc2NhbGVGYWN0b3IgPSBvYmplY3QucnkgLyBvYmplY3Qucng7XG4gICAgICBlbGxpcHNlTWF0cml4ID0gJyBzY2FsZSgxLCAnICsgc2NhbGVGYWN0b3IgKyAnKSc7XG4gICAgICBpZiAob3B0aW9ucy55MSkge1xuICAgICAgICBvcHRpb25zLnkxIC89IHNjYWxlRmFjdG9yO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMueTIpIHtcbiAgICAgICAgb3B0aW9ucy55MiAvPSBzY2FsZUZhY3RvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsbGlwc2VNYXRyaXg7XG4gIH1cbn0pKCk7XG5cblxuLyoqXG4gKiBQYXR0ZXJuIGNsYXNzXG4gKiBAY2xhc3MgZmFicmljLlBhdHRlcm5cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vcGF0dGVybnN8UGF0dGVybiBkZW1vfVxuICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9keW5hbWljLXBhdHRlcm5zfER5bmFtaWNQYXR0ZXJuIGRlbW99XG4gKiBAc2VlIHtAbGluayBmYWJyaWMuUGF0dGVybiNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICovXG5mYWJyaWMuUGF0dGVybiA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKC8qKiBAbGVuZHMgZmFicmljLlBhdHRlcm4ucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogUmVwZWF0IHByb3BlcnR5IG9mIGEgcGF0dGVybiAob25lIG9mIHJlcGVhdCwgcmVwZWF0LXgsIHJlcGVhdC15IG9yIG5vLXJlcGVhdClcbiAgICogQHR5cGUgU3RyaW5nXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICByZXBlYXQ6ICdyZXBlYXQnLFxuXG4gIC8qKlxuICAgKiBQYXR0ZXJuIGhvcml6b250YWwgb2Zmc2V0IGZyb20gb2JqZWN0J3MgbGVmdC90b3AgY29ybmVyXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgb2Zmc2V0WDogMCxcblxuICAvKipcbiAgICogUGF0dGVybiB2ZXJ0aWNhbCBvZmZzZXQgZnJvbSBvYmplY3QncyBsZWZ0L3RvcCBjb3JuZXJcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBvZmZzZXRZOiAwLFxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5QYXR0ZXJufSB0aGlzQXJnXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICB0aGlzLmlkID0gZmFicmljLk9iamVjdC5fX3VpZCsrO1xuXG4gICAgaWYgKG9wdGlvbnMuc291cmNlKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMuc291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBmdW5jdGlvbiBzdHJpbmdcbiAgICAgICAgaWYgKHR5cGVvZiBmYWJyaWMudXRpbC5nZXRGdW5jdGlvbkJvZHkob3B0aW9ucy5zb3VyY2UpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRoaXMuc291cmNlID0gbmV3IEZ1bmN0aW9uKGZhYnJpYy51dGlsLmdldEZ1bmN0aW9uQm9keShvcHRpb25zLnNvdXJjZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGltZyBzcmMgc3RyaW5nXG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLnNvdXJjZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUltYWdlKCk7XG4gICAgICAgICAgZmFicmljLnV0aWwubG9hZEltYWdlKG9wdGlvbnMuc291cmNlLCBmdW5jdGlvbihpbWcpIHtcbiAgICAgICAgICAgIF90aGlzLnNvdXJjZSA9IGltZztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGltZyBlbGVtZW50XG4gICAgICAgIHRoaXMuc291cmNlID0gb3B0aW9ucy5zb3VyY2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJlcGVhdCkge1xuICAgICAgdGhpcy5yZXBlYXQgPSBvcHRpb25zLnJlcGVhdDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMub2Zmc2V0WCkge1xuICAgICAgdGhpcy5vZmZzZXRYID0gb3B0aW9ucy5vZmZzZXRYO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5vZmZzZXRZKSB7XG4gICAgICB0aGlzLm9mZnNldFkgPSBvcHRpb25zLm9mZnNldFk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIHBhdHRlcm5cbiAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYSBwYXR0ZXJuIGluc3RhbmNlXG4gICAqL1xuICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgc291cmNlO1xuXG4gICAgLy8gY2FsbGJhY2tcbiAgICBpZiAodHlwZW9mIHRoaXMuc291cmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzb3VyY2UgPSBTdHJpbmcodGhpcy5zb3VyY2UpO1xuICAgIH1cbiAgICAvLyA8aW1nPiBlbGVtZW50XG4gICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuc291cmNlLnNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNvdXJjZSA9IHRoaXMuc291cmNlLnNyYztcbiAgICB9XG4gICAgLy8gPGNhbnZhcz4gZWxlbWVudFxuICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZSA9PT0gJ29iamVjdCcgJiYgdGhpcy5zb3VyY2UudG9EYXRhVVJMKSB7XG4gICAgICBzb3VyY2UgPSB0aGlzLnNvdXJjZS50b0RhdGFVUkwoKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICByZXBlYXQ6IHRoaXMucmVwZWF0LFxuICAgICAgb2Zmc2V0WDogdGhpcy5vZmZzZXRYLFxuICAgICAgb2Zmc2V0WTogdGhpcy5vZmZzZXRZXG4gICAgfTtcbiAgfSxcblxuICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogUmV0dXJucyBTVkcgcmVwcmVzZW50YXRpb24gb2YgYSBwYXR0ZXJuXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0XG4gICAqIEByZXR1cm4ge1N0cmluZ30gU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGEgcGF0dGVyblxuICAgKi9cbiAgdG9TVkc6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBwYXR0ZXJuU291cmNlID0gdHlwZW9mIHRoaXMuc291cmNlID09PSAnZnVuY3Rpb24nID8gdGhpcy5zb3VyY2UoKSA6IHRoaXMuc291cmNlLFxuICAgICAgICBwYXR0ZXJuV2lkdGggPSBwYXR0ZXJuU291cmNlLndpZHRoIC8gb2JqZWN0LmdldFdpZHRoKCksXG4gICAgICAgIHBhdHRlcm5IZWlnaHQgPSBwYXR0ZXJuU291cmNlLmhlaWdodCAvIG9iamVjdC5nZXRIZWlnaHQoKSxcbiAgICAgICAgcGF0dGVybk9mZnNldFggPSB0aGlzLm9mZnNldFggLyBvYmplY3QuZ2V0V2lkdGgoKSxcbiAgICAgICAgcGF0dGVybk9mZnNldFkgPSB0aGlzLm9mZnNldFkgLyBvYmplY3QuZ2V0SGVpZ2h0KCksXG4gICAgICAgIHBhdHRlcm5JbWdTcmMgPSAnJztcbiAgICBpZiAodGhpcy5yZXBlYXQgPT09ICdyZXBlYXQteCcgfHwgdGhpcy5yZXBlYXQgPT09ICduby1yZXBlYXQnKSB7XG4gICAgICBwYXR0ZXJuSGVpZ2h0ID0gMTtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVwZWF0ID09PSAncmVwZWF0LXknIHx8IHRoaXMucmVwZWF0ID09PSAnbm8tcmVwZWF0Jykge1xuICAgICAgcGF0dGVybldpZHRoID0gMTtcbiAgICB9XG4gICAgaWYgKHBhdHRlcm5Tb3VyY2Uuc3JjKSB7XG4gICAgICBwYXR0ZXJuSW1nU3JjID0gcGF0dGVyblNvdXJjZS5zcmM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhdHRlcm5Tb3VyY2UudG9EYXRhVVJMKSB7XG4gICAgICBwYXR0ZXJuSW1nU3JjID0gcGF0dGVyblNvdXJjZS50b0RhdGFVUkwoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJzxwYXR0ZXJuIGlkPVwiU1ZHSURfJyArIHRoaXMuaWQgK1xuICAgICAgICAgICAgICAgICAgJ1wiIHg9XCInICsgcGF0dGVybk9mZnNldFggK1xuICAgICAgICAgICAgICAgICAgJ1wiIHk9XCInICsgcGF0dGVybk9mZnNldFkgK1xuICAgICAgICAgICAgICAgICAgJ1wiIHdpZHRoPVwiJyArIHBhdHRlcm5XaWR0aCArXG4gICAgICAgICAgICAgICAgICAnXCIgaGVpZ2h0PVwiJyArIHBhdHRlcm5IZWlnaHQgKyAnXCI+XFxuJyArXG4gICAgICAgICAgICAgJzxpbWFnZSB4PVwiMFwiIHk9XCIwXCInICtcbiAgICAgICAgICAgICAgICAgICAgJyB3aWR0aD1cIicgKyBwYXR0ZXJuU291cmNlLndpZHRoICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiIGhlaWdodD1cIicgKyBwYXR0ZXJuU291cmNlLmhlaWdodCArXG4gICAgICAgICAgICAgICAgICAgICdcIiB4bGluazpocmVmPVwiJyArIHBhdHRlcm5JbWdTcmMgK1xuICAgICAgICAgICAgICdcIj48L2ltYWdlPlxcbicgK1xuICAgICAgICAgICAnPC9wYXR0ZXJuPlxcbic7XG4gIH0sXG4gIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIENhbnZhc1BhdHRlcm5cbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIGNyZWF0ZSBwYXR0ZXJuXG4gICAqIEByZXR1cm4ge0NhbnZhc1BhdHRlcm59XG4gICAqL1xuICB0b0xpdmU6IGZ1bmN0aW9uKGN0eCkge1xuICAgIHZhciBzb3VyY2UgPSB0eXBlb2YgdGhpcy5zb3VyY2UgPT09ICdmdW5jdGlvbidcbiAgICAgID8gdGhpcy5zb3VyY2UoKVxuICAgICAgOiB0aGlzLnNvdXJjZTtcblxuICAgIC8vIGlmIHRoZSBpbWFnZSBmYWlsZWQgdG8gbG9hZCwgcmV0dXJuLCBhbmQgYWxsb3cgcmVzdCB0byBjb250aW51ZSBsb2FkaW5nXG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyBpZiBhbiBpbWFnZVxuICAgIGlmICh0eXBlb2Ygc291cmNlLnNyYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmICghc291cmNlLmNvbXBsZXRlKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIGlmIChzb3VyY2UubmF0dXJhbFdpZHRoID09PSAwIHx8IHNvdXJjZS5uYXR1cmFsSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN0eC5jcmVhdGVQYXR0ZXJuKHNvdXJjZSwgdGhpcy5yZXBlYXQpO1xuICB9XG59KTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkO1xuXG4gIGlmIChmYWJyaWMuU2hhZG93KSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5TaGFkb3cgaXMgYWxyZWFkeSBkZWZpbmVkLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaGFkb3cgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5TaGFkb3dcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9zaGFkb3dzfFNoYWRvdyBkZW1vfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuU2hhZG93I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuU2hhZG93ID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoLyoqIEBsZW5kcyBmYWJyaWMuU2hhZG93LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBTaGFkb3cgY29sb3JcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNvbG9yOiAncmdiKDAsMCwwKScsXG5cbiAgICAvKipcbiAgICAgKiBTaGFkb3cgYmx1clxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIGJsdXI6IDAsXG5cbiAgICAvKipcbiAgICAgKiBTaGFkb3cgaG9yaXpvbnRhbCBvZmZzZXRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG9mZnNldFg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBTaGFkb3cgdmVydGljYWwgb2Zmc2V0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvZmZzZXRZOiAwLFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgc2hhZG93IHNob3VsZCBhZmZlY3Qgc3Ryb2tlIG9wZXJhdGlvbnNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBhZmZlY3RTdHJva2U6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdG9PYmplY3Qgc2hvdWxkIGluY2x1ZGUgZGVmYXVsdCB2YWx1ZXNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbmNsdWRlRGVmYXVsdFZhbHVlczogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3Qgd2l0aCBhbnkgb2YgY29sb3IsIGJsdXIsIG9mZnNldFgsIG9mZnNldFggcHJvcGVydGllcyBvciBzdHJpbmcgKGUuZy4gXCJyZ2JhKDAsMCwwLDAuMikgMnB4IDJweCAxMHB4LCBcIjJweCAycHggMTBweCByZ2JhKDAsMCwwLDAuMilcIilcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuU2hhZG93fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLl9wYXJzZVNoYWRvdyhvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXNbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlkID0gZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaGFkb3cgU2hhZG93IHZhbHVlIHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBTaGFkb3cgb2JqZWN0IHdpdGggY29sb3IsIG9mZnNldFgsIG9mZnNldFkgYW5kIGJsdXJcbiAgICAgKi9cbiAgICBfcGFyc2VTaGFkb3c6IGZ1bmN0aW9uKHNoYWRvdykge1xuICAgICAgdmFyIHNoYWRvd1N0ciA9IHNoYWRvdy50cmltKCksXG4gICAgICAgICAgb2Zmc2V0c0FuZEJsdXIgPSBmYWJyaWMuU2hhZG93LnJlT2Zmc2V0c0FuZEJsdXIuZXhlYyhzaGFkb3dTdHIpIHx8IFtdLFxuICAgICAgICAgIGNvbG9yID0gc2hhZG93U3RyLnJlcGxhY2UoZmFicmljLlNoYWRvdy5yZU9mZnNldHNBbmRCbHVyLCAnJykgfHwgJ3JnYigwLDAsMCknO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2xvcjogY29sb3IudHJpbSgpLFxuICAgICAgICBvZmZzZXRYOiBwYXJzZUludChvZmZzZXRzQW5kQmx1clsxXSwgMTApIHx8IDAsXG4gICAgICAgIG9mZnNldFk6IHBhcnNlSW50KG9mZnNldHNBbmRCbHVyWzJdLCAxMCkgfHwgMCxcbiAgICAgICAgYmx1cjogcGFyc2VJbnQob2Zmc2V0c0FuZEJsdXJbM10sIDEwKSB8fCAwXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MtdGV4dC1kZWNvci0zLyN0ZXh0LXNoYWRvd1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyBDU1MzIHRleHQtc2hhZG93IGRlY2xhcmF0aW9uXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLm9mZnNldFgsIHRoaXMub2Zmc2V0WSwgdGhpcy5ibHVyLCB0aGlzLmNvbG9yXS5qb2luKCdweCAnKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhIHNoYWRvd1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTVkcgcmVwcmVzZW50YXRpb24gb2YgYSBzaGFkb3dcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgZkJveFggPSA0MCwgZkJveFkgPSA0MCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUyxcbiAgICAgICAgICBvZmZzZXQgPSBmYWJyaWMudXRpbC5yb3RhdGVWZWN0b3IoXG4gICAgICAgICAgICB7IHg6IHRoaXMub2Zmc2V0WCwgeTogdGhpcy5vZmZzZXRZIH0sXG4gICAgICAgICAgICBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKC1vYmplY3QuYW5nbGUpKSxcbiAgICAgICAgICBCTFVSX0JPWCA9IDIwO1xuXG4gICAgICBpZiAob2JqZWN0LndpZHRoICYmIG9iamVjdC5oZWlnaHQpIHtcbiAgICAgICAgLy9odHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvZmlsdGVycy5odG1sI0ZpbHRlckVmZmVjdHNSZWdpb25cbiAgICAgICAgLy8gd2UgYWRkIHNvbWUgZXh0cmEgc3BhY2UgdG8gZmlsdGVyIGJveCB0byBjb250YWluIHRoZSBibHVyICggMjAgKVxuICAgICAgICBmQm94WCA9IHRvRml4ZWQoKE1hdGguYWJzKG9mZnNldC54KSArIHRoaXMuYmx1cikgLyBvYmplY3Qud2lkdGgsIE5VTV9GUkFDVElPTl9ESUdJVFMpICogMTAwICsgQkxVUl9CT1g7XG4gICAgICAgIGZCb3hZID0gdG9GaXhlZCgoTWF0aC5hYnMob2Zmc2V0LnkpICsgdGhpcy5ibHVyKSAvIG9iamVjdC5oZWlnaHQsIE5VTV9GUkFDVElPTl9ESUdJVFMpICogMTAwICsgQkxVUl9CT1g7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmZsaXBYKSB7XG4gICAgICAgIG9mZnNldC54ICo9IC0xO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5mbGlwWSkge1xuICAgICAgICBvZmZzZXQueSAqPSAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXG4gICAgICAgICc8ZmlsdGVyIGlkPVwiU1ZHSURfJyArIHRoaXMuaWQgKyAnXCIgeT1cIi0nICsgZkJveFkgKyAnJVwiIGhlaWdodD1cIicgKyAoMTAwICsgMiAqIGZCb3hZKSArICclXCIgJyArXG4gICAgICAgICAgJ3g9XCItJyArIGZCb3hYICsgJyVcIiB3aWR0aD1cIicgKyAoMTAwICsgMiAqIGZCb3hYKSArICclXCIgJyArICc+XFxuJyArXG4gICAgICAgICAgJ1xcdDxmZUdhdXNzaWFuQmx1ciBpbj1cIlNvdXJjZUFscGhhXCIgc3RkRGV2aWF0aW9uPVwiJyArXG4gICAgICAgICAgICB0b0ZpeGVkKHRoaXMuYmx1ciA/IHRoaXMuYmx1ciAvIDIgOiAwLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICdcIj48L2ZlR2F1c3NpYW5CbHVyPlxcbicgK1xuICAgICAgICAgICdcXHQ8ZmVPZmZzZXQgZHg9XCInICsgdG9GaXhlZChvZmZzZXQueCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgK1xuICAgICAgICAgICdcIiBkeT1cIicgKyB0b0ZpeGVkKG9mZnNldC55LCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICdcIiByZXN1bHQ9XCJvQmx1clwiID48L2ZlT2Zmc2V0PlxcbicgK1xuICAgICAgICAgICdcXHQ8ZmVGbG9vZCBmbG9vZC1jb2xvcj1cIicgKyB0aGlzLmNvbG9yICsgJ1wiLz5cXG4nICtcbiAgICAgICAgICAnXFx0PGZlQ29tcG9zaXRlIGluMj1cIm9CbHVyXCIgb3BlcmF0b3I9XCJpblwiIC8+XFxuJyArXG4gICAgICAgICAgJ1xcdDxmZU1lcmdlPlxcbicgK1xuICAgICAgICAgICAgJ1xcdFxcdDxmZU1lcmdlTm9kZT48L2ZlTWVyZ2VOb2RlPlxcbicgK1xuICAgICAgICAgICAgJ1xcdFxcdDxmZU1lcmdlTm9kZSBpbj1cIlNvdXJjZUdyYXBoaWNcIj48L2ZlTWVyZ2VOb2RlPlxcbicgK1xuICAgICAgICAgICdcXHQ8L2ZlTWVyZ2U+XFxuJyArXG4gICAgICAgICc8L2ZpbHRlcj5cXG4nKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYSBzaGFkb3dcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIHNoYWRvdyBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmluY2x1ZGVEZWZhdWx0VmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICAgICAgYmx1cjogdGhpcy5ibHVyLFxuICAgICAgICAgIG9mZnNldFg6IHRoaXMub2Zmc2V0WCxcbiAgICAgICAgICBvZmZzZXRZOiB0aGlzLm9mZnNldFksXG4gICAgICAgICAgYWZmZWN0U3Ryb2tlOiB0aGlzLmFmZmVjdFN0cm9rZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IHsgfSwgcHJvdG8gPSBmYWJyaWMuU2hhZG93LnByb3RvdHlwZTtcblxuICAgICAgWydjb2xvcicsICdibHVyJywgJ29mZnNldFgnLCAnb2Zmc2V0WScsICdhZmZlY3RTdHJva2UnXS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgaWYgKHRoaXNbcHJvcF0gIT09IHByb3RvW3Byb3BdKSB7XG4gICAgICAgICAgb2JqW3Byb3BdID0gdGhpc1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmVnZXggbWF0Y2hpbmcgc2hhZG93IG9mZnNldFgsIG9mZnNldFkgYW5kIGJsdXIgKGV4OiBcIjJweCAycHggMTBweCByZ2JhKDAsMCwwLDAuMilcIiwgXCJyZ2IoMCwyNTUsMCkgMnB4IDJweFwiKVxuICAgKiBAc3RhdGljXG4gICAqIEBmaWVsZFxuICAgKiBAbWVtYmVyT2YgZmFicmljLlNoYWRvd1xuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgZmFicmljLlNoYWRvdy5yZU9mZnNldHNBbmRCbHVyID0gLyg/Olxcc3xeKSgtP1xcZCsoPzpweCk/KD86XFxzP3wkKSk/KC0/XFxkKyg/OnB4KT8oPzpcXHM/fCQpKT8oXFxkKyg/OnB4KT8pPyg/Olxccz98JCkoPzokfFxccykvO1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uICgpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKGZhYnJpYy5TdGF0aWNDYW52YXMpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlN0YXRpY0NhbnZhcyBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gYWxpYXNlcyBmb3IgZmFzdGVyIHJlc29sdXRpb25cbiAgdmFyIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBnZXRFbGVtZW50T2Zmc2V0ID0gZmFicmljLnV0aWwuZ2V0RWxlbWVudE9mZnNldCxcbiAgICAgIHJlbW92ZUZyb21BcnJheSA9IGZhYnJpYy51dGlsLnJlbW92ZUZyb21BcnJheSxcbiAgICAgIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkLFxuXG4gICAgICBDQU5WQVNfSU5JVF9FUlJPUiA9IG5ldyBFcnJvcignQ291bGQgbm90IGluaXRpYWxpemUgYGNhbnZhc2AgZWxlbWVudCcpO1xuXG4gIC8qKlxuICAgKiBTdGF0aWMgY2FudmFzIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuU3RhdGljQ2FudmFzXG4gICAqIEBtaXhlcyBmYWJyaWMuQ29sbGVjdGlvblxuICAgKiBAbWl4ZXMgZmFicmljLk9ic2VydmFibGVcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9zdGF0aWNfY2FudmFzfFN0YXRpY0NhbnZhcyBkZW1vfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBmaXJlcyBiZWZvcmU6cmVuZGVyXG4gICAqIEBmaXJlcyBhZnRlcjpyZW5kZXJcbiAgICogQGZpcmVzIGNhbnZhczpjbGVhcmVkXG4gICAqIEBmaXJlcyBvYmplY3Q6YWRkZWRcbiAgICogQGZpcmVzIG9iamVjdDpyZW1vdmVkXG4gICAqL1xuICBmYWJyaWMuU3RhdGljQ2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoLyoqIEBsZW5kcyBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBTdHJpbmd9IGVsICZsdDtjYW52YXM+IGVsZW1lbnQgdG8gaW5pdGlhbGl6ZSBpbnN0YW5jZSBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHRoaXMuX2luaXRTdGF0aWMoZWwsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCYWNrZ3JvdW5kIGNvbG9yIG9mIGNhbnZhcyBpbnN0YW5jZS5cbiAgICAgKiBTaG91bGQgYmUgc2V0IHZpYSB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNzZXRCYWNrZ3JvdW5kQ29sb3J9LlxuICAgICAqIEB0eXBlIHsoU3RyaW5nfGZhYnJpYy5QYXR0ZXJuKX1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJhY2tncm91bmRDb2xvcjogJycsXG5cbiAgICAvKipcbiAgICAgKiBCYWNrZ3JvdW5kIGltYWdlIG9mIGNhbnZhcyBpbnN0YW5jZS5cbiAgICAgKiBTaG91bGQgYmUgc2V0IHZpYSB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNzZXRCYWNrZ3JvdW5kSW1hZ2V9LlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoZSBcImJhY2tncm91bmRJbWFnZU9wYWNpdHlcIlxuICAgICAqIGFuZCBcImJhY2tncm91bmRJbWFnZVN0cmV0Y2hcIiBwcm9wZXJ0aWVzIGFyZSBkZXByZWNhdGVkIHNpbmNlIDEuMy45LlxuICAgICAqIFVzZSB7QGxpbmsgZmFicmljLkltYWdlI29wYWNpdHl9LCB7QGxpbmsgZmFicmljLkltYWdlI3dpZHRofSBhbmQge0BsaW5rIGZhYnJpYy5JbWFnZSNoZWlnaHR9LlxuICAgICAqIEB0eXBlIGZhYnJpYy5JbWFnZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYmFja2dyb3VuZEltYWdlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogT3ZlcmxheSBjb2xvciBvZiBjYW52YXMgaW5zdGFuY2UuXG4gICAgICogU2hvdWxkIGJlIHNldCB2aWEge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjc2V0T3ZlcmxheUNvbG9yfVxuICAgICAqIEBzaW5jZSAxLjMuOVxuICAgICAqIEB0eXBlIHsoU3RyaW5nfGZhYnJpYy5QYXR0ZXJuKX1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG92ZXJsYXlDb2xvcjogJycsXG5cbiAgICAvKipcbiAgICAgKiBPdmVybGF5IGltYWdlIG9mIGNhbnZhcyBpbnN0YW5jZS5cbiAgICAgKiBTaG91bGQgYmUgc2V0IHZpYSB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNzZXRPdmVybGF5SW1hZ2V9LlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoZSBcIm92ZXJsYXlJbWFnZUxlZnRcIlxuICAgICAqIGFuZCBcIm92ZXJsYXlJbWFnZVRvcFwiIHByb3BlcnRpZXMgYXJlIGRlcHJlY2F0ZWQgc2luY2UgMS4zLjkuXG4gICAgICogVXNlIHtAbGluayBmYWJyaWMuSW1hZ2UjbGVmdH0gYW5kIHtAbGluayBmYWJyaWMuSW1hZ2UjdG9wfS5cbiAgICAgKiBAdHlwZSBmYWJyaWMuSW1hZ2VcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG92ZXJsYXlJbWFnZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRvT2JqZWN0L3RvRGF0YWxlc3NPYmplY3Qgc2hvdWxkIGluY2x1ZGUgZGVmYXVsdCB2YWx1ZXNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbmNsdWRlRGVmYXVsdFZhbHVlczogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIG9iamVjdHMnIHN0YXRlIHNob3VsZCBiZSBzYXZlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0YXRlZnVsOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIge0BsaW5rIGZhYnJpYy5Db2xsZWN0aW9uLmFkZH0sIHtAbGluayBmYWJyaWMuQ29sbGVjdGlvbi5pbnNlcnRBdH0gYW5kIHtAbGluayBmYWJyaWMuQ29sbGVjdGlvbi5yZW1vdmV9IHNob3VsZCBhbHNvIHJlLXJlbmRlciBjYW52YXMuXG4gICAgICogRGlzYWJsaW5nIHRoaXMgb3B0aW9uIGNvdWxkIGdpdmUgYSBncmVhdCBwZXJmb3JtYW5jZSBib29zdCB3aGVuIGFkZGluZy9yZW1vdmluZyBhIGxvdCBvZiBvYmplY3RzIHRvL2Zyb20gY2FudmFzIGF0IG9uY2VcbiAgICAgKiAoZm9sbG93ZWQgYnkgYSBtYW51YWwgcmVuZGVyaW5nIGFmdGVyIGFkZGl0aW9uL2RlbGV0aW9uKVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJlbmRlck9uQWRkUmVtb3ZlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIGNsaXBwaW5nIG9mIGVudGlyZSBjYW52YXMgYXJlYVxuICAgICAqIEJlaW5nIHBhc3NlZCBjb250ZXh0IGFzIGZpcnN0IGFyZ3VtZW50LiBTZWUgY2xpcHBpbmcgY2FudmFzIGFyZWEgaW4ge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9rYW5nYXgvZmFicmljLmpzL3dpa2kvRkFRfVxuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjbGlwVG86IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvYmplY3QgY29udHJvbHMgKGJvcmRlcnMvY29udHJvbHMpIGFyZSByZW5kZXJlZCBhYm92ZSBvdmVybGF5IGltYWdlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29udHJvbHNBYm92ZU92ZXJsYXk6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGJyb3dzZXIgY2FuIGJlIHNjcm9sbGVkIHdoZW4gdXNpbmcgYSB0b3VjaHNjcmVlbiBhbmQgZHJhZ2dpbmcgb24gdGhlIGNhbnZhc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGFsbG93VG91Y2hTY3JvbGxpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBjYW52YXMgd2lsbCB1c2UgaW1hZ2Ugc21vb3RoaW5nLCB0aGlzIGlzIG9uIGJ5IGRlZmF1bHQgaW4gYnJvd3NlcnNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbWFnZVNtb290aGluZ0VuYWJsZWQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHJhbnNmb3JtYXRpb24gKGluIHRoZSBmb3JtYXQgb2YgQ2FudmFzIHRyYW5zZm9ybSkgd2hpY2ggZm9jdXNlcyB0aGUgdmlld3BvcnRcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdmlld3BvcnRUcmFuc2Zvcm06IFsxLCAwLCAwLCAxLCAwLCAwXSxcblxuICAgIC8qKlxuICAgICAqIGlmIHNldCB0byBmYWxzZSBiYWNrZ3JvdW5kIGltYWdlIGlzIG5vdCBhZmZlY3RlZCBieSB2aWV3cG9ydCB0cmFuc2Zvcm1cbiAgICAgKiBAc2luY2UgMS42LjNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kVnB0OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogaWYgc2V0IHRvIGZhbHNlIG92ZXJseWEgaW1hZ2UgaXMgbm90IGFmZmVjdGVkIGJ5IHZpZXdwb3J0IHRyYW5zZm9ybVxuICAgICAqIEBzaW5jZSAxLjYuM1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG92ZXJsYXlWcHQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjazsgaW52b2tlZCByaWdodCBiZWZvcmUgb2JqZWN0IGlzIGFib3V0IHRvIGJlIHNjYWxlZC9yb3RhdGVkXG4gICAgICovXG4gICAgb25CZWZvcmVTY2FsZVJvdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgLyogTk9PUCAqL1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIGNhbnZhcyBpcyBzY2FsZWQgYnkgZGV2aWNlUGl4ZWxSYXRpbyBmb3IgYmV0dGVyIHJlbmRlcmluZyBvbiByZXRpbmEgc2NyZWVuc1xuICAgICAqL1xuICAgIGVuYWJsZVJldGluYVNjYWxpbmc6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBTdHJpbmd9IGVsICZsdDtjYW52YXM+IGVsZW1lbnQgdG8gaW5pdGlhbGl6ZSBpbnN0YW5jZSBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBfaW5pdFN0YXRpYzogZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjYiA9IGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLnJlbmRlckFsbC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgdGhpcy5fY3JlYXRlTG93ZXJDYW52YXMoZWwpO1xuICAgICAgdGhpcy5faW5pdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB0aGlzLl9zZXRJbWFnZVNtb290aGluZygpO1xuICAgICAgLy8gb25seSBpbml0aWFsaXplIHJldGluYSBzY2FsaW5nIG9uY2VcbiAgICAgIGlmICghdGhpcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICB0aGlzLl9pbml0UmV0aW5hU2NhbGluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5vdmVybGF5SW1hZ2UpIHtcbiAgICAgICAgdGhpcy5zZXRPdmVybGF5SW1hZ2Uob3B0aW9ucy5vdmVybGF5SW1hZ2UsIGNiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmJhY2tncm91bmRJbWFnZSkge1xuICAgICAgICB0aGlzLnNldEJhY2tncm91bmRJbWFnZShvcHRpb25zLmJhY2tncm91bmRJbWFnZSwgY2IpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIHRoaXMuc2V0QmFja2dyb3VuZENvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLCBjYik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5vdmVybGF5Q29sb3IpIHtcbiAgICAgICAgdGhpcy5zZXRPdmVybGF5Q29sb3Iob3B0aW9ucy5vdmVybGF5Q29sb3IsIGNiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsY09mZnNldCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc1JldGluYVNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbyAhPT0gMSAmJiB0aGlzLmVuYWJsZVJldGluYVNjYWxpbmcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gcmV0aW5hU2NhbGluZyBpZiBhcHBsaWVkLCBvdGhlcndpc2UgMTtcbiAgICAgKi9cbiAgICBnZXRSZXRpbmFTY2FsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc1JldGluYVNjYWxpbmcoKSA/IGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdFJldGluYVNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9pc1JldGluYVNjYWxpbmcoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMud2lkdGggKiBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmhlaWdodCAqIGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvKTtcblxuICAgICAgdGhpcy5jb250ZXh0Q29udGFpbmVyLnNjYWxlKGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvLCBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgY2FudmFzIGVsZW1lbnQgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGFsc28gYXR0YWNoZWQgYXMgXCJyZXNpemVcIiBldmVudCBoYW5kbGVyIG9mIHdpbmRvd1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNhbGNPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX29mZnNldCA9IGdldEVsZW1lbnRPZmZzZXQodGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI292ZXJsYXlJbWFnZXxvdmVybGF5IGltYWdlfSBmb3IgdGhpcyBjYW52YXNcbiAgICAgKiBAcGFyYW0geyhmYWJyaWMuSW1hZ2V8U3RyaW5nKX0gaW1hZ2UgZmFicmljLkltYWdlIGluc3RhbmNlIG9yIFVSTCBvZiBhbiBpbWFnZSB0byBzZXQgb3ZlcmxheSB0b1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIHRvIGludm9rZSB3aGVuIGltYWdlIGlzIGxvYWRlZCBhbmQgc2V0IGFzIGFuIG92ZXJsYXlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIG9wdGlvbnMgdG8gc2V0IGZvciB0aGUge0BsaW5rIGZhYnJpYy5JbWFnZXxvdmVybGF5IGltYWdlfS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvTW56SFQvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Tm9ybWFsIG92ZXJsYXlJbWFnZSB3aXRoIGxlZnQvdG9wID0gMDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9qYWlsX2NlbGxfYmFycy5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgLy8gTmVlZGVkIHRvIHBvc2l0aW9uIG92ZXJsYXlJbWFnZSBhdCAwLzBcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+b3ZlcmxheUltYWdlIHdpdGggZGlmZmVyZW50IHByb3BlcnRpZXM8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIG9wYWNpdHk6IDAuNSxcbiAgICAgKiAgIGFuZ2xlOiA0NSxcbiAgICAgKiAgIGxlZnQ6IDQwMCxcbiAgICAgKiAgIHRvcDogNDAwLFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCdcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdHJldGNoZWQgb3ZlcmxheUltYWdlICMxIC0gd2lkdGgvaGVpZ2h0IGNvcnJlc3BvbmQgdG8gY2FudmFzIHdpZHRoL2hlaWdodDwvY2FwdGlvbj5cbiAgICAgKiBmYWJyaWMuSW1hZ2UuZnJvbVVSTCgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgZnVuY3Rpb24oaW1nKSB7XG4gICAgICogICAgaW1nLnNldCh7d2lkdGg6IGNhbnZhcy53aWR0aCwgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LCBvcmlnaW5YOiAnbGVmdCcsIG9yaWdpblk6ICd0b3AnfSk7XG4gICAgICogICAgY2FudmFzLnNldE92ZXJsYXlJbWFnZShpbWcsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdHJldGNoZWQgb3ZlcmxheUltYWdlICMyIC0gd2lkdGgvaGVpZ2h0IGNvcnJlc3BvbmQgdG8gY2FudmFzIHdpZHRoL2hlaWdodDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9qYWlsX2NlbGxfYmFycy5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgKiAgIGhlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgKiAgIC8vIE5lZWRlZCB0byBwb3NpdGlvbiBvdmVybGF5SW1hZ2UgYXQgMC8wXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPm92ZXJsYXlJbWFnZSBsb2FkZWQgZnJvbSBjcm9zcy1vcmlnaW48L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIG9wYWNpdHk6IDAuNSxcbiAgICAgKiAgIGFuZ2xlOiA0NSxcbiAgICAgKiAgIGxlZnQ6IDQwMCxcbiAgICAgKiAgIHRvcDogNDAwLFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCcsXG4gICAgICogICBjcm9zc09yaWdpbjogJ2Fub255bW91cydcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBzZXRPdmVybGF5SW1hZ2U6IGZ1bmN0aW9uIChpbWFnZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc2V0QmdPdmVybGF5SW1hZ2UoJ292ZXJsYXlJbWFnZScsIGltYWdlLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjYmFja2dyb3VuZEltYWdlfGJhY2tncm91bmQgaW1hZ2V9IGZvciB0aGlzIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7KGZhYnJpYy5JbWFnZXxTdHJpbmcpfSBpbWFnZSBmYWJyaWMuSW1hZ2UgaW5zdGFuY2Ugb3IgVVJMIG9mIGFuIGltYWdlIHRvIHNldCBiYWNrZ3JvdW5kIHRvXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gaW1hZ2UgaXMgbG9hZGVkIGFuZCBzZXQgYXMgYmFja2dyb3VuZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uYWwgb3B0aW9ucyB0byBzZXQgZm9yIHRoZSB7QGxpbmsgZmFicmljLkltYWdlfGJhY2tncm91bmQgaW1hZ2V9LlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9ZSDl5RC98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Ob3JtYWwgYmFja2dyb3VuZEltYWdlIHdpdGggbGVmdC90b3AgPSAwPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kSW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgLy8gTmVlZGVkIHRvIHBvc2l0aW9uIGJhY2tncm91bmRJbWFnZSBhdCAwLzBcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+YmFja2dyb3VuZEltYWdlIHdpdGggZGlmZmVyZW50IHByb3BlcnRpZXM8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvaG9uZXlfaW1fc3VidGxlLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICBvcGFjaXR5OiAwLjUsXG4gICAgICogICBhbmdsZTogNDUsXG4gICAgICogICBsZWZ0OiA0MDAsXG4gICAgICogICB0b3A6IDQwMCxcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U3RyZXRjaGVkIGJhY2tncm91bmRJbWFnZSAjMSAtIHdpZHRoL2hlaWdodCBjb3JyZXNwb25kIHRvIGNhbnZhcyB3aWR0aC9oZWlnaHQ8L2NhcHRpb24+XG4gICAgICogZmFicmljLkltYWdlLmZyb21VUkwoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBmdW5jdGlvbihpbWcpIHtcbiAgICAgKiAgICBpbWcuc2V0KHt3aWR0aDogY2FudmFzLndpZHRoLCBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsIG9yaWdpblg6ICdsZWZ0Jywgb3JpZ2luWTogJ3RvcCd9KTtcbiAgICAgKiAgICBjYW52YXMuc2V0QmFja2dyb3VuZEltYWdlKGltZywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlN0cmV0Y2hlZCBiYWNrZ3JvdW5kSW1hZ2UgIzIgLSB3aWR0aC9oZWlnaHQgY29ycmVzcG9uZCB0byBjYW52YXMgd2lkdGgvaGVpZ2h0PC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kSW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgKiAgIGhlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgKiAgIC8vIE5lZWRlZCB0byBwb3NpdGlvbiBiYWNrZ3JvdW5kSW1hZ2UgYXQgMC8wXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmJhY2tncm91bmRJbWFnZSBsb2FkZWQgZnJvbSBjcm9zcy1vcmlnaW48L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvaG9uZXlfaW1fc3VidGxlLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICBvcGFjaXR5OiAwLjUsXG4gICAgICogICBhbmdsZTogNDUsXG4gICAgICogICBsZWZ0OiA0MDAsXG4gICAgICogICB0b3A6IDQwMCxcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnLFxuICAgICAqICAgY3Jvc3NPcmlnaW46ICdhbm9ueW1vdXMnXG4gICAgICogfSk7XG4gICAgICovXG4gICAgc2V0QmFja2dyb3VuZEltYWdlOiBmdW5jdGlvbiAoaW1hZ2UsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3NldEJnT3ZlcmxheUltYWdlKCdiYWNrZ3JvdW5kSW1hZ2UnLCBpbWFnZSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI292ZXJsYXlDb2xvcnxiYWNrZ3JvdW5kIGNvbG9yfSBmb3IgdGhpcyBjYW52YXNcbiAgICAgKiBAcGFyYW0geyhTdHJpbmd8ZmFicmljLlBhdHRlcm4pfSBvdmVybGF5Q29sb3IgQ29sb3Igb3IgcGF0dGVybiB0byBzZXQgYmFja2dyb3VuZCBjb2xvciB0b1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGJhY2tncm91bmQgY29sb3IgaXMgc2V0XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL3BCNTVoL3xqc0ZpZGRsZSBkZW1vfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk5vcm1hbCBvdmVybGF5Q29sb3IgLSBjb2xvciB2YWx1ZTwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUNvbG9yKCdyZ2JhKDI1NSwgNzMsIDY0LCAwLjYpJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmZhYnJpYy5QYXR0ZXJuIHVzZWQgYXMgb3ZlcmxheUNvbG9yPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRPdmVybGF5Q29sb3Ioe1xuICAgICAqICAgc291cmNlOiAnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvZXNjaGVyZXNxdWVfc3RlLnBuZydcbiAgICAgKiB9LCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+ZmFicmljLlBhdHRlcm4gdXNlZCBhcyBvdmVybGF5Q29sb3Igd2l0aCByZXBlYXQgYW5kIG9mZnNldDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUNvbG9yKHtcbiAgICAgKiAgIHNvdXJjZTogJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2VzY2hlcmVzcXVlX3N0ZS5wbmcnLFxuICAgICAqICAgcmVwZWF0OiAncmVwZWF0JyxcbiAgICAgKiAgIG9mZnNldFg6IDIwMCxcbiAgICAgKiAgIG9mZnNldFk6IDEwMFxuICAgICAqIH0sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKi9cbiAgICBzZXRPdmVybGF5Q29sb3I6IGZ1bmN0aW9uKG92ZXJsYXlDb2xvciwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc2V0QmdPdmVybGF5Q29sb3IoJ292ZXJsYXlDb2xvcicsIG92ZXJsYXlDb2xvciwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI2JhY2tncm91bmRDb2xvcnxiYWNrZ3JvdW5kIGNvbG9yfSBmb3IgdGhpcyBjYW52YXNcbiAgICAgKiBAcGFyYW0geyhTdHJpbmd8ZmFicmljLlBhdHRlcm4pfSBiYWNrZ3JvdW5kQ29sb3IgQ29sb3Igb3IgcGF0dGVybiB0byBzZXQgYmFja2dyb3VuZCBjb2xvciB0b1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGJhY2tncm91bmQgY29sb3IgaXMgc2V0XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL2hYenZrL3xqc0ZpZGRsZSBkZW1vfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk5vcm1hbCBiYWNrZ3JvdW5kQ29sb3IgLSBjb2xvciB2YWx1ZTwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0QmFja2dyb3VuZENvbG9yKCdyZ2JhKDI1NSwgNzMsIDY0LCAwLjYpJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmZhYnJpYy5QYXR0ZXJuIHVzZWQgYXMgYmFja2dyb3VuZENvbG9yPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kQ29sb3Ioe1xuICAgICAqICAgc291cmNlOiAnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvZXNjaGVyZXNxdWVfc3RlLnBuZydcbiAgICAgKiB9LCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+ZmFicmljLlBhdHRlcm4gdXNlZCBhcyBiYWNrZ3JvdW5kQ29sb3Igd2l0aCByZXBlYXQgYW5kIG9mZnNldDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0QmFja2dyb3VuZENvbG9yKHtcbiAgICAgKiAgIHNvdXJjZTogJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2VzY2hlcmVzcXVlX3N0ZS5wbmcnLFxuICAgICAqICAgcmVwZWF0OiAncmVwZWF0JyxcbiAgICAgKiAgIG9mZnNldFg6IDIwMCxcbiAgICAgKiAgIG9mZnNldFk6IDEwMFxuICAgICAqIH0sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKi9cbiAgICBzZXRCYWNrZ3JvdW5kQ29sb3I6IGZ1bmN0aW9uKGJhY2tncm91bmRDb2xvciwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc2V0QmdPdmVybGF5Q29sb3IoJ2JhY2tncm91bmRDb2xvcicsIGJhY2tncm91bmRDb2xvciwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2RvbS1jb250ZXh0LTJkLWltYWdlc21vb3RoaW5nZW5hYmxlZHxXaGF0V0cgQ2FudmFzIFN0YW5kYXJkfVxuICAgICAqL1xuICAgIF9zZXRJbWFnZVNtb290aGluZzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5nZXRDb250ZXh0KCk7XG5cbiAgICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IGN0eC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWRcbiAgICAgICAgfHwgY3R4Lm1vekltYWdlU21vb3RoaW5nRW5hYmxlZCB8fCBjdHgubXNJbWFnZVNtb290aGluZ0VuYWJsZWQgfHwgY3R4Lm9JbWFnZVNtb290aGluZ0VuYWJsZWQ7XG4gICAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdGhpcy5pbWFnZVNtb290aGluZ0VuYWJsZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRvIHNldCAoe0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjYmFja2dyb3VuZEltYWdlfGJhY2tncm91bmRJbWFnZX1cbiAgICAgKiBvciB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNvdmVybGF5SW1hZ2V8b3ZlcmxheUltYWdlfSlcbiAgICAgKiBAcGFyYW0geyhmYWJyaWMuSW1hZ2V8U3RyaW5nfG51bGwpfSBpbWFnZSBmYWJyaWMuSW1hZ2UgaW5zdGFuY2UsIFVSTCBvZiBhbiBpbWFnZSBvciBudWxsIHRvIHNldCBiYWNrZ3JvdW5kIG9yIG92ZXJsYXkgdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBpbWFnZSBpcyBsb2FkZWQgYW5kIHNldCBhcyBiYWNrZ3JvdW5kIG9yIG92ZXJsYXlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIG9wdGlvbnMgdG8gc2V0IGZvciB0aGUge0BsaW5rIGZhYnJpYy5JbWFnZXxpbWFnZX0uXG4gICAgICovXG4gICAgX19zZXRCZ092ZXJsYXlJbWFnZTogZnVuY3Rpb24ocHJvcGVydHksIGltYWdlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBpbWFnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZmFicmljLnV0aWwubG9hZEltYWdlKGltYWdlLCBmdW5jdGlvbihpbWcpIHtcbiAgICAgICAgICBpbWcgJiYgKHRoaXNbcHJvcGVydHldID0gbmV3IGZhYnJpYy5JbWFnZShpbWcsIG9wdGlvbnMpKTtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhpbWcpO1xuICAgICAgICB9LCB0aGlzLCBvcHRpb25zICYmIG9wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgJiYgaW1hZ2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBpbWFnZTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soaW1hZ2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdG8gc2V0ICh7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNiYWNrZ3JvdW5kQ29sb3J8YmFja2dyb3VuZENvbG9yfVxuICAgICAqIG9yIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI292ZXJsYXlDb2xvcnxvdmVybGF5Q29sb3J9KVxuICAgICAqIEBwYXJhbSB7KE9iamVjdHxTdHJpbmd8bnVsbCl9IGNvbG9yIE9iamVjdCB3aXRoIHBhdHRlcm4gaW5mb3JtYXRpb24sIGNvbG9yIHZhbHVlIG9yIG51bGxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIGlzIGludm9rZWQgd2hlbiBjb2xvciBpcyBzZXRcbiAgICAgKi9cbiAgICBfX3NldEJnT3ZlcmxheUNvbG9yOiBmdW5jdGlvbihwcm9wZXJ0eSwgY29sb3IsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoY29sb3IgJiYgY29sb3Iuc291cmNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGZhYnJpYy51dGlsLmxvYWRJbWFnZShjb2xvci5zb3VyY2UsIGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgIF90aGlzW3Byb3BlcnR5XSA9IG5ldyBmYWJyaWMuUGF0dGVybih7XG4gICAgICAgICAgICBzb3VyY2U6IGltZyxcbiAgICAgICAgICAgIHJlcGVhdDogY29sb3IucmVwZWF0LFxuICAgICAgICAgICAgb2Zmc2V0WDogY29sb3Iub2Zmc2V0WCxcbiAgICAgICAgICAgIG9mZnNldFk6IGNvbG9yLm9mZnNldFlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IGNvbG9yO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQ2FudmFzRWxlbWVudDogZnVuY3Rpb24oY2FudmFzRWwpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudChjYW52YXNFbClcbiAgICAgIGlmICghZWxlbWVudC5zdHlsZSkge1xuICAgICAgICBlbGVtZW50LnN0eWxlID0geyB9O1xuICAgICAgfVxuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHRocm93IENBTlZBU19JTklUX0VSUk9SO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50LmdldENvbnRleHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IENBTlZBU19JTklUX0VSUk9SO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIF9pbml0T3B0aW9uczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzW3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy53aWR0aCA9IHRoaXMud2lkdGggfHwgcGFyc2VJbnQodGhpcy5sb3dlckNhbnZhc0VsLndpZHRoLCAxMCkgfHwgMDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgfHwgcGFyc2VJbnQodGhpcy5sb3dlckNhbnZhc0VsLmhlaWdodCwgMTApIHx8IDA7XG5cbiAgICAgIGlmICghdGhpcy5sb3dlckNhbnZhc0VsLnN0eWxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb3dlckNhbnZhc0VsLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgIHRoaXMubG93ZXJDYW52YXNFbC5oZWlnaHQgPSB0aGlzLmhlaWdodDtcblxuICAgICAgdGhpcy5sb3dlckNhbnZhc0VsLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArICdweCc7XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyAncHgnO1xuXG4gICAgICB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybS5zbGljZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYm90dG9tIGNhbnZhc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2NhbnZhc0VsXVxuICAgICAqL1xuICAgIF9jcmVhdGVMb3dlckNhbnZhczogZnVuY3Rpb24gKGNhbnZhc0VsKSB7XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwgPSBmYWJyaWMudXRpbC5nZXRCeUlkKGNhbnZhc0VsKSB8fCB0aGlzLl9jcmVhdGVDYW52YXNFbGVtZW50KGNhbnZhc0VsKTtcblxuICAgICAgZmFicmljLnV0aWwuYWRkQ2xhc3ModGhpcy5sb3dlckNhbnZhc0VsLCAnbG93ZXItY2FudmFzJyk7XG5cbiAgICAgIGlmICh0aGlzLmludGVyYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuX2FwcGx5Q2FudmFzU3R5bGUodGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250ZXh0Q29udGFpbmVyID0gdGhpcy5sb3dlckNhbnZhc0VsLmdldENvbnRleHQoJzJkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY2FudmFzIHdpZHRoIChpbiBweClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNhbnZhcyBoZWlnaHQgKGluIHB4KVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB3aWR0aCBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWUgICAgICAgICAgICAgICAgICAgICAgICAgVmFsdWUgdG8gc2V0IHdpZHRoIHRvXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICBbb3B0aW9uc10gICAgICAgICAgICAgICAgICAgICBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuYmFja3N0b3JlT25seT1mYWxzZV0gU2V0IHRoZSBnaXZlbiBkaW1lbnNpb25zIG9ubHkgYXMgY2FudmFzIGJhY2tzdG9yZSBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5jc3NPbmx5PWZhbHNlXSAgICAgICBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjc3MgZGltZW5zaW9uc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgc2V0V2lkdGg6IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0RGltZW5zaW9ucyh7IHdpZHRoOiB2YWx1ZSB9LCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBoZWlnaHQgb2YgdGhpcyBjYW52YXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHZhbHVlICAgICAgICAgICAgICAgICAgICAgICAgIFZhbHVlIHRvIHNldCBoZWlnaHQgdG9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIFtvcHRpb25zXSAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5iYWNrc3RvcmVPbmx5PWZhbHNlXSBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjYW52YXMgYmFja3N0b3JlIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgIFtvcHRpb25zLmNzc09ubHk9ZmFsc2VdICAgICAgIFNldCB0aGUgZ2l2ZW4gZGltZW5zaW9ucyBvbmx5IGFzIGNzcyBkaW1lbnNpb25zXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0RGltZW5zaW9ucyh7IGhlaWdodDogdmFsdWUgfSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgZGltZW5zaW9ucyAod2lkdGgsIGhlaWdodCkgb2YgdGhpcyBjYW52YXMgaW5zdGFuY2UuIHdoZW4gb3B0aW9ucy5jc3NPbmx5IGZsYWcgYWN0aXZlIHlvdSBzaG91bGQgYWxzbyBzdXBwbHkgdGhlIHVuaXQgb2YgbWVhc3VyZSAocHgvJS9lbSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIGRpbWVuc2lvbnMgICAgICAgICAgICAgICAgICAgIE9iamVjdCB3aXRoIHdpZHRoL2hlaWdodCBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbZGltZW5zaW9ucy53aWR0aF0gICAgICAgICAgICBXaWR0aCBvZiBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW2RpbWVuc2lvbnMuaGVpZ2h0XSAgICAgICAgICAgSGVpZ2h0IG9mIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICBbb3B0aW9uc10gICAgICAgICAgICAgICAgICAgICBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuYmFja3N0b3JlT25seT1mYWxzZV0gU2V0IHRoZSBnaXZlbiBkaW1lbnNpb25zIG9ubHkgYXMgY2FudmFzIGJhY2tzdG9yZSBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5jc3NPbmx5PWZhbHNlXSAgICAgICBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjc3MgZGltZW5zaW9uc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0RGltZW5zaW9uczogZnVuY3Rpb24gKGRpbWVuc2lvbnMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjc3NWYWx1ZTtcblxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gZGltZW5zaW9ucykge1xuICAgICAgICBjc3NWYWx1ZSA9IGRpbWVuc2lvbnNbcHJvcF07XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmNzc09ubHkpIHtcbiAgICAgICAgICB0aGlzLl9zZXRCYWNrc3RvcmVEaW1lbnNpb24ocHJvcCwgZGltZW5zaW9uc1twcm9wXSk7XG4gICAgICAgICAgY3NzVmFsdWUgKz0gJ3B4JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy5iYWNrc3RvcmVPbmx5KSB7XG4gICAgICAgICAgdGhpcy5fc2V0Q3NzRGltZW5zaW9uKHByb3AsIGNzc1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5faW5pdFJldGluYVNjYWxpbmcoKTtcbiAgICAgIHRoaXMuX3NldEltYWdlU21vb3RoaW5nKCk7XG4gICAgICB0aGlzLmNhbGNPZmZzZXQoKTtcblxuICAgICAgaWYgKCFvcHRpb25zLmNzc09ubHkpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJBbGwoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmb3Igc2V0dGluZyB3aWR0aC9oZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIHByb3BlcnR5ICh3aWR0aHxoZWlnaHQpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIHZhbHVlIHRvIHNldCBwcm9wZXJ0eSB0b1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgX3NldEJhY2tzdG9yZURpbWVuc2lvbjogZnVuY3Rpb24gKHByb3AsIHZhbHVlKSB7XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWxbcHJvcF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHRoaXMudXBwZXJDYW52YXNFbCkge1xuICAgICAgICB0aGlzLnVwcGVyQ2FudmFzRWxbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2FjaGVDYW52YXNFbCkge1xuICAgICAgICB0aGlzLmNhY2hlQ2FudmFzRWxbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpc1twcm9wXSA9IHZhbHVlO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZvciBzZXR0aW5nIGNzcyB3aWR0aC9oZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIHByb3BlcnR5ICh3aWR0aHxoZWlnaHQpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIHZhbHVlIHRvIHNldCBwcm9wZXJ0eSB0b1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgX3NldENzc0RpbWVuc2lvbjogZnVuY3Rpb24gKHByb3AsIHZhbHVlKSB7XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHRoaXMudXBwZXJDYW52YXNFbCkge1xuICAgICAgICB0aGlzLnVwcGVyQ2FudmFzRWwuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMud3JhcHBlckVsKSB7XG4gICAgICAgIHRoaXMud3JhcHBlckVsLnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNhbnZhcyB6b29tIGxldmVsXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFpvb206IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy52aWV3cG9ydFRyYW5zZm9ybVswXSAqIHRoaXMudmlld3BvcnRUcmFuc2Zvcm1bM10pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHZpZXdwb3J0IHRyYW5zZm9ybSBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZwdCB0aGUgdHJhbnNmb3JtIGluIHRoZSBmb3JtIG9mIGNvbnRleHQudHJhbnNmb3JtXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBzZXRWaWV3cG9ydFRyYW5zZm9ybTogZnVuY3Rpb24gKHZwdCkge1xuICAgICAgdmFyIGFjdGl2ZUdyb3VwID0gdGhpcy5fYWN0aXZlR3JvdXAsIG9iamVjdDtcbiAgICAgIHRoaXMudmlld3BvcnRUcmFuc2Zvcm0gPSB2cHQ7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBvYmplY3QgPSB0aGlzLl9vYmplY3RzW2ldO1xuICAgICAgICBvYmplY3QuZ3JvdXAgfHwgb2JqZWN0LnNldENvb3JkcygpO1xuICAgICAgfVxuICAgICAgaWYgKGFjdGl2ZUdyb3VwKSB7XG4gICAgICAgIGFjdGl2ZUdyb3VwLnNldENvb3JkcygpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHpvb20gbGV2ZWwgb2YgdGhpcyBjYW52YXMgaW5zdGFuY2UsIHpvb20gY2VudGVyZWQgYXJvdW5kIHBvaW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IHRvIHpvb20gd2l0aCByZXNwZWN0IHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIHRvIHNldCB6b29tIHRvLCBsZXNzIHRoYW4gMSB6b29tcyBvdXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIHpvb21Ub1BvaW50OiBmdW5jdGlvbiAocG9pbnQsIHZhbHVlKSB7XG4gICAgICAvLyBUT0RPOiBqdXN0IGNoYW5nZSB0aGUgc2NhbGUsIHByZXNlcnZlIG90aGVyIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgdmFyIGJlZm9yZSA9IHBvaW50LCB2cHQgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtLnNsaWNlKDApO1xuICAgICAgcG9pbnQgPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChwb2ludCwgZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtKHRoaXMudmlld3BvcnRUcmFuc2Zvcm0pKTtcbiAgICAgIHZwdFswXSA9IHZhbHVlO1xuICAgICAgdnB0WzNdID0gdmFsdWU7XG4gICAgICB2YXIgYWZ0ZXIgPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChwb2ludCwgdnB0KTtcbiAgICAgIHZwdFs0XSArPSBiZWZvcmUueCAtIGFmdGVyLng7XG4gICAgICB2cHRbNV0gKz0gYmVmb3JlLnkgLSBhZnRlci55O1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Vmlld3BvcnRUcmFuc2Zvcm0odnB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB6b29tIGxldmVsIG9mIHRoaXMgY2FudmFzIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIHRvIHNldCB6b29tIHRvLCBsZXNzIHRoYW4gMSB6b29tcyBvdXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIHNldFpvb206IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdGhpcy56b29tVG9Qb2ludChuZXcgZmFicmljLlBvaW50KDAsIDApLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFuIHZpZXdwb3J0IHNvIGFzIHRvIHBsYWNlIHBvaW50IGF0IHRvcCBsZWZ0IGNvcm5lciBvZiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgdG8gbW92ZSB0b1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgYWJzb2x1dGVQYW46IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgdmFyIHZwdCA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0uc2xpY2UoMCk7XG4gICAgICB2cHRbNF0gPSAtcG9pbnQueDtcbiAgICAgIHZwdFs1XSA9IC1wb2ludC55O1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Vmlld3BvcnRUcmFuc2Zvcm0odnB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFucyB2aWV3cG9pbnQgcmVsYXRpdmVseVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCAocG9zaXRpb24gdmVjdG9yKSB0byBtb3ZlIGJ5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICByZWxhdGl2ZVBhbjogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5hYnNvbHV0ZVBhbihuZXcgZmFicmljLlBvaW50KFxuICAgICAgICAtcG9pbnQueCAtIHRoaXMudmlld3BvcnRUcmFuc2Zvcm1bNF0sXG4gICAgICAgIC1wb2ludC55IC0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybVs1XVxuICAgICAgKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgJmx0O2NhbnZhcz4gZWxlbWVudCBjb3JyZXNwb25kaW5nIHRvIHRoaXMgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICBnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb3dlckNhbnZhc0VsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqIE9iamVjdCB0aGF0IHdhcyBhZGRlZFxuICAgICAqL1xuICAgIF9vbk9iamVjdEFkZGVkOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHRoaXMuc3RhdGVmdWwgJiYgb2JqLnNldHVwU3RhdGUoKTtcbiAgICAgIG9iai5fc2V0KCdjYW52YXMnLCB0aGlzKTtcbiAgICAgIG9iai5zZXRDb29yZHMoKTtcbiAgICAgIHRoaXMuZmlyZSgnb2JqZWN0OmFkZGVkJywgeyB0YXJnZXQ6IG9iaiB9KTtcbiAgICAgIG9iai5maXJlKCdhZGRlZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqIE9iamVjdCB0aGF0IHdhcyByZW1vdmVkXG4gICAgICovXG4gICAgX29uT2JqZWN0UmVtb3ZlZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICB0aGlzLmZpcmUoJ29iamVjdDpyZW1vdmVkJywgeyB0YXJnZXQ6IG9iaiB9KTtcbiAgICAgIG9iai5maXJlKCdyZW1vdmVkJyk7XG4gICAgICBkZWxldGUgb2JqLmNhbnZhcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHNwZWNpZmllZCBjb250ZXh0IG9mIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIGNsZWFyXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjbGVhckNvbnRleHQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb250ZXh0IG9mIGNhbnZhcyB3aGVyZSBvYmplY3RzIGFyZSBkcmF3blxuICAgICAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cbiAgICBnZXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0Q29udGFpbmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIGNvbnRleHRzIChiYWNrZ3JvdW5kLCBtYWluLCB0b3ApIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fb2JqZWN0cy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kSW1hZ2UgPSBudWxsO1xuICAgICAgdGhpcy5vdmVybGF5SW1hZ2UgPSBudWxsO1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSAnJztcbiAgICAgIHRoaXMub3ZlcmxheUNvbG9yID0gJydcbiAgICAgIGlmICh0aGlzLl9oYXNJVGV4dEhhbmRsZXJzKSB7XG4gICAgICAgIHRoaXMub2ZmKCdzZWxlY3Rpb246Y2xlYXJlZCcsIHRoaXMuX2NhbnZhc0lUZXh0U2VsZWN0aW9uQ2xlYXJlZEhhbmxkZXIpO1xuICAgICAgICB0aGlzLm9mZignb2JqZWN0OnNlbGVjdGVkJywgdGhpcy5fY2FudmFzSVRleHRTZWxlY3Rpb25DbGVhcmVkSGFubGRlcik7XG4gICAgICAgIHRoaXMub2ZmKCdtb3VzZTp1cCcsIHRoaXMuX21vdXNlVXBJVGV4dEhhbmRsZXIpO1xuICAgICAgICB0aGlzLl9pVGV4dEluc3RhbmNlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2hhc0lUZXh0SGFuZGxlcnMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0KHRoaXMuY29udGV4dENvbnRhaW5lcik7XG4gICAgICB0aGlzLmZpcmUoJ2NhbnZhczpjbGVhcmVkJyk7XG4gICAgICB0aGlzLnJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYm90aCB0aGUgY2FudmFzLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlbmRlckFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNhbnZhc1RvRHJhd09uID0gdGhpcy5jb250ZXh0Q29udGFpbmVyO1xuICAgICAgdGhpcy5yZW5kZXJDYW52YXMoY2FudmFzVG9EcmF3T24sIHRoaXMuX29iamVjdHMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYmFja2dyb3VuZCwgb2JqZWN0cywgb3ZlcmxheSBhbmQgY29udHJvbHMuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9iamVjdHMgdG8gcmVuZGVyXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVuZGVyQ2FudmFzOiBmdW5jdGlvbihjdHgsIG9iamVjdHMpIHtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0KGN0eCk7XG4gICAgICB0aGlzLmZpcmUoJ2JlZm9yZTpyZW5kZXInKTtcbiAgICAgIGlmICh0aGlzLmNsaXBUbykge1xuICAgICAgICBmYWJyaWMudXRpbC5jbGlwQ29udGV4dCh0aGlzLCBjdHgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyQmFja2dyb3VuZChjdHgpO1xuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgLy9hcHBseSB2aWV3cG9ydCB0cmFuc2Zvcm0gb25jZSBmb3IgYWxsIHJlbmRlcmluZyBwcm9jZXNzXG4gICAgICBjdHgudHJhbnNmb3JtLmFwcGx5KGN0eCwgdGhpcy52aWV3cG9ydFRyYW5zZm9ybSk7XG4gICAgICB0aGlzLl9yZW5kZXJPYmplY3RzKGN0eCwgb2JqZWN0cyk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgaWYgKCF0aGlzLmNvbnRyb2xzQWJvdmVPdmVybGF5ICYmIHRoaXMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5kcmF3Q29udHJvbHMoY3R4KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNsaXBUbykge1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyT3ZlcmxheShjdHgpO1xuICAgICAgaWYgKHRoaXMuY29udHJvbHNBYm92ZU92ZXJsYXkgJiYgdGhpcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICB0aGlzLmRyYXdDb250cm9scyhjdHgpO1xuICAgICAgfVxuICAgICAgdGhpcy5maXJlKCdhZnRlcjpyZW5kZXInKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqZWN0cyB0byByZW5kZXJcbiAgICAgKi9cbiAgICBfcmVuZGVyT2JqZWN0czogZnVuY3Rpb24oY3R4LCBvYmplY3RzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBvYmplY3RzW2ldICYmIG9iamVjdHNbaV0ucmVuZGVyKGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAnYmFja2dyb3VuZCcgb3IgJ292ZXJsYXknXG4gICAgICovXG4gICAgX3JlbmRlckJhY2tncm91bmRPck92ZXJsYXk6IGZ1bmN0aW9uKGN0eCwgcHJvcGVydHkpIHtcbiAgICAgIHZhciBvYmplY3QgPSB0aGlzW3Byb3BlcnR5ICsgJ0NvbG9yJ107XG4gICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvYmplY3QudG9MaXZlXG4gICAgICAgICAgPyBvYmplY3QudG9MaXZlKGN0eClcbiAgICAgICAgICA6IG9iamVjdDtcblxuICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgb2JqZWN0Lm9mZnNldFggfHwgMCxcbiAgICAgICAgICBvYmplY3Qub2Zmc2V0WSB8fCAwLFxuICAgICAgICAgIHRoaXMud2lkdGgsXG4gICAgICAgICAgdGhpcy5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gdGhpc1twcm9wZXJ0eSArICdJbWFnZSddO1xuICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICBpZiAodGhpc1twcm9wZXJ0eSArICdWcHQnXSkge1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgY3R4LnRyYW5zZm9ybS5hcHBseShjdHgsIHRoaXMudmlld3BvcnRUcmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdC5yZW5kZXIoY3R4KTtcbiAgICAgICAgdGhpc1twcm9wZXJ0eSArICdWcHQnXSAmJiBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyQmFja2dyb3VuZDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLl9yZW5kZXJCYWNrZ3JvdW5kT3JPdmVybGF5KGN0eCwgJ2JhY2tncm91bmQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlck92ZXJsYXk6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5fcmVuZGVyQmFja2dyb3VuZE9yT3ZlcmxheShjdHgsICdvdmVybGF5Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29vcmRpbmF0ZXMgb2YgYSBjZW50ZXIgb2YgY2FudmFzLlxuICAgICAqIFJldHVybmVkIHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIHRvcCBhbmQgbGVmdCBwcm9wZXJ0aWVzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBcInRvcFwiIGFuZCBcImxlZnRcIiBudW1iZXIgdmFsdWVzXG4gICAgICovXG4gICAgZ2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHRoaXMuZ2V0SGVpZ2h0KCkgLyAyLFxuICAgICAgICBsZWZ0OiB0aGlzLmdldFdpZHRoKCkgLyAyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBob3Jpem9udGFsbHkgaW4gdGhlIGNhbnZhc1xuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciBob3Jpem9udGFsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICovXG4gICAgY2VudGVyT2JqZWN0SDogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIG5ldyBmYWJyaWMuUG9pbnQodGhpcy5nZXRDZW50ZXIoKS5sZWZ0LCBvYmplY3QuZ2V0Q2VudGVyUG9pbnQoKS55KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgaW4gdGhlIGNhbnZhc1xuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciB2ZXJ0aWNhbGx5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjZW50ZXJPYmplY3RWOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2VudGVyT2JqZWN0KG9iamVjdCwgbmV3IGZhYnJpYy5Qb2ludChvYmplY3QuZ2V0Q2VudGVyUG9pbnQoKS54LCB0aGlzLmdldENlbnRlcigpLnRvcCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHkgaW4gdGhlIGNhbnZhc1xuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNlbnRlck9iamVjdDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIG5ldyBmYWJyaWMuUG9pbnQoY2VudGVyLmxlZnQsIGNlbnRlci50b3ApKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5IGluIHRoZSB2aWV3cG9ydFxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVyT2JqZWN0OiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciB2cENlbnRlciA9IHRoaXMuZ2V0VnBDZW50ZXIoKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIHZwQ2VudGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgaG9yaXpvbnRhbGx5IGluIHRoZSB2aWV3cG9ydCwgb2JqZWN0LnRvcCBpcyB1bmNoYW5nZWRcbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXIgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB2aWV3cG9ydENlbnRlck9iamVjdEg6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHZwQ2VudGVyID0gdGhpcy5nZXRWcENlbnRlcigpO1xuICAgICAgdGhpcy5fY2VudGVyT2JqZWN0KG9iamVjdCwgbmV3IGZhYnJpYy5Qb2ludCh2cENlbnRlci54LCBvYmplY3QuZ2V0Q2VudGVyUG9pbnQoKS55KSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgVmVydGljYWxseSBpbiB0aGUgdmlld3BvcnQsIG9iamVjdC50b3AgaXMgdW5jaGFuZ2VkXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyIHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdmlld3BvcnRDZW50ZXJPYmplY3RWOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciB2cENlbnRlciA9IHRoaXMuZ2V0VnBDZW50ZXIoKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIG5ldyBmYWJyaWMuUG9pbnQob2JqZWN0LmdldENlbnRlclBvaW50KCkueCwgdnBDZW50ZXIueSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvaW50IGluIGNhbnZhcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIGNlbnRlciBvZiBhY3R1YWwgdmlld3BvcnQuXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB2cENlbnRlciwgdmlld3BvcnQgY2VudGVyXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGdldFZwQ2VudGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpLFxuICAgICAgICAgIGlWcHQgPSBmYWJyaWMudXRpbC5pbnZlcnRUcmFuc2Zvcm0odGhpcy52aWV3cG9ydFRyYW5zZm9ybSk7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQoeyB4OiBjZW50ZXIubGVmdCwgeTogY2VudGVyLnRvcCB9LCBpVnB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGNlbnRlciBDZW50ZXIgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIF9jZW50ZXJPYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCwgY2VudGVyKSB7XG4gICAgICBvYmplY3Quc2V0UG9zaXRpb25CeU9yaWdpbihjZW50ZXIsICdjZW50ZXInLCAnY2VudGVyJyk7XG4gICAgICB0aGlzLnJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVycyBkYXRhbGVzcyBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGpzb24gc3RyaW5nXG4gICAgICovXG4gICAgdG9EYXRhbGVzc0pTT046IGZ1bmN0aW9uIChwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0RhdGFsZXNzT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24gKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b09iamVjdE1ldGhvZCgndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBkYXRhbGVzcyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgY2FudmFzXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9EYXRhbGVzc09iamVjdDogZnVuY3Rpb24gKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b09iamVjdE1ldGhvZCgndG9EYXRhbGVzc09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90b09iamVjdE1ldGhvZDogZnVuY3Rpb24gKG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcblxuICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgIG9iamVjdHM6IHRoaXMuX3RvT2JqZWN0cyhtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKVxuICAgICAgfTtcblxuICAgICAgZXh0ZW5kKGRhdGEsIHRoaXMuX19zZXJpYWxpemVCZ092ZXJsYXkocHJvcGVydGllc1RvSW5jbHVkZSkpO1xuXG4gICAgICBmYWJyaWMudXRpbC5wb3B1bGF0ZVdpdGhQcm9wZXJ0aWVzKHRoaXMsIGRhdGEsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdG9PYmplY3RzOiBmdW5jdGlvbihtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RzKCkuZmlsdGVyKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gIW9iamVjdC5leGNsdWRlRnJvbUV4cG9ydDtcbiAgICAgIH0pLm1hcChmdW5jdGlvbihpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9PYmplY3QoaW5zdGFuY2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RvT2JqZWN0OiBmdW5jdGlvbihpbnN0YW5jZSwgbWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG9yaWdpbmFsVmFsdWU7XG5cbiAgICAgIGlmICghdGhpcy5pbmNsdWRlRGVmYXVsdFZhbHVlcykge1xuICAgICAgICBvcmlnaW5hbFZhbHVlID0gaW5zdGFuY2UuaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICAgIGluc3RhbmNlLmluY2x1ZGVEZWZhdWx0VmFsdWVzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBvYmplY3QgPSBpbnN0YW5jZVttZXRob2ROYW1lXShwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIGlmICghdGhpcy5pbmNsdWRlRGVmYXVsdFZhbHVlcykge1xuICAgICAgICBpbnN0YW5jZS5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IG9yaWdpbmFsVmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9fc2VyaWFsaXplQmdPdmVybGF5OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgYmFja2dyb3VuZDogKHRoaXMuYmFja2dyb3VuZENvbG9yICYmIHRoaXMuYmFja2dyb3VuZENvbG9yLnRvT2JqZWN0KVxuICAgICAgICAgID8gdGhpcy5iYWNrZ3JvdW5kQ29sb3IudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSlcbiAgICAgICAgICA6IHRoaXMuYmFja2dyb3VuZENvbG9yXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5vdmVybGF5Q29sb3IpIHtcbiAgICAgICAgZGF0YS5vdmVybGF5ID0gdGhpcy5vdmVybGF5Q29sb3IudG9PYmplY3RcbiAgICAgICAgICA/IHRoaXMub3ZlcmxheUNvbG9yLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpXG4gICAgICAgICAgOiB0aGlzLm92ZXJsYXlDb2xvcjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmJhY2tncm91bmRJbWFnZSkge1xuICAgICAgICBkYXRhLmJhY2tncm91bmRJbWFnZSA9IHRoaXMuYmFja2dyb3VuZEltYWdlLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3ZlcmxheUltYWdlKSB7XG4gICAgICAgIGRhdGEub3ZlcmxheUltYWdlID0gdGhpcy5vdmVybGF5SW1hZ2UudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgZ2V0U3ZnVHJhbnNmb3JtKCkgd2lsbCBhcHBseSB0aGUgU3RhdGljQ2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtIHRvIHRoZSBTVkcgdHJhbnNmb3JtYXRpb24uIFdoZW4gdHJ1ZSxcbiAgICAgKiBhIHpvb21lZCBjYW52YXMgd2lsbCB0aGVuIHByb2R1Y2Ugem9vbWVkIFNWRyBvdXRwdXQuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3ZnVmlld3BvcnRUcmFuc2Zvcm1hdGlvbjogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGNhbnZhc1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3QgZm9yIFNWRyBvdXRwdXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN1cHByZXNzUHJlYW1ibGU9ZmFsc2VdIElmIHRydWUgeG1sIHRhZyBpcyBub3QgaW5jbHVkZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudmlld0JveF0gU1ZHIHZpZXdib3ggb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnZpZXdCb3gueF0geC1jb29yaWRuYXRlIG9mIHZpZXdib3hcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmlld0JveC55XSB5LWNvb3JkaW5hdGUgb2Ygdmlld2JveFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52aWV3Qm94LndpZHRoXSBXaWR0aCBvZiB2aWV3Ym94XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnZpZXdCb3guaGVpZ2h0XSBIZWlnaHQgb2Ygdmlld2JveFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz1VVEYtOF0gRW5jb2Rpbmcgb2YgU1ZHIG91dHB1dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy53aWR0aF0gZGVzaXJlZCB3aWR0aCBvZiBzdmcgd2l0aCBvciB3aXRob3V0IHVuaXRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmhlaWdodF0gZGVzaXJlZCBoZWlnaHQgb2Ygc3ZnIHdpdGggb3Igd2l0aG91dCB1bml0c1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgZWxlbWVudHMsIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY29udmVydGVkIGludG8gc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU1ZHIHN0cmluZ1xuICAgICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0zI3NlcmlhbGl6YXRpb259XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9qUTNaWi98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Ob3JtYWwgU1ZHIG91dHB1dDwvY2FwdGlvbj5cbiAgICAgKiB2YXIgc3ZnID0gY2FudmFzLnRvU1ZHKCk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U1ZHIG91dHB1dCB3aXRob3V0IHByZWFtYmxlICh3aXRob3V0ICZsdDs/eG1sIC4uLz4pPC9jYXB0aW9uPlxuICAgICAqIHZhciBzdmcgPSBjYW52YXMudG9TVkcoe3N1cHByZXNzUHJlYW1ibGU6IHRydWV9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TVkcgb3V0cHV0IHdpdGggdmlld0JveCBhdHRyaWJ1dGU8L2NhcHRpb24+XG4gICAgICogdmFyIHN2ZyA9IGNhbnZhcy50b1NWRyh7XG4gICAgICogICB2aWV3Qm94OiB7XG4gICAgICogICAgIHg6IDEwMCxcbiAgICAgKiAgICAgeTogMTAwLFxuICAgICAqICAgICB3aWR0aDogMjAwLFxuICAgICAqICAgICBoZWlnaHQ6IDMwMFxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlNWRyBvdXRwdXQgd2l0aCBkaWZmZXJlbnQgZW5jb2RpbmcgKGRlZmF1bHQ6IFVURi04KTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgc3ZnID0gY2FudmFzLnRvU1ZHKHtlbmNvZGluZzogJ0lTTy04ODU5LTEnfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+TW9kaWZ5IFNWRyBvdXRwdXQgd2l0aCByZXZpdmVyIGZ1bmN0aW9uPC9jYXB0aW9uPlxuICAgICAqIHZhciBzdmcgPSBjYW52YXMudG9TVkcobnVsbCwgZnVuY3Rpb24oc3ZnKSB7XG4gICAgICogICByZXR1cm4gc3ZnLnJlcGxhY2UoJ3N0cm9rZS1kYXNoYXJyYXk6IDsgc3Ryb2tlLWxpbmVjYXA6IGJ1dHQ7IHN0cm9rZS1saW5lam9pbjogbWl0ZXI7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgJywgJycpO1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihvcHRpb25zLCByZXZpdmVyKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdmFyIG1hcmt1cCA9IFtdO1xuXG4gICAgICB0aGlzLl9zZXRTVkdQcmVhbWJsZShtYXJrdXAsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc2V0U1ZHSGVhZGVyKG1hcmt1cCwgb3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuX3NldFNWR0JnT3ZlcmxheUNvbG9yKG1hcmt1cCwgJ2JhY2tncm91bmRDb2xvcicpO1xuICAgICAgdGhpcy5fc2V0U1ZHQmdPdmVybGF5SW1hZ2UobWFya3VwLCAnYmFja2dyb3VuZEltYWdlJywgcmV2aXZlcik7XG5cbiAgICAgIHRoaXMuX3NldFNWR09iamVjdHMobWFya3VwLCByZXZpdmVyKTtcblxuICAgICAgdGhpcy5fc2V0U1ZHQmdPdmVybGF5Q29sb3IobWFya3VwLCAnb3ZlcmxheUNvbG9yJyk7XG4gICAgICB0aGlzLl9zZXRTVkdCZ092ZXJsYXlJbWFnZShtYXJrdXAsICdvdmVybGF5SW1hZ2UnLCByZXZpdmVyKTtcblxuICAgICAgbWFya3VwLnB1c2goJzwvc3ZnPicpO1xuXG4gICAgICByZXR1cm4gbWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdQcmVhbWJsZTogZnVuY3Rpb24obWFya3VwLCBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdXBwcmVzc1ByZWFtYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiJywgKG9wdGlvbnMuZW5jb2RpbmcgfHwgJ1VURi04JyksICdcIiBzdGFuZGFsb25lPVwibm9cIiA/PlxcbicsXG4gICAgICAgICAgJzwhRE9DVFlQRSBzdmcgUFVCTElDIFwiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU5cIiAnLFxuICAgICAgICAgICAgJ1wiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkXCI+XFxuJ1xuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHSGVhZGVyOiBmdW5jdGlvbihtYXJrdXAsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB3aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgdGhpcy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCB0aGlzLmhlaWdodCxcbiAgICAgICAgICB2cHQsIHZpZXdCb3ggPSAndmlld0JveD1cIjAgMCAnICsgdGhpcy53aWR0aCArICcgJyArIHRoaXMuaGVpZ2h0ICsgJ1wiICcsXG4gICAgICAgICAgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUztcblxuICAgICAgaWYgKG9wdGlvbnMudmlld0JveCkge1xuICAgICAgICB2aWV3Qm94ID0gJ3ZpZXdCb3g9XCInICtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnZpZXdCb3gueCArICcgJyArXG4gICAgICAgICAgICAgICAgb3B0aW9ucy52aWV3Qm94LnkgKyAnICcgK1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudmlld0JveC53aWR0aCArICcgJyArXG4gICAgICAgICAgICAgICAgb3B0aW9ucy52aWV3Qm94LmhlaWdodCArICdcIiAnO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLnN2Z1ZpZXdwb3J0VHJhbnNmb3JtYXRpb24pIHtcbiAgICAgICAgICB2cHQgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgICAgICAgIHZpZXdCb3ggPSAndmlld0JveD1cIicgK1xuICAgICAgICAgICAgICAgICAgdG9GaXhlZCgtdnB0WzRdIC8gdnB0WzBdLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICcgJyArXG4gICAgICAgICAgICAgICAgICB0b0ZpeGVkKC12cHRbNV0gLyB2cHRbM10sIE5VTV9GUkFDVElPTl9ESUdJVFMpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy53aWR0aCAvIHZwdFswXSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmhlaWdodCAvIHZwdFszXSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnXCIgJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgJzxzdmcgJyxcbiAgICAgICAgICAneG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiICcsXG4gICAgICAgICAgJ3htbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiICcsXG4gICAgICAgICAgJ3ZlcnNpb249XCIxLjFcIiAnLFxuICAgICAgICAgICd3aWR0aD1cIicsIHdpZHRoLCAnXCIgJyxcbiAgICAgICAgICAnaGVpZ2h0PVwiJywgaGVpZ2h0LCAnXCIgJyxcbiAgICAgICAgICAodGhpcy5iYWNrZ3JvdW5kQ29sb3IgJiYgIXRoaXMuYmFja2dyb3VuZENvbG9yLnRvTGl2ZVxuICAgICAgICAgICAgPyAnc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiAnICsgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgKyAnXCIgJ1xuICAgICAgICAgICAgOiBudWxsKSxcbiAgICAgICAgICB2aWV3Qm94LFxuICAgICAgICAgICd4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiPlxcbicsXG4gICAgICAgICc8ZGVzYz5DcmVhdGVkIHdpdGggRmFicmljLmpzICcsIGZhYnJpYy52ZXJzaW9uLCAnPC9kZXNjPlxcbicsXG4gICAgICAgICc8ZGVmcz4nLFxuICAgICAgICAgIGZhYnJpYy5jcmVhdGVTVkdGb250RmFjZXNNYXJrdXAodGhpcy5nZXRPYmplY3RzKCkpLFxuICAgICAgICAgIGZhYnJpYy5jcmVhdGVTVkdSZWZFbGVtZW50c01hcmt1cCh0aGlzKSxcbiAgICAgICAgJzwvZGVmcz5cXG4nXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdPYmplY3RzOiBmdW5jdGlvbihtYXJrdXAsIHJldml2ZXIpIHtcbiAgICAgIHZhciBpbnN0YW5jZTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBvYmplY3RzID0gdGhpcy5nZXRPYmplY3RzKCksIGxlbiA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaW5zdGFuY2UgPSBvYmplY3RzW2ldO1xuICAgICAgICBpZiAoaW5zdGFuY2UuZXhjbHVkZUZyb21FeHBvcnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRTVkdPYmplY3QobWFya3VwLCBpbnN0YW5jZSwgcmV2aXZlcik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHB1c2ggc2luZ2xlIG9iamVjdCBzdmcgcmVwcmVzZW50YXRpb24gaW4gdGhlIG1hcmt1cFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR09iamVjdDogZnVuY3Rpb24obWFya3VwLCBpbnN0YW5jZSwgcmV2aXZlcikge1xuICAgICAgbWFya3VwLnB1c2goaW5zdGFuY2UudG9TVkcocmV2aXZlcikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdCZ092ZXJsYXlJbWFnZTogZnVuY3Rpb24obWFya3VwLCBwcm9wZXJ0eSwgcmV2aXZlcikge1xuICAgICAgaWYgKHRoaXNbcHJvcGVydHldICYmIHRoaXNbcHJvcGVydHldLnRvU1ZHKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKHRoaXNbcHJvcGVydHldLnRvU1ZHKHJldml2ZXIpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHQmdPdmVybGF5Q29sb3I6IGZ1bmN0aW9uKG1hcmt1cCwgcHJvcGVydHkpIHtcbiAgICAgIGlmICh0aGlzW3Byb3BlcnR5XSAmJiB0aGlzW3Byb3BlcnR5XS5zb3VyY2UpIHtcbiAgICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICAgJzxyZWN0IHg9XCInLCB0aGlzW3Byb3BlcnR5XS5vZmZzZXRYLCAnXCIgeT1cIicsIHRoaXNbcHJvcGVydHldLm9mZnNldFksICdcIiAnLFxuICAgICAgICAgICAgJ3dpZHRoPVwiJyxcbiAgICAgICAgICAgICAgKHRoaXNbcHJvcGVydHldLnJlcGVhdCA9PT0gJ3JlcGVhdC15JyB8fCB0aGlzW3Byb3BlcnR5XS5yZXBlYXQgPT09ICduby1yZXBlYXQnXG4gICAgICAgICAgICAgICAgPyB0aGlzW3Byb3BlcnR5XS5zb3VyY2Uud2lkdGhcbiAgICAgICAgICAgICAgICA6IHRoaXMud2lkdGgpLFxuICAgICAgICAgICAgJ1wiIGhlaWdodD1cIicsXG4gICAgICAgICAgICAgICh0aGlzW3Byb3BlcnR5XS5yZXBlYXQgPT09ICdyZXBlYXQteCcgfHwgdGhpc1twcm9wZXJ0eV0ucmVwZWF0ID09PSAnbm8tcmVwZWF0J1xuICAgICAgICAgICAgICAgID8gdGhpc1twcm9wZXJ0eV0uc291cmNlLmhlaWdodFxuICAgICAgICAgICAgICAgIDogdGhpcy5oZWlnaHQpLFxuICAgICAgICAgICAgJ1wiIGZpbGw9XCJ1cmwoIycgKyBwcm9wZXJ0eSArICdQYXR0ZXJuKVwiJyxcbiAgICAgICAgICAnPjwvcmVjdD5cXG4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzW3Byb3BlcnR5XSAmJiBwcm9wZXJ0eSA9PT0gJ292ZXJsYXlDb2xvcicpIHtcbiAgICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICAgJzxyZWN0IHg9XCIwXCIgeT1cIjBcIiAnLFxuICAgICAgICAgICAgJ3dpZHRoPVwiJywgdGhpcy53aWR0aCxcbiAgICAgICAgICAgICdcIiBoZWlnaHQ9XCInLCB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgICdcIiBmaWxsPVwiJywgdGhpc1twcm9wZXJ0eV0sICdcIicsXG4gICAgICAgICAgJz48L3JlY3Q+XFxuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBvYmplY3Qgb3IgdGhlIG9iamVjdHMgb2YgYSBtdWx0aXBsZSBzZWxlY3Rpb25cbiAgICAgKiB0byB0aGUgYm90dG9tIG9mIHRoZSBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmQgdG8gYmFja1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2VuZFRvQmFjazogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgYWN0aXZlR3JvdXAgPSB0aGlzLl9hY3RpdmVHcm91cCxcbiAgICAgICAgICBpLCBvYmosIG9ianM7XG4gICAgICBpZiAob2JqZWN0ID09PSBhY3RpdmVHcm91cCkge1xuICAgICAgICBvYmpzID0gYWN0aXZlR3JvdXAuX29iamVjdHM7XG4gICAgICAgIGZvciAoaSA9IG9ianMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgb2JqID0gb2Jqc1tpXTtcbiAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqKTtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzLnVuc2hpZnQob2JqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgICB0aGlzLl9vYmplY3RzLnVuc2hpZnQob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlckFsbCAmJiB0aGlzLnJlbmRlckFsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBvYmplY3Qgb3IgdGhlIG9iamVjdHMgb2YgYSBtdWx0aXBsZSBzZWxlY3Rpb25cbiAgICAgKiB0byB0aGUgdG9wIG9mIHRoZSBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgYWN0aXZlR3JvdXAgPSB0aGlzLl9hY3RpdmVHcm91cCxcbiAgICAgICAgICBpLCBvYmosIG9ianM7XG4gICAgICBpZiAob2JqZWN0ID09PSBhY3RpdmVHcm91cCkge1xuICAgICAgICBvYmpzID0gYWN0aXZlR3JvdXAuX29iamVjdHM7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmpzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgb2JqID0gb2Jqc1tpXTtcbiAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqKTtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzLnB1c2gob2JqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgICB0aGlzLl9vYmplY3RzLnB1c2gob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlckFsbCAmJiB0aGlzLnJlbmRlckFsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBvYmplY3Qgb3IgYSBzZWxlY3Rpb24gZG93biBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnRlcnNlY3RpbmddIElmIGB0cnVlYCwgc2VuZCBvYmplY3QgYmVoaW5kIG5leHQgbG93ZXIgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2VuZEJhY2t3YXJkczogZnVuY3Rpb24gKG9iamVjdCwgaW50ZXJzZWN0aW5nKSB7XG4gICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBhY3RpdmVHcm91cCA9IHRoaXMuX2FjdGl2ZUdyb3VwLFxuICAgICAgICAgIGksIG9iaiwgaWR4LCBuZXdJZHgsIG9ianM7XG5cbiAgICAgIGlmIChvYmplY3QgPT09IGFjdGl2ZUdyb3VwKSB7XG4gICAgICAgIG9ianMgPSBhY3RpdmVHcm91cC5fb2JqZWN0cztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9ianMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvYmogPSBvYmpzW2ldO1xuICAgICAgICAgIGlkeCA9IHRoaXMuX29iamVjdHMuaW5kZXhPZihvYmopO1xuICAgICAgICAgIGlmIChpZHggIT09IDApIHtcbiAgICAgICAgICAgIG5ld0lkeCA9IGlkeCAtIDE7XG4gICAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqKTtcbiAgICAgICAgICAgIHRoaXMuX29iamVjdHMuc3BsaWNlKG5ld0lkeCwgMCwgb2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZHggPSB0aGlzLl9vYmplY3RzLmluZGV4T2Yob2JqZWN0KTtcbiAgICAgICAgaWYgKGlkeCAhPT0gMCkge1xuICAgICAgICAgIC8vIGlmIG9iamVjdCBpcyBub3Qgb24gdGhlIGJvdHRvbSBvZiBzdGFja1xuICAgICAgICAgIG5ld0lkeCA9IHRoaXMuX2ZpbmROZXdMb3dlckluZGV4KG9iamVjdCwgaWR4LCBpbnRlcnNlY3RpbmcpO1xuICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgICAgIHRoaXMuX29iamVjdHMuc3BsaWNlKG5ld0lkeCwgMCwgb2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJBbGwgJiYgdGhpcy5yZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maW5kTmV3TG93ZXJJbmRleDogZnVuY3Rpb24ob2JqZWN0LCBpZHgsIGludGVyc2VjdGluZykge1xuICAgICAgdmFyIG5ld0lkeDtcblxuICAgICAgaWYgKGludGVyc2VjdGluZykge1xuICAgICAgICBuZXdJZHggPSBpZHg7XG5cbiAgICAgICAgLy8gdHJhdmVyc2UgZG93biB0aGUgc3RhY2sgbG9va2luZyBmb3IgdGhlIG5lYXJlc3QgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgICAgICBmb3IgKHZhciBpID0gaWR4IC0gMTsgaSA+PSAwOyAtLWkpIHtcblxuICAgICAgICAgIHZhciBpc0ludGVyc2VjdGluZyA9IG9iamVjdC5pbnRlcnNlY3RzV2l0aE9iamVjdCh0aGlzLl9vYmplY3RzW2ldKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdCh0aGlzLl9vYmplY3RzW2ldKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29iamVjdHNbaV0uaXNDb250YWluZWRXaXRoaW5PYmplY3Qob2JqZWN0KTtcblxuICAgICAgICAgIGlmIChpc0ludGVyc2VjdGluZykge1xuICAgICAgICAgICAgbmV3SWR4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld0lkeCA9IGlkeCAtIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdJZHg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIG9iamVjdCBvciBhIHNlbGVjdGlvbiB1cCBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnRlcnNlY3RpbmddIElmIGB0cnVlYCwgc2VuZCBvYmplY3QgaW4gZnJvbnQgb2YgbmV4dCB1cHBlciBpbnRlcnNlY3Rpbmcgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBicmluZ0ZvcndhcmQ6IGZ1bmN0aW9uIChvYmplY3QsIGludGVyc2VjdGluZykge1xuICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgYWN0aXZlR3JvdXAgPSB0aGlzLl9hY3RpdmVHcm91cCxcbiAgICAgICAgICBpLCBvYmosIGlkeCwgbmV3SWR4LCBvYmpzO1xuXG4gICAgICBpZiAob2JqZWN0ID09PSBhY3RpdmVHcm91cCkge1xuICAgICAgICBvYmpzID0gYWN0aXZlR3JvdXAuX29iamVjdHM7XG4gICAgICAgIGZvciAoaSA9IG9ianMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgb2JqID0gb2Jqc1tpXTtcbiAgICAgICAgICBpZHggPSB0aGlzLl9vYmplY3RzLmluZGV4T2Yob2JqKTtcbiAgICAgICAgICBpZiAoaWR4ICE9PSB0aGlzLl9vYmplY3RzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIG5ld0lkeCA9IGlkeCArIDE7XG4gICAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqKTtcbiAgICAgICAgICAgIHRoaXMuX29iamVjdHMuc3BsaWNlKG5ld0lkeCwgMCwgb2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZHggPSB0aGlzLl9vYmplY3RzLmluZGV4T2Yob2JqZWN0KTtcbiAgICAgICAgaWYgKGlkeCAhPT0gdGhpcy5fb2JqZWN0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgLy8gaWYgb2JqZWN0IGlzIG5vdCBvbiB0b3Agb2Ygc3RhY2sgKGxhc3QgaXRlbSBpbiBhbiBhcnJheSlcbiAgICAgICAgICBuZXdJZHggPSB0aGlzLl9maW5kTmV3VXBwZXJJbmRleChvYmplY3QsIGlkeCwgaW50ZXJzZWN0aW5nKTtcbiAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqZWN0KTtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzLnNwbGljZShuZXdJZHgsIDAsIG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyQWxsICYmIHRoaXMucmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZE5ld1VwcGVySW5kZXg6IGZ1bmN0aW9uKG9iamVjdCwgaWR4LCBpbnRlcnNlY3RpbmcpIHtcbiAgICAgIHZhciBuZXdJZHg7XG5cbiAgICAgIGlmIChpbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgbmV3SWR4ID0gaWR4O1xuXG4gICAgICAgIC8vIHRyYXZlcnNlIHVwIHRoZSBzdGFjayBsb29raW5nIGZvciB0aGUgbmVhcmVzdCBpbnRlcnNlY3Rpbmcgb2JqZWN0XG4gICAgICAgIGZvciAodmFyIGkgPSBpZHggKyAxOyBpIDwgdGhpcy5fb2JqZWN0cy5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgICAgdmFyIGlzSW50ZXJzZWN0aW5nID0gb2JqZWN0LmludGVyc2VjdHNXaXRoT2JqZWN0KHRoaXMuX29iamVjdHNbaV0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmlzQ29udGFpbmVkV2l0aGluT2JqZWN0KHRoaXMuX29iamVjdHNbaV0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdChvYmplY3QpO1xuXG4gICAgICAgICAgaWYgKGlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICBuZXdJZHggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3SWR4ID0gaWR4ICsgMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld0lkeDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYW4gb2JqZWN0IHRvIHNwZWNpZmllZCBsZXZlbCBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggUG9zaXRpb24gdG8gbW92ZSB0b1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgbW92ZVRvOiBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCkge1xuICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iamVjdCk7XG4gICAgICB0aGlzLl9vYmplY3RzLnNwbGljZShpbmRleCwgMCwgb2JqZWN0KTtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlckFsbCAmJiB0aGlzLnJlbmRlckFsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYSBjYW52YXMgZWxlbWVudCBhbmQgcmVtb3ZlcyBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuQ2FudmFzICgnICsgdGhpcy5jb21wbGV4aXR5KCkgKyAnKTogJyArXG4gICAgICAgICAgICAgICAneyBvYmplY3RzOiAnICsgdGhpcy5nZXRPYmplY3RzKCkubGVuZ3RoICsgJyB9Pic7XG4gICAgfVxuICB9KTtcblxuICBleHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIGZhYnJpYy5PYnNlcnZhYmxlKTtcbiAgZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCBmYWJyaWMuQ29sbGVjdGlvbik7XG4gIGV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSwgZmFicmljLkRhdGFVUkxFeHBvcnRlcik7XG5cbiAgZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcyAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBFTVBUWV9KU09OOiAne1wib2JqZWN0c1wiOiBbXSwgXCJiYWNrZ3JvdW5kXCI6IFwid2hpdGVcIn0nLFxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSB3YXkgdG8gY2hlY2sgc3VwcG9ydCBvZiBzb21lIG9mIHRoZSBjYW52YXMgbWV0aG9kc1xuICAgICAqIChlaXRoZXIgdGhvc2Ugb2YgSFRNTENhbnZhc0VsZW1lbnQgaXRzZWxmLCBvciByZW5kZXJpbmcgY29udGV4dClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2ROYW1lIE1ldGhvZCB0byBjaGVjayBzdXBwb3J0IGZvcjtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb3VsZCBiZSBvbmUgb2YgXCJnZXRJbWFnZURhdGFcIiwgXCJ0b0RhdGFVUkxcIiwgXCJ0b0RhdGFVUkxXaXRoUXVhbGl0eVwiIG9yIFwic2V0TGluZURhc2hcIlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW4gfCBudWxsfSBgdHJ1ZWAgaWYgbWV0aG9kIGlzIHN1cHBvcnRlZCAob3IgYXQgbGVhc3QgZXhpc3RzKSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYG51bGxgIGlmIGNhbnZhcyBlbGVtZW50IG9yIGNvbnRleHQgY2FuIG5vdCBiZSBpbml0aWFsaXplZFxuICAgICAqL1xuICAgIHN1cHBvcnRzOiBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGVsID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuXG4gICAgICBpZiAoIWVsIHx8ICFlbC5nZXRDb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gZWwuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGlmICghY3R4KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKG1ldGhvZE5hbWUpIHtcblxuICAgICAgICBjYXNlICdnZXRJbWFnZURhdGEnOlxuICAgICAgICAgIHJldHVybiB0eXBlb2YgY3R4LmdldEltYWdlRGF0YSAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAgICAgY2FzZSAnc2V0TGluZURhc2gnOlxuICAgICAgICAgIHJldHVybiB0eXBlb2YgY3R4LnNldExpbmVEYXNoICE9PSAndW5kZWZpbmVkJztcblxuICAgICAgICBjYXNlICd0b0RhdGFVUkwnOlxuICAgICAgICAgIHJldHVybiB0eXBlb2YgZWwudG9EYXRhVVJMICE9PSAndW5kZWZpbmVkJztcblxuICAgICAgICBjYXNlICd0b0RhdGFVUkxXaXRoUXVhbGl0eSc6XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVsLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycsIDApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIEpTT04gcmVwcmVzZW50YXRpb24gb2YgY2FudmFzXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAqIEByZXR1cm4ge1N0cmluZ30gSlNPTiBzdHJpbmdcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTMjc2VyaWFsaXphdGlvbn1cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9wZWM4Ni98anNGaWRkbGUgZGVtb31cbiAgICogQGV4YW1wbGUgPGNhcHRpb24+SlNPTiB3aXRob3V0IGFkZGl0aW9uYWwgcHJvcGVydGllczwvY2FwdGlvbj5cbiAgICogdmFyIGpzb24gPSBjYW52YXMudG9KU09OKCk7XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkpTT04gd2l0aCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgaW5jbHVkZWQ8L2NhcHRpb24+XG4gICAqIHZhciBqc29uID0gY2FudmFzLnRvSlNPTihbJ2xvY2tNb3ZlbWVudFgnLCAnbG9ja01vdmVtZW50WScsICdsb2NrUm90YXRpb24nLCAnbG9ja1NjYWxpbmdYJywgJ2xvY2tTY2FsaW5nWScsICdsb2NrVW5pU2NhbGluZyddKTtcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+SlNPTiB3aXRob3V0IGRlZmF1bHQgdmFsdWVzPC9jYXB0aW9uPlxuICAgKiBjYW52YXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBmYWxzZTtcbiAgICogdmFyIGpzb24gPSBjYW52YXMudG9KU09OKCk7XG4gICAqL1xuICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS50b0pTT04gPSBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS50b09iamVjdDtcblxufSkoKTtcblxuXG4vKipcbiAqIEJhc2VCcnVzaCBjbGFzc1xuICogQGNsYXNzIGZhYnJpYy5CYXNlQnJ1c2hcbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZnJlZWRyYXdpbmd8RnJlZWRyYXdpbmcgZGVtb31cbiAqL1xuZmFicmljLkJhc2VCcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKC8qKiBAbGVuZHMgZmFicmljLkJhc2VCcnVzaC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBDb2xvciBvZiBhIGJydXNoXG4gICAqIEB0eXBlIFN0cmluZ1xuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgY29sb3I6ICdyZ2IoMCwgMCwgMCknLFxuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiBhIGJydXNoXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgd2lkdGg6IDEsXG5cbiAgLyoqXG4gICAqIFNoYWRvdyBvYmplY3QgcmVwcmVzZW50aW5nIHNoYWRvdyBvZiB0aGlzIHNoYXBlLlxuICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHJlcGxhY2VzIFwic2hhZG93Q29sb3JcIiAoU3RyaW5nKSwgXCJzaGFkb3dPZmZzZXRYXCIgKE51bWJlciksXG4gICAqIFwic2hhZG93T2Zmc2V0WVwiIChOdW1iZXIpIGFuZCBcInNoYWRvd0JsdXJcIiAoTnVtYmVyKSBzaW5jZSB2MS4yLjEyXG4gICAqIEB0eXBlIGZhYnJpYy5TaGFkb3dcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHNoYWRvdzogbnVsbCxcblxuICAvKipcbiAgICogTGluZSBlbmRpbmdzIHN0eWxlIG9mIGEgYnJ1c2ggKG9uZSBvZiBcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiKVxuICAgKiBAdHlwZSBTdHJpbmdcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHN0cm9rZUxpbmVDYXA6ICdyb3VuZCcsXG5cbiAgLyoqXG4gICAqIENvcm5lciBzdHlsZSBvZiBhIGJydXNoIChvbmUgb2YgXCJiZXZpbFwiLCBcInJvdW5kXCIsIFwibWl0ZXJcIilcbiAgICogQHR5cGUgU3RyaW5nXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBzdHJva2VMaW5lSm9pbjogJ3JvdW5kJyxcblxuICAvKipcbiAgICogU3Ryb2tlIERhc2ggQXJyYXkuXG4gICAqIEB0eXBlIEFycmF5XG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBzdHJva2VEYXNoQXJyYXk6IG51bGwsXG5cbiAgLyoqXG4gICAqIFNldHMgc2hhZG93IG9mIGFuIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdCBvciBzdHJpbmcgKGUuZy4gXCIycHggMnB4IDEwcHggcmdiYSgwLDAsMCwwLjIpXCIpXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgc2V0U2hhZG93OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5zaGFkb3cgPSBuZXcgZmFicmljLlNoYWRvdyhvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBicnVzaCBzdHlsZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRCcnVzaFN0eWxlczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG5cbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGN0eC5saW5lQ2FwID0gdGhpcy5zdHJva2VMaW5lQ2FwO1xuICAgIGN0eC5saW5lSm9pbiA9IHRoaXMuc3Ryb2tlTGluZUpvaW47XG4gICAgaWYgKHRoaXMuc3Ryb2tlRGFzaEFycmF5ICYmIGZhYnJpYy5TdGF0aWNDYW52YXMuc3VwcG9ydHMoJ3NldExpbmVEYXNoJykpIHtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaCh0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGJydXNoIHNoYWRvdyBzdHlsZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRTaGFkb3c6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5zaGFkb3cpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcDtcblxuICAgIGN0eC5zaGFkb3dDb2xvciA9IHRoaXMuc2hhZG93LmNvbG9yO1xuICAgIGN0eC5zaGFkb3dCbHVyID0gdGhpcy5zaGFkb3cuYmx1cjtcbiAgICBjdHguc2hhZG93T2Zmc2V0WCA9IHRoaXMuc2hhZG93Lm9mZnNldFg7XG4gICAgY3R4LnNoYWRvd09mZnNldFkgPSB0aGlzLnNoYWRvdy5vZmZzZXRZO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGJydXNoIHNoYWRvdyBzdHlsZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXNldFNoYWRvdzogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG5cbiAgICBjdHguc2hhZG93Q29sb3IgPSAnJztcbiAgICBjdHguc2hhZG93Qmx1ciA9IGN0eC5zaGFkb3dPZmZzZXRYID0gY3R4LnNoYWRvd09mZnNldFkgPSAwO1xuICB9XG59KTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIFBlbmNpbEJydXNoIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUGVuY2lsQnJ1c2hcbiAgICogQGV4dGVuZHMgZmFicmljLkJhc2VCcnVzaFxuICAgKi9cbiAgZmFicmljLlBlbmNpbEJydXNoID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLkJhc2VCcnVzaCwgLyoqIEBsZW5kcyBmYWJyaWMuUGVuY2lsQnJ1c2gucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtmYWJyaWMuQ2FudmFzfSBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUGVuY2lsQnJ1c2h9IEluc3RhbmNlIG9mIGEgcGVuY2lsIGJydXNoXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIHRoaXMuX3BvaW50cyA9IFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbm92b2tlZCBvbiBtb3VzZSBkb3duXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bjogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgICAgdGhpcy5fcHJlcGFyZUZvckRyYXdpbmcocG9pbnRlcik7XG4gICAgICAvLyBjYXB0dXJlIGNvb3JkaW5hdGVzIGltbWVkaWF0ZWx5XG4gICAgICAvLyB0aGlzIGFsbG93cyB0byBkcmF3IGRvdHMgKHdoZW4gbW92ZW1lbnQgbmV2ZXIgb2NjdXJzKVxuICAgICAgdGhpcy5fY2FwdHVyZURyYXdpbmdQYXRoKHBvaW50ZXIpO1xuICAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElub3Zva2VkIG9uIG1vdXNlIG1vdmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgICAqL1xuICAgIG9uTW91c2VNb3ZlOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgICB0aGlzLl9jYXB0dXJlRHJhd2luZ1BhdGgocG9pbnRlcik7XG4gICAgICAvLyByZWRyYXcgY3VydmVcbiAgICAgIC8vIGNsZWFyIHRvcCBjYW52YXNcbiAgICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICAgIHRoaXMuX3JlbmRlcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIG9uIG1vdXNlIHVwXG4gICAgICovXG4gICAgb25Nb3VzZVVwOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2ZpbmFsaXplQW5kQWRkUGF0aCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyIEFjdHVhbCBtb3VzZSBwb3NpdGlvbiByZWxhdGVkIHRvIHRoZSBjYW52YXMuXG4gICAgICovXG4gICAgX3ByZXBhcmVGb3JEcmF3aW5nOiBmdW5jdGlvbihwb2ludGVyKSB7XG5cbiAgICAgIHZhciBwID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSk7XG5cbiAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICB0aGlzLl9hZGRQb2ludChwKTtcblxuICAgICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5tb3ZlVG8ocC54LCBwLnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBQb2ludCB0byBiZSBhZGRlZCB0byBwb2ludHMgYXJyYXlcbiAgICAgKi9cbiAgICBfYWRkUG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICB0aGlzLl9wb2ludHMucHVzaChwb2ludCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFyIHBvaW50cyBhcnJheSBhbmQgc2V0IGNvbnRleHRUb3AgY2FudmFzIHN0eWxlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3BvaW50cy5sZW5ndGggPSAwO1xuXG4gICAgICB0aGlzLl9zZXRCcnVzaFN0eWxlcygpO1xuICAgICAgdGhpcy5fc2V0U2hhZG93KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXIgQWN0dWFsIG1vdXNlIHBvc2l0aW9uIHJlbGF0ZWQgdG8gdGhlIGNhbnZhcy5cbiAgICAgKi9cbiAgICBfY2FwdHVyZURyYXdpbmdQYXRoOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgICB2YXIgcG9pbnRlclBvaW50ID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSk7XG4gICAgICB0aGlzLl9hZGRQb2ludChwb2ludGVyUG9pbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgc21vb3RoIHBhdGggb24gdGhlIHRvcENhbnZhcyB1c2luZyBxdWFkcmF0aWNDdXJ2ZVRvXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdHggID0gdGhpcy5jYW52YXMuY29udGV4dFRvcCxcbiAgICAgICAgICB2ID0gdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm0sXG4gICAgICAgICAgcDEgPSB0aGlzLl9wb2ludHNbMF0sXG4gICAgICAgICAgcDIgPSB0aGlzLl9wb2ludHNbMV07XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNmb3JtKHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAvL2lmIHdlIG9ubHkgaGF2ZSAyIHBvaW50cyBpbiB0aGUgcGF0aCBhbmQgdGhleSBhcmUgdGhlIHNhbWVcbiAgICAgIC8vaXQgbWVhbnMgdGhhdCB0aGUgdXNlciBvbmx5IGNsaWNrZWQgdGhlIGNhbnZhcyB3aXRob3V0IG1vdmluZyB0aGUgbW91c2VcbiAgICAgIC8vdGhlbiB3ZSBzaG91bGQgYmUgZHJhd2luZyBhIGRvdC4gQSBwYXRoIGlzbid0IGRyYXduIGJldHdlZW4gdHdvIGlkZW50aWNhbCBkb3RzXG4gICAgICAvL3RoYXQncyB3aHkgd2Ugc2V0IHRoZW0gYXBhcnQgYSBiaXRcbiAgICAgIGlmICh0aGlzLl9wb2ludHMubGVuZ3RoID09PSAyICYmIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueSkge1xuICAgICAgICBwMS54IC09IDAuNTtcbiAgICAgICAgcDIueCArPSAwLjU7XG4gICAgICB9XG4gICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gdGhpcy5fcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIHdlIHBpY2sgdGhlIHBvaW50IGJldHdlZW4gcGkgKyAxICYgcGkgKyAyIGFzIHRoZVxuICAgICAgICAvLyBlbmQgcG9pbnQgYW5kIHAxIGFzIG91ciBjb250cm9sIHBvaW50LlxuICAgICAgICB2YXIgbWlkUG9pbnQgPSBwMS5taWRQb2ludEZyb20ocDIpO1xuICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhwMS54LCBwMS55LCBtaWRQb2ludC54LCBtaWRQb2ludC55KTtcblxuICAgICAgICBwMSA9IHRoaXMuX3BvaW50c1tpXTtcbiAgICAgICAgcDIgPSB0aGlzLl9wb2ludHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gRHJhdyBsYXN0IGxpbmUgYXMgYSBzdHJhaWdodCBsaW5lIHdoaWxlXG4gICAgICAvLyB3ZSB3YWl0IGZvciB0aGUgbmV4dCBwb2ludCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZVxuICAgICAgLy8gdGhlIGJlemllciBjb250cm9sIHBvaW50XG4gICAgICBjdHgubGluZVRvKHAxLngsIHAxLnkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgcG9pbnRzIHRvIFNWRyBwYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIEFycmF5IG9mIHBvaW50c1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU1ZHIHBhdGhcbiAgICAgKi9cbiAgICBjb252ZXJ0UG9pbnRzVG9TVkdQYXRoOiBmdW5jdGlvbihwb2ludHMpIHtcbiAgICAgIHZhciBwYXRoID0gW10sXG4gICAgICAgICAgcDEgPSBuZXcgZmFicmljLlBvaW50KHBvaW50c1swXS54LCBwb2ludHNbMF0ueSksXG4gICAgICAgICAgcDIgPSBuZXcgZmFicmljLlBvaW50KHBvaW50c1sxXS54LCBwb2ludHNbMV0ueSk7XG5cbiAgICAgIHBhdGgucHVzaCgnTSAnLCBwb2ludHNbMF0ueCwgJyAnLCBwb2ludHNbMF0ueSwgJyAnKTtcbiAgICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIG1pZFBvaW50ID0gcDEubWlkUG9pbnRGcm9tKHAyKTtcbiAgICAgICAgLy8gcDEgaXMgb3VyIGJlemllciBjb250cm9sIHBvaW50XG4gICAgICAgIC8vIG1pZHBvaW50IGlzIG91ciBlbmRwb2ludFxuICAgICAgICAvLyBzdGFydCBwb2ludCBpcyBwKGktMSkgdmFsdWUuXG4gICAgICAgIHBhdGgucHVzaCgnUSAnLCBwMS54LCAnICcsIHAxLnksICcgJywgbWlkUG9pbnQueCwgJyAnLCBtaWRQb2ludC55LCAnICcpO1xuICAgICAgICBwMSA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRzW2ldLngsIHBvaW50c1tpXS55KTtcbiAgICAgICAgaWYgKChpICsgMSkgPCBwb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgcDIgPSBuZXcgZmFicmljLlBvaW50KHBvaW50c1tpICsgMV0ueCwgcG9pbnRzW2kgKyAxXS55KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGF0aC5wdXNoKCdMICcsIHAxLngsICcgJywgcDEueSwgJyAnKTtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGZhYnJpYy5QYXRoIG9iamVjdCB0byBhZGQgb24gY2FudmFzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhEYXRhIFBhdGggZGF0YVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5QYXRofSBQYXRoIHRvIGFkZCBvbiBjYW52YXNcbiAgICAgKi9cbiAgICBjcmVhdGVQYXRoOiBmdW5jdGlvbihwYXRoRGF0YSkge1xuICAgICAgdmFyIHBhdGggPSBuZXcgZmFicmljLlBhdGgocGF0aERhdGEsIHtcbiAgICAgICAgZmlsbDogbnVsbCxcbiAgICAgICAgc3Ryb2tlOiB0aGlzLmNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgc3Ryb2tlTGluZUNhcDogdGhpcy5zdHJva2VMaW5lQ2FwLFxuICAgICAgICBzdHJva2VMaW5lSm9pbjogdGhpcy5zdHJva2VMaW5lSm9pbixcbiAgICAgICAgc3Ryb2tlRGFzaEFycmF5OiB0aGlzLnN0cm9rZURhc2hBcnJheSxcbiAgICAgICAgb3JpZ2luWDogJ2NlbnRlcicsXG4gICAgICAgIG9yaWdpblk6ICdjZW50ZXInXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuc2hhZG93KSB7XG4gICAgICAgIHRoaXMuc2hhZG93LmFmZmVjdFN0cm9rZSA9IHRydWU7XG4gICAgICAgIHBhdGguc2V0U2hhZG93KHRoaXMuc2hhZG93KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNldXAgYWZ0ZXIgZHJhd2luZyB0aGUgcGF0aCBvbiBjb250ZXh0VG9wIGNhbnZhc1xuICAgICAqIHdlIHVzZSB0aGUgcG9pbnRzIGNhcHR1cmVkIHRvIGNyZWF0ZSBhbiBuZXcgZmFicmljIHBhdGggb2JqZWN0XG4gICAgICogYW5kIGFkZCBpdCB0byB0aGUgZmFicmljIGNhbnZhcy5cbiAgICAgKi9cbiAgICBfZmluYWxpemVBbmRBZGRQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICB2YXIgcGF0aERhdGEgPSB0aGlzLmNvbnZlcnRQb2ludHNUb1NWR1BhdGgodGhpcy5fcG9pbnRzKS5qb2luKCcnKTtcbiAgICAgIGlmIChwYXRoRGF0YSA9PT0gJ00gMCAwIFEgMCAwIDAgMCBMIDAgMCcpIHtcbiAgICAgICAgLy8gZG8gbm90IGNyZWF0ZSAwIHdpZHRoL2hlaWdodCBwYXRocywgYXMgdGhleSBhcmVcbiAgICAgICAgLy8gcmVuZGVyZWQgaW5jb25zaXN0ZW50bHkgYWNyb3NzIGJyb3dzZXJzXG4gICAgICAgIC8vIEZpcmVmb3ggNCwgZm9yIGV4YW1wbGUsIHJlbmRlcnMgYSBkb3QsXG4gICAgICAgIC8vIHdoZXJlYXMgQ2hyb21lIDEwIHJlbmRlcnMgbm90aGluZ1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGF0aCA9IHRoaXMuY3JlYXRlUGF0aChwYXRoRGF0YSk7XG5cbiAgICAgIHRoaXMuY2FudmFzLmFkZChwYXRoKTtcbiAgICAgIHBhdGguc2V0Q29vcmRzKCk7XG5cbiAgICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICAgIHRoaXMuX3Jlc2V0U2hhZG93KCk7XG4gICAgICB0aGlzLmNhbnZhcy5yZW5kZXJBbGwoKTtcblxuICAgICAgLy8gZmlyZSBldmVudCAncGF0aCcgY3JlYXRlZFxuICAgICAgdGhpcy5jYW52YXMuZmlyZSgncGF0aDpjcmVhdGVkJywgeyBwYXRoOiBwYXRoIH0pO1xuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbi8qKlxuICogQ2lyY2xlQnJ1c2ggY2xhc3NcbiAqIEBjbGFzcyBmYWJyaWMuQ2lyY2xlQnJ1c2hcbiAqL1xuZmFicmljLkNpcmNsZUJydXNoID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLkJhc2VCcnVzaCwgLyoqIEBsZW5kcyBmYWJyaWMuQ2lyY2xlQnJ1c2gucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogV2lkdGggb2YgYSBicnVzaFxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHdpZHRoOiAxMCxcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtmYWJyaWMuQ2FudmFzfSBjYW52YXNcbiAgICogQHJldHVybiB7ZmFicmljLkNpcmNsZUJydXNofSBJbnN0YW5jZSBvZiBhIGNpcmNsZSBicnVzaFxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBpbnNpZGUgb24gbW91c2UgZG93biBhbmQgbW91c2UgbW92ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKi9cbiAgZHJhd0RvdDogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHZhciBwb2ludCA9IHRoaXMuYWRkUG9pbnQocG9pbnRlciksXG4gICAgICAgIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3AsXG4gICAgICAgIHYgPSB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG5cbiAgICBjdHguZmlsbFN0eWxlID0gcG9pbnQuZmlsbDtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyhwb2ludC54LCBwb2ludC55LCBwb2ludC5yYWRpdXMsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsKCk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIGRvd25cbiAgICovXG4gIG9uTW91c2VEb3duOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdGhpcy5wb2ludHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgdGhpcy5fc2V0U2hhZG93KCk7XG4gICAgdGhpcy5kcmF3RG90KHBvaW50ZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIG1vdmVcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICovXG4gIG9uTW91c2VNb3ZlOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdGhpcy5kcmF3RG90KHBvaW50ZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIHVwXG4gICAqL1xuICBvbk1vdXNlVXA6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcmlnaW5hbFJlbmRlck9uQWRkUmVtb3ZlID0gdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmU7XG4gICAgdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmUgPSBmYWxzZTtcblxuICAgIHZhciBjaXJjbGVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBwb2ludCA9IHRoaXMucG9pbnRzW2ldLFxuICAgICAgICAgIGNpcmNsZSA9IG5ldyBmYWJyaWMuQ2lyY2xlKHtcbiAgICAgICAgICAgIHJhZGl1czogcG9pbnQucmFkaXVzLFxuICAgICAgICAgICAgbGVmdDogcG9pbnQueCxcbiAgICAgICAgICAgIHRvcDogcG9pbnQueSxcbiAgICAgICAgICAgIG9yaWdpblg6ICdjZW50ZXInLFxuICAgICAgICAgICAgb3JpZ2luWTogJ2NlbnRlcicsXG4gICAgICAgICAgICBmaWxsOiBwb2ludC5maWxsXG4gICAgICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc2hhZG93ICYmIGNpcmNsZS5zZXRTaGFkb3codGhpcy5zaGFkb3cpO1xuXG4gICAgICBjaXJjbGVzLnB1c2goY2lyY2xlKTtcbiAgICB9XG4gICAgdmFyIGdyb3VwID0gbmV3IGZhYnJpYy5Hcm91cChjaXJjbGVzLCB7IG9yaWdpblg6ICdjZW50ZXInLCBvcmlnaW5ZOiAnY2VudGVyJyB9KTtcbiAgICBncm91cC5jYW52YXMgPSB0aGlzLmNhbnZhcztcblxuICAgIHRoaXMuY2FudmFzLmFkZChncm91cCk7XG4gICAgdGhpcy5jYW52YXMuZmlyZSgncGF0aDpjcmVhdGVkJywgeyBwYXRoOiBncm91cCB9KTtcblxuICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICB0aGlzLl9yZXNldFNoYWRvdygpO1xuICAgIHRoaXMuY2FudmFzLnJlbmRlck9uQWRkUmVtb3ZlID0gb3JpZ2luYWxSZW5kZXJPbkFkZFJlbW92ZTtcbiAgICB0aGlzLmNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSBKdXN0IGFkZGVkIHBvaW50ZXIgcG9pbnRcbiAgICovXG4gIGFkZFBvaW50OiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdmFyIHBvaW50ZXJQb2ludCA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRlci54LCBwb2ludGVyLnkpLFxuXG4gICAgICAgIGNpcmNsZVJhZGl1cyA9IGZhYnJpYy51dGlsLmdldFJhbmRvbUludChcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KDAsIHRoaXMud2lkdGggLSAyMCksIHRoaXMud2lkdGggKyAyMCkgLyAyLFxuXG4gICAgICAgIGNpcmNsZUNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldEFscGhhKGZhYnJpYy51dGlsLmdldFJhbmRvbUludCgwLCAxMDApIC8gMTAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvUmdiYSgpO1xuXG4gICAgcG9pbnRlclBvaW50LnJhZGl1cyA9IGNpcmNsZVJhZGl1cztcbiAgICBwb2ludGVyUG9pbnQuZmlsbCA9IGNpcmNsZUNvbG9yO1xuXG4gICAgdGhpcy5wb2ludHMucHVzaChwb2ludGVyUG9pbnQpO1xuXG4gICAgcmV0dXJuIHBvaW50ZXJQb2ludDtcbiAgfVxufSk7XG5cblxuLyoqXG4gKiBTcHJheUJydXNoIGNsYXNzXG4gKiBAY2xhc3MgZmFicmljLlNwcmF5QnJ1c2hcbiAqL1xuZmFicmljLlNwcmF5QnJ1c2ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyggZmFicmljLkJhc2VCcnVzaCwgLyoqIEBsZW5kcyBmYWJyaWMuU3ByYXlCcnVzaC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiBhIHNwcmF5XG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgd2lkdGg6ICAgICAgICAgICAgICAxMCxcblxuICAvKipcbiAgICogRGVuc2l0eSBvZiBhIHNwcmF5IChudW1iZXIgb2YgZG90cyBwZXIgY2h1bmspXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgZGVuc2l0eTogICAgICAgICAgICAyMCxcblxuICAvKipcbiAgICogV2lkdGggb2Ygc3ByYXkgZG90c1xuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIGRvdFdpZHRoOiAgICAgICAgICAgMSxcblxuICAvKipcbiAgICogV2lkdGggdmFyaWFuY2Ugb2Ygc3ByYXkgZG90c1xuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIGRvdFdpZHRoVmFyaWFuY2U6ICAgMSxcblxuICAvKipcbiAgICogV2hldGhlciBvcGFjaXR5IG9mIGEgZG90IHNob3VsZCBiZSByYW5kb21cbiAgICogQHR5cGUgQm9vbGVhblxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgcmFuZG9tT3BhY2l0eTogICAgICAgIGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG92ZXJsYXBwaW5nIGRvdHMgKHJlY3RhbmdsZXMpIHNob3VsZCBiZSByZW1vdmVkIChmb3IgcGVyZm9ybWFuY2UgcmVhc29ucylcbiAgICogQHR5cGUgQm9vbGVhblxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgb3B0aW1pemVPdmVybGFwcGluZzogIHRydWUsXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7ZmFicmljLkNhbnZhc30gY2FudmFzXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5TcHJheUJydXNofSBJbnN0YW5jZSBvZiBhIHNwcmF5IGJydXNoXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLnNwcmF5Q2h1bmtzID0gW107XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb24gbW91c2UgZG93blxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKi9cbiAgb25Nb3VzZURvd246IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB0aGlzLnNwcmF5Q2h1bmtzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jYW52YXMuY2xlYXJDb250ZXh0KHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgIHRoaXMuX3NldFNoYWRvdygpO1xuXG4gICAgdGhpcy5hZGRTcHJheUNodW5rKHBvaW50ZXIpO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb24gbW91c2UgbW92ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKi9cbiAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB0aGlzLmFkZFNwcmF5Q2h1bmsocG9pbnRlcik7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBvbiBtb3VzZSB1cFxuICAgKi9cbiAgb25Nb3VzZVVwOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3JpZ2luYWxSZW5kZXJPbkFkZFJlbW92ZSA9IHRoaXMuY2FudmFzLnJlbmRlck9uQWRkUmVtb3ZlO1xuICAgIHRoaXMuY2FudmFzLnJlbmRlck9uQWRkUmVtb3ZlID0gZmFsc2U7XG5cbiAgICB2YXIgcmVjdHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBpbGVuID0gdGhpcy5zcHJheUNodW5rcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHZhciBzcHJheUNodW5rID0gdGhpcy5zcHJheUNodW5rc1tpXTtcblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBzcHJheUNodW5rLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuXG4gICAgICAgIHZhciByZWN0ID0gbmV3IGZhYnJpYy5SZWN0KHtcbiAgICAgICAgICB3aWR0aDogc3ByYXlDaHVua1tqXS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHNwcmF5Q2h1bmtbal0ud2lkdGgsXG4gICAgICAgICAgbGVmdDogc3ByYXlDaHVua1tqXS54ICsgMSxcbiAgICAgICAgICB0b3A6IHNwcmF5Q2h1bmtbal0ueSArIDEsXG4gICAgICAgICAgb3JpZ2luWDogJ2NlbnRlcicsXG4gICAgICAgICAgb3JpZ2luWTogJ2NlbnRlcicsXG4gICAgICAgICAgZmlsbDogdGhpcy5jb2xvclxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnNoYWRvdyAmJiByZWN0LnNldFNoYWRvdyh0aGlzLnNoYWRvdyk7XG4gICAgICAgIHJlY3RzLnB1c2gocmVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW1pemVPdmVybGFwcGluZykge1xuICAgICAgcmVjdHMgPSB0aGlzLl9nZXRPcHRpbWl6ZWRSZWN0cyhyZWN0cyk7XG4gICAgfVxuXG4gICAgdmFyIGdyb3VwID0gbmV3IGZhYnJpYy5Hcm91cChyZWN0cywgeyBvcmlnaW5YOiAnY2VudGVyJywgb3JpZ2luWTogJ2NlbnRlcicgfSk7XG4gICAgZ3JvdXAuY2FudmFzID0gdGhpcy5jYW52YXM7XG5cbiAgICB0aGlzLmNhbnZhcy5hZGQoZ3JvdXApO1xuICAgIHRoaXMuY2FudmFzLmZpcmUoJ3BhdGg6Y3JlYXRlZCcsIHsgcGF0aDogZ3JvdXAgfSk7XG5cbiAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgdGhpcy5fcmVzZXRTaGFkb3coKTtcbiAgICB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZSA9IG9yaWdpbmFsUmVuZGVyT25BZGRSZW1vdmU7XG4gICAgdGhpcy5jYW52YXMucmVuZGVyQWxsKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJlY3RzXG4gICAqL1xuICBfZ2V0T3B0aW1pemVkUmVjdHM6IGZ1bmN0aW9uKHJlY3RzKSB7XG5cbiAgICAvLyBhdm9pZCBjcmVhdGluZyBkdXBsaWNhdGUgcmVjdHMgYXQgdGhlIHNhbWUgY29vcmRpbmF0ZXNcbiAgICB2YXIgdW5pcXVlUmVjdHMgPSB7IH0sIGtleTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAga2V5ID0gcmVjdHNbaV0ubGVmdCArICcnICsgcmVjdHNbaV0udG9wO1xuICAgICAgaWYgKCF1bmlxdWVSZWN0c1trZXldKSB7XG4gICAgICAgIHVuaXF1ZVJlY3RzW2tleV0gPSByZWN0c1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHVuaXF1ZVJlY3RzQXJyYXkgPSBbXTtcbiAgICBmb3IgKGtleSBpbiB1bmlxdWVSZWN0cykge1xuICAgICAgdW5pcXVlUmVjdHNBcnJheS5wdXNoKHVuaXF1ZVJlY3RzW2tleV0pO1xuICAgIH1cblxuICAgIHJldHVybiB1bmlxdWVSZWN0c0FycmF5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGJydXNoXG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yO1xuXG4gICAgdmFyIHYgPSB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5zcHJheUNodW5rUG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcG9pbnQgPSB0aGlzLnNwcmF5Q2h1bmtQb2ludHNbaV07XG4gICAgICBpZiAodHlwZW9mIHBvaW50Lm9wYWNpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHBvaW50Lm9wYWNpdHk7XG4gICAgICB9XG4gICAgICBjdHguZmlsbFJlY3QocG9pbnQueCwgcG9pbnQueSwgcG9pbnQud2lkdGgsIHBvaW50LndpZHRoKTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICovXG4gIGFkZFNwcmF5Q2h1bms6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB0aGlzLnNwcmF5Q2h1bmtQb2ludHMgPSBbXTtcblxuICAgIHZhciB4LCB5LCB3aWR0aCwgcmFkaXVzID0gdGhpcy53aWR0aCAvIDI7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGVuc2l0eTsgaSsrKSB7XG5cbiAgICAgIHggPSBmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQocG9pbnRlci54IC0gcmFkaXVzLCBwb2ludGVyLnggKyByYWRpdXMpO1xuICAgICAgeSA9IGZhYnJpYy51dGlsLmdldFJhbmRvbUludChwb2ludGVyLnkgLSByYWRpdXMsIHBvaW50ZXIueSArIHJhZGl1cyk7XG5cbiAgICAgIGlmICh0aGlzLmRvdFdpZHRoVmFyaWFuY2UpIHtcbiAgICAgICAgd2lkdGggPSBmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQoXG4gICAgICAgICAgLy8gYm90dG9tIGNsYW1wIHdpZHRoIHRvIDFcbiAgICAgICAgICBNYXRoLm1heCgxLCB0aGlzLmRvdFdpZHRoIC0gdGhpcy5kb3RXaWR0aFZhcmlhbmNlKSxcbiAgICAgICAgICB0aGlzLmRvdFdpZHRoICsgdGhpcy5kb3RXaWR0aFZhcmlhbmNlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB3aWR0aCA9IHRoaXMuZG90V2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludCA9IG5ldyBmYWJyaWMuUG9pbnQoeCwgeSk7XG4gICAgICBwb2ludC53aWR0aCA9IHdpZHRoO1xuXG4gICAgICBpZiAodGhpcy5yYW5kb21PcGFjaXR5KSB7XG4gICAgICAgIHBvaW50Lm9wYWNpdHkgPSBmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQoMCwgMTAwKSAvIDEwMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zcHJheUNodW5rUG9pbnRzLnB1c2gocG9pbnQpO1xuICAgIH1cblxuICAgIHRoaXMuc3ByYXlDaHVua3MucHVzaCh0aGlzLnNwcmF5Q2h1bmtQb2ludHMpO1xuICB9XG59KTtcblxuXG4vKipcbiAqIFBhdHRlcm5CcnVzaCBjbGFzc1xuICogQGNsYXNzIGZhYnJpYy5QYXR0ZXJuQnJ1c2hcbiAqIEBleHRlbmRzIGZhYnJpYy5CYXNlQnJ1c2hcbiAqL1xuZmFicmljLlBhdHRlcm5CcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5QZW5jaWxCcnVzaCwgLyoqIEBsZW5kcyBmYWJyaWMuUGF0dGVybkJydXNoLnByb3RvdHlwZSAqLyB7XG5cbiAgZ2V0UGF0dGVyblNyYzogZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZG90V2lkdGggPSAyMCxcbiAgICAgICAgZG90RGlzdGFuY2UgPSA1LFxuICAgICAgICBwYXR0ZXJuQ2FudmFzID0gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLFxuICAgICAgICBwYXR0ZXJuQ3R4ID0gcGF0dGVybkNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgcGF0dGVybkNhbnZhcy53aWR0aCA9IHBhdHRlcm5DYW52YXMuaGVpZ2h0ID0gZG90V2lkdGggKyBkb3REaXN0YW5jZTtcblxuICAgIHBhdHRlcm5DdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICBwYXR0ZXJuQ3R4LmJlZ2luUGF0aCgpO1xuICAgIHBhdHRlcm5DdHguYXJjKGRvdFdpZHRoIC8gMiwgZG90V2lkdGggLyAyLCBkb3RXaWR0aCAvIDIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgcGF0dGVybkN0eC5jbG9zZVBhdGgoKTtcbiAgICBwYXR0ZXJuQ3R4LmZpbGwoKTtcblxuICAgIHJldHVybiBwYXR0ZXJuQ2FudmFzO1xuICB9LFxuXG4gIGdldFBhdHRlcm5TcmNGdW5jdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFN0cmluZyh0aGlzLmdldFBhdHRlcm5TcmMpLnJlcGxhY2UoJ3RoaXMuY29sb3InLCAnXCInICsgdGhpcy5jb2xvciArICdcIicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFwicGF0dGVyblwiIGluc3RhbmNlIHByb3BlcnR5XG4gICAqL1xuICBnZXRQYXR0ZXJuOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXMuY29udGV4dFRvcC5jcmVhdGVQYXR0ZXJuKHRoaXMuc291cmNlIHx8IHRoaXMuZ2V0UGF0dGVyblNyYygpLCAncmVwZWF0Jyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYnJ1c2ggc3R5bGVzXG4gICAqL1xuICBfc2V0QnJ1c2hTdHlsZXM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0QnJ1c2hTdHlsZXMnKTtcbiAgICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLnN0cm9rZVN0eWxlID0gdGhpcy5nZXRQYXR0ZXJuKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgcGF0aFxuICAgKi9cbiAgY3JlYXRlUGF0aDogZnVuY3Rpb24ocGF0aERhdGEpIHtcbiAgICB2YXIgcGF0aCA9IHRoaXMuY2FsbFN1cGVyKCdjcmVhdGVQYXRoJywgcGF0aERhdGEpLFxuICAgICAgICB0b3BMZWZ0ID0gcGF0aC5fZ2V0TGVmdFRvcENvb3JkcygpLnNjYWxhckFkZChwYXRoLnN0cm9rZVdpZHRoIC8gMik7XG5cbiAgICBwYXRoLnN0cm9rZSA9IG5ldyBmYWJyaWMuUGF0dGVybih7XG4gICAgICBzb3VyY2U6IHRoaXMuc291cmNlIHx8IHRoaXMuZ2V0UGF0dGVyblNyY0Z1bmN0aW9uKCksXG4gICAgICBvZmZzZXRYOiAtdG9wTGVmdC54LFxuICAgICAgb2Zmc2V0WTogLXRvcExlZnQueVxuICAgIH0pO1xuICAgIHJldHVybiBwYXRoO1xuICB9XG59KTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGdldFBvaW50ZXIgPSBmYWJyaWMudXRpbC5nZXRQb2ludGVyLFxuICAgICAgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgICByYWRpYW5zVG9EZWdyZWVzID0gZmFicmljLnV0aWwucmFkaWFuc1RvRGVncmVlcyxcbiAgICAgIGF0YW4yID0gTWF0aC5hdGFuMixcbiAgICAgIGFicyA9IE1hdGguYWJzLFxuICAgICAgc3VwcG9ydExpbmVEYXNoID0gZmFicmljLlN0YXRpY0NhbnZhcy5zdXBwb3J0cygnc2V0TGluZURhc2gnKSxcblxuICAgICAgU1RST0tFX09GRlNFVCA9IDAuNTtcblxuICAvKipcbiAgICogQ2FudmFzIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuQ2FudmFzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXNcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTEjY2FudmFzfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuQ2FudmFzI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqXG4gICAqIEBmaXJlcyBvYmplY3Q6YWRkZWRcbiAgICogQGZpcmVzIG9iamVjdDptb2RpZmllZFxuICAgKiBAZmlyZXMgb2JqZWN0OnJvdGF0aW5nXG4gICAqIEBmaXJlcyBvYmplY3Q6c2NhbGluZ1xuICAgKiBAZmlyZXMgb2JqZWN0Om1vdmluZ1xuICAgKiBAZmlyZXMgb2JqZWN0OnNlbGVjdGVkXG4gICAqXG4gICAqIEBmaXJlcyBiZWZvcmU6c2VsZWN0aW9uOmNsZWFyZWRcbiAgICogQGZpcmVzIHNlbGVjdGlvbjpjbGVhcmVkXG4gICAqIEBmaXJlcyBzZWxlY3Rpb246Y3JlYXRlZFxuICAgKlxuICAgKiBAZmlyZXMgcGF0aDpjcmVhdGVkXG4gICAqIEBmaXJlcyBtb3VzZTpkb3duXG4gICAqIEBmaXJlcyBtb3VzZTptb3ZlXG4gICAqIEBmaXJlcyBtb3VzZTp1cFxuICAgKiBAZmlyZXMgbW91c2U6b3ZlclxuICAgKiBAZmlyZXMgbW91c2U6b3V0XG4gICAqXG4gICAqL1xuICBmYWJyaWMuQ2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLlN0YXRpY0NhbnZhcywgLyoqIEBsZW5kcyBmYWJyaWMuQ2FudmFzLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBTdHJpbmd9IGVsICZsdDtjYW52YXM+IGVsZW1lbnQgdG8gaW5pdGlhbGl6ZSBpbnN0YW5jZSBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHRoaXMuX2luaXRTdGF0aWMoZWwsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5faW5pdEludGVyYWN0aXZlKCk7XG4gICAgICB0aGlzLl9jcmVhdGVDYWNoZUNhbnZhcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdHMgY2FuIGJlIHRyYW5zZm9ybWVkIGJ5IG9uZSBzaWRlICh1bnByb3BvcnRpb25hbGx5KVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHVuaVNjYWxlVHJhbnNmb3JtOiAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoaWNoIGtleSBlbmFibGUgdW5wcm9wb3J0aW9uYWwgc2NhbGluZ1xuICAgICAqIHZhbHVlczogYWx0S2V5LCBzaGlmdEtleSwgY3RybEtleVxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdW5pU2NhbGVLZXk6ICAgICAgICAgICAnc2hpZnRLZXknLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBvYmplY3RzIHVzZSBjZW50ZXIgcG9pbnQgYXMgdGhlIG9yaWdpbiBvZiBzY2FsZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHJlcGxhY2VzIFwiY2VudGVyVHJhbnNmb3JtXCIgKEJvb2xlYW4pLlxuICAgICAqIEBzaW5jZSAxLjMuNFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNlbnRlcmVkU2NhbGluZzogICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBvYmplY3RzIHVzZSBjZW50ZXIgcG9pbnQgYXMgdGhlIG9yaWdpbiBvZiByb3RhdGUgdHJhbnNmb3JtYXRpb24uXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSByZXBsYWNlcyBcImNlbnRlclRyYW5zZm9ybVwiIChCb29sZWFuKS5cbiAgICAgKiBAc2luY2UgMS4zLjRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjZW50ZXJlZFJvdGF0aW9uOiAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGljaCBrZXkgZW5hYmxlIGNlbnRlcmVkIFRyYW5zZnJvbVxuICAgICAqIHZhbHVlczogYWx0S2V5LCBzaGlmdEtleSwgY3RybEtleVxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2VudGVyZWRLZXk6ICAgICAgICAgICAnYWx0S2V5JyxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGljaCBrZXkgZW5hYmxlIGFsdGVybmF0ZSBhY3Rpb24gb24gY29ybmVyXG4gICAgICogdmFsdWVzOiBhbHRLZXksIHNoaWZ0S2V5LCBjdHJsS2V5XG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBhbHRBY3Rpb25LZXk6ICAgICAgICAgICAnc2hpZnRLZXknLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgY2FudmFzIGlzIGludGVyYWN0aXZlLiBUaGlzIHByb3BlcnR5IHNob3VsZCBub3QgYmUgY2hhbmdlZC5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbnRlcmFjdGl2ZTogICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgZ3JvdXAgc2VsZWN0aW9uIHNob3VsZCBiZSBlbmFibGVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uOiAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGljaCBrZXkgZW5hYmxlIG11bHRpcGxlIGNsaWNrIHNlbGVjdGlvblxuICAgICAqIHZhbHVlczogYWx0S2V5LCBzaGlmdEtleSwgY3RybEtleSwgY21kS2V5XG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25LZXk6ICAgICAgICAgICAnc2hpZnRLZXknLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoaWNoIGtleSBlbmFibGUgYWx0ZXJuYXRpdmUgc2VsZWN0aW9uXG4gICAgICogaW4gY2FzZSBvZiB0YXJnZXQgb3ZlcmxhcHBpbmcgd2l0aCBhY3RpdmUgb2JqZWN0XG4gICAgICogdmFsdWVzOiBhbHRLZXksIHNoaWZ0S2V5LCBjdHJsS2V5LCBjbWRLZXlcbiAgICAgKiBAc2luY2UgMS42LjVcbiAgICAgKiBAdHlwZSBudWxsfFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYWx0U2VsZWN0aW9uS2V5OiAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIHNlbGVjdGlvblxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uQ29sb3I6ICAgICAgICAgJ3JnYmEoMTAwLCAxMDAsIDI1NSwgMC4zKScsIC8vIGJsdWVcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgZGFzaCBhcnJheSBwYXR0ZXJuXG4gICAgICogSWYgbm90IGVtcHR5IHRoZSBzZWxlY3Rpb24gYm9yZGVyIGlzIGRhc2hlZFxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc2VsZWN0aW9uRGFzaEFycmF5OiAgICAgW10sXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiB0aGUgYm9yZGVyIG9mIHNlbGVjdGlvbiAodXN1YWxseSBzbGlnaHRseSBkYXJrZXIgdGhhbiBjb2xvciBvZiBzZWxlY3Rpb24gaXRzZWxmKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uQm9yZGVyQ29sb3I6ICAgJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKScsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBhIGxpbmUgdXNlZCBpbiBvYmplY3QvZ3JvdXAgc2VsZWN0aW9uXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25MaW5lV2lkdGg6ICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCB3aGVuIGhvdmVyaW5nIG92ZXIgYW4gb2JqZWN0IG9uIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaG92ZXJDdXJzb3I6ICAgICAgICAgICAgJ21vdmUnLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCB3aGVuIG1vdmluZyBhbiBvYmplY3Qgb24gY2FudmFzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtb3ZlQ3Vyc29yOiAgICAgICAgICAgICAnbW92ZScsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGN1cnNvciB2YWx1ZSB1c2VkIGZvciB0aGUgZW50aXJlIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZGVmYXVsdEN1cnNvcjogICAgICAgICAgJ2RlZmF1bHQnLFxuXG4gICAgLyoqXG4gICAgICogQ3Vyc29yIHZhbHVlIHVzZWQgZHVyaW5nIGZyZWUgZHJhd2luZ1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZnJlZURyYXdpbmdDdXJzb3I6ICAgICAgJ2Nyb3NzaGFpcicsXG5cbiAgICAvKipcbiAgICAgKiBDdXJzb3IgdmFsdWUgdXNlZCBmb3Igcm90YXRpb24gcG9pbnRcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJvdGF0aW9uQ3Vyc29yOiAgICAgICAgICdjcm9zc2hhaXInLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBlbGVtZW50IGNsYXNzIHRoYXQncyBnaXZlbiB0byB3cmFwcGVyIChkaXYpIGVsZW1lbnQgb2YgY2FudmFzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb250YWluZXJDbGFzczogICAgICAgICAnY2FudmFzLWNvbnRhaW5lcicsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdCBkZXRlY3Rpb24gaGFwcGVucyBvbiBwZXItcGl4ZWwgYmFzaXMgcmF0aGVyIHRoYW4gb24gcGVyLWJvdW5kaW5nLWJveFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBlclBpeGVsVGFyZ2V0RmluZDogICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIHBpeGVscyBhcm91bmQgdGFyZ2V0IHBpeGVsIHRvIHRvbGVyYXRlIChjb25zaWRlciBhY3RpdmUpIGR1cmluZyBvYmplY3QgZGV0ZWN0aW9uXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0YXJnZXRGaW5kVG9sZXJhbmNlOiAgICAwLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCB0YXJnZXQgZGV0ZWN0aW9uIGlzIHNraXBwZWQgd2hlbiBob3ZlcmluZyBvdmVyIGNhbnZhcy4gVGhpcyBjYW4gYmUgdXNlZCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNraXBUYXJnZXRGaW5kOiAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBtb3VzZSBldmVudHMgb24gY2FudmFzIChtb3VzZWRvd24vbW91c2Vtb3ZlL21vdXNldXApIHJlc3VsdCBpbiBmcmVlIGRyYXdpbmcuXG4gICAgICogQWZ0ZXIgbW91c2Vkb3duLCBtb3VzZW1vdmUgY3JlYXRlcyBhIHNoYXBlLFxuICAgICAqIGFuZCB0aGVuIG1vdXNldXAgZmluYWxpemVzIGl0IGFuZCBhZGRzIGFuIGluc3RhbmNlIG9mIGBmYWJyaWMuUGF0aGAgb250byBjYW52YXMuXG4gICAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTQjZnJlZV9kcmF3aW5nfVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGlzRHJhd2luZ01vZGU6ICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgb2JqZWN0cyBzaG91bGQgcmVtYWluIGluIGN1cnJlbnQgc3RhY2sgcG9zaXRpb24gd2hlbiBzZWxlY3RlZC5cbiAgICAgKiBXaGVuIGZhbHNlIG9iamVjdHMgYXJlIGJyb3VnaHQgdG8gdG9wIGFuZCByZW5kZXJlZCBhcyBwYXJ0IG9mIHRoZSBzZWxlY3Rpb24gZ3JvdXBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwcmVzZXJ2ZU9iamVjdFN0YWNraW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgcmlnaHQgY2xpY2sgb24gY2FudmFzIGNhbiBvdXRwdXQgdGhlIGNvbnRleHQgbWVudSBvciBub3RcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQHNpbmNlIDEuNi41XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdG9wQ29udGV4dE1lbnU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSBjYW52YXMgY2FuIGZpcmUgcmlnaHQgY2xpY2sgZXZlbnRzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBzaW5jZSAxLjYuNVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZmlyZVJpZ2h0Q2xpY2s6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdEludGVyYWN0aXZlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0gPSBudWxsO1xuICAgICAgdGhpcy5fZ3JvdXBTZWxlY3RvciA9IG51bGw7XG4gICAgICB0aGlzLl9pbml0V3JhcHBlckVsZW1lbnQoKTtcbiAgICAgIHRoaXMuX2NyZWF0ZVVwcGVyQ2FudmFzKCk7XG4gICAgICB0aGlzLl9pbml0RXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgICAgdGhpcy5faW5pdFJldGluYVNjYWxpbmcoKTtcblxuICAgICAgdGhpcy5mcmVlRHJhd2luZ0JydXNoID0gZmFicmljLlBlbmNpbEJydXNoICYmIG5ldyBmYWJyaWMuUGVuY2lsQnJ1c2godGhpcyk7XG5cbiAgICAgIHRoaXMuY2FsY09mZnNldCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIG9iamVjdHMgaW4gdHdvIGdyb3Vwcywgb25lIHRvIHJlbmRlciBpbW1lZGlhdGVseVxuICAgICAqIGFuZCBvbmUgdG8gcmVuZGVyIGFzIGFjdGl2ZUdyb3VwLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBvYmplY3RzIHRvIHJlbmRlciBpbW1lZGlhdGVseSBhbmQgcHVzaGVzIHRoZSBvdGhlciBpbiB0aGUgYWN0aXZlR3JvdXAuXG4gICAgICovXG4gICAgX2Nob29zZU9iamVjdHNUb1JlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYWN0aXZlR3JvdXAgPSB0aGlzLmdldEFjdGl2ZUdyb3VwKCksXG4gICAgICAgICAgYWN0aXZlT2JqZWN0ID0gdGhpcy5nZXRBY3RpdmVPYmplY3QoKSxcbiAgICAgICAgICBvYmplY3QsIG9ianNUb1JlbmRlciA9IFtdLCBhY3RpdmVHcm91cE9iamVjdHMgPSBbXTtcblxuICAgICAgaWYgKChhY3RpdmVHcm91cCB8fCBhY3RpdmVPYmplY3QpICYmICF0aGlzLnByZXNlcnZlT2JqZWN0U3RhY2tpbmcpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvYmplY3QgPSB0aGlzLl9vYmplY3RzW2ldO1xuICAgICAgICAgIGlmICgoIWFjdGl2ZUdyb3VwIHx8ICFhY3RpdmVHcm91cC5jb250YWlucyhvYmplY3QpKSAmJiBvYmplY3QgIT09IGFjdGl2ZU9iamVjdCkge1xuICAgICAgICAgICAgb2Jqc1RvUmVuZGVyLnB1c2gob2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY3RpdmVHcm91cE9iamVjdHMucHVzaChvYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aXZlR3JvdXApIHtcbiAgICAgICAgICBhY3RpdmVHcm91cC5fc2V0KCdfb2JqZWN0cycsIGFjdGl2ZUdyb3VwT2JqZWN0cyk7XG4gICAgICAgICAgb2Jqc1RvUmVuZGVyLnB1c2goYWN0aXZlR3JvdXApO1xuICAgICAgICB9XG4gICAgICAgIGFjdGl2ZU9iamVjdCAmJiBvYmpzVG9SZW5kZXIucHVzaChhY3RpdmVPYmplY3QpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9ianNUb1JlbmRlciA9IHRoaXMuX29iamVjdHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Jqc1RvUmVuZGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGJvdGggdGhlIHRvcCBjYW52YXMgYW5kIHRoZSBzZWNvbmRhcnkgY29udGFpbmVyIGNhbnZhcy5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZW5kZXJBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbiAmJiAhdGhpcy5fZ3JvdXBTZWxlY3RvciAmJiAhdGhpcy5pc0RyYXdpbmdNb2RlKSB7XG4gICAgICAgIHRoaXMuY2xlYXJDb250ZXh0KHRoaXMuY29udGV4dFRvcCk7XG4gICAgICB9XG4gICAgICB2YXIgY2FudmFzVG9EcmF3T24gPSB0aGlzLmNvbnRleHRDb250YWluZXI7XG4gICAgICB0aGlzLnJlbmRlckNhbnZhcyhjYW52YXNUb0RyYXdPbiwgdGhpcy5fY2hvb3NlT2JqZWN0c1RvUmVuZGVyKCkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byByZW5kZXIgb25seSB0aGUgdG9wIGNhbnZhcy5cbiAgICAgKiBBbHNvIHVzZWQgdG8gcmVuZGVyIHRoZSBncm91cCBzZWxlY3Rpb24gYm94LlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVuZGVyVG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0VG9wO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHQoY3R4KTtcblxuICAgICAgLy8gd2UgcmVuZGVyIHRoZSB0b3AgY29udGV4dCAtIGxhc3Qgb2JqZWN0XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb24gJiYgdGhpcy5fZ3JvdXBTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLl9kcmF3U2VsZWN0aW9uKGN0eCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmlyZSgnYWZ0ZXI6cmVuZGVyJyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGN1cnJlbnQgdHJhbnNmb3JtIHRvIGl0cyBvcmlnaW5hbCB2YWx1ZXMgYW5kIGNob29zZXMgdGhlIHR5cGUgb2YgcmVzaXppbmcgYmFzZWQgb24gdGhlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVzZXRDdXJyZW50VHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybTtcblxuICAgICAgdC50YXJnZXQuc2V0KHtcbiAgICAgICAgc2NhbGVYOiB0Lm9yaWdpbmFsLnNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiB0Lm9yaWdpbmFsLnNjYWxlWSxcbiAgICAgICAgc2tld1g6IHQub3JpZ2luYWwuc2tld1gsXG4gICAgICAgIHNrZXdZOiB0Lm9yaWdpbmFsLnNrZXdZLFxuICAgICAgICBsZWZ0OiB0Lm9yaWdpbmFsLmxlZnQsXG4gICAgICAgIHRvcDogdC5vcmlnaW5hbC50b3BcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5fc2hvdWxkQ2VudGVyVHJhbnNmb3JtKHQudGFyZ2V0KSkge1xuICAgICAgICBpZiAodC5hY3Rpb24gPT09ICdyb3RhdGUnKSB7XG4gICAgICAgICAgdGhpcy5fc2V0T3JpZ2luVG9DZW50ZXIodC50YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0Lm9yaWdpblggIT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICBpZiAodC5vcmlnaW5YID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgIHQubW91c2VYU2lnbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHQubW91c2VYU2lnbiA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0Lm9yaWdpblkgIT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICBpZiAodC5vcmlnaW5ZID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgICB0Lm1vdXNlWVNpZ24gPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0Lm1vdXNlWVNpZ24gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHQub3JpZ2luWCA9ICdjZW50ZXInO1xuICAgICAgICAgIHQub3JpZ2luWSA9ICdjZW50ZXInO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdC5vcmlnaW5YID0gdC5vcmlnaW5hbC5vcmlnaW5YO1xuICAgICAgICB0Lm9yaWdpblkgPSB0Lm9yaWdpbmFsLm9yaWdpblk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBwb2ludCBpcyBjb250YWluZWQgd2l0aGluIGFuIGFyZWEgb2YgZ2l2ZW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldCBPYmplY3QgdG8gdGVzdCBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwb2ludF0geCx5IG9iamVjdCBvZiBwb2ludCBjb29yZGluYXRlcyB3ZSB3YW50IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgcG9pbnQgaXMgY29udGFpbmVkIHdpdGhpbiBhbiBhcmVhIG9mIGdpdmVuIG9iamVjdFxuICAgICAqL1xuICAgIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChlLCB0YXJnZXQsIHBvaW50KSB7XG4gICAgICB2YXIgaWdub3JlWm9vbSA9IHRydWUsXG4gICAgICAgICAgcG9pbnRlciA9IHBvaW50IHx8IHRoaXMuZ2V0UG9pbnRlcihlLCBpZ25vcmVab29tKSxcbiAgICAgICAgICB4eTtcblxuICAgICAgaWYgKHRhcmdldC5ncm91cCAmJiB0YXJnZXQuZ3JvdXAgPT09IHRoaXMuZ2V0QWN0aXZlR3JvdXAoKSkge1xuICAgICAgICB4eSA9IHRoaXMuX25vcm1hbGl6ZVBvaW50ZXIodGFyZ2V0Lmdyb3VwLCBwb2ludGVyKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB4eSA9IHsgeDogcG9pbnRlci54LCB5OiBwb2ludGVyLnkgfTtcbiAgICAgIH1cbiAgICAgIC8vIGh0dHA6Ly93d3cuZ2VvZy51YmMuY2EvY291cnNlcy9rbGluay9naXMubm90ZXMvbmNnaWEvdTMyLmh0bWxcbiAgICAgIC8vIGh0dHA6Ly9pZGF2LnVjZGF2aXMuZWR1L35va3JleWxvcy9UQXNoaXAvU3ByaW5nMjAwMC9Qb2ludEluUG9seWdvbi5odG1sXG4gICAgICByZXR1cm4gKHRhcmdldC5jb250YWluc1BvaW50KHh5KSB8fCB0YXJnZXQuX2ZpbmRUYXJnZXRDb3JuZXIocG9pbnRlcikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9ub3JtYWxpemVQb2ludGVyOiBmdW5jdGlvbiAob2JqZWN0LCBwb2ludGVyKSB7XG4gICAgICB2YXIgbSA9IG9iamVjdC5jYWxjVHJhbnNmb3JtTWF0cml4KCksXG4gICAgICAgICAgaW52ZXJ0ZWRNID0gZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtKG0pLFxuICAgICAgICAgIHZwdCA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0sXG4gICAgICAgICAgdnB0UG9pbnRlciA9IHRoaXMucmVzdG9yZVBvaW50ZXJWcHQocG9pbnRlciksXG4gICAgICAgICAgcCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHZwdFBvaW50ZXIsIGludmVydGVkTSk7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQocCwgdnB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyB0cmFuc3BhcmVudCBhdCBhIGNlcnRhaW4gbG9jYXRpb25cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldCBPYmplY3QgdG8gY2hlY2tcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBMZWZ0IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBUb3AgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNUYXJnZXRUcmFuc3BhcmVudDogZnVuY3Rpb24gKHRhcmdldCwgeCwgeSkge1xuICAgICAgdmFyIGhhc0JvcmRlcnMgPSB0YXJnZXQuaGFzQm9yZGVycyxcbiAgICAgICAgICB0cmFuc3BhcmVudENvcm5lcnMgPSB0YXJnZXQudHJhbnNwYXJlbnRDb3JuZXJzLFxuICAgICAgICAgIGN0eCA9IHRoaXMuY29udGV4dENhY2hlLFxuICAgICAgICAgIG9yaWdpbmFsQ29sb3IgPSB0YXJnZXQuc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yO1xuXG4gICAgICB0YXJnZXQuaGFzQm9yZGVycyA9IHRhcmdldC50cmFuc3BhcmVudENvcm5lcnMgPSBmYWxzZTtcbiAgICAgIHRhcmdldC5zZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3IgPSAnJztcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0uYXBwbHkoY3R4LCB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtKTtcbiAgICAgIHRhcmdldC5yZW5kZXIoY3R4KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIHRhcmdldC5hY3RpdmUgJiYgdGFyZ2V0Ll9yZW5kZXJDb250cm9scyhjdHgpO1xuXG4gICAgICB0YXJnZXQuaGFzQm9yZGVycyA9IGhhc0JvcmRlcnM7XG4gICAgICB0YXJnZXQudHJhbnNwYXJlbnRDb3JuZXJzID0gdHJhbnNwYXJlbnRDb3JuZXJzO1xuICAgICAgdGFyZ2V0LnNlbGVjdGlvbkJhY2tncm91bmRDb2xvciA9IG9yaWdpbmFsQ29sb3I7XG5cbiAgICAgIHZhciBpc1RyYW5zcGFyZW50ID0gZmFicmljLnV0aWwuaXNUcmFuc3BhcmVudChcbiAgICAgICAgY3R4LCB4LCB5LCB0aGlzLnRhcmdldEZpbmRUb2xlcmFuY2UpO1xuXG4gICAgICB0aGlzLmNsZWFyQ29udGV4dChjdHgpO1xuXG4gICAgICByZXR1cm4gaXNUcmFuc3BhcmVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgX3Nob3VsZENsZWFyU2VsZWN0aW9uOiBmdW5jdGlvbiAoZSwgdGFyZ2V0KSB7XG4gICAgICB2YXIgYWN0aXZlR3JvdXAgPSB0aGlzLmdldEFjdGl2ZUdyb3VwKCksXG4gICAgICAgICAgYWN0aXZlT2JqZWN0ID0gdGhpcy5nZXRBY3RpdmVPYmplY3QoKTtcblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgIXRhcmdldFxuICAgICAgICB8fFxuICAgICAgICAodGFyZ2V0ICYmXG4gICAgICAgICAgYWN0aXZlR3JvdXAgJiZcbiAgICAgICAgICAhYWN0aXZlR3JvdXAuY29udGFpbnModGFyZ2V0KSAmJlxuICAgICAgICAgIGFjdGl2ZUdyb3VwICE9PSB0YXJnZXQgJiZcbiAgICAgICAgICAhZVt0aGlzLnNlbGVjdGlvbktleV0pXG4gICAgICAgIHx8XG4gICAgICAgICh0YXJnZXQgJiYgIXRhcmdldC5ldmVudGVkKVxuICAgICAgICB8fFxuICAgICAgICAodGFyZ2V0ICYmXG4gICAgICAgICAgIXRhcmdldC5zZWxlY3RhYmxlICYmXG4gICAgICAgICAgYWN0aXZlT2JqZWN0ICYmXG4gICAgICAgICAgYWN0aXZlT2JqZWN0ICE9PSB0YXJnZXQpXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgX3Nob3VsZENlbnRlclRyYW5zZm9ybTogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdCA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sXG4gICAgICAgICAgY2VudGVyVHJhbnNmb3JtO1xuXG4gICAgICBpZiAodC5hY3Rpb24gPT09ICdzY2FsZScgfHwgdC5hY3Rpb24gPT09ICdzY2FsZVgnIHx8IHQuYWN0aW9uID09PSAnc2NhbGVZJykge1xuICAgICAgICBjZW50ZXJUcmFuc2Zvcm0gPSB0aGlzLmNlbnRlcmVkU2NhbGluZyB8fCB0YXJnZXQuY2VudGVyZWRTY2FsaW5nO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodC5hY3Rpb24gPT09ICdyb3RhdGUnKSB7XG4gICAgICAgIGNlbnRlclRyYW5zZm9ybSA9IHRoaXMuY2VudGVyZWRSb3RhdGlvbiB8fCB0YXJnZXQuY2VudGVyZWRSb3RhdGlvbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNlbnRlclRyYW5zZm9ybSA/ICF0LmFsdEtleSA6IHQuYWx0S2V5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRPcmlnaW5Gcm9tQ29ybmVyOiBmdW5jdGlvbih0YXJnZXQsIGNvcm5lcikge1xuICAgICAgdmFyIG9yaWdpbiA9IHtcbiAgICAgICAgeDogdGFyZ2V0Lm9yaWdpblgsXG4gICAgICAgIHk6IHRhcmdldC5vcmlnaW5ZXG4gICAgICB9O1xuXG4gICAgICBpZiAoY29ybmVyID09PSAnbWwnIHx8IGNvcm5lciA9PT0gJ3RsJyB8fCBjb3JuZXIgPT09ICdibCcpIHtcbiAgICAgICAgb3JpZ2luLnggPSAncmlnaHQnO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY29ybmVyID09PSAnbXInIHx8IGNvcm5lciA9PT0gJ3RyJyB8fCBjb3JuZXIgPT09ICdicicpIHtcbiAgICAgICAgb3JpZ2luLnggPSAnbGVmdCc7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb3JuZXIgPT09ICd0bCcgfHwgY29ybmVyID09PSAnbXQnIHx8IGNvcm5lciA9PT0gJ3RyJykge1xuICAgICAgICBvcmlnaW4ueSA9ICdib3R0b20nO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY29ybmVyID09PSAnYmwnIHx8IGNvcm5lciA9PT0gJ21iJyB8fCBjb3JuZXIgPT09ICdicicpIHtcbiAgICAgICAgb3JpZ2luLnkgPSAndG9wJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9yaWdpbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0QWN0aW9uRnJvbUNvcm5lcjogZnVuY3Rpb24odGFyZ2V0LCBjb3JuZXIsIGUpIHtcbiAgICAgIGlmICghY29ybmVyKSB7XG4gICAgICAgIHJldHVybiAnZHJhZyc7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoY29ybmVyKSB7XG4gICAgICAgIGNhc2UgJ210cic6XG4gICAgICAgICAgcmV0dXJuICdyb3RhdGUnO1xuICAgICAgICBjYXNlICdtbCc6XG4gICAgICAgIGNhc2UgJ21yJzpcbiAgICAgICAgICByZXR1cm4gZVt0aGlzLmFsdEFjdGlvbktleV0gPyAnc2tld1knIDogJ3NjYWxlWCc7XG4gICAgICAgIGNhc2UgJ210JzpcbiAgICAgICAgY2FzZSAnbWInOlxuICAgICAgICAgIHJldHVybiBlW3RoaXMuYWx0QWN0aW9uS2V5XSA/ICdza2V3WCcgOiAnc2NhbGVZJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gJ3NjYWxlJztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgX3NldHVwQ3VycmVudFRyYW5zZm9ybTogZnVuY3Rpb24gKGUsIHRhcmdldCkge1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlKSxcbiAgICAgICAgICBjb3JuZXIgPSB0YXJnZXQuX2ZpbmRUYXJnZXRDb3JuZXIodGhpcy5nZXRQb2ludGVyKGUsIHRydWUpKSxcbiAgICAgICAgICBhY3Rpb24gPSB0aGlzLl9nZXRBY3Rpb25Gcm9tQ29ybmVyKHRhcmdldCwgY29ybmVyLCBlKSxcbiAgICAgICAgICBvcmlnaW4gPSB0aGlzLl9nZXRPcmlnaW5Gcm9tQ29ybmVyKHRhcmdldCwgY29ybmVyKTtcblxuICAgICAgdGhpcy5fY3VycmVudFRyYW5zZm9ybSA9IHtcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBjb3JuZXI6IGNvcm5lcixcbiAgICAgICAgc2NhbGVYOiB0YXJnZXQuc2NhbGVYLFxuICAgICAgICBzY2FsZVk6IHRhcmdldC5zY2FsZVksXG4gICAgICAgIHNrZXdYOiB0YXJnZXQuc2tld1gsXG4gICAgICAgIHNrZXdZOiB0YXJnZXQuc2tld1ksXG4gICAgICAgIG9mZnNldFg6IHBvaW50ZXIueCAtIHRhcmdldC5sZWZ0LFxuICAgICAgICBvZmZzZXRZOiBwb2ludGVyLnkgLSB0YXJnZXQudG9wLFxuICAgICAgICBvcmlnaW5YOiBvcmlnaW4ueCxcbiAgICAgICAgb3JpZ2luWTogb3JpZ2luLnksXG4gICAgICAgIGV4OiBwb2ludGVyLngsXG4gICAgICAgIGV5OiBwb2ludGVyLnksXG4gICAgICAgIGxhc3RYOiBwb2ludGVyLngsXG4gICAgICAgIGxhc3RZOiBwb2ludGVyLnksXG4gICAgICAgIGxlZnQ6IHRhcmdldC5sZWZ0LFxuICAgICAgICB0b3A6IHRhcmdldC50b3AsXG4gICAgICAgIHRoZXRhOiBkZWdyZWVzVG9SYWRpYW5zKHRhcmdldC5hbmdsZSksXG4gICAgICAgIHdpZHRoOiB0YXJnZXQud2lkdGggKiB0YXJnZXQuc2NhbGVYLFxuICAgICAgICBtb3VzZVhTaWduOiAxLFxuICAgICAgICBtb3VzZVlTaWduOiAxLFxuICAgICAgICBzaGlmdEtleTogZS5zaGlmdEtleSxcbiAgICAgICAgYWx0S2V5OiBlW3RoaXMuY2VudGVyZWRLZXldXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9jdXJyZW50VHJhbnNmb3JtLm9yaWdpbmFsID0ge1xuICAgICAgICBsZWZ0OiB0YXJnZXQubGVmdCxcbiAgICAgICAgdG9wOiB0YXJnZXQudG9wLFxuICAgICAgICBzY2FsZVg6IHRhcmdldC5zY2FsZVgsXG4gICAgICAgIHNjYWxlWTogdGFyZ2V0LnNjYWxlWSxcbiAgICAgICAgc2tld1g6IHRhcmdldC5za2V3WCxcbiAgICAgICAgc2tld1k6IHRhcmdldC5za2V3WSxcbiAgICAgICAgb3JpZ2luWDogb3JpZ2luLngsXG4gICAgICAgIG9yaWdpblk6IG9yaWdpbi55XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9yZXNldEN1cnJlbnRUcmFuc2Zvcm0oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyBvYmplY3QgYnkgXCJzZXR0aW5nXCIgaXRzIGxlZnQvdG9wXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBwb2ludGVyJ3MgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgcG9pbnRlcidzIHkgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHRyYW5zbGF0aW9uIG9jY3VycmVkXG4gICAgICovXG4gICAgX3RyYW5zbGF0ZU9iamVjdDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLl9jdXJyZW50VHJhbnNmb3JtLFxuICAgICAgICAgIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsXG4gICAgICAgICAgbmV3TGVmdCA9IHggLSB0cmFuc2Zvcm0ub2Zmc2V0WCxcbiAgICAgICAgICBuZXdUb3AgPSB5IC0gdHJhbnNmb3JtLm9mZnNldFksXG4gICAgICAgICAgbW92ZVggPSAhdGFyZ2V0LmdldCgnbG9ja01vdmVtZW50WCcpICYmIHRhcmdldC5sZWZ0ICE9PSBuZXdMZWZ0LFxuICAgICAgICAgIG1vdmVZID0gIXRhcmdldC5nZXQoJ2xvY2tNb3ZlbWVudFknKSAmJiB0YXJnZXQudG9wICE9PSBuZXdUb3A7XG5cbiAgICAgIG1vdmVYICYmIHRhcmdldC5zZXQoJ2xlZnQnLCBuZXdMZWZ0KTtcbiAgICAgIG1vdmVZICYmIHRhcmdldC5zZXQoJ3RvcCcsIG5ld1RvcCk7XG4gICAgICByZXR1cm4gbW92ZVggfHwgbW92ZVk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHdlIGFyZSBpbmNyZWFzaW5nIGEgcG9zaXRpdmUgc2tldyBvciBsb3dlciBpdCxcbiAgICAgKiBjaGVja2luZyBtb3VzZSBkaXJlY3Rpb24gYW5kIHByZXNzZWQgY29ybmVyLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NoYW5nZVNrZXdUcmFuc2Zvcm1PcmlnaW46IGZ1bmN0aW9uKG1vdXNlTW92ZSwgdCwgYnkpIHtcbiAgICAgIHZhciBwcm9wZXJ0eSA9ICdvcmlnaW5YJywgb3JpZ2lucyA9IHsgMDogJ2NlbnRlcicgfSxcbiAgICAgICAgICBza2V3ID0gdC50YXJnZXQuc2tld1gsIG9yaWdpbkEgPSAnbGVmdCcsIG9yaWdpbkIgPSAncmlnaHQnLFxuICAgICAgICAgIGNvcm5lciA9IHQuY29ybmVyID09PSAnbXQnIHx8IHQuY29ybmVyID09PSAnbWwnID8gMSA6IC0xLFxuICAgICAgICAgIGZsaXBTaWduID0gMTtcblxuICAgICAgbW91c2VNb3ZlID0gbW91c2VNb3ZlID4gMCA/IDEgOiAtMTtcbiAgICAgIGlmIChieSA9PT0gJ3knKSB7XG4gICAgICAgIHNrZXcgPSB0LnRhcmdldC5za2V3WTtcbiAgICAgICAgb3JpZ2luQSA9ICd0b3AnO1xuICAgICAgICBvcmlnaW5CID0gJ2JvdHRvbSc7XG4gICAgICAgIHByb3BlcnR5ID0gJ29yaWdpblknO1xuICAgICAgfVxuICAgICAgb3JpZ2luc1stMV0gPSBvcmlnaW5BO1xuICAgICAgb3JpZ2luc1sxXSA9IG9yaWdpbkI7XG5cbiAgICAgIHQudGFyZ2V0LmZsaXBYICYmIChmbGlwU2lnbiAqPSAtMSk7XG4gICAgICB0LnRhcmdldC5mbGlwWSAmJiAoZmxpcFNpZ24gKj0gLTEpO1xuXG4gICAgICBpZiAoc2tldyA9PT0gMCkge1xuICAgICAgICB0LnNrZXdTaWduID0gLWNvcm5lciAqIG1vdXNlTW92ZSAqIGZsaXBTaWduO1xuICAgICAgICB0W3Byb3BlcnR5XSA9IG9yaWdpbnNbLW1vdXNlTW92ZV07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2tldyA9IHNrZXcgPiAwID8gMSA6IC0xO1xuICAgICAgICB0LnNrZXdTaWduID0gc2tldztcbiAgICAgICAgdFtwcm9wZXJ0eV0gPSBvcmlnaW5zW3NrZXcgKiBjb3JuZXIgKiBmbGlwU2lnbl07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNrZXcgb2JqZWN0IGJ5IG1vdXNlIGV2ZW50c1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggcG9pbnRlcidzIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHBvaW50ZXIncyB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYnkgRWl0aGVyICd4JyBvciAneSdcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBza2V3aW5nIG9jY3VycmVkXG4gICAgICovXG4gICAgX3NrZXdPYmplY3Q6IGZ1bmN0aW9uICh4LCB5LCBieSkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9jdXJyZW50VHJhbnNmb3JtLFxuICAgICAgICAgIHRhcmdldCA9IHQudGFyZ2V0LCBza2V3ZWQgPSBmYWxzZSxcbiAgICAgICAgICBsb2NrU2tld2luZ1ggPSB0YXJnZXQuZ2V0KCdsb2NrU2tld2luZ1gnKSxcbiAgICAgICAgICBsb2NrU2tld2luZ1kgPSB0YXJnZXQuZ2V0KCdsb2NrU2tld2luZ1knKTtcblxuICAgICAgaWYgKChsb2NrU2tld2luZ1ggJiYgYnkgPT09ICd4JykgfHwgKGxvY2tTa2V3aW5nWSAmJiBieSA9PT0gJ3knKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB0aGUgY29uc3RyYWludCBwb2ludFxuICAgICAgdmFyIGNlbnRlciA9IHRhcmdldC5nZXRDZW50ZXJQb2ludCgpLFxuICAgICAgICAgIGFjdHVhbE1vdXNlQnlDZW50ZXIgPSB0YXJnZXQudG9Mb2NhbFBvaW50KG5ldyBmYWJyaWMuUG9pbnQoeCwgeSksICdjZW50ZXInLCAnY2VudGVyJylbYnldLFxuICAgICAgICAgIGxhc3RNb3VzZUJ5Q2VudGVyID0gdGFyZ2V0LnRvTG9jYWxQb2ludChuZXcgZmFicmljLlBvaW50KHQubGFzdFgsIHQubGFzdFkpLCAnY2VudGVyJywgJ2NlbnRlcicpW2J5XSxcbiAgICAgICAgICBhY3R1YWxNb3VzZUJ5T3JpZ2luLCBjb25zdHJhaW50UG9zaXRpb24sIGRpbSA9IHRhcmdldC5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCk7XG5cbiAgICAgIHRoaXMuX2NoYW5nZVNrZXdUcmFuc2Zvcm1PcmlnaW4oYWN0dWFsTW91c2VCeUNlbnRlciAtIGxhc3RNb3VzZUJ5Q2VudGVyLCB0LCBieSk7XG4gICAgICBhY3R1YWxNb3VzZUJ5T3JpZ2luID0gdGFyZ2V0LnRvTG9jYWxQb2ludChuZXcgZmFicmljLlBvaW50KHgsIHkpLCB0Lm9yaWdpblgsIHQub3JpZ2luWSlbYnldO1xuICAgICAgY29uc3RyYWludFBvc2l0aW9uID0gdGFyZ2V0LnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQoY2VudGVyLCB0Lm9yaWdpblgsIHQub3JpZ2luWSk7XG4gICAgICAvLyBBY3R1YWxseSBza2V3IHRoZSBvYmplY3RcbiAgICAgIHNrZXdlZCA9IHRoaXMuX3NldE9iamVjdFNrZXcoYWN0dWFsTW91c2VCeU9yaWdpbiwgdCwgYnksIGRpbSk7XG4gICAgICB0Lmxhc3RYID0geDtcbiAgICAgIHQubGFzdFkgPSB5O1xuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBjb25zdHJhaW50cyBhcHBseVxuICAgICAgdGFyZ2V0LnNldFBvc2l0aW9uQnlPcmlnaW4oY29uc3RyYWludFBvc2l0aW9uLCB0Lm9yaWdpblgsIHQub3JpZ2luWSk7XG4gICAgICByZXR1cm4gc2tld2VkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgb2JqZWN0IHNrZXdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNrZXdpbmcgb2NjdXJyZWRcbiAgICAgKi9cbiAgICBfc2V0T2JqZWN0U2tldzogZnVuY3Rpb24obG9jYWxNb3VzZSwgdHJhbnNmb3JtLCBieSwgX2RpbSkge1xuICAgICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsIG5ld1ZhbHVlLCBza2V3ZWQgPSBmYWxzZSxcbiAgICAgICAgICBza2V3U2lnbiA9IHRyYW5zZm9ybS5za2V3U2lnbiwgbmV3RGltLCBkaW1Ob1NrZXcsXG4gICAgICAgICAgb3RoZXJCeSwgX290aGVyQnksIF9ieSwgbmV3RGltTW91c2UsIHNrZXdYLCBza2V3WTtcblxuICAgICAgaWYgKGJ5ID09PSAneCcpIHtcbiAgICAgICAgb3RoZXJCeSA9ICd5JztcbiAgICAgICAgX290aGVyQnkgPSAnWSc7XG4gICAgICAgIF9ieSA9ICdYJztcbiAgICAgICAgc2tld1ggPSAwO1xuICAgICAgICBza2V3WSA9IHRhcmdldC5za2V3WTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvdGhlckJ5ID0gJ3gnO1xuICAgICAgICBfb3RoZXJCeSA9ICdYJztcbiAgICAgICAgX2J5ID0gJ1knO1xuICAgICAgICBza2V3WCA9IHRhcmdldC5za2V3WDtcbiAgICAgICAgc2tld1kgPSAwO1xuICAgICAgfVxuXG4gICAgICBkaW1Ob1NrZXcgPSB0YXJnZXQuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucyhza2V3WCwgc2tld1kpO1xuICAgICAgbmV3RGltTW91c2UgPSAyICogTWF0aC5hYnMobG9jYWxNb3VzZSkgLSBkaW1Ob1NrZXdbYnldO1xuICAgICAgaWYgKG5ld0RpbU1vdXNlIDw9IDIpIHtcbiAgICAgICAgbmV3VmFsdWUgPSAwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlID0gc2tld1NpZ24gKiBNYXRoLmF0YW4oKG5ld0RpbU1vdXNlIC8gdGFyZ2V0WydzY2FsZScgKyBfYnldKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRpbU5vU2tld1tvdGhlckJ5XSAvIHRhcmdldFsnc2NhbGUnICsgX290aGVyQnldKSk7XG4gICAgICAgIG5ld1ZhbHVlID0gZmFicmljLnV0aWwucmFkaWFuc1RvRGVncmVlcyhuZXdWYWx1ZSk7XG4gICAgICB9XG4gICAgICBza2V3ZWQgPSB0YXJnZXRbJ3NrZXcnICsgX2J5XSAhPT0gbmV3VmFsdWU7XG4gICAgICB0YXJnZXQuc2V0KCdza2V3JyArIF9ieSwgbmV3VmFsdWUpO1xuICAgICAgaWYgKHRhcmdldFsnc2tldycgKyBfb3RoZXJCeV0gIT09IDApIHtcbiAgICAgICAgbmV3RGltID0gdGFyZ2V0Ll9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKTtcbiAgICAgICAgbmV3VmFsdWUgPSAoX2RpbVtvdGhlckJ5XSAvIG5ld0RpbVtvdGhlckJ5XSkgKiB0YXJnZXRbJ3NjYWxlJyArIF9vdGhlckJ5XTtcbiAgICAgICAgdGFyZ2V0LnNldCgnc2NhbGUnICsgX290aGVyQnksIG5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBza2V3ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlcyBvYmplY3QgYnkgaW52b2tpbmcgaXRzIHNjYWxlWC9zY2FsZVkgbWV0aG9kc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggcG9pbnRlcidzIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHBvaW50ZXIncyB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYnkgRWl0aGVyICd4JyBvciAneScgLSBzcGVjaWZpZXMgZGltZW5zaW9uIGNvbnN0cmFpbnQgYnkgd2hpY2ggdG8gc2NhbGUgYW4gb2JqZWN0LlxuICAgICAqICAgICAgICAgICAgICAgICAgICBXaGVuIG5vdCBwcm92aWRlZCwgYW4gb2JqZWN0IGlzIHNjYWxlZCBieSBib3RoIGRpbWVuc2lvbnMgZXF1YWxseVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNjYWxpbmcgb2NjdXJyZWRcbiAgICAgKi9cbiAgICBfc2NhbGVPYmplY3Q6IGZ1bmN0aW9uICh4LCB5LCBieSkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9jdXJyZW50VHJhbnNmb3JtLFxuICAgICAgICAgIHRhcmdldCA9IHQudGFyZ2V0LFxuICAgICAgICAgIGxvY2tTY2FsaW5nWCA9IHRhcmdldC5nZXQoJ2xvY2tTY2FsaW5nWCcpLFxuICAgICAgICAgIGxvY2tTY2FsaW5nWSA9IHRhcmdldC5nZXQoJ2xvY2tTY2FsaW5nWScpLFxuICAgICAgICAgIGxvY2tTY2FsaW5nRmxpcCA9IHRhcmdldC5nZXQoJ2xvY2tTY2FsaW5nRmxpcCcpO1xuXG4gICAgICBpZiAobG9ja1NjYWxpbmdYICYmIGxvY2tTY2FsaW5nWSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB0aGUgY29uc3RyYWludCBwb2ludFxuICAgICAgdmFyIGNvbnN0cmFpbnRQb3NpdGlvbiA9IHRhcmdldC50cmFuc2xhdGVUb09yaWdpblBvaW50KHRhcmdldC5nZXRDZW50ZXJQb2ludCgpLCB0Lm9yaWdpblgsIHQub3JpZ2luWSksXG4gICAgICAgICAgbG9jYWxNb3VzZSA9IHRhcmdldC50b0xvY2FsUG9pbnQobmV3IGZhYnJpYy5Qb2ludCh4LCB5KSwgdC5vcmlnaW5YLCB0Lm9yaWdpblkpLFxuICAgICAgICAgIGRpbSA9IHRhcmdldC5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCksIHNjYWxlZCA9IGZhbHNlO1xuXG4gICAgICB0aGlzLl9zZXRMb2NhbE1vdXNlKGxvY2FsTW91c2UsIHQpO1xuXG4gICAgICAvLyBBY3R1YWxseSBzY2FsZSB0aGUgb2JqZWN0XG4gICAgICBzY2FsZWQgPSB0aGlzLl9zZXRPYmplY3RTY2FsZShsb2NhbE1vdXNlLCB0LCBsb2NrU2NhbGluZ1gsIGxvY2tTY2FsaW5nWSwgYnksIGxvY2tTY2FsaW5nRmxpcCwgZGltKTtcblxuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBjb25zdHJhaW50cyBhcHBseVxuICAgICAgdGFyZ2V0LnNldFBvc2l0aW9uQnlPcmlnaW4oY29uc3RyYWludFBvc2l0aW9uLCB0Lm9yaWdpblgsIHQub3JpZ2luWSk7XG4gICAgICByZXR1cm4gc2NhbGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNjYWxpbmcgb2NjdXJyZWRcbiAgICAgKi9cbiAgICBfc2V0T2JqZWN0U2NhbGU6IGZ1bmN0aW9uKGxvY2FsTW91c2UsIHRyYW5zZm9ybSwgbG9ja1NjYWxpbmdYLCBsb2NrU2NhbGluZ1ksIGJ5LCBsb2NrU2NhbGluZ0ZsaXAsIF9kaW0pIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LCBmb3JiaWRTY2FsaW5nWCA9IGZhbHNlLCBmb3JiaWRTY2FsaW5nWSA9IGZhbHNlLCBzY2FsZWQgPSBmYWxzZSxcbiAgICAgICAgICBjaGFuZ2VYLCBjaGFuZ2VZLCBzY2FsZVgsIHNjYWxlWTtcblxuICAgICAgc2NhbGVYID0gbG9jYWxNb3VzZS54ICogdGFyZ2V0LnNjYWxlWCAvIF9kaW0ueDtcbiAgICAgIHNjYWxlWSA9IGxvY2FsTW91c2UueSAqIHRhcmdldC5zY2FsZVkgLyBfZGltLnk7XG4gICAgICBjaGFuZ2VYID0gdGFyZ2V0LnNjYWxlWCAhPT0gc2NhbGVYO1xuICAgICAgY2hhbmdlWSA9IHRhcmdldC5zY2FsZVkgIT09IHNjYWxlWTtcblxuICAgICAgaWYgKGxvY2tTY2FsaW5nRmxpcCAmJiBzY2FsZVggPD0gMCAmJiBzY2FsZVggPCB0YXJnZXQuc2NhbGVYKSB7XG4gICAgICAgIGZvcmJpZFNjYWxpbmdYID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxvY2tTY2FsaW5nRmxpcCAmJiBzY2FsZVkgPD0gMCAmJiBzY2FsZVkgPCB0YXJnZXQuc2NhbGVZKSB7XG4gICAgICAgIGZvcmJpZFNjYWxpbmdZID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJ5ID09PSAnZXF1YWxseScgJiYgIWxvY2tTY2FsaW5nWCAmJiAhbG9ja1NjYWxpbmdZKSB7XG4gICAgICAgIGZvcmJpZFNjYWxpbmdYIHx8IGZvcmJpZFNjYWxpbmdZIHx8IChzY2FsZWQgPSB0aGlzLl9zY2FsZU9iamVjdEVxdWFsbHkobG9jYWxNb3VzZSwgdGFyZ2V0LCB0cmFuc2Zvcm0sIF9kaW0pKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFieSkge1xuICAgICAgICBmb3JiaWRTY2FsaW5nWCB8fCBsb2NrU2NhbGluZ1ggfHwgKHRhcmdldC5zZXQoJ3NjYWxlWCcsIHNjYWxlWCkgJiYgKHNjYWxlZCA9IHNjYWxlZCB8fCBjaGFuZ2VYKSk7XG4gICAgICAgIGZvcmJpZFNjYWxpbmdZIHx8IGxvY2tTY2FsaW5nWSB8fCAodGFyZ2V0LnNldCgnc2NhbGVZJywgc2NhbGVZKSAmJiAoc2NhbGVkID0gc2NhbGVkIHx8IGNoYW5nZVkpKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJ5ID09PSAneCcgJiYgIXRhcmdldC5nZXQoJ2xvY2tVbmlTY2FsaW5nJykpIHtcbiAgICAgICAgZm9yYmlkU2NhbGluZ1ggfHwgbG9ja1NjYWxpbmdYIHx8ICh0YXJnZXQuc2V0KCdzY2FsZVgnLCBzY2FsZVgpICYmIChzY2FsZWQgPSBzY2FsZWQgfHwgY2hhbmdlWCkpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYnkgPT09ICd5JyAmJiAhdGFyZ2V0LmdldCgnbG9ja1VuaVNjYWxpbmcnKSkge1xuICAgICAgICBmb3JiaWRTY2FsaW5nWSB8fCBsb2NrU2NhbGluZ1kgfHwgKHRhcmdldC5zZXQoJ3NjYWxlWScsIHNjYWxlWSkgJiYgKHNjYWxlZCA9IHNjYWxlZCB8fCBjaGFuZ2VZKSk7XG4gICAgICB9XG4gICAgICB0cmFuc2Zvcm0ubmV3U2NhbGVYID0gc2NhbGVYO1xuICAgICAgdHJhbnNmb3JtLm5ld1NjYWxlWSA9IHNjYWxlWTtcbiAgICAgIGZvcmJpZFNjYWxpbmdYIHx8IGZvcmJpZFNjYWxpbmdZIHx8IHRoaXMuX2ZsaXBPYmplY3QodHJhbnNmb3JtLCBieSk7XG4gICAgICByZXR1cm4gc2NhbGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNjYWxpbmcgb2NjdXJyZWRcbiAgICAgKi9cbiAgICBfc2NhbGVPYmplY3RFcXVhbGx5OiBmdW5jdGlvbihsb2NhbE1vdXNlLCB0YXJnZXQsIHRyYW5zZm9ybSwgX2RpbSkge1xuXG4gICAgICB2YXIgZGlzdCA9IGxvY2FsTW91c2UueSArIGxvY2FsTW91c2UueCxcbiAgICAgICAgICBsYXN0RGlzdCA9IF9kaW0ueSAqIHRyYW5zZm9ybS5vcmlnaW5hbC5zY2FsZVkgLyB0YXJnZXQuc2NhbGVZICtcbiAgICAgICAgICAgICAgICAgICAgIF9kaW0ueCAqIHRyYW5zZm9ybS5vcmlnaW5hbC5zY2FsZVggLyB0YXJnZXQuc2NhbGVYLFxuICAgICAgICAgIHNjYWxlZDtcblxuICAgICAgLy8gV2UgdXNlIHRyYW5zZm9ybS5zY2FsZVgvWSBpbnN0ZWFkIG9mIHRhcmdldC5zY2FsZVgvWVxuICAgICAgLy8gYmVjYXVzZSB0aGUgb2JqZWN0IG1heSBoYXZlIGEgbWluIHNjYWxlIGFuZCB3ZSdsbCBsb29zZSB0aGUgcHJvcG9ydGlvbnNcbiAgICAgIHRyYW5zZm9ybS5uZXdTY2FsZVggPSB0cmFuc2Zvcm0ub3JpZ2luYWwuc2NhbGVYICogZGlzdCAvIGxhc3REaXN0O1xuICAgICAgdHJhbnNmb3JtLm5ld1NjYWxlWSA9IHRyYW5zZm9ybS5vcmlnaW5hbC5zY2FsZVkgKiBkaXN0IC8gbGFzdERpc3Q7XG4gICAgICBzY2FsZWQgPSB0cmFuc2Zvcm0ubmV3U2NhbGVYICE9PSB0YXJnZXQuc2NhbGVYIHx8IHRyYW5zZm9ybS5uZXdTY2FsZVkgIT09IHRhcmdldC5zY2FsZVk7XG4gICAgICB0YXJnZXQuc2V0KCdzY2FsZVgnLCB0cmFuc2Zvcm0ubmV3U2NhbGVYKTtcbiAgICAgIHRhcmdldC5zZXQoJ3NjYWxlWScsIHRyYW5zZm9ybS5uZXdTY2FsZVkpO1xuICAgICAgcmV0dXJuIHNjYWxlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmxpcE9iamVjdDogZnVuY3Rpb24odHJhbnNmb3JtLCBieSkge1xuICAgICAgaWYgKHRyYW5zZm9ybS5uZXdTY2FsZVggPCAwICYmIGJ5ICE9PSAneScpIHtcbiAgICAgICAgaWYgKHRyYW5zZm9ybS5vcmlnaW5YID09PSAnbGVmdCcpIHtcbiAgICAgICAgICB0cmFuc2Zvcm0ub3JpZ2luWCA9ICdyaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHJhbnNmb3JtLm9yaWdpblggPT09ICdyaWdodCcpIHtcbiAgICAgICAgICB0cmFuc2Zvcm0ub3JpZ2luWCA9ICdsZWZ0JztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNmb3JtLm5ld1NjYWxlWSA8IDAgJiYgYnkgIT09ICd4Jykge1xuICAgICAgICBpZiAodHJhbnNmb3JtLm9yaWdpblkgPT09ICd0b3AnKSB7XG4gICAgICAgICAgdHJhbnNmb3JtLm9yaWdpblkgPSAnYm90dG9tJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0cmFuc2Zvcm0ub3JpZ2luWSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICB0cmFuc2Zvcm0ub3JpZ2luWSA9ICd0b3AnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldExvY2FsTW91c2U6IGZ1bmN0aW9uKGxvY2FsTW91c2UsIHQpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0LnRhcmdldDtcblxuICAgICAgaWYgKHQub3JpZ2luWCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBsb2NhbE1vdXNlLnggKj0gLTE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0Lm9yaWdpblggPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGxvY2FsTW91c2UueCAqPSB0Lm1vdXNlWFNpZ24gKiAyO1xuICAgICAgICBpZiAobG9jYWxNb3VzZS54IDwgMCkge1xuICAgICAgICAgIHQubW91c2VYU2lnbiA9IC10Lm1vdXNlWFNpZ247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHQub3JpZ2luWSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgbG9jYWxNb3VzZS55ICo9IC0xO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodC5vcmlnaW5ZID09PSAnY2VudGVyJykge1xuICAgICAgICBsb2NhbE1vdXNlLnkgKj0gdC5tb3VzZVlTaWduICogMjtcbiAgICAgICAgaWYgKGxvY2FsTW91c2UueSA8IDApIHtcbiAgICAgICAgICB0Lm1vdXNlWVNpZ24gPSAtdC5tb3VzZVlTaWduO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGFkanVzdCB0aGUgbW91c2UgY29vcmRpbmF0ZXMgd2hlbiBkZWFsaW5nIHdpdGggcGFkZGluZ1xuICAgICAgaWYgKGFicyhsb2NhbE1vdXNlLngpID4gdGFyZ2V0LnBhZGRpbmcpIHtcbiAgICAgICAgaWYgKGxvY2FsTW91c2UueCA8IDApIHtcbiAgICAgICAgICBsb2NhbE1vdXNlLnggKz0gdGFyZ2V0LnBhZGRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbG9jYWxNb3VzZS54IC09IHRhcmdldC5wYWRkaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHsgLy8gbW91c2UgaXMgd2l0aGluIHRoZSBwYWRkaW5nLCBzZXQgdG8gMFxuICAgICAgICBsb2NhbE1vdXNlLnggPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWJzKGxvY2FsTW91c2UueSkgPiB0YXJnZXQucGFkZGluZykge1xuICAgICAgICBpZiAobG9jYWxNb3VzZS55IDwgMCkge1xuICAgICAgICAgIGxvY2FsTW91c2UueSArPSB0YXJnZXQucGFkZGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsb2NhbE1vdXNlLnkgLT0gdGFyZ2V0LnBhZGRpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsb2NhbE1vdXNlLnkgPSAwO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIG9iamVjdCBieSBpbnZva2luZyBpdHMgcm90YXRlIG1ldGhvZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggcG9pbnRlcidzIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHBvaW50ZXIncyB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSByb3RhdGlvbiBvY2N1cnJlZFxuICAgICAqL1xuICAgIF9yb3RhdGVPYmplY3Q6IGZ1bmN0aW9uICh4LCB5KSB7XG5cbiAgICAgIHZhciB0ID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybTtcblxuICAgICAgaWYgKHQudGFyZ2V0LmdldCgnbG9ja1JvdGF0aW9uJykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGFzdEFuZ2xlID0gYXRhbjIodC5leSAtIHQudG9wLCB0LmV4IC0gdC5sZWZ0KSxcbiAgICAgICAgICBjdXJBbmdsZSA9IGF0YW4yKHkgLSB0LnRvcCwgeCAtIHQubGVmdCksXG4gICAgICAgICAgYW5nbGUgPSByYWRpYW5zVG9EZWdyZWVzKGN1ckFuZ2xlIC0gbGFzdEFuZ2xlICsgdC50aGV0YSk7XG5cbiAgICAgIC8vIG5vcm1hbGl6ZSBhbmdsZSB0byBwb3NpdGl2ZSB2YWx1ZVxuICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICBhbmdsZSA9IDM2MCArIGFuZ2xlO1xuICAgICAgfVxuXG4gICAgICB0LnRhcmdldC5hbmdsZSA9IGFuZ2xlICUgMzYwO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY3Vyc29yIHR5cGUgb2YgdGhlIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIEN1cnNvciB0eXBlIG9mIHRoZSBjYW52YXMgZWxlbWVudC5cbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtdWkvI2N1cnNvclxuICAgICAqL1xuICAgIHNldEN1cnNvcjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB0aGlzLnVwcGVyQ2FudmFzRWwuc3R5bGUuY3Vyc29yID0gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0IHRvIHJlc2V0IHRyYW5zZm9ybVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2V0T2JqZWN0VHJhbnNmb3JtOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICB0YXJnZXQuc2NhbGVYID0gMTtcbiAgICAgIHRhcmdldC5zY2FsZVkgPSAxO1xuICAgICAgdGFyZ2V0LnNrZXdYID0gMDtcbiAgICAgIHRhcmdldC5za2V3WSA9IDA7XG4gICAgICB0YXJnZXQuc2V0QW5nbGUoMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCB0byBkcmF3IHRoZSBzZWxlY3Rpb24gb25cbiAgICAgKi9cbiAgICBfZHJhd1NlbGVjdGlvbjogZnVuY3Rpb24gKGN0eCkge1xuICAgICAgdmFyIGdyb3VwU2VsZWN0b3IgPSB0aGlzLl9ncm91cFNlbGVjdG9yLFxuICAgICAgICAgIGxlZnQgPSBncm91cFNlbGVjdG9yLmxlZnQsXG4gICAgICAgICAgdG9wID0gZ3JvdXBTZWxlY3Rvci50b3AsXG4gICAgICAgICAgYWxlZnQgPSBhYnMobGVmdCksXG4gICAgICAgICAgYXRvcCA9IGFicyh0b3ApO1xuXG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25Db2xvcikge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5zZWxlY3Rpb25Db2xvcjtcblxuICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgZ3JvdXBTZWxlY3Rvci5leCAtICgobGVmdCA+IDApID8gMCA6IC1sZWZ0KSxcbiAgICAgICAgICBncm91cFNlbGVjdG9yLmV5IC0gKCh0b3AgPiAwKSA/IDAgOiAtdG9wKSxcbiAgICAgICAgICBhbGVmdCxcbiAgICAgICAgICBhdG9wXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5zZWxlY3Rpb25MaW5lV2lkdGggfHwgIXRoaXMuc2VsZWN0aW9uQm9yZGVyQ29sb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuc2VsZWN0aW9uTGluZVdpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5zZWxlY3Rpb25Cb3JkZXJDb2xvcjtcblxuICAgICAgLy8gc2VsZWN0aW9uIGJvcmRlclxuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uRGFzaEFycmF5Lmxlbmd0aCA+IDEgJiYgIXN1cHBvcnRMaW5lRGFzaCkge1xuXG4gICAgICAgIHZhciBweCA9IGdyb3VwU2VsZWN0b3IuZXggKyBTVFJPS0VfT0ZGU0VUIC0gKChsZWZ0ID4gMCkgPyAwIDogYWxlZnQpLFxuICAgICAgICAgICAgcHkgPSBncm91cFNlbGVjdG9yLmV5ICsgU1RST0tFX09GRlNFVCAtICgodG9wID4gMCkgPyAwIDogYXRvcCk7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgcHgsIHB5LCBweCArIGFsZWZ0LCBweSwgdGhpcy5zZWxlY3Rpb25EYXNoQXJyYXkpO1xuICAgICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHB4LCBweSArIGF0b3AgLSAxLCBweCArIGFsZWZ0LCBweSArIGF0b3AgLSAxLCB0aGlzLnNlbGVjdGlvbkRhc2hBcnJheSk7XG4gICAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgcHgsIHB5LCBweCwgcHkgKyBhdG9wLCB0aGlzLnNlbGVjdGlvbkRhc2hBcnJheSk7XG4gICAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgcHggKyBhbGVmdCAtIDEsIHB5LCBweCArIGFsZWZ0IC0gMSwgcHkgKyBhdG9wLCB0aGlzLnNlbGVjdGlvbkRhc2hBcnJheSk7XG5cbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZmFicmljLk9iamVjdC5wcm90b3R5cGUuX3NldExpbmVEYXNoLmNhbGwodGhpcywgY3R4LCB0aGlzLnNlbGVjdGlvbkRhc2hBcnJheSk7XG4gICAgICAgIGN0eC5zdHJva2VSZWN0KFxuICAgICAgICAgIGdyb3VwU2VsZWN0b3IuZXggKyBTVFJPS0VfT0ZGU0VUIC0gKChsZWZ0ID4gMCkgPyAwIDogYWxlZnQpLFxuICAgICAgICAgIGdyb3VwU2VsZWN0b3IuZXkgKyBTVFJPS0VfT0ZGU0VUIC0gKCh0b3AgPiAwKSA/IDAgOiBhdG9wKSxcbiAgICAgICAgICBhbGVmdCxcbiAgICAgICAgICBhdG9wXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGRldGVybWluZXMgd2hhdCBvYmplY3Qgd2UgYXJlIGNsaWNraW5nIG9uXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBtb3VzZSBldmVudFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcEdyb3VwIHdoZW4gdHJ1ZSwgYWN0aXZlR3JvdXAgaXMgc2tpcHBlZCBhbmQgb25seSBvYmplY3RzIGFyZSB0cmF2ZXJzZWQgdGhyb3VnaFxuICAgICAqL1xuICAgIGZpbmRUYXJnZXQ6IGZ1bmN0aW9uIChlLCBza2lwR3JvdXApIHtcbiAgICAgIGlmICh0aGlzLnNraXBUYXJnZXRGaW5kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlnbm9yZVpvb20gPSB0cnVlLFxuICAgICAgICAgIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSwgaWdub3JlWm9vbSksXG4gICAgICAgICAgYWN0aXZlR3JvdXAgPSB0aGlzLmdldEFjdGl2ZUdyb3VwKCksXG4gICAgICAgICAgYWN0aXZlT2JqZWN0ID0gdGhpcy5nZXRBY3RpdmVPYmplY3QoKSxcbiAgICAgICAgICBhY3RpdmVUYXJnZXQ7XG5cbiAgICAgIC8vIGZpcnN0IGNoZWNrIGN1cnJlbnQgZ3JvdXAgKGlmIG9uZSBleGlzdHMpXG4gICAgICAvLyBhY3RpdmUgZ3JvdXAgZG9lcyBub3QgY2hlY2sgc3ViIHRhcmdldHMgbGlrZSBub3JtYWwgZ3JvdXBzLlxuICAgICAgLy8gaWYgYWN0aXZlIGdyb3VwIGp1c3QgZXhpdHMuXG4gICAgICBpZiAoYWN0aXZlR3JvdXAgJiYgIXNraXBHcm91cCAmJiB0aGlzLl9jaGVja1RhcmdldChwb2ludGVyLCBhY3RpdmVHcm91cCkpIHtcbiAgICAgICAgdGhpcy5fZmlyZU92ZXJPdXRFdmVudHMoYWN0aXZlR3JvdXAsIGUpO1xuICAgICAgICByZXR1cm4gYWN0aXZlR3JvdXA7XG4gICAgICB9XG4gICAgICAvLyBpZiB3ZSBoaXQgdGhlIGNvcm5lciBvZiBhbiBhY3RpdmVPYmplY3QsIGxldCdzIHJldHVybiB0aGF0LlxuICAgICAgaWYgKGFjdGl2ZU9iamVjdCAmJiBhY3RpdmVPYmplY3QuX2ZpbmRUYXJnZXRDb3JuZXIocG9pbnRlcikpIHtcbiAgICAgICAgdGhpcy5fZmlyZU92ZXJPdXRFdmVudHMoYWN0aXZlT2JqZWN0LCBlKTtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZU9iamVjdDtcbiAgICAgIH1cbiAgICAgIGlmIChhY3RpdmVPYmplY3QgJiYgdGhpcy5fY2hlY2tUYXJnZXQocG9pbnRlciwgYWN0aXZlT2JqZWN0KSkge1xuICAgICAgICBpZiAoIXRoaXMucHJlc2VydmVPYmplY3RTdGFja2luZykge1xuICAgICAgICAgIHRoaXMuX2ZpcmVPdmVyT3V0RXZlbnRzKGFjdGl2ZU9iamVjdCwgZSk7XG4gICAgICAgICAgcmV0dXJuIGFjdGl2ZU9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhY3RpdmVUYXJnZXQgPSBhY3RpdmVPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy50YXJnZXRzID0gW107XG5cbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9zZWFyY2hQb3NzaWJsZVRhcmdldHModGhpcy5fb2JqZWN0cywgcG9pbnRlcik7XG4gICAgICBpZiAoZVt0aGlzLmFsdFNlbGVjdGlvbktleV0gJiYgdGFyZ2V0ICYmIGFjdGl2ZVRhcmdldCAmJiB0YXJnZXQgIT09IGFjdGl2ZVRhcmdldCkge1xuICAgICAgICB0YXJnZXQgPSBhY3RpdmVUYXJnZXQ7XG4gICAgICB9XG4gICAgICB0aGlzLl9maXJlT3Zlck91dEV2ZW50cyh0YXJnZXQsIGUpO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZU92ZXJPdXRFdmVudHM6IGZ1bmN0aW9uKHRhcmdldCwgZSkge1xuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICBpZiAodGhpcy5faG92ZXJlZFRhcmdldCAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2hvdmVyZWRUYXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW91c2U6b3V0JywgeyB0YXJnZXQ6IHRoaXMuX2hvdmVyZWRUYXJnZXQsIGU6IGUgfSk7XG4gICAgICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0LmZpcmUoJ21vdXNlb3V0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZmlyZSgnbW91c2U6b3ZlcicsIHsgdGFyZ2V0OiB0YXJnZXQsIGU6IGUgfSk7XG4gICAgICAgICAgdGFyZ2V0LmZpcmUoJ21vdXNlb3ZlcicpO1xuICAgICAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMuX2hvdmVyZWRUYXJnZXQpIHtcbiAgICAgICAgdGhpcy5maXJlKCdtb3VzZTpvdXQnLCB7IHRhcmdldDogdGhpcy5faG92ZXJlZFRhcmdldCwgZTogZSB9KTtcbiAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldC5maXJlKCdtb3VzZW91dCcpO1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2hlY2tUYXJnZXQ6IGZ1bmN0aW9uKHBvaW50ZXIsIG9iaikge1xuICAgICAgaWYgKG9iaiAmJlxuICAgICAgICAgIG9iai52aXNpYmxlICYmXG4gICAgICAgICAgb2JqLmV2ZW50ZWQgJiZcbiAgICAgICAgICB0aGlzLmNvbnRhaW5zUG9pbnQobnVsbCwgb2JqLCBwb2ludGVyKSl7XG4gICAgICAgIGlmICgodGhpcy5wZXJQaXhlbFRhcmdldEZpbmQgfHwgb2JqLnBlclBpeGVsVGFyZ2V0RmluZCkgJiYgIW9iai5pc0VkaXRpbmcpIHtcbiAgICAgICAgICB2YXIgaXNUcmFuc3BhcmVudCA9IHRoaXMuaXNUYXJnZXRUcmFuc3BhcmVudChvYmosIHBvaW50ZXIueCwgcG9pbnRlci55KTtcbiAgICAgICAgICBpZiAoIWlzVHJhbnNwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZWFyY2hQb3NzaWJsZVRhcmdldHM6IGZ1bmN0aW9uKG9iamVjdHMsIHBvaW50ZXIpIHtcblxuICAgICAgLy8gQ2FjaGUgYWxsIHRhcmdldHMgd2hlcmUgdGhlaXIgYm91bmRpbmcgYm94IGNvbnRhaW5zIHBvaW50LlxuICAgICAgdmFyIHRhcmdldCwgaSA9IG9iamVjdHMubGVuZ3RoLCBub3JtYWxpemVkUG9pbnRlciwgc3ViVGFyZ2V0O1xuICAgICAgLy8gRG8gbm90IGNoZWNrIGZvciBjdXJyZW50bHkgZ3JvdXBlZCBvYmplY3RzLCBzaW5jZSB3ZSBjaGVjayB0aGUgcGFyZW50IGdyb3VwIGl0c2VsZi5cbiAgICAgIC8vIHVudGlsbCB3ZSBjYWxsIHRoaXMgZnVuY3Rpb24gc3BlY2lmaWNhbGx5IHRvIHNlYXJjaCBpbnNpZGUgdGhlIGFjdGl2ZUdyb3VwXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmICh0aGlzLl9jaGVja1RhcmdldChwb2ludGVyLCBvYmplY3RzW2ldKSkge1xuICAgICAgICAgIHRhcmdldCA9IG9iamVjdHNbaV07XG4gICAgICAgICAgaWYgKHRhcmdldC50eXBlID09PSAnZ3JvdXAnICYmIHRhcmdldC5zdWJUYXJnZXRDaGVjaykge1xuICAgICAgICAgICAgbm9ybWFsaXplZFBvaW50ZXIgPSB0aGlzLl9ub3JtYWxpemVQb2ludGVyKHRhcmdldCwgcG9pbnRlcik7XG4gICAgICAgICAgICBzdWJUYXJnZXQgPSB0aGlzLl9zZWFyY2hQb3NzaWJsZVRhcmdldHModGFyZ2V0Ll9vYmplY3RzLCBub3JtYWxpemVkUG9pbnRlcik7XG4gICAgICAgICAgICBzdWJUYXJnZXQgJiYgdGhpcy50YXJnZXRzLnB1c2goc3ViVGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcG9pbnRlciBjb29yZGluYXRlcyB3aXRob3V0IHRoZSBlZmZlY3Qgb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXIgd2l0aCBcInhcIiBhbmQgXCJ5XCIgbnVtYmVyIHZhbHVlc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHdpdGggXCJ4XCIgYW5kIFwieVwiIG51bWJlciB2YWx1ZXNcbiAgICAgKi9cbiAgICByZXN0b3JlUG9pbnRlclZwdDogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KFxuICAgICAgICBwb2ludGVyLFxuICAgICAgICBmYWJyaWMudXRpbC5pbnZlcnRUcmFuc2Zvcm0odGhpcy52aWV3cG9ydFRyYW5zZm9ybSlcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcG9pbnRlciBjb29yZGluYXRlcyByZWxhdGl2ZSB0byBjYW52YXMuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlWm9vbVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHdpdGggXCJ4XCIgYW5kIFwieVwiIG51bWJlciB2YWx1ZXNcbiAgICAgKi9cbiAgICBnZXRQb2ludGVyOiBmdW5jdGlvbiAoZSwgaWdub3JlWm9vbSwgdXBwZXJDYW52YXNFbCkge1xuICAgICAgaWYgKCF1cHBlckNhbnZhc0VsKSB7XG4gICAgICAgIHVwcGVyQ2FudmFzRWwgPSB0aGlzLnVwcGVyQ2FudmFzRWw7XG4gICAgICB9XG4gICAgICB2YXIgcG9pbnRlciA9IGdldFBvaW50ZXIoZSksXG4gICAgICAgICAgYm91bmRzID0gdXBwZXJDYW52YXNFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICBib3VuZHNXaWR0aCA9IGJvdW5kcy53aWR0aCB8fCAwLFxuICAgICAgICAgIGJvdW5kc0hlaWdodCA9IGJvdW5kcy5oZWlnaHQgfHwgMCxcbiAgICAgICAgICBjc3NTY2FsZTtcblxuICAgICAgaWYgKCFib3VuZHNXaWR0aCB8fCAhYm91bmRzSGVpZ2h0ICkge1xuICAgICAgICBpZiAoJ3RvcCcgaW4gYm91bmRzICYmICdib3R0b20nIGluIGJvdW5kcykge1xuICAgICAgICAgIGJvdW5kc0hlaWdodCA9IE1hdGguYWJzKCBib3VuZHMudG9wIC0gYm91bmRzLmJvdHRvbSApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgncmlnaHQnIGluIGJvdW5kcyAmJiAnbGVmdCcgaW4gYm91bmRzKSB7XG4gICAgICAgICAgYm91bmRzV2lkdGggPSBNYXRoLmFicyggYm91bmRzLnJpZ2h0IC0gYm91bmRzLmxlZnQgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmNhbGNPZmZzZXQoKTtcblxuICAgICAgcG9pbnRlci54ID0gcG9pbnRlci54IC0gdGhpcy5fb2Zmc2V0LmxlZnQ7XG4gICAgICBwb2ludGVyLnkgPSBwb2ludGVyLnkgLSB0aGlzLl9vZmZzZXQudG9wO1xuICAgICAgaWYgKCFpZ25vcmVab29tKSB7XG4gICAgICAgIHBvaW50ZXIgPSB0aGlzLnJlc3RvcmVQb2ludGVyVnB0KHBvaW50ZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYm91bmRzV2lkdGggPT09IDAgfHwgYm91bmRzSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIC8vIElmIGJvdW5kcyBhcmUgbm90IGF2YWlsYWJsZSAoaS5lLiBub3QgdmlzaWJsZSksIGRvIG5vdCBhcHBseSBzY2FsZS5cbiAgICAgICAgY3NzU2NhbGUgPSB7IHdpZHRoOiAxLCBoZWlnaHQ6IDEgfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjc3NTY2FsZSA9IHtcbiAgICAgICAgICB3aWR0aDogdXBwZXJDYW52YXNFbC53aWR0aCAvIGJvdW5kc1dpZHRoLFxuICAgICAgICAgIGhlaWdodDogdXBwZXJDYW52YXNFbC5oZWlnaHQgLyBib3VuZHNIZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcG9pbnRlci54ICogY3NzU2NhbGUud2lkdGgsXG4gICAgICAgIHk6IHBvaW50ZXIueSAqIGNzc1NjYWxlLmhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdGhyb3dzIHtDQU5WQVNfSU5JVF9FUlJPUn0gSWYgY2FudmFzIGNhbiBub3QgYmUgaW5pdGlhbGl6ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlVXBwZXJDYW52YXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsb3dlckNhbnZhc0NsYXNzID0gdGhpcy5sb3dlckNhbnZhc0VsLmNsYXNzTmFtZS5yZXBsYWNlKC9cXHMqbG93ZXItY2FudmFzXFxzKi8sICcnKTtcblxuICAgICAgdGhpcy51cHBlckNhbnZhc0VsID0gdGhpcy5fY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgZmFicmljLnV0aWwuYWRkQ2xhc3ModGhpcy51cHBlckNhbnZhc0VsLCAndXBwZXItY2FudmFzICcgKyBsb3dlckNhbnZhc0NsYXNzKTtcblxuICAgICAgdGhpcy53cmFwcGVyRWwuYXBwZW5kQ2hpbGQodGhpcy51cHBlckNhbnZhc0VsKTtcblxuICAgICAgdGhpcy5fY29weUNhbnZhc1N0eWxlKHRoaXMubG93ZXJDYW52YXNFbCwgdGhpcy51cHBlckNhbnZhc0VsKTtcbiAgICAgIHRoaXMuX2FwcGx5Q2FudmFzU3R5bGUodGhpcy51cHBlckNhbnZhc0VsKTtcbiAgICAgIHRoaXMuY29udGV4dFRvcCA9IHRoaXMudXBwZXJDYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVDYWNoZUNhbnZhczogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYWNoZUNhbnZhc0VsID0gdGhpcy5fY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgdGhpcy5jYWNoZUNhbnZhc0VsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLndpZHRoKTtcbiAgICAgIHRoaXMuY2FjaGVDYW52YXNFbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHRoaXMuY29udGV4dENhY2hlID0gdGhpcy5jYWNoZUNhbnZhc0VsLmdldENvbnRleHQoJzJkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRXcmFwcGVyRWxlbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy53cmFwcGVyRWwgPSBmYWJyaWMudXRpbC53cmFwRWxlbWVudCh0aGlzLmxvd2VyQ2FudmFzRWwsICdkaXYnLCB7XG4gICAgICAgICdjbGFzcyc6IHRoaXMuY29udGFpbmVyQ2xhc3NcbiAgICAgIH0pO1xuICAgICAgZmFicmljLnV0aWwuc2V0U3R5bGUodGhpcy53cmFwcGVyRWwsIHtcbiAgICAgICAgd2lkdGg6IHRoaXMuZ2V0V2lkdGgoKSArICdweCcsXG4gICAgICAgIGhlaWdodDogdGhpcy5nZXRIZWlnaHQoKSArICdweCcsXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gICAgICB9KTtcbiAgICAgIGZhYnJpYy51dGlsLm1ha2VFbGVtZW50VW5zZWxlY3RhYmxlKHRoaXMud3JhcHBlckVsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IGNhbnZhcyBlbGVtZW50IHRvIGFwcGx5IHN0eWxlcyBvblxuICAgICAqL1xuICAgIF9hcHBseUNhbnZhc1N0eWxlOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpIHx8IGVsZW1lbnQud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKSB8fCBlbGVtZW50LmhlaWdodDtcblxuICAgICAgZmFicmljLnV0aWwuc2V0U3R5bGUoZWxlbWVudCwge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgd2lkdGg6IHdpZHRoICsgJ3B4JyxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyAncHgnLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB0b3A6IDBcbiAgICAgIH0pO1xuICAgICAgZWxlbWVudC53aWR0aCA9IHdpZHRoO1xuICAgICAgZWxlbWVudC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBmYWJyaWMudXRpbC5tYWtlRWxlbWVudFVuc2VsZWN0YWJsZShlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29weXMgdGhlIHRoZSBlbnRpcmUgaW5saW5lIHN0eWxlIGZyb20gb25lIGVsZW1lbnQgKGZyb21FbCkgdG8gYW5vdGhlciAodG9FbClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZnJvbUVsIEVsZW1lbnQgc3R5bGUgaXMgY29waWVkIGZyb21cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRvRWwgRWxlbWVudCBjb3BpZWQgc3R5bGUgaXMgYXBwbGllZCB0b1xuICAgICAqL1xuICAgIF9jb3B5Q2FudmFzU3R5bGU6IGZ1bmN0aW9uIChmcm9tRWwsIHRvRWwpIHtcbiAgICAgIHRvRWwuc3R5bGUuY3NzVGV4dCA9IGZyb21FbC5zdHlsZS5jc3NUZXh0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRleHQgb2YgY2FudmFzIHdoZXJlIG9iamVjdCBzZWxlY3Rpb24gaXMgZHJhd25cbiAgICAgKiBAcmV0dXJuIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICovXG4gICAgZ2V0U2VsZWN0aW9uQ29udGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0VG9wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zICZsdDtjYW52YXM+IGVsZW1lbnQgb24gd2hpY2ggb2JqZWN0IHNlbGVjdGlvbiBpcyBkcmF3blxuICAgICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIGdldFNlbGVjdGlvbkVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnVwcGVyQ2FudmFzRWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAqL1xuICAgIF9zZXRBY3RpdmVPYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgaWYgKHRoaXMuX2FjdGl2ZU9iamVjdCkge1xuICAgICAgICB0aGlzLl9hY3RpdmVPYmplY3Quc2V0KCdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9hY3RpdmVPYmplY3QgPSBvYmplY3Q7XG4gICAgICBvYmplY3Quc2V0KCdhY3RpdmUnLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBnaXZlbiBvYmplY3QgYXMgdGhlIG9ubHkgYWN0aXZlIG9iamVjdCBvbiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc2V0IGFzIGFuIGFjdGl2ZSBvbmVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgKHBhc3NlZCBhbG9uZyB3aGVuIGZpcmluZyBcIm9iamVjdDpzZWxlY3RlZFwiKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0QWN0aXZlT2JqZWN0OiBmdW5jdGlvbiAob2JqZWN0LCBlKSB7XG4gICAgICB0aGlzLl9zZXRBY3RpdmVPYmplY3Qob2JqZWN0KTtcbiAgICAgIHRoaXMucmVuZGVyQWxsKCk7XG4gICAgICB0aGlzLmZpcmUoJ29iamVjdDpzZWxlY3RlZCcsIHsgdGFyZ2V0OiBvYmplY3QsIGU6IGUgfSk7XG4gICAgICBvYmplY3QuZmlyZSgnc2VsZWN0ZWQnLCB7IGU6IGUgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjdXJyZW50bHkgYWN0aXZlIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IGFjdGl2ZSBvYmplY3RcbiAgICAgKi9cbiAgICBnZXRBY3RpdmVPYmplY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgd2FzIHJlbW92ZWRcbiAgICAgKi9cbiAgICBfb25PYmplY3RSZW1vdmVkOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIC8vIHJlbW92aW5nIGFjdGl2ZSBvYmplY3Qgc2hvdWxkIGZpcmUgXCJzZWxlY3Rpb246Y2xlYXJlZFwiIGV2ZW50c1xuICAgICAgaWYgKHRoaXMuZ2V0QWN0aXZlT2JqZWN0KCkgPT09IG9iaikge1xuICAgICAgICB0aGlzLmZpcmUoJ2JlZm9yZTpzZWxlY3Rpb246Y2xlYXJlZCcsIHsgdGFyZ2V0OiBvYmogfSk7XG4gICAgICAgIHRoaXMuX2Rpc2NhcmRBY3RpdmVPYmplY3QoKTtcbiAgICAgICAgdGhpcy5maXJlKCdzZWxlY3Rpb246Y2xlYXJlZCcsIHsgdGFyZ2V0OiBvYmogfSk7XG4gICAgICAgIG9iai5maXJlKCdkZXNlbGVjdGVkJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbGxTdXBlcignX29uT2JqZWN0UmVtb3ZlZCcsIG9iaik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2Rpc2NhcmRBY3RpdmVPYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX2FjdGl2ZU9iamVjdCkge1xuICAgICAgICB0aGlzLl9hY3RpdmVPYmplY3Quc2V0KCdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9hY3RpdmVPYmplY3QgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNjYXJkcyBjdXJyZW50bHkgYWN0aXZlIG9iamVjdCBhbmQgZmlyZSBldmVudHNcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkaXNjYXJkQWN0aXZlT2JqZWN0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGFjdGl2ZU9iamVjdCA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgIHRoaXMuZmlyZSgnYmVmb3JlOnNlbGVjdGlvbjpjbGVhcmVkJywgeyB0YXJnZXQ6IGFjdGl2ZU9iamVjdCwgZTogZSB9KTtcbiAgICAgIHRoaXMuX2Rpc2NhcmRBY3RpdmVPYmplY3QoKTtcbiAgICAgIHRoaXMuZmlyZSgnc2VsZWN0aW9uOmNsZWFyZWQnLCB7IGU6IGUgfSk7XG4gICAgICBhY3RpdmVPYmplY3QgJiYgYWN0aXZlT2JqZWN0LmZpcmUoJ2Rlc2VsZWN0ZWQnLCB7IGU6IGUgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Hcm91cH0gZ3JvdXBcbiAgICAgKi9cbiAgICBfc2V0QWN0aXZlR3JvdXA6IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICB0aGlzLl9hY3RpdmVHcm91cCA9IGdyb3VwO1xuICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgIGdyb3VwLnNldCgnYWN0aXZlJywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgYWN0aXZlIGdyb3VwIHRvIGEgc3BlY2lmaWVkIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLkdyb3VwfSBncm91cCBHcm91cCB0byBzZXQgYXMgYSBjdXJyZW50IG9uZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRBY3RpdmVHcm91cDogZnVuY3Rpb24gKGdyb3VwLCBlKSB7XG4gICAgICB0aGlzLl9zZXRBY3RpdmVHcm91cChncm91cCk7XG4gICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgdGhpcy5maXJlKCdvYmplY3Q6c2VsZWN0ZWQnLCB7IHRhcmdldDogZ3JvdXAsIGU6IGUgfSk7XG4gICAgICAgIGdyb3VwLmZpcmUoJ3NlbGVjdGVkJywgeyBlOiBlIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY3VycmVudGx5IGFjdGl2ZSBncm91cFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gQ3VycmVudCBncm91cFxuICAgICAqL1xuICAgIGdldEFjdGl2ZUdyb3VwOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWN0aXZlR3JvdXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2Rpc2NhcmRBY3RpdmVHcm91cDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZyA9IHRoaXMuZ2V0QWN0aXZlR3JvdXAoKTtcbiAgICAgIGlmIChnKSB7XG4gICAgICAgIGcuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRBY3RpdmVHcm91cChudWxsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzY2FyZHMgY3VycmVudGx5IGFjdGl2ZSBncm91cCBhbmQgZmlyZSBldmVudHNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRpc2NhcmRBY3RpdmVHcm91cDogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBnID0gdGhpcy5nZXRBY3RpdmVHcm91cCgpO1xuICAgICAgdGhpcy5maXJlKCdiZWZvcmU6c2VsZWN0aW9uOmNsZWFyZWQnLCB7IGU6IGUsIHRhcmdldDogZyB9KTtcbiAgICAgIHRoaXMuX2Rpc2NhcmRBY3RpdmVHcm91cCgpO1xuICAgICAgdGhpcy5maXJlKCdzZWxlY3Rpb246Y2xlYXJlZCcsIHsgZTogZSB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWFjdGl2YXRlcyBhbGwgb2JqZWN0cyBvbiBjYW52YXMsIHJlbW92aW5nIGFueSBhY3RpdmUgZ3JvdXAgb3Igb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkZWFjdGl2YXRlQWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYWxsT2JqZWN0cyA9IHRoaXMuZ2V0T2JqZWN0cygpLFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIGxlbiA9IGFsbE9iamVjdHMubGVuZ3RoO1xuICAgICAgZm9yICggOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYWxsT2JqZWN0c1tpXS5zZXQoJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2Rpc2NhcmRBY3RpdmVHcm91cCgpO1xuICAgICAgdGhpcy5fZGlzY2FyZEFjdGl2ZU9iamVjdCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlYWN0aXZhdGVzIGFsbCBvYmplY3RzIGFuZCBkaXNwYXRjaGVzIGFwcHJvcHJpYXRlIGV2ZW50c1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZGVhY3RpdmF0ZUFsbFdpdGhEaXNwYXRjaDogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBhY3RpdmVHcm91cCA9IHRoaXMuZ2V0QWN0aXZlR3JvdXAoKSxcbiAgICAgICAgICBhY3RpdmVPYmplY3QgPSB0aGlzLmdldEFjdGl2ZU9iamVjdCgpO1xuICAgICAgaWYgKGFjdGl2ZU9iamVjdCB8fCBhY3RpdmVHcm91cCkge1xuICAgICAgICB0aGlzLmZpcmUoJ2JlZm9yZTpzZWxlY3Rpb246Y2xlYXJlZCcsIHsgdGFyZ2V0OiBhY3RpdmVPYmplY3QgfHwgYWN0aXZlR3JvdXAsIGU6IGUgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLmRlYWN0aXZhdGVBbGwoKTtcbiAgICAgIGlmIChhY3RpdmVPYmplY3QgfHwgYWN0aXZlR3JvdXApIHtcbiAgICAgICAgdGhpcy5maXJlKCdzZWxlY3Rpb246Y2xlYXJlZCcsIHsgZTogZSwgdGFyZ2V0OiBhY3RpdmVPYmplY3QgfSk7XG4gICAgICAgIGFjdGl2ZU9iamVjdCAmJiBhY3RpdmVPYmplY3QuZmlyZSgnZGVzZWxlY3RlZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhIGNhbnZhcyBlbGVtZW50IGFuZCByZW1vdmVzIGFsbCBldmVudCBsaXN0ZW5lcnNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdkaXNwb3NlJyk7XG4gICAgICB2YXIgd3JhcHBlciA9IHRoaXMud3JhcHBlckVsO1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIHdyYXBwZXIucmVtb3ZlQ2hpbGQodGhpcy51cHBlckNhbnZhc0VsKTtcbiAgICAgIHdyYXBwZXIucmVtb3ZlQ2hpbGQodGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIGRlbGV0ZSB0aGlzLnVwcGVyQ2FudmFzRWw7XG4gICAgICBpZiAod3JhcHBlci5wYXJlbnROb2RlKSB7XG4gICAgICAgIHdyYXBwZXIucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodGhpcy5sb3dlckNhbnZhc0VsLCB0aGlzLndyYXBwZXJFbCk7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy53cmFwcGVyRWw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCBjb250ZXh0cyAoYmFja2dyb3VuZCwgbWFpbiwgdG9wKSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZGlzY2FyZEFjdGl2ZUdyb3VwKCk7XG4gICAgICB0aGlzLmRpc2NhcmRBY3RpdmVPYmplY3QoKTtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0KHRoaXMuY29udGV4dFRvcCk7XG4gICAgICByZXR1cm4gdGhpcy5jYWxsU3VwZXIoJ2NsZWFyJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIG9iamVjdHMnIGNvbnRyb2xzIChib3JkZXJzL2NvbnRyb2xzKVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgY29udHJvbHMgb25cbiAgICAgKi9cbiAgICBkcmF3Q29udHJvbHM6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIGFjdGl2ZUdyb3VwID0gdGhpcy5nZXRBY3RpdmVHcm91cCgpO1xuXG4gICAgICBpZiAoYWN0aXZlR3JvdXApIHtcbiAgICAgICAgYWN0aXZlR3JvdXAuX3JlbmRlckNvbnRyb2xzKGN0eCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fZHJhd09iamVjdHNDb250cm9scyhjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kcmF3T2JqZWN0c0NvbnRyb2xzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGlmICghdGhpcy5fb2JqZWN0c1tpXSB8fCAhdGhpcy5fb2JqZWN0c1tpXS5hY3RpdmUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vYmplY3RzW2ldLl9yZW5kZXJDb250cm9scyhjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90b09iamVjdDogZnVuY3Rpb24oaW5zdGFuY2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIC8vSWYgdGhlIG9iamVjdCBpcyBwYXJ0IG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBncm91cCwgaXQgc2hvdWxkXG4gICAgICAvL2JlIHRyYW5zZm9ybWVkIGFwcHJvcHJpYXRlbHlcbiAgICAgIC8vaS5lLiBpdCBzaG91bGQgYmUgc2VyaWFsaXNlZCBhcyBpdCB3b3VsZCBhcHBlYXIgaWYgdGhlIHNlbGVjdGlvbiBncm91cFxuICAgICAgLy93ZXJlIHRvIGJlIGRlc3Ryb3llZC5cbiAgICAgIHZhciBvcmlnaW5hbFByb3BlcnRpZXMgPSB0aGlzLl9yZWFsaXplR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdChpbnN0YW5jZSksXG4gICAgICAgICAgb2JqZWN0ID0gdGhpcy5jYWxsU3VwZXIoJ190b09iamVjdCcsIGluc3RhbmNlLCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIC8vVW5kbyB0aGUgZGFtYWdlIHdlIGRpZCBieSBjaGFuZ2luZyBhbGwgb2YgaXRzIHByb3BlcnRpZXNcbiAgICAgIHRoaXMuX3Vud2luZEdyb3VwVHJhbnNmb3JtT25PYmplY3QoaW5zdGFuY2UsIG9yaWdpbmFsUHJvcGVydGllcyk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWFsaXNlcyBhbiBvYmplY3QncyBncm91cCB0cmFuc2Zvcm1hdGlvbiBvbiBpdFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBbaW5zdGFuY2VdIHRoZSBvYmplY3QgdG8gdHJhbnNmb3JtIChnZXRzIG11dGF0ZWQpXG4gICAgICogQHJldHVybnMgdGhlIG9yaWdpbmFsIHZhbHVlcyBvZiBpbnN0YW5jZSB3aGljaCB3ZXJlIGNoYW5nZWRcbiAgICAgKi9cbiAgICBfcmVhbGl6ZUdyb3VwVHJhbnNmb3JtT25PYmplY3Q6IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gICAgICB2YXIgbGF5b3V0UHJvcHMgPSBbJ2FuZ2xlJywgJ2ZsaXBYJywgJ2ZsaXBZJywgJ2hlaWdodCcsICdsZWZ0JywgJ3NjYWxlWCcsICdzY2FsZVknLCAndG9wJywgJ3dpZHRoJ107XG4gICAgICBpZiAoaW5zdGFuY2UuZ3JvdXAgJiYgaW5zdGFuY2UuZ3JvdXAgPT09IHRoaXMuZ2V0QWN0aXZlR3JvdXAoKSkge1xuICAgICAgICAvL0NvcHkgYWxsIHRoZSBwb3NpdGlvbmFsbHkgcmVsZXZhbnQgcHJvcGVydGllcyBhY3Jvc3Mgbm93XG4gICAgICAgIHZhciBvcmlnaW5hbFZhbHVlcyA9IHt9O1xuICAgICAgICBsYXlvdXRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgICBvcmlnaW5hbFZhbHVlc1twcm9wXSA9IGluc3RhbmNlW3Byb3BdO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5nZXRBY3RpdmVHcm91cCgpLnJlYWxpemVUcmFuc2Zvcm0oaW5zdGFuY2UpO1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxWYWx1ZXM7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmVzIHRoZSBjaGFuZ2VkIHByb3BlcnRpZXMgb2YgaW5zdGFuY2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gW2luc3RhbmNlXSB0aGUgb2JqZWN0IHRvIHVuLXRyYW5zZm9ybSAoZ2V0cyBtdXRhdGVkKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3JpZ2luYWxWYWx1ZXNdIHRoZSBvcmlnaW5hbCB2YWx1ZXMgb2YgaW5zdGFuY2UsIGFzIHJldHVybmVkIGJ5IF9yZWFsaXplR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdFxuICAgICAqL1xuICAgIF91bndpbmRHcm91cFRyYW5zZm9ybU9uT2JqZWN0OiBmdW5jdGlvbihpbnN0YW5jZSwgb3JpZ2luYWxWYWx1ZXMpIHtcbiAgICAgIGlmIChvcmlnaW5hbFZhbHVlcykge1xuICAgICAgICBpbnN0YW5jZS5zZXQob3JpZ2luYWxWYWx1ZXMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdPYmplY3Q6IGZ1bmN0aW9uKG1hcmt1cCwgaW5zdGFuY2UsIHJldml2ZXIpIHtcbiAgICAgIHZhciBvcmlnaW5hbFByb3BlcnRpZXM7XG4gICAgICAvL0lmIHRoZSBvYmplY3QgaXMgaW4gYSBzZWxlY3Rpb24gZ3JvdXAsIHNpbXVsYXRlIHdoYXQgd291bGQgaGFwcGVuIHRvIHRoYXRcbiAgICAgIC8vb2JqZWN0IHdoZW4gdGhlIGdyb3VwIGlzIGRlc2VsZWN0ZWRcbiAgICAgIG9yaWdpbmFsUHJvcGVydGllcyA9IHRoaXMuX3JlYWxpemVHcm91cFRyYW5zZm9ybU9uT2JqZWN0KGluc3RhbmNlKTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0U1ZHT2JqZWN0JywgbWFya3VwLCBpbnN0YW5jZSwgcmV2aXZlcik7XG4gICAgICB0aGlzLl91bndpbmRHcm91cFRyYW5zZm9ybU9uT2JqZWN0KGluc3RhbmNlLCBvcmlnaW5hbFByb3BlcnRpZXMpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8vIGNvcHlpbmcgc3RhdGljIHByb3BlcnRpZXMgbWFudWFsbHkgdG8gd29yayBhcm91bmQgT3BlcmEncyBidWcsXG4gIC8vIHdoZXJlIFwicHJvdG90eXBlXCIgcHJvcGVydHkgaXMgZW51bWVyYWJsZSBhbmQgb3ZlcnJpZGVzIGV4aXN0aW5nIHByb3RvdHlwZVxuICBmb3IgKHZhciBwcm9wIGluIGZhYnJpYy5TdGF0aWNDYW52YXMpIHtcbiAgICBpZiAocHJvcCAhPT0gJ3Byb3RvdHlwZScpIHtcbiAgICAgIGZhYnJpYy5DYW52YXNbcHJvcF0gPSBmYWJyaWMuU3RhdGljQ2FudmFzW3Byb3BdO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmYWJyaWMuaXNUb3VjaFN1cHBvcnRlZCkge1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgZmFicmljLkNhbnZhcy5wcm90b3R5cGUuX3NldEN1cnNvckZyb21FdmVudCA9IGZ1bmN0aW9uKCkgeyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICogQGNsYXNzIGZhYnJpYy5FbGVtZW50XG4gICAqIEBhbGlhcyBmYWJyaWMuQ2FudmFzXG4gICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgZmFicmljLkNhbnZhc30gaW5zdGVhZC5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmYWJyaWMuRWxlbWVudCA9IGZhYnJpYy5DYW52YXM7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgY3Vyc29yT2Zmc2V0ID0ge1xuICAgICAgICBtdDogMCwgLy8gblxuICAgICAgICB0cjogMSwgLy8gbmVcbiAgICAgICAgbXI6IDIsIC8vIGVcbiAgICAgICAgYnI6IDMsIC8vIHNlXG4gICAgICAgIG1iOiA0LCAvLyBzXG4gICAgICAgIGJsOiA1LCAvLyBzd1xuICAgICAgICBtbDogNiwgLy8gd1xuICAgICAgICB0bDogNyAvLyBud1xuICAgICAgfSxcbiAgICAgIGFkZExpc3RlbmVyID0gZmFicmljLnV0aWwuYWRkTGlzdGVuZXIsXG4gICAgICByZW1vdmVMaXN0ZW5lciA9IGZhYnJpYy51dGlsLnJlbW92ZUxpc3RlbmVyO1xuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLkNhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLkNhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogTWFwIG9mIGN1cnNvciBzdHlsZSB2YWx1ZXMgZm9yIGVhY2ggb2YgdGhlIG9iamVjdCBjb250cm9sc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY3Vyc29yTWFwOiBbXG4gICAgICAnbi1yZXNpemUnLFxuICAgICAgJ25lLXJlc2l6ZScsXG4gICAgICAnZS1yZXNpemUnLFxuICAgICAgJ3NlLXJlc2l6ZScsXG4gICAgICAncy1yZXNpemUnLFxuICAgICAgJ3N3LXJlc2l6ZScsXG4gICAgICAndy1yZXNpemUnLFxuICAgICAgJ253LXJlc2l6ZSdcbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBtb3VzZSBsaXN0ZW5lcnMgdG8gY2FudmFzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdEV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcblxuICAgICAgYWRkTGlzdGVuZXIoZmFicmljLndpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplKTtcblxuICAgICAgLy8gbW91c2UgZXZlbnRzXG4gICAgICBhZGRMaXN0ZW5lcih0aGlzLnVwcGVyQ2FudmFzRWwsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93bik7XG4gICAgICBhZGRMaXN0ZW5lcih0aGlzLnVwcGVyQ2FudmFzRWwsICdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG4gICAgICBhZGRMaXN0ZW5lcih0aGlzLnVwcGVyQ2FudmFzRWwsICdtb3VzZW91dCcsIHRoaXMuX29uTW91c2VPdXQpO1xuICAgICAgYWRkTGlzdGVuZXIodGhpcy51cHBlckNhbnZhc0VsLCAnd2hlZWwnLCB0aGlzLl9vbk1vdXNlV2hlZWwpO1xuICAgICAgYWRkTGlzdGVuZXIodGhpcy51cHBlckNhbnZhc0VsLCAnY29udGV4dG1lbnUnLCB0aGlzLl9vbkNvbnRleHRNZW51KTtcblxuICAgICAgLy8gdG91Y2ggZXZlbnRzXG4gICAgICBhZGRMaXN0ZW5lcih0aGlzLnVwcGVyQ2FudmFzRWwsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Nb3VzZURvd24pO1xuICAgICAgYWRkTGlzdGVuZXIodGhpcy51cHBlckNhbnZhc0VsLCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUpO1xuXG4gICAgICBpZiAodHlwZW9mIGV2ZW50anMgIT09ICd1bmRlZmluZWQnICYmICdhZGQnIGluIGV2ZW50anMpIHtcbiAgICAgICAgZXZlbnRqcy5hZGQodGhpcy51cHBlckNhbnZhc0VsLCAnZ2VzdHVyZScsIHRoaXMuX29uR2VzdHVyZSk7XG4gICAgICAgIGV2ZW50anMuYWRkKHRoaXMudXBwZXJDYW52YXNFbCwgJ2RyYWcnLCB0aGlzLl9vbkRyYWcpO1xuICAgICAgICBldmVudGpzLmFkZCh0aGlzLnVwcGVyQ2FudmFzRWwsICdvcmllbnRhdGlvbicsIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UpO1xuICAgICAgICBldmVudGpzLmFkZCh0aGlzLnVwcGVyQ2FudmFzRWwsICdzaGFrZScsIHRoaXMuX29uU2hha2UpO1xuICAgICAgICBldmVudGpzLmFkZCh0aGlzLnVwcGVyQ2FudmFzRWwsICdsb25ncHJlc3MnLCB0aGlzLl9vbkxvbmdQcmVzcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2JpbmRFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fb25Nb3VzZURvd24gPSB0aGlzLl9vbk1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Nb3VzZU1vdmUgPSB0aGlzLl9vbk1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Nb3VzZVVwID0gdGhpcy5fb25Nb3VzZVVwLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vblJlc2l6ZSA9IHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbkdlc3R1cmUgPSB0aGlzLl9vbkdlc3R1cmUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uRHJhZyA9IHRoaXMuX29uRHJhZy5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25TaGFrZSA9IHRoaXMuX29uU2hha2UuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTG9uZ1ByZXNzID0gdGhpcy5fb25Mb25nUHJlc3MuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UgPSB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlV2hlZWwgPSB0aGlzLl9vbk1vdXNlV2hlZWwuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTW91c2VPdXQgPSB0aGlzLl9vbk1vdXNlT3V0LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbkNvbnRleHRNZW51ID0gdGhpcy5fb25Db250ZXh0TWVudS5iaW5kKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBldmVudCBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICByZW1vdmVMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLndpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplKTtcblxuICAgICAgcmVtb3ZlTGlzdGVuZXIodGhpcy51cHBlckNhbnZhc0VsLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24pO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIodGhpcy51cHBlckNhbnZhc0VsLCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIodGhpcy51cHBlckNhbnZhc0VsLCAnbW91c2VvdXQnLCB0aGlzLl9vbk1vdXNlT3V0KTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKHRoaXMudXBwZXJDYW52YXNFbCwgJ3doZWVsJywgdGhpcy5fb25Nb3VzZVdoZWVsKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKHRoaXMudXBwZXJDYW52YXNFbCwgJ2NvbnRleHRtZW51JywgdGhpcy5fb25Db250ZXh0TWVudSk7XG5cbiAgICAgIHJlbW92ZUxpc3RlbmVyKHRoaXMudXBwZXJDYW52YXNFbCwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbk1vdXNlRG93bik7XG4gICAgICByZW1vdmVMaXN0ZW5lcih0aGlzLnVwcGVyQ2FudmFzRWwsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgZXZlbnRqcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ3JlbW92ZScgaW4gZXZlbnRqcykge1xuICAgICAgICBldmVudGpzLnJlbW92ZSh0aGlzLnVwcGVyQ2FudmFzRWwsICdnZXN0dXJlJywgdGhpcy5fb25HZXN0dXJlKTtcbiAgICAgICAgZXZlbnRqcy5yZW1vdmUodGhpcy51cHBlckNhbnZhc0VsLCAnZHJhZycsIHRoaXMuX29uRHJhZyk7XG4gICAgICAgIGV2ZW50anMucmVtb3ZlKHRoaXMudXBwZXJDYW52YXNFbCwgJ29yaWVudGF0aW9uJywgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSk7XG4gICAgICAgIGV2ZW50anMucmVtb3ZlKHRoaXMudXBwZXJDYW52YXNFbCwgJ3NoYWtlJywgdGhpcy5fb25TaGFrZSk7XG4gICAgICAgIGV2ZW50anMucmVtb3ZlKHRoaXMudXBwZXJDYW52YXNFbCwgJ2xvbmdwcmVzcycsIHRoaXMuX29uTG9uZ1ByZXNzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIGdlc3R1cmVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbc2VsZl0gSW5uZXIgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX29uR2VzdHVyZTogZnVuY3Rpb24oZSwgc2VsZikge1xuICAgICAgdGhpcy5fX29uVHJhbnNmb3JtR2VzdHVyZSAmJiB0aGlzLl9fb25UcmFuc2Zvcm1HZXN0dXJlKGUsIHNlbGYpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCBvYmplY3QgZmlyZWQgb24gRXZlbnQuanMgZHJhZ1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25EcmFnOiBmdW5jdGlvbihlLCBzZWxmKSB7XG4gICAgICB0aGlzLl9fb25EcmFnICYmIHRoaXMuX19vbkRyYWcoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiB3aGVlbCBldmVudFxuICAgICAqL1xuICAgIF9vbk1vdXNlV2hlZWw6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuX19vbk1vdXNlV2hlZWwoZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX29uTW91c2VPdXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9ob3ZlcmVkVGFyZ2V0O1xuICAgICAgdGhpcy5maXJlKCdtb3VzZTpvdXQnLCB7IHRhcmdldDogdGFyZ2V0LCBlOiBlIH0pO1xuICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IG51bGw7XG4gICAgICB0YXJnZXQgJiYgdGFyZ2V0LmZpcmUoJ21vdXNlb3V0JywgeyBlOiBlIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCBvYmplY3QgZmlyZWQgb24gRXZlbnQuanMgb3JpZW50YXRpb24gY2hhbmdlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW3NlbGZdIElubmVyIEV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIF9vbk9yaWVudGF0aW9uQ2hhbmdlOiBmdW5jdGlvbihlLCBzZWxmKSB7XG4gICAgICB0aGlzLl9fb25PcmllbnRhdGlvbkNoYW5nZSAmJiB0aGlzLl9fb25PcmllbnRhdGlvbkNoYW5nZShlLCBzZWxmKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIHNoYWtlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW3NlbGZdIElubmVyIEV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIF9vblNoYWtlOiBmdW5jdGlvbihlLCBzZWxmKSB7XG4gICAgICB0aGlzLl9fb25TaGFrZSAmJiB0aGlzLl9fb25TaGFrZShlLCBzZWxmKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIHNoYWtlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW3NlbGZdIElubmVyIEV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIF9vbkxvbmdQcmVzczogZnVuY3Rpb24oZSwgc2VsZikge1xuICAgICAgdGhpcy5fX29uTG9uZ1ByZXNzICYmIHRoaXMuX19vbkxvbmdQcmVzcyhlLCBzZWxmKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Db250ZXh0TWVudTogZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICh0aGlzLnN0b3BDb250ZXh0TWVudSkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9fb25Nb3VzZURvd24oZSk7XG5cbiAgICAgIGFkZExpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Nb3VzZVVwKTtcbiAgICAgIGFkZExpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW91c2VNb3ZlKTtcblxuICAgICAgcmVtb3ZlTGlzdGVuZXIodGhpcy51cHBlckNhbnZhc0VsLCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIodGhpcy51cHBlckNhbnZhc0VsLCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUpO1xuXG4gICAgICBpZiAoZS50eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAgICAgLy8gVW5iaW5kIG1vdXNlZG93biB0byBwcmV2ZW50IGRvdWJsZSB0cmlnZ2VycyBmcm9tIHRvdWNoIGRldmljZXNcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIodGhpcy51cHBlckNhbnZhc0VsLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGFkZExpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXApO1xuICAgICAgICBhZGRMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2V1cFxuICAgICAqL1xuICAgIF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9fb25Nb3VzZVVwKGUpO1xuXG4gICAgICByZW1vdmVMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Nb3VzZVVwKTtcblxuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUpO1xuXG4gICAgICBhZGRMaXN0ZW5lcih0aGlzLnVwcGVyQ2FudmFzRWwsICdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG4gICAgICBhZGRMaXN0ZW5lcih0aGlzLnVwcGVyQ2FudmFzRWwsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG5cbiAgICAgIGlmIChlLnR5cGUgPT09ICd0b3VjaGVuZCcpIHtcbiAgICAgICAgLy8gV2FpdCA0MDBtcyBiZWZvcmUgcmViaW5kaW5nIG1vdXNlZG93biB0byBwcmV2ZW50IGRvdWJsZSB0cmlnZ2Vyc1xuICAgICAgICAvLyBmcm9tIHRvdWNoIGRldmljZXNcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBhZGRMaXN0ZW5lcihfdGhpcy51cHBlckNhbnZhc0VsLCAnbW91c2Vkb3duJywgX3RoaXMuX29uTW91c2VEb3duKTtcbiAgICAgICAgfSwgNDAwKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZW1vdmVcbiAgICAgKi9cbiAgICBfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAhdGhpcy5hbGxvd1RvdWNoU2Nyb2xsaW5nICYmIGUucHJldmVudERlZmF1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5fX29uTW91c2VNb3ZlKGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vblJlc2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYWxjT2Zmc2V0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY2lkZXMgd2hldGhlciB0aGUgY2FudmFzIHNob3VsZCBiZSByZWRyYXduIGluIG1vdXNldXAgYW5kIG1vdXNlZG93biBldmVudHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICAgKi9cbiAgICBfc2hvdWxkUmVuZGVyOiBmdW5jdGlvbih0YXJnZXQsIHBvaW50ZXIpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3QgPSB0aGlzLmdldEFjdGl2ZUdyb3VwKCkgfHwgdGhpcy5nZXRBY3RpdmVPYmplY3QoKTtcblxuICAgICAgcmV0dXJuICEhKFxuICAgICAgICAodGFyZ2V0ICYmIChcbiAgICAgICAgICB0YXJnZXQuaXNNb3ZpbmcgfHxcbiAgICAgICAgICB0YXJnZXQgIT09IGFjdGl2ZU9iamVjdCkpXG4gICAgICAgIHx8XG4gICAgICAgICghdGFyZ2V0ICYmICEhYWN0aXZlT2JqZWN0KVxuICAgICAgICB8fFxuICAgICAgICAoIXRhcmdldCAmJiAhYWN0aXZlT2JqZWN0ICYmICF0aGlzLl9ncm91cFNlbGVjdG9yKVxuICAgICAgICB8fFxuICAgICAgICAocG9pbnRlciAmJlxuICAgICAgICAgIHRoaXMuX3ByZXZpb3VzUG9pbnRlciAmJlxuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uICYmIChcbiAgICAgICAgICBwb2ludGVyLnggIT09IHRoaXMuX3ByZXZpb3VzUG9pbnRlci54IHx8XG4gICAgICAgICAgcG9pbnRlci55ICE9PSB0aGlzLl9wcmV2aW91c1BvaW50ZXIueSkpXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBkZWZpbmVzIHRoZSBhY3Rpb25zIHdoZW4gbW91c2UgaXMgcmVsZWFzZWQgb24gY2FudmFzLlxuICAgICAqIFRoZSBtZXRob2QgcmVzZXRzIHRoZSBjdXJyZW50VHJhbnNmb3JtIHBhcmFtZXRlcnMsIHN0b3JlIHRoZSBpbWFnZSBjb3JuZXJcbiAgICAgKiBwb3NpdGlvbiBpbiB0aGUgaW1hZ2Ugb2JqZWN0IGFuZCByZW5kZXIgdGhlIGNhbnZhcyBvbiB0b3AuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZXVwXG4gICAgICovXG4gICAgX19vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgdGFyZ2V0LCBzZWFyY2hUYXJnZXQgPSB0cnVlLCB0cmFuc2Zvcm0gPSB0aGlzLl9jdXJyZW50VHJhbnNmb3JtLFxuICAgICAgICAgIGdyb3VwU2VsZWN0b3IgPSB0aGlzLl9ncm91cFNlbGVjdG9yLFxuICAgICAgICAgIGlzQ2xpY2sgPSAoIWdyb3VwU2VsZWN0b3IgfHwgKGdyb3VwU2VsZWN0b3IubGVmdCA9PT0gMCAmJiBncm91cFNlbGVjdG9yLnRvcCA9PT0gMCkpO1xuXG4gICAgICBpZiAodGhpcy5pc0RyYXdpbmdNb2RlICYmIHRoaXMuX2lzQ3VycmVudGx5RHJhd2luZykge1xuICAgICAgICB0aGlzLl9vbk1vdXNlVXBJbkRyYXdpbmdNb2RlKGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdGhpcy5fZmluYWxpemVDdXJyZW50VHJhbnNmb3JtKCk7XG4gICAgICAgIHNlYXJjaFRhcmdldCA9ICF0cmFuc2Zvcm0uYWN0aW9uUGVyZm9ybWVkO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXQgPSBzZWFyY2hUYXJnZXQgPyB0aGlzLmZpbmRUYXJnZXQoZSwgdHJ1ZSkgOiB0cmFuc2Zvcm0udGFyZ2V0O1xuXG4gICAgICB2YXIgc2hvdWxkUmVuZGVyID0gdGhpcy5fc2hvdWxkUmVuZGVyKHRhcmdldCwgdGhpcy5nZXRQb2ludGVyKGUpKTtcblxuICAgICAgaWYgKHRhcmdldCB8fCAhaXNDbGljaykge1xuICAgICAgICB0aGlzLl9tYXliZUdyb3VwT2JqZWN0cyhlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyB0aG9zZSBhcmUgZG9uZSBieSBkZWZhdWx0IG9uIG1vdXNlIHVwXG4gICAgICAgIC8vIGJ5IF9tYXliZUdyb3VwT2JqZWN0cywgd2UgYXJlIHNraXBwaW5nIGl0IGluIGNhc2Ugb2Ygbm8gdGFyZ2V0IGZpbmRcbiAgICAgICAgdGhpcy5fZ3JvdXBTZWxlY3RvciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldC5pc01vdmluZyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9oYW5kbGVDdXJzb3JBbmRFdmVudChlLCB0YXJnZXQsICd1cCcpO1xuICAgICAgdGFyZ2V0ICYmICh0YXJnZXQuX19jb3JuZXIgPSAwKTtcbiAgICAgIHNob3VsZFJlbmRlciAmJiB0aGlzLnJlbmRlckFsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzZXQgY3Vyc29yIGZvciBtb3VzZSB1cCBhbmQgaGFuZGxlIG1vdXNlVXAgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIGV2ZW50IGZyb20gbW91c2VcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldCByZWNlaXZpbmcgZXZlbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIGV2ZW50IHRvIGZpcmUgKHVwLCBkb3duIG9yIG1vdmUpXG4gICAgICovXG4gICAgX2hhbmRsZUN1cnNvckFuZEV2ZW50OiBmdW5jdGlvbihlLCB0YXJnZXQsIGV2ZW50VHlwZSkge1xuICAgICAgdGhpcy5fc2V0Q3Vyc29yRnJvbUV2ZW50KGUsIHRhcmdldCk7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCBldmVudFR5cGUsIHRhcmdldCA/IHRhcmdldCA6IG51bGwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgZXZlbnQgZmlyaW5nIGZvciB0YXJnZXQgYW5kIHN1YnRhcmdldHNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIGV2ZW50IGZyb20gbW91c2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIGV2ZW50IHRvIGZpcmUgKHVwLCBkb3duIG9yIG1vdmUpXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRPYmogcmVjZWl2aW5nIGV2ZW50XG4gICAgICovXG4gICAgX2hhbmRsZUV2ZW50OiBmdW5jdGlvbihlLCBldmVudFR5cGUsIHRhcmdldE9iaikge1xuICAgICAgdmFyIHRhcmdldCA9IHR5cGVvZiB0YXJnZXRPYmogPT09IHVuZGVmaW5lZCA/IHRoaXMuZmluZFRhcmdldChlKSA6IHRhcmdldE9iaixcbiAgICAgICAgICB0YXJnZXRzID0gdGhpcy50YXJnZXRzIHx8IFtdLFxuICAgICAgICAgIG9wdGlvbnMgPSB7IGU6IGUsIHRhcmdldDogdGFyZ2V0LCBzdWJUYXJnZXRzOiB0YXJnZXRzIH07XG5cbiAgICAgIHRoaXMuZmlyZSgnbW91c2U6JyArIGV2ZW50VHlwZSwgb3B0aW9ucyk7XG4gICAgICB0YXJnZXQgJiYgdGFyZ2V0LmZpcmUoJ21vdXNlJyArIGV2ZW50VHlwZSwgb3B0aW9ucyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGFyZ2V0c1tpXS5maXJlKCdtb3VzZScgKyBldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maW5hbGl6ZUN1cnJlbnRUcmFuc2Zvcm06IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybSxcbiAgICAgICAgICB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0O1xuXG4gICAgICBpZiAodGFyZ2V0Ll9zY2FsaW5nKSB7XG4gICAgICAgIHRhcmdldC5fc2NhbGluZyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXQuc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLl9yZXN0b3JlT3JpZ2luWFkodGFyZ2V0KTtcblxuICAgICAgaWYgKHRyYW5zZm9ybS5hY3Rpb25QZXJmb3JtZWQgfHwgKHRoaXMuc3RhdGVmdWwgJiYgdGFyZ2V0Lmhhc1N0YXRlQ2hhbmdlZCgpKSkge1xuICAgICAgICB0aGlzLmZpcmUoJ29iamVjdDptb2RpZmllZCcsIHsgdGFyZ2V0OiB0YXJnZXQgfSk7XG4gICAgICAgIHRhcmdldC5maXJlKCdtb2RpZmllZCcpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgT2JqZWN0IHRvIHJlc3RvcmVcbiAgICAgKi9cbiAgICBfcmVzdG9yZU9yaWdpblhZOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIGlmICh0aGlzLl9wcmV2aW91c09yaWdpblggJiYgdGhpcy5fcHJldmlvdXNPcmlnaW5ZKSB7XG5cbiAgICAgICAgdmFyIG9yaWdpblBvaW50ID0gdGFyZ2V0LnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQoXG4gICAgICAgICAgdGFyZ2V0LmdldENlbnRlclBvaW50KCksXG4gICAgICAgICAgdGhpcy5fcHJldmlvdXNPcmlnaW5YLFxuICAgICAgICAgIHRoaXMuX3ByZXZpb3VzT3JpZ2luWSk7XG5cbiAgICAgICAgdGFyZ2V0Lm9yaWdpblggPSB0aGlzLl9wcmV2aW91c09yaWdpblg7XG4gICAgICAgIHRhcmdldC5vcmlnaW5ZID0gdGhpcy5fcHJldmlvdXNPcmlnaW5ZO1xuXG4gICAgICAgIHRhcmdldC5sZWZ0ID0gb3JpZ2luUG9pbnQueDtcbiAgICAgICAgdGFyZ2V0LnRvcCA9IG9yaWdpblBvaW50Lnk7XG5cbiAgICAgICAgdGhpcy5fcHJldmlvdXNPcmlnaW5YID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNPcmlnaW5ZID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Nb3VzZURvd25JbkRyYXdpbmdNb2RlOiBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5kaXNjYXJkQWN0aXZlT2JqZWN0KGUpLnJlbmRlckFsbCgpO1xuICAgICAgaWYgKHRoaXMuY2xpcFRvKSB7XG4gICAgICAgIGZhYnJpYy51dGlsLmNsaXBDb250ZXh0KHRoaXMsIHRoaXMuY29udGV4dFRvcCk7XG4gICAgICB9XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlKTtcbiAgICAgIHRoaXMuZnJlZURyYXdpbmdCcnVzaC5vbk1vdXNlRG93bihwb2ludGVyKTtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdkb3duJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vtb3ZlXG4gICAgICovXG4gICAgX29uTW91c2VNb3ZlSW5EcmF3aW5nTW9kZTogZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKHRoaXMuX2lzQ3VycmVudGx5RHJhd2luZykge1xuICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlKTtcbiAgICAgICAgdGhpcy5mcmVlRHJhd2luZ0JydXNoLm9uTW91c2VNb3ZlKHBvaW50ZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRDdXJzb3IodGhpcy5mcmVlRHJhd2luZ0N1cnNvcik7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnbW92ZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNldXBcbiAgICAgKi9cbiAgICBfb25Nb3VzZVVwSW5EcmF3aW5nTW9kZTogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5faXNDdXJyZW50bHlEcmF3aW5nID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5jbGlwVG8pIHtcbiAgICAgICAgdGhpcy5jb250ZXh0VG9wLnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJlZURyYXdpbmdCcnVzaC5vbk1vdXNlVXAoKTtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICd1cCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBkZWZpbmVzIHRoZSBhY3Rpb25zIHdoZW4gbW91c2UgaXMgY2xpYyBrZWQgb24gY2FudmFzLlxuICAgICAqIFRoZSBtZXRob2QgaW5pdHMgdGhlIGN1cnJlbnRUcmFuc2Zvcm0gcGFyYW1ldGVycyBhbmQgcmVuZGVycyBhbGwgdGhlXG4gICAgICogY2FudmFzIHNvIHRoZSBjdXJyZW50IGltYWdlIGNhbiBiZSBwbGFjZWQgb24gdGhlIHRvcCBjYW52YXMgYW5kIHRoZSByZXN0XG4gICAgICogaW4gb24gdGhlIGNvbnRhaW5lciBvbmUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfX29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuXG4gICAgICAvLyBpZiByaWdodCBjbGljayBqdXN0IGZpcmUgZXZlbnRzXG4gICAgICB2YXIgaXNSaWdodENsaWNrICA9ICd3aGljaCcgaW4gZSA/IGUud2hpY2ggPT09IDMgOiBlLmJ1dHRvbiA9PT0gMjtcbiAgICAgIGlmIChpc1JpZ2h0Q2xpY2spIHtcbiAgICAgICAgaWYgKHRoaXMuZmlyZVJpZ2h0Q2xpY2spIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnZG93bicsIHRhcmdldCA/IHRhcmdldCA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNEcmF3aW5nTW9kZSkge1xuICAgICAgICB0aGlzLl9vbk1vdXNlRG93bkluRHJhd2luZ01vZGUoZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gaWdub3JlIGlmIHNvbWUgb2JqZWN0IGlzIGJlaW5nIHRyYW5zZm9ybWVkIGF0IHRoaXMgbW9tZW50XG4gICAgICBpZiAodGhpcy5fY3VycmVudFRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmZpbmRUYXJnZXQoZSksXG4gICAgICAgICAgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlLCB0cnVlKTtcblxuICAgICAgLy8gc2F2ZSBwb2ludGVyIGZvciBjaGVjayBpbiBfX29uTW91c2VVcCBldmVudFxuICAgICAgdGhpcy5fcHJldmlvdXNQb2ludGVyID0gcG9pbnRlcjtcblxuICAgICAgdmFyIHNob3VsZFJlbmRlciA9IHRoaXMuX3Nob3VsZFJlbmRlcih0YXJnZXQsIHBvaW50ZXIpLFxuICAgICAgICAgIHNob3VsZEdyb3VwID0gdGhpcy5fc2hvdWxkR3JvdXAoZSwgdGFyZ2V0KTtcblxuICAgICAgaWYgKHRoaXMuX3Nob3VsZENsZWFyU2VsZWN0aW9uKGUsIHRhcmdldCkpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJTZWxlY3Rpb24oZSwgdGFyZ2V0LCBwb2ludGVyKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNob3VsZEdyb3VwKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUdyb3VwaW5nKGUsIHRhcmdldCk7XG4gICAgICAgIHRhcmdldCA9IHRoaXMuZ2V0QWN0aXZlR3JvdXAoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICBpZiAodGFyZ2V0LnNlbGVjdGFibGUgJiYgKHRhcmdldC5fX2Nvcm5lciB8fCAhc2hvdWxkR3JvdXApKSB7XG4gICAgICAgICAgdGhpcy5fYmVmb3JlVHJhbnNmb3JtKGUsIHRhcmdldCk7XG4gICAgICAgICAgdGhpcy5fc2V0dXBDdXJyZW50VHJhbnNmb3JtKGUsIHRhcmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0ICE9PSB0aGlzLmdldEFjdGl2ZUdyb3VwKCkgJiYgdGFyZ2V0ICE9PSB0aGlzLmdldEFjdGl2ZU9iamVjdCgpKSB7XG4gICAgICAgICAgdGhpcy5kZWFjdGl2YXRlQWxsKCk7XG4gICAgICAgICAgdGFyZ2V0LnNlbGVjdGFibGUgJiYgdGhpcy5zZXRBY3RpdmVPYmplY3QodGFyZ2V0LCBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2Rvd24nLCB0YXJnZXQgPyB0YXJnZXQgOiBudWxsKTtcbiAgICAgIC8vIHdlIG11c3QgcmVuZGVyQWxsIHNvIHRoYXQgd2UgdXBkYXRlIHRoZSB2aXN1YWxzXG4gICAgICBzaG91bGRSZW5kZXIgJiYgdGhpcy5yZW5kZXJBbGwoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYmVmb3JlVHJhbnNmb3JtOiBmdW5jdGlvbihlLCB0YXJnZXQpIHtcbiAgICAgIHRoaXMuc3RhdGVmdWwgJiYgdGFyZ2V0LnNhdmVTdGF0ZSgpO1xuXG4gICAgICAvLyBkZXRlcm1pbmUgaWYgaXQncyBhIGRyYWcgb3Igcm90YXRlIGNhc2VcbiAgICAgIGlmICh0YXJnZXQuX2ZpbmRUYXJnZXRDb3JuZXIodGhpcy5nZXRQb2ludGVyKGUpKSkge1xuICAgICAgICB0aGlzLm9uQmVmb3JlU2NhbGVSb3RhdGUodGFyZ2V0KTtcbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jbGVhclNlbGVjdGlvbjogZnVuY3Rpb24oZSwgdGFyZ2V0LCBwb2ludGVyKSB7XG4gICAgICB0aGlzLmRlYWN0aXZhdGVBbGxXaXRoRGlzcGF0Y2goZSk7XG5cbiAgICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0LnNlbGVjdGFibGUpIHtcbiAgICAgICAgdGhpcy5zZXRBY3RpdmVPYmplY3QodGFyZ2V0LCBlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2dyb3VwU2VsZWN0b3IgPSB7XG4gICAgICAgICAgZXg6IHBvaW50ZXIueCxcbiAgICAgICAgICBleTogcG9pbnRlci55LFxuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBsZWZ0OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBPYmplY3QgZm9yIHRoYXQgb3JpZ2luIGlzIHNldCB0byBjZW50ZXJcbiAgICAgKi9cbiAgICBfc2V0T3JpZ2luVG9DZW50ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgdGhpcy5fcHJldmlvdXNPcmlnaW5YID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybS50YXJnZXQub3JpZ2luWDtcbiAgICAgIHRoaXMuX3ByZXZpb3VzT3JpZ2luWSA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0udGFyZ2V0Lm9yaWdpblk7XG5cbiAgICAgIHZhciBjZW50ZXIgPSB0YXJnZXQuZ2V0Q2VudGVyUG9pbnQoKTtcblxuICAgICAgdGFyZ2V0Lm9yaWdpblggPSAnY2VudGVyJztcbiAgICAgIHRhcmdldC5vcmlnaW5ZID0gJ2NlbnRlcic7XG5cbiAgICAgIHRhcmdldC5sZWZ0ID0gY2VudGVyLng7XG4gICAgICB0YXJnZXQudG9wID0gY2VudGVyLnk7XG5cbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0ubGVmdCA9IHRhcmdldC5sZWZ0O1xuICAgICAgdGhpcy5fY3VycmVudFRyYW5zZm9ybS50b3AgPSB0YXJnZXQudG9wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgT2JqZWN0IGZvciB0aGF0IGNlbnRlciBpcyBzZXQgdG8gb3JpZ2luXG4gICAgICovXG4gICAgX3NldENlbnRlclRvT3JpZ2luOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIHZhciBvcmlnaW5Qb2ludCA9IHRhcmdldC50cmFuc2xhdGVUb09yaWdpblBvaW50KFxuICAgICAgICB0YXJnZXQuZ2V0Q2VudGVyUG9pbnQoKSxcbiAgICAgICAgdGhpcy5fcHJldmlvdXNPcmlnaW5YLFxuICAgICAgICB0aGlzLl9wcmV2aW91c09yaWdpblkpO1xuXG4gICAgICB0YXJnZXQub3JpZ2luWCA9IHRoaXMuX3ByZXZpb3VzT3JpZ2luWDtcbiAgICAgIHRhcmdldC5vcmlnaW5ZID0gdGhpcy5fcHJldmlvdXNPcmlnaW5ZO1xuXG4gICAgICB0YXJnZXQubGVmdCA9IG9yaWdpblBvaW50Lng7XG4gICAgICB0YXJnZXQudG9wID0gb3JpZ2luUG9pbnQueTtcblxuICAgICAgdGhpcy5fcHJldmlvdXNPcmlnaW5YID0gbnVsbDtcbiAgICAgIHRoaXMuX3ByZXZpb3VzT3JpZ2luWSA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGRlZmluZXMgdGhlIGFjdGlvbnMgd2hlbiBtb3VzZSBpcyBob3ZlcmluZyB0aGUgY2FudmFzLlxuICAgICAqIFRoZSBjdXJyZW50VHJhbnNmb3JtIHBhcmFtZXRlciB3aWxsIGRlZmluZGUgd2hldGhlciB0aGUgdXNlciBpcyByb3RhdGluZy9zY2FsaW5nL3RyYW5zbGF0aW5nXG4gICAgICogYW4gaW1hZ2Ugb3IgbmVpdGhlciBvZiB0aGVtIChvbmx5IGhvdmVyaW5nKS4gQSBncm91cCBzZWxlY3Rpb24gaXMgYWxzbyBwb3NzaWJsZSBhbmQgd291bGQgY2FuY2VsXG4gICAgICogYWxsIGFueSBvdGhlciB0eXBlIG9mIGFjdGlvbi5cbiAgICAgKiBJbiBjYXNlIG9mIGFuIGltYWdlIHRyYW5zZm9ybWF0aW9uIG9ubHkgdGhlIHRvcCBjYW52YXMgd2lsbCBiZSByZW5kZXJlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlbW92ZVxuICAgICAqL1xuICAgIF9fb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cbiAgICAgIHZhciB0YXJnZXQsIHBvaW50ZXI7XG5cbiAgICAgIGlmICh0aGlzLmlzRHJhd2luZ01vZGUpIHtcbiAgICAgICAgdGhpcy5fb25Nb3VzZU1vdmVJbkRyYXdpbmdNb2RlKGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGUudG91Y2hlcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZ3JvdXBTZWxlY3RvciA9IHRoaXMuX2dyb3VwU2VsZWN0b3I7XG5cbiAgICAgIC8vIFdlIGluaXRpYWxseSBjbGlja2VkIGluIGFuIGVtcHR5IGFyZWEsIHNvIHdlIGRyYXcgYSBib3ggZm9yIG11bHRpcGxlIHNlbGVjdGlvblxuICAgICAgaWYgKGdyb3VwU2VsZWN0b3IpIHtcbiAgICAgICAgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlLCB0cnVlKTtcblxuICAgICAgICBncm91cFNlbGVjdG9yLmxlZnQgPSBwb2ludGVyLnggLSBncm91cFNlbGVjdG9yLmV4O1xuICAgICAgICBncm91cFNlbGVjdG9yLnRvcCA9IHBvaW50ZXIueSAtIGdyb3VwU2VsZWN0b3IuZXk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJUb3AoKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCF0aGlzLl9jdXJyZW50VHJhbnNmb3JtKSB7XG4gICAgICAgIHRhcmdldCA9IHRoaXMuZmluZFRhcmdldChlKTtcbiAgICAgICAgdGhpcy5fc2V0Q3Vyc29yRnJvbUV2ZW50KGUsIHRhcmdldCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtT2JqZWN0KGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ21vdmUnLCB0YXJnZXQgPyB0YXJnZXQgOiBudWxsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZGVmaW5lcyBhY3Rpb25zIHdoZW4gYW4gRXZlbnQgTW91c2UgV2hlZWxcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZXVwXG4gICAgICovXG4gICAgX19vbk1vdXNlV2hlZWw6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuZmlyZSgnbW91c2U6d2hlZWwnLCB7XG4gICAgICAgIGU6IGVcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgZmlyZWQgb24gbW91c2Vtb3ZlXG4gICAgICovXG4gICAgX3RyYW5zZm9ybU9iamVjdDogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSksXG4gICAgICAgICAgdHJhbnNmb3JtID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybTtcblxuICAgICAgdHJhbnNmb3JtLnJlc2V0ID0gZmFsc2U7XG4gICAgICB0cmFuc2Zvcm0udGFyZ2V0LmlzTW92aW5nID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fYmVmb3JlU2NhbGVUcmFuc2Zvcm0oZSwgdHJhbnNmb3JtKTtcbiAgICAgIHRoaXMuX3BlcmZvcm1UcmFuc2Zvcm1BY3Rpb24oZSwgdHJhbnNmb3JtLCBwb2ludGVyKTtcblxuICAgICAgdHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZCAmJiB0aGlzLnJlbmRlckFsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wZXJmb3JtVHJhbnNmb3JtQWN0aW9uOiBmdW5jdGlvbihlLCB0cmFuc2Zvcm0sIHBvaW50ZXIpIHtcbiAgICAgIHZhciB4ID0gcG9pbnRlci54LFxuICAgICAgICAgIHkgPSBwb2ludGVyLnksXG4gICAgICAgICAgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCxcbiAgICAgICAgICBhY3Rpb24gPSB0cmFuc2Zvcm0uYWN0aW9uLFxuICAgICAgICAgIGFjdGlvblBlcmZvcm1lZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoYWN0aW9uID09PSAncm90YXRlJykge1xuICAgICAgICAoYWN0aW9uUGVyZm9ybWVkID0gdGhpcy5fcm90YXRlT2JqZWN0KHgsIHkpKSAmJiB0aGlzLl9maXJlKCdyb3RhdGluZycsIHRhcmdldCwgZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhY3Rpb24gPT09ICdzY2FsZScpIHtcbiAgICAgICAgKGFjdGlvblBlcmZvcm1lZCA9IHRoaXMuX29uU2NhbGUoZSwgdHJhbnNmb3JtLCB4LCB5KSkgJiYgdGhpcy5fZmlyZSgnc2NhbGluZycsIHRhcmdldCwgZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhY3Rpb24gPT09ICdzY2FsZVgnKSB7XG4gICAgICAgIChhY3Rpb25QZXJmb3JtZWQgPSB0aGlzLl9zY2FsZU9iamVjdCh4LCB5LCAneCcpKSAmJiB0aGlzLl9maXJlKCdzY2FsaW5nJywgdGFyZ2V0LCBlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ3NjYWxlWScpIHtcbiAgICAgICAgKGFjdGlvblBlcmZvcm1lZCA9IHRoaXMuX3NjYWxlT2JqZWN0KHgsIHksICd5JykpICYmIHRoaXMuX2ZpcmUoJ3NjYWxpbmcnLCB0YXJnZXQsIGUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnc2tld1gnKSB7XG4gICAgICAgIChhY3Rpb25QZXJmb3JtZWQgPSB0aGlzLl9za2V3T2JqZWN0KHgsIHksICd4JykpICYmIHRoaXMuX2ZpcmUoJ3NrZXdpbmcnLCB0YXJnZXQsIGUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnc2tld1knKSB7XG4gICAgICAgIChhY3Rpb25QZXJmb3JtZWQgPSB0aGlzLl9za2V3T2JqZWN0KHgsIHksICd5JykpICYmIHRoaXMuX2ZpcmUoJ3NrZXdpbmcnLCB0YXJnZXQsIGUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGFjdGlvblBlcmZvcm1lZCA9IHRoaXMuX3RyYW5zbGF0ZU9iamVjdCh4LCB5KTtcbiAgICAgICAgaWYgKGFjdGlvblBlcmZvcm1lZCkge1xuICAgICAgICAgIHRoaXMuX2ZpcmUoJ21vdmluZycsIHRhcmdldCwgZSk7XG4gICAgICAgICAgdGhpcy5zZXRDdXJzb3IodGFyZ2V0Lm1vdmVDdXJzb3IgfHwgdGhpcy5tb3ZlQ3Vyc29yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZCA9IGFjdGlvblBlcmZvcm1lZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZTogZnVuY3Rpb24oZXZlbnROYW1lLCB0YXJnZXQsIGUpIHtcbiAgICAgIHRoaXMuZmlyZSgnb2JqZWN0OicgKyBldmVudE5hbWUsIHsgdGFyZ2V0OiB0YXJnZXQsIGU6IGUgfSk7XG4gICAgICB0YXJnZXQuZmlyZShldmVudE5hbWUsIHsgZTogZSB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYmVmb3JlU2NhbGVUcmFuc2Zvcm06IGZ1bmN0aW9uKGUsIHRyYW5zZm9ybSkge1xuICAgICAgaWYgKHRyYW5zZm9ybS5hY3Rpb24gPT09ICdzY2FsZScgfHwgdHJhbnNmb3JtLmFjdGlvbiA9PT0gJ3NjYWxlWCcgfHwgdHJhbnNmb3JtLmFjdGlvbiA9PT0gJ3NjYWxlWScpIHtcbiAgICAgICAgdmFyIGNlbnRlclRyYW5zZm9ybSA9IHRoaXMuX3Nob3VsZENlbnRlclRyYW5zZm9ybSh0cmFuc2Zvcm0udGFyZ2V0KTtcblxuICAgICAgICAvLyBTd2l0Y2ggZnJvbSBhIG5vcm1hbCByZXNpemUgdG8gY2VudGVyLWJhc2VkXG4gICAgICAgIGlmICgoY2VudGVyVHJhbnNmb3JtICYmICh0cmFuc2Zvcm0ub3JpZ2luWCAhPT0gJ2NlbnRlcicgfHwgdHJhbnNmb3JtLm9yaWdpblkgIT09ICdjZW50ZXInKSkgfHxcbiAgICAgICAgICAgLy8gU3dpdGNoIGZyb20gY2VudGVyLWJhc2VkIHJlc2l6ZSB0byBub3JtYWwgb25lXG4gICAgICAgICAgICghY2VudGVyVHJhbnNmb3JtICYmIHRyYW5zZm9ybS5vcmlnaW5YID09PSAnY2VudGVyJyAmJiB0cmFuc2Zvcm0ub3JpZ2luWSA9PT0gJ2NlbnRlcicpXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMuX3Jlc2V0Q3VycmVudFRyYW5zZm9ybSgpO1xuICAgICAgICAgIHRyYW5zZm9ybS5yZXNldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gY3VycmVudCB0cmFuZm9ybVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IG1vdXNlIHBvc2l0aW9uIHggZnJvbSBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBtb3VzZSBwb2lzdGlvbiB5IGZyb20gb3JpZ2luXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2NhbGluZyBvY2N1cnJlZFxuICAgICAqL1xuICAgIF9vblNjYWxlOiBmdW5jdGlvbihlLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICAgIGlmICgoZVt0aGlzLnVuaVNjYWxlS2V5XSB8fCB0aGlzLnVuaVNjYWxlVHJhbnNmb3JtKSAmJiAhdHJhbnNmb3JtLnRhcmdldC5nZXQoJ2xvY2tVbmlTY2FsaW5nJykpIHtcbiAgICAgICAgdHJhbnNmb3JtLmN1cnJlbnRBY3Rpb24gPSAnc2NhbGUnO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGVPYmplY3QoeCwgeSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gU3dpdGNoIGZyb20gYSBub3JtYWwgcmVzaXplIHRvIHByb3BvcnRpb25hbFxuICAgICAgICBpZiAoIXRyYW5zZm9ybS5yZXNldCAmJiB0cmFuc2Zvcm0uY3VycmVudEFjdGlvbiA9PT0gJ3NjYWxlJykge1xuICAgICAgICAgIHRoaXMuX3Jlc2V0Q3VycmVudFRyYW5zZm9ybSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhbnNmb3JtLmN1cnJlbnRBY3Rpb24gPSAnc2NhbGVFcXVhbGx5JztcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlT2JqZWN0KHgsIHksICdlcXVhbGx5Jyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnNvciBkZXBlbmRpbmcgb24gd2hlcmUgdGhlIGNhbnZhcyBpcyBiZWluZyBob3ZlcmVkLlxuICAgICAqIE5vdGU6IHZlcnkgYnVnZ3kgaW4gT3BlcmFcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgT2JqZWN0IHRoYXQgdGhlIG1vdXNlIGlzIGhvdmVyaW5nLCBpZiBzby5cbiAgICAgKi9cbiAgICBfc2V0Q3Vyc29yRnJvbUV2ZW50OiBmdW5jdGlvbiAoZSwgdGFyZ2V0KSB7XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICB0aGlzLnNldEN1cnNvcih0aGlzLmRlZmF1bHRDdXJzb3IpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBob3ZlckN1cnNvciA9IHRhcmdldC5ob3ZlckN1cnNvciB8fCB0aGlzLmhvdmVyQ3Vyc29yO1xuICAgICAgaWYgKCF0YXJnZXQuc2VsZWN0YWJsZSkge1xuICAgICAgICAvL2xldCdzIHNraXAgX2ZpbmRUYXJnZXRDb3JuZXIgaWYgb2JqZWN0IGlzIG5vdCBzZWxlY3RhYmxlXG4gICAgICAgIHRoaXMuc2V0Q3Vyc29yKGhvdmVyQ3Vyc29yKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgYWN0aXZlR3JvdXAgPSB0aGlzLmdldEFjdGl2ZUdyb3VwKCksXG4gICAgICAgICAgICAvLyBvbmx5IHNob3cgcHJvcGVyIGNvcm5lciB3aGVuIGdyb3VwIHNlbGVjdGlvbiBpcyBub3QgYWN0aXZlXG4gICAgICAgICAgICBjb3JuZXIgPSB0YXJnZXQuX2ZpbmRUYXJnZXRDb3JuZXJcbiAgICAgICAgICAgICAgICAgICAgICAmJiAoIWFjdGl2ZUdyb3VwIHx8ICFhY3RpdmVHcm91cC5jb250YWlucyh0YXJnZXQpKVxuICAgICAgICAgICAgICAgICAgICAgICYmIHRhcmdldC5fZmluZFRhcmdldENvcm5lcih0aGlzLmdldFBvaW50ZXIoZSwgdHJ1ZSkpO1xuXG4gICAgICAgIGlmICghY29ybmVyKSB7XG4gICAgICAgICAgdGhpcy5zZXRDdXJzb3IoaG92ZXJDdXJzb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NldENvcm5lckN1cnNvcihjb3JuZXIsIHRhcmdldCwgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vYWN0dWFsbHkgdW5jbGVhciB3aHkgaXQgc2hvdWxkIHJldHVybiBzb21ldGhpbmdcbiAgICAgIC8vaXMgbmV2ZXIgZXZhbHVhdGVkXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0Q29ybmVyQ3Vyc29yOiBmdW5jdGlvbihjb3JuZXIsIHRhcmdldCwgZSkge1xuICAgICAgaWYgKGNvcm5lciBpbiBjdXJzb3JPZmZzZXQpIHtcbiAgICAgICAgdGhpcy5zZXRDdXJzb3IodGhpcy5fZ2V0Um90YXRlZENvcm5lckN1cnNvcihjb3JuZXIsIHRhcmdldCwgZSkpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY29ybmVyID09PSAnbXRyJyAmJiB0YXJnZXQuaGFzUm90YXRpbmdQb2ludCkge1xuICAgICAgICB0aGlzLnNldEN1cnNvcih0aGlzLnJvdGF0aW9uQ3Vyc29yKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnNldEN1cnNvcih0aGlzLmRlZmF1bHRDdXJzb3IpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFJvdGF0ZWRDb3JuZXJDdXJzb3I6IGZ1bmN0aW9uKGNvcm5lciwgdGFyZ2V0LCBlKSB7XG4gICAgICB2YXIgbiA9IE1hdGgucm91bmQoKHRhcmdldC5nZXRBbmdsZSgpICUgMzYwKSAvIDQ1KTtcblxuICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgIG4gKz0gODsgLy8gZnVsbCBjaXJjbGUgYWhlYWRcbiAgICAgIH1cbiAgICAgIG4gKz0gY3Vyc29yT2Zmc2V0W2Nvcm5lcl07XG4gICAgICBpZiAoZVt0aGlzLmFsdEFjdGlvbktleV0gJiYgY3Vyc29yT2Zmc2V0W2Nvcm5lcl0gJSAyID09PSAwKSB7XG4gICAgICAgIC8vaWYgd2UgYXJlIGhvbGRpbmcgc2hpZnQgYW5kIHdlIGFyZSBvbiBhIG14IGNvcm5lci4uLlxuICAgICAgICBuICs9IDI7XG4gICAgICB9XG4gICAgICAvLyBub3JtYWxpemUgbiB0byBiZSBmcm9tIDAgdG8gN1xuICAgICAgbiAlPSA4O1xuXG4gICAgICByZXR1cm4gdGhpcy5jdXJzb3JNYXBbbl07XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBtaW4gPSBNYXRoLm1pbixcbiAgICAgIG1heCA9IE1hdGgubWF4O1xuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLkNhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLkNhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBfc2hvdWxkR3JvdXA6IGZ1bmN0aW9uKGUsIHRhcmdldCkge1xuICAgICAgdmFyIGFjdGl2ZU9iamVjdCA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0KCk7XG4gICAgICByZXR1cm4gZVt0aGlzLnNlbGVjdGlvbktleV0gJiYgdGFyZ2V0ICYmIHRhcmdldC5zZWxlY3RhYmxlICYmXG4gICAgICAgICAgICAodGhpcy5nZXRBY3RpdmVHcm91cCgpIHx8IChhY3RpdmVPYmplY3QgJiYgYWN0aXZlT2JqZWN0ICE9PSB0YXJnZXQpKVxuICAgICAgICAgICAgJiYgdGhpcy5zZWxlY3Rpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldFxuICAgICAqL1xuICAgIF9oYW5kbGVHcm91cGluZzogZnVuY3Rpb24gKGUsIHRhcmdldCkge1xuICAgICAgdmFyIGFjdGl2ZUdyb3VwID0gdGhpcy5nZXRBY3RpdmVHcm91cCgpO1xuXG4gICAgICBpZiAodGFyZ2V0ID09PSBhY3RpdmVHcm91cCkge1xuICAgICAgICAvLyBpZiBpdCdzIGEgZ3JvdXAsIGZpbmQgdGFyZ2V0IGFnYWluLCB1c2luZyBhY3RpdmVHcm91cCBvYmplY3RzXG4gICAgICAgIHRhcmdldCA9IHRoaXMuZmluZFRhcmdldChlLCB0cnVlKTtcbiAgICAgICAgLy8gaWYgZXZlbiBvYmplY3QgaXMgbm90IGZvdW5kLCBiYWlsIG91dFxuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFjdGl2ZUdyb3VwKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUFjdGl2ZUdyb3VwKHRhcmdldCwgZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlQWN0aXZlR3JvdXAodGFyZ2V0LCBlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2FjdGl2ZUdyb3VwKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUdyb3VwLnNhdmVDb29yZHMoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlQWN0aXZlR3JvdXA6IGZ1bmN0aW9uKHRhcmdldCwgZSkge1xuICAgICAgdmFyIGFjdGl2ZUdyb3VwID0gdGhpcy5nZXRBY3RpdmVHcm91cCgpO1xuXG4gICAgICBpZiAoYWN0aXZlR3JvdXAuY29udGFpbnModGFyZ2V0KSkge1xuXG4gICAgICAgIGFjdGl2ZUdyb3VwLnJlbW92ZVdpdGhVcGRhdGUodGFyZ2V0KTtcbiAgICAgICAgdGFyZ2V0LnNldCgnYWN0aXZlJywgZmFsc2UpO1xuXG4gICAgICAgIGlmIChhY3RpdmVHcm91cC5zaXplKCkgPT09IDEpIHtcbiAgICAgICAgICAvLyByZW1vdmUgZ3JvdXAgYWxsdG9nZXRoZXIgaWYgYWZ0ZXIgcmVtb3ZhbCBpdCBvbmx5IGNvbnRhaW5zIDEgb2JqZWN0XG4gICAgICAgICAgdGhpcy5kaXNjYXJkQWN0aXZlR3JvdXAoZSk7XG4gICAgICAgICAgLy8gYWN0aXZhdGUgbGFzdCByZW1haW5pbmcgb2JqZWN0XG4gICAgICAgICAgdGhpcy5zZXRBY3RpdmVPYmplY3QoYWN0aXZlR3JvdXAuaXRlbSgwKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYWN0aXZlR3JvdXAuYWRkV2l0aFVwZGF0ZSh0YXJnZXQpO1xuICAgICAgfVxuICAgICAgdGhpcy5maXJlKCdzZWxlY3Rpb246Y3JlYXRlZCcsIHsgdGFyZ2V0OiBhY3RpdmVHcm91cCwgZTogZSB9KTtcbiAgICAgIGFjdGl2ZUdyb3VwLnNldCgnYWN0aXZlJywgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZUFjdGl2ZUdyb3VwOiBmdW5jdGlvbih0YXJnZXQsIGUpIHtcblxuICAgICAgaWYgKHRoaXMuX2FjdGl2ZU9iamVjdCAmJiB0YXJnZXQgIT09IHRoaXMuX2FjdGl2ZU9iamVjdCkge1xuXG4gICAgICAgIHZhciBncm91cCA9IHRoaXMuX2NyZWF0ZUdyb3VwKHRhcmdldCk7XG4gICAgICAgIGdyb3VwLmFkZFdpdGhVcGRhdGUoKTtcblxuICAgICAgICB0aGlzLnNldEFjdGl2ZUdyb3VwKGdyb3VwKTtcbiAgICAgICAgdGhpcy5fYWN0aXZlT2JqZWN0ID0gbnVsbDtcblxuICAgICAgICB0aGlzLmZpcmUoJ3NlbGVjdGlvbjpjcmVhdGVkJywgeyB0YXJnZXQ6IGdyb3VwLCBlOiBlIH0pO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXQuc2V0KCdhY3RpdmUnLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgX2NyZWF0ZUdyb3VwOiBmdW5jdGlvbih0YXJnZXQpIHtcblxuICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLmdldE9iamVjdHMoKSxcbiAgICAgICAgICBpc0FjdGl2ZUxvd2VyID0gb2JqZWN0cy5pbmRleE9mKHRoaXMuX2FjdGl2ZU9iamVjdCkgPCBvYmplY3RzLmluZGV4T2YodGFyZ2V0KSxcbiAgICAgICAgICBncm91cE9iamVjdHMgPSBpc0FjdGl2ZUxvd2VyXG4gICAgICAgICAgICA/IFt0aGlzLl9hY3RpdmVPYmplY3QsIHRhcmdldF1cbiAgICAgICAgICAgIDogW3RhcmdldCwgdGhpcy5fYWN0aXZlT2JqZWN0XTtcbiAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdC5pc0VkaXRpbmcgJiYgdGhpcy5fYWN0aXZlT2JqZWN0LmV4aXRFZGl0aW5nKCk7XG4gICAgICByZXR1cm4gbmV3IGZhYnJpYy5Hcm91cChncm91cE9iamVjdHMsIHtcbiAgICAgICAgY2FudmFzOiB0aGlzXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIG1vdXNlIGV2ZW50XG4gICAgICovXG4gICAgX2dyb3VwU2VsZWN0ZWRPYmplY3RzOiBmdW5jdGlvbiAoZSkge1xuXG4gICAgICB2YXIgZ3JvdXAgPSB0aGlzLl9jb2xsZWN0T2JqZWN0cygpO1xuXG4gICAgICAvLyBkbyBub3QgY3JlYXRlIGdyb3VwIGZvciAxIGVsZW1lbnQgb25seVxuICAgICAgaWYgKGdyb3VwLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGlzLnNldEFjdGl2ZU9iamVjdChncm91cFswXSwgZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChncm91cC5sZW5ndGggPiAxKSB7XG4gICAgICAgIGdyb3VwID0gbmV3IGZhYnJpYy5Hcm91cChncm91cC5yZXZlcnNlKCksIHtcbiAgICAgICAgICBjYW52YXM6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIGdyb3VwLmFkZFdpdGhVcGRhdGUoKTtcbiAgICAgICAgdGhpcy5zZXRBY3RpdmVHcm91cChncm91cCwgZSk7XG4gICAgICAgIGdyb3VwLnNhdmVDb29yZHMoKTtcbiAgICAgICAgdGhpcy5maXJlKCdzZWxlY3Rpb246Y3JlYXRlZCcsIHsgdGFyZ2V0OiBncm91cCB9KTtcbiAgICAgICAgdGhpcy5yZW5kZXJBbGwoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY29sbGVjdE9iamVjdHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGdyb3VwID0gW10sXG4gICAgICAgICAgY3VycmVudE9iamVjdCxcbiAgICAgICAgICB4MSA9IHRoaXMuX2dyb3VwU2VsZWN0b3IuZXgsXG4gICAgICAgICAgeTEgPSB0aGlzLl9ncm91cFNlbGVjdG9yLmV5LFxuICAgICAgICAgIHgyID0geDEgKyB0aGlzLl9ncm91cFNlbGVjdG9yLmxlZnQsXG4gICAgICAgICAgeTIgPSB5MSArIHRoaXMuX2dyb3VwU2VsZWN0b3IudG9wLFxuICAgICAgICAgIHNlbGVjdGlvblgxWTEgPSBuZXcgZmFicmljLlBvaW50KG1pbih4MSwgeDIpLCBtaW4oeTEsIHkyKSksXG4gICAgICAgICAgc2VsZWN0aW9uWDJZMiA9IG5ldyBmYWJyaWMuUG9pbnQobWF4KHgxLCB4MiksIG1heCh5MSwgeTIpKSxcbiAgICAgICAgICBpc0NsaWNrID0geDEgPT09IHgyICYmIHkxID09PSB5MjtcblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICBjdXJyZW50T2JqZWN0ID0gdGhpcy5fb2JqZWN0c1tpXTtcblxuICAgICAgICBpZiAoIWN1cnJlbnRPYmplY3QgfHwgIWN1cnJlbnRPYmplY3Quc2VsZWN0YWJsZSB8fCAhY3VycmVudE9iamVjdC52aXNpYmxlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudE9iamVjdC5pbnRlcnNlY3RzV2l0aFJlY3Qoc2VsZWN0aW9uWDFZMSwgc2VsZWN0aW9uWDJZMikgfHxcbiAgICAgICAgICAgIGN1cnJlbnRPYmplY3QuaXNDb250YWluZWRXaXRoaW5SZWN0KHNlbGVjdGlvblgxWTEsIHNlbGVjdGlvblgyWTIpIHx8XG4gICAgICAgICAgICBjdXJyZW50T2JqZWN0LmNvbnRhaW5zUG9pbnQoc2VsZWN0aW9uWDFZMSkgfHxcbiAgICAgICAgICAgIGN1cnJlbnRPYmplY3QuY29udGFpbnNQb2ludChzZWxlY3Rpb25YMlkyKVxuICAgICAgICApIHtcbiAgICAgICAgICBjdXJyZW50T2JqZWN0LnNldCgnYWN0aXZlJywgdHJ1ZSk7XG4gICAgICAgICAgZ3JvdXAucHVzaChjdXJyZW50T2JqZWN0KTtcblxuICAgICAgICAgIC8vIG9ubHkgYWRkIG9uZSBvYmplY3QgaWYgaXQncyBhIGNsaWNrXG4gICAgICAgICAgaWYgKGlzQ2xpY2spIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21heWJlR3JvdXBPYmplY3RzOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb24gJiYgdGhpcy5fZ3JvdXBTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLl9ncm91cFNlbGVjdGVkT2JqZWN0cyhlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFjdGl2ZUdyb3VwID0gdGhpcy5nZXRBY3RpdmVHcm91cCgpO1xuICAgICAgaWYgKGFjdGl2ZUdyb3VwKSB7XG4gICAgICAgIGFjdGl2ZUdyb3VwLnNldE9iamVjdHNDb29yZHMoKS5zZXRDb29yZHMoKTtcbiAgICAgICAgYWN0aXZlR3JvdXAuaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZXRDdXJzb3IodGhpcy5kZWZhdWx0Q3Vyc29yKTtcbiAgICAgIH1cblxuICAgICAgLy8gY2xlYXIgc2VsZWN0aW9uIGFuZCBjdXJyZW50IHRyYW5zZm9ybWF0aW9uXG4gICAgICB0aGlzLl9ncm91cFNlbGVjdG9yID0gbnVsbDtcbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0gPSBudWxsO1xuICAgIH1cbiAgfSk7XG5cbn0pKCk7XG5cblxuKGZ1bmN0aW9uICgpIHtcblxuICB2YXIgc3VwcG9ydFF1YWxpdHkgPSBmYWJyaWMuU3RhdGljQ2FudmFzLnN1cHBvcnRzKCd0b0RhdGFVUkxXaXRoUXVhbGl0eScpO1xuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRXhwb3J0cyBjYW52YXMgZWxlbWVudCB0byBhIGRhdGF1cmwgaW1hZ2UuIE5vdGUgdGhhdCB3aGVuIG11bHRpcGxpZXIgaXMgdXNlZCwgY3JvcHBpbmcgaXMgc2NhbGVkIGFwcHJvcHJpYXRlbHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmZvcm1hdD1wbmddIFRoZSBmb3JtYXQgb2YgdGhlIG91dHB1dCBpbWFnZS4gRWl0aGVyIFwianBlZ1wiIG9yIFwicG5nXCJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucXVhbGl0eT0xXSBRdWFsaXR5IGxldmVsICgwLi4xKS4gT25seSB1c2VkIGZvciBqcGVnLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tdWx0aXBsaWVyPTFdIE11bHRpcGxpZXIgdG8gc2NhbGUgYnlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubGVmdF0gQ3JvcHBpbmcgbGVmdCBvZmZzZXQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50b3BdIENyb3BwaW5nIHRvcCBvZmZzZXQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aF0gQ3JvcHBpbmcgd2lkdGguIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHRdIENyb3BwaW5nIGhlaWdodC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBSZXR1cm5zIGEgZGF0YTogVVJMIGNvbnRhaW5pbmcgYSByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0IGluIHRoZSBmb3JtYXQgc3BlY2lmaWVkIGJ5IG9wdGlvbnMuZm9ybWF0XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9OZlpWYi98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5HZW5lcmF0ZSBqcGVnIGRhdGFVUkwgd2l0aCBsb3dlciBxdWFsaXR5PC9jYXB0aW9uPlxuICAgICAqIHZhciBkYXRhVVJMID0gY2FudmFzLnRvRGF0YVVSTCh7XG4gICAgICogICBmb3JtYXQ6ICdqcGVnJyxcbiAgICAgKiAgIHF1YWxpdHk6IDAuOFxuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkdlbmVyYXRlIGNyb3BwZWQgcG5nIGRhdGFVUkwgKGNsaXBwaW5nIG9mIGNhbnZhcyk8L2NhcHRpb24+XG4gICAgICogdmFyIGRhdGFVUkwgPSBjYW52YXMudG9EYXRhVVJMKHtcbiAgICAgKiAgIGZvcm1hdDogJ3BuZycsXG4gICAgICogICBsZWZ0OiAxMDAsXG4gICAgICogICB0b3A6IDEwMCxcbiAgICAgKiAgIHdpZHRoOiAyMDAsXG4gICAgICogICBoZWlnaHQ6IDIwMFxuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkdlbmVyYXRlIGRvdWJsZSBzY2FsZWQgcG5nIGRhdGFVUkw8L2NhcHRpb24+XG4gICAgICogdmFyIGRhdGFVUkwgPSBjYW52YXMudG9EYXRhVVJMKHtcbiAgICAgKiAgIGZvcm1hdDogJ3BuZycsXG4gICAgICogICBtdWx0aXBsaWVyOiAyXG4gICAgICogfSk7XG4gICAgICovXG4gICAgdG9EYXRhVVJMOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHZhciBmb3JtYXQgPSBvcHRpb25zLmZvcm1hdCB8fCAncG5nJyxcbiAgICAgICAgICBxdWFsaXR5ID0gb3B0aW9ucy5xdWFsaXR5IHx8IDEsXG4gICAgICAgICAgbXVsdGlwbGllciA9IG9wdGlvbnMubXVsdGlwbGllciB8fCAxLFxuICAgICAgICAgIGNyb3BwaW5nID0ge1xuICAgICAgICAgICAgbGVmdDogb3B0aW9ucy5sZWZ0IHx8IDAsXG4gICAgICAgICAgICB0b3A6IG9wdGlvbnMudG9wIHx8IDAsXG4gICAgICAgICAgICB3aWR0aDogb3B0aW9ucy53aWR0aCB8fCAwLFxuICAgICAgICAgICAgaGVpZ2h0OiBvcHRpb25zLmhlaWdodCB8fCAwLFxuICAgICAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5fX3RvRGF0YVVSTFdpdGhNdWx0aXBsaWVyKGZvcm1hdCwgcXVhbGl0eSwgY3JvcHBpbmcsIG11bHRpcGxpZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9fdG9EYXRhVVJMV2l0aE11bHRpcGxpZXI6IGZ1bmN0aW9uKGZvcm1hdCwgcXVhbGl0eSwgY3JvcHBpbmcsIG11bHRpcGxpZXIpIHtcblxuICAgICAgdmFyIG9yaWdXaWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgICBvcmlnSGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKSxcbiAgICAgICAgICBzY2FsZWRXaWR0aCA9IChjcm9wcGluZy53aWR0aCB8fCB0aGlzLmdldFdpZHRoKCkpICogbXVsdGlwbGllcixcbiAgICAgICAgICBzY2FsZWRIZWlnaHQgPSAoY3JvcHBpbmcuaGVpZ2h0IHx8IHRoaXMuZ2V0SGVpZ2h0KCkpICogbXVsdGlwbGllcixcbiAgICAgICAgICB6b29tID0gdGhpcy5nZXRab29tKCksXG4gICAgICAgICAgbmV3Wm9vbSA9IHpvb20gKiBtdWx0aXBsaWVyLFxuICAgICAgICAgIHZwID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybSxcbiAgICAgICAgICB0cmFuc2xhdGVYID0gKHZwWzRdIC0gY3JvcHBpbmcubGVmdCkgKiBtdWx0aXBsaWVyLFxuICAgICAgICAgIHRyYW5zbGF0ZVkgPSAodnBbNV0gLSBjcm9wcGluZy50b3ApICogbXVsdGlwbGllcixcbiAgICAgICAgICBuZXdWcCA9IFtuZXdab29tLCAwLCAwLCBuZXdab29tLCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZXSxcbiAgICAgICAgICBvcmlnaW5hbEludGVyYWN0aXZlID0gdGhpcy5pbnRlcmFjdGl2ZTtcblxuICAgICAgdGhpcy52aWV3cG9ydFRyYW5zZm9ybSA9IG5ld1ZwO1xuICAgICAgLy8gc2V0dGluZyBpbnRlcmFjdGl2ZSB0byBmYWxzZSBhdm9pZCBleHBvcnRpbmcgY29udHJvbHNcbiAgICAgIHRoaXMuaW50ZXJhY3RpdmUgJiYgKHRoaXMuaW50ZXJhY3RpdmUgPSBmYWxzZSk7XG4gICAgICBpZiAob3JpZ1dpZHRoICE9PSBzY2FsZWRXaWR0aCB8fCBvcmlnSGVpZ2h0ICE9PSBzY2FsZWRIZWlnaHQpIHtcbiAgICAgICAgLy8gdGhpcy5zZXREaW1lbnNpb25zIGlzIGdvaW5nIHRvIHJlbmRlckFsbCBhbHNvO1xuICAgICAgICB0aGlzLnNldERpbWVuc2lvbnMoeyB3aWR0aDogc2NhbGVkV2lkdGgsIGhlaWdodDogc2NhbGVkSGVpZ2h0IH0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMucmVuZGVyQWxsKCk7XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX190b0RhdGFVUkwoZm9ybWF0LCBxdWFsaXR5LCBjcm9wcGluZyk7XG4gICAgICBvcmlnaW5hbEludGVyYWN0aXZlICYmICh0aGlzLmludGVyYWN0aXZlID0gb3JpZ2luYWxJbnRlcmFjdGl2ZSk7XG4gICAgICB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtID0gdnA7XG4gICAgICAvL3NldERpbWVuc2lvbnMgd2l0aCBubyBvcHRpb24gb2JqZWN0IGlzIHRha2luZyBjYXJlIG9mOlxuICAgICAgLy90aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5yZW5kZXJBbGwoKVxuICAgICAgdGhpcy5zZXREaW1lbnNpb25zKHsgd2lkdGg6IG9yaWdXaWR0aCwgaGVpZ2h0OiBvcmlnSGVpZ2h0IH0pO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX190b0RhdGFVUkw6IGZ1bmN0aW9uKGZvcm1hdCwgcXVhbGl0eSkge1xuXG4gICAgICB2YXIgY2FudmFzRWwgPSB0aGlzLmNvbnRleHRDb250YWluZXIuY2FudmFzO1xuICAgICAgLy8gdG8gYXZvaWQgY29tbW9uIGNvbmZ1c2lvbiBodHRwczovL2dpdGh1Yi5jb20va2FuZ2F4L2ZhYnJpYy5qcy9pc3N1ZXMvODA2XG4gICAgICBpZiAoZm9ybWF0ID09PSAnanBnJykge1xuICAgICAgICBmb3JtYXQgPSAnanBlZyc7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhID0gc3VwcG9ydFF1YWxpdHlcbiAgICAgICAgICAgICAgICA/IGNhbnZhc0VsLnRvRGF0YVVSTCgnaW1hZ2UvJyArIGZvcm1hdCwgcXVhbGl0eSlcbiAgICAgICAgICAgICAgICA6IGNhbnZhc0VsLnRvRGF0YVVSTCgnaW1hZ2UvJyArIGZvcm1hdCk7XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeHBvcnRzIGNhbnZhcyBlbGVtZW50IHRvIGEgZGF0YXVybCBpbWFnZSAoYWxsb3dpbmcgdG8gY2hhbmdlIGltYWdlIHNpemUgdmlhIG11bHRpcGxpZXIpLlxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIDEuMC4xM1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXQgKHBuZ3xqcGVnKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtdWx0aXBsaWVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHF1YWxpdHkgKDAuLjEpXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvRGF0YVVSTFdpdGhNdWx0aXBsaWVyOiBmdW5jdGlvbiAoZm9ybWF0LCBtdWx0aXBsaWVyLCBxdWFsaXR5KSB7XG4gICAgICByZXR1cm4gdGhpcy50b0RhdGFVUkwoe1xuICAgICAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICAgICAgbXVsdGlwbGllcjogbXVsdGlwbGllcixcbiAgICAgICAgcXVhbGl0eTogcXVhbGl0eVxuICAgICAgfSk7XG4gICAgfSxcbiAgfSk7XG5cbn0pKCk7XG5cblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIFBvcHVsYXRlcyBjYW52YXMgd2l0aCBkYXRhIGZyb20gdGhlIHNwZWNpZmllZCBkYXRhbGVzcyBKU09OLlxuICAgKiBKU09OIGZvcm1hdCBtdXN0IGNvbmZvcm0gdG8gdGhlIG9uZSBvZiB7QGxpbmsgZmFicmljLkNhbnZhcyN0b0RhdGFsZXNzSlNPTn1cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgMS4yLjJcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBqc29uIEpTT04gc3RyaW5nIG9yIG9iamVjdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjaywgaW52b2tlZCB3aGVuIGpzb24gaXMgcGFyc2VkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBjb3JyZXNwb25kaW5nIG9iamVjdHMgKGUuZzoge0BsaW5rIGZhYnJpYy5JbWFnZX0pXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBpbml0aWFsaXplZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgSlNPTiBlbGVtZW50cywgY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjcmVhdGVkLlxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgKiBAY2hhaW5hYmxlXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0zI2Rlc2VyaWFsaXphdGlvbn1cbiAgICovXG4gIGxvYWRGcm9tRGF0YWxlc3NKU09OOiBmdW5jdGlvbiAoanNvbiwgY2FsbGJhY2ssIHJldml2ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkRnJvbUpTT04oanNvbiwgY2FsbGJhY2ssIHJldml2ZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQb3B1bGF0ZXMgY2FudmFzIHdpdGggZGF0YSBmcm9tIHRoZSBzcGVjaWZpZWQgSlNPTi5cbiAgICogSlNPTiBmb3JtYXQgbXVzdCBjb25mb3JtIHRvIHRoZSBvbmUgb2Yge0BsaW5rIGZhYnJpYy5DYW52YXMjdG9KU09OfVxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGpzb24gSlNPTiBzdHJpbmcgb3Igb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrLCBpbnZva2VkIHdoZW4ganNvbiBpcyBwYXJzZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIGNvcnJlc3BvbmRpbmcgb2JqZWN0cyAoZS5nOiB7QGxpbmsgZmFicmljLkltYWdlfSlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIGluaXRpYWxpemVkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBKU09OIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAqIEBjaGFpbmFibGVcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTMjZGVzZXJpYWxpemF0aW9ufVxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL2ZtZ1h0L3xqc0ZpZGRsZSBkZW1vfVxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5sb2FkRnJvbUpTT048L2NhcHRpb24+XG4gICAqIGNhbnZhcy5sb2FkRnJvbUpTT04oanNvbiwgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5sb2FkRnJvbUpTT04gd2l0aCByZXZpdmVyPC9jYXB0aW9uPlxuICAgKiBjYW52YXMubG9hZEZyb21KU09OKGpzb24sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCBmdW5jdGlvbihvLCBvYmplY3QpIHtcbiAgICogICAvLyBgb2AgPSBqc29uIG9iamVjdFxuICAgKiAgIC8vIGBvYmplY3RgID0gZmFicmljLk9iamVjdCBpbnN0YW5jZVxuICAgKiAgIC8vIC4uLiBkbyBzb21lIHN0dWZmIC4uLlxuICAgKiB9KTtcbiAgICovXG4gIGxvYWRGcm9tSlNPTjogZnVuY3Rpb24gKGpzb24sIGNhbGxiYWNrLCByZXZpdmVyKSB7XG4gICAgaWYgKCFqc29uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc2VyaWFsaXplIGlmIGl0IHdhc24ndCBhbHJlYWR5XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSAodHlwZW9mIGpzb24gPT09ICdzdHJpbmcnKVxuICAgICAgPyBKU09OLnBhcnNlKGpzb24pXG4gICAgICA6IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShqc29uKTtcblxuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5fZW5saXZlbk9iamVjdHMoc2VyaWFsaXplZC5vYmplY3RzLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5fc2V0QmdPdmVybGF5KHNlcmlhbGl6ZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHBhcnRzIGkgY2Fubm90IHNldCBhcyBvcHRpb25zXG4gICAgICAgIGRlbGV0ZSBzZXJpYWxpemVkLm9iamVjdHM7XG4gICAgICAgIGRlbGV0ZSBzZXJpYWxpemVkLmJhY2tncm91bmRJbWFnZTtcbiAgICAgICAgZGVsZXRlIHNlcmlhbGl6ZWQub3ZlcmxheUltYWdlO1xuICAgICAgICBkZWxldGUgc2VyaWFsaXplZC5iYWNrZ3JvdW5kO1xuICAgICAgICBkZWxldGUgc2VyaWFsaXplZC5vdmVybGF5O1xuICAgICAgICAvLyB0aGlzLl9pbml0T3B0aW9ucyBkb2VzIHRvbyBtYW55IHRoaW5ncyB0byBqdXN0XG4gICAgICAgIC8vIGNhbGwgaXQuIE5vcm1hbGx5IGxvYWRpbmcgYW4gT2JqZWN0IGZyb20gSlNPTlxuICAgICAgICAvLyBjcmVhdGUgdGhlIE9iamVjdCBpbnN0YW5jZS4gSGVyZSB0aGUgQ2FudmFzIGlzXG4gICAgICAgIC8vIGFscmVhZHkgYW4gaW5zdGFuY2UgYW5kIHdlIGFyZSBqdXN0IGxvYWRpbmcgdGhpbmdzIG92ZXIgaXRcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzZXJpYWxpemVkKSB7XG4gICAgICAgICAgX3RoaXNbcHJvcF0gPSBzZXJpYWxpemVkW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICB9LCByZXZpdmVyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNlcmlhbGl6ZWQgT2JqZWN0IHdpdGggYmFja2dyb3VuZCBhbmQgb3ZlcmxheSBpbmZvcm1hdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBJbnZva2VkIGFmdGVyIGFsbCBiYWNrZ3JvdW5kIGFuZCBvdmVybGF5IGltYWdlcy9wYXR0ZXJucyBsb2FkZWRcbiAgICovXG4gIF9zZXRCZ092ZXJsYXk6IGZ1bmN0aW9uKHNlcmlhbGl6ZWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgbG9hZGVkID0ge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogZmFsc2UsXG4gICAgICAgICAgb3ZlcmxheUNvbG9yOiBmYWxzZSxcbiAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGZhbHNlLFxuICAgICAgICAgIG92ZXJsYXlJbWFnZTogZmFsc2VcbiAgICAgICAgfTtcblxuICAgIGlmICghc2VyaWFsaXplZC5iYWNrZ3JvdW5kSW1hZ2UgJiYgIXNlcmlhbGl6ZWQub3ZlcmxheUltYWdlICYmICFzZXJpYWxpemVkLmJhY2tncm91bmQgJiYgIXNlcmlhbGl6ZWQub3ZlcmxheSkge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2JJZkxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChsb2FkZWQuYmFja2dyb3VuZEltYWdlICYmIGxvYWRlZC5vdmVybGF5SW1hZ2UgJiYgbG9hZGVkLmJhY2tncm91bmRDb2xvciAmJiBsb2FkZWQub3ZlcmxheUNvbG9yKSB7XG4gICAgICAgIF90aGlzLnJlbmRlckFsbCgpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLl9fc2V0QmdPdmVybGF5KCdiYWNrZ3JvdW5kSW1hZ2UnLCBzZXJpYWxpemVkLmJhY2tncm91bmRJbWFnZSwgbG9hZGVkLCBjYklmTG9hZGVkKTtcbiAgICB0aGlzLl9fc2V0QmdPdmVybGF5KCdvdmVybGF5SW1hZ2UnLCBzZXJpYWxpemVkLm92ZXJsYXlJbWFnZSwgbG9hZGVkLCBjYklmTG9hZGVkKTtcbiAgICB0aGlzLl9fc2V0QmdPdmVybGF5KCdiYWNrZ3JvdW5kQ29sb3InLCBzZXJpYWxpemVkLmJhY2tncm91bmQsIGxvYWRlZCwgY2JJZkxvYWRlZCk7XG4gICAgdGhpcy5fX3NldEJnT3ZlcmxheSgnb3ZlcmxheUNvbG9yJywgc2VyaWFsaXplZC5vdmVybGF5LCBsb2FkZWQsIGNiSWZMb2FkZWQpO1xuXG4gICAgY2JJZkxvYWRlZCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdG8gc2V0IChiYWNrZ3JvdW5kSW1hZ2UsIG92ZXJsYXlJbWFnZSwgYmFja2dyb3VuZENvbG9yLCBvdmVybGF5Q29sb3IpXG4gICAqIEBwYXJhbSB7KE9iamVjdHxTdHJpbmcpfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGxvYWRlZCBTZXQgbG9hZGVkIHByb3BlcnR5IHRvIHRydWUgaWYgcHJvcGVydHkgaXMgc2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBpbnZva2UgYWZ0ZXIgcHJvcGVydHkgaXMgc2V0XG4gICAqL1xuICBfX3NldEJnT3ZlcmxheTogZnVuY3Rpb24ocHJvcGVydHksIHZhbHVlLCBsb2FkZWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIGxvYWRlZFtwcm9wZXJ0eV0gPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wZXJ0eSA9PT0gJ2JhY2tncm91bmRJbWFnZScgfHwgcHJvcGVydHkgPT09ICdvdmVybGF5SW1hZ2UnKSB7XG4gICAgICBmYWJyaWMuSW1hZ2UuZnJvbU9iamVjdCh2YWx1ZSwgZnVuY3Rpb24oaW1nKSB7XG4gICAgICAgIF90aGlzW3Byb3BlcnR5XSA9IGltZztcbiAgICAgICAgbG9hZGVkW3Byb3BlcnR5XSA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzWydzZXQnICsgZmFicmljLnV0aWwuc3RyaW5nLmNhcGl0YWxpemUocHJvcGVydHksIHRydWUpXSh2YWx1ZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGxvYWRlZFtwcm9wZXJ0eV0gPSB0cnVlO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXVxuICAgKi9cbiAgX2VubGl2ZW5PYmplY3RzOiBmdW5jdGlvbiAob2JqZWN0cywgY2FsbGJhY2ssIHJldml2ZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCFvYmplY3RzIHx8IG9iamVjdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZW5kZXJPbkFkZFJlbW92ZSA9IHRoaXMucmVuZGVyT25BZGRSZW1vdmU7XG4gICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSA9IGZhbHNlO1xuXG4gICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMob2JqZWN0cywgZnVuY3Rpb24oZW5saXZlbmVkT2JqZWN0cykge1xuICAgICAgZW5saXZlbmVkT2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iaiwgaW5kZXgpIHtcbiAgICAgICAgLy8gd2Ugc3BsaWNlIHRoZSBhcnJheSBqdXN0IGluIGNhc2Ugc29tZSBjdXN0b20gY2xhc3NlcyByZXN0b3JlZCBmcm9tIEpTT05cbiAgICAgICAgLy8gd2lsbCBhZGQgbW9yZSBvYmplY3QgdG8gY2FudmFzIGF0IGNhbnZhcyBpbml0LlxuICAgICAgICBfdGhpcy5pbnNlcnRBdChvYmosIGluZGV4KTtcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSA9IHJlbmRlck9uQWRkUmVtb3ZlO1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9LCBudWxsLCByZXZpdmVyKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgX3RvRGF0YVVSTDogZnVuY3Rpb24gKGZvcm1hdCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmNsb25lKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgY2FsbGJhY2soY2xvbmUudG9EYXRhVVJMKGZvcm1hdCkpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtdWx0aXBsaWVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBfdG9EYXRhVVJMV2l0aE11bHRpcGxpZXI6IGZ1bmN0aW9uIChmb3JtYXQsIG11bHRpcGxpZXIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jbG9uZShmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgIGNhbGxiYWNrKGNsb25lLnRvRGF0YVVSTFdpdGhNdWx0aXBsaWVyKGZvcm1hdCwgbXVsdGlwbGllcikpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9uZXMgY2FudmFzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY2FsbGJhY2tdIFJlY2VpdmVzIGNsb25lZCBpbnN0YW5jZSBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzXSBBcnJheSBvZiBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgaW4gdGhlIGNsb25lZCBjYW52YXMgYW5kIGNoaWxkcmVuXG4gICAqL1xuICBjbG9uZTogZnVuY3Rpb24gKGNhbGxiYWNrLCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIGRhdGEgPSBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTihwcm9wZXJ0aWVzKSk7XG4gICAgdGhpcy5jbG9uZVdpdGhvdXREYXRhKGZ1bmN0aW9uKGNsb25lKSB7XG4gICAgICBjbG9uZS5sb2FkRnJvbUpTT04oZGF0YSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGNsb25lKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9uZXMgY2FudmFzIGluc3RhbmNlIHdpdGhvdXQgY2xvbmluZyBleGlzdGluZyBkYXRhLlxuICAgKiBUaGlzIGVzc2VudGlhbGx5IGNvcGllcyBjYW52YXMgZGltZW5zaW9ucywgY2xpcHBpbmcgcHJvcGVydGllcywgZXRjLlxuICAgKiBidXQgbGVhdmVzIGRhdGEgZW1wdHkgKHNvIHRoYXQgeW91IGNhbiBwb3B1bGF0ZSBpdCB3aXRoIHlvdXIgb3duKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NhbGxiYWNrXSBSZWNlaXZlcyBjbG9uZWQgaW5zdGFuY2UgYXMgYSBmaXJzdCBhcmd1bWVudFxuICAgKi9cbiAgY2xvbmVXaXRob3V0RGF0YTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgZWwgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICBlbC53aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICBlbC5oZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xuXG4gICAgdmFyIGNsb25lID0gbmV3IGZhYnJpYy5DYW52YXMoZWwpO1xuICAgIGNsb25lLmNsaXBUbyA9IHRoaXMuY2xpcFRvO1xuICAgIGlmICh0aGlzLmJhY2tncm91bmRJbWFnZSkge1xuICAgICAgY2xvbmUuc2V0QmFja2dyb3VuZEltYWdlKHRoaXMuYmFja2dyb3VuZEltYWdlLnNyYywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsb25lLnJlbmRlckFsbCgpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhjbG9uZSk7XG4gICAgICB9KTtcbiAgICAgIGNsb25lLmJhY2tncm91bmRJbWFnZU9wYWNpdHkgPSB0aGlzLmJhY2tncm91bmRJbWFnZU9wYWNpdHk7XG4gICAgICBjbG9uZS5iYWNrZ3JvdW5kSW1hZ2VTdHJldGNoID0gdGhpcy5iYWNrZ3JvdW5kSW1hZ2VTdHJldGNoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGNsb25lKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkLFxuICAgICAgY2FwaXRhbGl6ZSA9IGZhYnJpYy51dGlsLnN0cmluZy5jYXBpdGFsaXplLFxuICAgICAgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgICBzdXBwb3J0c0xpbmVEYXNoID0gZmFicmljLlN0YXRpY0NhbnZhcy5zdXBwb3J0cygnc2V0TGluZURhc2gnKTtcblxuICBpZiAoZmFicmljLk9iamVjdCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSb290IG9iamVjdCBjbGFzcyBmcm9tIHdoaWNoIGFsbCAyZCBzaGFwZSBjbGFzc2VzIGluaGVyaXQgZnJvbVxuICAgKiBAY2xhc3MgZmFicmljLk9iamVjdFxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMSNvYmplY3RzfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuT2JqZWN0I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqXG4gICAqIEBmaXJlcyBhZGRlZFxuICAgKiBAZmlyZXMgcmVtb3ZlZFxuICAgKlxuICAgKiBAZmlyZXMgc2VsZWN0ZWRcbiAgICogQGZpcmVzIGRlc2VsZWN0ZWRcbiAgICogQGZpcmVzIG1vZGlmaWVkXG4gICAqIEBmaXJlcyByb3RhdGluZ1xuICAgKiBAZmlyZXMgc2NhbGluZ1xuICAgKiBAZmlyZXMgbW92aW5nXG4gICAqIEBmaXJlcyBza2V3aW5nXG4gICAqXG4gICAqIEBmaXJlcyBtb3VzZWRvd25cbiAgICogQGZpcmVzIG1vdXNldXBcbiAgICogQGZpcmVzIG1vdXNlb3ZlclxuICAgKiBAZmlyZXMgbW91c2VvdXRcbiAgICovXG4gIGZhYnJpYy5PYmplY3QgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcygvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCNjbGlwVG98Y2xpcHBpbmcgZnVuY3Rpb259XG4gICAgICogQG1ldGhvZCBnZXRDbGlwVG9cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFNldHMgb2JqZWN0J3Mge0BsaW5rIGZhYnJpYy5PYmplY3QjY2xpcFRvfGNsaXBwaW5nIGZ1bmN0aW9ufVxuICAgICAqIEBtZXRob2Qgc2V0Q2xpcFRvXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2xpcFRvIENsaXBwaW5nIGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCN0cmFuc2Zvcm1NYXRyaXh8dHJhbnNmb3JtTWF0cml4fVxuICAgICAqIEBtZXRob2QgZ2V0VHJhbnNmb3JtTWF0cml4XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7QXJyYXl9IHRyYW5zZm9ybU1hdHJpeFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCN0cmFuc2Zvcm1NYXRyaXh8dHJhbnNmb3JtTWF0cml4fVxuICAgICAqIEBtZXRob2Qgc2V0VHJhbnNmb3JtTWF0cml4XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtTWF0cml4XG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCN2aXNpYmxlfHZpc2libGV9IHN0YXRlXG4gICAgICogQG1ldGhvZCBnZXRWaXNpYmxlXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB2aXNpYmxlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9iamVjdCdzIHtAbGluayBmYWJyaWMuT2JqZWN0I3Zpc2libGV8dmlzaWJsZX0gc3RhdGVcbiAgICAgKiBAbWV0aG9kIHNldFZpc2libGVcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIHZpc2libGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG9iamVjdCdzIHtAbGluayBmYWJyaWMuT2JqZWN0I3NoYWRvd3xzaGFkb3d9XG4gICAgICogQG1ldGhvZCBnZXRTaGFkb3dcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFNoYWRvdyBpbnN0YW5jZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG9iamVjdCdzIHtAbGluayBmYWJyaWMuT2JqZWN0I3N0cm9rZXxzdHJva2V9XG4gICAgICogQG1ldGhvZCBnZXRTdHJva2VcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN0cm9rZSB2YWx1ZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCNzdHJva2V8c3Ryb2tlfVxuICAgICAqIEBtZXRob2Qgc2V0U3Ryb2tlXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIHN0cm9rZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgb2JqZWN0J3Mge0BsaW5rIGZhYnJpYy5PYmplY3Qjc3Ryb2tlV2lkdGh8c3Ryb2tlV2lkdGh9XG4gICAgICogQG1ldGhvZCBnZXRTdHJva2VXaWR0aFxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gc3Ryb2tlV2lkdGggdmFsdWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFNldHMgb2JqZWN0J3Mge0BsaW5rIGZhYnJpYy5PYmplY3Qjc3Ryb2tlV2lkdGh8c3Ryb2tlV2lkdGh9XG4gICAgICogQG1ldGhvZCBzZXRTdHJva2VXaWR0aFxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBzdHJva2VXaWR0aCB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgb2JqZWN0J3Mge0BsaW5rIGZhYnJpYy5PYmplY3Qjb3JpZ2luWHxvcmlnaW5YfVxuICAgICAqIEBtZXRob2QgZ2V0T3JpZ2luWFxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gb3JpZ2luWCB2YWx1ZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCNvcmlnaW5YfG9yaWdpblh9XG4gICAgICogQG1ldGhvZCBzZXRPcmlnaW5YXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIG9yaWdpblggdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG9iamVjdCdzIHtAbGluayBmYWJyaWMuT2JqZWN0I29yaWdpbll8b3JpZ2luWX1cbiAgICAgKiBAbWV0aG9kIGdldE9yaWdpbllcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IG9yaWdpblkgdmFsdWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFNldHMgb2JqZWN0J3Mge0BsaW5rIGZhYnJpYy5PYmplY3Qjb3JpZ2luWXxvcmlnaW5ZfVxuICAgICAqIEBtZXRob2Qgc2V0T3JpZ2luWVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBvcmlnaW5ZIHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCNmaWxsfGZpbGx9XG4gICAgICogQG1ldGhvZCBnZXRGaWxsXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBGaWxsIHZhbHVlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9iamVjdCdzIHtAbGluayBmYWJyaWMuT2JqZWN0I2ZpbGx8ZmlsbH1cbiAgICAgKiBAbWV0aG9kIHNldEZpbGxcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgRmlsbCB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgb2JqZWN0J3Mge0BsaW5rIGZhYnJpYy5PYmplY3Qjb3BhY2l0eXxvcGFjaXR5fVxuICAgICAqIEBtZXRob2QgZ2V0T3BhY2l0eVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gT3BhY2l0eSB2YWx1ZSAoMC0xKVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCNvcGFjaXR5fG9wYWNpdHl9XG4gICAgICogQG1ldGhvZCBzZXRPcGFjaXR5XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIE9wYWNpdHkgdmFsdWUgKDAtMSlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG9iamVjdCdzIHtAbGluayBmYWJyaWMuT2JqZWN0I2FuZ2xlfGFuZ2xlfSAoaW4gZGVncmVlcylcbiAgICAgKiBAbWV0aG9kIGdldEFuZ2xlXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG9iamVjdCdzIHtAbGluayBmYWJyaWMuT2JqZWN0I3RvcHx0b3AgcG9zaXRpb259XG4gICAgICogQG1ldGhvZCBnZXRUb3BcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRvcCB2YWx1ZSAoaW4gcGl4ZWxzKVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCN0b3B8dG9wIHBvc2l0aW9ufVxuICAgICAqIEBtZXRob2Qgc2V0VG9wXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRvcCB2YWx1ZSAoaW4gcGl4ZWxzKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgb2JqZWN0J3Mge0BsaW5rIGZhYnJpYy5PYmplY3QjbGVmdHxsZWZ0IHBvc2l0aW9ufVxuICAgICAqIEBtZXRob2QgZ2V0TGVmdFxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTGVmdCB2YWx1ZSAoaW4gcGl4ZWxzKVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCNsZWZ0fGxlZnQgcG9zaXRpb259XG4gICAgICogQG1ldGhvZCBzZXRMZWZ0XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIExlZnQgdmFsdWUgKGluIHBpeGVscylcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG9iamVjdCdzIHtAbGluayBmYWJyaWMuT2JqZWN0I3NjYWxlWHxzY2FsZVh9IHZhbHVlXG4gICAgICogQG1ldGhvZCBnZXRTY2FsZVhcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlWCB2YWx1ZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCNzY2FsZVh8c2NhbGVYfSB2YWx1ZVxuICAgICAqIEBtZXRob2Qgc2V0U2NhbGVYXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIHNjYWxlWCB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgb2JqZWN0J3Mge0BsaW5rIGZhYnJpYy5PYmplY3Qjc2NhbGVZfHNjYWxlWX0gdmFsdWVcbiAgICAgKiBAbWV0aG9kIGdldFNjYWxlWVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gc2NhbGVZIHZhbHVlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9iamVjdCdzIHtAbGluayBmYWJyaWMuT2JqZWN0I3NjYWxlWXxzY2FsZVl9IHZhbHVlXG4gICAgICogQG1ldGhvZCBzZXRTY2FsZVlcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgc2NhbGVZIHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCNmbGlwWHxmbGlwWH0gdmFsdWVcbiAgICAgKiBAbWV0aG9kIGdldEZsaXBYXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gZmxpcFggdmFsdWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFNldHMgb2JqZWN0J3Mge0BsaW5rIGZhYnJpYy5PYmplY3QjZmxpcFh8ZmxpcFh9IHZhbHVlXG4gICAgICogQG1ldGhvZCBzZXRGbGlwWFxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgZmxpcFggdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG9iamVjdCdzIHtAbGluayBmYWJyaWMuT2JqZWN0I2ZsaXBZfGZsaXBZfSB2YWx1ZVxuICAgICAqIEBtZXRob2QgZ2V0RmxpcFlcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBmbGlwWSB2YWx1ZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCNmbGlwWXxmbGlwWX0gdmFsdWVcbiAgICAgKiBAbWV0aG9kIHNldEZsaXBZXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBmbGlwWSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdCAocmVjdCwgY2lyY2xlLCBwYXRoLCBldGMuKS5cbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyBtZWFudCB0byBiZSByZWFkLW9ubHkgYW5kIG5vdCBtZWFudCB0byBiZSBtb2RpZmllZC5cbiAgICAgKiBJZiB5b3UgbW9kaWZ5LCBjZXJ0YWluIHBhcnRzIG9mIEZhYnJpYyAoc3VjaCBhcyBKU09OIGxvYWRpbmcpIHdvbid0IHdvcmsgY29ycmVjdGx5LlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogICAgICAgICAgICAgICAgICAgICAnb2JqZWN0JyxcblxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWwgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uIG9mIGFuIG9iamVjdCAob25lIG9mIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiY2VudGVyXCIpXG4gICAgICogU2VlIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvMW93MDJnZWEvNDAvIG9uIGhvdyBvcmlnaW5YL29yaWdpblkgYWZmZWN0IG9iamVjdHMgaW4gZ3JvdXBzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvcmlnaW5YOiAgICAgICAgICAgICAgICAgICdsZWZ0JyxcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2FsIG9yaWdpbiBvZiB0cmFuc2Zvcm1hdGlvbiBvZiBhbiBvYmplY3QgKG9uZSBvZiBcInRvcFwiLCBcImJvdHRvbVwiLCBcImNlbnRlclwiKVxuICAgICAqIFNlZSBodHRwOi8vanNmaWRkbGUubmV0LzFvdzAyZ2VhLzQwLyBvbiBob3cgb3JpZ2luWC9vcmlnaW5ZIGFmZmVjdCBvYmplY3RzIGluIGdyb3Vwc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3JpZ2luWTogICAgICAgICAgICAgICAgICAndG9wJyxcblxuICAgIC8qKlxuICAgICAqIFRvcCBwb3NpdGlvbiBvZiBhbiBvYmplY3QuIE5vdGUgdGhhdCBieSBkZWZhdWx0IGl0J3MgcmVsYXRpdmUgdG8gb2JqZWN0IHRvcC4gWW91IGNhbiBjaGFuZ2UgdGhpcyBieSBzZXR0aW5nIG9yaWdpblk9e3RvcC9jZW50ZXIvYm90dG9tfVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdG9wOiAgICAgICAgICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogTGVmdCBwb3NpdGlvbiBvZiBhbiBvYmplY3QuIE5vdGUgdGhhdCBieSBkZWZhdWx0IGl0J3MgcmVsYXRpdmUgdG8gb2JqZWN0IGxlZnQuIFlvdSBjYW4gY2hhbmdlIHRoaXMgYnkgc2V0dGluZyBvcmlnaW5YPXtsZWZ0L2NlbnRlci9yaWdodH1cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxlZnQ6ICAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIE9iamVjdCB3aWR0aFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgd2lkdGg6ICAgICAgICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IGhlaWdodFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaGVpZ2h0OiAgICAgICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IHNjYWxlIGZhY3RvciAoaG9yaXpvbnRhbClcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNjYWxlWDogICAgICAgICAgICAgICAgICAgMSxcblxuICAgIC8qKlxuICAgICAqIE9iamVjdCBzY2FsZSBmYWN0b3IgKHZlcnRpY2FsKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2NhbGVZOiAgICAgICAgICAgICAgICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBhbiBvYmplY3QgaXMgcmVuZGVyZWQgYXMgZmxpcHBlZCBob3Jpem9udGFsbHlcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmbGlwWDogICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBhbiBvYmplY3QgaXMgcmVuZGVyZWQgYXMgZmxpcHBlZCB2ZXJ0aWNhbGx5XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZmxpcFk6ICAgICAgICAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIE9wYWNpdHkgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvcGFjaXR5OiAgICAgICAgICAgICAgICAgIDEsXG5cbiAgICAvKipcbiAgICAgKiBBbmdsZSBvZiByb3RhdGlvbiBvZiBhbiBvYmplY3QgKGluIGRlZ3JlZXMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBhbmdsZTogICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBBbmdsZSBvZiBza2V3IG9uIHggYXhlcyBvZiBhbiBvYmplY3QgKGluIGRlZ3JlZXMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBza2V3WDogICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBBbmdsZSBvZiBza2V3IG9uIHkgYXhlcyBvZiBhbiBvYmplY3QgKGluIGRlZ3JlZXMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBza2V3WTogICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBTaXplIG9mIG9iamVjdCdzIGNvbnRyb2xsaW5nIGNvcm5lcnMgKGluIHBpeGVscylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNvcm5lclNpemU6ICAgICAgICAgICAgICAgMTMsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdCdzIGNvbnRyb2xsaW5nIGNvcm5lcnMgYXJlIHJlbmRlcmVkIGFzIHRyYW5zcGFyZW50IGluc2lkZSAoaS5lLiBzdHJva2UgaW5zdGVhZCBvZiBmaWxsKVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRyYW5zcGFyZW50Q29ybmVyczogICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgY3Vyc29yIHZhbHVlIHVzZWQgd2hlbiBob3ZlcmluZyBvdmVyIHRoaXMgb2JqZWN0IG9uIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaG92ZXJDdXJzb3I6ICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCB3aGVuIG1vdmluZyB0aGlzIG9iamVjdCBvbiBjYW52YXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1vdmVDdXJzb3I6ICAgICAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFBhZGRpbmcgYmV0d2VlbiBvYmplY3QgYW5kIGl0cyBjb250cm9sbGluZyBib3JkZXJzIChpbiBwaXhlbHMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwYWRkaW5nOiAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiBjb250cm9sbGluZyBib3JkZXJzIG9mIGFuIG9iamVjdCAod2hlbiBpdCdzIGFjdGl2ZSlcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJvcmRlckNvbG9yOiAgICAgICAgICAgICAgJ3JnYmEoMTAyLDE1MywyNTUsMC43NSknLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgc3BlY2lmeWluZyBkYXNoIHBhdHRlcm4gb2YgYW4gb2JqZWN0J3MgYm9yZGVycyAoaGFzQm9yZGVyIG11c3QgYmUgdHJ1ZSlcbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIGJvcmRlckRhc2hBcnJheTogICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIGNvbnRyb2xsaW5nIGNvcm5lcnMgb2YgYW4gb2JqZWN0ICh3aGVuIGl0J3MgYWN0aXZlKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29ybmVyQ29sb3I6ICAgICAgICAgICAgICAncmdiYSgxMDIsMTUzLDI1NSwwLjUpJyxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIGNvbnRyb2xsaW5nIGNvcm5lcnMgb2YgYW4gb2JqZWN0ICh3aGVuIGl0J3MgYWN0aXZlIGFuZCB0cmFuc3BhcmVudENvcm5lcnMgZmFsc2UpXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb3JuZXJTdHJva2VDb2xvcjogICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHN0eWxlIG9mIGNvbnRyb2wsICdyZWN0JyBvciAnY2lyY2xlJ1xuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIGNvcm5lclN0eWxlOiAgICAgICAgICAncmVjdCcsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBzcGVjaWZ5aW5nIGRhc2ggcGF0dGVybiBvZiBhbiBvYmplY3QncyBjb250cm9sIChoYXNCb3JkZXIgbXVzdCBiZSB0cnVlKVxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgY29ybmVyRGFzaEFycmF5OiAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCB0aGlzIG9iamVjdCB3aWxsIHVzZSBjZW50ZXIgcG9pbnQgYXMgdGhlIG9yaWdpbiBvZiB0cmFuc2Zvcm1hdGlvblxuICAgICAqIHdoZW4gYmVpbmcgc2NhbGVkIHZpYSB0aGUgY29udHJvbHMuXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSByZXBsYWNlcyBcImNlbnRlclRyYW5zZm9ybVwiIChCb29sZWFuKS5cbiAgICAgKiBAc2luY2UgMS4zLjRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjZW50ZXJlZFNjYWxpbmc6ICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCB0aGlzIG9iamVjdCB3aWxsIHVzZSBjZW50ZXIgcG9pbnQgYXMgdGhlIG9yaWdpbiBvZiB0cmFuc2Zvcm1hdGlvblxuICAgICAqIHdoZW4gYmVpbmcgcm90YXRlZCB2aWEgdGhlIGNvbnRyb2xzLlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgcmVwbGFjZXMgXCJjZW50ZXJUcmFuc2Zvcm1cIiAoQm9vbGVhbikuXG4gICAgICogQHNpbmNlIDEuMy40XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2VudGVyZWRSb3RhdGlvbjogICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2Ygb2JqZWN0J3MgZmlsbFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZmlsbDogICAgICAgICAgICAgICAgICAgICAncmdiKDAsMCwwKScsXG5cbiAgICAvKipcbiAgICAgKiBGaWxsIHJ1bGUgdXNlZCB0byBmaWxsIGFuIG9iamVjdFxuICAgICAqIGFjY2VwdGVkIHZhbHVlcyBhcmUgbm9uemVybywgZXZlbm9kZFxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgd2FzIHVzZWQgZm9yIHNldHRpbmcgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIHVudGlsIHYxLjQuMTIgKHVzZSBgZmFicmljLk9iamVjdCNnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25gIGluc3RlYWQpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmaWxsUnVsZTogICAgICAgICAgICAgICAgICdub256ZXJvJyxcblxuICAgIC8qKlxuICAgICAqIENvbXBvc2l0ZSBydWxlIHVzZWQgZm9yIGNhbnZhcyBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjogJ3NvdXJjZS1vdmVyJyxcblxuICAgIC8qKlxuICAgICAqIEJhY2tncm91bmQgY29sb3Igb2YgYW4gb2JqZWN0LiBPbmx5IHdvcmtzIHdpdGggdGV4dCBvYmplY3RzIGF0IHRoZSBtb21lbnQuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICAgICAgICAgICcnLFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0aW9uIEJhY2tncm91bmQgY29sb3Igb2YgYW4gb2JqZWN0LiBjb2xvcmVkIGxheWVyIGJlaGluZCB0aGUgb2JqZWN0IHdoZW4gaXQgaXMgYWN0aXZlLlxuICAgICAqIGRvZXMgbm90IG1peCBnb29kIHdpdGggZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIG1ldGhvZHMuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3I6ICAgICAgICAgICcnLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBkZWZpbmVkLCBhbiBvYmplY3QgaXMgcmVuZGVyZWQgdmlhIHN0cm9rZSBhbmQgdGhpcyBwcm9wZXJ0eSBzcGVjaWZpZXMgaXRzIGNvbG9yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2U6ICAgICAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBhIHN0cm9rZSB1c2VkIHRvIHJlbmRlciB0aGlzIG9iamVjdFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlV2lkdGg6ICAgICAgICAgICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgc3BlY2lmeWluZyBkYXNoIHBhdHRlcm4gb2YgYW4gb2JqZWN0J3Mgc3Ryb2tlIChzdHJva2UgbXVzdCBiZSBkZWZpbmVkKVxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc3Ryb2tlRGFzaEFycmF5OiAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogTGluZSBlbmRpbmdzIHN0eWxlIG9mIGFuIG9iamVjdCdzIHN0cm9rZSAob25lIG9mIFwiYnV0dFwiLCBcInJvdW5kXCIsIFwic3F1YXJlXCIpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2VMaW5lQ2FwOiAgICAgICAgICAgICdidXR0JyxcblxuICAgIC8qKlxuICAgICAqIENvcm5lciBzdHlsZSBvZiBhbiBvYmplY3QncyBzdHJva2UgKG9uZSBvZiBcImJldmlsXCIsIFwicm91bmRcIiwgXCJtaXRlclwiKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlTGluZUpvaW46ICAgICAgICAgICAnbWl0ZXInLFxuXG4gICAgLyoqXG4gICAgICogTWF4aW11bSBtaXRlciBsZW5ndGggKHVzZWQgZm9yIHN0cm9rZUxpbmVKb2luID0gXCJtaXRlclwiKSBvZiBhbiBvYmplY3QncyBzdHJva2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZU1pdGVyTGltaXQ6ICAgICAgICAgMTAsXG5cbiAgICAvKipcbiAgICAgKiBTaGFkb3cgb2JqZWN0IHJlcHJlc2VudGluZyBzaGFkb3cgb2YgdGhpcyBzaGFwZVxuICAgICAqIEB0eXBlIGZhYnJpYy5TaGFkb3dcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNoYWRvdzogICAgICAgICAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIE9wYWNpdHkgb2Ygb2JqZWN0J3MgY29udHJvbGxpbmcgYm9yZGVycyB3aGVuIG9iamVjdCBpcyBhY3RpdmUgYW5kIG1vdmluZ1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYm9yZGVyT3BhY2l0eVdoZW5Nb3Zpbmc6ICAwLjQsXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZSBmYWN0b3Igb2Ygb2JqZWN0J3MgY29udHJvbGxpbmcgYm9yZGVyc1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYm9yZGVyU2NhbGVGYWN0b3I6ICAgICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIG1hdHJpeCAoc2ltaWxhciB0byBTVkcncyB0cmFuc2Zvcm0gbWF0cml4KVxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgdHJhbnNmb3JtTWF0cml4OiAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogTWluaW11bSBhbGxvd2VkIHNjYWxlIHZhbHVlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWluU2NhbGVMaW1pdDogICAgICAgICAgICAwLjAxLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgYW4gb2JqZWN0IGNhbiBub3QgYmUgc2VsZWN0ZWQgZm9yIG1vZGlmaWNhdGlvbiAodXNpbmcgZWl0aGVyIHBvaW50LWNsaWNrLWJhc2VkIG9yIGdyb3VwLWJhc2VkIHNlbGVjdGlvbikuXG4gICAgICogQnV0IGV2ZW50cyBzdGlsbCBmaXJlIG9uIGl0LlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGFibGU6ICAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIGFuIG9iamVjdCBjYW4gbm90IGJlIGEgdGFyZ2V0IG9mIGV2ZW50cy4gQWxsIGV2ZW50cyBwcm9wYWdhdGUgdGhyb3VnaCBpdC4gSW50cm9kdWNlZCBpbiB2MS4zLjRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBldmVudGVkOiAgICAgICAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgZmFsc2VgLCBhbiBvYmplY3QgaXMgbm90IHJlbmRlcmVkIG9uIGNhbnZhc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHZpc2libGU6ICAgICAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIG9iamVjdCdzIGNvbnRyb2xzIGFyZSBub3QgZGlzcGxheWVkIGFuZCBjYW4gbm90IGJlIHVzZWQgdG8gbWFuaXB1bGF0ZSBvYmplY3RcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBoYXNDb250cm9sczogICAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgZmFsc2VgLCBvYmplY3QncyBjb250cm9sbGluZyBib3JkZXJzIGFyZSBub3QgcmVuZGVyZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBoYXNCb3JkZXJzOiAgICAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgZmFsc2VgLCBvYmplY3QncyBjb250cm9sbGluZyByb3RhdGluZyBwb2ludCB3aWxsIG5vdCBiZSB2aXNpYmxlIG9yIHNlbGVjdGFibGVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBoYXNSb3RhdGluZ1BvaW50OiAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBPZmZzZXQgZm9yIG9iamVjdCdzIGNvbnRyb2xsaW5nIHJvdGF0aW5nIHBvaW50ICh3aGVuIGVuYWJsZWQgdmlhIGBoYXNSb3RhdGluZ1BvaW50YClcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJvdGF0aW5nUG9pbnRPZmZzZXQ6ICAgICAgNDAsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgdHJ1ZWAsIG9iamVjdHMgYXJlIFwiZm91bmRcIiBvbiBjYW52YXMgb24gcGVyLXBpeGVsIGJhc2lzIHJhdGhlciB0aGFuIGFjY29yZGluZyB0byBib3VuZGluZyBib3hcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwZXJQaXhlbFRhcmdldEZpbmQ6ICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgZmFsc2VgLCBkZWZhdWx0IG9iamVjdCdzIHZhbHVlcyBhcmUgbm90IGluY2x1ZGVkIGluIGl0cyBzZXJpYWxpemF0aW9uXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaW5jbHVkZURlZmF1bHRWYWx1ZXM6ICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIGNsaXBwaW5nIG9mIGFuIG9iamVjdCAoY29udGV4dCBpcyBwYXNzZWQgYXMgYSBmaXJzdCBhcmd1bWVudClcbiAgICAgKiBOb3RlIHRoYXQgY29udGV4dCBvcmlnaW4gaXMgYXQgdGhlIG9iamVjdCdzIGNlbnRlciBwb2ludCAobm90IGxlZnQvdG9wIGNvcm5lcilcbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqL1xuICAgIGNsaXBUbzogICAgICAgICAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgaG9yaXpvbnRhbCBtb3ZlbWVudCBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrTW92ZW1lbnRYOiAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCB2ZXJ0aWNhbCBtb3ZlbWVudCBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrTW92ZW1lbnRZOiAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCByb3RhdGlvbiBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrUm90YXRpb246ICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBob3Jpem9udGFsIHNjYWxpbmcgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NjYWxpbmdYOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgdmVydGljYWwgc2NhbGluZyBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrU2NhbGluZ1k6ICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBub24tdW5pZm9ybSBzY2FsaW5nIGlzIGxvY2tlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxvY2tVbmlTY2FsaW5nOiAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IGhvcml6b250YWwgc2tld2luZyBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrU2tld2luZ1g6ICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCB2ZXJ0aWNhbCBza2V3aW5nIGlzIGxvY2tlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxvY2tTa2V3aW5nWTogICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IGNhbm5vdCBiZSBmbGlwcGVkIGJ5IHNjYWxpbmcgaW50byBuZWdhdGl2ZSB2YWx1ZXNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cblxuICAgIGxvY2tTY2FsaW5nRmxpcDogICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IGlzIG5vdCBleHBvcnRlZCBpbiBTVkcgb3IgT0JKRUNUL0pTT05cbiAgICAgKiBzaW5jZSAxLjYuM1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuXG4gICAgZXhjbHVkZUZyb21FeHBvcnQ6ICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbnNpZGVyIHdoZW4gY2hlY2tpbmcgaWYgc3RhdGVcbiAgICAgKiBvZiBhbiBvYmplY3QgaXMgY2hhbmdlZCAoZmFicmljLk9iamVjdCNoYXNTdGF0ZUNoYW5nZWQpXG4gICAgICogYXMgd2VsbCBhcyBmb3IgaGlzdG9yeSAodW5kby9yZWRvKSBwdXJwb3Nlc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc3RhdGVQcm9wZXJ0aWVzOiAgKFxuICAgICAgJ3RvcCBsZWZ0IHdpZHRoIGhlaWdodCBzY2FsZVggc2NhbGVZIGZsaXBYIGZsaXBZIG9yaWdpblggb3JpZ2luWSB0cmFuc2Zvcm1NYXRyaXggJyArXG4gICAgICAnc3Ryb2tlIHN0cm9rZVdpZHRoIHN0cm9rZURhc2hBcnJheSBzdHJva2VMaW5lQ2FwIHN0cm9rZUxpbmVKb2luIHN0cm9rZU1pdGVyTGltaXQgJyArXG4gICAgICAnYW5nbGUgb3BhY2l0eSBmaWxsIGZpbGxSdWxlIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiBzaGFkb3cgY2xpcFRvIHZpc2libGUgYmFja2dyb3VuZENvbG9yICcgK1xuICAgICAgJ3NrZXdYIHNrZXdZJ1xuICAgICkuc3BsaXQoJyAnKSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgX2luaXRHcmFkaWVudDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMuZmlsbCAmJiBvcHRpb25zLmZpbGwuY29sb3JTdG9wcyAmJiAhKG9wdGlvbnMuZmlsbCBpbnN0YW5jZW9mIGZhYnJpYy5HcmFkaWVudCkpIHtcbiAgICAgICAgdGhpcy5zZXQoJ2ZpbGwnLCBuZXcgZmFicmljLkdyYWRpZW50KG9wdGlvbnMuZmlsbCkpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc3Ryb2tlICYmIG9wdGlvbnMuc3Ryb2tlLmNvbG9yU3RvcHMgJiYgIShvcHRpb25zLnN0cm9rZSBpbnN0YW5jZW9mIGZhYnJpYy5HcmFkaWVudCkpIHtcbiAgICAgICAgdGhpcy5zZXQoJ3N0cm9rZScsIG5ldyBmYWJyaWMuR3JhZGllbnQob3B0aW9ucy5zdHJva2UpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgX2luaXRQYXR0ZXJuOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy5maWxsICYmIG9wdGlvbnMuZmlsbC5zb3VyY2UgJiYgIShvcHRpb25zLmZpbGwgaW5zdGFuY2VvZiBmYWJyaWMuUGF0dGVybikpIHtcbiAgICAgICAgdGhpcy5zZXQoJ2ZpbGwnLCBuZXcgZmFicmljLlBhdHRlcm4ob3B0aW9ucy5maWxsKSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5zdHJva2UgJiYgb3B0aW9ucy5zdHJva2Uuc291cmNlICYmICEob3B0aW9ucy5zdHJva2UgaW5zdGFuY2VvZiBmYWJyaWMuUGF0dGVybikpIHtcbiAgICAgICAgdGhpcy5zZXQoJ3N0cm9rZScsIG5ldyBmYWJyaWMuUGF0dGVybihvcHRpb25zLnN0cm9rZSkpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBfaW5pdENsaXBwaW5nOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMuY2xpcFRvIHx8IHR5cGVvZiBvcHRpb25zLmNsaXBUbyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZnVuY3Rpb25Cb2R5ID0gZmFicmljLnV0aWwuZ2V0RnVuY3Rpb25Cb2R5KG9wdGlvbnMuY2xpcFRvKTtcbiAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25Cb2R5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmNsaXBUbyA9IG5ldyBGdW5jdGlvbignY3R4JywgZnVuY3Rpb25Cb2R5KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBvYmplY3QncyBwcm9wZXJ0aWVzIGZyb20gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBzZXRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zZXQocHJvcCwgb3B0aW9uc1twcm9wXSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9pbml0R3JhZGllbnQob3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0UGF0dGVybihvcHRpb25zKTtcbiAgICAgIHRoaXMuX2luaXRDbGlwcGluZyhvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBjb250ZXh0IHdoZW4gcmVuZGVyaW5nIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZnJvbUxlZnQgV2hlbiB0cnVlLCBjb250ZXh0IGlzIHRyYW5zZm9ybWVkIHRvIG9iamVjdCdzIHRvcC9sZWZ0IGNvcm5lci4gVGhpcyBpcyB1c2VkIHdoZW4gcmVuZGVyaW5nIHRleHQgb24gTm9kZVxuICAgICAqL1xuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24oY3R4LCBmcm9tTGVmdCkge1xuICAgICAgaWYgKHRoaXMuZ3JvdXAgJiYgIXRoaXMuZ3JvdXAuX3RyYW5zZm9ybURvbmUgJiYgdGhpcy5ncm91cCA9PT0gdGhpcy5jYW52YXMuX2FjdGl2ZUdyb3VwKSB7XG4gICAgICAgIHRoaXMuZ3JvdXAudHJhbnNmb3JtKGN0eCk7XG4gICAgICB9XG4gICAgICB2YXIgY2VudGVyID0gZnJvbUxlZnQgPyB0aGlzLl9nZXRMZWZ0VG9wQ29vcmRzKCkgOiB0aGlzLmdldENlbnRlclBvaW50KCk7XG4gICAgICBjdHgudHJhbnNsYXRlKGNlbnRlci54LCBjZW50ZXIueSk7XG4gICAgICBjdHgucm90YXRlKGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSkpO1xuICAgICAgY3R4LnNjYWxlKFxuICAgICAgICB0aGlzLnNjYWxlWCAqICh0aGlzLmZsaXBYID8gLTEgOiAxKSxcbiAgICAgICAgdGhpcy5zY2FsZVkgKiAodGhpcy5mbGlwWSA/IC0xIDogMSlcbiAgICAgICk7XG4gICAgICBjdHgudHJhbnNmb3JtKDEsIDAsIE1hdGgudGFuKGRlZ3JlZXNUb1JhZGlhbnModGhpcy5za2V3WCkpLCAxLCAwLCAwKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0oMSwgTWF0aC50YW4oZGVncmVlc1RvUmFkaWFucyh0aGlzLnNrZXdZKSksIDAsIDEsIDAsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUyxcblxuICAgICAgICAgIG9iamVjdCA9IHtcbiAgICAgICAgICAgIHR5cGU6ICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlLFxuICAgICAgICAgICAgb3JpZ2luWDogICAgICAgICAgICAgICAgICB0aGlzLm9yaWdpblgsXG4gICAgICAgICAgICBvcmlnaW5ZOiAgICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luWSxcbiAgICAgICAgICAgIGxlZnQ6ICAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmxlZnQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgdG9wOiAgICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMudG9wLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHdpZHRoOiAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLndpZHRoLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIGhlaWdodDogICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmhlaWdodCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBmaWxsOiAgICAgICAgICAgICAgICAgICAgICh0aGlzLmZpbGwgJiYgdGhpcy5maWxsLnRvT2JqZWN0KSA/IHRoaXMuZmlsbC50b09iamVjdCgpIDogdGhpcy5maWxsLFxuICAgICAgICAgICAgc3Ryb2tlOiAgICAgICAgICAgICAgICAgICAodGhpcy5zdHJva2UgJiYgdGhpcy5zdHJva2UudG9PYmplY3QpID8gdGhpcy5zdHJva2UudG9PYmplY3QoKSA6IHRoaXMuc3Ryb2tlLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6ICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc3Ryb2tlV2lkdGgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc3Ryb2tlRGFzaEFycmF5OiAgICAgICAgICB0aGlzLnN0cm9rZURhc2hBcnJheSA/IHRoaXMuc3Ryb2tlRGFzaEFycmF5LmNvbmNhdCgpIDogdGhpcy5zdHJva2VEYXNoQXJyYXksXG4gICAgICAgICAgICBzdHJva2VMaW5lQ2FwOiAgICAgICAgICAgIHRoaXMuc3Ryb2tlTGluZUNhcCxcbiAgICAgICAgICAgIHN0cm9rZUxpbmVKb2luOiAgICAgICAgICAgdGhpcy5zdHJva2VMaW5lSm9pbixcbiAgICAgICAgICAgIHN0cm9rZU1pdGVyTGltaXQ6ICAgICAgICAgdG9GaXhlZCh0aGlzLnN0cm9rZU1pdGVyTGltaXQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc2NhbGVYOiAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc2NhbGVYLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHNjYWxlWTogICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLnNjYWxlWSwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBhbmdsZTogICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5nZXRBbmdsZSgpLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIGZsaXBYOiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbGlwWCxcbiAgICAgICAgICAgIGZsaXBZOiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbGlwWSxcbiAgICAgICAgICAgIG9wYWNpdHk6ICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLm9wYWNpdHksIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc2hhZG93OiAgICAgICAgICAgICAgICAgICAodGhpcy5zaGFkb3cgJiYgdGhpcy5zaGFkb3cudG9PYmplY3QpID8gdGhpcy5zaGFkb3cudG9PYmplY3QoKSA6IHRoaXMuc2hhZG93LFxuICAgICAgICAgICAgdmlzaWJsZTogICAgICAgICAgICAgICAgICB0aGlzLnZpc2libGUsXG4gICAgICAgICAgICBjbGlwVG86ICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpcFRvICYmIFN0cmluZyh0aGlzLmNsaXBUbyksXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICAgICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgZmlsbFJ1bGU6ICAgICAgICAgICAgICAgICB0aGlzLmZpbGxSdWxlLFxuICAgICAgICAgICAgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uOiB0aGlzLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbixcbiAgICAgICAgICAgIHRyYW5zZm9ybU1hdHJpeDogICAgICAgICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPyB0aGlzLnRyYW5zZm9ybU1hdHJpeC5jb25jYXQoKSA6IHRoaXMudHJhbnNmb3JtTWF0cml4LFxuICAgICAgICAgICAgc2tld1g6ICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc2tld1gsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc2tld1k6ICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc2tld1ksIE5VTV9GUkFDVElPTl9ESUdJVFMpXG4gICAgICAgICAgfTtcblxuICAgICAgaWYgKCF0aGlzLmluY2x1ZGVEZWZhdWx0VmFsdWVzKSB7XG4gICAgICAgIG9iamVjdCA9IHRoaXMuX3JlbW92ZURlZmF1bHRWYWx1ZXMob2JqZWN0KTtcbiAgICAgIH1cblxuICAgICAgZmFicmljLnV0aWwucG9wdWxhdGVXaXRoUHJvcGVydGllcyh0aGlzLCBvYmplY3QsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIChkYXRhbGVzcykgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9EYXRhbGVzc09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgLy8gd2lsbCBiZSBvdmVyd3JpdHRlbiBieSBzdWJjbGFzc2VzXG4gICAgICByZXR1cm4gdGhpcy50b09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICovXG4gICAgX3JlbW92ZURlZmF1bHRWYWx1ZXM6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHByb3RvdHlwZSA9IGZhYnJpYy51dGlsLmdldEtsYXNzKG9iamVjdC50eXBlKS5wcm90b3R5cGUsXG4gICAgICAgICAgc3RhdGVQcm9wZXJ0aWVzID0gcHJvdG90eXBlLnN0YXRlUHJvcGVydGllcztcblxuICAgICAgc3RhdGVQcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICBpZiAob2JqZWN0W3Byb3BdID09PSBwcm90b3R5cGVbcHJvcF0pIHtcbiAgICAgICAgICBkZWxldGUgb2JqZWN0W3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc0FycmF5ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdFtwcm9wXSkgPT09ICdbb2JqZWN0IEFycmF5XScgJiZcbiAgICAgICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJvdG90eXBlW3Byb3BdKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcblxuICAgICAgICAvLyBiYXNpY2FsbHkgYSBjaGVjayBmb3IgW10gPT09IFtdXG4gICAgICAgIGlmIChpc0FycmF5ICYmIG9iamVjdFtwcm9wXS5sZW5ndGggPT09IDAgJiYgcHJvdG90eXBlW3Byb3BdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSBvYmplY3RbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuJyArIGNhcGl0YWxpemUodGhpcy50eXBlKSArICc+JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQmFzaWMgZ2V0dGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHsqfSB2YWx1ZSBvZiBhIHByb3BlcnR5XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRoaXNbcHJvcGVydHldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG9iamVjdCBzY2FsZSBmYWN0b3IgY291bnRpbmcgYWxzbyB0aGUgZ3JvdXAgc2NhbGluZ1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHdpdGggc2NhbGVYIGFuZCBzY2FsZVkgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdldE9iamVjdFNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNjYWxlWCA9IHRoaXMuc2NhbGVYLCBzY2FsZVkgPSB0aGlzLnNjYWxlWTtcbiAgICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICAgIHZhciBzY2FsaW5nID0gdGhpcy5ncm91cC5nZXRPYmplY3RTY2FsaW5nKCk7XG4gICAgICAgIHNjYWxlWCAqPSBzY2FsaW5nLnNjYWxlWDtcbiAgICAgICAgc2NhbGVZICo9IHNjYWxpbmcuc2NhbGVZO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc2NhbGVYOiBzY2FsZVgsIHNjYWxlWTogc2NhbGVZIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldE9iamVjdDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICB0aGlzLl9zZXQocHJvcCwgb2JqW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBwcm9wZXJ0eSB0byBhIGdpdmVuIHZhbHVlLiBXaGVuIGNoYW5naW5nIHBvc2l0aW9uL2RpbWVuc2lvbiAtcmVsYXRlZCBwcm9wZXJ0aWVzIChsZWZ0LCB0b3AsIHNjYWxlLCBhbmdsZSwgZXRjLikgYHNldGAgZG9lcyBub3QgdXBkYXRlIHBvc2l0aW9uIG9mIG9iamVjdCdzIGJvcmRlcnMvY29udHJvbHMuIElmIHlvdSBuZWVkIHRvIHVwZGF0ZSB0aG9zZSwgY2FsbCBgc2V0Q29vcmRzKClgLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0ga2V5IFByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IChpZiBvYmplY3QsIGl0ZXJhdGUgb3ZlciB0aGUgb2JqZWN0IHByb3BlcnRpZXMpXG4gICAgICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHZhbHVlIFByb3BlcnR5IHZhbHVlIChpZiBmdW5jdGlvbiwgdGhlIHZhbHVlIGlzIHBhc3NlZCBpbnRvIGl0IGFuZCBpdHMgcmV0dXJuIHZhbHVlIGlzIHVzZWQgYXMgYSBuZXcgb25lKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhpcy5fc2V0T2JqZWN0KGtleSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBrZXkgIT09ICdjbGlwVG8nKSB7XG4gICAgICAgICAgdGhpcy5fc2V0KGtleSwgdmFsdWUodGhpcy5nZXQoa2V5KSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgX3NldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIHNob3VsZENvbnN0cmFpblZhbHVlID0gKGtleSA9PT0gJ3NjYWxlWCcgfHwga2V5ID09PSAnc2NhbGVZJyk7XG5cbiAgICAgIGlmIChzaG91bGRDb25zdHJhaW5WYWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuX2NvbnN0cmFpblNjYWxlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09ICdzY2FsZVgnICYmIHZhbHVlIDwgMCkge1xuICAgICAgICB0aGlzLmZsaXBYID0gIXRoaXMuZmxpcFg7XG4gICAgICAgIHZhbHVlICo9IC0xO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc2NhbGVZJyAmJiB2YWx1ZSA8IDApIHtcbiAgICAgICAgdGhpcy5mbGlwWSA9ICF0aGlzLmZsaXBZO1xuICAgICAgICB2YWx1ZSAqPSAtMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3NoYWRvdycgJiYgdmFsdWUgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIGZhYnJpYy5TaGFkb3cpKSB7XG4gICAgICAgIHZhbHVlID0gbmV3IGZhYnJpYy5TaGFkb3codmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcblxuICAgICAgaWYgKGtleSA9PT0gJ3dpZHRoJyB8fCBrZXkgPT09ICdoZWlnaHQnKSB7XG4gICAgICAgIHRoaXMubWluU2NhbGVMaW1pdCA9IE1hdGgubWluKDAuMSwgMSAvIE1hdGgubWF4KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSB0aGUgcGFyZW50IGdyb3VwIG9mIGFuIG9iamVjdCBldmVyeVxuICAgICAqIHRpbWUgYSBub24tZGVsZWdhdGVkIHByb3BlcnR5IGNoYW5nZXMgb24gdGhlIGdyb3VwLiBJdCBpcyBwYXNzZWQgdGhlIGtleVxuICAgICAqIGFuZCB2YWx1ZSBhcyBwYXJhbWV0ZXJzLiBOb3QgYWRkaW5nIGluIHRoaXMgZnVuY3Rpb24ncyBzaWduYXR1cmUgdG8gYXZvaWRcbiAgICAgKiBUcmF2aXMgYnVpbGQgZXJyb3IgYWJvdXQgdW51c2VkIHZhcmlhYmxlcy5cbiAgICAgKi9cbiAgICBzZXRPbkdyb3VwOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGltcGxlbWVudGVkIGJ5IHN1Yi1jbGFzc2VzLCBhcyBuZWVkZWQuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgc3BlY2lmaWVkIHByb3BlcnR5IGZyb20gYHRydWVgIHRvIGBmYWxzZWAgb3IgZnJvbSBgZmFsc2VgIHRvIGB0cnVlYFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byB0b2dnbGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHRvZ2dsZTogZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KHByb3BlcnR5KTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICB0aGlzLnNldChwcm9wZXJ0eSwgIXZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNvdXJjZVBhdGggb2YgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHNldCBzb3VyY2VQYXRoIHRvXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRTb3VyY2VQYXRoOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdGhpcy5zb3VyY2VQYXRoID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHZpZXdwb3J0VHJhbnNmb3JtIGZyb20gT2JqZWN0J3MgY2FudmFzIGlmIHBvc3NpYmxlXG4gICAgICogQG1ldGhvZCBnZXRWaWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGZsaXBZIHZhbHVlIC8vIFRPRE9cbiAgICAgKi9cbiAgICBnZXRWaWV3cG9ydFRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhbiBvYmplY3Qgb24gYSBzcGVjaWZpZWQgY29udGV4dFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtub1RyYW5zZm9ybV0gV2hlbiB0cnVlLCBjb250ZXh0IGlzIG5vdCB0cmFuc2Zvcm1lZFxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4LCBub1RyYW5zZm9ybSkge1xuICAgICAgLy8gZG8gbm90IHJlbmRlciBpZiB3aWR0aC9oZWlnaHQgYXJlIHplcm9zIG9yIG9iamVjdCBpcyBub3QgdmlzaWJsZVxuICAgICAgaWYgKCh0aGlzLndpZHRoID09PSAwICYmIHRoaXMuaGVpZ2h0ID09PSAwKSB8fCAhdGhpcy52aXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgLy9zZXR1cCBmaWxsIHJ1bGUgZm9yIGN1cnJlbnQgb2JqZWN0XG4gICAgICB0aGlzLl9zZXR1cENvbXBvc2l0ZU9wZXJhdGlvbihjdHgpO1xuICAgICAgdGhpcy5kcmF3U2VsZWN0aW9uQmFja2dyb3VuZChjdHgpO1xuICAgICAgaWYgKCFub1RyYW5zZm9ybSkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybShjdHgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0T3BhY2l0eShjdHgpO1xuICAgICAgdGhpcy5fc2V0U2hhZG93KGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJCYWNrZ3JvdW5kKGN0eCk7XG4gICAgICB0aGlzLl9zZXRTdHJva2VTdHlsZXMoY3R4KTtcbiAgICAgIHRoaXMuX3NldEZpbGxTdHlsZXMoY3R4KTtcbiAgICAgIGlmICh0aGlzLnRyYW5zZm9ybU1hdHJpeCkge1xuICAgICAgICBjdHgudHJhbnNmb3JtLmFwcGx5KGN0eCwgdGhpcy50cmFuc2Zvcm1NYXRyaXgpO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGlwVG8gJiYgZmFicmljLnV0aWwuY2xpcENvbnRleHQodGhpcywgY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlcihjdHgsIG5vVHJhbnNmb3JtKTtcbiAgICAgIHRoaXMuY2xpcFRvICYmIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGEgYmFja2dyb3VuZCBmb3IgdGhlIG9iamVjdCBiaWcgYXMgaXRzIHdpZHRoIGFuZCBoZWlnaHQ7XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckJhY2tncm91bmQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvcjtcblxuICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAtdGhpcy53aWR0aCAvIDIsXG4gICAgICAgIC10aGlzLmhlaWdodCAvIDIsXG4gICAgICAgIHRoaXMud2lkdGgsXG4gICAgICAgIHRoaXMuaGVpZ2h0XG4gICAgICApO1xuICAgICAgLy8gaWYgdGhlcmUgaXMgYmFja2dyb3VuZCBjb2xvciBubyBvdGhlciBzaGFkb3dzXG4gICAgICAvLyBzaG91bGQgYmUgY2FzdGVkXG4gICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3NldE9wYWNpdHk6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgICAgdGhpcy5ncm91cC5fc2V0T3BhY2l0eShjdHgpO1xuICAgICAgfVxuICAgICAgY3R4Lmdsb2JhbEFscGhhICo9IHRoaXMub3BhY2l0eTtcbiAgICB9LFxuXG4gICAgX3NldFN0cm9rZVN0eWxlczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAodGhpcy5zdHJva2UpIHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGg7XG4gICAgICAgIGN0eC5saW5lQ2FwID0gdGhpcy5zdHJva2VMaW5lQ2FwO1xuICAgICAgICBjdHgubGluZUpvaW4gPSB0aGlzLnN0cm9rZUxpbmVKb2luO1xuICAgICAgICBjdHgubWl0ZXJMaW1pdCA9IHRoaXMuc3Ryb2tlTWl0ZXJMaW1pdDtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5zdHJva2UudG9MaXZlXG4gICAgICAgICAgPyB0aGlzLnN0cm9rZS50b0xpdmUoY3R4LCB0aGlzKVxuICAgICAgICAgIDogdGhpcy5zdHJva2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9zZXRGaWxsU3R5bGVzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICh0aGlzLmZpbGwpIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuZmlsbC50b0xpdmVcbiAgICAgICAgICA/IHRoaXMuZmlsbC50b0xpdmUoY3R4LCB0aGlzKVxuICAgICAgICAgIDogdGhpcy5maWxsO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIFNldHMgbGluZSBkYXNoXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHNldCB0aGUgZGFzaCBsaW5lIG9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGFzaEFycmF5IGFycmF5IHJlcHJlc2VudGluZyBkYXNoZXNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhbHRlcm5hdGl2ZSBmdW5jdGlvbiB0byBjYWxsIGlmIGJyb3dhc2VyIGRvZXMgbm90IHN1cHBvcnQgbGluZURhc2hcbiAgICAgKi9cbiAgICBfc2V0TGluZURhc2g6IGZ1bmN0aW9uKGN0eCwgZGFzaEFycmF5LCBhbHRlcm5hdGl2ZSkge1xuICAgICAgaWYgKCFkYXNoQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gU3BlYyByZXF1aXJlcyB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0d28gY29waWVzIHRoZSBkYXNoIGxpc3Qgd2hlbiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGlzIG9kZFxuICAgICAgaWYgKDEgJiBkYXNoQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIGRhc2hBcnJheS5wdXNoLmFwcGx5KGRhc2hBcnJheSwgZGFzaEFycmF5KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdXBwb3J0c0xpbmVEYXNoKSB7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChkYXNoQXJyYXkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGFsdGVybmF0aXZlICYmIGFsdGVybmF0aXZlKGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgY29udHJvbHMgYW5kIGJvcmRlcnMgZm9yIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbbm9UcmFuc2Zvcm1dIFdoZW4gdHJ1ZSwgY29udGV4dCBpcyBub3QgdHJhbnNmb3JtZWRcbiAgICAgKi9cbiAgICBfcmVuZGVyQ29udHJvbHM6IGZ1bmN0aW9uKGN0eCwgbm9UcmFuc2Zvcm0pIHtcbiAgICAgIGlmICghdGhpcy5hY3RpdmUgfHwgbm9UcmFuc2Zvcm1cbiAgICAgICAgICB8fCAodGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwICE9PSB0aGlzLmNhbnZhcy5nZXRBY3RpdmVHcm91cCgpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB2cHQgPSB0aGlzLmdldFZpZXdwb3J0VHJhbnNmb3JtKCksXG4gICAgICAgICAgbWF0cml4ID0gdGhpcy5jYWxjVHJhbnNmb3JtTWF0cml4KCksXG4gICAgICAgICAgb3B0aW9ucztcbiAgICAgIG1hdHJpeCA9IGZhYnJpYy51dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXModnB0LCBtYXRyaXgpO1xuICAgICAgb3B0aW9ucyA9IGZhYnJpYy51dGlsLnFyRGVjb21wb3NlKG1hdHJpeCk7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKG9wdGlvbnMudHJhbnNsYXRlWCwgb3B0aW9ucy50cmFuc2xhdGVZKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSAxICogdGhpcy5ib3JkZXJTY2FsZUZhY3RvcjtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuaXNNb3ZpbmcgPyB0aGlzLmJvcmRlck9wYWNpdHlXaGVuTW92aW5nIDogMTtcblxuICAgICAgaWYgKHRoaXMuZ3JvdXAgJiYgdGhpcy5ncm91cCA9PT0gdGhpcy5jYW52YXMuZ2V0QWN0aXZlR3JvdXAoKSkge1xuICAgICAgICBjdHgucm90YXRlKGRlZ3JlZXNUb1JhZGlhbnMob3B0aW9ucy5hbmdsZSkpO1xuICAgICAgICB0aGlzLmRyYXdCb3JkZXJzSW5Hcm91cChjdHgsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGN0eC5yb3RhdGUoZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSk7XG4gICAgICAgIHRoaXMuZHJhd0JvcmRlcnMoY3R4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZHJhd0NvbnRyb2xzKGN0eCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfc2V0U2hhZG93OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5zaGFkb3cpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbXVsdFggPSAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm1bMF0pIHx8IDEsXG4gICAgICAgICAgbXVsdFkgPSAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm1bM10pIHx8IDEsXG4gICAgICAgICAgc2NhbGluZyA9IHRoaXMuZ2V0T2JqZWN0U2NhbGluZygpO1xuICAgICAgaWYgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLl9pc1JldGluYVNjYWxpbmcoKSkge1xuICAgICAgICBtdWx0WCAqPSBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgbXVsdFkgKj0gZmFicmljLmRldmljZVBpeGVsUmF0aW87XG4gICAgICB9XG4gICAgICBjdHguc2hhZG93Q29sb3IgPSB0aGlzLnNoYWRvdy5jb2xvcjtcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gdGhpcy5zaGFkb3cuYmx1ciAqIChtdWx0WCArIG11bHRZKSAqIChzY2FsaW5nLnNjYWxlWCArIHNjYWxpbmcuc2NhbGVZKSAvIDQ7XG4gICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IHRoaXMuc2hhZG93Lm9mZnNldFggKiBtdWx0WCAqIHNjYWxpbmcuc2NhbGVYO1xuICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSB0aGlzLnNoYWRvdy5vZmZzZXRZICogbXVsdFkgKiBzY2FsaW5nLnNjYWxlWTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbW92ZVNoYWRvdzogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuc2hhZG93KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gJyc7XG4gICAgICBjdHguc2hhZG93Qmx1ciA9IGN0eC5zaGFkb3dPZmZzZXRYID0gY3R4LnNoYWRvd09mZnNldFkgPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyRmlsbDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuZmlsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBpZiAodGhpcy5maWxsLmdyYWRpZW50VHJhbnNmb3JtKSB7XG4gICAgICAgIHZhciBnID0gdGhpcy5maWxsLmdyYWRpZW50VHJhbnNmb3JtO1xuICAgICAgICBjdHgudHJhbnNmb3JtLmFwcGx5KGN0eCwgZyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5maWxsLnRvTGl2ZSkge1xuICAgICAgICBjdHgudHJhbnNsYXRlKFxuICAgICAgICAgIC10aGlzLndpZHRoIC8gMiArIHRoaXMuZmlsbC5vZmZzZXRYIHx8IDAsXG4gICAgICAgICAgLXRoaXMuaGVpZ2h0IC8gMiArIHRoaXMuZmlsbC5vZmZzZXRZIHx8IDApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZmlsbFJ1bGUgPT09ICdldmVub2RkJykge1xuICAgICAgICBjdHguZmlsbCgnZXZlbm9kZCcpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyU3Ryb2tlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5zdHJva2UgfHwgdGhpcy5zdHJva2VXaWR0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNoYWRvdyAmJiAhdGhpcy5zaGFkb3cuYWZmZWN0U3Ryb2tlKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVNoYWRvdyhjdHgpO1xuICAgICAgfVxuXG4gICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICB0aGlzLl9zZXRMaW5lRGFzaChjdHgsIHRoaXMuc3Ryb2tlRGFzaEFycmF5LCB0aGlzLl9yZW5kZXJEYXNoZWRTdHJva2UpO1xuICAgICAgaWYgKHRoaXMuc3Ryb2tlLmdyYWRpZW50VHJhbnNmb3JtKSB7XG4gICAgICAgIHZhciBnID0gdGhpcy5zdHJva2UuZ3JhZGllbnRUcmFuc2Zvcm07XG4gICAgICAgIGN0eC50cmFuc2Zvcm0uYXBwbHkoY3R4LCBnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0cm9rZS50b0xpdmUpIHtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZShcbiAgICAgICAgICAtdGhpcy53aWR0aCAvIDIgKyB0aGlzLnN0cm9rZS5vZmZzZXRYIHx8IDAsXG4gICAgICAgICAgLXRoaXMuaGVpZ2h0IC8gMiArIHRoaXMuc3Ryb2tlLm9mZnNldFkgfHwgMCk7XG4gICAgICB9XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbG9uZXMgYW4gaW5zdGFuY2UsIHNvbWUgb2JqZWN0cyBhcmUgYXN5bmMsIHNvIHVzaW5nIGNhbGxiYWNrIG1ldGhvZCB3aWxsIHdvcmsgZm9yIGV2ZXJ5IG9iamVjdC5cbiAgICAgKiBVc2luZyB0aGUgZGlyZWN0IHJldHVybiBkb2VzIG5vdCB3b3JrIGZvciBpbWFnZXMgYW5kIGdyb3Vwcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBpcyBpbnZva2VkIHdpdGggYSBjbG9uZSBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IGNsb25lIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKGNhbGxiYWNrLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5mcm9tT2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmZyb21PYmplY3QodGhpcy50b09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuT2JqZWN0KHRoaXMudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZSBvdXQgb2YgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2ssIGludm9rZWQgd2l0aCBhbiBpbnN0YW5jZSBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBmb3IgY2xvbmUgYXMgaW1hZ2UsIHBhc3NlZCB0byB0b0RhdGFVUkxcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZVJldGluYVNjYWxpbmddIGVuYWJsZSByZXRpbmEgc2NhbGluZyBmb3IgdGhlIGNsb25lZCBpbWFnZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBjbG9uZUFzSW1hZ2U6IGZ1bmN0aW9uKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICB2YXIgZGF0YVVybCA9IHRoaXMudG9EYXRhVVJMKG9wdGlvbnMpO1xuICAgICAgZmFicmljLnV0aWwubG9hZEltYWdlKGRhdGFVcmwsIGZ1bmN0aW9uKGltZykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhuZXcgZmFicmljLkltYWdlKGltZykpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIGRhdGEtdXJsLWxpa2Ugc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZm9ybWF0PXBuZ10gVGhlIGZvcm1hdCBvZiB0aGUgb3V0cHV0IGltYWdlLiBFaXRoZXIgXCJqcGVnXCIgb3IgXCJwbmdcIlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5xdWFsaXR5PTFdIFF1YWxpdHkgbGV2ZWwgKDAuLjEpLiBPbmx5IHVzZWQgZm9yIGpwZWcuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm11bHRpcGxpZXI9MV0gTXVsdGlwbGllciB0byBzY2FsZSBieVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sZWZ0XSBDcm9wcGluZyBsZWZ0IG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRvcF0gQ3JvcHBpbmcgdG9wIG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoXSBDcm9wcGluZyB3aWR0aC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gQ3JvcHBpbmcgaGVpZ2h0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZVJldGluYV0gRW5hYmxlIHJldGluYSBzY2FsaW5nIGZvciBjbG9uZSBpbWFnZS4gSW50cm9kdWNlIGluIDEuNi40XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBSZXR1cm5zIGEgZGF0YTogVVJMIGNvbnRhaW5pbmcgYSByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0IGluIHRoZSBmb3JtYXQgc3BlY2lmaWVkIGJ5IG9wdGlvbnMuZm9ybWF0XG4gICAgICovXG4gICAgdG9EYXRhVVJMOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdmFyIGVsID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLFxuICAgICAgICAgIGJvdW5kaW5nUmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG5cbiAgICAgIGVsLndpZHRoID0gYm91bmRpbmdSZWN0LndpZHRoO1xuICAgICAgZWwuaGVpZ2h0ID0gYm91bmRpbmdSZWN0LmhlaWdodDtcbiAgICAgIGZhYnJpYy51dGlsLndyYXBFbGVtZW50KGVsLCAnZGl2Jyk7XG4gICAgICB2YXIgY2FudmFzID0gbmV3IGZhYnJpYy5TdGF0aWNDYW52YXMoZWwsIHsgZW5hYmxlUmV0aW5hU2NhbGluZzogb3B0aW9ucy5lbmFibGVSZXRpbmFTY2FsaW5nIH0pO1xuICAgICAgLy8gdG8gYXZvaWQgY29tbW9uIGNvbmZ1c2lvbiBodHRwczovL2dpdGh1Yi5jb20va2FuZ2F4L2ZhYnJpYy5qcy9pc3N1ZXMvODA2XG4gICAgICBpZiAob3B0aW9ucy5mb3JtYXQgPT09ICdqcGcnKSB7XG4gICAgICAgIG9wdGlvbnMuZm9ybWF0ID0gJ2pwZWcnO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5mb3JtYXQgPT09ICdqcGVnJykge1xuICAgICAgICBjYW52YXMuYmFja2dyb3VuZENvbG9yID0gJyNmZmYnO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3JpZ1BhcmFtcyA9IHtcbiAgICAgICAgYWN0aXZlOiB0aGlzLmdldCgnYWN0aXZlJyksXG4gICAgICAgIGxlZnQ6IHRoaXMuZ2V0TGVmdCgpLFxuICAgICAgICB0b3A6IHRoaXMuZ2V0VG9wKClcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuc2V0KCdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICB0aGlzLnNldFBvc2l0aW9uQnlPcmlnaW4obmV3IGZhYnJpYy5Qb2ludChjYW52YXMuZ2V0V2lkdGgoKSAvIDIsIGNhbnZhcy5nZXRIZWlnaHQoKSAvIDIpLCAnY2VudGVyJywgJ2NlbnRlcicpO1xuXG4gICAgICB2YXIgb3JpZ2luYWxDYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgIGNhbnZhcy5hZGQodGhpcyk7XG4gICAgICB2YXIgZGF0YSA9IGNhbnZhcy50b0RhdGFVUkwob3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuc2V0KG9yaWdQYXJhbXMpLnNldENvb3JkcygpO1xuICAgICAgdGhpcy5jYW52YXMgPSBvcmlnaW5hbENhbnZhcztcblxuICAgICAgY2FudmFzLmRpc3Bvc2UoKTtcbiAgICAgIGNhbnZhcyA9IG51bGw7XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgc3BlY2lmaWVkIHR5cGUgaXMgaWRlbnRpY2FsIHRvIHRoZSB0eXBlIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSB0byBjaGVjayBhZ2FpbnN0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1R5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29tcGxleGl0eSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gY29tcGxleGl0eSBvZiB0aGlzIGluc3RhbmNlXG4gICAgICovXG4gICAgY29tcGxleGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBKU09OXG4gICAgICovXG4gICAgdG9KU09OOiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICAvLyBkZWxlZ2F0ZSwgbm90IGFsaWFzXG4gICAgICByZXR1cm4gdGhpcy50b09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBncmFkaWVudCAoZmlsbCBvciBzdHJva2UpIG9mIGFuIG9iamVjdFxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgbWV0aG9kIHdhcyBuYW1lZCBcInNldEdyYWRpZW50RmlsbFwiIHVudGlsIHYxLjEuMFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lICdzdHJva2UnIG9yICdmaWxsJ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudHlwZV0gVHlwZSBvZiBncmFkaWVudCAncmFkaWFsJyBvciAnbGluZWFyJ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy54MT0wXSB4LWNvb3JkaW5hdGUgb2Ygc3RhcnQgcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMueTE9MF0geS1jb29yZGluYXRlIG9mIHN0YXJ0IHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLngyPTBdIHgtY29vcmRpbmF0ZSBvZiBlbmQgcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMueTI9MF0geS1jb29yZGluYXRlIG9mIGVuZCBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yMT0wXSBSYWRpdXMgb2Ygc3RhcnQgcG9pbnQgKG9ubHkgZm9yIHJhZGlhbCBncmFkaWVudHMpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnIyPTBdIFJhZGl1cyBvZiBlbmQgcG9pbnQgKG9ubHkgZm9yIHJhZGlhbCBncmFkaWVudHMpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmNvbG9yU3RvcHNdIENvbG9yIHN0b3BzIG9iamVjdCBlZy4gezA6ICdmZjAwMDAnLCAxOiAnMDAwMDAwJ31cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZ3JhZGllbnRUcmFuc2Zvcm1dIHRyYW5zZm9yTWF0cml4IGZvciBncmFkaWVudFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy81OHk4Yi98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TZXQgbGluZWFyIGdyYWRpZW50PC9jYXB0aW9uPlxuICAgICAqIG9iamVjdC5zZXRHcmFkaWVudCgnZmlsbCcsIHtcbiAgICAgKiAgIHR5cGU6ICdsaW5lYXInLFxuICAgICAqICAgeDE6IC1vYmplY3Qud2lkdGggLyAyLFxuICAgICAqICAgeTE6IDAsXG4gICAgICogICB4Mjogb2JqZWN0LndpZHRoIC8gMixcbiAgICAgKiAgIHkyOiAwLFxuICAgICAqICAgY29sb3JTdG9wczoge1xuICAgICAqICAgICAwOiAncmVkJyxcbiAgICAgKiAgICAgMC41OiAnIzAwNTU1NScsXG4gICAgICogICAgIDE6ICdyZ2JhKDAsMCwyNTUsMC41KSdcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U2V0IHJhZGlhbCBncmFkaWVudDwvY2FwdGlvbj5cbiAgICAgKiBvYmplY3Quc2V0R3JhZGllbnQoJ2ZpbGwnLCB7XG4gICAgICogICB0eXBlOiAncmFkaWFsJyxcbiAgICAgKiAgIHgxOiAwLFxuICAgICAqICAgeTE6IDAsXG4gICAgICogICB4MjogMCxcbiAgICAgKiAgIHkyOiAwLFxuICAgICAqICAgcjE6IG9iamVjdC53aWR0aCAvIDIsXG4gICAgICogICByMjogMTAsXG4gICAgICogICBjb2xvclN0b3BzOiB7XG4gICAgICogICAgIDA6ICdyZWQnLFxuICAgICAqICAgICAwLjU6ICcjMDA1NTU1JyxcbiAgICAgKiAgICAgMTogJ3JnYmEoMCwwLDI1NSwwLjUpJ1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICAgKi9cbiAgICBzZXRHcmFkaWVudDogZnVuY3Rpb24ocHJvcGVydHksIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICB2YXIgZ3JhZGllbnQgPSB7IGNvbG9yU3RvcHM6IFtdIH07XG5cbiAgICAgIGdyYWRpZW50LnR5cGUgPSBvcHRpb25zLnR5cGUgfHwgKG9wdGlvbnMucjEgfHwgb3B0aW9ucy5yMiA/ICdyYWRpYWwnIDogJ2xpbmVhcicpO1xuICAgICAgZ3JhZGllbnQuY29vcmRzID0ge1xuICAgICAgICB4MTogb3B0aW9ucy54MSxcbiAgICAgICAgeTE6IG9wdGlvbnMueTEsXG4gICAgICAgIHgyOiBvcHRpb25zLngyLFxuICAgICAgICB5Mjogb3B0aW9ucy55MlxuICAgICAgfTtcblxuICAgICAgaWYgKG9wdGlvbnMucjEgfHwgb3B0aW9ucy5yMikge1xuICAgICAgICBncmFkaWVudC5jb29yZHMucjEgPSBvcHRpb25zLnIxO1xuICAgICAgICBncmFkaWVudC5jb29yZHMucjIgPSBvcHRpb25zLnIyO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zLmdyYWRpZW50VHJhbnNmb3JtICYmIChncmFkaWVudC5ncmFkaWVudFRyYW5zZm9ybSA9IG9wdGlvbnMuZ3JhZGllbnRUcmFuc2Zvcm0pO1xuXG4gICAgICBmb3IgKHZhciBwb3NpdGlvbiBpbiBvcHRpb25zLmNvbG9yU3RvcHMpIHtcbiAgICAgICAgdmFyIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcihvcHRpb25zLmNvbG9yU3RvcHNbcG9zaXRpb25dKTtcbiAgICAgICAgZ3JhZGllbnQuY29sb3JTdG9wcy5wdXNoKHtcbiAgICAgICAgICBvZmZzZXQ6IHBvc2l0aW9uLFxuICAgICAgICAgIGNvbG9yOiBjb2xvci50b1JnYigpLFxuICAgICAgICAgIG9wYWNpdHk6IGNvbG9yLmdldEFscGhhKClcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnNldChwcm9wZXJ0eSwgZmFicmljLkdyYWRpZW50LmZvck9iamVjdCh0aGlzLCBncmFkaWVudCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHBhdHRlcm4gZmlsbCBvZiBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7KFN0cmluZ3xIVE1MSW1hZ2VFbGVtZW50KX0gb3B0aW9ucy5zb3VyY2UgUGF0dGVybiBzb3VyY2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmVwZWF0PXJlcGVhdF0gUmVwZWF0IHByb3BlcnR5IG9mIGEgcGF0dGVybiAob25lIG9mIHJlcGVhdCwgcmVwZWF0LXgsIHJlcGVhdC15IG9yIG5vLXJlcGVhdClcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0WD0wXSBQYXR0ZXJuIGhvcml6b250YWwgb2Zmc2V0IGZyb20gb2JqZWN0J3MgbGVmdC90b3AgY29ybmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldFk9MF0gUGF0dGVybiB2ZXJ0aWNhbCBvZmZzZXQgZnJvbSBvYmplY3QncyBsZWZ0L3RvcCBjb3JuZXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvUVQzcGEvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U2V0IHBhdHRlcm48L2NhcHRpb24+XG4gICAgICogZmFicmljLnV0aWwubG9hZEltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9lc2NoZXJlc3F1ZV9zdGUucG5nJywgZnVuY3Rpb24oaW1nKSB7XG4gICAgICogICBvYmplY3Quc2V0UGF0dGVybkZpbGwoe1xuICAgICAqICAgICBzb3VyY2U6IGltZyxcbiAgICAgKiAgICAgcmVwZWF0OiAncmVwZWF0J1xuICAgICAqICAgfSk7XG4gICAgICogICBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgc2V0UGF0dGVybkZpbGw6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldCgnZmlsbCcsIG5ldyBmYWJyaWMuUGF0dGVybihvcHRpb25zKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMge0BsaW5rIGZhYnJpYy5PYmplY3Qjc2hhZG93fHNoYWRvd30gb2YgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3Qgb3Igc3RyaW5nIChlLmcuIFwiMnB4IDJweCAxMHB4IHJnYmEoMCwwLDAsMC4yKVwiKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jb2xvcj1yZ2IoMCwwLDApXSBTaGFkb3cgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYmx1cj0wXSBTaGFkb3cgYmx1clxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZzZXRYPTBdIFNoYWRvdyBob3Jpem9udGFsIG9mZnNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZzZXRZPTBdIFNoYWRvdyB2ZXJ0aWNhbCBvZmZzZXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvN2d2SkcvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U2V0IHNoYWRvdyB3aXRoIHN0cmluZyBub3RhdGlvbjwvY2FwdGlvbj5cbiAgICAgKiBvYmplY3Quc2V0U2hhZG93KCcycHggMnB4IDEwcHggcmdiYSgwLDAsMCwwLjIpJyk7XG4gICAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlNldCBzaGFkb3cgd2l0aCBvYmplY3Qgbm90YXRpb248L2NhcHRpb24+XG4gICAgICogb2JqZWN0LnNldFNoYWRvdyh7XG4gICAgICogICBjb2xvcjogJ3JlZCcsXG4gICAgICogICBibHVyOiAxMCxcbiAgICAgKiAgIG9mZnNldFg6IDIwLFxuICAgICAqICAgb2Zmc2V0WTogMjBcbiAgICAgKiB9KTtcbiAgICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAgICovXG4gICAgc2V0U2hhZG93OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoJ3NoYWRvdycsIG9wdGlvbnMgPyBuZXcgZmFicmljLlNoYWRvdyhvcHRpb25zKSA6IG51bGwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIFwiY29sb3JcIiBvZiBhbiBpbnN0YW5jZSAoYWxpYXMgb2YgYHNldCgnZmlsbCcsICZoZWxsaXA7KWApXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIENvbG9yIHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRDb2xvcjogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgIHRoaXMuc2V0KCdmaWxsJywgY29sb3IpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgXCJhbmdsZVwiIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIEFuZ2xlIHZhbHVlIChpbiBkZWdyZWVzKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0QW5nbGU6IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICB2YXIgc2hvdWxkQ2VudGVyT3JpZ2luID0gKHRoaXMub3JpZ2luWCAhPT0gJ2NlbnRlcicgfHwgdGhpcy5vcmlnaW5ZICE9PSAnY2VudGVyJykgJiYgdGhpcy5jZW50ZXJlZFJvdGF0aW9uO1xuXG4gICAgICBpZiAoc2hvdWxkQ2VudGVyT3JpZ2luKSB7XG4gICAgICAgIHRoaXMuX3NldE9yaWdpblRvQ2VudGVyKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0KCdhbmdsZScsIGFuZ2xlKTtcblxuICAgICAgaWYgKHNob3VsZENlbnRlck9yaWdpbikge1xuICAgICAgICB0aGlzLl9yZXNldE9yaWdpbigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgaG9yaXpvbnRhbGx5IG9uIGNhbnZhcyB0byB3aGljaCBpdCB3YXMgYWRkZWQgbGFzdC5cbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2VudGVySDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuY2VudGVyT2JqZWN0SCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBob3Jpem9udGFsbHkgb24gY3VycmVudCB2aWV3cG9ydCBvZiBjYW52YXMgdG8gd2hpY2ggaXQgd2FzIGFkZGVkIGxhc3QuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVySDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMudmlld3BvcnRDZW50ZXJPYmplY3RIKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgb24gY2FudmFzIHRvIHdoaWNoIGl0IHdhcyBhZGRlZCBsYXN0LlxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjZW50ZXJWOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5jZW50ZXJPYmplY3RWKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgb24gY3VycmVudCB2aWV3cG9ydCBvZiBjYW52YXMgdG8gd2hpY2ggaXQgd2FzIGFkZGVkIGxhc3QuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVyVjogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMudmlld3BvcnRDZW50ZXJPYmplY3RWKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseSBvbiBjYW52YXMgdG8gd2hpY2ggaXMgd2FzIGFkZGVkIGxhc3RcbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2VudGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5jZW50ZXJPYmplY3QodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3Qgb24gY3VycmVudCB2aWV3cG9ydCBvZiBjYW52YXMgdG8gd2hpY2ggaXQgd2FzIGFkZGVkIGxhc3QuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy52aWV3cG9ydENlbnRlck9iamVjdCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIG9iamVjdCBmcm9tIGNhbnZhcyB0byB3aGljaCBpdCB3YXMgYWRkZWQgbGFzdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnJlbW92ZSh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnRlciByZWxhdGl2ZSB0byBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IHRvIG9wZXJhdGUgdXBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcG9pbnRlcl0gUG9pbnRlciB0byBvcGVyYXRlIHVwb24gKGluc3RlYWQgb2YgZXZlbnQpXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDb29yZGluYXRlcyBvZiBhIHBvaW50ZXIgKHgsIHkpXG4gICAgICovXG4gICAgZ2V0TG9jYWxQb2ludGVyOiBmdW5jdGlvbihlLCBwb2ludGVyKSB7XG4gICAgICBwb2ludGVyID0gcG9pbnRlciB8fCB0aGlzLmNhbnZhcy5nZXRQb2ludGVyKGUpO1xuICAgICAgdmFyIHBDbGlja2VkID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSksXG4gICAgICAgICAgb2JqZWN0TGVmdFRvcCA9IHRoaXMuX2dldExlZnRUb3BDb29yZHMoKTtcbiAgICAgIGlmICh0aGlzLmFuZ2xlKSB7XG4gICAgICAgIHBDbGlja2VkID0gZmFicmljLnV0aWwucm90YXRlUG9pbnQoXG4gICAgICAgICAgcENsaWNrZWQsIG9iamVjdExlZnRUb3AsIGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMoLXRoaXMuYW5nbGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHBDbGlja2VkLnggLSBvYmplY3RMZWZ0VG9wLngsXG4gICAgICAgIHk6IHBDbGlja2VkLnkgLSBvYmplY3RMZWZ0VG9wLnlcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgY2FudmFzIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiBmb3Igc3BlY2lmaWMgb2JqZWN0XG4gICAgICogY3VzdG9tIGNvbXBvc2l0aW9uIG9wZXJhdGlvbiBmb3IgdGhlIHBhcnRpY3VsYXIgb2JqZWN0IGNhbiBiZSBzcGVjaWZlZCB1c2luZyBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFJlbmRlcmluZyBjYW52YXMgY29udGV4dFxuICAgICAqL1xuICAgIF9zZXR1cENvbXBvc2l0ZU9wZXJhdGlvbjogZnVuY3Rpb24gKGN0eCkge1xuICAgICAgaWYgKHRoaXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uKSB7XG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSB0aGlzLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGZhYnJpYy51dGlsLmNyZWF0ZUFjY2Vzc29ycyhmYWJyaWMuT2JqZWN0KTtcblxuICAvKipcbiAgICogQWxpYXMgZm9yIHtAbGluayBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5zZXRBbmdsZX1cbiAgICogQGFsaWFzIHJvdGF0ZSAtPiBzZXRBbmdsZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdFxuICAgKi9cbiAgZmFicmljLk9iamVjdC5wcm90b3R5cGUucm90YXRlID0gZmFicmljLk9iamVjdC5wcm90b3R5cGUuc2V0QW5nbGU7XG5cbiAgZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCBmYWJyaWMuT2JzZXJ2YWJsZSk7XG5cbiAgLyoqXG4gICAqIERlZmluZXMgdGhlIG51bWJlciBvZiBmcmFjdGlvbiBkaWdpdHMgdG8gdXNlIHdoZW4gc2VyaWFsaXppbmcgb2JqZWN0IHZhbHVlcy5cbiAgICogWW91IGNhbiB1c2UgaXQgdG8gaW5jcmVhc2UvZGVjcmVhc2UgcHJlY2lzaW9uIG9mIHN1Y2ggdmFsdWVzIGxpa2UgbGVmdCwgdG9wLCBzY2FsZVgsIHNjYWxlWSwgZXRjLlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0XG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICovXG4gIGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IDI7XG5cbiAgLyoqXG4gICAqIFVuaXF1ZSBpZCB1c2VkIGludGVybmFsbHkgd2hlbiBjcmVhdGluZyBTVkcgZWxlbWVudHNcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdFxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICovXG4gIGZhYnJpYy5PYmplY3QuX191aWQgPSAwO1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBkZWdyZWVzVG9SYWRpYW5zID0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyxcbiAgICAgIG9yaWdpblhPZmZzZXQgPSB7XG4gICAgICAgIGxlZnQ6IC0wLjUsXG4gICAgICAgIGNlbnRlcjogMCxcbiAgICAgICAgcmlnaHQ6IDAuNVxuICAgICAgfSxcbiAgICAgIG9yaWdpbllPZmZzZXQgPSB7XG4gICAgICAgIHRvcDogLTAuNSxcbiAgICAgICAgY2VudGVyOiAwLFxuICAgICAgICBib3R0b206IDAuNVxuICAgICAgfTtcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgdGhlIGNvb3JkaW5hdGVzIGZyb20gb3JpZ2luIHRvIGNlbnRlciBjb29yZGluYXRlcyAoYmFzZWQgb24gdGhlIG9iamVjdCdzIGRpbWVuc2lvbnMpXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFRoZSBwb2ludCB3aGljaCBjb3JyZXNwb25kcyB0byB0aGUgb3JpZ2luWCBhbmQgb3JpZ2luWSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZnJvbU9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmcm9tT3JpZ2luWSBWZXJ0aWNhbCBvcmlnaW46ICd0b3AnLCAnY2VudGVyJyBvciAnYm90dG9tJ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b09yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b09yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgdHJhbnNsYXRlVG9HaXZlbk9yaWdpbjogZnVuY3Rpb24ocG9pbnQsIGZyb21PcmlnaW5YLCBmcm9tT3JpZ2luWSwgdG9PcmlnaW5YLCB0b09yaWdpblkpIHtcbiAgICAgIHZhciB4ID0gcG9pbnQueCxcbiAgICAgICAgICB5ID0gcG9pbnQueSxcbiAgICAgICAgICBvZmZzZXRYLCBvZmZzZXRZLCBkaW07XG5cbiAgICAgIGlmICh0eXBlb2YgZnJvbU9yaWdpblggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZyb21PcmlnaW5YID0gb3JpZ2luWE9mZnNldFtmcm9tT3JpZ2luWF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZnJvbU9yaWdpblggLT0gMC41O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRvT3JpZ2luWCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdG9PcmlnaW5YID0gb3JpZ2luWE9mZnNldFt0b09yaWdpblhdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRvT3JpZ2luWCAtPSAwLjU7XG4gICAgICB9XG5cbiAgICAgIG9mZnNldFggPSB0b09yaWdpblggLSBmcm9tT3JpZ2luWDtcblxuICAgICAgaWYgKHR5cGVvZiBmcm9tT3JpZ2luWSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZnJvbU9yaWdpblkgPSBvcmlnaW5ZT2Zmc2V0W2Zyb21PcmlnaW5ZXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmcm9tT3JpZ2luWSAtPSAwLjU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdG9PcmlnaW5ZID09PSAnc3RyaW5nJykge1xuICAgICAgICB0b09yaWdpblkgPSBvcmlnaW5ZT2Zmc2V0W3RvT3JpZ2luWV07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdG9PcmlnaW5ZIC09IDAuNTtcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0WSA9IHRvT3JpZ2luWSAtIGZyb21PcmlnaW5ZO1xuXG4gICAgICBpZiAob2Zmc2V0WCB8fCBvZmZzZXRZKSB7XG4gICAgICAgIGRpbSA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpO1xuICAgICAgICB4ID0gcG9pbnQueCArIG9mZnNldFggKiBkaW0ueDtcbiAgICAgICAgeSA9IHBvaW50LnkgKyBvZmZzZXRZICogZGltLnk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgZmFicmljLlBvaW50KHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSBjb29yZGluYXRlcyBmcm9tIG9yaWdpbiB0byBjZW50ZXIgY29vcmRpbmF0ZXMgKGJhc2VkIG9uIHRoZSBvYmplY3QncyBkaW1lbnNpb25zKVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBUaGUgcG9pbnQgd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhlIG9yaWdpblggYW5kIG9yaWdpblkgcGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIHRyYW5zbGF0ZVRvQ2VudGVyUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBvcmlnaW5YLCBvcmlnaW5ZKSB7XG4gICAgICB2YXIgcCA9IHRoaXMudHJhbnNsYXRlVG9HaXZlbk9yaWdpbihwb2ludCwgb3JpZ2luWCwgb3JpZ2luWSwgJ2NlbnRlcicsICdjZW50ZXInKTtcbiAgICAgIGlmICh0aGlzLmFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBmYWJyaWMudXRpbC5yb3RhdGVQb2ludChwLCBwb2ludCwgZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyB0aGUgY29vcmRpbmF0ZXMgZnJvbSBjZW50ZXIgdG8gb3JpZ2luIGNvb3JkaW5hdGVzIChiYXNlZCBvbiB0aGUgb2JqZWN0J3MgZGltZW5zaW9ucylcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gY2VudGVyIFRoZSBwb2ludCB3aGljaCBjb3JyZXNwb25kcyB0byBjZW50ZXIgb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5YIEhvcml6b250YWwgb3JpZ2luOiAnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWSBWZXJ0aWNhbCBvcmlnaW46ICd0b3AnLCAnY2VudGVyJyBvciAnYm90dG9tJ1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICB0cmFuc2xhdGVUb09yaWdpblBvaW50OiBmdW5jdGlvbihjZW50ZXIsIG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICAgIHZhciBwID0gdGhpcy50cmFuc2xhdGVUb0dpdmVuT3JpZ2luKGNlbnRlciwgJ2NlbnRlcicsICdjZW50ZXInLCBvcmlnaW5YLCBvcmlnaW5ZKTtcbiAgICAgIGlmICh0aGlzLmFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBmYWJyaWMudXRpbC5yb3RhdGVQb2ludChwLCBjZW50ZXIsIGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlYWwgY2VudGVyIGNvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgZ2V0Q2VudGVyUG9pbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlZnRUb3AgPSBuZXcgZmFicmljLlBvaW50KHRoaXMubGVmdCwgdGhpcy50b3ApO1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlVG9DZW50ZXJQb2ludChsZWZ0VG9wLCB0aGlzLm9yaWdpblgsIHRoaXMub3JpZ2luWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3QgYmFzZWQgb24gY2VudGVyIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFRoZSBwb2ludCB3aGljaCBjb3JyZXNwb25kcyB0byB0aGUgb3JpZ2luWCBhbmQgb3JpZ2luWSBwYXJhbXNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgLy8gZ2V0T3JpZ2luUG9pbnQ6IGZ1bmN0aW9uKGNlbnRlcikge1xuICAgIC8vICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlVG9PcmlnaW5Qb2ludChjZW50ZXIsIHRoaXMub3JpZ2luWCwgdGhpcy5vcmlnaW5ZKTtcbiAgICAvLyB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBhcyBpZiBpdCBoYXMgYSBkaWZmZXJlbnQgb3JpZ2luXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIGdldFBvaW50QnlPcmlnaW46IGZ1bmN0aW9uKG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCk7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVUb09yaWdpblBvaW50KGNlbnRlciwgb3JpZ2luWCwgb3JpZ2luWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvaW50IGluIGxvY2FsIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFRoZSBwb2ludCByZWxhdGl2ZSB0byB0aGUgZ2xvYmFsIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIHRvTG9jYWxQb2ludDogZnVuY3Rpb24ocG9pbnQsIG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCksXG4gICAgICAgICAgcCwgcDI7XG5cbiAgICAgIGlmICh0eXBlb2Ygb3JpZ2luWCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG9yaWdpblkgIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICBwID0gdGhpcy50cmFuc2xhdGVUb0dpdmVuT3JpZ2luKGNlbnRlciwgJ2NlbnRlcicsICdjZW50ZXInLCBvcmlnaW5YLCBvcmlnaW5ZKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwID0gbmV3IGZhYnJpYy5Qb2ludCh0aGlzLmxlZnQsIHRoaXMudG9wKTtcbiAgICAgIH1cblxuICAgICAgcDIgPSBuZXcgZmFicmljLlBvaW50KHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgaWYgKHRoaXMuYW5nbGUpIHtcbiAgICAgICAgcDIgPSBmYWJyaWMudXRpbC5yb3RhdGVQb2ludChwMiwgY2VudGVyLCAtZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcDIuc3VidHJhY3RFcXVhbHMocCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvaW50IGluIGdsb2JhbCBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBUaGUgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIC8vIHRvR2xvYmFsUG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgLy8gICByZXR1cm4gZmFicmljLnV0aWwucm90YXRlUG9pbnQocG9pbnQsIHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSwgZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSkuYWRkRXF1YWxzKG5ldyBmYWJyaWMuUG9pbnQodGhpcy5sZWZ0LCB0aGlzLnRvcCkpO1xuICAgIC8vIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgb2JqZWN0IHRha2luZyBpbnRvIGNvbnNpZGVyYXRpb24gdGhlIG9iamVjdCdzIG9yaWdpblxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb3MgVGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBzZXRQb3NpdGlvbkJ5T3JpZ2luOiBmdW5jdGlvbihwb3MsIG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLnRyYW5zbGF0ZVRvQ2VudGVyUG9pbnQocG9zLCBvcmlnaW5YLCBvcmlnaW5ZKSxcbiAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMudHJhbnNsYXRlVG9PcmlnaW5Qb2ludChjZW50ZXIsIHRoaXMub3JpZ2luWCwgdGhpcy5vcmlnaW5ZKTtcblxuICAgICAgdGhpcy5zZXQoJ2xlZnQnLCBwb3NpdGlvbi54KTtcbiAgICAgIHRoaXMuc2V0KCd0b3AnLCBwb3NpdGlvbi55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRvIE9uZSBvZiAnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXG4gICAgICovXG4gICAgYWRqdXN0UG9zaXRpb246IGZ1bmN0aW9uKHRvKSB7XG4gICAgICB2YXIgYW5nbGUgPSBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpLFxuICAgICAgICAgIGh5cG90RnVsbCA9IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgICB4RnVsbCA9IE1hdGguY29zKGFuZ2xlKSAqIGh5cG90RnVsbCxcbiAgICAgICAgICB5RnVsbCA9IE1hdGguc2luKGFuZ2xlKSAqIGh5cG90RnVsbCxcbiAgICAgICAgICBvZmZzZXRGcm9tLCBvZmZzZXRUbztcblxuICAgICAgLy9UT0RPOiB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IGNvbnNpZGVyIG1peGVkIHNpdHVhdGlvbiBsaWtlIHRvcCwgY2VudGVyLlxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9yaWdpblggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9mZnNldEZyb20gPSBvcmlnaW5YT2Zmc2V0W3RoaXMub3JpZ2luWF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb2Zmc2V0RnJvbSA9IHRoaXMub3JpZ2luWCAtIDAuNTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9mZnNldFRvID0gb3JpZ2luWE9mZnNldFt0b107XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb2Zmc2V0VG8gPSB0byAtIDAuNTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGVmdCArPSB4RnVsbCAqIChvZmZzZXRUbyAtIG9mZnNldEZyb20pO1xuICAgICAgdGhpcy50b3AgKz0geUZ1bGwgKiAob2Zmc2V0VG8gLSBvZmZzZXRGcm9tKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLm9yaWdpblggPSB0bztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgb3JpZ2luL3Bvc2l0aW9uIG9mIHRoZSBvYmplY3QgdG8gaXQncyBjZW50ZXIgcG9pbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgX3NldE9yaWdpblRvQ2VudGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWCA9IHRoaXMub3JpZ2luWDtcbiAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWSA9IHRoaXMub3JpZ2luWTtcblxuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKTtcblxuICAgICAgdGhpcy5vcmlnaW5YID0gJ2NlbnRlcic7XG4gICAgICB0aGlzLm9yaWdpblkgPSAnY2VudGVyJztcblxuICAgICAgdGhpcy5sZWZ0ID0gY2VudGVyLng7XG4gICAgICB0aGlzLnRvcCA9IGNlbnRlci55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIG9yaWdpbi9wb3NpdGlvbiBvZiB0aGUgb2JqZWN0IHRvIGl0J3Mgb3JpZ2luYWwgb3JpZ2luXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIF9yZXNldE9yaWdpbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3JpZ2luUG9pbnQgPSB0aGlzLnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQoXG4gICAgICAgIHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSxcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxPcmlnaW5YLFxuICAgICAgICB0aGlzLl9vcmlnaW5hbE9yaWdpblkpO1xuXG4gICAgICB0aGlzLm9yaWdpblggPSB0aGlzLl9vcmlnaW5hbE9yaWdpblg7XG4gICAgICB0aGlzLm9yaWdpblkgPSB0aGlzLl9vcmlnaW5hbE9yaWdpblk7XG5cbiAgICAgIHRoaXMubGVmdCA9IG9yaWdpblBvaW50Lng7XG4gICAgICB0aGlzLnRvcCA9IG9yaWdpblBvaW50Lnk7XG5cbiAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWCA9IG51bGw7XG4gICAgICB0aGlzLl9vcmlnaW5hbE9yaWdpblkgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRMZWZ0VG9wQ29vcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQodGhpcy5nZXRDZW50ZXJQb2ludCgpLCAnbGVmdCcsICd0b3AnKTtcbiAgICB9XG4gIH0pO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICBmdW5jdGlvbiBnZXRDb29yZHMob0Nvb3Jkcykge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgZmFicmljLlBvaW50KG9Db29yZHMudGwueCwgb0Nvb3Jkcy50bC55KSxcbiAgICAgIG5ldyBmYWJyaWMuUG9pbnQob0Nvb3Jkcy50ci54LCBvQ29vcmRzLnRyLnkpLFxuICAgICAgbmV3IGZhYnJpYy5Qb2ludChvQ29vcmRzLmJyLngsIG9Db29yZHMuYnIueSksXG4gICAgICBuZXcgZmFicmljLlBvaW50KG9Db29yZHMuYmwueCwgb0Nvb3Jkcy5ibC55KVxuICAgIF07XG4gIH1cblxuICB2YXIgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgICBtdWx0aXBseU1hdHJpY2VzID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcztcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIE9iamVjdCBjb250YWluaW5nIGNvb3JkaW5hdGVzIG9mIG9iamVjdCdzIGNvbnRyb2xzXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvQ29vcmRzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIG9iamVjdCBpbnRlcnNlY3RzIHdpdGggYW4gYXJlYSBmb3JtZWQgYnkgMiBwb2ludHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRUTCB0b3AtbGVmdCBwb2ludCBvZiBhcmVhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50QlIgYm90dG9tLXJpZ2h0IHBvaW50IG9mIGFyZWFcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9iamVjdCBpbnRlcnNlY3RzIHdpdGggYW4gYXJlYSBmb3JtZWQgYnkgMiBwb2ludHNcbiAgICAgKi9cbiAgICBpbnRlcnNlY3RzV2l0aFJlY3Q6IGZ1bmN0aW9uKHBvaW50VEwsIHBvaW50QlIpIHtcbiAgICAgIHZhciBvQ29vcmRzID0gZ2V0Q29vcmRzKHRoaXMub0Nvb3JkcyksXG4gICAgICAgICAgaW50ZXJzZWN0aW9uID0gZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RQb2x5Z29uUmVjdGFuZ2xlKFxuICAgICAgICAgICAgb0Nvb3JkcyxcbiAgICAgICAgICAgIHBvaW50VEwsXG4gICAgICAgICAgICBwb2ludEJSXG4gICAgICAgICAgKTtcbiAgICAgIHJldHVybiBpbnRlcnNlY3Rpb24uc3RhdHVzID09PSAnSW50ZXJzZWN0aW9uJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIG9iamVjdCBpbnRlcnNlY3RzIHdpdGggYW5vdGhlciBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgT2JqZWN0IHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9iamVjdCBpbnRlcnNlY3RzIHdpdGggYW5vdGhlciBvYmplY3RcbiAgICAgKi9cbiAgICBpbnRlcnNlY3RzV2l0aE9iamVjdDogZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBmYWJyaWMuSW50ZXJzZWN0aW9uLmludGVyc2VjdFBvbHlnb25Qb2x5Z29uKFxuICAgICAgICAgICAgZ2V0Q29vcmRzKHRoaXMub0Nvb3JkcyksXG4gICAgICAgICAgICBnZXRDb29yZHMob3RoZXIub0Nvb3JkcylcbiAgICAgICAgICApO1xuXG4gICAgICByZXR1cm4gaW50ZXJzZWN0aW9uLnN0YXR1cyA9PT0gJ0ludGVyc2VjdGlvbidcbiAgICAgICAgfHwgb3RoZXIuaXNDb250YWluZWRXaXRoaW5PYmplY3QodGhpcylcbiAgICAgICAgfHwgdGhpcy5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdChvdGhlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBvYmplY3QgaXMgZnVsbHkgY29udGFpbmVkIHdpdGhpbiBhcmVhIG9mIGFub3RoZXIgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIE9iamVjdCB0byB0ZXN0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaXMgZnVsbHkgY29udGFpbmVkIHdpdGhpbiBhcmVhIG9mIGFub3RoZXIgb2JqZWN0XG4gICAgICovXG4gICAgaXNDb250YWluZWRXaXRoaW5PYmplY3Q6IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICB2YXIgcG9pbnRzID0gZ2V0Q29vcmRzKHRoaXMub0Nvb3JkcyksXG4gICAgICAgICAgaSA9IDA7XG4gICAgICBmb3IgKDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBpZiAoIW90aGVyLmNvbnRhaW5zUG9pbnQocG9pbnRzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBvYmplY3QgaXMgZnVsbHkgY29udGFpbmVkIHdpdGhpbiBhcmVhIGZvcm1lZCBieSAyIHBvaW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludFRMIHRvcC1sZWZ0IHBvaW50IG9mIGFyZWFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRCUiBib3R0b20tcmlnaHQgcG9pbnQgb2YgYXJlYVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgb2JqZWN0IGlzIGZ1bGx5IGNvbnRhaW5lZCB3aXRoaW4gYXJlYSBmb3JtZWQgYnkgMiBwb2ludHNcbiAgICAgKi9cbiAgICBpc0NvbnRhaW5lZFdpdGhpblJlY3Q6IGZ1bmN0aW9uKHBvaW50VEwsIHBvaW50QlIpIHtcbiAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICBib3VuZGluZ1JlY3QubGVmdCA+PSBwb2ludFRMLnggJiZcbiAgICAgICAgYm91bmRpbmdSZWN0LmxlZnQgKyBib3VuZGluZ1JlY3Qud2lkdGggPD0gcG9pbnRCUi54ICYmXG4gICAgICAgIGJvdW5kaW5nUmVjdC50b3AgPj0gcG9pbnRUTC55ICYmXG4gICAgICAgIGJvdW5kaW5nUmVjdC50b3AgKyBib3VuZGluZ1JlY3QuaGVpZ2h0IDw9IHBvaW50QlIueVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHBvaW50IGlzIGluc2lkZSB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFBvaW50IHRvIGNoZWNrIGFnYWluc3RcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHBvaW50IGlzIGluc2lkZSB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgY29udGFpbnNQb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgIGlmICghdGhpcy5vQ29vcmRzKSB7XG4gICAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB9XG4gICAgICB2YXIgbGluZXMgPSB0aGlzLl9nZXRJbWFnZUxpbmVzKHRoaXMub0Nvb3JkcyksXG4gICAgICAgICAgeFBvaW50cyA9IHRoaXMuX2ZpbmRDcm9zc1BvaW50cyhwb2ludCwgbGluZXMpO1xuXG4gICAgICAvLyBpZiB4UG9pbnRzIGlzIG9kZCB0aGVuIHBvaW50IGlzIGluc2lkZSB0aGUgb2JqZWN0XG4gICAgICByZXR1cm4gKHhQb2ludHMgIT09IDAgJiYgeFBvaW50cyAlIDIgPT09IDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBvYmplY3QgZWRnZXMgaW4gaXQsIGdpdmVuIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgY29ybmVyc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9Db29yZHMgQ29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBjb3JuZXJzXG4gICAgICovXG4gICAgX2dldEltYWdlTGluZXM6IGZ1bmN0aW9uKG9Db29yZHMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcGxpbmU6IHtcbiAgICAgICAgICBvOiBvQ29vcmRzLnRsLFxuICAgICAgICAgIGQ6IG9Db29yZHMudHJcbiAgICAgICAgfSxcbiAgICAgICAgcmlnaHRsaW5lOiB7XG4gICAgICAgICAgbzogb0Nvb3Jkcy50cixcbiAgICAgICAgICBkOiBvQ29vcmRzLmJyXG4gICAgICAgIH0sXG4gICAgICAgIGJvdHRvbWxpbmU6IHtcbiAgICAgICAgICBvOiBvQ29vcmRzLmJyLFxuICAgICAgICAgIGQ6IG9Db29yZHMuYmxcbiAgICAgICAgfSxcbiAgICAgICAgbGVmdGxpbmU6IHtcbiAgICAgICAgICBvOiBvQ29vcmRzLmJsLFxuICAgICAgICAgIGQ6IG9Db29yZHMudGxcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBkZXRlcm1pbmUgaG93IG1hbnkgY3Jvc3MgcG9pbnRzIGFyZSBiZXR3ZWVuIHRoZSA0IG9iamVjdCBlZGdlc1xuICAgICAqIGFuZCB0aGUgaG9yaXpvbnRhbCBsaW5lIGRldGVybWluZWQgYnkgYSBwb2ludCBvbiBjYW52YXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBQb2ludCB0byBjaGVja1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvQ29vcmRzIENvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3QgYmVpbmcgZXZhbHVhdGVkXG4gICAgICovXG4gICAgIC8vIHJlbW92ZSB5aSwgbm90IHVzZWQgYnV0IGxlZnQgY29kZSBoZXJlIGp1c3QgaW4gY2FzZS5cbiAgICBfZmluZENyb3NzUG9pbnRzOiBmdW5jdGlvbihwb2ludCwgb0Nvb3Jkcykge1xuICAgICAgdmFyIGIxLCBiMiwgYTEsIGEyLCB4aSwgLy8geWksXG4gICAgICAgICAgeGNvdW50ID0gMCxcbiAgICAgICAgICBpTGluZTtcblxuICAgICAgZm9yICh2YXIgbGluZUtleSBpbiBvQ29vcmRzKSB7XG4gICAgICAgIGlMaW5lID0gb0Nvb3Jkc1tsaW5lS2V5XTtcbiAgICAgICAgLy8gb3B0aW1pc2F0aW9uIDE6IGxpbmUgYmVsb3cgcG9pbnQuIG5vIGNyb3NzXG4gICAgICAgIGlmICgoaUxpbmUuby55IDwgcG9pbnQueSkgJiYgKGlMaW5lLmQueSA8IHBvaW50LnkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3B0aW1pc2F0aW9uIDI6IGxpbmUgYWJvdmUgcG9pbnQuIG5vIGNyb3NzXG4gICAgICAgIGlmICgoaUxpbmUuby55ID49IHBvaW50LnkpICYmIChpTGluZS5kLnkgPj0gcG9pbnQueSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvcHRpbWlzYXRpb24gMzogdmVydGljYWwgbGluZSBjYXNlXG4gICAgICAgIGlmICgoaUxpbmUuby54ID09PSBpTGluZS5kLngpICYmIChpTGluZS5vLnggPj0gcG9pbnQueCkpIHtcbiAgICAgICAgICB4aSA9IGlMaW5lLm8ueDtcbiAgICAgICAgICAvLyB5aSA9IHBvaW50Lnk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYjEgPSAwO1xuICAgICAgICAgIGIyID0gKGlMaW5lLmQueSAtIGlMaW5lLm8ueSkgLyAoaUxpbmUuZC54IC0gaUxpbmUuby54KTtcbiAgICAgICAgICBhMSA9IHBvaW50LnkgLSBiMSAqIHBvaW50Lng7XG4gICAgICAgICAgYTIgPSBpTGluZS5vLnkgLSBiMiAqIGlMaW5lLm8ueDtcblxuICAgICAgICAgIHhpID0gLShhMSAtIGEyKSAvIChiMSAtIGIyKTtcbiAgICAgICAgICAvLyB5aSA9IGExICsgYjEgKiB4aTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkb250IGNvdW50IHhpIDwgcG9pbnQueCBjYXNlc1xuICAgICAgICBpZiAoeGkgPj0gcG9pbnQueCkge1xuICAgICAgICAgIHhjb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9wdGltaXNhdGlvbiA0OiBzcGVjaWZpYyBmb3Igc3F1YXJlIGltYWdlc1xuICAgICAgICBpZiAoeGNvdW50ID09PSAyKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB4Y291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2lkdGggb2YgYW4gb2JqZWN0J3MgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgMS4wLjRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHdpZHRoIHZhbHVlXG4gICAgICovXG4gICAgZ2V0Qm91bmRpbmdSZWN0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaGVpZ2h0IG9mIGFuIG9iamVjdCdzIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIDEuMC40XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBoZWlnaHQgdmFsdWVcbiAgICAgKi9cbiAgICBnZXRCb3VuZGluZ1JlY3RIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvb3JkaW5hdGVzIG9mIG9iamVjdCdzIGJvdW5kaW5nIHJlY3RhbmdsZSAobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHdpdGggbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5vQ29vcmRzIHx8IHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwubWFrZUJvdW5kaW5nQm94RnJvbVBvaW50cyhbXG4gICAgICAgIHRoaXMub0Nvb3Jkcy50bCxcbiAgICAgICAgdGhpcy5vQ29vcmRzLnRyLFxuICAgICAgICB0aGlzLm9Db29yZHMuYnIsXG4gICAgICAgIHRoaXMub0Nvb3Jkcy5ibFxuICAgICAgXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2lkdGggb2YgYW4gb2JqZWN0IGJvdW5kaW5nIGJveCBjb3VudGluZyB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHdpZHRoIHZhbHVlXG4gICAgICovXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpLng7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaGVpZ2h0IG9mIGFuIG9iamVjdCBib3VuZGluZyBib3ggY291bnRpbmcgdHJhbnNmb3JtYXRpb25zXG4gICAgICogdG8gYmUgcmVuYW1lZCBpbiAyLjBcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGhlaWdodCB2YWx1ZVxuICAgICAqL1xuICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCkueTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZXMgc3VyZSB0aGUgc2NhbGUgaXMgdmFsaWQgYW5kIG1vZGlmaWVzIGl0IGlmIG5lY2Vzc2FyeVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIF9jb25zdHJhaW5TY2FsZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmIChNYXRoLmFicyh2YWx1ZSkgPCB0aGlzLm1pblNjYWxlTGltaXQpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICAgIHJldHVybiAtdGhpcy5taW5TY2FsZUxpbWl0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1pblNjYWxlTGltaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2NhbGVzIGFuIG9iamVjdCAoZXF1YWxseSBieSB4IGFuZCB5KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBTY2FsZSBmYWN0b3JcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNjYWxlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFsdWUgPSB0aGlzLl9jb25zdHJhaW5TY2FsZSh2YWx1ZSk7XG5cbiAgICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgdGhpcy5mbGlwWCA9ICF0aGlzLmZsaXBYO1xuICAgICAgICB0aGlzLmZsaXBZID0gIXRoaXMuZmxpcFk7XG4gICAgICAgIHZhbHVlICo9IC0xO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNjYWxlWCA9IHZhbHVlO1xuICAgICAgdGhpcy5zY2FsZVkgPSB2YWx1ZTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2NhbGVzIGFuIG9iamVjdCB0byBhIGdpdmVuIHdpZHRoLCB3aXRoIHJlc3BlY3QgdG8gYm91bmRpbmcgYm94IChzY2FsaW5nIGJ5IHgveSBlcXVhbGx5KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBOZXcgd2lkdGggdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNjYWxlVG9XaWR0aDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIC8vIGFkanVzdCB0byBib3VuZGluZyByZWN0IGZhY3RvciBzbyB0aGF0IHJvdGF0ZWQgc2hhcGVzIHdvdWxkIGZpdCBhcyB3ZWxsXG4gICAgICB2YXIgYm91bmRpbmdSZWN0RmFjdG9yID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAvIHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgIHJldHVybiB0aGlzLnNjYWxlKHZhbHVlIC8gdGhpcy53aWR0aCAvIGJvdW5kaW5nUmVjdEZhY3Rvcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlcyBhbiBvYmplY3QgdG8gYSBnaXZlbiBoZWlnaHQsIHdpdGggcmVzcGVjdCB0byBib3VuZGluZyBib3ggKHNjYWxpbmcgYnkgeC95IGVxdWFsbHkpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIE5ldyBoZWlnaHQgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNjYWxlVG9IZWlnaHQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAvLyBhZGp1c3QgdG8gYm91bmRpbmcgcmVjdCBmYWN0b3Igc28gdGhhdCByb3RhdGVkIHNoYXBlcyB3b3VsZCBmaXQgYXMgd2VsbFxuICAgICAgdmFyIGJvdW5kaW5nUmVjdEZhY3RvciA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0IC8gdGhpcy5nZXRIZWlnaHQoKTtcbiAgICAgIHJldHVybiB0aGlzLnNjYWxlKHZhbHVlIC8gdGhpcy5oZWlnaHQgLyBib3VuZGluZ1JlY3RGYWN0b3IpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGNvcm5lciBwb3NpdGlvbiBjb29yZGluYXRlcyBiYXNlZCBvbiBjdXJyZW50IGFuZ2xlLCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9rYW5nYXgvZmFicmljLmpzL3dpa2kvV2hlbi10by1jYWxsLXNldENvb3Jkc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0Q29vcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0aGV0YSA9IGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSksXG4gICAgICAgICAgdnB0ID0gdGhpcy5nZXRWaWV3cG9ydFRyYW5zZm9ybSgpLFxuICAgICAgICAgIGRpbSA9IHRoaXMuX2NhbGN1bGF0ZUN1cnJlbnREaW1lbnNpb25zKCksXG4gICAgICAgICAgY3VycmVudFdpZHRoID0gZGltLngsIGN1cnJlbnRIZWlnaHQgPSBkaW0ueTtcblxuICAgICAgLy8gSWYgd2lkdGggaXMgbmVnYXRpdmUsIG1ha2UgcG9zdGl2ZS4gRml4ZXMgcGF0aCBzZWxlY3Rpb24gaXNzdWVcbiAgICAgIGlmIChjdXJyZW50V2lkdGggPCAwKSB7XG4gICAgICAgIGN1cnJlbnRXaWR0aCA9IE1hdGguYWJzKGN1cnJlbnRXaWR0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaW5UaCA9IE1hdGguc2luKHRoZXRhKSxcbiAgICAgICAgICBjb3NUaCA9IE1hdGguY29zKHRoZXRhKSxcbiAgICAgICAgICBfYW5nbGUgPSBjdXJyZW50V2lkdGggPiAwID8gTWF0aC5hdGFuKGN1cnJlbnRIZWlnaHQgLyBjdXJyZW50V2lkdGgpIDogMCxcbiAgICAgICAgICBfaHlwb3RlbnVzZSA9IChjdXJyZW50V2lkdGggLyBNYXRoLmNvcyhfYW5nbGUpKSAvIDIsXG4gICAgICAgICAgb2Zmc2V0WCA9IE1hdGguY29zKF9hbmdsZSArIHRoZXRhKSAqIF9oeXBvdGVudXNlLFxuICAgICAgICAgIG9mZnNldFkgPSBNYXRoLnNpbihfYW5nbGUgKyB0aGV0YSkgKiBfaHlwb3RlbnVzZSxcblxuICAgICAgICAgIC8vIG9mZnNldCBhZGRlZCBmb3Igcm90YXRlIGFuZCBzY2FsZSBhY3Rpb25zXG4gICAgICAgICAgY29vcmRzID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQodGhpcy5nZXRDZW50ZXJQb2ludCgpLCB2cHQpLFxuICAgICAgICAgIHRsICA9IG5ldyBmYWJyaWMuUG9pbnQoY29vcmRzLnggLSBvZmZzZXRYLCBjb29yZHMueSAtIG9mZnNldFkpLFxuICAgICAgICAgIHRyICA9IG5ldyBmYWJyaWMuUG9pbnQodGwueCArIChjdXJyZW50V2lkdGggKiBjb3NUaCksIHRsLnkgKyAoY3VycmVudFdpZHRoICogc2luVGgpKSxcbiAgICAgICAgICBibCAgPSBuZXcgZmFicmljLlBvaW50KHRsLnggLSAoY3VycmVudEhlaWdodCAqIHNpblRoKSwgdGwueSArIChjdXJyZW50SGVpZ2h0ICogY29zVGgpKSxcbiAgICAgICAgICBiciAgPSBuZXcgZmFicmljLlBvaW50KGNvb3Jkcy54ICsgb2Zmc2V0WCwgY29vcmRzLnkgKyBvZmZzZXRZKSxcbiAgICAgICAgICBtbCAgPSBuZXcgZmFicmljLlBvaW50KCh0bC54ICsgYmwueCkgLyAyLCAodGwueSArIGJsLnkpIC8gMiksXG4gICAgICAgICAgbXQgID0gbmV3IGZhYnJpYy5Qb2ludCgodHIueCArIHRsLngpIC8gMiwgKHRyLnkgKyB0bC55KSAvIDIpLFxuICAgICAgICAgIG1yICA9IG5ldyBmYWJyaWMuUG9pbnQoKGJyLnggKyB0ci54KSAvIDIsIChici55ICsgdHIueSkgLyAyKSxcbiAgICAgICAgICBtYiAgPSBuZXcgZmFicmljLlBvaW50KChici54ICsgYmwueCkgLyAyLCAoYnIueSArIGJsLnkpIC8gMiksXG4gICAgICAgICAgbXRyID0gbmV3IGZhYnJpYy5Qb2ludChtdC54ICsgc2luVGggKiB0aGlzLnJvdGF0aW5nUG9pbnRPZmZzZXQsIG10LnkgLSBjb3NUaCAqIHRoaXMucm90YXRpbmdQb2ludE9mZnNldCk7XG4gICAgICAvLyBkZWJ1Z2dpbmdcblxuICAgICAgLyogc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxTdHlsZSA9ICdncmVlbic7XG4gICAgICAgICBjYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChtYi54LCBtYi55LCAzLCAzKTtcbiAgICAgICAgIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGJsLngsIGJsLnksIDMsIDMpO1xuICAgICAgICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QoYnIueCwgYnIueSwgMywgMyk7XG4gICAgICAgICBjYW52YXMuY29udGV4dFRvcC5maWxsUmVjdCh0bC54LCB0bC55LCAzLCAzKTtcbiAgICAgICAgIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KHRyLngsIHRyLnksIDMsIDMpO1xuICAgICAgICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobWwueCwgbWwueSwgMywgMyk7XG4gICAgICAgICBjYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChtci54LCBtci55LCAzLCAzKTtcbiAgICAgICAgIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KG10LngsIG10LnksIDMsIDMpO1xuICAgICAgICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobXRyLngsIG10ci55LCAzLCAzKTtcbiAgICAgICB9LCA1MCk7ICovXG5cbiAgICAgIHRoaXMub0Nvb3JkcyA9IHtcbiAgICAgICAgLy8gY29ybmVyc1xuICAgICAgICB0bDogdGwsIHRyOiB0ciwgYnI6IGJyLCBibDogYmwsXG4gICAgICAgIC8vIG1pZGRsZVxuICAgICAgICBtbDogbWwsIG10OiBtdCwgbXI6IG1yLCBtYjogbWIsXG4gICAgICAgIC8vIHJvdGF0aW5nIHBvaW50XG4gICAgICAgIG10cjogbXRyXG4gICAgICB9O1xuXG4gICAgICAvLyBzZXQgY29vcmRpbmF0ZXMgb2YgdGhlIGRyYWdnYWJsZSBib3hlcyBpbiB0aGUgY29ybmVycyB1c2VkIHRvIHNjYWxlL3JvdGF0ZSB0aGUgaW1hZ2VcbiAgICAgIHRoaXMuX3NldENvcm5lckNvb3JkcyAmJiB0aGlzLl9zZXRDb3JuZXJDb29yZHMoKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qXG4gICAgICogY2FsY3VsYXRlIHJvdGF0aW9uIG1hdHJpeCBvZiBhbiBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gcm90YXRpb24gbWF0cml4IGZvciB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgX2NhbGNSb3RhdGVNYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuYW5nbGUpIHtcbiAgICAgICAgdmFyIHRoZXRhID0gZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSwgY29zID0gTWF0aC5jb3ModGhldGEpLCBzaW4gPSBNYXRoLnNpbih0aGV0YSk7XG4gICAgICAgIHJldHVybiBbY29zLCBzaW4sIC1zaW4sIGNvcywgMCwgMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIGNhbGN1bGF0ZSB0cmFzZm9ybSBNYXRyaXggdGhhdCByZXByZXNlbnQgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBmcm9tXG4gICAgICogb2JqZWN0IHByb3BlcnRpZXMuXG4gICAgICogQHJldHVybiB7QXJyYXl9IG1hdHJpeCBUcmFuc2Zvcm0gTWF0cml4IGZvciB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgY2FsY1RyYW5zZm9ybU1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXJQb2ludCgpLFxuICAgICAgICAgIHRyYW5zbGF0ZU1hdHJpeCA9IFsxLCAwLCAwLCAxLCBjZW50ZXIueCwgY2VudGVyLnldLFxuICAgICAgICAgIHJvdGF0ZU1hdHJpeCA9IHRoaXMuX2NhbGNSb3RhdGVNYXRyaXgoKSxcbiAgICAgICAgICBkaW1lbnNpb25NYXRyaXggPSB0aGlzLl9jYWxjRGltZW5zaW9uc1RyYW5zZm9ybU1hdHJpeCh0aGlzLnNrZXdYLCB0aGlzLnNrZXdZLCB0cnVlKSxcbiAgICAgICAgICBtYXRyaXggPSB0aGlzLmdyb3VwID8gdGhpcy5ncm91cC5jYWxjVHJhbnNmb3JtTWF0cml4KCkgOiBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgICBtYXRyaXggPSBtdWx0aXBseU1hdHJpY2VzKG1hdHJpeCwgdHJhbnNsYXRlTWF0cml4KTtcbiAgICAgIG1hdHJpeCA9IG11bHRpcGx5TWF0cmljZXMobWF0cml4LCByb3RhdGVNYXRyaXgpO1xuICAgICAgbWF0cml4ID0gbXVsdGlwbHlNYXRyaWNlcyhtYXRyaXgsIGRpbWVuc2lvbk1hdHJpeCk7XG4gICAgICByZXR1cm4gbWF0cml4O1xuICAgIH0sXG5cbiAgICBfY2FsY0RpbWVuc2lvbnNUcmFuc2Zvcm1NYXRyaXg6IGZ1bmN0aW9uKHNrZXdYLCBza2V3WSwgZmxpcHBpbmcpIHtcbiAgICAgIHZhciBza2V3TWF0cml4WCA9IFsxLCAwLCBNYXRoLnRhbihkZWdyZWVzVG9SYWRpYW5zKHNrZXdYKSksIDFdLFxuICAgICAgICAgIHNrZXdNYXRyaXhZID0gWzEsIE1hdGgudGFuKGRlZ3JlZXNUb1JhZGlhbnMoc2tld1kpKSwgMCwgMV0sXG4gICAgICAgICAgc2NhbGVYID0gdGhpcy5zY2FsZVggKiAoZmxpcHBpbmcgJiYgdGhpcy5mbGlwWCA/IC0xIDogMSksXG4gICAgICAgICAgc2NhbGVZID0gdGhpcy5zY2FsZVkgKiAoZmxpcHBpbmcgJiYgdGhpcy5mbGlwWSA/IC0xIDogMSksXG4gICAgICAgICAgc2NhbGVNYXRyaXggPSBbc2NhbGVYLCAwLCAwLCBzY2FsZVldLFxuICAgICAgICAgIG0gPSBtdWx0aXBseU1hdHJpY2VzKHNjYWxlTWF0cml4LCBza2V3TWF0cml4WCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gbXVsdGlwbHlNYXRyaWNlcyhtLCBza2V3TWF0cml4WSwgdHJ1ZSk7XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIE1vdmVzIGFuIG9iamVjdCB0byB0aGUgYm90dG9tIG9mIHRoZSBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgc2VuZFRvQmFjazogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLnNlbmRUb0JhY2suY2FsbCh0aGlzLmdyb3VwLCB0aGlzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmNhbnZhcy5zZW5kVG9CYWNrKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgYW4gb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5icmluZ1RvRnJvbnQuY2FsbCh0aGlzLmdyb3VwLCB0aGlzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmNhbnZhcy5icmluZ1RvRnJvbnQodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBvYmplY3QgZG93biBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ludGVyc2VjdGluZ10gSWYgYHRydWVgLCBzZW5kIG9iamVjdCBiZWhpbmQgbmV4dCBsb3dlciBpbnRlcnNlY3Rpbmcgb2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgc2VuZEJhY2t3YXJkczogZnVuY3Rpb24oaW50ZXJzZWN0aW5nKSB7XG4gICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLnNlbmRCYWNrd2FyZHMuY2FsbCh0aGlzLmdyb3VwLCB0aGlzLCBpbnRlcnNlY3RpbmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuY2FudmFzLnNlbmRCYWNrd2FyZHModGhpcywgaW50ZXJzZWN0aW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGFuIG9iamVjdCB1cCBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ludGVyc2VjdGluZ10gSWYgYHRydWVgLCBzZW5kIG9iamVjdCBpbiBmcm9udCBvZiBuZXh0IHVwcGVyIGludGVyc2VjdGluZyBvYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBicmluZ0ZvcndhcmQ6IGZ1bmN0aW9uKGludGVyc2VjdGluZykge1xuICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5icmluZ0ZvcndhcmQuY2FsbCh0aGlzLmdyb3VwLCB0aGlzLCBpbnRlcnNlY3RpbmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuY2FudmFzLmJyaW5nRm9yd2FyZCh0aGlzLCBpbnRlcnNlY3RpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgYW4gb2JqZWN0IHRvIHNwZWNpZmllZCBsZXZlbCBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBOZXcgcG9zaXRpb24gb2Ygb2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgbW92ZVRvOiBmdW5jdGlvbihpbmRleCkge1xuICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5tb3ZlVG8uY2FsbCh0aGlzLmdyb3VwLCB0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jYW52YXMubW92ZVRvKHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG5cbi8qIF9UT19TVkdfU1RBUlRfICovXG4oZnVuY3Rpb24oKSB7XG5cbiAgZnVuY3Rpb24gZ2V0U3ZnQ29sb3JTdHJpbmcocHJvcCwgdmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gcHJvcCArICc6IG5vbmU7ICc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlLnRvTGl2ZSkge1xuICAgICAgcmV0dXJuIHByb3AgKyAnOiB1cmwoI1NWR0lEXycgKyB2YWx1ZS5pZCArICcpOyAnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBjb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IodmFsdWUpLFxuICAgICAgICAgIHN0ciA9IHByb3AgKyAnOiAnICsgY29sb3IudG9SZ2IoKSArICc7ICcsXG4gICAgICAgICAgb3BhY2l0eSA9IGNvbG9yLmdldEFscGhhKCk7XG4gICAgICBpZiAob3BhY2l0eSAhPT0gMSkge1xuICAgICAgICAvL2NoYW5nZSB0aGUgY29sb3IgaW4gcmdiICsgb3BhY2l0eVxuICAgICAgICBzdHIgKz0gcHJvcCArICctb3BhY2l0eTogJyArIG9wYWNpdHkudG9TdHJpbmcoKSArICc7ICc7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfVxuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3R5bGVzLXN0cmluZyBmb3Igc3ZnLWV4cG9ydFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcFNoYWRvdyBhIGJvb2xlYW4gdG8gc2tpcCBzaGFkb3cgZmlsdGVyIG91dHB1dFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdTdHlsZXM6IGZ1bmN0aW9uKHNraXBTaGFkb3cpIHtcblxuICAgICAgdmFyIGZpbGxSdWxlID0gdGhpcy5maWxsUnVsZSxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGggPyB0aGlzLnN0cm9rZVdpZHRoIDogJzAnLFxuICAgICAgICAgIHN0cm9rZURhc2hBcnJheSA9IHRoaXMuc3Ryb2tlRGFzaEFycmF5ID8gdGhpcy5zdHJva2VEYXNoQXJyYXkuam9pbignICcpIDogJ25vbmUnLFxuICAgICAgICAgIHN0cm9rZUxpbmVDYXAgPSB0aGlzLnN0cm9rZUxpbmVDYXAgPyB0aGlzLnN0cm9rZUxpbmVDYXAgOiAnYnV0dCcsXG4gICAgICAgICAgc3Ryb2tlTGluZUpvaW4gPSB0aGlzLnN0cm9rZUxpbmVKb2luID8gdGhpcy5zdHJva2VMaW5lSm9pbiA6ICdtaXRlcicsXG4gICAgICAgICAgc3Ryb2tlTWl0ZXJMaW1pdCA9IHRoaXMuc3Ryb2tlTWl0ZXJMaW1pdCA/IHRoaXMuc3Ryb2tlTWl0ZXJMaW1pdCA6ICc0JyxcbiAgICAgICAgICBvcGFjaXR5ID0gdHlwZW9mIHRoaXMub3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcgPyB0aGlzLm9wYWNpdHkgOiAnMScsXG4gICAgICAgICAgdmlzaWJpbGl0eSA9IHRoaXMudmlzaWJsZSA/ICcnIDogJyB2aXNpYmlsaXR5OiBoaWRkZW47JyxcbiAgICAgICAgICBmaWx0ZXIgPSBza2lwU2hhZG93ID8gJycgOiB0aGlzLmdldFN2Z0ZpbHRlcigpLFxuICAgICAgICAgIGZpbGwgPSBnZXRTdmdDb2xvclN0cmluZygnZmlsbCcsIHRoaXMuZmlsbCksXG4gICAgICAgICAgc3Ryb2tlID0gZ2V0U3ZnQ29sb3JTdHJpbmcoJ3N0cm9rZScsIHRoaXMuc3Ryb2tlKTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgc3Ryb2tlLFxuICAgICAgICAnc3Ryb2tlLXdpZHRoOiAnLCBzdHJva2VXaWR0aCwgJzsgJyxcbiAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXk6ICcsIHN0cm9rZURhc2hBcnJheSwgJzsgJyxcbiAgICAgICAgJ3N0cm9rZS1saW5lY2FwOiAnLCBzdHJva2VMaW5lQ2FwLCAnOyAnLFxuICAgICAgICAnc3Ryb2tlLWxpbmVqb2luOiAnLCBzdHJva2VMaW5lSm9pbiwgJzsgJyxcbiAgICAgICAgJ3N0cm9rZS1taXRlcmxpbWl0OiAnLCBzdHJva2VNaXRlckxpbWl0LCAnOyAnLFxuICAgICAgICBmaWxsLFxuICAgICAgICAnZmlsbC1ydWxlOiAnLCBmaWxsUnVsZSwgJzsgJyxcbiAgICAgICAgJ29wYWNpdHk6ICcsIG9wYWNpdHksICc7JyxcbiAgICAgICAgZmlsdGVyLFxuICAgICAgICB2aXNpYmlsaXR5XG4gICAgICBdLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGZpbHRlciBmb3Igc3ZnIHNoYWRvd1xuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdGaWx0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2hhZG93ID8gJ2ZpbHRlcjogdXJsKCNTVkdJRF8nICsgdGhpcy5zaGFkb3cuaWQgKyAnKTsnIDogJyc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWQgYXR0cmlidXRlIGZvciBzdmcgb3V0cHV0XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z0lkOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmlkID8gJ2lkPVwiJyArIHRoaXMuaWQgKyAnXCIgJyA6ICcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRyYW5zZm9ybS1zdHJpbmcgZm9yIHN2Zy1leHBvcnRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnVHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmdyb3VwICYmIHRoaXMuZ3JvdXAudHlwZSA9PT0gJ3BhdGgtZ3JvdXAnKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHZhciB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZCxcbiAgICAgICAgICBhbmdsZSA9IHRoaXMuZ2V0QW5nbGUoKSxcbiAgICAgICAgICBza2V3WCA9ICh0aGlzLmdldFNrZXdYKCkgJSAzNjApLFxuICAgICAgICAgIHNrZXdZID0gKHRoaXMuZ2V0U2tld1koKSAlIDM2MCksXG4gICAgICAgICAgY2VudGVyID0gdGhpcy5nZXRDZW50ZXJQb2ludCgpLFxuXG4gICAgICAgICAgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUyxcblxuICAgICAgICAgIHRyYW5zbGF0ZVBhcnQgPSB0aGlzLnR5cGUgPT09ICdwYXRoLWdyb3VwJyA/ICcnIDogJ3RyYW5zbGF0ZSgnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKGNlbnRlci54LCBOVU1fRlJBQ1RJT05fRElHSVRTKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKGNlbnRlci55LCBOVU1fRlJBQ1RJT05fRElHSVRTKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICcpJyxcblxuICAgICAgICAgIGFuZ2xlUGFydCA9IGFuZ2xlICE9PSAwXG4gICAgICAgICAgICA/ICgnIHJvdGF0ZSgnICsgdG9GaXhlZChhbmdsZSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnKScpXG4gICAgICAgICAgICA6ICcnLFxuXG4gICAgICAgICAgc2NhbGVQYXJ0ID0gKHRoaXMuc2NhbGVYID09PSAxICYmIHRoaXMuc2NhbGVZID09PSAxKVxuICAgICAgICAgICAgPyAnJyA6XG4gICAgICAgICAgICAoJyBzY2FsZSgnICtcbiAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLnNjYWxlWCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgK1xuICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc2NhbGVZLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArXG4gICAgICAgICAgICAnKScpLFxuXG4gICAgICAgICAgc2tld1hQYXJ0ID0gc2tld1ggIT09IDAgPyAnIHNrZXdYKCcgKyB0b0ZpeGVkKHNrZXdYLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICcpJyA6ICcnLFxuXG4gICAgICAgICAgc2tld1lQYXJ0ID0gc2tld1kgIT09IDAgPyAnIHNrZXdZKCcgKyB0b0ZpeGVkKHNrZXdZLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICcpJyA6ICcnLFxuXG4gICAgICAgICAgYWRkVHJhbnNsYXRlWCA9IHRoaXMudHlwZSA9PT0gJ3BhdGgtZ3JvdXAnID8gdGhpcy53aWR0aCA6IDAsXG5cbiAgICAgICAgICBmbGlwWFBhcnQgPSB0aGlzLmZsaXBYID8gJyBtYXRyaXgoLTEgMCAwIDEgJyArIGFkZFRyYW5zbGF0ZVggKyAnIDApICcgOiAnJyxcblxuICAgICAgICAgIGFkZFRyYW5zbGF0ZVkgPSB0aGlzLnR5cGUgPT09ICdwYXRoLWdyb3VwJyA/IHRoaXMuaGVpZ2h0IDogMCxcblxuICAgICAgICAgIGZsaXBZUGFydCA9IHRoaXMuZmxpcFkgPyAnIG1hdHJpeCgxIDAgMCAtMSAwICcgKyBhZGRUcmFuc2xhdGVZICsgJyknIDogJyc7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHRyYW5zbGF0ZVBhcnQsIGFuZ2xlUGFydCwgc2NhbGVQYXJ0LCBmbGlwWFBhcnQsIGZsaXBZUGFydCwgc2tld1hQYXJ0LCBza2V3WVBhcnRcbiAgICAgIF0uam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJhbnNmb3JtLXN0cmluZyBmb3Igc3ZnLWV4cG9ydCBmcm9tIHRoZSB0cmFuc2Zvcm0gbWF0cml4IG9mIHNpbmdsZSBlbGVtZW50c1xuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdUcmFuc2Zvcm1NYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtTWF0cml4ID8gJyBtYXRyaXgoJyArIHRoaXMudHJhbnNmb3JtTWF0cml4LmpvaW4oJyAnKSArICcpICcgOiAnJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQmFzZVNWR01hcmt1cDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWFya3VwID0gW107XG5cbiAgICAgIGlmICh0aGlzLmZpbGwgJiYgdGhpcy5maWxsLnRvTGl2ZSkge1xuICAgICAgICBtYXJrdXAucHVzaCh0aGlzLmZpbGwudG9TVkcodGhpcywgZmFsc2UpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0cm9rZSAmJiB0aGlzLnN0cm9rZS50b0xpdmUpIHtcbiAgICAgICAgbWFya3VwLnB1c2godGhpcy5zdHJva2UudG9TVkcodGhpcywgZmFsc2UpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNoYWRvdykge1xuICAgICAgICBtYXJrdXAucHVzaCh0aGlzLnNoYWRvdy50b1NWRyh0aGlzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFya3VwO1xuICAgIH1cbiAgfSk7XG59KSgpO1xuLyogX1RPX1NWR19FTkRfICovXG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kO1xuXG4gIC8qXG4gICAgRGVwZW5kcyBvbiBgc3RhdGVQcm9wZXJ0aWVzYFxuICAqL1xuICBmdW5jdGlvbiBzYXZlUHJvcHMob3JpZ2luLCBkZXN0aW5hdGlvbiwgcHJvcHMpIHtcbiAgICB2YXIgdG1wT2JqID0geyB9LCBkZWVwID0gdHJ1ZTtcbiAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgIHRtcE9ialtwcm9wXSA9IG9yaWdpbltwcm9wXTtcbiAgICB9KTtcbiAgICBleHRlbmQob3JpZ2luW2Rlc3RpbmF0aW9uXSwgdG1wT2JqLCBkZWVwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pc0VxdWFsKG9yaWdWYWx1ZSwgY3VycmVudFZhbHVlKSB7XG4gICAgaWYgKCFmYWJyaWMuaXNMaWtlbHlOb2RlICYmIG9yaWdWYWx1ZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgIC8vIGF2b2lkIGNoZWNraW5nIGRlZXAgaHRtbCBlbGVtZW50c1xuICAgICAgcmV0dXJuIG9yaWdWYWx1ZSA9PT0gY3VycmVudFZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcmlnVmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgaWYgKG9yaWdWYWx1ZS5sZW5ndGggIT09IGN1cnJlbnRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICB2YXIgX2N1cnJlbnRWYWx1ZSA9IGN1cnJlbnRWYWx1ZS5jb25jYXQoKS5zb3J0KCksXG4gICAgICAgICAgX29yaWdWYWx1ZSA9IG9yaWdWYWx1ZS5jb25jYXQoKS5zb3J0KCk7XG4gICAgICByZXR1cm4gIV9vcmlnVmFsdWUuc29tZShmdW5jdGlvbih2LCBpKSB7XG4gICAgICAgIHJldHVybiAhX2lzRXF1YWwoX2N1cnJlbnRWYWx1ZVtpXSwgdik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3JpZ1ZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb3JpZ1ZhbHVlKSB7XG4gICAgICAgIGlmICghX2lzRXF1YWwob3JpZ1ZhbHVlW2tleV0sIGN1cnJlbnRWYWx1ZVtrZXldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIG9yaWdWYWx1ZSA9PT0gY3VycmVudFZhbHVlO1xuICAgIH1cbiAgfVxuXG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IHN0YXRlIChvbmUgb2YgaXRzIHN0YXRlIHByb3BlcnRpZXMpIHdhcyBjaGFuZ2VkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBpbnN0YW5jZScgc3RhdGUgaGFzIGNoYW5nZWQgc2luY2UgYHtAbGluayBmYWJyaWMuT2JqZWN0I3NhdmVTdGF0ZX1gIHdhcyBjYWxsZWRcbiAgICAgKi9cbiAgICBoYXNTdGF0ZUNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICFfaXNFcXVhbCh0aGlzLm9yaWdpbmFsU3RhdGUsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTYXZlcyBzdGF0ZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9iamVjdCB3aXRoIGFkZGl0aW9uYWwgYHN0YXRlUHJvcGVydGllc2AgYXJyYXkgdG8gaW5jbHVkZSB3aGVuIHNhdmluZyBzdGF0ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBzYXZlU3RhdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHNhdmVQcm9wcyh0aGlzLCAnb3JpZ2luYWxTdGF0ZScsIHRoaXMuc3RhdGVQcm9wZXJ0aWVzKTtcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc3RhdGVQcm9wZXJ0aWVzKSB7XG4gICAgICAgIHNhdmVQcm9wcyh0aGlzLCAnb3JpZ2luYWxTdGF0ZScsIG9wdGlvbnMuc3RhdGVQcm9wZXJ0aWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXR1cHMgc3RhdGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPYmplY3Qgd2l0aCBhZGRpdGlvbmFsIGBzdGF0ZVByb3BlcnRpZXNgIGFycmF5IHRvIGluY2x1ZGUgd2hlbiBzYXZpbmcgc3RhdGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgc2V0dXBTdGF0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5vcmlnaW5hbFN0YXRlID0geyB9O1xuICAgICAgdGhpcy5zYXZlU3RhdGUob3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGRlZ3JlZXNUb1JhZGlhbnMgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zLFxuICAgICAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gICAgICBpc1ZNTCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHlwZW9mIEdfdm1sQ2FudmFzTWFuYWdlciAhPT0gJ3VuZGVmaW5lZCc7IH07XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvYmplY3QgaW50ZXJhY3Rpdml0eSBjb250cm9scy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jb250cm9sc1Zpc2liaWxpdHk6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoaWNoIGNvcm5lciBoYXMgYmVlbiBjbGlja2VkXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlciBUaGUgcG9pbnRlciBpbmRpY2F0aW5nIHRoZSBtb3VzZSBwb3NpdGlvblxuICAgICAqIEByZXR1cm4ge1N0cmluZ3xCb29sZWFufSBjb3JuZXIgY29kZSAodGwsIHRyLCBibCwgYnIsIGV0Yy4pLCBvciBmYWxzZSBpZiBub3RoaW5nIGlzIGZvdW5kXG4gICAgICovXG4gICAgX2ZpbmRUYXJnZXRDb3JuZXI6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICAgIGlmICghdGhpcy5oYXNDb250cm9scyB8fCAhdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXggPSBwb2ludGVyLngsXG4gICAgICAgICAgZXkgPSBwb2ludGVyLnksXG4gICAgICAgICAgeFBvaW50cyxcbiAgICAgICAgICBsaW5lcztcbiAgICAgIHRoaXMuX19jb3JuZXIgPSAwO1xuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLm9Db29yZHMpIHtcblxuICAgICAgICBpZiAoIXRoaXMuaXNDb250cm9sVmlzaWJsZShpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPT09ICdtdHInICYmICF0aGlzLmhhc1JvdGF0aW5nUG9pbnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdldCgnbG9ja1VuaVNjYWxpbmcnKSAmJlxuICAgICAgICAgICAoaSA9PT0gJ210JyB8fCBpID09PSAnbXInIHx8IGkgPT09ICdtYicgfHwgaSA9PT0gJ21sJykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmVzID0gdGhpcy5fZ2V0SW1hZ2VMaW5lcyh0aGlzLm9Db29yZHNbaV0uY29ybmVyKTtcblxuICAgICAgICAvLyBkZWJ1Z2dpbmdcblxuICAgICAgICAvLyBjYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5ib3R0b21saW5lLmQueCwgbGluZXMuYm90dG9tbGluZS5kLnksIDIsIDIpO1xuICAgICAgICAvLyBjYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5ib3R0b21saW5lLm8ueCwgbGluZXMuYm90dG9tbGluZS5vLnksIDIsIDIpO1xuXG4gICAgICAgIC8vIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLmxlZnRsaW5lLmQueCwgbGluZXMubGVmdGxpbmUuZC55LCAyLCAyKTtcbiAgICAgICAgLy8gY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMubGVmdGxpbmUuby54LCBsaW5lcy5sZWZ0bGluZS5vLnksIDIsIDIpO1xuXG4gICAgICAgIC8vIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnRvcGxpbmUuZC54LCBsaW5lcy50b3BsaW5lLmQueSwgMiwgMik7XG4gICAgICAgIC8vIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnRvcGxpbmUuby54LCBsaW5lcy50b3BsaW5lLm8ueSwgMiwgMik7XG5cbiAgICAgICAgLy8gY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMucmlnaHRsaW5lLmQueCwgbGluZXMucmlnaHRsaW5lLmQueSwgMiwgMik7XG4gICAgICAgIC8vIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnJpZ2h0bGluZS5vLngsIGxpbmVzLnJpZ2h0bGluZS5vLnksIDIsIDIpO1xuXG4gICAgICAgIHhQb2ludHMgPSB0aGlzLl9maW5kQ3Jvc3NQb2ludHMoeyB4OiBleCwgeTogZXkgfSwgbGluZXMpO1xuICAgICAgICBpZiAoeFBvaW50cyAhPT0gMCAmJiB4UG9pbnRzICUgMiA9PT0gMSkge1xuICAgICAgICAgIHRoaXMuX19jb3JuZXIgPSBpO1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBkcmFnZ2FibGUgYm94ZXMgaW4gdGhlIGNvcm5lcnMgb2ZcbiAgICAgKiB0aGUgaW1hZ2UgdXNlZCB0byBzY2FsZS9yb3RhdGUgaXQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0Q29ybmVyQ29vcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb29yZHMgPSB0aGlzLm9Db29yZHMsXG4gICAgICAgICAgbmV3VGhldGEgPSBkZWdyZWVzVG9SYWRpYW5zKDQ1IC0gdGhpcy5hbmdsZSksXG4gICAgICAgICAgLyogTWF0aC5zcXJ0KDIgKiBNYXRoLnBvdyh0aGlzLmNvcm5lclNpemUsIDIpKSAvIDIsICovXG4gICAgICAgICAgLyogMC43MDcxMDYgc3RhbmRzIGZvciBzcXJ0KDIpLzIgKi9cbiAgICAgICAgICBjb3JuZXJIeXBvdGVudXNlID0gdGhpcy5jb3JuZXJTaXplICogMC43MDcxMDYsXG4gICAgICAgICAgY29zSGFsZk9mZnNldCA9IGNvcm5lckh5cG90ZW51c2UgKiBNYXRoLmNvcyhuZXdUaGV0YSksXG4gICAgICAgICAgc2luSGFsZk9mZnNldCA9IGNvcm5lckh5cG90ZW51c2UgKiBNYXRoLnNpbihuZXdUaGV0YSksXG4gICAgICAgICAgeCwgeTtcblxuICAgICAgZm9yICh2YXIgcG9pbnQgaW4gY29vcmRzKSB7XG4gICAgICAgIHggPSBjb29yZHNbcG9pbnRdLng7XG4gICAgICAgIHkgPSBjb29yZHNbcG9pbnRdLnk7XG4gICAgICAgIGNvb3Jkc1twb2ludF0uY29ybmVyID0ge1xuICAgICAgICAgIHRsOiB7XG4gICAgICAgICAgICB4OiB4IC0gc2luSGFsZk9mZnNldCxcbiAgICAgICAgICAgIHk6IHkgLSBjb3NIYWxmT2Zmc2V0XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cjoge1xuICAgICAgICAgICAgeDogeCArIGNvc0hhbGZPZmZzZXQsXG4gICAgICAgICAgICB5OiB5IC0gc2luSGFsZk9mZnNldFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYmw6IHtcbiAgICAgICAgICAgIHg6IHggLSBjb3NIYWxmT2Zmc2V0LFxuICAgICAgICAgICAgeTogeSArIHNpbkhhbGZPZmZzZXRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJyOiB7XG4gICAgICAgICAgICB4OiB4ICsgc2luSGFsZk9mZnNldCxcbiAgICAgICAgICAgIHk6IHkgKyBjb3NIYWxmT2Zmc2V0XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIENhbGN1bGF0ZSBvYmplY3QgZGltZW5zaW9ucyBmcm9tIGl0cyBwcm9wZXJ0aWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdHJva2VXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgdyA9IHRoaXMud2lkdGgsXG4gICAgICAgICAgaCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgIGFkZFN0cm9rZVRvVyA9IHRydWUsXG4gICAgICAgICAgYWRkU3Ryb2tlVG9IID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2xpbmUnICYmIHRoaXMuc3Ryb2tlTGluZUNhcCA9PT0gJ2J1dHQnKSB7XG4gICAgICAgIGFkZFN0cm9rZVRvSCA9IHc7XG4gICAgICAgIGFkZFN0cm9rZVRvVyA9IGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRTdHJva2VUb0gpIHtcbiAgICAgICAgaCArPSBoIDwgMCA/IC1zdHJva2VXaWR0aCA6IHN0cm9rZVdpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkU3Ryb2tlVG9XKSB7XG4gICAgICAgIHcgKz0gdyA8IDAgPyAtc3Ryb2tlV2lkdGggOiBzdHJva2VXaWR0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgeDogdywgeTogaCB9O1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFRyYW5zZm9ybWVkRGltZW5zaW9uczogZnVuY3Rpb24oc2tld1gsIHNrZXdZKSB7XG4gICAgICBpZiAodHlwZW9mIHNrZXdYID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBza2V3WCA9IHRoaXMuc2tld1g7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHNrZXdZID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBza2V3WSA9IHRoaXMuc2tld1k7XG4gICAgICB9XG4gICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9ucygpLFxuICAgICAgICAgIGRpbVggPSBkaW1lbnNpb25zLnggLyAyLCBkaW1ZID0gZGltZW5zaW9ucy55IC8gMixcbiAgICAgICAgICBwb2ludHMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IC1kaW1YLFxuICAgICAgICAgICAgICB5OiAtZGltWVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgeDogZGltWCxcbiAgICAgICAgICAgICAgeTogLWRpbVlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IC1kaW1YLFxuICAgICAgICAgICAgICB5OiBkaW1ZXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiBkaW1YLFxuICAgICAgICAgICAgICB5OiBkaW1ZXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICBpLCB0cmFuc2Zvcm1NYXRyaXggPSB0aGlzLl9jYWxjRGltZW5zaW9uc1RyYW5zZm9ybU1hdHJpeChza2V3WCwgc2tld1ksIGZhbHNlKSxcbiAgICAgICAgICBiYm94O1xuICAgICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwb2ludHNbaV0gPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChwb2ludHNbaV0sIHRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICB9XG4gICAgICBiYm94ID0gZmFicmljLnV0aWwubWFrZUJvdW5kaW5nQm94RnJvbVBvaW50cyhwb2ludHMpO1xuICAgICAgcmV0dXJuIHsgeDogYmJveC53aWR0aCwgeTogYmJveC5oZWlnaHQgfTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZUN1cnJlbnREaW1lbnNpb25zOiBmdW5jdGlvbigpICB7XG4gICAgICB2YXIgdnB0ID0gdGhpcy5nZXRWaWV3cG9ydFRyYW5zZm9ybSgpLFxuICAgICAgICAgIGRpbSA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpLFxuICAgICAgICAgIHcgPSBkaW0ueCwgaCA9IGRpbS55LFxuICAgICAgICAgIHAgPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChuZXcgZmFicmljLlBvaW50KHcsIGgpLCB2cHQsIHRydWUpO1xuXG4gICAgICByZXR1cm4gcC5zY2FsYXJBZGQoMiAqIHRoaXMucGFkZGluZyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGEgY29sb3JlZCBsYXllciBiZWhpbmQgdGhlIG9iamVjdCwgaW5zaWRlIGl0cyBzZWxlY3Rpb24gYm9yZGVycy5cbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgb3B0aW9uczogcGFkZGluZywgc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yXG4gICAgICogdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiB0aGUgY29udGV4dCBpcyB0cmFuc2Zvcm1lZFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBkcmF3IG9uXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkcmF3U2VsZWN0aW9uQmFja2dyb3VuZDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yIHx8IHRoaXMuZ3JvdXAgfHwgIXRoaXMuYWN0aXZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCksIHdoID0gdGhpcy5fY2FsY3VsYXRlQ3VycmVudERpbWVuc2lvbnMoKSxcbiAgICAgICAgICB2cHQgPSB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybTtcbiAgICAgIGN0eC50cmFuc2xhdGUoY2VudGVyLngsIGNlbnRlci55KTtcbiAgICAgIGN0eC5zY2FsZSgxIC8gdnB0WzBdLCAxIC8gdnB0WzNdKTtcbiAgICAgIGN0eC5yb3RhdGUoZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5zZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBjdHguZmlsbFJlY3QoLXdoLnggLyAyLCAtd2gueSAvIDIsIHdoLngsIHdoLnkpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBib3JkZXJzIG9mIGFuIG9iamVjdCdzIGJvdW5kaW5nIGJveC5cbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgcHJvcGVydGllczogd2lkdGgsIGhlaWdodFxuICAgICAqIFJlcXVpcmVzIHB1YmxpYyBvcHRpb25zOiBwYWRkaW5nLCBib3JkZXJDb2xvclxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBkcmF3IG9uXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkcmF3Qm9yZGVyczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuaGFzQm9yZGVycykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIHdoID0gdGhpcy5fY2FsY3VsYXRlQ3VycmVudERpbWVuc2lvbnMoKSxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IDEgLyB0aGlzLmJvcmRlclNjYWxlRmFjdG9yLFxuICAgICAgICAgIHdpZHRoID0gd2gueCArIHN0cm9rZVdpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IHdoLnkgKyBzdHJva2VXaWR0aDtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYm9yZGVyQ29sb3I7XG4gICAgICB0aGlzLl9zZXRMaW5lRGFzaChjdHgsIHRoaXMuYm9yZGVyRGFzaEFycmF5LCBudWxsKTtcblxuICAgICAgY3R4LnN0cm9rZVJlY3QoXG4gICAgICAgIC13aWR0aCAvIDIsXG4gICAgICAgIC1oZWlnaHQgLyAyLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICApO1xuXG4gICAgICBpZiAodGhpcy5oYXNSb3RhdGluZ1BvaW50ICYmIHRoaXMuaXNDb250cm9sVmlzaWJsZSgnbXRyJykgJiYgIXRoaXMuZ2V0KCdsb2NrUm90YXRpb24nKSAmJiB0aGlzLmhhc0NvbnRyb2xzKSB7XG5cbiAgICAgICAgdmFyIHJvdGF0ZUhlaWdodCA9IC1oZWlnaHQgLyAyO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbygwLCByb3RhdGVIZWlnaHQpO1xuICAgICAgICBjdHgubGluZVRvKDAsIHJvdGF0ZUhlaWdodCAtIHRoaXMucm90YXRpbmdQb2ludE9mZnNldCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGJvcmRlcnMgb2YgYW4gb2JqZWN0J3MgYm91bmRpbmcgYm94IHdoZW4gaXQgaXMgaW5zaWRlIGEgZ3JvdXAuXG4gICAgICogUmVxdWlyZXMgcHVibGljIHByb3BlcnRpZXM6IHdpZHRoLCBoZWlnaHRcbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgb3B0aW9uczogcGFkZGluZywgYm9yZGVyQ29sb3JcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gZHJhdyBvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIG9iamVjdCByZXByZXNlbnRpbmcgY3VycmVudCBvYmplY3QgcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZHJhd0JvcmRlcnNJbkdyb3VwOiBmdW5jdGlvbihjdHgsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5oYXNCb3JkZXJzKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgcCA9IHRoaXMuX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9ucygpLFxuICAgICAgICAgIG1hdHJpeCA9IGZhYnJpYy51dGlsLmN1c3RvbVRyYW5zZm9ybU1hdHJpeChvcHRpb25zLnNjYWxlWCwgb3B0aW9ucy5zY2FsZVksIG9wdGlvbnMuc2tld1gpLFxuICAgICAgICAgIHdoID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQocCwgbWF0cml4KSxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IDEgLyB0aGlzLmJvcmRlclNjYWxlRmFjdG9yLFxuICAgICAgICAgIHdpZHRoID0gd2gueCArIHN0cm9rZVdpZHRoICsgMiAqIHRoaXMucGFkZGluZyxcbiAgICAgICAgICBoZWlnaHQgPSB3aC55ICsgc3Ryb2tlV2lkdGggKyAyICogdGhpcy5wYWRkaW5nO1xuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdGhpcy5fc2V0TGluZURhc2goY3R4LCB0aGlzLmJvcmRlckRhc2hBcnJheSwgbnVsbCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmJvcmRlckNvbG9yO1xuXG4gICAgICBjdHguc3Ryb2tlUmVjdChcbiAgICAgICAgLXdpZHRoIC8gMixcbiAgICAgICAgLWhlaWdodCAvIDIsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgICk7XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgY29ybmVycyBvZiBhbiBvYmplY3QncyBib3VuZGluZyBib3guXG4gICAgICogUmVxdWlyZXMgcHVibGljIHByb3BlcnRpZXM6IHdpZHRoLCBoZWlnaHRcbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgb3B0aW9uczogY29ybmVyU2l6ZSwgcGFkZGluZ1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBkcmF3IG9uXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkcmF3Q29udHJvbHM6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLmhhc0NvbnRyb2xzKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgd2ggPSB0aGlzLl9jYWxjdWxhdGVDdXJyZW50RGltZW5zaW9ucygpLFxuICAgICAgICAgIHdpZHRoID0gd2gueCxcbiAgICAgICAgICBoZWlnaHQgPSB3aC55LFxuICAgICAgICAgIHNjYWxlT2Zmc2V0ID0gdGhpcy5jb3JuZXJTaXplLFxuICAgICAgICAgIGxlZnQgPSAtKHdpZHRoICsgc2NhbGVPZmZzZXQpIC8gMixcbiAgICAgICAgICB0b3AgPSAtKGhlaWdodCArIHNjYWxlT2Zmc2V0KSAvIDIsXG4gICAgICAgICAgbWV0aG9kTmFtZSA9IHRoaXMudHJhbnNwYXJlbnRDb3JuZXJzID8gJ3N0cm9rZScgOiAnZmlsbCc7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlID0gdGhpcy5jb3JuZXJDb2xvcjtcbiAgICAgIGlmICghdGhpcy50cmFuc3BhcmVudENvcm5lcnMpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb3JuZXJTdHJva2VDb2xvcjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldExpbmVEYXNoKGN0eCwgdGhpcy5jb3JuZXJEYXNoQXJyYXksIG51bGwpO1xuXG4gICAgICAvLyB0b3AtbGVmdFxuICAgICAgdGhpcy5fZHJhd0NvbnRyb2woJ3RsJywgY3R4LCBtZXRob2ROYW1lLFxuICAgICAgICBsZWZ0LFxuICAgICAgICB0b3ApO1xuXG4gICAgICAvLyB0b3AtcmlnaHRcbiAgICAgIHRoaXMuX2RyYXdDb250cm9sKCd0cicsIGN0eCwgbWV0aG9kTmFtZSxcbiAgICAgICAgbGVmdCArIHdpZHRoLFxuICAgICAgICB0b3ApO1xuXG4gICAgICAvLyBib3R0b20tbGVmdFxuICAgICAgdGhpcy5fZHJhd0NvbnRyb2woJ2JsJywgY3R4LCBtZXRob2ROYW1lLFxuICAgICAgICBsZWZ0LFxuICAgICAgICB0b3AgKyBoZWlnaHQpO1xuXG4gICAgICAvLyBib3R0b20tcmlnaHRcbiAgICAgIHRoaXMuX2RyYXdDb250cm9sKCdicicsIGN0eCwgbWV0aG9kTmFtZSxcbiAgICAgICAgbGVmdCArIHdpZHRoLFxuICAgICAgICB0b3AgKyBoZWlnaHQpO1xuXG4gICAgICBpZiAoIXRoaXMuZ2V0KCdsb2NrVW5pU2NhbGluZycpKSB7XG5cbiAgICAgICAgLy8gbWlkZGxlLXRvcFxuICAgICAgICB0aGlzLl9kcmF3Q29udHJvbCgnbXQnLCBjdHgsIG1ldGhvZE5hbWUsXG4gICAgICAgICAgbGVmdCArIHdpZHRoIC8gMixcbiAgICAgICAgICB0b3ApO1xuXG4gICAgICAgIC8vIG1pZGRsZS1ib3R0b21cbiAgICAgICAgdGhpcy5fZHJhd0NvbnRyb2woJ21iJywgY3R4LCBtZXRob2ROYW1lLFxuICAgICAgICAgIGxlZnQgKyB3aWR0aCAvIDIsXG4gICAgICAgICAgdG9wICsgaGVpZ2h0KTtcblxuICAgICAgICAvLyBtaWRkbGUtcmlnaHRcbiAgICAgICAgdGhpcy5fZHJhd0NvbnRyb2woJ21yJywgY3R4LCBtZXRob2ROYW1lLFxuICAgICAgICAgIGxlZnQgKyB3aWR0aCxcbiAgICAgICAgICB0b3AgKyBoZWlnaHQgLyAyKTtcblxuICAgICAgICAvLyBtaWRkbGUtbGVmdFxuICAgICAgICB0aGlzLl9kcmF3Q29udHJvbCgnbWwnLCBjdHgsIG1ldGhvZE5hbWUsXG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICB0b3AgKyBoZWlnaHQgLyAyKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWlkZGxlLXRvcC1yb3RhdGVcbiAgICAgIGlmICh0aGlzLmhhc1JvdGF0aW5nUG9pbnQpIHtcbiAgICAgICAgdGhpcy5fZHJhd0NvbnRyb2woJ210cicsIGN0eCwgbWV0aG9kTmFtZSxcbiAgICAgICAgICBsZWZ0ICsgd2lkdGggLyAyLFxuICAgICAgICAgIHRvcCAtIHRoaXMucm90YXRpbmdQb2ludE9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kcmF3Q29udHJvbDogZnVuY3Rpb24oY29udHJvbCwgY3R4LCBtZXRob2ROYW1lLCBsZWZ0LCB0b3ApIHtcbiAgICAgIGlmICghdGhpcy5pc0NvbnRyb2xWaXNpYmxlKGNvbnRyb2wpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzaXplID0gdGhpcy5jb3JuZXJTaXplLCBzdHJva2UgPSAhdGhpcy50cmFuc3BhcmVudENvcm5lcnMgJiYgdGhpcy5jb3JuZXJTdHJva2VDb2xvcjtcbiAgICAgIHN3aXRjaCAodGhpcy5jb3JuZXJTdHlsZSkge1xuICAgICAgICBjYXNlICdjaXJjbGUnOlxuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHguYXJjKGxlZnQgKyBzaXplIC8gMiwgdG9wICsgc2l6ZSAvIDIsIHNpemUgLyAyLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICAgIGN0eFttZXRob2ROYW1lXSgpO1xuICAgICAgICAgIGlmIChzdHJva2UpIHtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaXNWTUwoKSB8fCB0aGlzLnRyYW5zcGFyZW50Q29ybmVycyB8fCBjdHguY2xlYXJSZWN0KGxlZnQsIHRvcCwgc2l6ZSwgc2l6ZSk7XG4gICAgICAgICAgY3R4W21ldGhvZE5hbWUgKyAnUmVjdCddKGxlZnQsIHRvcCwgc2l6ZSwgc2l6ZSk7XG4gICAgICAgICAgaWYgKHN0cm9rZSkge1xuICAgICAgICAgICAgY3R4LnN0cm9rZVJlY3QobGVmdCwgdG9wLCBzaXplLCBzaXplKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGNvbnRyb2wgaXMgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb250cm9sTmFtZSBUaGUgbmFtZSBvZiB0aGUgY29udHJvbC4gUG9zc2libGUgdmFsdWVzIGFyZSAndGwnLCAndHInLCAnYnInLCAnYmwnLCAnbWwnLCAnbXQnLCAnbXInLCAnbWInLCAnbXRyJy5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGNvbnRyb2wgaXMgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgaXNDb250cm9sVmlzaWJsZTogZnVuY3Rpb24oY29udHJvbE5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRDb250cm9sc1Zpc2liaWxpdHkoKVtjb250cm9sTmFtZV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHNwZWNpZmllZCBjb250cm9sLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb250cm9sTmFtZSBUaGUgbmFtZSBvZiB0aGUgY29udHJvbC4gUG9zc2libGUgdmFsdWVzIGFyZSAndGwnLCAndHInLCAnYnInLCAnYmwnLCAnbWwnLCAnbXQnLCAnbXInLCAnbWInLCAnbXRyJy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZpc2libGUgdHJ1ZSB0byBzZXQgdGhlIHNwZWNpZmllZCBjb250cm9sIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0Q29udHJvbFZpc2libGU6IGZ1bmN0aW9uKGNvbnRyb2xOYW1lLCB2aXNpYmxlKSB7XG4gICAgICB0aGlzLl9nZXRDb250cm9sc1Zpc2liaWxpdHkoKVtjb250cm9sTmFtZV0gPSB2aXNpYmxlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZpc2liaWxpdHkgc3RhdGUgb2Ygb2JqZWN0IGNvbnRyb2xzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJsXSB0cnVlIHRvIGVuYWJsZSB0aGUgYm90dG9tLWxlZnQgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYnJdIHRydWUgdG8gZW5hYmxlIHRoZSBib3R0b20tcmlnaHQgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWJdIHRydWUgdG8gZW5hYmxlIHRoZSBtaWRkbGUtYm90dG9tIGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1sXSB0cnVlIHRvIGVuYWJsZSB0aGUgbWlkZGxlLWxlZnQgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubXJdIHRydWUgdG8gZW5hYmxlIHRoZSBtaWRkbGUtcmlnaHQgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubXRdIHRydWUgdG8gZW5hYmxlIHRoZSBtaWRkbGUtdG9wIGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRsXSB0cnVlIHRvIGVuYWJsZSB0aGUgdG9wLWxlZnQgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJdIHRydWUgdG8gZW5hYmxlIHRoZSB0b3AtcmlnaHQgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubXRyXSB0cnVlIHRvIGVuYWJsZSB0aGUgbWlkZGxlLXRvcC1yb3RhdGUgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0Q29udHJvbHNWaXNpYmlsaXR5OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgZm9yICh2YXIgcCBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc2V0Q29udHJvbFZpc2libGUocCwgb3B0aW9uc1twXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgdGhlIGNvbnRyb2wgdmlzaWJpbGl0eSBzZXQgZm9yIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBfZ2V0Q29udHJvbHNWaXNpYmlsaXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5fY29udHJvbHNWaXNpYmlsaXR5KSB7XG4gICAgICAgIHRoaXMuX2NvbnRyb2xzVmlzaWJpbGl0eSA9IHtcbiAgICAgICAgICB0bDogdHJ1ZSxcbiAgICAgICAgICB0cjogdHJ1ZSxcbiAgICAgICAgICBicjogdHJ1ZSxcbiAgICAgICAgICBibDogdHJ1ZSxcbiAgICAgICAgICBtbDogdHJ1ZSxcbiAgICAgICAgICBtdDogdHJ1ZSxcbiAgICAgICAgICBtcjogdHJ1ZSxcbiAgICAgICAgICBtYjogdHJ1ZSxcbiAgICAgICAgICBtdHI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9jb250cm9sc1Zpc2liaWxpdHk7XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIEFuaW1hdGlvbiBkdXJhdGlvbiAoaW4gbXMpIGZvciBmeCogbWV0aG9kc1xuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIEZYX0RVUkFUSU9OOiA1MDAsXG5cbiAgLyoqXG4gICAqIENlbnRlcnMgb2JqZWN0IGhvcml6b250YWxseSB3aXRoIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlclxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NhbGxiYWNrc10gQ2FsbGJhY2tzIG9iamVjdCB3aXRoIG9wdGlvbmFsIFwib25Db21wbGV0ZVwiIGFuZC9vciBcIm9uQ2hhbmdlXCIgcHJvcGVydGllc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ29tcGxldGVdIEludm9rZWQgb24gY29tcGxldGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ2hhbmdlXSBJbnZva2VkIG9uIGV2ZXJ5IHN0ZXAgb2YgYW5pbWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZnhDZW50ZXJPYmplY3RIOiBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3MgfHwgeyB9O1xuXG4gICAgdmFyIGVtcHR5ID0gZnVuY3Rpb24oKSB7IH0sXG4gICAgICAgIG9uQ29tcGxldGUgPSBjYWxsYmFja3Mub25Db21wbGV0ZSB8fCBlbXB0eSxcbiAgICAgICAgb25DaGFuZ2UgPSBjYWxsYmFja3Mub25DaGFuZ2UgfHwgZW1wdHksXG4gICAgICAgIF90aGlzID0gdGhpcztcblxuICAgIGZhYnJpYy51dGlsLmFuaW1hdGUoe1xuICAgICAgc3RhcnRWYWx1ZTogb2JqZWN0LmdldCgnbGVmdCcpLFxuICAgICAgZW5kVmFsdWU6IHRoaXMuZ2V0Q2VudGVyKCkubGVmdCxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLkZYX0RVUkFUSU9OLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIG9iamVjdC5zZXQoJ2xlZnQnLCB2YWx1ZSk7XG4gICAgICAgIF90aGlzLnJlbmRlckFsbCgpO1xuICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBvYmplY3Quc2V0Q29vcmRzKCk7XG4gICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDZW50ZXJzIG9iamVjdCB2ZXJ0aWNhbGx5IHdpdGggYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY2FsbGJhY2tzXSBDYWxsYmFja3Mgb2JqZWN0IHdpdGggb3B0aW9uYWwgXCJvbkNvbXBsZXRlXCIgYW5kL29yIFwib25DaGFuZ2VcIiBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25Db21wbGV0ZV0gSW52b2tlZCBvbiBjb21wbGV0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25DaGFuZ2VdIEludm9rZWQgb24gZXZlcnkgc3RlcCBvZiBhbmltYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmeENlbnRlck9iamVjdFY6IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcyB8fCB7IH07XG5cbiAgICB2YXIgZW1wdHkgPSBmdW5jdGlvbigpIHsgfSxcbiAgICAgICAgb25Db21wbGV0ZSA9IGNhbGxiYWNrcy5vbkNvbXBsZXRlIHx8IGVtcHR5LFxuICAgICAgICBvbkNoYW5nZSA9IGNhbGxiYWNrcy5vbkNoYW5nZSB8fCBlbXB0eSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgZmFicmljLnV0aWwuYW5pbWF0ZSh7XG4gICAgICBzdGFydFZhbHVlOiBvYmplY3QuZ2V0KCd0b3AnKSxcbiAgICAgIGVuZFZhbHVlOiB0aGlzLmdldENlbnRlcigpLnRvcCxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLkZYX0RVUkFUSU9OLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIG9iamVjdC5zZXQoJ3RvcCcsIHZhbHVlKTtcbiAgICAgICAgX3RoaXMucmVuZGVyQWxsKCk7XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIG9iamVjdC5zZXRDb29yZHMoKTtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhbWUgYXMgYGZhYnJpYy5DYW52YXMjcmVtb3ZlYCBidXQgYW5pbWF0ZWRcbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHJlbW92ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NhbGxiYWNrc10gQ2FsbGJhY2tzIG9iamVjdCB3aXRoIG9wdGlvbmFsIFwib25Db21wbGV0ZVwiIGFuZC9vciBcIm9uQ2hhbmdlXCIgcHJvcGVydGllc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ29tcGxldGVdIEludm9rZWQgb24gY29tcGxldGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ2hhbmdlXSBJbnZva2VkIG9uIGV2ZXJ5IHN0ZXAgb2YgYW5pbWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZnhSZW1vdmU6IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcyB8fCB7IH07XG5cbiAgICB2YXIgZW1wdHkgPSBmdW5jdGlvbigpIHsgfSxcbiAgICAgICAgb25Db21wbGV0ZSA9IGNhbGxiYWNrcy5vbkNvbXBsZXRlIHx8IGVtcHR5LFxuICAgICAgICBvbkNoYW5nZSA9IGNhbGxiYWNrcy5vbkNoYW5nZSB8fCBlbXB0eSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgZmFicmljLnV0aWwuYW5pbWF0ZSh7XG4gICAgICBzdGFydFZhbHVlOiBvYmplY3QuZ2V0KCdvcGFjaXR5JyksXG4gICAgICBlbmRWYWx1ZTogMCxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLkZYX0RVUkFUSU9OLFxuICAgICAgb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIG9iamVjdC5zZXQoJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgIH0sXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgb2JqZWN0LnNldCgnb3BhY2l0eScsIHZhbHVlKTtcbiAgICAgICAgX3RoaXMucmVuZGVyQWxsKCk7XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5yZW1vdmUob2JqZWN0KTtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcbiAgLyoqXG4gICAqIEFuaW1hdGVzIG9iamVjdCdzIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBhbmltYXRlIChpZiBzdHJpbmcpIG9yIHByb3BlcnRpZXMgdG8gYW5pbWF0ZSAoaWYgb2JqZWN0KVxuICAgKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IHZhbHVlIFZhbHVlIHRvIGFuaW1hdGUgcHJvcGVydHkgdG8gKGlmIHN0cmluZyB3YXMgZ2l2ZW4gZmlyc3QpIG9yIG9wdGlvbnMgb2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTIjYW5pbWF0aW9ufVxuICAgKiBAY2hhaW5hYmxlXG4gICAqXG4gICAqIEFzIG9iamVjdCDigJQgbXVsdGlwbGUgcHJvcGVydGllc1xuICAgKlxuICAgKiBvYmplY3QuYW5pbWF0ZSh7IGxlZnQ6IC4uLiwgdG9wOiAuLi4gfSk7XG4gICAqIG9iamVjdC5hbmltYXRlKHsgbGVmdDogLi4uLCB0b3A6IC4uLiB9LCB7IGR1cmF0aW9uOiAuLi4gfSk7XG4gICAqXG4gICAqIEFzIHN0cmluZyDigJQgb25lIHByb3BlcnR5XG4gICAqXG4gICAqIG9iamVjdC5hbmltYXRlKCdsZWZ0JywgLi4uKTtcbiAgICogb2JqZWN0LmFuaW1hdGUoJ2xlZnQnLCB7IGR1cmF0aW9uOiAuLi4gfSk7XG4gICAqXG4gICAqL1xuICBhbmltYXRlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgcHJvcHNUb0FuaW1hdGUgPSBbXSwgcHJvcCwgc2tpcENhbGxiYWNrcztcbiAgICAgIGZvciAocHJvcCBpbiBhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgcHJvcHNUb0FuaW1hdGUucHVzaChwcm9wKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm9wc1RvQW5pbWF0ZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwcm9wID0gcHJvcHNUb0FuaW1hdGVbaV07XG4gICAgICAgIHNraXBDYWxsYmFja3MgPSBpICE9PSBsZW4gLSAxO1xuICAgICAgICB0aGlzLl9hbmltYXRlKHByb3AsIGFyZ3VtZW50c1swXVtwcm9wXSwgYXJndW1lbnRzWzFdLCBza2lwQ2FsbGJhY2tzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9hbmltYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdG8gYW5pbWF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdG8gVmFsdWUgdG8gYW5pbWF0ZSB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBDYWxsYmFja3NdIFdoZW4gdHJ1ZSwgY2FsbGJhY2tzIGxpa2Ugb25jaGFuZ2UgYW5kIG9uY29tcGxldGUgYXJlIG5vdCBpbnZva2VkXG4gICAqL1xuICBfYW5pbWF0ZTogZnVuY3Rpb24ocHJvcGVydHksIHRvLCBvcHRpb25zLCBza2lwQ2FsbGJhY2tzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcywgcHJvcFBhaXI7XG5cbiAgICB0byA9IHRvLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7IH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAofnByb3BlcnR5LmluZGV4T2YoJy4nKSkge1xuICAgICAgcHJvcFBhaXIgPSBwcm9wZXJ0eS5zcGxpdCgnLicpO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50VmFsdWUgPSBwcm9wUGFpclxuICAgICAgPyB0aGlzLmdldChwcm9wUGFpclswXSlbcHJvcFBhaXJbMV1dXG4gICAgICA6IHRoaXMuZ2V0KHByb3BlcnR5KTtcblxuICAgIGlmICghKCdmcm9tJyBpbiBvcHRpb25zKSkge1xuICAgICAgb3B0aW9ucy5mcm9tID0gY3VycmVudFZhbHVlO1xuICAgIH1cblxuICAgIGlmICh+dG8uaW5kZXhPZignPScpKSB7XG4gICAgICB0byA9IGN1cnJlbnRWYWx1ZSArIHBhcnNlRmxvYXQodG8ucmVwbGFjZSgnPScsICcnKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdG8gPSBwYXJzZUZsb2F0KHRvKTtcbiAgICB9XG5cbiAgICBmYWJyaWMudXRpbC5hbmltYXRlKHtcbiAgICAgIHN0YXJ0VmFsdWU6IG9wdGlvbnMuZnJvbSxcbiAgICAgIGVuZFZhbHVlOiB0byxcbiAgICAgIGJ5VmFsdWU6IG9wdGlvbnMuYnksXG4gICAgICBlYXNpbmc6IG9wdGlvbnMuZWFzaW5nLFxuICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG4gICAgICBhYm9ydDogb3B0aW9ucy5hYm9ydCAmJiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuYWJvcnQuY2FsbChfdGhpcyk7XG4gICAgICB9LFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9wUGFpcikge1xuICAgICAgICAgIF90aGlzW3Byb3BQYWlyWzBdXVtwcm9wUGFpclsxXV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5zZXQocHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tpcENhbGxiYWNrcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLm9uQ2hhbmdlICYmIG9wdGlvbnMub25DaGFuZ2UoKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHNraXBDYWxsYmFja3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgICAgb3B0aW9ucy5vbkNvbXBsZXRlICYmIG9wdGlvbnMub25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59KTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBjb29yZFByb3BzID0geyB4MTogMSwgeDI6IDEsIHkxOiAxLCB5MjogMSB9LFxuICAgICAgc3VwcG9ydHNMaW5lRGFzaCA9IGZhYnJpYy5TdGF0aWNDYW52YXMuc3VwcG9ydHMoJ3NldExpbmVEYXNoJyk7XG5cbiAgaWYgKGZhYnJpYy5MaW5lKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5MaW5lIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaW5lIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuTGluZVxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5MaW5lI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuTGluZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLkxpbmUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnbGluZScsXG5cbiAgICAvKipcbiAgICAgKiB4IHZhbHVlIG9yIGZpcnN0IGxpbmUgZWRnZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgeDE6IDAsXG5cbiAgICAvKipcbiAgICAgKiB5IHZhbHVlIG9yIGZpcnN0IGxpbmUgZWRnZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgeTE6IDAsXG5cbiAgICAvKipcbiAgICAgKiB4IHZhbHVlIG9yIHNlY29uZCBsaW5lIGVkZ2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHgyOiAwLFxuXG4gICAgLyoqXG4gICAgICogeSB2YWx1ZSBvciBzZWNvbmQgbGluZSBlZGdlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB5MjogMCxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BvaW50c10gQXJyYXkgb2YgcG9pbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5MaW5lfSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ocG9pbnRzLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG5cbiAgICAgIGlmICghcG9pbnRzKSB7XG4gICAgICAgIHBvaW50cyA9IFswLCAwLCAwLCAwXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcblxuICAgICAgdGhpcy5zZXQoJ3gxJywgcG9pbnRzWzBdKTtcbiAgICAgIHRoaXMuc2V0KCd5MScsIHBvaW50c1sxXSk7XG4gICAgICB0aGlzLnNldCgneDInLCBwb2ludHNbMl0pO1xuICAgICAgdGhpcy5zZXQoJ3kyJywgcG9pbnRzWzNdKTtcblxuICAgICAgdGhpcy5fc2V0V2lkdGhIZWlnaHQob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zXG4gICAgICovXG4gICAgX3NldFdpZHRoSGVpZ2h0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdGhpcy53aWR0aCA9IE1hdGguYWJzKHRoaXMueDIgLSB0aGlzLngxKTtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5hYnModGhpcy55MiAtIHRoaXMueTEpO1xuXG4gICAgICB0aGlzLmxlZnQgPSAnbGVmdCcgaW4gb3B0aW9uc1xuICAgICAgICA/IG9wdGlvbnMubGVmdFxuICAgICAgICA6IHRoaXMuX2dldExlZnRUb09yaWdpblgoKTtcblxuICAgICAgdGhpcy50b3AgPSAndG9wJyBpbiBvcHRpb25zXG4gICAgICAgID8gb3B0aW9ucy50b3BcbiAgICAgICAgOiB0aGlzLl9nZXRUb3BUb09yaWdpblkoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0Jywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAodHlwZW9mIGNvb3JkUHJvcHNba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5fc2V0V2lkdGhIZWlnaHQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gbGVmdFRvT3JpZ2luWCBEaXN0YW5jZSBmcm9tIGxlZnQgZWRnZSBvZiBjYW52YXMgdG8gb3JpZ2luWCBvZiBMaW5lLlxuICAgICAqL1xuICAgIF9nZXRMZWZ0VG9PcmlnaW5YOiBtYWtlRWRnZVRvT3JpZ2luR2V0dGVyKFxuICAgICAgeyAvLyBwcm9wZXJ0eSBuYW1lc1xuICAgICAgICBvcmlnaW46ICdvcmlnaW5YJyxcbiAgICAgICAgYXhpczE6ICd4MScsXG4gICAgICAgIGF4aXMyOiAneDInLFxuICAgICAgICBkaW1lbnNpb246ICd3aWR0aCdcbiAgICAgIH0sXG4gICAgICB7IC8vIHBvc3NpYmxlIHZhbHVlcyBvZiBvcmlnaW5cbiAgICAgICAgbmVhcmVzdDogJ2xlZnQnLFxuICAgICAgICBjZW50ZXI6ICdjZW50ZXInLFxuICAgICAgICBmYXJ0aGVzdDogJ3JpZ2h0J1xuICAgICAgfVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gdG9wVG9PcmlnaW5ZIERpc3RhbmNlIGZyb20gdG9wIGVkZ2Ugb2YgY2FudmFzIHRvIG9yaWdpblkgb2YgTGluZS5cbiAgICAgKi9cbiAgICBfZ2V0VG9wVG9PcmlnaW5ZOiBtYWtlRWRnZVRvT3JpZ2luR2V0dGVyKFxuICAgICAgeyAvLyBwcm9wZXJ0eSBuYW1lc1xuICAgICAgICBvcmlnaW46ICdvcmlnaW5ZJyxcbiAgICAgICAgYXhpczE6ICd5MScsXG4gICAgICAgIGF4aXMyOiAneTInLFxuICAgICAgICBkaW1lbnNpb246ICdoZWlnaHQnXG4gICAgICB9LFxuICAgICAgeyAvLyBwb3NzaWJsZSB2YWx1ZXMgb2Ygb3JpZ2luXG4gICAgICAgIG5lYXJlc3Q6ICd0b3AnLFxuICAgICAgICBjZW50ZXI6ICdjZW50ZXInLFxuICAgICAgICBmYXJ0aGVzdDogJ2JvdHRvbSdcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBub1RyYW5zZm9ybVxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCwgbm9UcmFuc2Zvcm0pIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgaWYgKG5vVHJhbnNmb3JtKSB7XG4gICAgICAgIC8vICBMaW5lIGNvb3JkcyBhcmUgZGlzdGFuY2VzIGZyb20gbGVmdC10b3Agb2YgY2FudmFzIHRvIG9yaWdpbiBvZiBsaW5lLlxuICAgICAgICAvLyAgVG8gcmVuZGVyIGxpbmUgaW4gYSBwYXRoLWdyb3VwLCB3ZSBuZWVkIHRvIHRyYW5zbGF0ZSB0aGVtIHRvXG4gICAgICAgIC8vICBkaXN0YW5jZXMgZnJvbSBjZW50ZXIgb2YgcGF0aC1ncm91cCB0byBjZW50ZXIgb2YgbGluZS5cbiAgICAgICAgdmFyIGNwID0gdGhpcy5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKFxuICAgICAgICAgIGNwLnggLSB0aGlzLnN0cm9rZVdpZHRoIC8gMixcbiAgICAgICAgICBjcC55IC0gdGhpcy5zdHJva2VXaWR0aCAvIDJcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnN0cm9rZURhc2hBcnJheSB8fCB0aGlzLnN0cm9rZURhc2hBcnJheSAmJiBzdXBwb3J0c0xpbmVEYXNoKSB7XG4gICAgICAgIC8vIG1vdmUgZnJvbSBjZW50ZXIgKG9mIHZpcnR1YWwgYm94KSB0byBpdHMgbGVmdC90b3AgY29ybmVyXG4gICAgICAgIC8vIHdlIGNhbid0IGFzc3VtZSB4MSwgeTEgaXMgdG9wIGxlZnQgYW5kIHgyLCB5MiBpcyBib3R0b20gcmlnaHRcbiAgICAgICAgdmFyIHAgPSB0aGlzLmNhbGNMaW5lUG9pbnRzKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8ocC54MSwgcC55MSk7XG4gICAgICAgIGN0eC5saW5lVG8ocC54MiwgcC55Mik7XG4gICAgICB9XG5cbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLnN0cm9rZVdpZHRoO1xuXG4gICAgICAvLyBUT0RPOiB0ZXN0IHRoaXNcbiAgICAgIC8vIG1ha2Ugc3VyZSBzZXR0aW5nIFwiZmlsbFwiIGNoYW5nZXMgY29sb3Igb2YgYSBsaW5lXG4gICAgICAvLyAoYnkgY29weWluZyBmaWxsU3R5bGUgdG8gc3Ryb2tlU3R5bGUsIHNpbmNlIGxpbmUgaXMgc3Ryb2tlZCwgbm90IGZpbGxlZClcbiAgICAgIHZhciBvcmlnU3Ryb2tlU3R5bGUgPSBjdHguc3Ryb2tlU3R5bGU7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnN0cm9rZSB8fCBjdHguZmlsbFN0eWxlO1xuICAgICAgdGhpcy5zdHJva2UgJiYgdGhpcy5fcmVuZGVyU3Ryb2tlKGN0eCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcmlnU3Ryb2tlU3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJEYXNoZWRTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHAgPSB0aGlzLmNhbGNMaW5lUG9pbnRzKCk7XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgcC54MSwgcC55MSwgcC54MiwgcC55MiwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBtZXRoZCB0b09iamVjdFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpLCB0aGlzLmNhbGNMaW5lUG9pbnRzKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZXMgbGluZSBwb2ludHMgZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2FsY0xpbmVQb2ludHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHhNdWx0ID0gdGhpcy54MSA8PSB0aGlzLngyID8gLTEgOiAxLFxuICAgICAgICAgIHlNdWx0ID0gdGhpcy55MSA8PSB0aGlzLnkyID8gLTEgOiAxLFxuICAgICAgICAgIHgxID0gKHhNdWx0ICogdGhpcy53aWR0aCAqIDAuNSksXG4gICAgICAgICAgeTEgPSAoeU11bHQgKiB0aGlzLmhlaWdodCAqIDAuNSksXG4gICAgICAgICAgeDIgPSAoeE11bHQgKiB0aGlzLndpZHRoICogLTAuNSksXG4gICAgICAgICAgeTIgPSAoeU11bHQgKiB0aGlzLmhlaWdodCAqIC0wLjUpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogeDEsXG4gICAgICAgIHgyOiB4MixcbiAgICAgICAgeTE6IHkxLFxuICAgICAgICB5MjogeTJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBTVkcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHZhciBtYXJrdXAgPSB0aGlzLl9jcmVhdGVCYXNlU1ZHTWFya3VwKCksXG4gICAgICAgICAgcCA9IHsgeDE6IHRoaXMueDEsIHgyOiB0aGlzLngyLCB5MTogdGhpcy55MSwgeTI6IHRoaXMueTIgfTtcblxuICAgICAgaWYgKCEodGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLnR5cGUgPT09ICdwYXRoLWdyb3VwJykpIHtcbiAgICAgICAgcCA9IHRoaXMuY2FsY0xpbmVQb2ludHMoKTtcbiAgICAgIH1cbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPGxpbmUgJywgdGhpcy5nZXRTdmdJZCgpLFxuICAgICAgICAgICd4MT1cIicsIHAueDEsXG4gICAgICAgICAgJ1wiIHkxPVwiJywgcC55MSxcbiAgICAgICAgICAnXCIgeDI9XCInLCBwLngyLFxuICAgICAgICAgICdcIiB5Mj1cIicsIHAueTIsXG4gICAgICAgICAgJ1wiIHN0eWxlPVwiJywgdGhpcy5nZXRTdmdTdHlsZXMoKSxcbiAgICAgICAgICAnXCIgdHJhbnNmb3JtPVwiJywgdGhpcy5nZXRTdmdUcmFuc2Zvcm0oKSxcbiAgICAgICAgICB0aGlzLmdldFN2Z1RyYW5zZm9ybU1hdHJpeCgpLFxuICAgICAgICAnXCIvPlxcbidcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiByZXZpdmVyID8gcmV2aXZlcihtYXJrdXAuam9pbignJykpIDogbWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbXBsZXhpdHkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHlcbiAgICAgKi9cbiAgICBjb21wbGV4aXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuTGluZS5mcm9tRWxlbWVudH0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5MaW5lXG4gICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI0xpbmVFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuTGluZS5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCd4MSB5MSB4MiB5Micuc3BsaXQoJyAnKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLkxpbmUgaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuTGluZVxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5MaW5lfSBpbnN0YW5jZSBvZiBmYWJyaWMuTGluZVxuICAgKi9cbiAgZmFicmljLkxpbmUuZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5MaW5lLkFUVFJJQlVURV9OQU1FUyksXG4gICAgICAgIHBvaW50cyA9IFtcbiAgICAgICAgICBwYXJzZWRBdHRyaWJ1dGVzLngxIHx8IDAsXG4gICAgICAgICAgcGFyc2VkQXR0cmlidXRlcy55MSB8fCAwLFxuICAgICAgICAgIHBhcnNlZEF0dHJpYnV0ZXMueDIgfHwgMCxcbiAgICAgICAgICBwYXJzZWRBdHRyaWJ1dGVzLnkyIHx8IDBcbiAgICAgICAgXTtcbiAgICByZXR1cm4gbmV3IGZhYnJpYy5MaW5lKHBvaW50cywgZXh0ZW5kKHBhcnNlZEF0dHJpYnV0ZXMsIG9wdGlvbnMpKTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuTGluZSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuTGluZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGludm9rZWQgd2l0aCBuZXcgaW5zdGFuY2UgYXMgZmlyc3QgYXJndW1lbnRcbiAgICogQHJldHVybiB7ZmFicmljLkxpbmV9IGluc3RhbmNlIG9mIGZhYnJpYy5MaW5lXG4gICAqL1xuICBmYWJyaWMuTGluZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHZhciBwb2ludHMgPSBbb2JqZWN0LngxLCBvYmplY3QueTEsIG9iamVjdC54Miwgb2JqZWN0LnkyXSxcbiAgICAgICAgbGluZSA9IG5ldyBmYWJyaWMuTGluZShwb2ludHMsIG9iamVjdCk7XG4gICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobGluZSk7XG4gICAgcmV0dXJuIGxpbmU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2R1Y2VzIGEgZnVuY3Rpb24gdGhhdCBjYWxjdWxhdGVzIGRpc3RhbmNlIGZyb20gY2FudmFzIGVkZ2UgdG8gTGluZSBvcmlnaW4uXG4gICAqL1xuICBmdW5jdGlvbiBtYWtlRWRnZVRvT3JpZ2luR2V0dGVyKHByb3BlcnR5TmFtZXMsIG9yaWdpblZhbHVlcykge1xuICAgIHZhciBvcmlnaW4gPSBwcm9wZXJ0eU5hbWVzLm9yaWdpbixcbiAgICAgICAgYXhpczEgPSBwcm9wZXJ0eU5hbWVzLmF4aXMxLFxuICAgICAgICBheGlzMiA9IHByb3BlcnR5TmFtZXMuYXhpczIsXG4gICAgICAgIGRpbWVuc2lvbiA9IHByb3BlcnR5TmFtZXMuZGltZW5zaW9uLFxuICAgICAgICBuZWFyZXN0ID0gb3JpZ2luVmFsdWVzLm5lYXJlc3QsXG4gICAgICAgIGNlbnRlciA9IG9yaWdpblZhbHVlcy5jZW50ZXIsXG4gICAgICAgIGZhcnRoZXN0ID0gb3JpZ2luVmFsdWVzLmZhcnRoZXN0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgc3dpdGNoICh0aGlzLmdldChvcmlnaW4pKSB7XG4gICAgICAgIGNhc2UgbmVhcmVzdDpcbiAgICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5nZXQoYXhpczEpLCB0aGlzLmdldChheGlzMikpO1xuICAgICAgICBjYXNlIGNlbnRlcjpcbiAgICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5nZXQoYXhpczEpLCB0aGlzLmdldChheGlzMikpICsgKDAuNSAqIHRoaXMuZ2V0KGRpbWVuc2lvbikpO1xuICAgICAgICBjYXNlIGZhcnRoZXN0OlxuICAgICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmdldChheGlzMSksIHRoaXMuZ2V0KGF4aXMyKSk7XG4gICAgICB9XG4gICAgfTtcblxuICB9XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIHBpID0gTWF0aC5QSSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQ7XG5cbiAgaWYgKGZhYnJpYy5DaXJjbGUpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkNpcmNsZSBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIENpcmNsZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkNpcmNsZVxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5DaXJjbGUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5DaXJjbGUgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5DaXJjbGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnY2lyY2xlJyxcblxuICAgIC8qKlxuICAgICAqIFJhZGl1cyBvZiB0aGlzIGNpcmNsZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcmFkaXVzOiAwLFxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgYW5nbGUgb2YgdGhlIGNpcmNsZSwgbW92aW5nIGNsb2Nrd2lzZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBzdGFydEFuZ2xlOiAwLFxuXG4gICAgLyoqXG4gICAgICogRW5kIGFuZ2xlIG9mIHRoZSBjaXJjbGVcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAyUGlcbiAgICAgKi9cbiAgICBlbmRBbmdsZTogcGkgKiAyLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkNpcmNsZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgfTtcblxuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuc2V0KCdyYWRpdXMnLCBvcHRpb25zLnJhZGl1cyB8fCAwKTtcblxuICAgICAgdGhpcy5zdGFydEFuZ2xlID0gb3B0aW9ucy5zdGFydEFuZ2xlIHx8IHRoaXMuc3RhcnRBbmdsZTtcbiAgICAgIHRoaXMuZW5kQW5nbGUgPSBvcHRpb25zLmVuZEFuZ2xlIHx8IHRoaXMuZW5kQW5nbGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2lyY2xlfSB0aGlzQXJnXG4gICAgICovXG4gICAgX3NldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19zZXQnLCBrZXksIHZhbHVlKTtcblxuICAgICAgaWYgKGtleSA9PT0gJ3JhZGl1cycpIHtcbiAgICAgICAgdGhpcy5zZXRSYWRpdXModmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSwge1xuICAgICAgICByYWRpdXM6IHRoaXMuZ2V0KCdyYWRpdXMnKSxcbiAgICAgICAgc3RhcnRBbmdsZTogdGhpcy5zdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZTogdGhpcy5lbmRBbmdsZVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHZhciBtYXJrdXAgPSB0aGlzLl9jcmVhdGVCYXNlU1ZHTWFya3VwKCksIHggPSAwLCB5ID0gMCxcbiAgICAgICAgICBhbmdsZSA9ICh0aGlzLmVuZEFuZ2xlIC0gdGhpcy5zdGFydEFuZ2xlKSAlICggMiAqIHBpKTtcblxuICAgICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICAgIGlmICh0aGlzLmdyb3VwICYmIHRoaXMuZ3JvdXAudHlwZSA9PT0gJ3BhdGgtZ3JvdXAnKSB7XG4gICAgICAgICAgeCA9IHRoaXMubGVmdCArIHRoaXMucmFkaXVzO1xuICAgICAgICAgIHkgPSB0aGlzLnRvcCArIHRoaXMucmFkaXVzO1xuICAgICAgICB9XG4gICAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAgICc8Y2lyY2xlICcsIHRoaXMuZ2V0U3ZnSWQoKSxcbiAgICAgICAgICAgICdjeD1cIicgKyB4ICsgJ1wiIGN5PVwiJyArIHkgKyAnXCIgJyxcbiAgICAgICAgICAgICdyPVwiJywgdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICAnXCIgc3R5bGU9XCInLCB0aGlzLmdldFN2Z1N0eWxlcygpLFxuICAgICAgICAgICAgJ1wiIHRyYW5zZm9ybT1cIicsIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtKCksXG4gICAgICAgICAgICAnICcsIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtTWF0cml4KCksXG4gICAgICAgICAgJ1wiLz5cXG4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIHN0YXJ0WCA9IE1hdGguY29zKHRoaXMuc3RhcnRBbmdsZSkgKiB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAgIHN0YXJ0WSA9IE1hdGguc2luKHRoaXMuc3RhcnRBbmdsZSkgKiB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAgIGVuZFggPSBNYXRoLmNvcyh0aGlzLmVuZEFuZ2xlKSAqIHRoaXMucmFkaXVzLFxuICAgICAgICAgICAgZW5kWSA9IE1hdGguc2luKHRoaXMuZW5kQW5nbGUpICogdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICBsYXJnZUZsYWcgPSBhbmdsZSA+IHBpID8gJzEnIDogJzAnO1xuXG4gICAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAgICc8cGF0aCBkPVwiTSAnICsgc3RhcnRYICsgJyAnICsgc3RhcnRZLFxuICAgICAgICAgICcgQSAnICsgdGhpcy5yYWRpdXMgKyAnICcgKyB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAnIDAgJywgK2xhcmdlRmxhZyArICcgMScsICcgJyArIGVuZFggKyAnICcgKyBlbmRZLFxuICAgICAgICAgICdcIiBzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKCksXG4gICAgICAgICAgJ1wiIHRyYW5zZm9ybT1cIicsIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtKCksXG4gICAgICAgICAgJyAnLCB0aGlzLmdldFN2Z1RyYW5zZm9ybU1hdHJpeCgpLFxuICAgICAgICAgICdcIi8+XFxuJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV2aXZlciA/IHJldml2ZXIobWFya3VwLmpvaW4oJycpKSA6IG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbbm9UcmFuc2Zvcm1dIFdoZW4gdHJ1ZSwgY29udGV4dCBpcyBub3QgdHJhbnNmb3JtZWRcbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgsIG5vVHJhbnNmb3JtKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKG5vVHJhbnNmb3JtID8gdGhpcy5sZWZ0ICsgdGhpcy5yYWRpdXMgOiAwLFxuICAgICAgICAgICAgICBub1RyYW5zZm9ybSA/IHRoaXMudG9wICsgdGhpcy5yYWRpdXMgOiAwLFxuICAgICAgICAgICAgICB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAgICAgdGhpcy5zdGFydEFuZ2xlLFxuICAgICAgICAgICAgICB0aGlzLmVuZEFuZ2xlLCBmYWxzZSk7XG4gICAgICB0aGlzLl9yZW5kZXJGaWxsKGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJTdHJva2UoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBob3Jpem9udGFsIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFjY29yZGluZyB0byBob3cgYW4gb2JqZWN0IGlzIHNjYWxlZClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0UmFkaXVzWDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoJ3JhZGl1cycpICogdGhpcy5nZXQoJ3NjYWxlWCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHZlcnRpY2FsIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFjY29yZGluZyB0byBob3cgYW4gb2JqZWN0IGlzIHNjYWxlZClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0UmFkaXVzWTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoJ3JhZGl1cycpICogdGhpcy5nZXQoJ3NjYWxlWScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFuZCB1cGRhdGVzIHdpZHRoIGFjY29yZGluZ2x5KVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DaXJjbGV9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBzZXRSYWRpdXM6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzLnJhZGl1cyA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KCd3aWR0aCcsIHZhbHVlICogMikuc2V0KCdoZWlnaHQnLCB2YWx1ZSAqIDIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbXBsZXhpdHkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHkgb2YgdGhpcyBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbXBsZXhpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkge0BsaW5rIGZhYnJpYy5DaXJjbGUuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ2lyY2xlXG4gICAqIEBzZWU6IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zaGFwZXMuaHRtbCNDaXJjbGVFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuQ2lyY2xlLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoJ2N4IGN5IHInLnNwbGl0KCcgJykpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuQ2lyY2xlfSBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5DaXJjbGVcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdmFsdWUgb2YgYHJgIGF0dHJpYnV0ZSBpcyBtaXNzaW5nIG9yIGludmFsaWRcbiAgICogQHJldHVybiB7ZmFicmljLkNpcmNsZX0gSW5zdGFuY2Ugb2YgZmFicmljLkNpcmNsZVxuICAgKi9cbiAgZmFicmljLkNpcmNsZS5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuQ2lyY2xlLkFUVFJJQlVURV9OQU1FUyk7XG5cbiAgICBpZiAoIWlzVmFsaWRSYWRpdXMocGFyc2VkQXR0cmlidXRlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgb2YgYHJgIGF0dHJpYnV0ZSBpcyByZXF1aXJlZCBhbmQgY2FuIG5vdCBiZSBuZWdhdGl2ZScpO1xuICAgIH1cblxuICAgIHBhcnNlZEF0dHJpYnV0ZXMubGVmdCA9IHBhcnNlZEF0dHJpYnV0ZXMubGVmdCB8fCAwO1xuICAgIHBhcnNlZEF0dHJpYnV0ZXMudG9wID0gcGFyc2VkQXR0cmlidXRlcy50b3AgfHwgMDtcblxuICAgIHZhciBvYmogPSBuZXcgZmFicmljLkNpcmNsZShleHRlbmQocGFyc2VkQXR0cmlidXRlcywgb3B0aW9ucykpO1xuXG4gICAgb2JqLmxlZnQgLT0gb2JqLnJhZGl1cztcbiAgICBvYmoudG9wIC09IG9iai5yYWRpdXM7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGlzVmFsaWRSYWRpdXMoYXR0cmlidXRlcykge1xuICAgIHJldHVybiAoKCdyYWRpdXMnIGluIGF0dHJpYnV0ZXMpICYmIChhdHRyaWJ1dGVzLnJhZGl1cyA+PSAwKSk7XG4gIH1cbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkNpcmNsZX0gaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkNpcmNsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGludm9rZWQgd2l0aCBuZXcgaW5zdGFuY2UgYXMgZmlyc3QgYXJndW1lbnRcbiAgICogQHJldHVybiB7T2JqZWN0fSBJbnN0YW5jZSBvZiBmYWJyaWMuQ2lyY2xlXG4gICAqL1xuICBmYWJyaWMuQ2lyY2xlLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGNpcmNsZSA9IG5ldyBmYWJyaWMuQ2lyY2xlKG9iamVjdCk7XG4gICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soY2lyY2xlKTtcbiAgICByZXR1cm4gY2lyY2xlO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSk7XG5cbiAgaWYgKGZhYnJpYy5UcmlhbmdsZSkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuVHJpYW5nbGUgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWFuZ2xlIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuVHJpYW5nbGVcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuVHJpYW5nbGV9IHRoaXNBcmdcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlRyaWFuZ2xlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuVHJpYW5nbGUgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5UcmlhbmdsZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICd0cmlhbmdsZScsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG5cbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuc2V0KCd3aWR0aCcsIG9wdGlvbnMud2lkdGggfHwgMTAwKVxuICAgICAgICAgIC5zZXQoJ2hlaWdodCcsIG9wdGlvbnMuaGVpZ2h0IHx8IDEwMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHdpZHRoQnkyID0gdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgaGVpZ2h0QnkyID0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKC13aWR0aEJ5MiwgaGVpZ2h0QnkyKTtcbiAgICAgIGN0eC5saW5lVG8oMCwgLWhlaWdodEJ5Mik7XG4gICAgICBjdHgubGluZVRvKHdpZHRoQnkyLCBoZWlnaHRCeTIpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICB0aGlzLl9yZW5kZXJGaWxsKGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJTdHJva2UoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckRhc2hlZFN0cm9rZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgd2lkdGhCeTIgPSB0aGlzLndpZHRoIC8gMixcbiAgICAgICAgICBoZWlnaHRCeTIgPSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgLXdpZHRoQnkyLCBoZWlnaHRCeTIsIDAsIC1oZWlnaHRCeTIsIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgMCwgLWhlaWdodEJ5Miwgd2lkdGhCeTIsIGhlaWdodEJ5MiwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCB3aWR0aEJ5MiwgaGVpZ2h0QnkyLCAtd2lkdGhCeTIsIGhlaWdodEJ5MiwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICB2YXIgbWFya3VwID0gdGhpcy5fY3JlYXRlQmFzZVNWR01hcmt1cCgpLFxuICAgICAgICAgIHdpZHRoQnkyID0gdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgaGVpZ2h0QnkyID0gdGhpcy5oZWlnaHQgLyAyLFxuICAgICAgICAgIHBvaW50cyA9IFtcbiAgICAgICAgICAgIC13aWR0aEJ5MiArICcgJyArIGhlaWdodEJ5MixcbiAgICAgICAgICAgICcwICcgKyAtaGVpZ2h0QnkyLFxuICAgICAgICAgICAgd2lkdGhCeTIgKyAnICcgKyBoZWlnaHRCeTJcbiAgICAgICAgICBdXG4gICAgICAgICAgLmpvaW4oJywnKTtcblxuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICc8cG9seWdvbiAnLCB0aGlzLmdldFN2Z0lkKCksXG4gICAgICAgICAgJ3BvaW50cz1cIicsIHBvaW50cyxcbiAgICAgICAgICAnXCIgc3R5bGU9XCInLCB0aGlzLmdldFN2Z1N0eWxlcygpLFxuICAgICAgICAgICdcIiB0cmFuc2Zvcm09XCInLCB0aGlzLmdldFN2Z1RyYW5zZm9ybSgpLFxuICAgICAgICAnXCIvPidcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiByZXZpdmVyID8gcmV2aXZlcihtYXJrdXAuam9pbignJykpIDogbWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbXBsZXhpdHkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHkgb2YgdGhpcyBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbXBsZXhpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuVHJpYW5nbGUgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlRyaWFuZ2xlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlRyaWFuZ2xlIGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICogQHJldHVybiB7T2JqZWN0fSBpbnN0YW5jZSBvZiBDYW52YXMuVHJpYW5nbGVcbiAgICovXG4gIGZhYnJpYy5UcmlhbmdsZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHZhciB0cmlhbmdsZSA9IG5ldyBmYWJyaWMuVHJpYW5nbGUob2JqZWN0KTtcbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjayh0cmlhbmdsZSk7XG4gICAgcmV0dXJuIHRyaWFuZ2xlO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBwaUJ5MiAgID0gTWF0aC5QSSAqIDIsXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kO1xuXG4gIGlmIChmYWJyaWMuRWxsaXBzZSkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuRWxsaXBzZSBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsbGlwc2UgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5FbGxpcHNlXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLkVsbGlwc2V9IHRoaXNBcmdcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkVsbGlwc2UjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5FbGxpcHNlID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuRWxsaXBzZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdlbGxpcHNlJyxcblxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWwgcmFkaXVzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByeDogICAwLFxuXG4gICAgLyoqXG4gICAgICogVmVydGljYWwgcmFkaXVzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByeTogICAwLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkVsbGlwc2V9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG5cbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuc2V0KCdyeCcsIG9wdGlvbnMucnggfHwgMCk7XG4gICAgICB0aGlzLnNldCgncnknLCBvcHRpb25zLnJ5IHx8IDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLkVsbGlwc2V9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBfc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3NldCcsIGtleSwgdmFsdWUpO1xuICAgICAgc3dpdGNoIChrZXkpIHtcblxuICAgICAgICBjYXNlICdyeCc6XG4gICAgICAgICAgdGhpcy5yeCA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuc2V0KCd3aWR0aCcsIHZhbHVlICogMik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncnknOlxuICAgICAgICAgIHRoaXMucnkgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnNldCgnaGVpZ2h0JywgdmFsdWUgKiAyKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaG9yaXpvbnRhbCByYWRpdXMgb2YgYW4gb2JqZWN0IChhY2NvcmRpbmcgdG8gaG93IGFuIG9iamVjdCBpcyBzY2FsZWQpXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJ4OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncngnKSAqIHRoaXMuZ2V0KCdzY2FsZVgnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBWZXJ0aWNhbCByYWRpdXMgb2YgYW4gb2JqZWN0IChhY2NvcmRpbmcgdG8gaG93IGFuIG9iamVjdCBpcyBzY2FsZWQpXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJ5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncnknKSAqIHRoaXMuZ2V0KCdzY2FsZVknKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSwge1xuICAgICAgICByeDogdGhpcy5nZXQoJ3J4JyksXG4gICAgICAgIHJ5OiB0aGlzLmdldCgncnknKVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHZhciBtYXJrdXAgPSB0aGlzLl9jcmVhdGVCYXNlU1ZHTWFya3VwKCksIHggPSAwLCB5ID0gMDtcbiAgICAgIGlmICh0aGlzLmdyb3VwICYmIHRoaXMuZ3JvdXAudHlwZSA9PT0gJ3BhdGgtZ3JvdXAnKSB7XG4gICAgICAgIHggPSB0aGlzLmxlZnQgKyB0aGlzLnJ4O1xuICAgICAgICB5ID0gdGhpcy50b3AgKyB0aGlzLnJ5O1xuICAgICAgfVxuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICc8ZWxsaXBzZSAnLCB0aGlzLmdldFN2Z0lkKCksXG4gICAgICAgICAgJ2N4PVwiJywgeCwgJ1wiIGN5PVwiJywgeSwgJ1wiICcsXG4gICAgICAgICAgJ3J4PVwiJywgdGhpcy5yeCxcbiAgICAgICAgICAnXCIgcnk9XCInLCB0aGlzLnJ5LFxuICAgICAgICAgICdcIiBzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKCksXG4gICAgICAgICAgJ1wiIHRyYW5zZm9ybT1cIicsIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtKCksXG4gICAgICAgICAgdGhpcy5nZXRTdmdUcmFuc2Zvcm1NYXRyaXgoKSxcbiAgICAgICAgJ1wiLz5cXG4nXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcmV2aXZlciA/IHJldml2ZXIobWFya3VwLmpvaW4oJycpKSA6IG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbbm9UcmFuc2Zvcm1dIFdoZW4gdHJ1ZSwgY29udGV4dCBpcyBub3QgdHJhbnNmb3JtZWRcbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgsIG5vVHJhbnNmb3JtKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSgxLCAwLCAwLCB0aGlzLnJ5IC8gdGhpcy5yeCwgMCwgMCk7XG4gICAgICBjdHguYXJjKFxuICAgICAgICBub1RyYW5zZm9ybSA/IHRoaXMubGVmdCArIHRoaXMucnggOiAwLFxuICAgICAgICBub1RyYW5zZm9ybSA/ICh0aGlzLnRvcCArIHRoaXMucnkpICogdGhpcy5yeCAvIHRoaXMucnkgOiAwLFxuICAgICAgICB0aGlzLnJ4LFxuICAgICAgICAwLFxuICAgICAgICBwaUJ5MixcbiAgICAgICAgZmFsc2UpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuX3JlbmRlckZpbGwoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclN0cm9rZShjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbXBsZXhpdHkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHlcbiAgICAgKi9cbiAgICBjb21wbGV4aXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuRWxsaXBzZS5mcm9tRWxlbWVudH0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5FbGxpcHNlXG4gICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI0VsbGlwc2VFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuRWxsaXBzZS5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCdjeCBjeSByeCByeScuc3BsaXQoJyAnKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5FbGxpcHNlfSBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5FbGxpcHNlXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLkVsbGlwc2V9XG4gICAqL1xuICBmYWJyaWMuRWxsaXBzZS5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuRWxsaXBzZS5BVFRSSUJVVEVfTkFNRVMpO1xuXG4gICAgcGFyc2VkQXR0cmlidXRlcy5sZWZ0ID0gcGFyc2VkQXR0cmlidXRlcy5sZWZ0IHx8IDA7XG4gICAgcGFyc2VkQXR0cmlidXRlcy50b3AgPSBwYXJzZWRBdHRyaWJ1dGVzLnRvcCB8fCAwO1xuXG4gICAgdmFyIGVsbGlwc2UgPSBuZXcgZmFicmljLkVsbGlwc2UoZXh0ZW5kKHBhcnNlZEF0dHJpYnV0ZXMsIG9wdGlvbnMpKTtcblxuICAgIGVsbGlwc2UudG9wIC09IGVsbGlwc2Uucnk7XG4gICAgZWxsaXBzZS5sZWZ0IC09IGVsbGlwc2Uucng7XG4gICAgcmV0dXJuIGVsbGlwc2U7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5FbGxpcHNlfSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuRWxsaXBzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGludm9rZWQgd2l0aCBuZXcgaW5zdGFuY2UgYXMgZmlyc3QgYXJndW1lbnRcbiAgICogQHJldHVybiB7ZmFicmljLkVsbGlwc2V9XG4gICAqL1xuICBmYWJyaWMuRWxsaXBzZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHZhciBlbGxpcHNlID0gbmV3IGZhYnJpYy5FbGxpcHNlKG9iamVjdCk7XG4gICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZWxsaXBzZSk7XG4gICAgcmV0dXJuIGVsbGlwc2U7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQ7XG5cbiAgaWYgKGZhYnJpYy5SZWN0KSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5SZWN0IGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzdGF0ZVByb3BlcnRpZXMgPSBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5zdGF0ZVByb3BlcnRpZXMuY29uY2F0KCk7XG4gIHN0YXRlUHJvcGVydGllcy5wdXNoKCdyeCcsICdyeScsICd4JywgJ3knKTtcblxuICAvKipcbiAgICogUmVjdGFuZ2xlIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUmVjdFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5SZWN0fSB0aGlzQXJnXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5SZWN0I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuUmVjdCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLlJlY3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciB3aGVuIGNoZWNraW5nIGlmIHN0YXRlIG9mIGFuIG9iamVjdCBpcyBjaGFuZ2VkICh7QGxpbmsgZmFicmljLk9iamVjdCNoYXNTdGF0ZUNoYW5nZWR9KVxuICAgICAqIGFzIHdlbGwgYXMgZm9yIGhpc3RvcnkgKHVuZG8vcmVkbykgcHVycG9zZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHN0YXRlUHJvcGVydGllczogc3RhdGVQcm9wZXJ0aWVzLFxuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdyZWN0JyxcblxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWwgYm9yZGVyIHJhZGl1c1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcng6ICAgMCxcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2FsIGJvcmRlciByYWRpdXNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJ5OiAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHNwZWNpZnkgZGFzaCBwYXR0ZXJuIGZvciBzdHJva2Ugb24gdGhpcyBvYmplY3RcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHN0cm9rZURhc2hBcnJheTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgfTtcblxuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX2luaXRSeFJ5KCk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgcngvcnkgYXR0cmlidXRlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRSeFJ5OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnJ4ICYmICF0aGlzLnJ5KSB7XG4gICAgICAgIHRoaXMucnkgPSB0aGlzLnJ4O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5yeSAmJiAhdGhpcy5yeCkge1xuICAgICAgICB0aGlzLnJ4ID0gdGhpcy5yeTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBub1RyYW5zZm9ybVxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCwgbm9UcmFuc2Zvcm0pIHtcblxuICAgICAgLy8gb3B0aW1pemUgMXgxIGNhc2UgKHVzZWQgaW4gc3ByYXkgYnJ1c2gpXG4gICAgICBpZiAodGhpcy53aWR0aCA9PT0gMSAmJiB0aGlzLmhlaWdodCA9PT0gMSkge1xuICAgICAgICBjdHguZmlsbFJlY3QoLTAuNSwgLTAuNSwgMSwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJ4ID0gdGhpcy5yeCA/IE1hdGgubWluKHRoaXMucngsIHRoaXMud2lkdGggLyAyKSA6IDAsXG4gICAgICAgICAgcnkgPSB0aGlzLnJ5ID8gTWF0aC5taW4odGhpcy5yeSwgdGhpcy5oZWlnaHQgLyAyKSA6IDAsXG4gICAgICAgICAgdyA9IHRoaXMud2lkdGgsXG4gICAgICAgICAgaCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgIHggPSBub1RyYW5zZm9ybSA/IHRoaXMubGVmdCA6IC10aGlzLndpZHRoIC8gMixcbiAgICAgICAgICB5ID0gbm9UcmFuc2Zvcm0gPyB0aGlzLnRvcCA6IC10aGlzLmhlaWdodCAvIDIsXG4gICAgICAgICAgaXNSb3VuZGVkID0gcnggIT09IDAgfHwgcnkgIT09IDAsXG4gICAgICAgICAgLyogXCJtYWdpYyBudW1iZXJcIiBmb3IgYmV6aWVyIGFwcHJveGltYXRpb25zIG9mIGFyY3MgKGh0dHA6Ly9pdGMua3R1Lmx0L2l0YzM1NC9SaXNrdXMzNTQucGRmKSAqL1xuICAgICAgICAgIGsgPSAxIC0gMC41NTIyODQ3NDk4O1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICBjdHgubW92ZVRvKHggKyByeCwgeSk7XG5cbiAgICAgIGN0eC5saW5lVG8oeCArIHcgLSByeCwgeSk7XG4gICAgICBpc1JvdW5kZWQgJiYgY3R4LmJlemllckN1cnZlVG8oeCArIHcgLSBrICogcngsIHksIHggKyB3LCB5ICsgayAqIHJ5LCB4ICsgdywgeSArIHJ5KTtcblxuICAgICAgY3R4LmxpbmVUbyh4ICsgdywgeSArIGggLSByeSk7XG4gICAgICBpc1JvdW5kZWQgJiYgY3R4LmJlemllckN1cnZlVG8oeCArIHcsIHkgKyBoIC0gayAqIHJ5LCB4ICsgdyAtIGsgKiByeCwgeSArIGgsIHggKyB3IC0gcngsIHkgKyBoKTtcblxuICAgICAgY3R4LmxpbmVUbyh4ICsgcngsIHkgKyBoKTtcbiAgICAgIGlzUm91bmRlZCAmJiBjdHguYmV6aWVyQ3VydmVUbyh4ICsgayAqIHJ4LCB5ICsgaCwgeCwgeSArIGggLSBrICogcnksIHgsIHkgKyBoIC0gcnkpO1xuXG4gICAgICBjdHgubGluZVRvKHgsIHkgKyByeSk7XG4gICAgICBpc1JvdW5kZWQgJiYgY3R4LmJlemllckN1cnZlVG8oeCwgeSArIGsgKiByeSwgeCArIGsgKiByeCwgeSwgeCArIHJ4LCB5KTtcblxuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICB0aGlzLl9yZW5kZXJGaWxsKGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJTdHJva2UoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckRhc2hlZFN0cm9rZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgeCA9IC10aGlzLndpZHRoIC8gMixcbiAgICAgICAgICB5ID0gLXRoaXMuaGVpZ2h0IC8gMixcbiAgICAgICAgICB3ID0gdGhpcy53aWR0aCxcbiAgICAgICAgICBoID0gdGhpcy5oZWlnaHQ7XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgeCwgeSwgeCArIHcsIHksIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgeCArIHcsIHksIHggKyB3LCB5ICsgaCwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCB4ICsgdywgeSArIGgsIHgsIHkgKyBoLCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHgsIHkgKyBoLCB4LCB5LCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBvYmplY3QgPSBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JywgcHJvcGVydGllc1RvSW5jbHVkZSksIHtcbiAgICAgICAgcng6IHRoaXMuZ2V0KCdyeCcpIHx8IDAsXG4gICAgICAgIHJ5OiB0aGlzLmdldCgncnknKSB8fCAwXG4gICAgICB9KTtcbiAgICAgIGlmICghdGhpcy5pbmNsdWRlRGVmYXVsdFZhbHVlcykge1xuICAgICAgICB0aGlzLl9yZW1vdmVEZWZhdWx0VmFsdWVzKG9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICB2YXIgbWFya3VwID0gdGhpcy5fY3JlYXRlQmFzZVNWR01hcmt1cCgpLCB4ID0gdGhpcy5sZWZ0LCB5ID0gdGhpcy50b3A7XG4gICAgICBpZiAoISh0aGlzLmdyb3VwICYmIHRoaXMuZ3JvdXAudHlwZSA9PT0gJ3BhdGgtZ3JvdXAnKSkge1xuICAgICAgICB4ID0gLXRoaXMud2lkdGggLyAyO1xuICAgICAgICB5ID0gLXRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIH1cbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPHJlY3QgJywgdGhpcy5nZXRTdmdJZCgpLFxuICAgICAgICAgICd4PVwiJywgeCwgJ1wiIHk9XCInLCB5LFxuICAgICAgICAgICdcIiByeD1cIicsIHRoaXMuZ2V0KCdyeCcpLCAnXCIgcnk9XCInLCB0aGlzLmdldCgncnknKSxcbiAgICAgICAgICAnXCIgd2lkdGg9XCInLCB0aGlzLndpZHRoLCAnXCIgaGVpZ2h0PVwiJywgdGhpcy5oZWlnaHQsXG4gICAgICAgICAgJ1wiIHN0eWxlPVwiJywgdGhpcy5nZXRTdmdTdHlsZXMoKSxcbiAgICAgICAgICAnXCIgdHJhbnNmb3JtPVwiJywgdGhpcy5nZXRTdmdUcmFuc2Zvcm0oKSxcbiAgICAgICAgICB0aGlzLmdldFN2Z1RyYW5zZm9ybU1hdHJpeCgpLFxuICAgICAgICAnXCIvPlxcbicpO1xuXG4gICAgICByZXR1cm4gcmV2aXZlciA/IHJldml2ZXIobWFya3VwLmpvaW4oJycpKSA6IG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb21wbGV4aXR5IG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBjb21wbGV4aXR5XG4gICAgICovXG4gICAgY29tcGxleGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSBgZmFicmljLlJlY3QuZnJvbUVsZW1lbnRgKVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUmVjdFxuICAgKiBAc2VlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc2hhcGVzLmh0bWwjUmVjdEVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5SZWN0LkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoJ3ggeSByeCByeSB3aWR0aCBoZWlnaHQnLnNwbGl0KCcgJykpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuUmVjdH0gaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUmVjdFxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5SZWN0fSBJbnN0YW5jZSBvZiBmYWJyaWMuUmVjdFxuICAgKi9cbiAgZmFicmljLlJlY3QuZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuXG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5SZWN0LkFUVFJJQlVURV9OQU1FUyk7XG5cbiAgICBwYXJzZWRBdHRyaWJ1dGVzLmxlZnQgPSBwYXJzZWRBdHRyaWJ1dGVzLmxlZnQgfHwgMDtcbiAgICBwYXJzZWRBdHRyaWJ1dGVzLnRvcCAgPSBwYXJzZWRBdHRyaWJ1dGVzLnRvcCAgfHwgMDtcbiAgICB2YXIgcmVjdCA9IG5ldyBmYWJyaWMuUmVjdChleHRlbmQoKG9wdGlvbnMgPyBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUob3B0aW9ucykgOiB7IH0pLCBwYXJzZWRBdHRyaWJ1dGVzKSk7XG4gICAgcmVjdC52aXNpYmxlID0gcmVjdC52aXNpYmxlICYmIHJlY3Qud2lkdGggPiAwICYmIHJlY3QuaGVpZ2h0ID4gMDtcbiAgICByZXR1cm4gcmVjdDtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLlJlY3R9IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5SZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlJlY3QgaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGluc3RhbmNlIG9mIGZhYnJpYy5SZWN0XG4gICAqL1xuICBmYWJyaWMuUmVjdC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHZhciByZWN0ID0gbmV3IGZhYnJpYy5SZWN0KG9iamVjdCk7XG4gICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVjdCk7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KTtcblxuICBpZiAoZmFicmljLlBvbHlsaW5lKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5Qb2x5bGluZSBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogUG9seWxpbmUgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5Qb2x5bGluZVxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5Qb2x5bGluZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlBvbHlsaW5lID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuUG9seWxpbmUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAncG9seWxpbmUnLFxuXG4gICAgLyoqXG4gICAgICogUG9pbnRzIGFycmF5XG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBvaW50czogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gWCBmcm9tIHBvaW50cyB2YWx1ZXMsIG5lY2Vzc2FyeSB0byBvZmZzZXQgcG9pbnRzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtaW5YOiAwLFxuXG4gICAgLyoqXG4gICAgICogTWluaW11bSBZIGZyb20gcG9pbnRzIHZhbHVlcywgbmVjZXNzYXJ5IHRvIG9mZnNldCBwb2ludHNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1pblk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyBBcnJheSBvZiBwb2ludHMgKHdoZXJlIGVhY2ggcG9pbnQgaXMgYW4gb2JqZWN0IHdpdGggeCBhbmQgeSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvbHlsaW5lfSB0aGlzQXJnXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcG9seSA9IG5ldyBmYWJyaWMuUG9seWxpbmUoW1xuICAgICAqICAgICB7IHg6IDEwLCB5OiAxMCB9LFxuICAgICAqICAgICB7IHg6IDUwLCB5OiAzMCB9LFxuICAgICAqICAgICB7IHg6IDQwLCB5OiA3MCB9LFxuICAgICAqICAgICB7IHg6IDYwLCB5OiA1MCB9LFxuICAgICAqICAgICB7IHg6IDEwMCwgeTogMTUwIH0sXG4gICAgICogICAgIHsgeDogNDAsIHk6IDEwMCB9XG4gICAgICogICBdLCB7XG4gICAgICogICBzdHJva2U6ICdyZWQnLFxuICAgICAqICAgbGVmdDogMTAwLFxuICAgICAqICAgdG9wOiAxMDBcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihwb2ludHMsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBmYWJyaWMuUG9seWdvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHBvaW50cywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGNEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWJyaWMuUG9seWdvbi5wcm90b3R5cGUuX2NhbGNEaW1lbnNpb25zLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiBmYWJyaWMuUG9seWdvbi5wcm90b3R5cGUudG9PYmplY3QuY2FsbCh0aGlzLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgcmV0dXJuIGZhYnJpYy5Qb2x5Z29uLnByb3RvdHlwZS50b1NWRy5jYWxsKHRoaXMsIHJldml2ZXIpO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG5vVHJhbnNmb3JtXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4LCBub1RyYW5zZm9ybSkge1xuICAgICAgaWYgKCFmYWJyaWMuUG9seWdvbi5wcm90b3R5cGUuY29tbW9uUmVuZGVyLmNhbGwodGhpcywgY3R4LCBub1RyYW5zZm9ybSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyRmlsbChjdHgpO1xuICAgICAgdGhpcy5fcmVuZGVyU3Ryb2tlKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJEYXNoZWRTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHAxLCBwMjtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHAxID0gdGhpcy5wb2ludHNbaV07XG4gICAgICAgIHAyID0gdGhpcy5wb2ludHNbaSArIDFdIHx8IHAxO1xuICAgICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHAxLngsIHAxLnksIHAyLngsIHAyLnksIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb21wbGV4aXR5IG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBjb21wbGV4aXR5IG9mIHRoaXMgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb21wbGV4aXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncG9pbnRzJykubGVuZ3RoO1xuICAgIH1cbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuUG9seWxpbmUuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWxpbmVcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI1BvbHlsaW5lRWxlbWVudFxuICAgKi9cbiAgZmFicmljLlBvbHlsaW5lLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoKTtcblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuUG9seWxpbmUgaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWxpbmVcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9seWxpbmV9IEluc3RhbmNlIG9mIGZhYnJpYy5Qb2x5bGluZVxuICAgKi9cbiAgZmFicmljLlBvbHlsaW5lLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgdmFyIHBvaW50cyA9IGZhYnJpYy5wYXJzZVBvaW50c0F0dHJpYnV0ZShlbGVtZW50LmdldEF0dHJpYnV0ZSgncG9pbnRzJykpLFxuICAgICAgICBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuUG9seWxpbmUuQVRUUklCVVRFX05BTUVTKTtcblxuICAgIHJldHVybiBuZXcgZmFicmljLlBvbHlsaW5lKHBvaW50cywgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChwYXJzZWRBdHRyaWJ1dGVzLCBvcHRpb25zKSk7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLlBvbHlsaW5lIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Qb2x5bGluZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGZhYnJpYy5QYXRoIGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICogQHJldHVybiB7ZmFicmljLlBvbHlsaW5lfSBJbnN0YW5jZSBvZiBmYWJyaWMuUG9seWxpbmVcbiAgICovXG4gIGZhYnJpYy5Qb2x5bGluZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHZhciBwb2x5bGluZSA9IG5ldyBmYWJyaWMuUG9seWxpbmUob2JqZWN0LnBvaW50cywgb2JqZWN0KTtcbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhwb2x5bGluZSk7XG4gICAgcmV0dXJuIHBvbHlsaW5lO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgbWluID0gZmFicmljLnV0aWwuYXJyYXkubWluLFxuICAgICAgbWF4ID0gZmFicmljLnV0aWwuYXJyYXkubWF4LFxuICAgICAgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQ7XG5cbiAgaWYgKGZhYnJpYy5Qb2x5Z29uKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5Qb2x5Z29uIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb2x5Z29uIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUG9seWdvblxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5Qb2x5Z29uI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuUG9seWdvbiA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLlBvbHlnb24ucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAncG9seWdvbicsXG5cbiAgICAvKipcbiAgICAgKiBQb2ludHMgYXJyYXlcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcG9pbnRzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogTWluaW11bSBYIGZyb20gcG9pbnRzIHZhbHVlcywgbmVjZXNzYXJ5IHRvIG9mZnNldCBwb2ludHNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1pblg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIFkgZnJvbSBwb2ludHMgdmFsdWVzLCBuZWNlc3NhcnkgdG8gb2Zmc2V0IHBvaW50c1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWluWTogMCxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIEFycmF5IG9mIHBvaW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9seWdvbn0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHBvaW50cywgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuICAgICAgdGhpcy5wb2ludHMgPSBwb2ludHMgfHwgW107XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5fY2FsY0RpbWVuc2lvbnMoKTtcbiAgICAgIGlmICghKCd0b3AnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgIHRoaXMudG9wID0gdGhpcy5taW5ZO1xuICAgICAgfVxuICAgICAgaWYgKCEoJ2xlZnQnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgIHRoaXMubGVmdCA9IHRoaXMubWluWDtcbiAgICAgIH1cbiAgICAgIHRoaXMucGF0aE9mZnNldCA9IHtcbiAgICAgICAgeDogdGhpcy5taW5YICsgdGhpcy53aWR0aCAvIDIsXG4gICAgICAgIHk6IHRoaXMubWluWSArIHRoaXMuaGVpZ2h0IC8gMlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY0RpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMsXG4gICAgICAgICAgbWluWCA9IG1pbihwb2ludHMsICd4JyksXG4gICAgICAgICAgbWluWSA9IG1pbihwb2ludHMsICd5JyksXG4gICAgICAgICAgbWF4WCA9IG1heChwb2ludHMsICd4JyksXG4gICAgICAgICAgbWF4WSA9IG1heChwb2ludHMsICd5Jyk7XG5cbiAgICAgIHRoaXMud2lkdGggPSAobWF4WCAtIG1pblgpIHx8IDA7XG4gICAgICB0aGlzLmhlaWdodCA9IChtYXhZIC0gbWluWSkgfHwgMDtcbiAgICAgIHRoaXMubWluWCA9IG1pblggfHwgMDtcbiAgICAgIHRoaXMubWluWSA9IG1pblkgfHwgMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSwge1xuICAgICAgICBwb2ludHM6IHRoaXMucG9pbnRzLmNvbmNhdCgpXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIHBvaW50cyA9IFtdLCBhZGRUcmFuc2Zvcm0sXG4gICAgICAgICAgbWFya3VwID0gdGhpcy5fY3JlYXRlQmFzZVNWR01hcmt1cCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcG9pbnRzLnB1c2godG9GaXhlZCh0aGlzLnBvaW50c1tpXS54LCAyKSwgJywnLCB0b0ZpeGVkKHRoaXMucG9pbnRzW2ldLnksIDIpLCAnICcpO1xuICAgICAgfVxuICAgICAgaWYgKCEodGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLnR5cGUgPT09ICdwYXRoLWdyb3VwJykpIHtcbiAgICAgICAgYWRkVHJhbnNmb3JtID0gJyB0cmFuc2xhdGUoJyArICgtdGhpcy5wYXRoT2Zmc2V0LngpICsgJywgJyArICgtdGhpcy5wYXRoT2Zmc2V0LnkpICsgJykgJztcbiAgICAgIH1cbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPCcsIHRoaXMudHlwZSwgJyAnLCB0aGlzLmdldFN2Z0lkKCksXG4gICAgICAgICAgJ3BvaW50cz1cIicsIHBvaW50cy5qb2luKCcnKSxcbiAgICAgICAgICAnXCIgc3R5bGU9XCInLCB0aGlzLmdldFN2Z1N0eWxlcygpLFxuICAgICAgICAgICdcIiB0cmFuc2Zvcm09XCInLCB0aGlzLmdldFN2Z1RyYW5zZm9ybSgpLCBhZGRUcmFuc2Zvcm0sXG4gICAgICAgICAgJyAnLCB0aGlzLmdldFN2Z1RyYW5zZm9ybU1hdHJpeCgpLFxuICAgICAgICAnXCIvPlxcbidcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiByZXZpdmVyID8gcmV2aXZlcihtYXJrdXAuam9pbignJykpIDogbWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG5vVHJhbnNmb3JtXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4LCBub1RyYW5zZm9ybSkge1xuICAgICAgaWYgKCF0aGlzLmNvbW1vblJlbmRlcihjdHgsIG5vVHJhbnNmb3JtKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9yZW5kZXJGaWxsKGN0eCk7XG4gICAgICBpZiAodGhpcy5zdHJva2UgfHwgdGhpcy5zdHJva2VEYXNoQXJyYXkpIHtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJTdHJva2UoY3R4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBub1RyYW5zZm9ybVxuICAgICAqL1xuICAgIGNvbW1vblJlbmRlcjogZnVuY3Rpb24oY3R4LCBub1RyYW5zZm9ybSkge1xuICAgICAgdmFyIHBvaW50LCBsZW4gPSB0aGlzLnBvaW50cy5sZW5ndGg7XG5cbiAgICAgIGlmICghbGVuIHx8IGlzTmFOKHRoaXMucG9pbnRzW2xlbiAtIDFdLnkpKSB7XG4gICAgICAgIC8vIGRvIG5vdCBkcmF3IGlmIG5vIHBvaW50cyBvciBvZGQgcG9pbnRzXG4gICAgICAgIC8vIE5hTiBjb21lcyBmcm9tIHBhcnNlRmxvYXQgb2YgYSBlbXB0eSBzdHJpbmcgaW4gcGFyc2VyXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgbm9UcmFuc2Zvcm0gfHwgY3R4LnRyYW5zbGF0ZSgtdGhpcy5wYXRoT2Zmc2V0LngsIC10aGlzLnBhdGhPZmZzZXQueSk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHRoaXMucG9pbnRzWzBdLngsIHRoaXMucG9pbnRzWzBdLnkpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwb2ludCA9IHRoaXMucG9pbnRzW2ldO1xuICAgICAgICBjdHgubGluZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJEYXNoZWRTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgZmFicmljLlBvbHlsaW5lLnByb3RvdHlwZS5fcmVuZGVyRGFzaGVkU3Ryb2tlLmNhbGwodGhpcywgY3R4KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb21wbGV4aXR5IG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBjb21wbGV4aXR5IG9mIHRoaXMgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb21wbGV4aXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBvaW50cy5sZW5ndGg7XG4gICAgfVxuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkgYGZhYnJpYy5Qb2x5Z29uLmZyb21FbGVtZW50YClcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlnb25cbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI1BvbHlnb25FbGVtZW50XG4gICAqL1xuICBmYWJyaWMuUG9seWdvbi5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5Qb2x5Z29ufSBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Qb2x5Z29uXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLlBvbHlnb259IEluc3RhbmNlIG9mIGZhYnJpYy5Qb2x5Z29uXG4gICAqL1xuICBmYWJyaWMuUG9seWdvbi5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgdmFyIHBvaW50cyA9IGZhYnJpYy5wYXJzZVBvaW50c0F0dHJpYnV0ZShlbGVtZW50LmdldEF0dHJpYnV0ZSgncG9pbnRzJykpLFxuICAgICAgICBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuUG9seWdvbi5BVFRSSUJVVEVfTkFNRVMpO1xuXG4gICAgcmV0dXJuIG5ldyBmYWJyaWMuUG9seWdvbihwb2ludHMsIGV4dGVuZChwYXJzZWRBdHRyaWJ1dGVzLCBvcHRpb25zKSk7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLlBvbHlnb24gaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlnb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBmYWJyaWMuUGF0aCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2x5Z29ufSBJbnN0YW5jZSBvZiBmYWJyaWMuUG9seWdvblxuICAgKi9cbiAgZmFicmljLlBvbHlnb24uZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgcG9seWdvbiA9IG5ldyBmYWJyaWMuUG9seWdvbihvYmplY3QucG9pbnRzLCBvYmplY3QpO1xuICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHBvbHlnb24pO1xuICAgIHJldHVybiBwb2x5Z29uO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBtaW4gPSBmYWJyaWMudXRpbC5hcnJheS5taW4sXG4gICAgICBtYXggPSBmYWJyaWMudXRpbC5hcnJheS5tYXgsXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcbiAgICAgIGRyYXdBcmMgPSBmYWJyaWMudXRpbC5kcmF3QXJjLFxuICAgICAgY29tbWFuZExlbmd0aHMgPSB7XG4gICAgICAgIG06IDIsXG4gICAgICAgIGw6IDIsXG4gICAgICAgIGg6IDEsXG4gICAgICAgIHY6IDEsXG4gICAgICAgIGM6IDYsXG4gICAgICAgIHM6IDQsXG4gICAgICAgIHE6IDQsXG4gICAgICAgIHQ6IDIsXG4gICAgICAgIGE6IDdcbiAgICAgIH0sXG4gICAgICByZXBlYXRlZENvbW1hbmRzID0ge1xuICAgICAgICBtOiAnbCcsXG4gICAgICAgIE06ICdMJ1xuICAgICAgfTtcblxuICBpZiAoZmFicmljLlBhdGgpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlBhdGggaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdGggY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5QYXRoXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTEjcGF0aF9hbmRfcGF0aGdyb3VwfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuUGF0aCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlBhdGggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5QYXRoLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3BhdGgnLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgcGF0aCBwb2ludHNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGF0aDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gWCBmcm9tIHBvaW50cyB2YWx1ZXMsIG5lY2Vzc2FyeSB0byBvZmZzZXQgcG9pbnRzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtaW5YOiAwLFxuXG4gICAgLyoqXG4gICAgICogTWluaW11bSBZIGZyb20gcG9pbnRzIHZhbHVlcywgbmVjZXNzYXJ5IHRvIG9mZnNldCBwb2ludHNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1pblk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBwYXRoIFBhdGggZGF0YSAoc2VxdWVuY2Ugb2YgY29vcmRpbmF0ZXMgYW5kIGNvcnJlc3BvbmRpbmcgXCJjb21tYW5kXCIgdG9rZW5zKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUGF0aH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgfTtcblxuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgcGF0aCA9IFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgZnJvbUFycmF5ID0gX3RvU3RyaW5nLmNhbGwocGF0aCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG5cbiAgICAgIHRoaXMucGF0aCA9IGZyb21BcnJheVxuICAgICAgICA/IHBhdGhcbiAgICAgICAgLy8gb25lIG9mIGNvbW1hbmRzIChtLE0sbCxMLHEsUSxjLEMsZXRjLikgZm9sbG93ZWQgYnkgbm9uLWNvbW1hbmQgY2hhcmFjdGVycyAoaS5lLiBjb21tYW5kIHZhbHVlcylcbiAgICAgICAgOiBwYXRoLm1hdGNoICYmIHBhdGgubWF0Y2goL1ttemxodmNzcXRhXVtebXpsaHZjc3F0YV0qL2dpKTtcblxuICAgICAgaWYgKCF0aGlzLnBhdGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZyb21BcnJheSkge1xuICAgICAgICB0aGlzLnBhdGggPSB0aGlzLl9wYXJzZVBhdGgoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2V0UG9zaXRpb25EaW1lbnNpb25zKG9wdGlvbnMpO1xuXG4gICAgICBpZiAob3B0aW9ucy5zb3VyY2VQYXRoKSB7XG4gICAgICAgIHRoaXMuc2V0U291cmNlUGF0aChvcHRpb25zLnNvdXJjZVBhdGgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgX3NldFBvc2l0aW9uRGltZW5zaW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNhbGNEaW0gPSB0aGlzLl9wYXJzZURpbWVuc2lvbnMoKTtcblxuICAgICAgdGhpcy5taW5YID0gY2FsY0RpbS5sZWZ0O1xuICAgICAgdGhpcy5taW5ZID0gY2FsY0RpbS50b3A7XG4gICAgICB0aGlzLndpZHRoID0gY2FsY0RpbS53aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gY2FsY0RpbS5oZWlnaHQ7XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sZWZ0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmxlZnQgPSBjYWxjRGltLmxlZnQgKyAodGhpcy5vcmlnaW5YID09PSAnY2VudGVyJ1xuICAgICAgICAgID8gdGhpcy53aWR0aCAvIDJcbiAgICAgICAgICA6IHRoaXMub3JpZ2luWCA9PT0gJ3JpZ2h0J1xuICAgICAgICAgICAgPyB0aGlzLndpZHRoXG4gICAgICAgICAgICA6IDApO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9wID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnRvcCA9IGNhbGNEaW0udG9wICsgKHRoaXMub3JpZ2luWSA9PT0gJ2NlbnRlcidcbiAgICAgICAgICA/IHRoaXMuaGVpZ2h0IC8gMlxuICAgICAgICAgIDogdGhpcy5vcmlnaW5ZID09PSAnYm90dG9tJ1xuICAgICAgICAgICAgPyB0aGlzLmhlaWdodFxuICAgICAgICAgICAgOiAwKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYXRoT2Zmc2V0ID0gdGhpcy5wYXRoT2Zmc2V0IHx8IHtcbiAgICAgICAgeDogdGhpcy5taW5YICsgdGhpcy53aWR0aCAvIDIsXG4gICAgICAgIHk6IHRoaXMubWluWSArIHRoaXMuaGVpZ2h0IC8gMlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIHBhdGggb25cbiAgICAgKi9cbiAgICBfcmVuZGVyUGF0aENvbW1hbmRzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBjdXJyZW50LCAvLyBjdXJyZW50IGluc3RydWN0aW9uXG4gICAgICAgICAgcHJldmlvdXMgPSBudWxsLFxuICAgICAgICAgIHN1YnBhdGhTdGFydFggPSAwLFxuICAgICAgICAgIHN1YnBhdGhTdGFydFkgPSAwLFxuICAgICAgICAgIHggPSAwLCAvLyBjdXJyZW50IHhcbiAgICAgICAgICB5ID0gMCwgLy8gY3VycmVudCB5XG4gICAgICAgICAgY29udHJvbFggPSAwLCAvLyBjdXJyZW50IGNvbnRyb2wgcG9pbnQgeFxuICAgICAgICAgIGNvbnRyb2xZID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHlcbiAgICAgICAgICB0ZW1wWCxcbiAgICAgICAgICB0ZW1wWSxcbiAgICAgICAgICBsID0gLXRoaXMucGF0aE9mZnNldC54LFxuICAgICAgICAgIHQgPSAtdGhpcy5wYXRoT2Zmc2V0Lnk7XG5cbiAgICAgIGlmICh0aGlzLmdyb3VwICYmIHRoaXMuZ3JvdXAudHlwZSA9PT0gJ3BhdGgtZ3JvdXAnKSB7XG4gICAgICAgIGwgPSAwO1xuICAgICAgICB0ID0gMDtcbiAgICAgIH1cblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5wYXRoLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cbiAgICAgICAgY3VycmVudCA9IHRoaXMucGF0aFtpXTtcblxuICAgICAgICBzd2l0Y2ggKGN1cnJlbnRbMF0pIHsgLy8gZmlyc3QgbGV0dGVyXG5cbiAgICAgICAgICBjYXNlICdsJzogLy8gbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgeSArPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdMJzogLy8gbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaCc6IC8vIGhvcml6b250YWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdIJzogLy8gaG9yaXpvbnRhbCBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndic6IC8vIHZlcnRpY2FsIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgICAgIHkgKz0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnVic6IC8vIHZlcmljYWwgbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgeSA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ20nOiAvLyBtb3ZlVG8sIHJlbGF0aXZlXG4gICAgICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICB5ICs9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBzdWJwYXRoU3RhcnRYID0geDtcbiAgICAgICAgICAgIHN1YnBhdGhTdGFydFkgPSB5O1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdNJzogLy8gbW92ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgICAgIHN1YnBhdGhTdGFydFggPSB4O1xuICAgICAgICAgICAgc3VicGF0aFN0YXJ0WSA9IHk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2MnOiAvLyBiZXppZXJDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFs1XTtcbiAgICAgICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNl07XG4gICAgICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzNdO1xuICAgICAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFs0XTtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICB4ICsgY3VycmVudFsxXSArIGwsIC8vIHgxXG4gICAgICAgICAgICAgIHkgKyBjdXJyZW50WzJdICsgdCwgLy8geTFcbiAgICAgICAgICAgICAgY29udHJvbFggKyBsLCAvLyB4MlxuICAgICAgICAgICAgICBjb250cm9sWSArIHQsIC8vIHkyXG4gICAgICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdDJzogLy8gYmV6aWVyQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzVdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbNl07XG4gICAgICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgY3VycmVudFsxXSArIGwsXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0gKyB0LFxuICAgICAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgICAgIGNvbnRyb2xZICsgdCxcbiAgICAgICAgICAgICAgeCArIGwsXG4gICAgICAgICAgICAgIHkgKyB0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdzJzogLy8gc2hvcnRoYW5kIGN1YmljIGJlemllckN1cnZlVG8sIHJlbGF0aXZlXG5cbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzRdO1xuXG4gICAgICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tDY1NzXS8pID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIEMsIGMsIFMsIG9yIHMsXG4gICAgICAgICAgICAgIC8vIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgICAgICB4ICsgY3VycmVudFsxXSArIGwsXG4gICAgICAgICAgICAgIHkgKyBjdXJyZW50WzJdICsgdCxcbiAgICAgICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvLyBzZXQgY29udHJvbCBwb2ludCB0byAybmQgb25lIG9mIHRoaXMgY29tbWFuZFxuICAgICAgICAgICAgLy8gXCIuLi4gdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgaXMgYXNzdW1lZCB0byBiZVxuICAgICAgICAgICAgLy8gdGhlIHJlZmxlY3Rpb24gb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50IG9uXG4gICAgICAgICAgICAvLyB0aGUgcHJldmlvdXMgY29tbWFuZCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb2ludC5cIlxuICAgICAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG5cbiAgICAgICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnUyc6IC8vIHNob3J0aGFuZCBjdWJpYyBiZXppZXJDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgdGVtcFggPSBjdXJyZW50WzNdO1xuICAgICAgICAgICAgdGVtcFkgPSBjdXJyZW50WzRdO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzWzBdLm1hdGNoKC9bQ2NTc10vKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBwcmV2aW91cyBjb21tYW5kIG9yIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIHdhcyBub3QgYSBDLCBjLCBTLCBvciBzLFxuICAgICAgICAgICAgICAvLyB0aGUgY29udHJvbCBwb2ludCBpcyBjb2luY2lkZW50IHdpdGggdGhlIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgICAgICAgY29udHJvbFggPSB4O1xuICAgICAgICAgICAgICBjb250cm9sWSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHNcbiAgICAgICAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0gKyBsLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdICsgdCxcbiAgICAgICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgICAgICB5ID0gdGVtcFk7XG5cbiAgICAgICAgICAgIC8vIHNldCBjb250cm9sIHBvaW50IHRvIDJuZCBvbmUgb2YgdGhpcyBjb21tYW5kXG4gICAgICAgICAgICAvLyBcIi4uLiB0aGUgZmlyc3QgY29udHJvbCBwb2ludCBpcyBhc3N1bWVkIHRvIGJlXG4gICAgICAgICAgICAvLyB0aGUgcmVmbGVjdGlvbiBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgb25cbiAgICAgICAgICAgIC8vIHRoZSBwcmV2aW91cyBjb21tYW5kIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvaW50LlwiXG4gICAgICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbMl07XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncSc6IC8vIHF1YWRyYXRpY0N1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgICAgICAvLyB0cmFuc2Zvcm0gdG8gYWJzb2x1dGUgeCx5XG4gICAgICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzNdO1xuICAgICAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs0XTtcblxuICAgICAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG5cbiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgICAgIGNvbnRyb2xZICsgdCxcbiAgICAgICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgdGVtcFggPSBjdXJyZW50WzNdO1xuICAgICAgICAgICAgdGVtcFkgPSBjdXJyZW50WzRdO1xuXG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgY3VycmVudFsxXSArIGwsXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0gKyB0LFxuICAgICAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgICAgIGNvbnRyb2xYID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIGNvbnRyb2xZID0gY3VycmVudFsyXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndCc6IC8vIHNob3J0aGFuZCBxdWFkcmF0aWNDdXJ2ZVRvLCByZWxhdGl2ZVxuXG4gICAgICAgICAgICAvLyB0cmFuc2Zvcm0gdG8gYWJzb2x1dGUgeCx5XG4gICAgICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFsyXTtcblxuICAgICAgICAgICAgaWYgKHByZXZpb3VzWzBdLm1hdGNoKC9bUXFUdF0vKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBwcmV2aW91cyBjb21tYW5kIG9yIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIHdhcyBub3QgYSBRLCBxLCBUIG9yIHQsXG4gICAgICAgICAgICAgIC8vIGFzc3VtZSB0aGUgY29udHJvbCBwb2ludCBpcyBjb2luY2lkZW50IHdpdGggdGhlIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgICAgICAgY29udHJvbFggPSB4O1xuICAgICAgICAgICAgICBjb250cm9sWSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgICAgIHkgPSB0ZW1wWTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICAgIHRlbXBYID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHRlbXBZID0gY3VycmVudFsyXTtcblxuICAgICAgICAgICAgaWYgKHByZXZpb3VzWzBdLm1hdGNoKC9bUXFUdF0vKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBwcmV2aW91cyBjb21tYW5kIG9yIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIHdhcyBub3QgYSBRLCBxLCBUIG9yIHQsXG4gICAgICAgICAgICAgIC8vIGFzc3VtZSB0aGUgY29udHJvbCBwb2ludCBpcyBjb2luY2lkZW50IHdpdGggdGhlIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgICAgICAgY29udHJvbFggPSB4O1xuICAgICAgICAgICAgICBjb250cm9sWSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgICAgIGNvbnRyb2xZICsgdCxcbiAgICAgICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgLy8gVE9ETzogb3B0aW1pemUgdGhpc1xuICAgICAgICAgICAgZHJhd0FyYyhjdHgsIHggKyBsLCB5ICsgdCwgW1xuICAgICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgICAgICBjdXJyZW50WzRdLFxuICAgICAgICAgICAgICBjdXJyZW50WzVdLFxuICAgICAgICAgICAgICBjdXJyZW50WzZdICsgeCArIGwsXG4gICAgICAgICAgICAgIGN1cnJlbnRbN10gKyB5ICsgdFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB4ICs9IGN1cnJlbnRbNl07XG4gICAgICAgICAgICB5ICs9IGN1cnJlbnRbN107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgLy8gVE9ETzogb3B0aW1pemUgdGhpc1xuICAgICAgICAgICAgZHJhd0FyYyhjdHgsIHggKyBsLCB5ICsgdCwgW1xuICAgICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgICAgICBjdXJyZW50WzRdLFxuICAgICAgICAgICAgICBjdXJyZW50WzVdLFxuICAgICAgICAgICAgICBjdXJyZW50WzZdICsgbCxcbiAgICAgICAgICAgICAgY3VycmVudFs3XSArIHRcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgeCA9IGN1cnJlbnRbNl07XG4gICAgICAgICAgICB5ID0gY3VycmVudFs3XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICB4ID0gc3VicGF0aFN0YXJ0WDtcbiAgICAgICAgICAgIHkgPSBzdWJwYXRoU3RhcnRZO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggY29udGV4dCB0byByZW5kZXIgcGF0aCBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5fcmVuZGVyUGF0aENvbW1hbmRzKGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJGaWxsKGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJTdHJva2UoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuUGF0aCAoJyArIHRoaXMuY29tcGxleGl0eSgpICtcbiAgICAgICAgJyk6IHsgXCJ0b3BcIjogJyArIHRoaXMudG9wICsgJywgXCJsZWZ0XCI6ICcgKyB0aGlzLmxlZnQgKyAnIH0+JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG8gPSBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JywgcHJvcGVydGllc1RvSW5jbHVkZSksIHtcbiAgICAgICAgcGF0aDogdGhpcy5wYXRoLm1hcChmdW5jdGlvbihpdGVtKSB7IHJldHVybiBpdGVtLnNsaWNlKCkgfSksXG4gICAgICAgIHBhdGhPZmZzZXQ6IHRoaXMucGF0aE9mZnNldFxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5zb3VyY2VQYXRoKSB7XG4gICAgICAgIG8uc291cmNlUGF0aCA9IHRoaXMuc291cmNlUGF0aDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRyYW5zZm9ybU1hdHJpeCkge1xuICAgICAgICBvLnRyYW5zZm9ybU1hdHJpeCA9IHRoaXMudHJhbnNmb3JtTWF0cml4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG87XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGF0YWxlc3Mgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9EYXRhbGVzc09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG8gPSB0aGlzLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgaWYgKHRoaXMuc291cmNlUGF0aCkge1xuICAgICAgICBvLnBhdGggPSB0aGlzLnNvdXJjZVBhdGg7XG4gICAgICB9XG4gICAgICBkZWxldGUgby5zb3VyY2VQYXRoO1xuICAgICAgcmV0dXJuIG87XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHZhciBjaHVua3MgPSBbXSxcbiAgICAgICAgICBtYXJrdXAgPSB0aGlzLl9jcmVhdGVCYXNlU1ZHTWFya3VwKCksIGFkZFRyYW5zZm9ybSA9ICcnO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5wYXRoLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNodW5rcy5wdXNoKHRoaXMucGF0aFtpXS5qb2luKCcgJykpO1xuICAgICAgfVxuICAgICAgdmFyIHBhdGggPSBjaHVua3Muam9pbignICcpO1xuICAgICAgaWYgKCEodGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLnR5cGUgPT09ICdwYXRoLWdyb3VwJykpIHtcbiAgICAgICAgYWRkVHJhbnNmb3JtID0gJyB0cmFuc2xhdGUoJyArICgtdGhpcy5wYXRoT2Zmc2V0LngpICsgJywgJyArICgtdGhpcy5wYXRoT2Zmc2V0LnkpICsgJykgJztcbiAgICAgIH1cbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPHBhdGggJywgdGhpcy5nZXRTdmdJZCgpLFxuICAgICAgICAgICdkPVwiJywgcGF0aCxcbiAgICAgICAgICAnXCIgc3R5bGU9XCInLCB0aGlzLmdldFN2Z1N0eWxlcygpLFxuICAgICAgICAgICdcIiB0cmFuc2Zvcm09XCInLCB0aGlzLmdldFN2Z1RyYW5zZm9ybSgpLCBhZGRUcmFuc2Zvcm0sXG4gICAgICAgICAgdGhpcy5nZXRTdmdUcmFuc2Zvcm1NYXRyaXgoKSwgJ1wiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiAnLFxuICAgICAgICAnLz5cXG4nXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcmV2aXZlciA/IHJldml2ZXIobWFya3VwLmpvaW4oJycpKSA6IG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBudW1iZXIgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2UgY29tcGxleGl0eVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gY29tcGxleGl0eSBvZiB0aGlzIGluc3RhbmNlXG4gICAgICovXG4gICAgY29tcGxleGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXRoLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcGFyc2VQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBjb29yZHMgPSBbXSxcbiAgICAgICAgICBjdXJyZW50UGF0aCxcbiAgICAgICAgICBwYXJzZWQsXG4gICAgICAgICAgcmUgPSAvKFstK10/KChcXGQrXFwuXFxkKyl8KChcXGQrKXwoXFwuXFxkKykpKSg/OmVbLStdP1xcZCspPykvaWcsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgY29vcmRzU3RyO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgY29vcmRzUGFyc2VkLCBsZW4gPSB0aGlzLnBhdGgubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY3VycmVudFBhdGggPSB0aGlzLnBhdGhbaV07XG5cbiAgICAgICAgY29vcmRzU3RyID0gY3VycmVudFBhdGguc2xpY2UoMSkudHJpbSgpO1xuICAgICAgICBjb29yZHMubGVuZ3RoID0gMDtcblxuICAgICAgICB3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhjb29yZHNTdHIpKSkge1xuICAgICAgICAgIGNvb3Jkcy5wdXNoKG1hdGNoWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvb3Jkc1BhcnNlZCA9IFtjdXJyZW50UGF0aC5jaGFyQXQoMCldO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gY29vcmRzLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgICAgIHBhcnNlZCA9IHBhcnNlRmxvYXQoY29vcmRzW2pdKTtcbiAgICAgICAgICBpZiAoIWlzTmFOKHBhcnNlZCkpIHtcbiAgICAgICAgICAgIGNvb3Jkc1BhcnNlZC5wdXNoKHBhcnNlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbW1hbmQgPSBjb29yZHNQYXJzZWRbMF0sXG4gICAgICAgICAgICBjb21tYW5kTGVuZ3RoID0gY29tbWFuZExlbmd0aHNbY29tbWFuZC50b0xvd2VyQ2FzZSgpXSxcbiAgICAgICAgICAgIHJlcGVhdGVkQ29tbWFuZCA9IHJlcGVhdGVkQ29tbWFuZHNbY29tbWFuZF0gfHwgY29tbWFuZDtcblxuICAgICAgICBpZiAoY29vcmRzUGFyc2VkLmxlbmd0aCAtIDEgPiBjb21tYW5kTGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgayA9IDEsIGtsZW4gPSBjb29yZHNQYXJzZWQubGVuZ3RoOyBrIDwga2xlbjsgayArPSBjb21tYW5kTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChbY29tbWFuZF0uY29uY2F0KGNvb3Jkc1BhcnNlZC5zbGljZShrLCBrICsgY29tbWFuZExlbmd0aCkpKTtcbiAgICAgICAgICAgIGNvbW1hbmQgPSByZXBlYXRlZENvbW1hbmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGNvb3Jkc1BhcnNlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcGFyc2VEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGFYID0gW10sXG4gICAgICAgICAgYVkgPSBbXSxcbiAgICAgICAgICBjdXJyZW50LCAvLyBjdXJyZW50IGluc3RydWN0aW9uXG4gICAgICAgICAgcHJldmlvdXMgPSBudWxsLFxuICAgICAgICAgIHN1YnBhdGhTdGFydFggPSAwLFxuICAgICAgICAgIHN1YnBhdGhTdGFydFkgPSAwLFxuICAgICAgICAgIHggPSAwLCAvLyBjdXJyZW50IHhcbiAgICAgICAgICB5ID0gMCwgLy8gY3VycmVudCB5XG4gICAgICAgICAgY29udHJvbFggPSAwLCAvLyBjdXJyZW50IGNvbnRyb2wgcG9pbnQgeFxuICAgICAgICAgIGNvbnRyb2xZID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHlcbiAgICAgICAgICB0ZW1wWCxcbiAgICAgICAgICB0ZW1wWSxcbiAgICAgICAgICBib3VuZHM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnBhdGgubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblxuICAgICAgICBjdXJyZW50ID0gdGhpcy5wYXRoW2ldO1xuXG4gICAgICAgIHN3aXRjaCAoY3VycmVudFswXSkgeyAvLyBmaXJzdCBsZXR0ZXJcblxuICAgICAgICAgIGNhc2UgJ2wnOiAvLyBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICB5ICs9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBib3VuZHMgPSBbXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnTCc6IC8vIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBib3VuZHMgPSBbXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaCc6IC8vIGhvcml6b250YWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0gnOiAvLyBob3Jpem9udGFsIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3YnOiAvLyB2ZXJ0aWNhbCBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgICAgICB5ICs9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICBib3VuZHMgPSBbXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnVic6IC8vIHZlcmljYWwgbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgeSA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICBib3VuZHMgPSBbXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbSc6IC8vIG1vdmVUbywgcmVsYXRpdmVcbiAgICAgICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgKz0gY3VycmVudFsyXTtcbiAgICAgICAgICAgIHN1YnBhdGhTdGFydFggPSB4O1xuICAgICAgICAgICAgc3VicGF0aFN0YXJ0WSA9IHk7XG4gICAgICAgICAgICBib3VuZHMgPSBbXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnTSc6IC8vIG1vdmVUbywgYWJzb2x1dGVcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBzdWJwYXRoU3RhcnRYID0geDtcbiAgICAgICAgICAgIHN1YnBhdGhTdGFydFkgPSB5O1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2MnOiAvLyBiZXppZXJDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFs1XTtcbiAgICAgICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNl07XG4gICAgICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzNdO1xuICAgICAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFs0XTtcbiAgICAgICAgICAgIGJvdW5kcyA9IGZhYnJpYy51dGlsLmdldEJvdW5kc09mQ3VydmUoeCwgeSxcbiAgICAgICAgICAgICAgeCArIGN1cnJlbnRbMV0sIC8vIHgxXG4gICAgICAgICAgICAgIHkgKyBjdXJyZW50WzJdLCAvLyB5MVxuICAgICAgICAgICAgICBjb250cm9sWCwgLy8geDJcbiAgICAgICAgICAgICAgY29udHJvbFksIC8vIHkyXG4gICAgICAgICAgICAgIHRlbXBYLFxuICAgICAgICAgICAgICB0ZW1wWVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQyc6IC8vIGJlemllckN1cnZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFs1XTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzZdO1xuICAgICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzNdO1xuICAgICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzRdO1xuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSh4LCB5LFxuICAgICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgICBjb250cm9sWCxcbiAgICAgICAgICAgICAgY29udHJvbFksXG4gICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgIHlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3MnOiAvLyBzaG9ydGhhbmQgY3ViaWMgYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcblxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNF07XG5cbiAgICAgICAgICAgIGlmIChwcmV2aW91c1swXS5tYXRjaCgvW0NjU3NdLykgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgY29tbWFuZCBvciBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCB3YXMgbm90IGEgQywgYywgUywgb3IgcyxcbiAgICAgICAgICAgICAgLy8gdGhlIGNvbnRyb2wgcG9pbnQgaXMgY29pbmNpZGVudCB3aXRoIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgICAgICAgIGNvbnRyb2xYID0geDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBib3VuZHMgPSBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkN1cnZlKHgsIHksXG4gICAgICAgICAgICAgIGNvbnRyb2xYLFxuICAgICAgICAgICAgICBjb250cm9sWSxcbiAgICAgICAgICAgICAgeCArIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICAgIHkgKyBjdXJyZW50WzJdLFxuICAgICAgICAgICAgICB0ZW1wWCxcbiAgICAgICAgICAgICAgdGVtcFlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvLyBzZXQgY29udHJvbCBwb2ludCB0byAybmQgb25lIG9mIHRoaXMgY29tbWFuZFxuICAgICAgICAgICAgLy8gXCIuLi4gdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgaXMgYXNzdW1lZCB0byBiZVxuICAgICAgICAgICAgLy8gdGhlIHJlZmxlY3Rpb24gb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50IG9uXG4gICAgICAgICAgICAvLyB0aGUgcHJldmlvdXMgY29tbWFuZCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb2ludC5cIlxuICAgICAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG4gICAgICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1MnOiAvLyBzaG9ydGhhbmQgY3ViaWMgYmV6aWVyQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgICAgIHRlbXBYID0gY3VycmVudFszXTtcbiAgICAgICAgICAgIHRlbXBZID0gY3VycmVudFs0XTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c1swXS5tYXRjaCgvW0NjU3NdLykgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgY29tbWFuZCBvciBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCB3YXMgbm90IGEgQywgYywgUywgb3IgcyxcbiAgICAgICAgICAgICAgLy8gdGhlIGNvbnRyb2wgcG9pbnQgaXMgY29pbmNpZGVudCB3aXRoIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgICAgICAgIGNvbnRyb2xYID0geDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSh4LCB5LFxuICAgICAgICAgICAgICBjb250cm9sWCxcbiAgICAgICAgICAgICAgY29udHJvbFksXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICAgIHRlbXBYLFxuICAgICAgICAgICAgICB0ZW1wWVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgICAgIC8vIHNldCBjb250cm9sIHBvaW50IHRvIDJuZCBvbmUgb2YgdGhpcyBjb21tYW5kXG4gICAgICAgICAgICAvLyBcIi4uLiB0aGUgZmlyc3QgY29udHJvbCBwb2ludCBpcyBhc3N1bWVkIHRvIGJlXG4gICAgICAgICAgICAvLyB0aGUgcmVmbGVjdGlvbiBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgb25cbiAgICAgICAgICAgIC8vIHRoZSBwcmV2aW91cyBjb21tYW5kIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvaW50LlwiXG4gICAgICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNF07XG4gICAgICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcbiAgICAgICAgICAgIGJvdW5kcyA9IGZhYnJpYy51dGlsLmdldEJvdW5kc09mQ3VydmUoeCwgeSxcbiAgICAgICAgICAgICAgY29udHJvbFgsXG4gICAgICAgICAgICAgIGNvbnRyb2xZLFxuICAgICAgICAgICAgICBjb250cm9sWCxcbiAgICAgICAgICAgICAgY29udHJvbFksXG4gICAgICAgICAgICAgIHRlbXBYLFxuICAgICAgICAgICAgICB0ZW1wWVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnUSc6IC8vIHF1YWRyYXRpY0N1cnZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBib3VuZHMgPSBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkN1cnZlKHgsIHksXG4gICAgICAgICAgICAgIGNvbnRyb2xYLFxuICAgICAgICAgICAgICBjb250cm9sWSxcbiAgICAgICAgICAgICAgY29udHJvbFgsXG4gICAgICAgICAgICAgIGNvbnRyb2xZLFxuICAgICAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgICAgICBjdXJyZW50WzRdXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgICB5ID0gY3VycmVudFs0XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndCc6IC8vIHNob3J0aGFuZCBxdWFkcmF0aWNDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbMl07XG4gICAgICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tRcVR0XS8pID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIFEsIHEsIFQgb3IgdCxcbiAgICAgICAgICAgICAgLy8gYXNzdW1lIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50XG4gICAgICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBib3VuZHMgPSBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkN1cnZlKHgsIHksXG4gICAgICAgICAgICAgIGNvbnRyb2xYLFxuICAgICAgICAgICAgICBjb250cm9sWSxcbiAgICAgICAgICAgICAgY29udHJvbFgsXG4gICAgICAgICAgICAgIGNvbnRyb2xZLFxuICAgICAgICAgICAgICB0ZW1wWCxcbiAgICAgICAgICAgICAgdGVtcFlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgICAgICB5ID0gdGVtcFk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbMl07XG5cbiAgICAgICAgICAgIGlmIChwcmV2aW91c1swXS5tYXRjaCgvW1FxVHRdLykgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgY29tbWFuZCBvciBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCB3YXMgbm90IGEgUSwgcSwgVCBvciB0LFxuICAgICAgICAgICAgICAvLyBhc3N1bWUgdGhlIGNvbnRyb2wgcG9pbnQgaXMgY29pbmNpZGVudCB3aXRoIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgICAgICAgIGNvbnRyb2xYID0geDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRcbiAgICAgICAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib3VuZHMgPSBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkN1cnZlKHgsIHksXG4gICAgICAgICAgICAgIGNvbnRyb2xYLFxuICAgICAgICAgICAgICBjb250cm9sWSxcbiAgICAgICAgICAgICAgY29udHJvbFgsXG4gICAgICAgICAgICAgIGNvbnRyb2xZLFxuICAgICAgICAgICAgICB0ZW1wWCxcbiAgICAgICAgICAgICAgdGVtcFlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgLy8gVE9ETzogb3B0aW1pemUgdGhpc1xuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZBcmMoeCwgeSxcbiAgICAgICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICAgICAgY3VycmVudFs0XSxcbiAgICAgICAgICAgICAgY3VycmVudFs1XSxcbiAgICAgICAgICAgICAgY3VycmVudFs2XSArIHgsXG4gICAgICAgICAgICAgIGN1cnJlbnRbN10gKyB5XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCArPSBjdXJyZW50WzZdO1xuICAgICAgICAgICAgeSArPSBjdXJyZW50WzddO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgIC8vIFRPRE86IG9wdGltaXplIHRoaXNcbiAgICAgICAgICAgIGJvdW5kcyA9IGZhYnJpYy51dGlsLmdldEJvdW5kc09mQXJjKHgsIHksXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNl0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbN11cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gY3VycmVudFs2XTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzddO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICAgIHggPSBzdWJwYXRoU3RhcnRYO1xuICAgICAgICAgICAgeSA9IHN1YnBhdGhTdGFydFk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gICAgICAgIGJvdW5kcy5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgIGFYLnB1c2gocG9pbnQueCk7XG4gICAgICAgICAgYVkucHVzaChwb2ludC55KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFYLnB1c2goeCk7XG4gICAgICAgIGFZLnB1c2goeSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtaW5YID0gbWluKGFYKSB8fCAwLFxuICAgICAgICAgIG1pblkgPSBtaW4oYVkpIHx8IDAsXG4gICAgICAgICAgbWF4WCA9IG1heChhWCkgfHwgMCxcbiAgICAgICAgICBtYXhZID0gbWF4KGFZKSB8fCAwLFxuICAgICAgICAgIGRlbHRhWCA9IG1heFggLSBtaW5YLFxuICAgICAgICAgIGRlbHRhWSA9IG1heFkgLSBtaW5ZLFxuXG4gICAgICAgICAgbyA9IHtcbiAgICAgICAgICAgIGxlZnQ6IG1pblgsXG4gICAgICAgICAgICB0b3A6IG1pblksXG4gICAgICAgICAgICB3aWR0aDogZGVsdGFYLFxuICAgICAgICAgICAgaGVpZ2h0OiBkZWx0YVlcbiAgICAgICAgICB9O1xuXG4gICAgICByZXR1cm4gbztcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZhYnJpYy5QYXRoIGZyb20gYW4gb2JqZWN0XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5QYXRoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBmYWJyaWMuUGF0aCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuUGF0aC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIC8vIHJlbW92ZSB0aGlzIHBhdHRlcm4gcm9tIDIuMCwgYWNjZXB0IGp1c3Qgb2JqZWN0LlxuICAgIHZhciBwYXRoO1xuICAgIGlmICh0eXBlb2Ygb2JqZWN0LnBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICBmYWJyaWMubG9hZFNWR0Zyb21VUkwob2JqZWN0LnBhdGgsIGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAgICAgICB2YXIgcGF0aFVybCA9IG9iamVjdC5wYXRoO1xuICAgICAgICBwYXRoID0gZWxlbWVudHNbMF07XG4gICAgICAgIGRlbGV0ZSBvYmplY3QucGF0aDtcblxuICAgICAgICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKHBhdGgsIG9iamVjdCk7XG4gICAgICAgIHBhdGguc2V0U291cmNlUGF0aChwYXRoVXJsKTtcblxuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhwYXRoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHBhdGggPSBuZXcgZmFicmljLlBhdGgob2JqZWN0LnBhdGgsIG9iamVjdCk7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhwYXRoKTtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgfTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkgYGZhYnJpYy5QYXRoLmZyb21FbGVtZW50YClcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBhdGhcbiAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNQYXRoRWxlbWVudFxuICAgKi9cbiAgZmFicmljLlBhdGguQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdChbJ2QnXSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgZmFicmljLlBhdGggZnJvbSBhbiBTVkcgPHBhdGg+IGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBhdGhcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGZhYnJpYy5QYXRoIGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgZmFicmljLlBhdGguZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuUGF0aC5BVFRSSUJVVEVfTkFNRVMpO1xuICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG5ldyBmYWJyaWMuUGF0aChwYXJzZWRBdHRyaWJ1dGVzLmQsIGV4dGVuZChwYXJzZWRBdHRyaWJ1dGVzLCBvcHRpb25zKSkpO1xuICB9O1xuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhhdCBpbnN0YW5jZXMgb2YgdGhpcyB0eXBlIGFyZSBhc3luY1xuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUGF0aFxuICAgKiBAdHlwZSBCb29sZWFuXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBmYWJyaWMuUGF0aC5hc3luYyA9IHRydWU7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBpbnZva2UgPSBmYWJyaWMudXRpbC5hcnJheS5pbnZva2UsXG4gICAgICBwYXJlbnRUb09iamVjdCA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnRvT2JqZWN0O1xuXG4gIGlmIChmYWJyaWMuUGF0aEdyb3VwKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5QYXRoR3JvdXAgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdGggZ3JvdXAgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5QYXRoR3JvdXBcbiAgICogQGV4dGVuZHMgZmFicmljLlBhdGhcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTEjcGF0aF9hbmRfcGF0aGdyb3VwfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuUGF0aEdyb3VwI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuUGF0aEdyb3VwID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLlBhdGgsIC8qKiBAbGVuZHMgZmFicmljLlBhdGhHcm91cC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdwYXRoLWdyb3VwJyxcblxuICAgIC8qKlxuICAgICAqIEZpbGwgdmFsdWVcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZpbGw6ICcnLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUGF0aEdyb3VwfSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ocGF0aHMsIG9wdGlvbnMpIHtcblxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuICAgICAgdGhpcy5wYXRocyA9IHBhdGhzIHx8IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5wYXRocy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgdGhpcy5wYXRoc1tpXS5ncm91cCA9IHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnRvQmVQYXJzZWQpIHtcbiAgICAgICAgdGhpcy5wYXJzZURpbWVuc2lvbnNGcm9tUGF0aHMob3B0aW9ucyk7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLnRvQmVQYXJzZWQ7XG4gICAgICB9XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuXG4gICAgICBpZiAob3B0aW9ucy5zb3VyY2VQYXRoKSB7XG4gICAgICAgIHRoaXMuc2V0U291cmNlUGF0aChvcHRpb25zLnNvdXJjZVBhdGgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgd2lkdGggYW5kIGhlaWdodCBiYXNlZCBvbiBwYXRocyBjb250YWluZWRcbiAgICAgKi9cbiAgICBwYXJzZURpbWVuc2lvbnNGcm9tUGF0aHM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBwb2ludHMsIHAsIHhDID0gW10sIHlDID0gW10sIHBhdGgsIGhlaWdodCwgd2lkdGgsXG4gICAgICAgICAgbTtcbiAgICAgIGZvciAodmFyIGogPSB0aGlzLnBhdGhzLmxlbmd0aDsgai0tOykge1xuICAgICAgICBwYXRoID0gdGhpcy5wYXRoc1tqXTtcbiAgICAgICAgaGVpZ2h0ID0gcGF0aC5oZWlnaHQgKyBwYXRoLnN0cm9rZVdpZHRoO1xuICAgICAgICB3aWR0aCA9IHBhdGgud2lkdGggKyBwYXRoLnN0cm9rZVdpZHRoO1xuICAgICAgICBwb2ludHMgPSBbXG4gICAgICAgICAgeyB4OiBwYXRoLmxlZnQsIHk6IHBhdGgudG9wIH0sXG4gICAgICAgICAgeyB4OiBwYXRoLmxlZnQgKyB3aWR0aCwgeTogcGF0aC50b3AgfSxcbiAgICAgICAgICB7IHg6IHBhdGgubGVmdCwgeTogcGF0aC50b3AgKyBoZWlnaHQgfSxcbiAgICAgICAgICB7IHg6IHBhdGgubGVmdCArIHdpZHRoLCB5OiBwYXRoLnRvcCArIGhlaWdodCB9XG4gICAgICAgIF07XG4gICAgICAgIG0gPSB0aGlzLnBhdGhzW2pdLnRyYW5zZm9ybU1hdHJpeDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBwID0gcG9pbnRzW2ldO1xuICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICBwID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQocCwgbSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB4Qy5wdXNoKHAueCk7XG4gICAgICAgICAgeUMucHVzaChwLnkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvcHRpb25zLndpZHRoID0gTWF0aC5tYXguYXBwbHkobnVsbCwgeEMpO1xuICAgICAgb3B0aW9ucy5oZWlnaHQgPSBNYXRoLm1heC5hcHBseShudWxsLCB5Qyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhpcyBncm91cCBvbiBhIHNwZWNpZmllZCBjb250ZXh0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciB0aGlzIGluc3RhbmNlIG9uXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIC8vIGRvIG5vdCByZW5kZXIgaWYgb2JqZWN0IGlzIG5vdCB2aXNpYmxlXG4gICAgICBpZiAoIXRoaXMudmlzaWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgIGlmICh0aGlzLnRyYW5zZm9ybU1hdHJpeCkge1xuICAgICAgICBjdHgudHJhbnNmb3JtLmFwcGx5KGN0eCwgdGhpcy50cmFuc2Zvcm1NYXRyaXgpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2Zvcm0oY3R4KTtcblxuICAgICAgdGhpcy5fc2V0U2hhZG93KGN0eCk7XG4gICAgICB0aGlzLmNsaXBUbyAmJiBmYWJyaWMudXRpbC5jbGlwQ29udGV4dCh0aGlzLCBjdHgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSgtdGhpcy53aWR0aCAvIDIsIC10aGlzLmhlaWdodCAvIDIpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLnBhdGhzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICB0aGlzLnBhdGhzW2ldLnJlbmRlcihjdHgsIHRydWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGlwVG8gJiYgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgY2VydGFpbiBwcm9wZXJ0eSB0byBhIGNlcnRhaW4gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUGF0aEdyb3VwfSB0aGlzQXJnXG4gICAgICovXG4gICAgX3NldDogZnVuY3Rpb24ocHJvcCwgdmFsdWUpIHtcblxuICAgICAgaWYgKHByb3AgPT09ICdmaWxsJyAmJiB2YWx1ZSAmJiB0aGlzLmlzU2FtZUNvbG9yKCkpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLnBhdGhzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHRoaXMucGF0aHNbaV0uX3NldChwcm9wLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCdfc2V0JywgcHJvcCwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHBhdGggZ3JvdXBcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG8gPSBleHRlbmQocGFyZW50VG9PYmplY3QuY2FsbCh0aGlzLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSwge1xuICAgICAgICBwYXRoczogaW52b2tlKHRoaXMuZ2V0T2JqZWN0cygpLCAndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKVxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5zb3VyY2VQYXRoKSB7XG4gICAgICAgIG8uc291cmNlUGF0aCA9IHRoaXMuc291cmNlUGF0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGRhdGFsZXNzIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHBhdGggZ3JvdXBcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBkYXRhbGVzcyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b0RhdGFsZXNzT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgbyA9IHRoaXMudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICBpZiAodGhpcy5zb3VyY2VQYXRoKSB7XG4gICAgICAgIG8ucGF0aHMgPSB0aGlzLnNvdXJjZVBhdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLmdldE9iamVjdHMoKSxcbiAgICAgICAgICBwID0gdGhpcy5nZXRQb2ludEJ5T3JpZ2luKCdsZWZ0JywgJ3RvcCcpLFxuICAgICAgICAgIHRyYW5zbGF0ZVBhcnQgPSAndHJhbnNsYXRlKCcgKyBwLnggKyAnICcgKyBwLnkgKyAnKScsXG4gICAgICAgICAgbWFya3VwID0gdGhpcy5fY3JlYXRlQmFzZVNWR01hcmt1cCgpO1xuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICc8ZyAnLCB0aGlzLmdldFN2Z0lkKCksXG4gICAgICAgICdzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKCksICdcIiAnLFxuICAgICAgICAndHJhbnNmb3JtPVwiJywgdGhpcy5nZXRTdmdUcmFuc2Zvcm1NYXRyaXgoKSwgdHJhbnNsYXRlUGFydCwgdGhpcy5nZXRTdmdUcmFuc2Zvcm0oKSwgJ1wiICcsXG4gICAgICAgICc+XFxuJ1xuICAgICAgKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbWFya3VwLnB1c2goJ1xcdCcsIG9iamVjdHNbaV0udG9TVkcocmV2aXZlcikpO1xuICAgICAgfVxuICAgICAgbWFya3VwLnB1c2goJzwvZz5cXG4nKTtcblxuICAgICAgcmV0dXJuIHJldml2ZXIgPyByZXZpdmVyKG1hcmt1cC5qb2luKCcnKSkgOiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBwYXRoIGdyb3VwXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5QYXRoR3JvdXAgKCcgKyB0aGlzLmNvbXBsZXhpdHkoKSArXG4gICAgICAgICcpOiB7IHRvcDogJyArIHRoaXMudG9wICsgJywgbGVmdDogJyArIHRoaXMubGVmdCArICcgfT4nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYWxsIHBhdGhzIGluIHRoaXMgZ3JvdXAgYXJlIG9mIHNhbWUgY29sb3JcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGFsbCBwYXRocyBhcmUgb2YgdGhlIHNhbWUgY29sb3IgKGBmaWxsYClcbiAgICAgKi9cbiAgICBpc1NhbWVDb2xvcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZmlyc3RQYXRoRmlsbCA9IHRoaXMuZ2V0T2JqZWN0cygpWzBdLmdldCgnZmlsbCcpIHx8ICcnO1xuICAgICAgaWYgKHR5cGVvZiBmaXJzdFBhdGhGaWxsICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmaXJzdFBhdGhGaWxsID0gZmlyc3RQYXRoRmlsbC50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0cygpLmV2ZXJ5KGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgdmFyIHBhdGhGaWxsID0gcGF0aC5nZXQoJ2ZpbGwnKSB8fCAnJztcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwYXRoRmlsbCA9PT0gJ3N0cmluZycgJiYgKHBhdGhGaWxsKS50b0xvd2VyQ2FzZSgpID09PSBmaXJzdFBhdGhGaWxsO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbnVtYmVyIHJlcHJlc2VudGF0aW9uIG9mIG9iamVjdCdzIGNvbXBsZXhpdHlcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHlcbiAgICAgKi9cbiAgICBjb21wbGV4aXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhdGhzLnJlZHVjZShmdW5jdGlvbih0b3RhbCwgcGF0aCkge1xuICAgICAgICByZXR1cm4gdG90YWwgKyAoKHBhdGggJiYgcGF0aC5jb21wbGV4aXR5KSA/IHBhdGguY29tcGxleGl0eSgpIDogMCk7XG4gICAgICB9LCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgcGF0aHMgaW4gdGhpcyBwYXRoIGdyb3VwXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFycmF5IG9mIHBhdGggb2JqZWN0cyBpbmNsdWRlZCBpbiB0aGlzIHBhdGggZ3JvdXBcbiAgICAgKi9cbiAgICBnZXRPYmplY3RzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhdGhzO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgZmFicmljLlBhdGhHcm91cCBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUGF0aEdyb3VwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlBhdGhHcm91cCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuUGF0aEdyb3VwLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgLy8gcmVtb3ZlIHRoaXMgcGF0dGVybiBmcm9tIDIuMCBhY2NlcHRzIG9ubHkgb2JqZWN0XG4gICAgaWYgKHR5cGVvZiBvYmplY3QucGF0aHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBmYWJyaWMubG9hZFNWR0Zyb21VUkwob2JqZWN0LnBhdGhzLCBmdW5jdGlvbiAoZWxlbWVudHMpIHtcblxuICAgICAgICB2YXIgcGF0aFVybCA9IG9iamVjdC5wYXRocztcbiAgICAgICAgZGVsZXRlIG9iamVjdC5wYXRocztcblxuICAgICAgICB2YXIgcGF0aEdyb3VwID0gZmFicmljLnV0aWwuZ3JvdXBTVkdFbGVtZW50cyhlbGVtZW50cywgb2JqZWN0LCBwYXRoVXJsKTtcblxuICAgICAgICBjYWxsYmFjayhwYXRoR3JvdXApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMob2JqZWN0LnBhdGhzLCBmdW5jdGlvbihlbmxpdmVuZWRPYmplY3RzKSB7XG4gICAgICAgIGRlbGV0ZSBvYmplY3QucGF0aHM7XG4gICAgICAgIGNhbGxiYWNrKG5ldyBmYWJyaWMuUGF0aEdyb3VwKGVubGl2ZW5lZE9iamVjdHMsIG9iamVjdCkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhhdCBpbnN0YW5jZXMgb2YgdGhpcyB0eXBlIGFyZSBhc3luY1xuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUGF0aEdyb3VwXG4gICAqIEB0eXBlIEJvb2xlYW5cbiAgICogQGRlZmF1bHRcbiAgICovXG4gIGZhYnJpYy5QYXRoR3JvdXAuYXN5bmMgPSB0cnVlO1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgbWluID0gZmFicmljLnV0aWwuYXJyYXkubWluLFxuICAgICAgbWF4ID0gZmFicmljLnV0aWwuYXJyYXkubWF4LFxuICAgICAgaW52b2tlID0gZmFicmljLnV0aWwuYXJyYXkuaW52b2tlO1xuXG4gIGlmIChmYWJyaWMuR3JvdXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBsb2NrLXJlbGF0ZWQgcHJvcGVydGllcywgZm9yIHVzZSBpbiBmYWJyaWMuR3JvdXAjZ2V0XG4gIC8vIHRvIGVuYWJsZSBsb2NraW5nIGJlaGF2aW9yIG9uIGdyb3VwXG4gIC8vIHdoZW4gb25lIG9mIGl0cyBvYmplY3RzIGhhcyBsb2NrLXJlbGF0ZWQgcHJvcGVydGllcyBzZXRcbiAgdmFyIF9sb2NrUHJvcGVydGllcyA9IHtcbiAgICBsb2NrTW92ZW1lbnRYOiAgdHJ1ZSxcbiAgICBsb2NrTW92ZW1lbnRZOiAgdHJ1ZSxcbiAgICBsb2NrUm90YXRpb246ICAgdHJ1ZSxcbiAgICBsb2NrU2NhbGluZ1g6ICAgdHJ1ZSxcbiAgICBsb2NrU2NhbGluZ1k6ICAgdHJ1ZSxcbiAgICBsb2NrVW5pU2NhbGluZzogdHJ1ZVxuICB9O1xuXG4gIC8qKlxuICAgKiBHcm91cCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkdyb3VwXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQG1peGVzIGZhYnJpYy5Db2xsZWN0aW9uXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0zI2dyb3Vwc31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkdyb3VwI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuR3JvdXAgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCBmYWJyaWMuQ29sbGVjdGlvbiwgLyoqIEBsZW5kcyBmYWJyaWMuR3JvdXAucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnZ3JvdXAnLFxuXG4gICAgLyoqXG4gICAgICogV2lkdGggb2Ygc3Ryb2tlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2VXaWR0aDogMCxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiBjbGljayBldmVudHMgc2hvdWxkIGFsc28gY2hlY2sgZm9yIHN1YnRhcmdldHNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdWJUYXJnZXRDaGVjazogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RzIEdyb3VwIG9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaXNBbHJlYWR5R3JvdXBlZF0gaWYgdHJ1ZSwgb2JqZWN0cyBoYXZlIGJlZW4gZ3JvdXBlZCBhbHJlYWR5LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9iamVjdHMsIG9wdGlvbnMsIGlzQWxyZWFkeUdyb3VwZWQpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgfTtcblxuICAgICAgdGhpcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgLy8gaWYgb2JqZWN0cyBlbmNsb3NlZCBpbiBhIGdyb3VwIGhhdmUgYmVlbiBncm91cGVkIGFscmVhZHksXG4gICAgICAvLyB3ZSBjYW5ub3QgY2hhbmdlIHByb3BlcnRpZXMgb2Ygb2JqZWN0cy5cbiAgICAgIC8vIFRodXMgd2UgbmVlZCB0byBzZXQgb3B0aW9ucyB0byBncm91cCB3aXRob3V0IG9iamVjdHMsXG4gICAgICAvLyBiZWNhdXNlIGRlbGVnYXRlZFByb3BlcnRpZXMgcHJvcGFnYXRlIHRvIG9iamVjdHMuXG4gICAgICBpc0FscmVhZHlHcm91cGVkICYmIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuX29iamVjdHMgPSBvYmplY3RzIHx8IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICB0aGlzLl9vYmplY3RzW2ldLmdyb3VwID0gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcmlnaW5hbFN0YXRlID0geyB9O1xuXG4gICAgICBpZiAob3B0aW9ucy5vcmlnaW5YKSB7XG4gICAgICAgIHRoaXMub3JpZ2luWCA9IG9wdGlvbnMub3JpZ2luWDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLm9yaWdpblkpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5ZID0gb3B0aW9ucy5vcmlnaW5ZO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNBbHJlYWR5R3JvdXBlZCkge1xuICAgICAgICAvLyBkbyBub3QgY2hhbmdlIGNvb3JkaW5hdGUgb2Ygb2JqZWN0cyBlbmNsb3NlZCBpbiBhIGdyb3VwLFxuICAgICAgICAvLyBiZWNhdXNlIG9iamVjdHMgY29vcmRpbmF0ZSBzeXN0ZW0gaGF2ZSBiZWVuIGdyb3VwIGNvb2RpbmF0ZSBzeXN0ZW0gYWxyZWFkeS5cbiAgICAgICAgdGhpcy5fdXBkYXRlT2JqZWN0c0Nvb3Jkcyh0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9jYWxjQm91bmRzKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZU9iamVjdHNDb29yZHMoKTtcbiAgICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIHRoaXMuc2F2ZUNvb3JkcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBDb29yZHNDaGFuZ2VdIGlmIHRydWUsIGNvb3JkaW5hdGVzIG9mIG9iamVjdHMgZW5jbG9zZWQgaW4gYSBncm91cCBkbyBub3QgY2hhbmdlXG4gICAgICovXG4gICAgX3VwZGF0ZU9iamVjdHNDb29yZHM6IGZ1bmN0aW9uKHNraXBDb29yZHNDaGFuZ2UpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaS0tOyApe1xuICAgICAgICB0aGlzLl91cGRhdGVPYmplY3RDb29yZHModGhpcy5fb2JqZWN0c1tpXSwgc2tpcENvb3Jkc0NoYW5nZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBDb29yZHNDaGFuZ2VdIGlmIHRydWUsIGNvb3JkaW5hdGVzIG9mIG9iamVjdCBkb3NlIG5vdCBjaGFuZ2VcbiAgICAgKi9cbiAgICBfdXBkYXRlT2JqZWN0Q29vcmRzOiBmdW5jdGlvbihvYmplY3QsIHNraXBDb29yZHNDaGFuZ2UpIHtcbiAgICAgIC8vIGRvIG5vdCBkaXNwbGF5IGNvcm5lcnMgb2Ygb2JqZWN0cyBlbmNsb3NlZCBpbiBhIGdyb3VwXG4gICAgICBvYmplY3QuX19vcmlnSGFzQ29udHJvbHMgPSBvYmplY3QuaGFzQ29udHJvbHM7XG4gICAgICBvYmplY3QuaGFzQ29udHJvbHMgPSBmYWxzZTtcblxuICAgICAgaWYgKHNraXBDb29yZHNDaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2JqZWN0TGVmdCA9IG9iamVjdC5nZXRMZWZ0KCksXG4gICAgICAgICAgb2JqZWN0VG9wID0gb2JqZWN0LmdldFRvcCgpLFxuICAgICAgICAgIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKTtcblxuICAgICAgb2JqZWN0LnNldCh7XG4gICAgICAgIG9yaWdpbmFsTGVmdDogb2JqZWN0TGVmdCxcbiAgICAgICAgb3JpZ2luYWxUb3A6IG9iamVjdFRvcCxcbiAgICAgICAgbGVmdDogb2JqZWN0TGVmdCAtIGNlbnRlci54LFxuICAgICAgICB0b3A6IG9iamVjdFRvcCAtIGNlbnRlci55XG4gICAgICB9KTtcbiAgICAgIG9iamVjdC5zZXRDb29yZHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW5hdGlvbiBvZiBhIGdyb3VwXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuR3JvdXA6ICgnICsgdGhpcy5jb21wbGV4aXR5KCkgKyAnKT4nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIG9iamVjdCB0byBhIGdyb3VwOyBUaGVuIHJlY2FsY3VsYXRlcyBncm91cCdzIGRpbWVuc2lvbiwgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBhZGRXaXRoVXBkYXRlOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHRoaXMuX3Jlc3RvcmVPYmplY3RzU3RhdGUoKTtcbiAgICAgIGZhYnJpYy51dGlsLnJlc2V0T2JqZWN0VHJhbnNmb3JtKHRoaXMpO1xuICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICB0aGlzLl9vYmplY3RzLnB1c2gob2JqZWN0KTtcbiAgICAgICAgb2JqZWN0Lmdyb3VwID0gdGhpcztcbiAgICAgICAgb2JqZWN0Ll9zZXQoJ2NhbnZhcycsIHRoaXMuY2FudmFzKTtcbiAgICAgIH1cbiAgICAgIC8vIHNpbmNlIF9yZXN0b3JlT2JqZWN0c1N0YXRlIHNldCBvYmplY3RzIGluYWN0aXZlXG4gICAgICB0aGlzLmZvckVhY2hPYmplY3QodGhpcy5fc2V0T2JqZWN0QWN0aXZlLCB0aGlzKTtcbiAgICAgIHRoaXMuX2NhbGNCb3VuZHMoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZU9iamVjdHNDb29yZHMoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRPYmplY3RBY3RpdmU6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgb2JqZWN0LnNldCgnYWN0aXZlJywgdHJ1ZSk7XG4gICAgICBvYmplY3QuZ3JvdXAgPSB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIG9iamVjdCBmcm9tIGEgZ3JvdXA7IFRoZW4gcmVjYWxjdWxhdGVzIGdyb3VwJ3MgZGltZW5zaW9uLCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlbW92ZVdpdGhVcGRhdGU6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdGhpcy5fcmVzdG9yZU9iamVjdHNTdGF0ZSgpO1xuICAgICAgZmFicmljLnV0aWwucmVzZXRPYmplY3RUcmFuc2Zvcm0odGhpcyk7XG4gICAgICAvLyBzaW5jZSBfcmVzdG9yZU9iamVjdHNTdGF0ZSBzZXQgb2JqZWN0cyBpbmFjdGl2ZVxuICAgICAgdGhpcy5mb3JFYWNoT2JqZWN0KHRoaXMuX3NldE9iamVjdEFjdGl2ZSwgdGhpcyk7XG5cbiAgICAgIHRoaXMucmVtb3ZlKG9iamVjdCk7XG4gICAgICB0aGlzLl9jYWxjQm91bmRzKCk7XG4gICAgICB0aGlzLl91cGRhdGVPYmplY3RzQ29vcmRzKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbk9iamVjdEFkZGVkOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIG9iamVjdC5ncm91cCA9IHRoaXM7XG4gICAgICBvYmplY3QuX3NldCgnY2FudmFzJywgdGhpcy5jYW52YXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbk9iamVjdFJlbW92ZWQ6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgZGVsZXRlIG9iamVjdC5ncm91cDtcbiAgICAgIG9iamVjdC5zZXQoJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyB0aGF0IGFyZSBkZWxlZ2F0ZWQgdG8gZ3JvdXAgb2JqZWN0cyB3aGVuIHJlYWRpbmcvd3JpdGluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWxlZ2F0ZWRQcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZGVsZWdhdGVkUHJvcGVydGllczoge1xuICAgICAgZmlsbDogICAgICAgICAgICAgdHJ1ZSxcbiAgICAgIHN0cm9rZTogICAgICAgICAgIHRydWUsXG4gICAgICBzdHJva2VXaWR0aDogICAgICB0cnVlLFxuICAgICAgZm9udEZhbWlseTogICAgICAgdHJ1ZSxcbiAgICAgIGZvbnRXZWlnaHQ6ICAgICAgIHRydWUsXG4gICAgICBmb250U2l6ZTogICAgICAgICB0cnVlLFxuICAgICAgZm9udFN0eWxlOiAgICAgICAgdHJ1ZSxcbiAgICAgIGxpbmVIZWlnaHQ6ICAgICAgIHRydWUsXG4gICAgICB0ZXh0RGVjb3JhdGlvbjogICB0cnVlLFxuICAgICAgdGV4dEFsaWduOiAgICAgICAgdHJ1ZSxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogIHRydWVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuX29iamVjdHMubGVuZ3RoO1xuXG4gICAgICBpZiAodGhpcy5kZWxlZ2F0ZWRQcm9wZXJ0aWVzW2tleV0gfHwga2V5ID09PSAnY2FudmFzJykge1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5zZXRPbkdyb3VwKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0Jywga2V5LCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JywgcHJvcGVydGllc1RvSW5jbHVkZSksIHtcbiAgICAgICAgb2JqZWN0czogaW52b2tlKHRoaXMuX29iamVjdHMsICd0b09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBpbnN0YW5jZSBvbiBhIGdpdmVuIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIGluc3RhbmNlIG9uXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIC8vIGRvIG5vdCByZW5kZXIgaWYgb2JqZWN0IGlzIG5vdCB2aXNpYmxlXG4gICAgICBpZiAoIXRoaXMudmlzaWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBpZiAodGhpcy50cmFuc2Zvcm1NYXRyaXgpIHtcbiAgICAgICAgY3R4LnRyYW5zZm9ybS5hcHBseShjdHgsIHRoaXMudHJhbnNmb3JtTWF0cml4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhbnNmb3JtKGN0eCk7XG4gICAgICB0aGlzLl9zZXRTaGFkb3coY3R4KTtcbiAgICAgIHRoaXMuY2xpcFRvICYmIGZhYnJpYy51dGlsLmNsaXBDb250ZXh0KHRoaXMsIGN0eCk7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1Eb25lID0gdHJ1ZTtcbiAgICAgIC8vIHRoZSBhcnJheSBpcyBub3cgc29ydGVkIGluIG9yZGVyIG9mIGhpZ2hlc3QgZmlyc3QsIHNvIHN0YXJ0IGZyb20gZW5kXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLl9yZW5kZXJPYmplY3QodGhpcy5fb2JqZWN0c1tpXSwgY3R4KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jbGlwVG8gJiYgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1Eb25lID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgY29udHJvbHMgYW5kIGJvcmRlcnMgZm9yIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbbm9UcmFuc2Zvcm1dIFdoZW4gdHJ1ZSwgY29udGV4dCBpcyBub3QgdHJhbnNmb3JtZWRcbiAgICAgKi9cbiAgICBfcmVuZGVyQ29udHJvbHM6IGZ1bmN0aW9uKGN0eCwgbm9UcmFuc2Zvcm0pIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfcmVuZGVyQ29udHJvbHMnLCBjdHgsIG5vVHJhbnNmb3JtKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuX29iamVjdHNbaV0uX3JlbmRlckNvbnRyb2xzKGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlck9iamVjdDogZnVuY3Rpb24ob2JqZWN0LCBjdHgpIHtcbiAgICAgIC8vIGRvIG5vdCByZW5kZXIgaWYgb2JqZWN0IGlzIG5vdCB2aXNpYmxlXG4gICAgICBpZiAoIW9iamVjdC52aXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG9yaWdpbmFsSGFzUm90YXRpbmdQb2ludCA9IG9iamVjdC5oYXNSb3RhdGluZ1BvaW50O1xuICAgICAgb2JqZWN0Lmhhc1JvdGF0aW5nUG9pbnQgPSBmYWxzZTtcbiAgICAgIG9iamVjdC5yZW5kZXIoY3R4KTtcbiAgICAgIG9iamVjdC5oYXNSb3RhdGluZ1BvaW50ID0gb3JpZ2luYWxIYXNSb3RhdGluZ1BvaW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRvcmVzIG9yaWdpbmFsIHN0YXRlIG9mIGVhY2ggb2YgZ3JvdXAgb2JqZWN0cyAob3JpZ2luYWwgc3RhdGUgaXMgdGhhdCB3aGljaCB3YXMgYmVmb3JlIGdyb3VwIHdhcyBjcmVhdGVkKS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBfcmVzdG9yZU9iamVjdHNTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9vYmplY3RzLmZvckVhY2godGhpcy5fcmVzdG9yZU9iamVjdFN0YXRlLCB0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWFsaXNlcyB0aGUgdHJhbnNmb3JtIGZyb20gdGhpcyBncm91cCBvbnRvIHRoZSBzdXBwbGllZCBvYmplY3RcbiAgICAgKiBpLmUuIGl0IHRlbGxzIHlvdSB3aGF0IHdvdWxkIGhhcHBlbiBpZiB0aGUgc3VwcGxpZWQgb2JqZWN0IHdhcyBpblxuICAgICAqIHRoZSBncm91cCwgYW5kIHRoZW4gdGhlIGdyb3VwIHdhcyBkZXN0cm95ZWQuIEl0IG11dGF0ZXMgdGhlIHN1cHBsaWVkXG4gICAgICogb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdHJhbnNmb3JtZWRPYmplY3RcbiAgICAgKi9cbiAgICByZWFsaXplVHJhbnNmb3JtOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBtYXRyaXggPSBvYmplY3QuY2FsY1RyYW5zZm9ybU1hdHJpeCgpLFxuICAgICAgICAgIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5xckRlY29tcG9zZShtYXRyaXgpLFxuICAgICAgICAgIGNlbnRlciA9IG5ldyBmYWJyaWMuUG9pbnQob3B0aW9ucy50cmFuc2xhdGVYLCBvcHRpb25zLnRyYW5zbGF0ZVkpO1xuICAgICAgb2JqZWN0LnNjYWxlWCA9IG9wdGlvbnMuc2NhbGVYO1xuICAgICAgb2JqZWN0LnNjYWxlWSA9IG9wdGlvbnMuc2NhbGVZO1xuICAgICAgb2JqZWN0LnNrZXdYID0gb3B0aW9ucy5za2V3WDtcbiAgICAgIG9iamVjdC5za2V3WSA9IG9wdGlvbnMuc2tld1k7XG4gICAgICBvYmplY3QuYW5nbGUgPSBvcHRpb25zLmFuZ2xlO1xuICAgICAgb2JqZWN0LmZsaXBYID0gZmFsc2U7XG4gICAgICBvYmplY3QuZmxpcFkgPSBmYWxzZTtcbiAgICAgIG9iamVjdC5zZXRQb3NpdGlvbkJ5T3JpZ2luKGNlbnRlciwgJ2NlbnRlcicsICdjZW50ZXInKTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmVzIG9yaWdpbmFsIHN0YXRlIG9mIGEgc3BlY2lmaWVkIG9iamVjdCBpbiBncm91cFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBfcmVzdG9yZU9iamVjdFN0YXRlOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHRoaXMucmVhbGl6ZVRyYW5zZm9ybShvYmplY3QpO1xuICAgICAgb2JqZWN0LnNldENvb3JkcygpO1xuICAgICAgb2JqZWN0Lmhhc0NvbnRyb2xzID0gb2JqZWN0Ll9fb3JpZ0hhc0NvbnRyb2xzO1xuICAgICAgZGVsZXRlIG9iamVjdC5fX29yaWdIYXNDb250cm9scztcbiAgICAgIG9iamVjdC5zZXQoJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgIGRlbGV0ZSBvYmplY3QuZ3JvdXA7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyBhIGdyb3VwIChyZXN0b3Jpbmcgc3RhdGUgb2YgaXRzIG9iamVjdHMpXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jlc3RvcmVPYmplY3RzU3RhdGUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2F2ZXMgY29vcmRpbmF0ZXMgb2YgdGhpcyBpbnN0YW5jZSAodG8gYmUgdXNlZCB0b2dldGhlciB3aXRoIGBoYXNNb3ZlZGApXG4gICAgICogQHNhdmVDb29yZHNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2F2ZUNvb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9vcmlnaW5hbExlZnQgPSB0aGlzLmdldCgnbGVmdCcpO1xuICAgICAgdGhpcy5fb3JpZ2luYWxUb3AgPSB0aGlzLmdldCgndG9wJyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhpcyBncm91cCB3YXMgbW92ZWQgKHNpbmNlIGBzYXZlQ29vcmRzYCB3YXMgY2FsbGVkIGxhc3QpXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBhbiBvYmplY3Qgd2FzIG1vdmVkIChzaW5jZSBmYWJyaWMuR3JvdXAjc2F2ZUNvb3JkcyB3YXMgY2FsbGVkKVxuICAgICAqL1xuICAgIGhhc01vdmVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbExlZnQgIT09IHRoaXMuZ2V0KCdsZWZ0JykgfHxcbiAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbFRvcCAhPT0gdGhpcy5nZXQoJ3RvcCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGNvb3JkaW5hdGVzIG9mIGFsbCBncm91cCBvYmplY3RzXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldE9iamVjdHNDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5mb3JFYWNoT2JqZWN0KGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBvYmplY3Quc2V0Q29vcmRzKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjQm91bmRzOiBmdW5jdGlvbihvbmx5V2lkdGhIZWlnaHQpIHtcbiAgICAgIHZhciBhWCA9IFtdLFxuICAgICAgICAgIGFZID0gW10sXG4gICAgICAgICAgbywgcHJvcCxcbiAgICAgICAgICBwcm9wcyA9IFsndHInLCAnYnInLCAnYmwnLCAndGwnXSxcbiAgICAgICAgICBpID0gMCwgaUxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoLFxuICAgICAgICAgIGosIGpMZW4gPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIGZvciAoIDsgaSA8IGlMZW47ICsraSkge1xuICAgICAgICBvID0gdGhpcy5fb2JqZWN0c1tpXTtcbiAgICAgICAgby5zZXRDb29yZHMoKTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGorKykge1xuICAgICAgICAgIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgICAgICBhWC5wdXNoKG8ub0Nvb3Jkc1twcm9wXS54KTtcbiAgICAgICAgICBhWS5wdXNoKG8ub0Nvb3Jkc1twcm9wXS55KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnNldCh0aGlzLl9nZXRCb3VuZHMoYVgsIGFZLCBvbmx5V2lkdGhIZWlnaHQpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Qm91bmRzOiBmdW5jdGlvbihhWCwgYVksIG9ubHlXaWR0aEhlaWdodCkge1xuICAgICAgdmFyIGl2dCA9IGZhYnJpYy51dGlsLmludmVydFRyYW5zZm9ybSh0aGlzLmdldFZpZXdwb3J0VHJhbnNmb3JtKCkpLFxuICAgICAgICAgIG1pblhZID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQobmV3IGZhYnJpYy5Qb2ludChtaW4oYVgpLCBtaW4oYVkpKSwgaXZ0KSxcbiAgICAgICAgICBtYXhYWSA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KG5ldyBmYWJyaWMuUG9pbnQobWF4KGFYKSwgbWF4KGFZKSksIGl2dCksXG4gICAgICAgICAgb2JqID0ge1xuICAgICAgICAgICAgd2lkdGg6IChtYXhYWS54IC0gbWluWFkueCkgfHwgMCxcbiAgICAgICAgICAgIGhlaWdodDogKG1heFhZLnkgLSBtaW5YWS55KSB8fCAwXG4gICAgICAgICAgfTtcblxuICAgICAgaWYgKCFvbmx5V2lkdGhIZWlnaHQpIHtcbiAgICAgICAgb2JqLmxlZnQgPSBtaW5YWS54IHx8IDA7XG4gICAgICAgIG9iai50b3AgPSBtaW5YWS55IHx8IDA7XG4gICAgICAgIGlmICh0aGlzLm9yaWdpblggPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgb2JqLmxlZnQgKz0gb2JqLndpZHRoIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcmlnaW5YID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgb2JqLmxlZnQgKz0gb2JqLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9yaWdpblkgPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgb2JqLnRvcCArPSBvYmouaGVpZ2h0IC8gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcmlnaW5ZID09PSAnYm90dG9tJykge1xuICAgICAgICAgIG9iai50b3AgKz0gb2JqLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIG1hcmt1cCA9IHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAoKTtcbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPGcgJywgdGhpcy5nZXRTdmdJZCgpLCAndHJhbnNmb3JtPVwiJyxcbiAgICAgICAgLyogYXZvaWRpbmcgc3R5bGVzIGludGVudGlvbmFsbHkgKi9cbiAgICAgICAgdGhpcy5nZXRTdmdUcmFuc2Zvcm0oKSxcbiAgICAgICAgdGhpcy5nZXRTdmdUcmFuc2Zvcm1NYXRyaXgoKSxcbiAgICAgICAgJ1wiIHN0eWxlPVwiJyxcbiAgICAgICAgdGhpcy5nZXRTdmdGaWx0ZXIoKSxcbiAgICAgICAgJ1wiPlxcbidcbiAgICAgICk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKCdcXHQnLCB0aGlzLl9vYmplY3RzW2ldLnRvU1ZHKHJldml2ZXIpKTtcbiAgICAgIH1cblxuICAgICAgbWFya3VwLnB1c2goJzwvZz5cXG4nKTtcblxuICAgICAgcmV0dXJuIHJldml2ZXIgPyByZXZpdmVyKG1hcmt1cC5qb2luKCcnKSkgOiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmVxdWVzdGVkIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3AgUHJvcGVydHkgdG8gZ2V0XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgIGlmIChwcm9wIGluIF9sb2NrUHJvcGVydGllcykge1xuICAgICAgICBpZiAodGhpc1twcm9wXSkge1xuICAgICAgICAgIHJldHVybiB0aGlzW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb2JqZWN0c1tpXVtwcm9wXSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHByb3AgaW4gdGhpcy5kZWxlZ2F0ZWRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX29iamVjdHNbMF0gJiYgdGhpcy5fb2JqZWN0c1swXS5nZXQocHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkdyb3VwfSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuR3JvdXBcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGEgZ3JvdXAgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGdyb3VwIGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICovXG4gIGZhYnJpYy5Hcm91cC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKG9iamVjdC5vYmplY3RzLCBmdW5jdGlvbihlbmxpdmVuZWRPYmplY3RzKSB7XG4gICAgICBkZWxldGUgb2JqZWN0Lm9iamVjdHM7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhuZXcgZmFicmljLkdyb3VwKGVubGl2ZW5lZE9iamVjdHMsIG9iamVjdCwgdHJ1ZSkpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhhdCBpbnN0YW5jZXMgb2YgdGhpcyB0eXBlIGFyZSBhc3luY1xuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuR3JvdXBcbiAgICogQHR5cGUgQm9vbGVhblxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgZmFicmljLkdyb3VwLmFzeW5jID0gdHJ1ZTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQ7XG5cbiAgaWYgKCFnbG9iYWwuZmFicmljKSB7XG4gICAgZ2xvYmFsLmZhYnJpYyA9IHsgfTtcbiAgfVxuXG4gIGlmIChnbG9iYWwuZmFicmljLkltYWdlKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5JbWFnZSBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHN0YXRlUHJvcGVydGllcyA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnN0YXRlUHJvcGVydGllcy5jb25jYXQoKTtcbiAgc3RhdGVQcm9wZXJ0aWVzLnB1c2goXG4gICAgJ2FsaWduWCcsXG4gICAgJ2FsaWduWScsXG4gICAgJ21lZXRPclNsaWNlJ1xuICApO1xuXG4gIC8qKlxuICAgKiBJbWFnZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTEjaW1hZ2VzfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5JbWFnZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2ltYWdlJyxcblxuICAgIC8qKlxuICAgICAqIGNyb3NzT3JpZ2luIHZhbHVlIChvbmUgb2YgXCJcIiwgXCJhbm9ueW1vdXNcIiwgXCJ1c2UtY3JlZGVudGlhbHNcIilcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNyb3NzT3JpZ2luOiAnJyxcblxuICAgIC8qKlxuICAgICAqIEFsaWduWCB2YWx1ZSwgcGFydCBvZiBwcmVzZXJ2ZUFzcGVjdFJhdGlvIChvbmUgb2YgXCJub25lXCIsIFwibWlkXCIsIFwibWluXCIsIFwibWF4XCIpXG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvY29vcmRzLmh0bWwjUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZVxuICAgICAqIFRoaXMgcGFyYW1ldGVyIGRlZmluZXMgaG93IHRoZSBwaWN0dXJlIGlzIGFsaWduZWQgdG8gaXRzIHZpZXdwb3J0IHdoZW4gaW1hZ2UgZWxlbWVudCB3aWR0aCBkaWZmZXJzIGZyb20gaW1hZ2Ugd2lkdGguXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBhbGlnblg6ICdub25lJyxcblxuICAgIC8qKlxuICAgICAqIEFsaWduWSB2YWx1ZSwgcGFydCBvZiBwcmVzZXJ2ZUFzcGVjdFJhdGlvIChvbmUgb2YgXCJub25lXCIsIFwibWlkXCIsIFwibWluXCIsIFwibWF4XCIpXG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvY29vcmRzLmh0bWwjUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZVxuICAgICAqIFRoaXMgcGFyYW1ldGVyIGRlZmluZXMgaG93IHRoZSBwaWN0dXJlIGlzIGFsaWduZWQgdG8gaXRzIHZpZXdwb3J0IHdoZW4gaW1hZ2UgZWxlbWVudCBoZWlnaHQgZGlmZmVycyBmcm9tIGltYWdlIGhlaWdodC5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGFsaWduWTogJ25vbmUnLFxuXG4gICAgLyoqXG4gICAgICogbWVldE9yU2xpY2UgdmFsdWUsIHBhcnQgb2YgcHJlc2VydmVBc3BlY3RSYXRpbyAgKG9uZSBvZiBcIm1lZXRcIiwgXCJzbGljZVwiKS5cbiAgICAgKiBpZiBtZWV0IHRoZSBpbWFnZSBpcyBhbHdheXMgZnVsbHkgdmlzaWJpbGUsIGlmIHNsaWNlIHRoZSB2aWV3cG9ydCBpcyBhbHdheXMgZmlsbGVkIHdpdGggaW1hZ2UuXG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvY29vcmRzLmh0bWwjUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWVldE9yU2xpY2U6ICdtZWV0JyxcblxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIGEgc3Ryb2tlLlxuICAgICAqIEZvciBpbWFnZSBxdWFsaXR5IGEgc3Ryb2tlIG11bHRpcGxlIG9mIDIgZ2l2ZXMgYmV0dGVyIHJlc3VsdHMuXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2VXaWR0aDogMCxcblxuICAgIC8qKlxuICAgICAqIHByaXZhdGVcbiAgICAgKiBjb250YWlucyBsYXN0IHZhbHVlIG9mIHNjYWxlWCB0byBkZXRlY3RcbiAgICAgKiBpZiB0aGUgSW1hZ2UgZ290IHJlc2l6ZWQgYWZ0ZXIgdGhlIGxhc3QgUmVuZGVyXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgX2xhc3RTY2FsZVg6IDEsXG5cbiAgICAvKipcbiAgICAgKiBwcml2YXRlXG4gICAgICogY29udGFpbnMgbGFzdCB2YWx1ZSBvZiBzY2FsZVkgdG8gZGV0ZWN0XG4gICAgICogaWYgdGhlIEltYWdlIGdvdCByZXNpemVkIGFmdGVyIHRoZSBsYXN0IFJlbmRlclxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIF9sYXN0U2NhbGVZOiAxLFxuXG4gICAgLyoqXG4gICAgICogbWluaW11bSBzY2FsZSBmYWN0b3IgdW5kZXIgd2hpY2ggYW55IHJlc2l6ZUZpbHRlciBpcyB0cmlnZ2VyZWQgdG8gcmVzaXplIHRoZSBpbWFnZVxuICAgICAqIDAgd2lsbCBkaXNhYmxlIHRoZSBhdXRvbWF0aWMgcmVzaXplLiAxIHdpbGwgdHJpZ2dlciBhdXRvbWF0aWNhbGx5IGFsd2F5cy5cbiAgICAgKiBudW1iZXIgYmlnZ2VyIHRoYW4gMSBjYW4gYmUgdXNlZCBpbiBjYXNlIHdlIHdhbnQgdG8gc2NhbGUgd2l0aCBzb21lIGZpbHRlciBhYm92ZVxuICAgICAqIHRoZSBuYXR1cmFsIGltYWdlIGRpbWVuc2lvbnNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICBtaW5pbXVtU2NhbGVUcmlnZ2VyOiAwLjUsXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZlxuICAgICAqIHN0YXRlIG9mIGFuIG9iamVjdCBpcyBjaGFuZ2VkICh7QGxpbmsgZmFicmljLk9iamVjdCNoYXNTdGF0ZUNoYW5nZWR9KVxuICAgICAqIGFzIHdlbGwgYXMgZm9yIGhpc3RvcnkgKHVuZG8vcmVkbykgcHVycG9zZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHN0YXRlUHJvcGVydGllczogc3RhdGVQcm9wZXJ0aWVzLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnQgfCBTdHJpbmd9IGVsZW1lbnQgSW1hZ2UgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgYWZ0ZXIgZXZlbnR1YWwgZmlsdGVycyBhcHBsaWVkLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIHRoaXMuZmlsdGVycyA9IFtdO1xuICAgICAgdGhpcy5yZXNpemVGaWx0ZXJzID0gW107XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5faW5pdEVsZW1lbnQoZWxlbWVudCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGltYWdlIGVsZW1lbnQgd2hpY2ggdGhpcyBpbnN0YW5jZSBpZiBiYXNlZCBvblxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEltYWdlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXRFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGltYWdlIGVsZW1lbnQgZm9yIHRoaXMgaW5zdGFuY2UgdG8gYSBzcGVjaWZpZWQgb25lLlxuICAgICAqIElmIGZpbHRlcnMgZGVmaW5lZCB0aGV5IGFyZSBhcHBsaWVkIHRvIG5ldyBpbWFnZS5cbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBjYW52YXMucmVuZGVyQWxsYCBhbmQgYG9iamVjdC5zZXRDb29yZHNgIGFmdGVyIHJlcGxhY2luZywgdG8gcmVuZGVyIG5ldyBpbWFnZSBhbmQgdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayBpcyBpbnZva2VkIHdoZW4gYWxsIGZpbHRlcnMgaGF2ZSBiZWVuIGFwcGxpZWQgYW5kIG5ldyBpbWFnZSBpcyBnZW5lcmF0ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkltYWdlfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldEVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG5cbiAgICAgIHZhciBfY2FsbGJhY2ssIF90aGlzO1xuXG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMuX29yaWdpbmFsRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLl9pbml0Q29uZmlnKG9wdGlvbnMpO1xuXG4gICAgICBpZiAodGhpcy5yZXNpemVGaWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBfY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9jYWxsYmFjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIF90aGlzLmFwcGx5RmlsdGVycyhjYWxsYmFjaywgX3RoaXMucmVzaXplRmlsdGVycywgX3RoaXMuX2ZpbHRlcmVkRWwgfHwgX3RoaXMuX29yaWdpbmFsRWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmZpbHRlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHRoaXMuYXBwbHlGaWx0ZXJzKF9jYWxsYmFjayk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChfY2FsbGJhY2spIHtcbiAgICAgICAgX2NhbGxiYWNrKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBjcm9zc09yaWdpbiB2YWx1ZSAob24gYW4gaW5zdGFuY2UgYW5kIGNvcnJlc3BvbmRpbmcgaW1hZ2UgZWxlbWVudClcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2V9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG4gICAgICB0aGlzLl9lbGVtZW50LmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9yaWdpbmFsIHNpemUgb2YgYW4gaW1hZ2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIFwid2lkdGhcIiBhbmQgXCJoZWlnaHRcIiBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ2V0T3JpZ2luYWxTaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogZWxlbWVudC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBlbGVtZW50LmhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3N0cm9rZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuc3Ryb2tlIHx8IHRoaXMuc3Ryb2tlV2lkdGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHcgPSB0aGlzLndpZHRoIC8gMiwgaCA9IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oLXcsIC1oKTtcbiAgICAgIGN0eC5saW5lVG8odywgLWgpO1xuICAgICAgY3R4LmxpbmVUbyh3LCBoKTtcbiAgICAgIGN0eC5saW5lVG8oLXcsIGgpO1xuICAgICAgY3R4LmxpbmVUbygtdywgLWgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyRGFzaGVkU3Ryb2tlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciB4ID0gLXRoaXMud2lkdGggLyAyLFxuICAgICAgICAgIHkgPSAtdGhpcy5oZWlnaHQgLyAyLFxuICAgICAgICAgIHcgPSB0aGlzLndpZHRoLFxuICAgICAgICAgIGggPSB0aGlzLmhlaWdodDtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuX3NldFN0cm9rZVN0eWxlcyhjdHgpO1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHgsIHksIHggKyB3LCB5LCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHggKyB3LCB5LCB4ICsgdywgeSArIGgsIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgeCArIHcsIHkgKyBoLCB4LCB5ICsgaCwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCB4LCB5ICsgaCwgeCwgeSwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIGZpbHRlcnMgPSBbXSwgcmVzaXplRmlsdGVycyA9IFtdLFxuICAgICAgICAgIHNjYWxlWCA9IDEsIHNjYWxlWSA9IDE7XG5cbiAgICAgIHRoaXMuZmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGZpbHRlck9iaikge1xuICAgICAgICBpZiAoZmlsdGVyT2JqKSB7XG4gICAgICAgICAgaWYgKGZpbHRlck9iai50eXBlID09PSAnUmVzaXplJykge1xuICAgICAgICAgICAgc2NhbGVYICo9IGZpbHRlck9iai5zY2FsZVg7XG4gICAgICAgICAgICBzY2FsZVkgKj0gZmlsdGVyT2JqLnNjYWxlWTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmlsdGVycy5wdXNoKGZpbHRlck9iai50b09iamVjdCgpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMucmVzaXplRmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGZpbHRlck9iaikge1xuICAgICAgICBmaWx0ZXJPYmogJiYgcmVzaXplRmlsdGVycy5wdXNoKGZpbHRlck9iai50b09iamVjdCgpKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgb2JqZWN0ID0gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpLCB7XG4gICAgICAgIHNyYzogdGhpcy5nZXRTcmMoKSxcbiAgICAgICAgZmlsdGVyczogZmlsdGVycyxcbiAgICAgICAgcmVzaXplRmlsdGVyczogcmVzaXplRmlsdGVycyxcbiAgICAgICAgY3Jvc3NPcmlnaW46IHRoaXMuY3Jvc3NPcmlnaW4sXG4gICAgICAgIGFsaWduWDogdGhpcy5hbGlnblgsXG4gICAgICAgIGFsaWduWTogdGhpcy5hbGlnblksXG4gICAgICAgIG1lZXRPclNsaWNlOiB0aGlzLm1lZXRPclNsaWNlXG4gICAgICB9KTtcblxuICAgICAgb2JqZWN0LndpZHRoIC89IHNjYWxlWDtcbiAgICAgIG9iamVjdC5oZWlnaHQgLz0gc2NhbGVZO1xuXG4gICAgICBpZiAoIXRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRGVmYXVsdFZhbHVlcyhvYmplY3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICB2YXIgbWFya3VwID0gdGhpcy5fY3JlYXRlQmFzZVNWR01hcmt1cCgpLCB4ID0gLXRoaXMud2lkdGggLyAyLCB5ID0gLXRoaXMuaGVpZ2h0IC8gMixcbiAgICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gJ25vbmUnLCBmaWx0ZXJlZCA9IHRydWU7XG4gICAgICBpZiAodGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLnR5cGUgPT09ICdwYXRoLWdyb3VwJykge1xuICAgICAgICB4ID0gdGhpcy5sZWZ0O1xuICAgICAgICB5ID0gdGhpcy50b3A7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5hbGlnblggIT09ICdub25lJyAmJiB0aGlzLmFsaWduWSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW8gPSAneCcgKyB0aGlzLmFsaWduWCArICdZJyArIHRoaXMuYWxpZ25ZICsgJyAnICsgdGhpcy5tZWV0T3JTbGljZTtcbiAgICAgIH1cbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPGcgdHJhbnNmb3JtPVwiJywgdGhpcy5nZXRTdmdUcmFuc2Zvcm0oKSwgdGhpcy5nZXRTdmdUcmFuc2Zvcm1NYXRyaXgoKSwgJ1wiPlxcbicsXG4gICAgICAgICAgJzxpbWFnZSAnLCB0aGlzLmdldFN2Z0lkKCksICd4bGluazpocmVmPVwiJywgdGhpcy5nZXRTdmdTcmMoZmlsdGVyZWQpLFxuICAgICAgICAgICAgJ1wiIHg9XCInLCB4LCAnXCIgeT1cIicsIHksXG4gICAgICAgICAgICAnXCIgc3R5bGU9XCInLCB0aGlzLmdldFN2Z1N0eWxlcygpLFxuICAgICAgICAgICAgLy8gd2UncmUgZXNzZW50aWFsbHkgbW92aW5nIG9yaWdpbiBvZiB0cmFuc2Zvcm1hdGlvbiBmcm9tIHRvcC9sZWZ0IGNvcm5lciB0byB0aGUgY2VudGVyIG9mIHRoZSBzaGFwZVxuICAgICAgICAgICAgLy8gYnkgd3JhcHBpbmcgaXQgaW4gY29udGFpbmVyIDxnPiBlbGVtZW50IHdpdGggYWN0dWFsIHRyYW5zZm9ybWF0aW9uLCB0aGVuIG9mZnNldHRpbmcgb2JqZWN0IHRvIHRoZSB0b3AvbGVmdFxuICAgICAgICAgICAgLy8gc28gdGhhdCBvYmplY3QncyBjZW50ZXIgYWxpZ25zIHdpdGggY29udGFpbmVyJ3MgbGVmdC90b3BcbiAgICAgICAgICAgICdcIiB3aWR0aD1cIicsIHRoaXMud2lkdGgsXG4gICAgICAgICAgICAnXCIgaGVpZ2h0PVwiJywgdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICAnXCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cIicsIHByZXNlcnZlQXNwZWN0UmF0aW8sICdcIicsXG4gICAgICAgICAgJz48L2ltYWdlPlxcbidcbiAgICAgICk7XG5cbiAgICAgIGlmICh0aGlzLnN0cm9rZSB8fCB0aGlzLnN0cm9rZURhc2hBcnJheSkge1xuICAgICAgICB2YXIgb3JpZ0ZpbGwgPSB0aGlzLmZpbGw7XG4gICAgICAgIHRoaXMuZmlsbCA9IG51bGw7XG4gICAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAgICc8cmVjdCAnLFxuICAgICAgICAgICAgJ3g9XCInLCB4LCAnXCIgeT1cIicsIHksXG4gICAgICAgICAgICAnXCIgd2lkdGg9XCInLCB0aGlzLndpZHRoLCAnXCIgaGVpZ2h0PVwiJywgdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICAnXCIgc3R5bGU9XCInLCB0aGlzLmdldFN2Z1N0eWxlcygpLFxuICAgICAgICAgICdcIi8+XFxuJ1xuICAgICAgICApO1xuICAgICAgICB0aGlzLmZpbGwgPSBvcmlnRmlsbDtcbiAgICAgIH1cblxuICAgICAgbWFya3VwLnB1c2goJzwvZz5cXG4nKTtcblxuICAgICAgcmV0dXJuIHJldml2ZXIgPyByZXZpdmVyKG1hcmt1cC5qb2luKCcnKSkgOiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc291cmNlIG9mIGFuIGltYWdlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBmaWx0ZXJlZCBpbmRpY2F0ZXMgaWYgdGhlIHNyYyBpcyBuZWVkZWQgZm9yIHN2Z1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU291cmNlIG9mIGFuIGltYWdlXG4gICAgICovXG4gICAgZ2V0U3JjOiBmdW5jdGlvbihmaWx0ZXJlZCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBmaWx0ZXJlZCA/IHRoaXMuX2VsZW1lbnQgOiB0aGlzLl9vcmlnaW5hbEVsZW1lbnQ7XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZmFicmljLmlzTGlrZWx5Tm9kZSA/IGVsZW1lbnQuX3NyYyA6IGVsZW1lbnQuc3JjO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNyYyB8fCAnJztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzb3VyY2Ugb2YgYW4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFNvdXJjZSBzdHJpbmcgKFVSTClcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIGlzIGludm9rZWQgd2hlbiBpbWFnZSBoYXMgYmVlbiBsb2FkZWQgKGFuZCBhbGwgZmlsdGVycyBoYXZlIGJlZW4gYXBwbGllZClcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkltYWdlfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFNyYzogZnVuY3Rpb24oc3JjLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgZmFicmljLnV0aWwubG9hZEltYWdlKHNyYywgZnVuY3Rpb24oaW1nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldEVsZW1lbnQoaW1nLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgICB9LCB0aGlzLCBvcHRpb25zICYmIG9wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5JbWFnZTogeyBzcmM6IFwiJyArIHRoaXMuZ2V0U3JjKCkgKyAnXCIgfT4nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlcnMgYXNzaWduZWQgdG8gdGhpcyBpbWFnZSAoZnJvbSBcImZpbHRlcnNcIiBhcnJheSlcbiAgICAgKiBAbWV0aG9kIGFwcGx5RmlsdGVyc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGlzIGludm9rZWQgd2hlbiBhbGwgZmlsdGVycyBoYXZlIGJlZW4gYXBwbGllZCBhbmQgbmV3IGltYWdlIGlzIGdlbmVyYXRlZFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcnMgdG8gYmUgYXBwbGllZFxuICAgICAqIEBwYXJhbSB7ZmFicmljLkltYWdlfSBpbWdFbGVtZW50IGltYWdlIHRvIGZpbHRlciAoIGRlZmF1bHQgdG8gdGhpcy5fZWxlbWVudCApXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBmb3JSZXNpemluZ1xuICAgICAqIEByZXR1cm4ge0NhbnZhc0VsZW1lbnR9IGNhbnZhc0VsIHRvIGJlIGRyYXduIGltbWVkaWF0ZWx5XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFwcGx5RmlsdGVyczogZnVuY3Rpb24oY2FsbGJhY2ssIGZpbHRlcnMsIGltZ0VsZW1lbnQsIGZvclJlc2l6aW5nKSB7XG5cbiAgICAgIGZpbHRlcnMgPSBmaWx0ZXJzIHx8IHRoaXMuZmlsdGVycztcbiAgICAgIGltZ0VsZW1lbnQgPSBpbWdFbGVtZW50IHx8IHRoaXMuX29yaWdpbmFsRWxlbWVudDtcblxuICAgICAgaWYgKCFpbWdFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlcGxhY2VtZW50ID0gZmFicmljLnV0aWwuY3JlYXRlSW1hZ2UoKSxcbiAgICAgICAgICByZXRpbmFTY2FsaW5nID0gdGhpcy5jYW52YXMgPyB0aGlzLmNhbnZhcy5nZXRSZXRpbmFTY2FsaW5nKCkgOiBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgICAgICBtaW5pbXVtU2NhbGUgPSB0aGlzLm1pbmltdW1TY2FsZVRyaWdnZXIgLyByZXRpbmFTY2FsaW5nLFxuICAgICAgICAgIF90aGlzID0gdGhpcywgc2NhbGVYLCBzY2FsZVk7XG5cbiAgICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gaW1nRWxlbWVudDtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sodGhpcyk7XG4gICAgICAgIHJldHVybiBpbWdFbGVtZW50O1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FudmFzRWwgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICBjYW52YXNFbC53aWR0aCA9IGltZ0VsZW1lbnQud2lkdGg7XG4gICAgICBjYW52YXNFbC5oZWlnaHQgPSBpbWdFbGVtZW50LmhlaWdodDtcbiAgICAgIGNhbnZhc0VsLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKGltZ0VsZW1lbnQsIDAsIDAsIGltZ0VsZW1lbnQud2lkdGgsIGltZ0VsZW1lbnQuaGVpZ2h0KTtcblxuICAgICAgZmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICBpZiAoIWZpbHRlcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9yUmVzaXppbmcpIHtcbiAgICAgICAgICBzY2FsZVggPSBfdGhpcy5zY2FsZVggPCBtaW5pbXVtU2NhbGUgPyBfdGhpcy5zY2FsZVggOiAxO1xuICAgICAgICAgIHNjYWxlWSA9IF90aGlzLnNjYWxlWSA8IG1pbmltdW1TY2FsZSA/IF90aGlzLnNjYWxlWSA6IDE7XG4gICAgICAgICAgaWYgKHNjYWxlWCAqIHJldGluYVNjYWxpbmcgPCAxKSB7XG4gICAgICAgICAgICBzY2FsZVggKj0gcmV0aW5hU2NhbGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNjYWxlWSAqIHJldGluYVNjYWxpbmcgPCAxKSB7XG4gICAgICAgICAgICBzY2FsZVkgKj0gcmV0aW5hU2NhbGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2NhbGVYID0gZmlsdGVyLnNjYWxlWDtcbiAgICAgICAgICBzY2FsZVkgPSBmaWx0ZXIuc2NhbGVZO1xuICAgICAgICB9XG4gICAgICAgIGZpbHRlci5hcHBseVRvKGNhbnZhc0VsLCBzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgIGlmICghZm9yUmVzaXppbmcgJiYgZmlsdGVyLnR5cGUgPT09ICdSZXNpemUnKSB7XG4gICAgICAgICAgX3RoaXMud2lkdGggKj0gZmlsdGVyLnNjYWxlWDtcbiAgICAgICAgICBfdGhpcy5oZWlnaHQgKj0gZmlsdGVyLnNjYWxlWTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8qKiBAaWdub3JlICovXG4gICAgICByZXBsYWNlbWVudC53aWR0aCA9IGNhbnZhc0VsLndpZHRoO1xuICAgICAgcmVwbGFjZW1lbnQuaGVpZ2h0ID0gY2FudmFzRWwuaGVpZ2h0O1xuICAgICAgaWYgKGZhYnJpYy5pc0xpa2VseU5vZGUpIHtcbiAgICAgICAgcmVwbGFjZW1lbnQuc3JjID0gY2FudmFzRWwudG9CdWZmZXIodW5kZWZpbmVkLCBmYWJyaWMuSW1hZ2UucG5nQ29tcHJlc3Npb24pO1xuICAgICAgICAvLyBvbmxvYWQgZG9lc24ndCBmaXJlIGluIHNvbWUgbm9kZSB2ZXJzaW9ucywgc28gd2UgaW52b2tlIGNhbGxiYWNrIG1hbnVhbGx5XG4gICAgICAgIF90aGlzLl9lbGVtZW50ID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICFmb3JSZXNpemluZyAmJiAoX3RoaXMuX2ZpbHRlcmVkRWwgPSByZXBsYWNlbWVudCk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKF90aGlzKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXBsYWNlbWVudC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBfdGhpcy5fZWxlbWVudCA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICFmb3JSZXNpemluZyAmJiAoX3RoaXMuX2ZpbHRlcmVkRWwgPSByZXBsYWNlbWVudCk7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soX3RoaXMpO1xuICAgICAgICAgIHJlcGxhY2VtZW50Lm9ubG9hZCA9IGNhbnZhc0VsID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgcmVwbGFjZW1lbnQuc3JjID0gY2FudmFzRWwudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYW52YXNFbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBub1RyYW5zZm9ybVxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCwgbm9UcmFuc2Zvcm0pIHtcbiAgICAgIHZhciB4LCB5LCBpbWFnZU1hcmdpbnMgPSB0aGlzLl9maW5kTWFyZ2lucygpLCBlbGVtZW50VG9EcmF3O1xuXG4gICAgICB4ID0gKG5vVHJhbnNmb3JtID8gdGhpcy5sZWZ0IDogLXRoaXMud2lkdGggLyAyKTtcbiAgICAgIHkgPSAobm9UcmFuc2Zvcm0gPyB0aGlzLnRvcCA6IC10aGlzLmhlaWdodCAvIDIpO1xuXG4gICAgICBpZiAodGhpcy5tZWV0T3JTbGljZSA9PT0gJ3NsaWNlJykge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5yZWN0KHgsIHksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNNb3ZpbmcgPT09IGZhbHNlICYmIHRoaXMucmVzaXplRmlsdGVycy5sZW5ndGggJiYgdGhpcy5fbmVlZHNSZXNpemUoKSkge1xuICAgICAgICB0aGlzLl9sYXN0U2NhbGVYID0gdGhpcy5zY2FsZVg7XG4gICAgICAgIHRoaXMuX2xhc3RTY2FsZVkgPSB0aGlzLnNjYWxlWTtcbiAgICAgICAgZWxlbWVudFRvRHJhdyA9IHRoaXMuYXBwbHlGaWx0ZXJzKG51bGwsIHRoaXMucmVzaXplRmlsdGVycywgdGhpcy5fZmlsdGVyZWRFbCB8fCB0aGlzLl9vcmlnaW5hbEVsZW1lbnQsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGVsZW1lbnRUb0RyYXcgPSB0aGlzLl9lbGVtZW50O1xuICAgICAgfVxuICAgICAgZWxlbWVudFRvRHJhdyAmJiBjdHguZHJhd0ltYWdlKGVsZW1lbnRUb0RyYXcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCArIGltYWdlTWFyZ2lucy5tYXJnaW5YLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKyBpbWFnZU1hcmdpbnMubWFyZ2luWSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU1hcmdpbnMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VNYXJnaW5zLmhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgdGhpcy5fc3Ryb2tlKGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJTdHJva2UoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGUsIG5lZWRlZCB0byBjaGVjayBpZiBpbWFnZSBuZWVkcyByZXNpemVcbiAgICAgKi9cbiAgICBfbmVlZHNSZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICh0aGlzLnNjYWxlWCAhPT0gdGhpcy5fbGFzdFNjYWxlWCB8fCB0aGlzLnNjYWxlWSAhPT0gdGhpcy5fbGFzdFNjYWxlWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbmRNYXJnaW5zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGgsIGhlaWdodCA9IHRoaXMuaGVpZ2h0LCBzY2FsZXMsXG4gICAgICAgICAgc2NhbGUsIG1hcmdpblggPSAwLCBtYXJnaW5ZID0gMDtcblxuICAgICAgaWYgKHRoaXMuYWxpZ25YICE9PSAnbm9uZScgfHwgdGhpcy5hbGlnblkgIT09ICdub25lJykge1xuICAgICAgICBzY2FsZXMgPSBbdGhpcy53aWR0aCAvIHRoaXMuX2VsZW1lbnQud2lkdGgsIHRoaXMuaGVpZ2h0IC8gdGhpcy5fZWxlbWVudC5oZWlnaHRdO1xuICAgICAgICBzY2FsZSA9IHRoaXMubWVldE9yU2xpY2UgPT09ICdtZWV0J1xuICAgICAgICAgICAgICAgID8gTWF0aC5taW4uYXBwbHkobnVsbCwgc2NhbGVzKSA6IE1hdGgubWF4LmFwcGx5KG51bGwsIHNjYWxlcyk7XG4gICAgICAgIHdpZHRoID0gdGhpcy5fZWxlbWVudC53aWR0aCAqIHNjYWxlO1xuICAgICAgICBoZWlnaHQgPSB0aGlzLl9lbGVtZW50LmhlaWdodCAqIHNjYWxlO1xuICAgICAgICBpZiAodGhpcy5hbGlnblggPT09ICdNaWQnKSB7XG4gICAgICAgICAgbWFyZ2luWCA9ICh0aGlzLndpZHRoIC0gd2lkdGgpIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbGlnblggPT09ICdNYXgnKSB7XG4gICAgICAgICAgbWFyZ2luWCA9IHRoaXMud2lkdGggLSB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbGlnblkgPT09ICdNaWQnKSB7XG4gICAgICAgICAgbWFyZ2luWSA9ICh0aGlzLmhlaWdodCAtIGhlaWdodCkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFsaWduWSA9PT0gJ01heCcpIHtcbiAgICAgICAgICBtYXJnaW5ZID0gdGhpcy5oZWlnaHQgLSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiAgd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICBtYXJnaW5YOiBtYXJnaW5YLFxuICAgICAgICBtYXJnaW5ZOiBtYXJnaW5ZXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNldFdpZHRoSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCk7XG5cbiAgICAgIHRoaXMuc2V0KCd3aWR0aCcsIGVsZW1lbnQud2lkdGgpO1xuICAgICAgdGhpcy5zZXQoJ2hlaWdodCcsIGVsZW1lbnQuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIEltYWdlIGNsYXNzJ3MgaW5pdGlhbGl6YXRpb24gbWV0aG9kLiBUaGlzIG1ldGhvZCBpcyBhdXRvbWF0aWNhbGx5XG4gICAgICogY2FsbGVkIGJ5IHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxTdHJpbmd9IGVsZW1lbnQgVGhlIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBpbWFnZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBfaW5pdEVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnNldEVsZW1lbnQoZmFicmljLnV0aWwuZ2V0QnlJZChlbGVtZW50KSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICAgICAgZmFicmljLnV0aWwuYWRkQ2xhc3ModGhpcy5nZXRFbGVtZW50KCksIGZhYnJpYy5JbWFnZS5DU1NfQ0FOVkFTKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgX2luaXRDb25maWc6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc2V0V2lkdGhIZWlnaHQob3B0aW9ucyk7XG4gICAgICBpZiAodGhpcy5fZWxlbWVudCAmJiB0aGlzLmNyb3NzT3JpZ2luKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcnMgdG8gYmUgaW5pdGlhbGl6ZWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbGwgZmFicmljLkltYWdlLmZpbHRlcnMgaW5zdGFuY2VzIGFyZSBjcmVhdGVkXG4gICAgICovXG4gICAgX2luaXRGaWx0ZXJzOiBmdW5jdGlvbihmaWx0ZXJzLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGZpbHRlcnMgJiYgZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMoZmlsdGVycywgZnVuY3Rpb24oZW5saXZlbmVkT2JqZWN0cykge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVubGl2ZW5lZE9iamVjdHMpO1xuICAgICAgICB9LCAnZmFicmljLkltYWdlLmZpbHRlcnMnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT2JqZWN0IHdpdGggd2lkdGgvaGVpZ2h0IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBfc2V0V2lkdGhIZWlnaHQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMud2lkdGggPSAnd2lkdGgnIGluIG9wdGlvbnNcbiAgICAgICAgPyBvcHRpb25zLndpZHRoXG4gICAgICAgIDogKHRoaXMuZ2V0RWxlbWVudCgpXG4gICAgICAgICAgICA/IHRoaXMuZ2V0RWxlbWVudCgpLndpZHRoIHx8IDBcbiAgICAgICAgICAgIDogMCk7XG5cbiAgICAgIHRoaXMuaGVpZ2h0ID0gJ2hlaWdodCcgaW4gb3B0aW9uc1xuICAgICAgICA/IG9wdGlvbnMuaGVpZ2h0XG4gICAgICAgIDogKHRoaXMuZ2V0RWxlbWVudCgpXG4gICAgICAgICAgICA/IHRoaXMuZ2V0RWxlbWVudCgpLmhlaWdodCB8fCAwXG4gICAgICAgICAgICA6IDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbXBsZXhpdHkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHkgb2YgdGhpcyBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbXBsZXhpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogRGVmYXVsdCBDU1MgY2xhc3MgbmFtZSBmb3IgY2FudmFzXG4gICAqIEBzdGF0aWNcbiAgICogQHR5cGUgU3RyaW5nXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuQ1NTX0NBTlZBUyA9ICdjYW52YXMtaW1nJztcblxuICAvKipcbiAgICogQWxpYXMgZm9yIGdldFNyY1xuICAgKiBAc3RhdGljXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UucHJvdG90eXBlLmdldFN2Z1NyYyA9IGZhYnJpYy5JbWFnZS5wcm90b3R5cGUuZ2V0U3JjO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZSBmcm9tIGl0cyBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBpbWFnZSBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICBmYWJyaWMudXRpbC5sb2FkSW1hZ2Uob2JqZWN0LnNyYywgZnVuY3Rpb24oaW1nKSB7XG4gICAgICBmYWJyaWMuSW1hZ2UucHJvdG90eXBlLl9pbml0RmlsdGVycy5jYWxsKG9iamVjdCwgb2JqZWN0LmZpbHRlcnMsIGZ1bmN0aW9uKGZpbHRlcnMpIHtcbiAgICAgICAgb2JqZWN0LmZpbHRlcnMgPSBmaWx0ZXJzIHx8IFtdO1xuICAgICAgICBmYWJyaWMuSW1hZ2UucHJvdG90eXBlLl9pbml0RmlsdGVycy5jYWxsKG9iamVjdCwgb2JqZWN0LnJlc2l6ZUZpbHRlcnMsIGZ1bmN0aW9uKHJlc2l6ZUZpbHRlcnMpIHtcbiAgICAgICAgICBvYmplY3QucmVzaXplRmlsdGVycyA9IHJlc2l6ZUZpbHRlcnMgfHwgW107XG4gICAgICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuSW1hZ2UoaW1nLCBvYmplY3QsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LCBudWxsLCBvYmplY3QuY3Jvc3NPcmlnaW4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZSBmcm9tIGFuIFVSTCBzdHJpbmdcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFVSTCB0byBjcmVhdGUgYW4gaW1hZ2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGltYWdlIGlzIGNyZWF0ZWQgKG5ld2x5IGNyZWF0ZWQgaW1hZ2UgaXMgcGFzc2VkIGFzIGEgZmlyc3QgYXJndW1lbnQpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbaW1nT3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5mcm9tVVJMID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaywgaW1nT3B0aW9ucykge1xuICAgIGZhYnJpYy51dGlsLmxvYWRJbWFnZSh1cmwsIGZ1bmN0aW9uKGltZykge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobmV3IGZhYnJpYy5JbWFnZShpbWcsIGltZ09wdGlvbnMpKTtcbiAgICB9LCBudWxsLCBpbWdPcHRpb25zICYmIGltZ09wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICB9O1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLkltYWdlLmZyb21FbGVtZW50fSlcbiAgICogQHN0YXRpY1xuICAgKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc3RydWN0Lmh0bWwjSW1hZ2VFbGVtZW50fVxuICAgKi9cbiAgZmFicmljLkltYWdlLkFUVFJJQlVURV9OQU1FUyA9XG4gICAgZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdCgneCB5IHdpZHRoIGhlaWdodCBwcmVzZXJ2ZUFzcGVjdFJhdGlvIHhsaW5rOmhyZWYnLnNwbGl0KCcgJykpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuSW1hZ2V9IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBleGVjdXRlIHdoZW4gZmFicmljLkltYWdlIG9iamVjdCBpcyBjcmVhdGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2VcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5JbWFnZS5BVFRSSUJVVEVfTkFNRVMpLFxuICAgICAgICBwcmVzZXJ2ZUFSO1xuXG4gICAgaWYgKHBhcnNlZEF0dHJpYnV0ZXMucHJlc2VydmVBc3BlY3RSYXRpbykge1xuICAgICAgcHJlc2VydmVBUiA9IGZhYnJpYy51dGlsLnBhcnNlUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZShwYXJzZWRBdHRyaWJ1dGVzLnByZXNlcnZlQXNwZWN0UmF0aW8pO1xuICAgICAgZXh0ZW5kKHBhcnNlZEF0dHJpYnV0ZXMsIHByZXNlcnZlQVIpO1xuICAgIH1cblxuICAgIGZhYnJpYy5JbWFnZS5mcm9tVVJMKHBhcnNlZEF0dHJpYnV0ZXNbJ3hsaW5rOmhyZWYnXSwgY2FsbGJhY2ssXG4gICAgICBleHRlbmQoKG9wdGlvbnMgPyBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUob3B0aW9ucykgOiB7IH0pLCBwYXJzZWRBdHRyaWJ1dGVzKSk7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGF0IGluc3RhbmNlcyBvZiB0aGlzIHR5cGUgYXJlIGFzeW5jXG4gICAqIEBzdGF0aWNcbiAgICogQHR5cGUgQm9vbGVhblxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgZmFicmljLkltYWdlLmFzeW5jID0gdHJ1ZTtcblxuICAvKipcbiAgICogSW5kaWNhdGVzIGNvbXByZXNzaW9uIGxldmVsIHVzZWQgd2hlbiBnZW5lcmF0aW5nIFBORyB1bmRlciBOb2RlIChpbiBhcHBseUZpbHRlcnMpLiBBbnkgb2YgMC05XG4gICAqIEBzdGF0aWNcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UucG5nQ29tcHJlc3Npb24gPSAxO1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge051bWJlcn0gYW5nbGUgdmFsdWVcbiAgICovXG4gIF9nZXRBbmdsZVZhbHVlRm9yU3RyYWlnaHRlbjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFuZ2xlID0gdGhpcy5nZXRBbmdsZSgpICUgMzYwO1xuICAgIGlmIChhbmdsZSA+IDApIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKChhbmdsZSAtIDEpIC8gOTApICogOTA7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnJvdW5kKGFuZ2xlIC8gOTApICogOTA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0cmFpZ2h0ZW5zIGFuIG9iamVjdCAocm90YXRpbmcgaXQgZnJvbSBjdXJyZW50IGFuZ2xlIHRvIG9uZSBvZiAwLCA5MCwgMTgwLCAyNzAsIGV0Yy4gZGVwZW5kaW5nIG9uIHdoaWNoIGlzIGNsb3NlcilcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBzdHJhaWdodGVuOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldEFuZ2xlKHRoaXMuX2dldEFuZ2xlVmFsdWVGb3JTdHJhaWdodGVuKCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIHtAbGluayBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5zdHJhaWdodGVufSBidXQgd2l0aCBhbmltYXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrcyBPYmplY3Qgd2l0aCBjYWxsYmFjayBmdW5jdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNvbXBsZXRlXSBJbnZva2VkIG9uIGNvbXBsZXRpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNoYW5nZV0gSW52b2tlZCBvbiBldmVyeSBzdGVwIG9mIGFuaW1hdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGZ4U3RyYWlnaHRlbjogZnVuY3Rpb24oY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzIHx8IHsgfTtcblxuICAgIHZhciBlbXB0eSA9IGZ1bmN0aW9uKCkgeyB9LFxuICAgICAgICBvbkNvbXBsZXRlID0gY2FsbGJhY2tzLm9uQ29tcGxldGUgfHwgZW1wdHksXG4gICAgICAgIG9uQ2hhbmdlID0gY2FsbGJhY2tzLm9uQ2hhbmdlIHx8IGVtcHR5LFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICBmYWJyaWMudXRpbC5hbmltYXRlKHtcbiAgICAgIHN0YXJ0VmFsdWU6IHRoaXMuZ2V0KCdhbmdsZScpLFxuICAgICAgZW5kVmFsdWU6IHRoaXMuX2dldEFuZ2xlVmFsdWVGb3JTdHJhaWdodGVuKCksXG4gICAgICBkdXJhdGlvbjogdGhpcy5GWF9EVVJBVElPTixcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBfdGhpcy5zZXRBbmdsZSh2YWx1ZSk7XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLnNldENvb3JkcygpO1xuICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICB9LFxuICAgICAgb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLnNldCgnYWN0aXZlJywgZmFsc2UpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogU3RyYWlnaHRlbnMgb2JqZWN0LCB0aGVuIHJlcmVuZGVycyBjYW52YXNcbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHN0cmFpZ2h0ZW5cbiAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBzdHJhaWdodGVuT2JqZWN0OiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgb2JqZWN0LnN0cmFpZ2h0ZW4oKTtcbiAgICB0aGlzLnJlbmRlckFsbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIHtAbGluayBmYWJyaWMuQ2FudmFzLnByb3RvdHlwZS5zdHJhaWdodGVuT2JqZWN0fSwgYnV0IGFuaW1hdGVkXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzdHJhaWdodGVuXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZnhTdHJhaWdodGVuT2JqZWN0OiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgb2JqZWN0LmZ4U3RyYWlnaHRlbih7XG4gICAgICBvbkNoYW5nZTogdGhpcy5yZW5kZXJBbGwuYmluZCh0aGlzKVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuXG4vKipcbiAqIEBuYW1lc3BhY2UgZmFicmljLkltYWdlLmZpbHRlcnNcbiAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2VcbiAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0yI2ltYWdlX2ZpbHRlcnN9XG4gKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gKi9cbmZhYnJpYy5JbWFnZS5maWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMgfHwgeyB9O1xuXG4vKipcbiAqIFJvb3QgZmlsdGVyIGNsYXNzIGZyb20gd2hpY2ggYWxsIGZpbHRlciBjbGFzc2VzIGluaGVyaXQgZnJvbVxuICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICovXG5mYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIEZpbHRlciB0eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICB0eXBlOiAnQmFzZUZpbHRlcicsXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBmaWx0ZXIncyBwcm9wZXJ0aWVzIGZyb20gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBzZXRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzW3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAqL1xuICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogdGhpcy50eXBlIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gSlNPTlxuICAgKi9cbiAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAvLyBkZWxlZ2F0ZSwgbm90IGFsaWFzXG4gICAgcmV0dXJuIHRoaXMudG9PYmplY3QoKTtcbiAgfVxufSk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEJyaWdodG5lc3MgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJyaWdodG5lc3MjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJyaWdodG5lc3Moe1xuICAgKiAgIGJyaWdodG5lc3M6IDIwMFxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICovXG4gIGZpbHRlcnMuQnJpZ2h0bmVzcyA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnQnJpZ2h0bmVzcycsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYnJpZ2h0bmVzcz0wXSBWYWx1ZSB0byBicmlnaHRlbiB0aGUgaW1hZ2UgdXAgKC0yNTUuLjI1NSlcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG4gICAgICB0aGlzLmJyaWdodG5lc3MgPSBvcHRpb25zLmJyaWdodG5lc3MgfHwgMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBmaWx0ZXIgdG8gY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICovXG4gICAgYXBwbHlUbzogZnVuY3Rpb24oY2FudmFzRWwpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXNFbC53aWR0aCwgY2FudmFzRWwuaGVpZ2h0KSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgYnJpZ2h0bmVzcyA9IHRoaXMuYnJpZ2h0bmVzcztcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgZGF0YVtpXSArPSBicmlnaHRuZXNzO1xuICAgICAgICBkYXRhW2kgKyAxXSArPSBicmlnaHRuZXNzO1xuICAgICAgICBkYXRhW2kgKyAyXSArPSBicmlnaHRuZXNzO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnKSwge1xuICAgICAgICBicmlnaHRuZXNzOiB0aGlzLmJyaWdodG5lc3NcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzc30gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzc1xuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzcy5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzKG9iamVjdCk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQWRhcHRlZCBmcm9tIDxhIGhyZWY9XCJodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9jYW52YXMvaW1hZ2VmaWx0ZXJzL1wiPmh0bWw1cm9ja3MgYXJ0aWNsZTwvYT5cbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TaGFycGVuIGZpbHRlcjwvY2FwdGlvbj5cbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUoe1xuICAgKiAgIG1hdHJpeDogWyAwLCAtMSwgIDAsXG4gICAqICAgICAgICAgICAgLTEsICA1LCAtMSxcbiAgICogICAgICAgICAgICAgMCwgLTEsICAwIF1cbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycyhjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkJsdXIgZmlsdGVyPC9jYXB0aW9uPlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZSh7XG4gICAqICAgbWF0cml4OiBbIDEvOSwgMS85LCAxLzksXG4gICAqICAgICAgICAgICAgIDEvOSwgMS85LCAxLzksXG4gICAqICAgICAgICAgICAgIDEvOSwgMS85LCAxLzkgXVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1ib3NzIGZpbHRlcjwvY2FwdGlvbj5cbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUoe1xuICAgKiAgIG1hdHJpeDogWyAxLCAgIDEsICAxLFxuICAgKiAgICAgICAgICAgICAxLCAwLjcsIC0xLFxuICAgKiAgICAgICAgICAgIC0xLCAgLTEsIC0xIF1cbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycyhjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtYm9zcyBmaWx0ZXIgd2l0aCBvcGFxdWVuZXNzPC9jYXB0aW9uPlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZSh7XG4gICAqICAgb3BhcXVlOiB0cnVlLFxuICAgKiAgIG1hdHJpeDogWyAxLCAgIDEsICAxLFxuICAgKiAgICAgICAgICAgICAxLCAwLjcsIC0xLFxuICAgKiAgICAgICAgICAgIC0xLCAgLTEsIC0xIF1cbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycyhjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAqL1xuICBmaWx0ZXJzLkNvbnZvbHV0ZSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdDb252b2x1dGUnLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm9wYXF1ZT1mYWxzZV0gT3BhcXVlIHZhbHVlICh0cnVlL2ZhbHNlKVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLm1hdHJpeF0gRmlsdGVyIG1hdHJpeFxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgfTtcblxuICAgICAgdGhpcy5vcGFxdWUgPSBvcHRpb25zLm9wYXF1ZTtcbiAgICAgIHRoaXMubWF0cml4ID0gb3B0aW9ucy5tYXRyaXggfHwgW1xuICAgICAgICAwLCAwLCAwLFxuICAgICAgICAwLCAxLCAwLFxuICAgICAgICAwLCAwLCAwXG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlciB0byBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKi9cbiAgICBhcHBseVRvOiBmdW5jdGlvbihjYW52YXNFbCkge1xuXG4gICAgICB2YXIgd2VpZ2h0cyA9IHRoaXMubWF0cml4LFxuICAgICAgICAgIGNvbnRleHQgPSBjYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICAgIHBpeGVscyA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhc0VsLndpZHRoLCBjYW52YXNFbC5oZWlnaHQpLFxuXG4gICAgICAgICAgc2lkZSA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KHdlaWdodHMubGVuZ3RoKSksXG4gICAgICAgICAgaGFsZlNpZGUgPSBNYXRoLmZsb29yKHNpZGUgLyAyKSxcbiAgICAgICAgICBzcmMgPSBwaXhlbHMuZGF0YSxcbiAgICAgICAgICBzdyA9IHBpeGVscy53aWR0aCxcbiAgICAgICAgICBzaCA9IHBpeGVscy5oZWlnaHQsXG4gICAgICAgICAgb3V0cHV0ID0gY29udGV4dC5jcmVhdGVJbWFnZURhdGEoc3csIHNoKSxcbiAgICAgICAgICBkc3QgPSBvdXRwdXQuZGF0YSxcbiAgICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBkZXN0aW5hdGlvbiBpbWFnZSBwaXhlbHNcbiAgICAgICAgICBhbHBoYUZhYyA9IHRoaXMub3BhcXVlID8gMSA6IDAsXG4gICAgICAgICAgciwgZywgYiwgYSwgZHN0T2ZmLFxuICAgICAgICAgIHNjeCwgc2N5LCBzcmNPZmYsIHd0O1xuXG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHNoOyB5KyspIHtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBzdzsgeCsrKSB7XG4gICAgICAgICAgZHN0T2ZmID0gKHkgKiBzdyArIHgpICogNDtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHdlaWdoZWQgc3VtIG9mIHRoZSBzb3VyY2UgaW1hZ2UgcGl4ZWxzIHRoYXRcbiAgICAgICAgICAvLyBmYWxsIHVuZGVyIHRoZSBjb252b2x1dGlvbiBtYXRyaXhcbiAgICAgICAgICByID0gMDsgZyA9IDA7IGIgPSAwOyBhID0gMDtcblxuICAgICAgICAgIGZvciAodmFyIGN5ID0gMDsgY3kgPCBzaWRlOyBjeSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBjeCA9IDA7IGN4IDwgc2lkZTsgY3grKykge1xuICAgICAgICAgICAgICBzY3kgPSB5ICsgY3kgLSBoYWxmU2lkZTtcbiAgICAgICAgICAgICAgc2N4ID0geCArIGN4IC0gaGFsZlNpZGU7XG5cbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxuICAgICAgICAgICAgICBpZiAoc2N5IDwgMCB8fCBzY3kgPiBzaCB8fCBzY3ggPCAwIHx8IHNjeCA+IHN3KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzcmNPZmYgPSAoc2N5ICogc3cgKyBzY3gpICogNDtcbiAgICAgICAgICAgICAgd3QgPSB3ZWlnaHRzW2N5ICogc2lkZSArIGN4XTtcblxuICAgICAgICAgICAgICByICs9IHNyY1tzcmNPZmZdICogd3Q7XG4gICAgICAgICAgICAgIGcgKz0gc3JjW3NyY09mZiArIDFdICogd3Q7XG4gICAgICAgICAgICAgIGIgKz0gc3JjW3NyY09mZiArIDJdICogd3Q7XG4gICAgICAgICAgICAgIGEgKz0gc3JjW3NyY09mZiArIDNdICogd3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGRzdFtkc3RPZmZdID0gcjtcbiAgICAgICAgICBkc3RbZHN0T2ZmICsgMV0gPSBnO1xuICAgICAgICAgIGRzdFtkc3RPZmYgKyAyXSA9IGI7XG4gICAgICAgICAgZHN0W2RzdE9mZiArIDNdID0gYSArIGFscGhhRmFjICogKDI1NSAtIGEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKG91dHB1dCwgMCwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcpLCB7XG4gICAgICAgIG9wYXF1ZTogdGhpcy5vcGFxdWUsXG4gICAgICAgIG1hdHJpeDogdGhpcy5tYXRyaXhcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGVcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUob2JqZWN0KTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBHcmFkaWVudFRyYW5zcGFyZW5jeSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYWRpZW50VHJhbnNwYXJlbmN5XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYWRpZW50VHJhbnNwYXJlbmN5I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmFkaWVudFRyYW5zcGFyZW5jeSh7XG4gICAqICAgdGhyZXNob2xkOiAyMDBcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycyhjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAqL1xuICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgZmlsdGVycy5HcmFkaWVudFRyYW5zcGFyZW5jeSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmFkaWVudFRyYW5zcGFyZW5jeS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0dyYWRpZW50VHJhbnNwYXJlbmN5JyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYWRpZW50VHJhbnNwYXJlbmN5LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGhyZXNob2xkPTEwMF0gVGhyZXNob2xkIHZhbHVlXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuICAgICAgdGhpcy50aHJlc2hvbGQgPSBvcHRpb25zLnRocmVzaG9sZCB8fCAxMDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZmlsdGVyIHRvIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqL1xuICAgIGFwcGx5VG86IGZ1bmN0aW9uKGNhbnZhc0VsKSB7XG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhc0VsLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzRWwud2lkdGgsIGNhbnZhc0VsLmhlaWdodCksXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgIHRocmVzaG9sZCA9IHRoaXMudGhyZXNob2xkLFxuICAgICAgICAgIHRvdGFsID0gZGF0YS5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGRhdGFbaSArIDNdID0gdGhyZXNob2xkICsgMjU1ICogKHRvdGFsIC0gaSkgLyB0b3RhbDtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JyksIHtcbiAgICAgICAgdGhyZXNob2xkOiB0aGlzLnRocmVzaG9sZFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmFkaWVudFRyYW5zcGFyZW5jeX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuR3JhZGllbnRUcmFuc3BhcmVuY3lcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYWRpZW50VHJhbnNwYXJlbmN5LmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYWRpZW50VHJhbnNwYXJlbmN5KG9iamVjdCk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBHcmF5c2NhbGUgaW1hZ2UgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGVcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYXlzY2FsZSgpO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgKi9cbiAgZmlsdGVycy5HcmF5c2NhbGUgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuR3JheXNjYWxlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnR3JheXNjYWxlJyxcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZmlsdGVyIHRvIGNhbnZhcyBlbGVtZW50XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYXlzY2FsZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICovXG4gICAgYXBwbHlUbzogZnVuY3Rpb24oY2FudmFzRWwpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXNFbC53aWR0aCwgY2FudmFzRWwuaGVpZ2h0KSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgbGVuID0gaW1hZ2VEYXRhLndpZHRoICogaW1hZ2VEYXRhLmhlaWdodCAqIDQsXG4gICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgIGF2ZXJhZ2U7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbikge1xuICAgICAgICBhdmVyYWdlID0gKGRhdGFbaW5kZXhdICsgZGF0YVtpbmRleCArIDFdICsgZGF0YVtpbmRleCArIDJdKSAvIDM7XG4gICAgICAgIGRhdGFbaW5kZXhdICAgICA9IGF2ZXJhZ2U7XG4gICAgICAgIGRhdGFbaW5kZXggKyAxXSA9IGF2ZXJhZ2U7XG4gICAgICAgIGRhdGFbaW5kZXggKyAyXSA9IGF2ZXJhZ2U7XG4gICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGV9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYXlzY2FsZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuR3JheXNjYWxlLmZyb21PYmplY3QgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYXlzY2FsZSgpO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogSW52ZXJ0IGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuSW52ZXJ0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5JbnZlcnQoKTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICovXG4gIGZpbHRlcnMuSW52ZXJ0ID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkludmVydC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0ludmVydCcsXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlciB0byBjYW52YXMgZWxlbWVudFxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5JbnZlcnQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqL1xuICAgIGFwcGx5VG86IGZ1bmN0aW9uKGNhbnZhc0VsKSB7XG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhc0VsLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzRWwud2lkdGgsIGNhbnZhc0VsLmhlaWdodCksXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgIGlMZW4gPSBkYXRhLmxlbmd0aCwgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGlMZW47IGkgKz0gNCkge1xuICAgICAgICBkYXRhW2ldID0gMjU1IC0gZGF0YVtpXTtcbiAgICAgICAgZGF0YVtpICsgMV0gPSAyNTUgLSBkYXRhW2kgKyAxXTtcbiAgICAgICAgZGF0YVtpICsgMl0gPSAyNTUgLSBkYXRhW2kgKyAyXTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkludmVydH0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuSW52ZXJ0XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5JbnZlcnQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuSW52ZXJ0KCk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogTWFzayBmaWx0ZXIgY2xhc3NcbiAgICogU2VlIGh0dHA6Ly9yZXNvdXJjZXMuYWxlcGgtMS5jb20vbWFzay9cbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk1hc2tcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuTWFzayNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmlsdGVycy5NYXNrID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk1hc2sucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdNYXNrJyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk1hc2sucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLkltYWdlfSBbb3B0aW9ucy5tYXNrXSBNYXNrIGltYWdlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jaGFubmVsPTBdIFJnYiBjaGFubmVsICgwLCAxLCAyIG9yIDMpXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuXG4gICAgICB0aGlzLm1hc2sgPSBvcHRpb25zLm1hc2s7XG4gICAgICB0aGlzLmNoYW5uZWwgPSBbMCwgMSwgMiwgM10uaW5kZXhPZihvcHRpb25zLmNoYW5uZWwpID4gLTEgPyBvcHRpb25zLmNoYW5uZWwgOiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlciB0byBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKi9cbiAgICBhcHBseVRvOiBmdW5jdGlvbihjYW52YXNFbCkge1xuICAgICAgaWYgKCF0aGlzLm1hc2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhc0VsLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzRWwud2lkdGgsIGNhbnZhc0VsLmhlaWdodCksXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgIG1hc2tFbCA9IHRoaXMubWFzay5nZXRFbGVtZW50KCksXG4gICAgICAgICAgbWFza0NhbnZhc0VsID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLFxuICAgICAgICAgIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWwsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBpTGVuID0gaW1hZ2VEYXRhLndpZHRoICogaW1hZ2VEYXRhLmhlaWdodCAqIDQ7XG5cbiAgICAgIG1hc2tDYW52YXNFbC53aWR0aCA9IGNhbnZhc0VsLndpZHRoO1xuICAgICAgbWFza0NhbnZhc0VsLmhlaWdodCA9IGNhbnZhc0VsLmhlaWdodDtcblxuICAgICAgbWFza0NhbnZhc0VsLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKG1hc2tFbCwgMCwgMCwgY2FudmFzRWwud2lkdGgsIGNhbnZhc0VsLmhlaWdodCk7XG5cbiAgICAgIHZhciBtYXNrSW1hZ2VEYXRhID0gbWFza0NhbnZhc0VsLmdldENvbnRleHQoJzJkJykuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhc0VsLndpZHRoLCBjYW52YXNFbC5oZWlnaHQpLFxuICAgICAgICAgIG1hc2tEYXRhID0gbWFza0ltYWdlRGF0YS5kYXRhO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaUxlbjsgaSArPSA0KSB7XG4gICAgICAgIGRhdGFbaSArIDNdID0gbWFza0RhdGFbaSArIGNoYW5uZWxdO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnKSwge1xuICAgICAgICBtYXNrOiB0aGlzLm1hc2sudG9PYmplY3QoKSxcbiAgICAgICAgY2hhbm5lbDogdGhpcy5jaGFubmVsXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYSBtYXNrIGZpbHRlciBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5NYXNrLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgZmFicmljLnV0aWwubG9hZEltYWdlKG9iamVjdC5tYXNrLnNyYywgZnVuY3Rpb24oaW1nKSB7XG4gICAgICBvYmplY3QubWFzayA9IG5ldyBmYWJyaWMuSW1hZ2UoaW1nLCBvYmplY3QubWFzayk7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuTWFzayhvYmplY3QpKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogSW5kaWNhdGVzIHRoYXQgaW5zdGFuY2VzIG9mIHRoaXMgdHlwZSBhcmUgYXN5bmNcbiAgICogQHN0YXRpY1xuICAgKiBAdHlwZSBCb29sZWFuXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5NYXNrLmFzeW5jID0gdHJ1ZTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBOb2lzZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZSh7XG4gICAqICAgbm9pc2U6IDcwMFxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICovXG4gIGZpbHRlcnMuTm9pc2UgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2UucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdOb2lzZScsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm5vaXNlPTBdIE5vaXNlIHZhbHVlXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuICAgICAgdGhpcy5ub2lzZSA9IG9wdGlvbnMubm9pc2UgfHwgMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBmaWx0ZXIgdG8gY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICovXG4gICAgYXBwbHlUbzogZnVuY3Rpb24oY2FudmFzRWwpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXNFbC53aWR0aCwgY2FudmFzRWwuaGVpZ2h0KSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgbm9pc2UgPSB0aGlzLm5vaXNlLCByYW5kO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gNCkge1xuXG4gICAgICAgIHJhbmQgPSAoMC41IC0gTWF0aC5yYW5kb20oKSkgKiBub2lzZTtcblxuICAgICAgICBkYXRhW2ldICs9IHJhbmQ7XG4gICAgICAgIGRhdGFbaSArIDFdICs9IHJhbmQ7XG4gICAgICAgIGRhdGFbaSArIDJdICs9IHJhbmQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcpLCB7XG4gICAgICAgIG5vaXNlOiB0aGlzLm5vaXNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2UuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2Uob2JqZWN0KTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBQaXhlbGF0ZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZSh7XG4gICAqICAgYmxvY2tzaXplOiA4XG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgKi9cbiAgZmlsdGVycy5QaXhlbGF0ZSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ1BpeGVsYXRlJyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYmxvY2tzaXplPTRdIEJsb2Nrc2l6ZSBmb3IgcGl4ZWxhdGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG4gICAgICB0aGlzLmJsb2Nrc2l6ZSA9IG9wdGlvbnMuYmxvY2tzaXplIHx8IDQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZmlsdGVyIHRvIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqL1xuICAgIGFwcGx5VG86IGZ1bmN0aW9uKGNhbnZhc0VsKSB7XG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhc0VsLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzRWwud2lkdGgsIGNhbnZhc0VsLmhlaWdodCksXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgIGlMZW4gPSBpbWFnZURhdGEuaGVpZ2h0LFxuICAgICAgICAgIGpMZW4gPSBpbWFnZURhdGEud2lkdGgsXG4gICAgICAgICAgaW5kZXgsIGksIGosIHIsIGcsIGIsIGE7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpTGVuOyBpICs9IHRoaXMuYmxvY2tzaXplKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IHRoaXMuYmxvY2tzaXplKSB7XG5cbiAgICAgICAgICBpbmRleCA9IChpICogNCkgKiBqTGVuICsgKGogKiA0KTtcblxuICAgICAgICAgIHIgPSBkYXRhW2luZGV4XTtcbiAgICAgICAgICBnID0gZGF0YVtpbmRleCArIDFdO1xuICAgICAgICAgIGIgPSBkYXRhW2luZGV4ICsgMl07XG4gICAgICAgICAgYSA9IGRhdGFbaW5kZXggKyAzXTtcblxuICAgICAgICAgIC8qXG4gICAgICAgICAgIGJsb2Nrc2l6ZTogNFxuXG4gICAgICAgICAgIFsxLHgseCx4LDFdXG4gICAgICAgICAgIFt4LHgseCx4LDFdXG4gICAgICAgICAgIFt4LHgseCx4LDFdXG4gICAgICAgICAgIFt4LHgseCx4LDFdXG4gICAgICAgICAgIFsxLDEsMSwxLDFdXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBmb3IgKHZhciBfaSA9IGksIF9pbGVuID0gaSArIHRoaXMuYmxvY2tzaXplOyBfaSA8IF9pbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaiA9IGosIF9qbGVuID0gaiArIHRoaXMuYmxvY2tzaXplOyBfaiA8IF9qbGVuOyBfaisrKSB7XG4gICAgICAgICAgICAgIGluZGV4ID0gKF9pICogNCkgKiBqTGVuICsgKF9qICogNCk7XG4gICAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gcjtcbiAgICAgICAgICAgICAgZGF0YVtpbmRleCArIDFdID0gZztcbiAgICAgICAgICAgICAgZGF0YVtpbmRleCArIDJdID0gYjtcbiAgICAgICAgICAgICAgZGF0YVtpbmRleCArIDNdID0gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JyksIHtcbiAgICAgICAgYmxvY2tzaXplOiB0aGlzLmJsb2Nrc2l6ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGVcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlKG9iamVjdCk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogUmVtb3ZlIHdoaXRlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlV2hpdGVcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlV2hpdGUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZVdoaXRlKHtcbiAgICogICB0aHJlc2hvbGQ6IDQwLFxuICAgKiAgIGRpc3RhbmNlOiAxNDBcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycyhjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAqL1xuICBmaWx0ZXJzLlJlbW92ZVdoaXRlID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZVdoaXRlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnUmVtb3ZlV2hpdGUnLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlV2hpdGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50aHJlc2hvbGQ9MzBdIFRocmVzaG9sZCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kaXN0YW5jZT0yMF0gRGlzdGFuY2UgdmFsdWVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG4gICAgICB0aGlzLnRocmVzaG9sZCA9IG9wdGlvbnMudGhyZXNob2xkIHx8IDMwO1xuICAgICAgdGhpcy5kaXN0YW5jZSA9IG9wdGlvbnMuZGlzdGFuY2UgfHwgMjA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZmlsdGVyIHRvIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqL1xuICAgIGFwcGx5VG86IGZ1bmN0aW9uKGNhbnZhc0VsKSB7XG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhc0VsLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzRWwud2lkdGgsIGNhbnZhc0VsLmhlaWdodCksXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgIHRocmVzaG9sZCA9IHRoaXMudGhyZXNob2xkLFxuICAgICAgICAgIGRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZSxcbiAgICAgICAgICBsaW1pdCA9IDI1NSAtIHRocmVzaG9sZCxcbiAgICAgICAgICBhYnMgPSBNYXRoLmFicyxcbiAgICAgICAgICByLCBnLCBiO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICByID0gZGF0YVtpXTtcbiAgICAgICAgZyA9IGRhdGFbaSArIDFdO1xuICAgICAgICBiID0gZGF0YVtpICsgMl07XG5cbiAgICAgICAgaWYgKHIgPiBsaW1pdCAmJlxuICAgICAgICAgICAgZyA+IGxpbWl0ICYmXG4gICAgICAgICAgICBiID4gbGltaXQgJiZcbiAgICAgICAgICAgIGFicyhyIC0gZykgPCBkaXN0YW5jZSAmJlxuICAgICAgICAgICAgYWJzKHIgLSBiKSA8IGRpc3RhbmNlICYmXG4gICAgICAgICAgICBhYnMoZyAtIGIpIDwgZGlzdGFuY2VcbiAgICAgICAgKSB7XG4gICAgICAgICAgZGF0YVtpICsgM10gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcpLCB7XG4gICAgICAgIHRocmVzaG9sZDogdGhpcy50aHJlc2hvbGQsXG4gICAgICAgIGRpc3RhbmNlOiB0aGlzLmRpc3RhbmNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZVdoaXRlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVXaGl0ZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlV2hpdGUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlV2hpdGUob2JqZWN0KTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIFNlcGlhIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuU2VwaWFcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNlcGlhKCk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycyhjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAqL1xuICBmaWx0ZXJzLlNlcGlhID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNlcGlhLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnU2VwaWEnLFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBmaWx0ZXIgdG8gY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuU2VwaWEucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqL1xuICAgIGFwcGx5VG86IGZ1bmN0aW9uKGNhbnZhc0VsKSB7XG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhc0VsLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzRWwud2lkdGgsIGNhbnZhc0VsLmhlaWdodCksXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgIGlMZW4gPSBkYXRhLmxlbmd0aCwgaSwgYXZnO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaUxlbjsgaSArPSA0KSB7XG4gICAgICAgIGF2ZyA9IDAuMyAgKiBkYXRhW2ldICsgMC41OSAqIGRhdGFbaSArIDFdICsgMC4xMSAqIGRhdGFbaSArIDJdO1xuICAgICAgICBkYXRhW2ldID0gYXZnICsgMTAwO1xuICAgICAgICBkYXRhW2kgKyAxXSA9IGF2ZyArIDUwO1xuICAgICAgICBkYXRhW2kgKyAyXSA9IGF2ZyArIDI1NTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLlNlcGlhfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TZXBpYVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuU2VwaWEuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuU2VwaWEoKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIFNlcGlhMiBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNlcGlhMlxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuU2VwaWEyKCk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycyhjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAqL1xuICBmaWx0ZXJzLlNlcGlhMiA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TZXBpYTIucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdTZXBpYTInLFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBmaWx0ZXIgdG8gY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuU2VwaWEucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqL1xuICAgIGFwcGx5VG86IGZ1bmN0aW9uKGNhbnZhc0VsKSB7XG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhc0VsLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzRWwud2lkdGgsIGNhbnZhc0VsLmhlaWdodCksXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgIGlMZW4gPSBkYXRhLmxlbmd0aCwgaSwgciwgZywgYjtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGlMZW47IGkgKz0gNCkge1xuICAgICAgICByID0gZGF0YVtpXTtcbiAgICAgICAgZyA9IGRhdGFbaSArIDFdO1xuICAgICAgICBiID0gZGF0YVtpICsgMl07XG5cbiAgICAgICAgZGF0YVtpXSA9IChyICogMC4zOTMgKyBnICogMC43NjkgKyBiICogMC4xODkgKSAvIDEuMzUxO1xuICAgICAgICBkYXRhW2kgKyAxXSA9IChyICogMC4zNDkgKyBnICogMC42ODYgKyBiICogMC4xNjggKSAvIDEuMjAzO1xuICAgICAgICBkYXRhW2kgKyAyXSA9IChyICogMC4yNzIgKyBnICogMC41MzQgKyBiICogMC4xMzEgKSAvIDIuMTQwO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuU2VwaWEyfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TZXBpYTJcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNlcGlhMi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TZXBpYTIoKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBUaW50IGZpbHRlciBjbGFzc1xuICAgKiBBZGFwdGVkIGZyb20gPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9tZXp6b2JsdWUvUGFpbnRicnVzaEpTXCI+aHR0cHM6Ly9naXRodWIuY29tL21lenpvYmx1ZS9QYWludGJydXNoSlM8L2E+XG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5UaW50XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlRpbnQjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5UaW50IGZpbHRlciB3aXRoIGhleCBjb2xvciBhbmQgb3BhY2l0eTwvY2FwdGlvbj5cbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5UaW50KHtcbiAgICogICBjb2xvcjogJyMzNTEzQjAnLFxuICAgKiAgIG9wYWNpdHk6IDAuNVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+VGludCBmaWx0ZXIgd2l0aCByZ2JhIGNvbG9yPC9jYXB0aW9uPlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLlRpbnQoe1xuICAgKiAgIGNvbG9yOiAncmdiYSg1MywgMjEsIDE3NiwgMC41KSdcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycyhjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAqL1xuICBmaWx0ZXJzLlRpbnQgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuVGludC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ1RpbnQnLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuVGludC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNvbG9yPSMwMDAwMDBdIENvbG9yIHRvIHRpbnQgdGhlIGltYWdlIHdpdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub3BhY2l0eV0gT3BhY2l0eSB2YWx1ZSB0aGF0IGNvbnRyb2xzIHRoZSB0aW50IGVmZmVjdCdzIHRyYW5zcGFyZW5jeSAoMC4uMSlcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG5cbiAgICAgIHRoaXMuY29sb3IgPSBvcHRpb25zLmNvbG9yIHx8ICcjMDAwMDAwJztcbiAgICAgIHRoaXMub3BhY2l0eSA9IHR5cGVvZiBvcHRpb25zLm9wYWNpdHkgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLm9wYWNpdHlcbiAgICAgICAgICAgICAgICAgICAgICA6IG5ldyBmYWJyaWMuQ29sb3IodGhpcy5jb2xvcikuZ2V0QWxwaGEoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBmaWx0ZXIgdG8gY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICovXG4gICAgYXBwbHlUbzogZnVuY3Rpb24oY2FudmFzRWwpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXNFbC53aWR0aCwgY2FudmFzRWwuaGVpZ2h0KSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgaUxlbiA9IGRhdGEubGVuZ3RoLCBpLFxuICAgICAgICAgIHRpbnRSLCB0aW50RywgdGludEIsXG4gICAgICAgICAgciwgZywgYiwgYWxwaGExLFxuICAgICAgICAgIHNvdXJjZTtcblxuICAgICAgc291cmNlID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKS5nZXRTb3VyY2UoKTtcblxuICAgICAgdGludFIgPSBzb3VyY2VbMF0gKiB0aGlzLm9wYWNpdHk7XG4gICAgICB0aW50RyA9IHNvdXJjZVsxXSAqIHRoaXMub3BhY2l0eTtcbiAgICAgIHRpbnRCID0gc291cmNlWzJdICogdGhpcy5vcGFjaXR5O1xuXG4gICAgICBhbHBoYTEgPSAxIC0gdGhpcy5vcGFjaXR5O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaUxlbjsgaSArPSA0KSB7XG4gICAgICAgIHIgPSBkYXRhW2ldO1xuICAgICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICAgIGIgPSBkYXRhW2kgKyAyXTtcblxuICAgICAgICAvLyBhbHBoYSBjb21wb3NpdGluZ1xuICAgICAgICBkYXRhW2ldID0gdGludFIgKyByICogYWxwaGExO1xuICAgICAgICBkYXRhW2kgKyAxXSA9IHRpbnRHICsgZyAqIGFscGhhMTtcbiAgICAgICAgZGF0YVtpICsgMl0gPSB0aW50QiArIGIgKiBhbHBoYTE7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcpLCB7XG4gICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICBvcGFjaXR5OiB0aGlzLm9wYWNpdHlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuVGludH0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuVGludFxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuVGludC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5UaW50KG9iamVjdCk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogTXVsdGlwbHkgZmlsdGVyIGNsYXNzXG4gICAqIEFkYXB0ZWQgZnJvbSA8YSBocmVmPVwiaHR0cDovL3d3dy5sYXVyZW5zY29yaWpuLmNvbS9hcnRpY2xlcy9jb2xvcm1hdGgtYmFzaWNzXCI+aHR0cDovL3d3dy5sYXVyZW5zY29yaWpuLmNvbS9hcnRpY2xlcy9jb2xvcm1hdGgtYmFzaWNzPC9hPlxuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuTXVsdGlwbHlcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+TXVsdGlwbHkgZmlsdGVyIHdpdGggaGV4IGNvbG9yPC9jYXB0aW9uPlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLk11bHRpcGx5KHtcbiAgICogICBjb2xvcjogJyNGMEYnXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5NdWx0aXBseSBmaWx0ZXIgd2l0aCByZ2IgY29sb3I8L2NhcHRpb24+XG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuTXVsdGlwbHkoe1xuICAgKiAgIGNvbG9yOiAncmdiKDUzLCAyMSwgMTc2KSdcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycyhjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAqL1xuICBmaWx0ZXJzLk11bHRpcGx5ID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk11bHRpcGx5LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnTXVsdGlwbHknLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuTXVsdGlwbHkucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jb2xvcj0jMDAwMDAwXSBDb2xvciB0byBtdWx0aXBseSB0aGUgaW1hZ2UgcGl4ZWxzIHdpdGhcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG5cbiAgICAgIHRoaXMuY29sb3IgPSBvcHRpb25zLmNvbG9yIHx8ICcjMDAwMDAwJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBmaWx0ZXIgdG8gY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICovXG4gICAgYXBwbHlUbzogZnVuY3Rpb24oY2FudmFzRWwpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXNFbC53aWR0aCwgY2FudmFzRWwuaGVpZ2h0KSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgaUxlbiA9IGRhdGEubGVuZ3RoLCBpLFxuICAgICAgICAgIHNvdXJjZTtcblxuICAgICAgc291cmNlID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKS5nZXRTb3VyY2UoKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGlMZW47IGkgKz0gNCkge1xuICAgICAgICBkYXRhW2ldICo9IHNvdXJjZVswXSAvIDI1NTtcbiAgICAgICAgZGF0YVtpICsgMV0gKj0gc291cmNlWzFdIC8gMjU1O1xuICAgICAgICBkYXRhW2kgKyAyXSAqPSBzb3VyY2VbMl0gLyAyNTU7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcpLCB7XG4gICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLk11bHRpcGx5fSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5NdWx0aXBseVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuTXVsdGlwbHkuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuTXVsdGlwbHkob2JqZWN0KTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQ29sb3IgQmxlbmQgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVyLkJsZW5kXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmQoe1xuICAgKiAgY29sb3I6ICcjMDAwJyxcbiAgICogIG1vZGU6ICdtdWx0aXBseSdcbiAgICogfSk7XG4gICAqXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmQoe1xuICAgKiAgaW1hZ2U6IGZhYnJpY0ltYWdlT2JqZWN0LFxuICAgKiAgbW9kZTogJ211bHRpcGx5JyxcbiAgICogIGFscGhhOiAwLjVcbiAgICogfSk7XG5cbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICovXG5cbiAgZmlsdGVycy5CbGVuZCA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZC5wcm90b3R5cGUgKi8ge1xuICAgIHR5cGU6ICdCbGVuZCcsXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHRoaXMuY29sb3IgPSBvcHRpb25zLmNvbG9yIHx8ICcjMDAwJztcbiAgICAgIHRoaXMuaW1hZ2UgPSBvcHRpb25zLmltYWdlIHx8IGZhbHNlO1xuICAgICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8ICdtdWx0aXBseSc7XG4gICAgICB0aGlzLmFscGhhID0gb3B0aW9ucy5hbHBoYSB8fCAxO1xuICAgIH0sXG5cbiAgICBhcHBseVRvOiBmdW5jdGlvbihjYW52YXNFbCkge1xuICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICAgIGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhc0VsLndpZHRoLCBjYW52YXNFbC5oZWlnaHQpLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICB0ciwgdGcsIHRiLFxuICAgICAgICAgIHIsIGcsIGIsXG4gICAgICAgICAgX3IsIF9nLCBfYixcbiAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgaXNJbWFnZSA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5pbWFnZSkge1xuICAgICAgICAvLyBCbGVuZCBpbWFnZXNcbiAgICAgICAgaXNJbWFnZSA9IHRydWU7XG5cbiAgICAgICAgdmFyIF9lbCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgICAgX2VsLndpZHRoID0gdGhpcy5pbWFnZS53aWR0aDtcbiAgICAgICAgX2VsLmhlaWdodCA9IHRoaXMuaW1hZ2UuaGVpZ2h0O1xuXG4gICAgICAgIHZhciB0bXBDYW52YXMgPSBuZXcgZmFicmljLlN0YXRpY0NhbnZhcyhfZWwpO1xuICAgICAgICB0bXBDYW52YXMuYWRkKHRoaXMuaW1hZ2UpO1xuICAgICAgICB2YXIgY29udGV4dDIgPSAgdG1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHNvdXJjZSA9IGNvbnRleHQyLmdldEltYWdlRGF0YSgwLCAwLCB0bXBDYW52YXMud2lkdGgsIHRtcENhbnZhcy5oZWlnaHQpLmRhdGE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gQmxlbmQgY29sb3JcbiAgICAgICAgc291cmNlID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKS5nZXRTb3VyY2UoKTtcblxuICAgICAgICB0ciA9IHNvdXJjZVswXSAqIHRoaXMuYWxwaGE7XG4gICAgICAgIHRnID0gc291cmNlWzFdICogdGhpcy5hbHBoYTtcbiAgICAgICAgdGIgPSBzb3VyY2VbMl0gKiB0aGlzLmFscGhhO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gNCkge1xuXG4gICAgICAgIHIgPSBkYXRhW2ldO1xuICAgICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICAgIGIgPSBkYXRhW2kgKyAyXTtcblxuICAgICAgICBpZiAoaXNJbWFnZSkge1xuICAgICAgICAgIHRyID0gc291cmNlW2ldICogdGhpcy5hbHBoYTtcbiAgICAgICAgICB0ZyA9IHNvdXJjZVtpICsgMV0gKiB0aGlzLmFscGhhO1xuICAgICAgICAgIHRiID0gc291cmNlW2kgKyAyXSAqIHRoaXMuYWxwaGE7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgICAgICAgIGNhc2UgJ211bHRpcGx5JzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSByICogdHIgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IGcgKiB0ZyAvIDI1NTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gYiAqIHRiIC8gMjU1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2NyZWVuJzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSAxIC0gKDEgLSByKSAqICgxIC0gdHIpO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSAxIC0gKDEgLSBnKSAqICgxIC0gdGcpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSAxIC0gKDEgLSBiKSAqICgxIC0gdGIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSBNYXRoLm1pbigyNTUsIHIgKyB0cik7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IE1hdGgubWluKDI1NSwgZyArIHRnKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gTWF0aC5taW4oMjU1LCBiICsgdGIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZGlmZic6XG4gICAgICAgICAgY2FzZSAnZGlmZmVyZW5jZSc6XG4gICAgICAgICAgICBkYXRhW2ldID0gTWF0aC5hYnMociAtIHRyKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gTWF0aC5hYnMoZyAtIHRnKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gTWF0aC5hYnMoYiAtIHRiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3N1YnRyYWN0JzpcbiAgICAgICAgICAgIF9yID0gciAtIHRyO1xuICAgICAgICAgICAgX2cgPSBnIC0gdGc7XG4gICAgICAgICAgICBfYiA9IGIgLSB0YjtcblxuICAgICAgICAgICAgZGF0YVtpXSA9IChfciA8IDApID8gMCA6IF9yO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSAoX2cgPCAwKSA/IDAgOiBfZztcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gKF9iIDwgMCkgPyAwIDogX2I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdkYXJrZW4nOlxuICAgICAgICAgICAgZGF0YVtpXSA9IE1hdGgubWluKHIsIHRyKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gTWF0aC5taW4oZywgdGcpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBNYXRoLm1pbihiLCB0Yik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdsaWdodGVuJzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSBNYXRoLm1heChyLCB0cik7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IE1hdGgubWF4KGcsIHRnKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gTWF0aC5tYXgoYiwgdGIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICBpbWFnZTogdGhpcy5pbWFnZSxcbiAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICBhbHBoYTogdGhpcy5hbHBoYVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kKG9iamVjdCk7XG4gIH07XG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLCBwb3cgPSBNYXRoLnBvdywgZmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgc3FydCA9IE1hdGguc3FydCwgYWJzID0gTWF0aC5hYnMsIG1heCA9IE1hdGgubWF4LCByb3VuZCA9IE1hdGgucm91bmQsIHNpbiA9IE1hdGguc2luLFxuICAgICAgY2VpbCA9IE1hdGguY2VpbCxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIFJlc2l6ZSBpbWFnZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplKCk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycyhjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAqL1xuICBmaWx0ZXJzLlJlc2l6ZSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdSZXNpemUnLFxuXG4gICAgLyoqXG4gICAgICogUmVzaXplIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVzaXplVHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcmVzaXplVHlwZTogJ2hlcm1pdGUnLFxuXG4gICAgLyoqXG4gICAgICogU2NhbGUgZmFjdG9yIGZvciByZXNpemluZywgeCBheGlzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2NhbGVYOiAwLFxuXG4gICAgLyoqXG4gICAgICogU2NhbGUgZmFjdG9yIGZvciByZXNpemluZywgeSBheGlzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2NhbGVZOiAwLFxuXG4gICAgLyoqXG4gICAgICogTGFuY3pvc0xvYmVzIHBhcmFtZXRlciBmb3IgbGFuY3pvcyBmaWx0ZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGFuY3pvc0xvYmVzXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsYW5jem9zTG9iZXM6IDMsXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlciB0byBjYW52YXMgZWxlbWVudFxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVZXG4gICAgICovXG4gICAgYXBwbHlUbzogZnVuY3Rpb24oY2FudmFzRWwsIHNjYWxlWCwgc2NhbGVZKSB7XG4gICAgICBpZiAoc2NhbGVYID09PSAxICYmIHNjYWxlWSA9PT0gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmNwU2NhbGVYID0gMSAvIHNjYWxlWDtcbiAgICAgIHRoaXMucmNwU2NhbGVZID0gMSAvIHNjYWxlWTtcblxuICAgICAgdmFyIG9XID0gY2FudmFzRWwud2lkdGgsIG9IID0gY2FudmFzRWwuaGVpZ2h0LFxuICAgICAgICAgIGRXID0gcm91bmQob1cgKiBzY2FsZVgpLCBkSCA9IHJvdW5kKG9IICogc2NhbGVZKSxcbiAgICAgICAgICBpbWFnZURhdGE7XG5cbiAgICAgIGlmICh0aGlzLnJlc2l6ZVR5cGUgPT09ICdzbGljZUhhY2snKSB7XG4gICAgICAgIGltYWdlRGF0YSA9IHRoaXMuc2xpY2VCeVR3byhjYW52YXNFbCwgb1csIG9ILCBkVywgZEgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmVzaXplVHlwZSA9PT0gJ2hlcm1pdGUnKSB7XG4gICAgICAgIGltYWdlRGF0YSA9IHRoaXMuaGVybWl0ZUZhc3RSZXNpemUoY2FudmFzRWwsIG9XLCBvSCwgZFcsIGRIKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJlc2l6ZVR5cGUgPT09ICdiaWxpbmVhcicpIHtcbiAgICAgICAgaW1hZ2VEYXRhID0gdGhpcy5iaWxpbmVhckZpbHRlcmluZyhjYW52YXNFbCwgb1csIG9ILCBkVywgZEgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmVzaXplVHlwZSA9PT0gJ2xhbmN6b3MnKSB7XG4gICAgICAgIGltYWdlRGF0YSA9IHRoaXMubGFuY3pvc1Jlc2l6ZShjYW52YXNFbCwgb1csIG9ILCBkVywgZEgpO1xuICAgICAgfVxuICAgICAgY2FudmFzRWwud2lkdGggPSBkVztcbiAgICAgIGNhbnZhc0VsLmhlaWdodCA9IGRIO1xuICAgICAgY2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKS5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHNsaWNlQnlUd29cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9XIE9yaWdpbmFsIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9IIE9yaWdpbmFsIEhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkVyBEZXN0aW5hdGlvbiBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkSCBEZXN0aW5hdGlvbiBIZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2VEYXRhfVxuICAgICAqL1xuICAgIHNsaWNlQnlUd286IGZ1bmN0aW9uKGNhbnZhc0VsLCBvVywgb0gsIGRXLCBkSCkge1xuICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpLCBpbWFnZURhdGEsXG4gICAgICAgICAgbXVsdFcgPSAwLjUsIG11bHRIID0gMC41LCBzaWduVyA9IDEsIHNpZ25IID0gMSxcbiAgICAgICAgICBkb25lVyA9IGZhbHNlLCBkb25lSCA9IGZhbHNlLCBzdGVwVyA9IG9XLCBzdGVwSCA9IG9ILFxuICAgICAgICAgIHRtcENhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKSxcbiAgICAgICAgICB0bXBDdHggPSB0bXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGRXID0gZmxvb3IoZFcpO1xuICAgICAgZEggPSBmbG9vcihkSCk7XG4gICAgICB0bXBDYW52YXMud2lkdGggPSBtYXgoZFcsIG9XKTtcbiAgICAgIHRtcENhbnZhcy5oZWlnaHQgPSBtYXgoZEgsIG9IKTtcblxuICAgICAgaWYgKGRXID4gb1cpIHtcbiAgICAgICAgbXVsdFcgPSAyO1xuICAgICAgICBzaWduVyA9IC0xO1xuICAgICAgfVxuICAgICAgaWYgKGRIID4gb0gpIHtcbiAgICAgICAgbXVsdEggPSAyO1xuICAgICAgICBzaWduSCA9IC0xO1xuICAgICAgfVxuICAgICAgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgb1csIG9IKTtcbiAgICAgIGNhbnZhc0VsLndpZHRoID0gbWF4KGRXLCBvVyk7XG4gICAgICBjYW52YXNFbC5oZWlnaHQgPSBtYXgoZEgsIG9IKTtcbiAgICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG5cbiAgICAgIHdoaWxlICghZG9uZVcgfHwgIWRvbmVIKSB7XG4gICAgICAgIG9XID0gc3RlcFc7XG4gICAgICAgIG9IID0gc3RlcEg7XG4gICAgICAgIGlmIChkVyAqIHNpZ25XIDwgZmxvb3Ioc3RlcFcgKiBtdWx0VyAqIHNpZ25XKSkge1xuICAgICAgICAgIHN0ZXBXID0gZmxvb3Ioc3RlcFcgKiBtdWx0Vyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3RlcFcgPSBkVztcbiAgICAgICAgICBkb25lVyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRIICogc2lnbkggPCBmbG9vcihzdGVwSCAqIG11bHRIICogc2lnbkgpKSB7XG4gICAgICAgICAgc3RlcEggPSBmbG9vcihzdGVwSCAqIG11bHRIKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzdGVwSCA9IGRIO1xuICAgICAgICAgIGRvbmVIID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBvVywgb0gpO1xuICAgICAgICB0bXBDdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHN0ZXBXLCBzdGVwSCk7XG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHRtcENhbnZhcywgMCwgMCwgb1csIG9ILCAwLCAwLCBzdGVwVywgc3RlcEgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGRXLCBkSCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciBsYW5jem9zUmVzaXplXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvVyBPcmlnaW5hbCBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvSCBPcmlnaW5hbCBIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZFcgRGVzdGluYXRpb24gV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZEggRGVzdGluYXRpb24gSGVpZ2h0XG4gICAgICogQHJldHVybnMge0ltYWdlRGF0YX1cbiAgICAgKi9cbiAgICBsYW5jem9zUmVzaXplOiBmdW5jdGlvbihjYW52YXNFbCwgb1csIG9ILCBkVywgZEgpIHtcblxuICAgICAgZnVuY3Rpb24gbGFuY3pvc0NyZWF0ZShsb2Jlcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgICAgIGlmICh4ID4gbG9iZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICB4ICo9IE1hdGguUEk7XG4gICAgICAgICAgaWYgKGFicyh4KSA8IDFlLTE2KSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHh4ID0geCAvIGxvYmVzO1xuICAgICAgICAgIHJldHVybiBzaW4oeCkgKiBzaW4oeHgpIC8geCAvIHh4O1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwcm9jZXNzKHUpIHtcbiAgICAgICAgdmFyIHYsIGksIHdlaWdodCwgaWR4LCBhLCByZWQsIGdyZWVuLFxuICAgICAgICAgICAgYmx1ZSwgYWxwaGEsIGZYLCBmWTtcbiAgICAgICAgY2VudGVyLnggPSAodSArIDAuNSkgKiByYXRpb1g7XG4gICAgICAgIGljZW50ZXIueCA9IGZsb29yKGNlbnRlci54KTtcbiAgICAgICAgZm9yICh2ID0gMDsgdiA8IGRIOyB2KyspIHtcbiAgICAgICAgICBjZW50ZXIueSA9ICh2ICsgMC41KSAqIHJhdGlvWTtcbiAgICAgICAgICBpY2VudGVyLnkgPSBmbG9vcihjZW50ZXIueSk7XG4gICAgICAgICAgYSA9IDA7IHJlZCA9IDA7IGdyZWVuID0gMDsgYmx1ZSA9IDA7IGFscGhhID0gMDtcbiAgICAgICAgICBmb3IgKGkgPSBpY2VudGVyLnggLSByYW5nZTJYOyBpIDw9IGljZW50ZXIueCArIHJhbmdlMlg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPCAwIHx8IGkgPj0gb1cpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmWCA9IGZsb29yKDEwMDAgKiBhYnMoaSAtIGNlbnRlci54KSk7XG4gICAgICAgICAgICBpZiAoIWNhY2hlTGFuY1tmWF0pIHtcbiAgICAgICAgICAgICAgY2FjaGVMYW5jW2ZYXSA9IHsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpY2VudGVyLnkgLSByYW5nZTJZOyBqIDw9IGljZW50ZXIueSArIHJhbmdlMlk7IGorKykge1xuICAgICAgICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBvSCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZZID0gZmxvb3IoMTAwMCAqIGFicyhqIC0gY2VudGVyLnkpKTtcbiAgICAgICAgICAgICAgaWYgKCFjYWNoZUxhbmNbZlhdW2ZZXSkge1xuICAgICAgICAgICAgICAgIGNhY2hlTGFuY1tmWF1bZlldID0gbGFuY3pvcyhzcXJ0KHBvdyhmWCAqIHJjcFJhdGlvWCwgMikgKyBwb3coZlkgKiByY3BSYXRpb1ksIDIpKSAvIDEwMDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdlaWdodCA9IGNhY2hlTGFuY1tmWF1bZlldO1xuICAgICAgICAgICAgICBpZiAod2VpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgIGlkeCA9IChqICogb1cgKyBpKSAqIDQ7XG4gICAgICAgICAgICAgICAgYSArPSB3ZWlnaHQ7XG4gICAgICAgICAgICAgICAgcmVkICs9IHdlaWdodCAqIHNyY0RhdGFbaWR4XTtcbiAgICAgICAgICAgICAgICBncmVlbiArPSB3ZWlnaHQgKiBzcmNEYXRhW2lkeCArIDFdO1xuICAgICAgICAgICAgICAgIGJsdWUgKz0gd2VpZ2h0ICogc3JjRGF0YVtpZHggKyAyXTtcbiAgICAgICAgICAgICAgICBhbHBoYSArPSB3ZWlnaHQgKiBzcmNEYXRhW2lkeCArIDNdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlkeCA9ICh2ICogZFcgKyB1KSAqIDQ7XG4gICAgICAgICAgZGVzdERhdGFbaWR4XSA9IHJlZCAvIGE7XG4gICAgICAgICAgZGVzdERhdGFbaWR4ICsgMV0gPSBncmVlbiAvIGE7XG4gICAgICAgICAgZGVzdERhdGFbaWR4ICsgMl0gPSBibHVlIC8gYTtcbiAgICAgICAgICBkZXN0RGF0YVtpZHggKyAzXSA9IGFscGhhIC8gYTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgrK3UgPCBkVykge1xuICAgICAgICAgIHJldHVybiBwcm9jZXNzKHUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZXN0SW1nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICBzcmNJbWcgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBvVywgb0gpLFxuICAgICAgICAgIGRlc3RJbWcgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBkVywgZEgpLFxuICAgICAgICAgIHNyY0RhdGEgPSBzcmNJbWcuZGF0YSwgZGVzdERhdGEgPSBkZXN0SW1nLmRhdGEsXG4gICAgICAgICAgbGFuY3pvcyA9IGxhbmN6b3NDcmVhdGUodGhpcy5sYW5jem9zTG9iZXMpLFxuICAgICAgICAgIHJhdGlvWCA9IHRoaXMucmNwU2NhbGVYLCByYXRpb1kgPSB0aGlzLnJjcFNjYWxlWSxcbiAgICAgICAgICByY3BSYXRpb1ggPSAyIC8gdGhpcy5yY3BTY2FsZVgsIHJjcFJhdGlvWSA9IDIgLyB0aGlzLnJjcFNjYWxlWSxcbiAgICAgICAgICByYW5nZTJYID0gY2VpbChyYXRpb1ggKiB0aGlzLmxhbmN6b3NMb2JlcyAvIDIpLFxuICAgICAgICAgIHJhbmdlMlkgPSBjZWlsKHJhdGlvWSAqIHRoaXMubGFuY3pvc0xvYmVzIC8gMiksXG4gICAgICAgICAgY2FjaGVMYW5jID0geyB9LCBjZW50ZXIgPSB7IH0sIGljZW50ZXIgPSB7IH07XG5cbiAgICAgIHJldHVybiBwcm9jZXNzKDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBiaWxpbmVhckZpbHRlcmluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb1cgT3JpZ2luYWwgV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb0ggT3JpZ2luYWwgSGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRXIERlc3RpbmF0aW9uIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRIIERlc3RpbmF0aW9uIEhlaWdodFxuICAgICAqIEByZXR1cm5zIHtJbWFnZURhdGF9XG4gICAgICovXG4gICAgYmlsaW5lYXJGaWx0ZXJpbmc6IGZ1bmN0aW9uKGNhbnZhc0VsLCBvVywgb0gsIGRXLCBkSCkge1xuICAgICAgdmFyIGEsIGIsIGMsIGQsIHgsIHksIGksIGosIHhEaWZmLCB5RGlmZiwgY2hubCxcbiAgICAgICAgICBjb2xvciwgb2Zmc2V0ID0gMCwgb3JpZ1BpeCwgcmF0aW9YID0gdGhpcy5yY3BTY2FsZVgsXG4gICAgICAgICAgcmF0aW9ZID0gdGhpcy5yY3BTY2FsZVksIGNvbnRleHQgPSBjYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICAgIHc0ID0gNCAqIChvVyAtIDEpLCBpbWcgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBvVywgb0gpLFxuICAgICAgICAgIHBpeGVscyA9IGltZy5kYXRhLCBkZXN0SW1hZ2UgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBkVywgZEgpLFxuICAgICAgICAgIGRlc3RQaXhlbHMgPSBkZXN0SW1hZ2UuZGF0YTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBkSDsgaSsrKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBkVzsgaisrKSB7XG4gICAgICAgICAgeCA9IGZsb29yKHJhdGlvWCAqIGopO1xuICAgICAgICAgIHkgPSBmbG9vcihyYXRpb1kgKiBpKTtcbiAgICAgICAgICB4RGlmZiA9IHJhdGlvWCAqIGogLSB4O1xuICAgICAgICAgIHlEaWZmID0gcmF0aW9ZICogaSAtIHk7XG4gICAgICAgICAgb3JpZ1BpeCA9IDQgKiAoeSAqIG9XICsgeCk7XG5cbiAgICAgICAgICBmb3IgKGNobmwgPSAwOyBjaG5sIDwgNDsgY2hubCsrKSB7XG4gICAgICAgICAgICBhID0gcGl4ZWxzW29yaWdQaXggKyBjaG5sXTtcbiAgICAgICAgICAgIGIgPSBwaXhlbHNbb3JpZ1BpeCArIDQgKyBjaG5sXTtcbiAgICAgICAgICAgIGMgPSBwaXhlbHNbb3JpZ1BpeCArIHc0ICsgY2hubF07XG4gICAgICAgICAgICBkID0gcGl4ZWxzW29yaWdQaXggKyB3NCArIDQgKyBjaG5sXTtcbiAgICAgICAgICAgIGNvbG9yID0gYSAqICgxIC0geERpZmYpICogKDEgLSB5RGlmZikgKyBiICogeERpZmYgKiAoMSAtIHlEaWZmKSArXG4gICAgICAgICAgICAgICAgICAgIGMgKiB5RGlmZiAqICgxIC0geERpZmYpICsgZCAqIHhEaWZmICogeURpZmY7XG4gICAgICAgICAgICBkZXN0UGl4ZWxzW29mZnNldCsrXSA9IGNvbG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc3RJbWFnZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaGVybWl0ZUZhc3RSZXNpemVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9XIE9yaWdpbmFsIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9IIE9yaWdpbmFsIEhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkVyBEZXN0aW5hdGlvbiBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkSCBEZXN0aW5hdGlvbiBIZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2VEYXRhfVxuICAgICAqL1xuICAgIGhlcm1pdGVGYXN0UmVzaXplOiBmdW5jdGlvbihjYW52YXNFbCwgb1csIG9ILCBkVywgZEgpIHtcbiAgICAgIHZhciByYXRpb1cgPSB0aGlzLnJjcFNjYWxlWCwgcmF0aW9IID0gdGhpcy5yY3BTY2FsZVksXG4gICAgICAgICAgcmF0aW9XSGFsZiA9IGNlaWwocmF0aW9XIC8gMiksXG4gICAgICAgICAgcmF0aW9ISGFsZiA9IGNlaWwocmF0aW9IIC8gMiksXG4gICAgICAgICAgY29udGV4dCA9IGNhbnZhc0VsLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgaW1nID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgb1csIG9IKSwgZGF0YSA9IGltZy5kYXRhLFxuICAgICAgICAgIGltZzIgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBkVywgZEgpLCBkYXRhMiA9IGltZzIuZGF0YTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZEg7IGorKykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRXOyBpKyspIHtcbiAgICAgICAgICB2YXIgeDIgPSAoaSArIGogKiBkVykgKiA0LCB3ZWlnaHQgPSAwLCB3ZWlnaHRzID0gMCwgd2VpZ2h0c0FscGhhID0gMCxcbiAgICAgICAgICAgICAgZ3hSID0gMCwgZ3hHID0gMCwgZ3hCID0gMCwgZ3hBID0gMCwgY2VudGVyWSA9IChqICsgMC41KSAqIHJhdGlvSDtcbiAgICAgICAgICBmb3IgKHZhciB5eSA9IGZsb29yKGogKiByYXRpb0gpOyB5eSA8IChqICsgMSkgKiByYXRpb0g7IHl5KyspIHtcbiAgICAgICAgICAgIHZhciBkeSA9IGFicyhjZW50ZXJZIC0gKHl5ICsgMC41KSkgLyByYXRpb0hIYWxmLFxuICAgICAgICAgICAgICAgIGNlbnRlclggPSAoaSArIDAuNSkgKiByYXRpb1csIHcwID0gZHkgKiBkeTtcbiAgICAgICAgICAgIGZvciAodmFyIHh4ID0gZmxvb3IoaSAqIHJhdGlvVyk7IHh4IDwgKGkgKyAxKSAqIHJhdGlvVzsgeHgrKykge1xuICAgICAgICAgICAgICB2YXIgZHggPSBhYnMoY2VudGVyWCAtICh4eCArIDAuNSkpIC8gcmF0aW9XSGFsZixcbiAgICAgICAgICAgICAgICAgIHcgPSBzcXJ0KHcwICsgZHggKiBkeCk7XG4gICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1kZXB0aCAqL1xuICAgICAgICAgICAgICBpZiAodyA+IDEgJiYgdyA8IC0xKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy9oZXJtaXRlIGZpbHRlclxuICAgICAgICAgICAgICB3ZWlnaHQgPSAyICogdyAqIHcgKiB3IC0gMyAqIHcgKiB3ICsgMTtcbiAgICAgICAgICAgICAgaWYgKHdlaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgICBkeCA9IDQgKiAoeHggKyB5eSAqIG9XKTtcbiAgICAgICAgICAgICAgICAvL2FscGhhXG4gICAgICAgICAgICAgICAgZ3hBICs9IHdlaWdodCAqIGRhdGFbZHggKyAzXTtcbiAgICAgICAgICAgICAgICB3ZWlnaHRzQWxwaGEgKz0gd2VpZ2h0O1xuICAgICAgICAgICAgICAgIC8vY29sb3JzXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbZHggKyAzXSA8IDI1NSkge1xuICAgICAgICAgICAgICAgICAgd2VpZ2h0ID0gd2VpZ2h0ICogZGF0YVtkeCArIDNdIC8gMjUwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBneFIgKz0gd2VpZ2h0ICogZGF0YVtkeF07XG4gICAgICAgICAgICAgICAgZ3hHICs9IHdlaWdodCAqIGRhdGFbZHggKyAxXTtcbiAgICAgICAgICAgICAgICBneEIgKz0gd2VpZ2h0ICogZGF0YVtkeCArIDJdO1xuICAgICAgICAgICAgICAgIHdlaWdodHMgKz0gd2VpZ2h0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWRlcHRoICovXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGEyW3gyXSA9IGd4UiAvIHdlaWdodHM7XG4gICAgICAgICAgZGF0YTJbeDIgKyAxXSA9IGd4RyAvIHdlaWdodHM7XG4gICAgICAgICAgZGF0YTJbeDIgKyAyXSA9IGd4QiAvIHdlaWdodHM7XG4gICAgICAgICAgZGF0YTJbeDIgKyAzXSA9IGd4QSAvIHdlaWdodHNBbHBoYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGltZzI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIHNjYWxlWDogdGhpcy5zY2FsZVgsXG4gICAgICAgIHNjYWxlWTogdGhpcy5zY2FsZVksXG4gICAgICAgIHJlc2l6ZVR5cGU6IHRoaXMucmVzaXplVHlwZSxcbiAgICAgICAgbGFuY3pvc0xvYmVzOiB0aGlzLmxhbmN6b3NMb2Jlc1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplKG9iamVjdCk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQ29sb3IgTWF0cml4IGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXhcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXgjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAc2VlIHtATGluayBodHRwOi8vd3d3LndlYndhc3AuY28udWsvdHV0b3JpYWxzLzIxOS9Db2xvcl9NYXRyaXhfRmlsdGVyLnBocH1cbiAgICogQHNlZSB7QExpbmsgaHR0cDovL3Bob2Jvc2xhYi5vcmcvbG9nLzIwMTMvMTEvZmFzdC1pbWFnZS1maWx0ZXJzLXdpdGgtd2ViZ2x9XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPktvZGFjaHJvbWUgZmlsdGVyPC9jYXB0aW9uPlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4KHtcbiAgICogIG1hdHJpeDogW1xuICAgICAgIDEuMTI4NTU4MjM5NjU5MzUyNSwgLTAuMzk2NzM4MjI4MzYwMTM0OCwgLTAuMDM5OTI1NTkxNzI5MjE3OTMsIDAsIDYzLjcyOTU4NzYyMTk2NTAyLFxuICAgICAgIC0wLjE2NDA0MzM5OTYyMjQ0NjE2LCAxLjA4MzUyNTE1NjYyOTEzMDQsIC0wLjA1NDk4ODA1MTE1NjMzMTMyLCAwLCAyNC43MzI0MDc4OTY3MDYyMDMsXG4gICAgICAgLTAuMTY3ODYwMTA3MDYxNTU3NjMsIC0wLjU2MDM0MTYyNzc2OTUyNDgsIDEuNjAxNDg1MDc2MTk2NDk0MywgMCwgMzUuNjI5ODI4MDc0NjA5NDYsXG4gICAgICAgMCwgMCwgMCwgMSwgMFxuICAgICAgXVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICovXG4gIGZpbHRlcnMuQ29sb3JNYXRyaXggPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXgucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdDb2xvck1hdHJpeCcsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubWF0cml4XSBDb2xvciBNYXRyaXggdG8gbW9kaWZ5IHRoZSBpbWFnZSBkYXRhIHdpdGhcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcbiAgICAgIG9wdGlvbnMgfHwgKCBvcHRpb25zID0ge30gKTtcbiAgICAgIHRoaXMubWF0cml4ID0gb3B0aW9ucy5tYXRyaXggfHwgW1xuICAgICAgICAxLCAwLCAwLCAwLCAwLFxuICAgICAgICAwLCAxLCAwLCAwLCAwLFxuICAgICAgICAwLCAwLCAxLCAwLCAwLFxuICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlciB0byBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKi9cbiAgICBhcHBseVRvOiBmdW5jdGlvbiggY2FudmFzRWwgKSB7XG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhc0VsLmdldENvbnRleHQoICcyZCcgKSxcbiAgICAgICAgICBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSggMCwgMCwgY2FudmFzRWwud2lkdGgsIGNhbnZhc0VsLmhlaWdodCApLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBpTGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgaSxcbiAgICAgICAgICByLFxuICAgICAgICAgIGcsXG4gICAgICAgICAgYixcbiAgICAgICAgICBhLFxuICAgICAgICAgIG0gPSB0aGlzLm1hdHJpeDtcblxuICAgICAgZm9yICggaSA9IDA7IGkgPCBpTGVuOyBpICs9IDQgKSB7XG4gICAgICAgIHIgPSBkYXRhWyBpIF07XG4gICAgICAgIGcgPSBkYXRhWyBpICsgMSBdO1xuICAgICAgICBiID0gZGF0YVsgaSArIDIgXTtcbiAgICAgICAgYSA9IGRhdGFbIGkgKyAzIF07XG5cbiAgICAgICAgZGF0YVsgaSBdID0gciAqIG1bIDAgXSArIGcgKiBtWyAxIF0gKyBiICogbVsgMiBdICsgYSAqIG1bIDMgXSArIG1bIDQgXTtcbiAgICAgICAgZGF0YVsgaSArIDEgXSA9IHIgKiBtWyA1IF0gKyBnICogbVsgNiBdICsgYiAqIG1bIDcgXSArIGEgKiBtWyA4IF0gKyBtWyA5IF07XG4gICAgICAgIGRhdGFbIGkgKyAyIF0gPSByICogbVsgMTAgXSArIGcgKiBtWyAxMSBdICsgYiAqIG1bIDEyIF0gKyBhICogbVsgMTMgXSArIG1bIDE0IF07XG4gICAgICAgIGRhdGFbIGkgKyAzIF0gPSByICogbVsgMTUgXSArIGcgKiBtWyAxNiBdICsgYiAqIG1bIDE3IF0gKyBhICogbVsgMTggXSArIG1bIDE5IF07XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKCBpbWFnZURhdGEsIDAsIDAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JyksIHtcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBtYXRyaXg6IHRoaXMubWF0cml4XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4fSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeFxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXguZnJvbU9iamVjdCA9IGZ1bmN0aW9uKCBvYmplY3QgKSB7XG4gICAgcmV0dXJuIG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeCggb2JqZWN0ICk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQ29udHJhc3QgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3Qoe1xuICAgKiAgIGNvbnRyYXN0OiA0MFxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICovXG4gIGZpbHRlcnMuQ29udHJhc3QgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdDb250cmFzdCcsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbnRyYXN0PTBdIFZhbHVlIHRvIGNvbnRyYXN0IHRoZSBpbWFnZSB1cCAoLTI1NS4uLjI1NSlcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG4gICAgICB0aGlzLmNvbnRyYXN0ID0gb3B0aW9ucy5jb250cmFzdCB8fCAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlciB0byBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKi9cbiAgICBhcHBseVRvOiBmdW5jdGlvbihjYW52YXNFbCkge1xuICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICAgIGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhc0VsLndpZHRoLCBjYW52YXNFbC5oZWlnaHQpLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBjb250cmFzdEYgPSAyNTkgKiAodGhpcy5jb250cmFzdCArIDI1NSkgLyAoMjU1ICogKDI1OSAtIHRoaXMuY29udHJhc3QpKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgZGF0YVtpXSA9IGNvbnRyYXN0RiAqIChkYXRhW2ldIC0gMTI4KSArIDEyODtcbiAgICAgICAgZGF0YVtpICsgMV0gPSBjb250cmFzdEYgKiAoZGF0YVtpICsgMV0gLSAxMjgpICsgMTI4O1xuICAgICAgICBkYXRhW2kgKyAyXSA9IGNvbnRyYXN0RiAqIChkYXRhW2kgKyAyXSAtIDEyOCkgKyAxMjg7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcpLCB7XG4gICAgICAgIGNvbnRyYXN0OiB0aGlzLmNvbnRyYXN0XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0fSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdFxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3QuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3Qob2JqZWN0KTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBTYXR1cmF0ZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0ZSh7XG4gICAqICAgc2F0dXJhdGU6IDEwMFxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICovXG4gIGZpbHRlcnMuU2F0dXJhdGUgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdTYXR1cmF0ZScsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbnRyYXN0PTBdIFZhbHVlIHRvIHNhdHVyYXRlIHRoZSBpbWFnZSAoLTI1NS4uLjI1NSlcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG4gICAgICB0aGlzLnNhdHVyYXRlID0gb3B0aW9ucy5zYXR1cmF0ZSB8fCAwO1xuICAgICAgdGhpcy5sb2FkUHJvZ3JhbSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlciB0byBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKi9cbiAgICBhcHBseVRvOiBmdW5jdGlvbihjYW52YXNFbCkge1xuICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICAgIGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhc0VsLndpZHRoLCBjYW52YXNFbC5oZWlnaHQpLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBtYXgsIGFkanVzdCA9IC10aGlzLnNhdHVyYXRlICogMC4wMTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgoZGF0YVtpXSwgZGF0YVtpICsgMV0sIGRhdGFbaSArIDJdKTtcbiAgICAgICAgZGF0YVtpXSArPSBtYXggIT09IGRhdGFbaV0gPyAobWF4IC0gZGF0YVtpXSkgKiBhZGp1c3QgOiAwO1xuICAgICAgICBkYXRhW2kgKyAxXSArPSBtYXggIT09IGRhdGFbaSArIDFdID8gKG1heCAtIGRhdGFbaSArIDFdKSAqIGFkanVzdCA6IDA7XG4gICAgICAgIGRhdGFbaSArIDJdICs9IG1heCAhPT0gZGF0YVtpICsgMl0gPyAobWF4IC0gZGF0YVtpICsgMl0pICogYWRqdXN0IDogMDtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JyksIHtcbiAgICAgICAgc2F0dXJhdGU6IHRoaXMuc2F0dXJhdGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGV9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0ZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0ZShvYmplY3QpO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUsXG4gICAgICB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZCxcbiAgICAgIE5VTV9GUkFDVElPTl9ESUdJVFMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFMsXG4gICAgICBNSU5fVEVYVF9XSURUSCA9IDI7XG5cbiAgaWYgKGZhYnJpYy5UZXh0KSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5UZXh0IGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzdGF0ZVByb3BlcnRpZXMgPSBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5zdGF0ZVByb3BlcnRpZXMuY29uY2F0KCk7XG4gIHN0YXRlUHJvcGVydGllcy5wdXNoKFxuICAgICdmb250RmFtaWx5JyxcbiAgICAnZm9udFdlaWdodCcsXG4gICAgJ2ZvbnRTaXplJyxcbiAgICAndGV4dCcsXG4gICAgJ3RleHREZWNvcmF0aW9uJyxcbiAgICAndGV4dEFsaWduJyxcbiAgICAnZm9udFN0eWxlJyxcbiAgICAnbGluZUhlaWdodCcsXG4gICAgJ3RleHRCYWNrZ3JvdW5kQ29sb3InXG4gICk7XG5cbiAgLyoqXG4gICAqIFRleHQgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5UZXh0XG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLlRleHR9IHRoaXNBcmdcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTIjdGV4dH1cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlRleHQjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5UZXh0ID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuVGV4dC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyB3aGljaCB3aGVuIHNldCBjYXVzZSBvYmplY3QgdG8gY2hhbmdlIGRpbWVuc2lvbnNcbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kaW1lbnNpb25BZmZlY3RpbmdQcm9wczoge1xuICAgICAgZm9udFNpemU6IHRydWUsXG4gICAgICBmb250V2VpZ2h0OiB0cnVlLFxuICAgICAgZm9udEZhbWlseTogdHJ1ZSxcbiAgICAgIGZvbnRTdHlsZTogdHJ1ZSxcbiAgICAgIGxpbmVIZWlnaHQ6IHRydWUsXG4gICAgICB0ZXh0OiB0cnVlLFxuICAgICAgY2hhclNwYWNpbmc6IHRydWUsXG4gICAgICB0ZXh0QWxpZ246IHRydWUsXG4gICAgICBzdHJva2VXaWR0aDogZmFsc2UsXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlTmV3bGluZTogL1xccj9cXG4vLFxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgcmVndWxhciBleHByZXNzaW9uIHRvIGZpbHRlciBmb3Igd2hpdGVzcGFjZSB0aGF0IGlzIG5vdCBhIG5ldyBsaW5lLlxuICAgICAqIE1vc3RseSB1c2VkIHdoZW4gdGV4dCBpcyAnanVzdGlmeScgYWxpZ25lZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZVNwYWNlc0FuZFRhYnM6IC9bIFxcdFxccl0rL2csXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgb2JqZWN0J3MgZm9udFNpemVcbiAgICAgKiBAbWV0aG9kIGdldEZvbnRTaXplXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gRm9udCBzaXplIChpbiBwaXhlbHMpXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9iamVjdCdzIGZvbnRTaXplXG4gICAgICogRG9lcyBub3QgdXBkYXRlIHRoZSBvYmplY3QgLndpZHRoIGFuZCAuaGVpZ2h0LFxuICAgICAqIGNhbGwgLl9pbml0RGltZW5zaW9ucygpIHRvIHVwZGF0ZSB0aGUgdmFsdWVzLlxuICAgICAqIEBtZXRob2Qgc2V0Rm9udFNpemVcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZvbnRTaXplIEZvbnQgc2l6ZSAoaW4gcGl4ZWxzKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5UZXh0fVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBvYmplY3QncyBmb250V2VpZ2h0XG4gICAgICogQG1ldGhvZCBnZXRGb250V2VpZ2h0XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4geyhTdHJpbmd8TnVtYmVyKX0gRm9udCB3ZWlnaHRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFNldHMgb2JqZWN0J3MgZm9udFdlaWdodFxuICAgICAqIERvZXMgbm90IHVwZGF0ZSB0aGUgb2JqZWN0IC53aWR0aCBhbmQgLmhlaWdodCxcbiAgICAgKiBjYWxsIC5faW5pdERpbWVuc2lvbnMoKSB0byB1cGRhdGUgdGhlIHZhbHVlcy5cbiAgICAgKiBAbWV0aG9kIHNldEZvbnRXZWlnaHRcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHsoTnVtYmVyfFN0cmluZyl9IGZvbnRXZWlnaHQgRm9udCB3ZWlnaHRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dH1cbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgb2JqZWN0J3MgZm9udEZhbWlseVxuICAgICAqIEBtZXRob2QgZ2V0Rm9udEZhbWlseVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IEZvbnQgZmFtaWx5XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9iamVjdCdzIGZvbnRGYW1pbHlcbiAgICAgKiBEb2VzIG5vdCB1cGRhdGUgdGhlIG9iamVjdCAud2lkdGggYW5kIC5oZWlnaHQsXG4gICAgICogY2FsbCAuX2luaXREaW1lbnNpb25zKCkgdG8gdXBkYXRlIHRoZSB2YWx1ZXMuXG4gICAgICogQG1ldGhvZCBzZXRGb250RmFtaWx5XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb250RmFtaWx5IEZvbnQgZmFtaWx5XG4gICAgICogQHJldHVybiB7ZmFicmljLlRleHR9XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG9iamVjdCdzIHRleHRcbiAgICAgKiBAbWV0aG9kIGdldFRleHRcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHQucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0ZXh0XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9iamVjdCdzIHRleHRcbiAgICAgKiBEb2VzIG5vdCB1cGRhdGUgdGhlIG9iamVjdCAud2lkdGggYW5kIC5oZWlnaHQsXG4gICAgICogY2FsbCAuX2luaXREaW1lbnNpb25zKCkgdG8gdXBkYXRlIHRoZSB2YWx1ZXMuXG4gICAgICogQG1ldGhvZCBzZXRUZXh0XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRleHRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dH1cbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgb2JqZWN0J3MgdGV4dERlY29yYXRpb25cbiAgICAgKiBAbWV0aG9kIGdldFRleHREZWNvcmF0aW9uXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGV4dCBkZWNvcmF0aW9uXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9iamVjdCdzIHRleHREZWNvcmF0aW9uXG4gICAgICogQG1ldGhvZCBzZXRUZXh0RGVjb3JhdGlvblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dERlY29yYXRpb24gVGV4dCBkZWNvcmF0aW9uXG4gICAgICogQHJldHVybiB7ZmFicmljLlRleHR9XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG9iamVjdCdzIGZvbnRTdHlsZVxuICAgICAqIEBtZXRob2QgZ2V0Rm9udFN0eWxlXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gRm9udCBzdHlsZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBvYmplY3QncyBmb250U3R5bGVcbiAgICAgKiBEb2VzIG5vdCB1cGRhdGUgdGhlIG9iamVjdCAud2lkdGggYW5kIC5oZWlnaHQsXG4gICAgICogY2FsbCAuX2luaXREaW1lbnNpb25zKCkgdG8gdXBkYXRlIHRoZSB2YWx1ZXMuXG4gICAgICogQG1ldGhvZCBzZXRGb250U3R5bGVcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZvbnRTdHlsZSBGb250IHN0eWxlXG4gICAgICogQHJldHVybiB7ZmFicmljLlRleHR9XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG9iamVjdCdzIGxpbmVIZWlnaHRcbiAgICAgKiBAbWV0aG9kIGdldExpbmVIZWlnaHRcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHQucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBMaW5lIGhlaWdodFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBvYmplY3QncyBsaW5lSGVpZ2h0XG4gICAgICogQG1ldGhvZCBzZXRMaW5lSGVpZ2h0XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSGVpZ2h0IExpbmUgaGVpZ2h0XG4gICAgICogQHJldHVybiB7ZmFicmljLlRleHR9XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG9iamVjdCdzIHRleHRBbGlnblxuICAgICAqIEBtZXRob2QgZ2V0VGV4dEFsaWduXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGV4dCBhbGlnbm1lbnRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFNldHMgb2JqZWN0J3MgdGV4dEFsaWduXG4gICAgICogQG1ldGhvZCBzZXRUZXh0QWxpZ25cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHRBbGlnbiBUZXh0IGFsaWdubWVudFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5UZXh0fVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBvYmplY3QncyB0ZXh0QmFja2dyb3VuZENvbG9yXG4gICAgICogQG1ldGhvZCBnZXRUZXh0QmFja2dyb3VuZENvbG9yXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGV4dCBiYWNrZ3JvdW5kIGNvbG9yXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9iamVjdCdzIHRleHRCYWNrZ3JvdW5kQ29sb3JcbiAgICAgKiBAbWV0aG9kIHNldFRleHRCYWNrZ3JvdW5kQ29sb3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHRCYWNrZ3JvdW5kQ29sb3IgVGV4dCBiYWNrZ3JvdW5kIGNvbG9yXG4gICAgICogQHJldHVybiB7ZmFicmljLlRleHR9XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICAgICAgICAgICAgICAgICAndGV4dCcsXG5cbiAgICAvKipcbiAgICAgKiBGb250IHNpemUgKGluIHBpeGVscylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZvbnRTaXplOiAgICAgICAgICAgICA0MCxcblxuICAgIC8qKlxuICAgICAqIEZvbnQgd2VpZ2h0IChlLmcuIGJvbGQsIG5vcm1hbCwgNDAwLCA2MDAsIDgwMClcbiAgICAgKiBAdHlwZSB7KE51bWJlcnxTdHJpbmcpfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZm9udFdlaWdodDogICAgICAgICAgICdub3JtYWwnLFxuXG4gICAgLyoqXG4gICAgICogRm9udCBmYW1pbHlcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZvbnRGYW1pbHk6ICAgICAgICAgICAnVGltZXMgTmV3IFJvbWFuJyxcblxuICAgIC8qKlxuICAgICAqIFRleHQgZGVjb3JhdGlvbiBQb3NzaWJsZSB2YWx1ZXM6IFwiXCIsIFwidW5kZXJsaW5lXCIsIFwib3ZlcmxpbmVcIiBvciBcImxpbmUtdGhyb3VnaFwiLlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdGV4dERlY29yYXRpb246ICAgICAgICcnLFxuXG4gICAgLyoqXG4gICAgICogVGV4dCBhbGlnbm1lbnQuIFBvc3NpYmxlIHZhbHVlczogXCJsZWZ0XCIsIFwiY2VudGVyXCIsIFwicmlnaHRcIiBvciBcImp1c3RpZnlcIi5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRleHRBbGlnbjogICAgICAgICAgICAnbGVmdCcsXG5cbiAgICAvKipcbiAgICAgKiBGb250IHN0eWxlIC4gUG9zc2libGUgdmFsdWVzOiBcIlwiLCBcIm5vcm1hbFwiLCBcIml0YWxpY1wiIG9yIFwib2JsaXF1ZVwiLlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZm9udFN0eWxlOiAgICAgICAgICAgICcnLFxuXG4gICAgLyoqXG4gICAgICogTGluZSBoZWlnaHRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxpbmVIZWlnaHQ6ICAgICAgICAgICAxLjE2LFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBjb2xvciBvZiB0ZXh0IGxpbmVzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0ZXh0QmFja2dyb3VuZENvbG9yOiAgJycsXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZlxuICAgICAqIHN0YXRlIG9mIGFuIG9iamVjdCBpcyBjaGFuZ2VkICh7QGxpbmsgZmFicmljLk9iamVjdCNoYXNTdGF0ZUNoYW5nZWR9KVxuICAgICAqIGFzIHdlbGwgYXMgZm9yIGhpc3RvcnkgKHVuZG8vcmVkbykgcHVycG9zZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHN0YXRlUHJvcGVydGllczogICAgICBzdGF0ZVByb3BlcnRpZXMsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGRlZmluZWQsIGFuIG9iamVjdCBpcyByZW5kZXJlZCB2aWEgc3Ryb2tlIGFuZCB0aGlzIHByb3BlcnR5IHNwZWNpZmllcyBpdHMgY29sb3IuXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSB3YXMgbmFtZWQgXCJzdHJva2VTdHlsZVwiIHVudGlsIHYxLjEuNlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlOiAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBTaGFkb3cgb2JqZWN0IHJlcHJlc2VudGluZyBzaGFkb3cgb2YgdGhpcyBzaGFwZS5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHdhcyBuYW1lZCBcInRleHRTaGFkb3dcIiAoU3RyaW5nKSB1bnRpbCB2MS4yLjExXG4gICAgICogQHR5cGUgZmFicmljLlNoYWRvd1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2hhZG93OiAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9mb250U2l6ZUZyYWN0aW9uOiAwLjI1LFxuXG4gICAgLyoqXG4gICAgICogVGV4dCBMaW5lIHByb3BvcnRpb24gdG8gZm9udCBTaXplIChpbiBwaXhlbHMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBfZm9udFNpemVNdWx0OiAgICAgICAgICAgICAxLjEzLFxuXG4gICAgLyoqXG4gICAgICogYWRkaXRpb25hbCBzcGFjZSBiZXR3ZWVuIGNoYXJhY3RlcnNcbiAgICAgKiBleHByZXNzZWQgaW4gdGhvdXNhbmRzIG9mIGVtIHVuaXRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNoYXJTcGFjaW5nOiAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUZXh0IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgfTtcbiAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICB0aGlzLl9fc2tpcERpbWVuc2lvbiA9IHRydWU7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB0aGlzLl9fc2tpcERpbWVuc2lvbiA9IGZhbHNlO1xuICAgICAgdGhpcy5faW5pdERpbWVuc2lvbnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0ZXh0IGRpbWVuc2lvbnMuIFJlbmRlciBhbGwgdGV4dCBvbiBnaXZlbiBjb250ZXh0XG4gICAgICogb3Igb24gYSBvZmZzY3JlZW4gY2FudmFzIHRvIGdldCB0aGUgdGV4dCB3aWR0aCB3aXRoIG1lYXN1cmVUZXh0LlxuICAgICAqIFVwZGF0ZXMgdGhpcy53aWR0aCBhbmQgdGhpcy5oZWlnaHQgd2l0aCB0aGUgcHJvcGVyIHZhbHVlcy5cbiAgICAgKiBEb2VzIG5vdCByZXR1cm4gZGltZW5zaW9ucy5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gW2N0eF0gQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0RGltZW5zaW9uczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAodGhpcy5fX3NraXBEaW1lbnNpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgY3R4ID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHRoaXMuX3NldFRleHRTdHlsZXMoY3R4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3RleHRMaW5lcyA9IHRoaXMuX3NwbGl0VGV4dEludG9MaW5lcygpO1xuICAgICAgdGhpcy5fY2xlYXJDYWNoZSgpO1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuX2dldFRleHRXaWR0aChjdHgpIHx8IHRoaXMuY3Vyc29yV2lkdGggfHwgTUlOX1RFWFRfV0lEVEg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuX2dldFRleHRIZWlnaHQoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0ZXh0IG9iamVjdFxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuVGV4dCAoJyArIHRoaXMuY29tcGxleGl0eSgpICtcbiAgICAgICAgJyk6IHsgXCJ0ZXh0XCI6IFwiJyArIHRoaXMudGV4dCArICdcIiwgXCJmb250RmFtaWx5XCI6IFwiJyArIHRoaXMuZm9udEZhbWlseSArICdcIiB9Pic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5jbGlwVG8gJiYgZmFicmljLnV0aWwuY2xpcENvbnRleHQodGhpcywgY3R4KTtcbiAgICAgIHRoaXMuX3NldE9wYWNpdHkoY3R4KTtcbiAgICAgIHRoaXMuX3NldFNoYWRvdyhjdHgpO1xuICAgICAgdGhpcy5fc2V0dXBDb21wb3NpdGVPcGVyYXRpb24oY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHRCYWNrZ3JvdW5kKGN0eCk7XG4gICAgICB0aGlzLl9zZXRTdHJva2VTdHlsZXMoY3R4KTtcbiAgICAgIHRoaXMuX3NldEZpbGxTdHlsZXMoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHQoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHREZWNvcmF0aW9uKGN0eCk7XG4gICAgICB0aGlzLmNsaXBUbyAmJiBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0RmlsbChjdHgpO1xuICAgICAgdGhpcy5fcmVuZGVyVGV4dFN0cm9rZShjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfc2V0VGV4dFN0eWxlczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ2FscGhhYmV0aWMnO1xuICAgICAgY3R4LmZvbnQgPSB0aGlzLl9nZXRGb250RGVjbGFyYXRpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEhlaWdodCBvZiBmYWJyaWMuVGV4dCBvYmplY3RcbiAgICAgKi9cbiAgICBfZ2V0VGV4dEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0SGVpZ2h0T2ZTaW5nbGVMaW5lKCkgKyAodGhpcy5fdGV4dExpbmVzLmxlbmd0aCAtIDEpICogdGhpcy5fZ2V0SGVpZ2h0T2ZMaW5lKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTWF4aW11bSB3aWR0aCBvZiBmYWJyaWMuVGV4dCBvYmplY3RcbiAgICAgKi9cbiAgICBfZ2V0VGV4dFdpZHRoOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBtYXhXaWR0aCA9IHRoaXMuX2dldExpbmVXaWR0aChjdHgsIDApO1xuXG4gICAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJyZW50TGluZVdpZHRoID0gdGhpcy5fZ2V0TGluZVdpZHRoKGN0eCwgaSk7XG4gICAgICAgIGlmIChjdXJyZW50TGluZVdpZHRoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICBtYXhXaWR0aCA9IGN1cnJlbnRMaW5lV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXhXaWR0aDtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgb2JqZWN0IGRpbWVuc2lvbnMgZnJvbSBpdHMgcHJvcGVydGllc1xuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4geyB4OiB0aGlzLndpZHRoLCB5OiB0aGlzLmhlaWdodCB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgTWV0aG9kIG5hbWUgKFwiZmlsbFRleHRcIiBvciBcInN0cm9rZVRleHRcIilcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNoYXJzIENoYXJzIHRvIHJlbmRlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IExlZnQgcG9zaXRpb24gb2YgdGV4dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgVG9wIHBvc2l0aW9uIG9mIHRleHRcbiAgICAgKi9cbiAgICBfcmVuZGVyQ2hhcnM6IGZ1bmN0aW9uKG1ldGhvZCwgY3R4LCBjaGFycywgbGVmdCwgdG9wKSB7XG4gICAgICAvLyByZW1vdmUgVGV4dCB3b3JkIGZyb20gbWV0aG9kIHZhclxuICAgICAgdmFyIHNob3J0TSA9IG1ldGhvZC5zbGljZSgwLCAtNCksIGNoYXIsIHdpZHRoO1xuICAgICAgaWYgKHRoaXNbc2hvcnRNXS50b0xpdmUpIHtcbiAgICAgICAgdmFyIG9mZnNldFggPSAtdGhpcy53aWR0aCAvIDIgKyB0aGlzW3Nob3J0TV0ub2Zmc2V0WCB8fCAwLFxuICAgICAgICAgICAgb2Zmc2V0WSA9IC10aGlzLmhlaWdodCAvIDIgKyB0aGlzW3Nob3J0TV0ub2Zmc2V0WSB8fCAwO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgICBsZWZ0IC09IG9mZnNldFg7XG4gICAgICAgIHRvcCAtPSBvZmZzZXRZO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2hhclNwYWNpbmcgIT09IDApIHtcbiAgICAgICAgdmFyIGFkZGl0aW9uYWxTcGFjZSA9IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpO1xuICAgICAgICBjaGFycyA9IGNoYXJzLnNwbGl0KCcnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoYXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY2hhciA9IGNoYXJzW2ldO1xuICAgICAgICAgIHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGNoYXIpLndpZHRoICsgYWRkaXRpb25hbFNwYWNlO1xuICAgICAgICAgIGN0eFttZXRob2RdKGNoYXIsIGxlZnQsIHRvcCk7XG4gICAgICAgICAgbGVmdCArPSB3aWR0aCA+IDAgPyB3aWR0aCA6IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjdHhbbWV0aG9kXShjaGFycywgbGVmdCwgdG9wKTtcbiAgICAgIH1cbiAgICAgIHRoaXNbc2hvcnRNXS50b0xpdmUgJiYgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIE1ldGhvZCBuYW1lIChcImZpbGxUZXh0XCIgb3IgXCJzdHJva2VUZXh0XCIpXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lIFRleHQgdG8gcmVuZGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBwb3NpdGlvbiBvZiB0ZXh0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgcG9zaXRpb24gb2YgdGV4dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggSW5kZXggb2YgYSBsaW5lIGluIGEgdGV4dFxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0TGluZTogZnVuY3Rpb24obWV0aG9kLCBjdHgsIGxpbmUsIGxlZnQsIHRvcCwgbGluZUluZGV4KSB7XG4gICAgICAvLyBsaWZ0IHRoZSBsaW5lIGJ5IHF1YXJ0ZXIgb2YgZm9udFNpemVcbiAgICAgIHRvcCAtPSB0aGlzLmZvbnRTaXplICogdGhpcy5fZm9udFNpemVGcmFjdGlvbjtcblxuICAgICAgLy8gc2hvcnQtY2lyY3VpdFxuICAgICAgdmFyIGxpbmVXaWR0aCA9IHRoaXMuX2dldExpbmVXaWR0aChjdHgsIGxpbmVJbmRleCk7XG4gICAgICBpZiAodGhpcy50ZXh0QWxpZ24gIT09ICdqdXN0aWZ5JyB8fCB0aGlzLndpZHRoIDwgbGluZVdpZHRoKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlckNoYXJzKG1ldGhvZCwgY3R4LCBsaW5lLCBsZWZ0LCB0b3AsIGxpbmVJbmRleCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gc3RyZXRjaCB0aGUgbGluZVxuICAgICAgdmFyIHdvcmRzID0gbGluZS5zcGxpdCgvXFxzKy8pLFxuICAgICAgICAgIGNoYXJPZmZzZXQgPSAwLFxuICAgICAgICAgIHdvcmRzV2lkdGggPSB0aGlzLl9nZXRXaWR0aE9mV29yZHMoY3R4LCB3b3Jkcy5qb2luKCcnKSwgbGluZUluZGV4LCAwKSxcbiAgICAgICAgICB3aWR0aERpZmYgPSB0aGlzLndpZHRoIC0gd29yZHNXaWR0aCxcbiAgICAgICAgICBudW1TcGFjZXMgPSB3b3Jkcy5sZW5ndGggLSAxLFxuICAgICAgICAgIHNwYWNlV2lkdGggPSBudW1TcGFjZXMgPiAwID8gd2lkdGhEaWZmIC8gbnVtU3BhY2VzIDogMCxcbiAgICAgICAgICBsZWZ0T2Zmc2V0ID0gMCwgd29yZDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHdvcmRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHdoaWxlIChsaW5lW2NoYXJPZmZzZXRdID09PSAnICcgJiYgY2hhck9mZnNldCA8IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgY2hhck9mZnNldCsrO1xuICAgICAgICB9XG4gICAgICAgIHdvcmQgPSB3b3Jkc1tpXTtcbiAgICAgICAgdGhpcy5fcmVuZGVyQ2hhcnMobWV0aG9kLCBjdHgsIHdvcmQsIGxlZnQgKyBsZWZ0T2Zmc2V0LCB0b3AsIGxpbmVJbmRleCwgY2hhck9mZnNldCk7XG4gICAgICAgIGxlZnRPZmZzZXQgKz0gdGhpcy5fZ2V0V2lkdGhPZldvcmRzKGN0eCwgd29yZCwgbGluZUluZGV4LCBjaGFyT2Zmc2V0KSArIHNwYWNlV2lkdGg7XG4gICAgICAgIGNoYXJPZmZzZXQgKz0gd29yZC5sZW5ndGg7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB3b3JkXG4gICAgICovXG4gICAgX2dldFdpZHRoT2ZXb3JkczogZnVuY3Rpb24gKGN0eCwgd29yZCkge1xuICAgICAgdmFyIHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHdvcmQpLndpZHRoLCBjaGFyQ291bnQsIGFkZGl0aW9uYWxTcGFjZTtcbiAgICAgIGlmICh0aGlzLmNoYXJTcGFjaW5nICE9PSAwKSB7XG4gICAgICAgIGNoYXJDb3VudCA9IHdvcmQuc3BsaXQoJycpLmxlbmd0aDtcbiAgICAgICAgYWRkaXRpb25hbFNwYWNlID0gY2hhckNvdW50ICogdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCk7XG4gICAgICAgIHdpZHRoICs9IGFkZGl0aW9uYWxTcGFjZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aWR0aCA+IDAgPyB3aWR0aCA6IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBMZWZ0IG9mZnNldFxuICAgICAqL1xuICAgIF9nZXRMZWZ0T2Zmc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAtdGhpcy53aWR0aCAvIDI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUb3Agb2Zmc2V0XG4gICAgICovXG4gICAgX2dldFRvcE9mZnNldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gLXRoaXMuaGVpZ2h0IC8gMjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGJlY2F1c2UgdGV4dCBoYXMgbm8gc3R5bGVcbiAgICAgKi9cbiAgICBpc0VtcHR5U3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIE1ldGhvZCBuYW1lIChcImZpbGxUZXh0XCIgb3IgXCJzdHJva2VUZXh0XCIpXG4gICAgICovXG4gICAgX3JlbmRlclRleHRDb21tb246IGZ1bmN0aW9uKGN0eCwgbWV0aG9kKSB7XG5cbiAgICAgIHZhciBsaW5lSGVpZ2h0cyA9IDAsIGxlZnQgPSB0aGlzLl9nZXRMZWZ0T2Zmc2V0KCksIHRvcCA9IHRoaXMuX2dldFRvcE9mZnNldCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBoZWlnaHRPZkxpbmUgPSB0aGlzLl9nZXRIZWlnaHRPZkxpbmUoY3R4LCBpKSxcbiAgICAgICAgICAgIG1heEhlaWdodCA9IGhlaWdodE9mTGluZSAvIHRoaXMubGluZUhlaWdodCxcbiAgICAgICAgICAgIGxpbmVXaWR0aCA9IHRoaXMuX2dldExpbmVXaWR0aChjdHgsIGkpLFxuICAgICAgICAgICAgbGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGxpbmVXaWR0aCk7XG4gICAgICAgIHRoaXMuX3JlbmRlclRleHRMaW5lKFxuICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICBjdHgsXG4gICAgICAgICAgdGhpcy5fdGV4dExpbmVzW2ldLFxuICAgICAgICAgIGxlZnQgKyBsZWZ0T2Zmc2V0LFxuICAgICAgICAgIHRvcCArIGxpbmVIZWlnaHRzICsgbWF4SGVpZ2h0LFxuICAgICAgICAgIGlcbiAgICAgICAgKTtcbiAgICAgICAgbGluZUhlaWdodHMgKz0gaGVpZ2h0T2ZMaW5lO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dEZpbGw6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLmZpbGwgJiYgdGhpcy5pc0VtcHR5U3R5bGVzKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZW5kZXJUZXh0Q29tbW9uKGN0eCwgJ2ZpbGxUZXh0Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0U3Ryb2tlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICgoIXRoaXMuc3Ryb2tlIHx8IHRoaXMuc3Ryb2tlV2lkdGggPT09IDApICYmIHRoaXMuaXNFbXB0eVN0eWxlcygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2hhZG93ICYmICF0aGlzLnNoYWRvdy5hZmZlY3RTdHJva2UpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU2hhZG93KGN0eCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLl9zZXRMaW5lRGFzaChjdHgsIHRoaXMuc3Ryb2tlZGFzaEFycmF5KTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHRDb21tb24oY3R4LCAnc3Ryb2tlVGV4dCcpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGhlaWdodCBvZiBsaW5lXG4gICAgICovXG4gICAgX2dldEhlaWdodE9mTGluZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0SGVpZ2h0T2ZTaW5nbGVMaW5lKCkgKiB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBoZWlnaHQgb2YgbGluZSB3aXRob3V0IGxpbmVIZWlnaHRcbiAgICAgKi9cbiAgICBfZ2V0SGVpZ2h0T2ZTaW5nbGVMaW5lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvbnRTaXplICogdGhpcy5fZm9udFNpemVNdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dEJhY2tncm91bmQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5fcmVuZGVyQmFja2dyb3VuZChjdHgpO1xuICAgICAgdGhpcy5fcmVuZGVyVGV4dExpbmVzQmFja2dyb3VuZChjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dExpbmVzQmFja2dyb3VuZDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMudGV4dEJhY2tncm91bmRDb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbGluZVRvcE9mZnNldCA9IDAsIGhlaWdodE9mTGluZSxcbiAgICAgICAgICBsaW5lV2lkdGgsIGxpbmVMZWZ0T2Zmc2V0O1xuXG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy50ZXh0QmFja2dyb3VuZENvbG9yO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBoZWlnaHRPZkxpbmUgPSB0aGlzLl9nZXRIZWlnaHRPZkxpbmUoY3R4LCBpKTtcbiAgICAgICAgbGluZVdpZHRoID0gdGhpcy5fZ2V0TGluZVdpZHRoKGN0eCwgaSk7XG4gICAgICAgIGlmIChsaW5lV2lkdGggPiAwKSB7XG4gICAgICAgICAgbGluZUxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChsaW5lV2lkdGgpO1xuICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgIHRoaXMuX2dldExlZnRPZmZzZXQoKSArIGxpbmVMZWZ0T2Zmc2V0LFxuICAgICAgICAgICAgdGhpcy5fZ2V0VG9wT2Zmc2V0KCkgKyBsaW5lVG9wT2Zmc2V0LFxuICAgICAgICAgICAgbGluZVdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0T2ZMaW5lIC8gdGhpcy5saW5lSGVpZ2h0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lVG9wT2Zmc2V0ICs9IGhlaWdodE9mTGluZTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHRoZXJlIGlzIHRleHQgYmFja2dyb3VuZCBjb2xvciBub1xuICAgICAgLy8gb3RoZXIgc2hhZG93cyBzaG91bGQgYmUgY2FzdGVkXG4gICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZVdpZHRoIFdpZHRoIG9mIHRleHQgbGluZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTGluZSBsZWZ0IG9mZnNldFxuICAgICAqL1xuICAgIF9nZXRMaW5lTGVmdE9mZnNldDogZnVuY3Rpb24obGluZVdpZHRoKSB7XG4gICAgICBpZiAodGhpcy50ZXh0QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHJldHVybiAodGhpcy53aWR0aCAtIGxpbmVXaWR0aCkgLyAyO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudGV4dEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoIC0gbGluZVdpZHRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NsZWFyQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fX2xpbmVXaWR0aHMgPSBbXTtcbiAgICAgIHRoaXMuX19saW5lSGVpZ2h0cyA9IFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zaG91bGRDbGVhckNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzaG91bGRDbGVhciA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuX2ZvcmNlQ2xlYXJDYWNoZSkge1xuICAgICAgICB0aGlzLl9mb3JjZUNsZWFyQ2FjaGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBwcm9wIGluIHRoaXMuX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzKSB7XG4gICAgICAgIGlmICh0aGlzWydfXycgKyBwcm9wXSAhPT0gdGhpc1twcm9wXSkge1xuICAgICAgICAgIHRoaXNbJ19fJyArIHByb3BdID0gdGhpc1twcm9wXTtcbiAgICAgICAgICBzaG91bGRDbGVhciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzaG91bGRDbGVhcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBsaW5lIG51bWJlclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTGluZSB3aWR0aFxuICAgICAqL1xuICAgIF9nZXRMaW5lV2lkdGg6IGZ1bmN0aW9uKGN0eCwgbGluZUluZGV4KSB7XG4gICAgICBpZiAodGhpcy5fX2xpbmVXaWR0aHNbbGluZUluZGV4XSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2xpbmVXaWR0aHNbbGluZUluZGV4XSA9PT0gLTEgPyB0aGlzLndpZHRoIDogdGhpcy5fX2xpbmVXaWR0aHNbbGluZUluZGV4XTtcbiAgICAgIH1cblxuICAgICAgdmFyIHdpZHRoLCB3b3JkQ291bnQsIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XTtcblxuICAgICAgaWYgKGxpbmUgPT09ICcnKSB7XG4gICAgICAgIHdpZHRoID0gMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB3aWR0aCA9IHRoaXMuX21lYXN1cmVMaW5lKGN0eCwgbGluZUluZGV4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19saW5lV2lkdGhzW2xpbmVJbmRleF0gPSB3aWR0aDtcblxuICAgICAgaWYgKHdpZHRoICYmIHRoaXMudGV4dEFsaWduID09PSAnanVzdGlmeScpIHtcbiAgICAgICAgd29yZENvdW50ID0gbGluZS5zcGxpdCgvXFxzKy8pO1xuICAgICAgICBpZiAod29yZENvdW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aGlzLl9fbGluZVdpZHRoc1tsaW5lSW5kZXhdID0gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9LFxuXG4gICAgX2dldFdpZHRoT2ZDaGFyU3BhY2luZzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jaGFyU3BhY2luZyAhPT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb250U2l6ZSAqIHRoaXMuY2hhclNwYWNpbmcgLyAxMDAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggbGluZSBudW1iZXJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IExpbmUgd2lkdGhcbiAgICAgKi9cbiAgICBfbWVhc3VyZUxpbmU6IGZ1bmN0aW9uKGN0eCwgbGluZUluZGV4KSB7XG4gICAgICB2YXIgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLFxuICAgICAgICAgIHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGxpbmUpLndpZHRoLFxuICAgICAgICAgIGFkZGl0aW9uYWxTcGFjZSA9IDAsIGNoYXJDb3VudCwgZmluYWxXaWR0aDtcbiAgICAgIGlmICh0aGlzLmNoYXJTcGFjaW5nICE9PSAwKSB7XG4gICAgICAgIGNoYXJDb3VudCA9IGxpbmUuc3BsaXQoJycpLmxlbmd0aDtcbiAgICAgICAgYWRkaXRpb25hbFNwYWNlID0gKGNoYXJDb3VudCAtIDEpICogdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCk7XG4gICAgICB9XG4gICAgICBmaW5hbFdpZHRoID0gd2lkdGggKyBhZGRpdGlvbmFsU3BhY2U7XG4gICAgICByZXR1cm4gZmluYWxXaWR0aCA+IDAgPyBmaW5hbFdpZHRoIDogMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclRleHREZWNvcmF0aW9uOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy50ZXh0RGVjb3JhdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaGFsZk9mVmVydGljYWxCb3ggPSB0aGlzLmhlaWdodCAvIDIsXG4gICAgICAgICAgX3RoaXMgPSB0aGlzLCBvZmZzZXRzID0gW107XG5cbiAgICAgIC8qKiBAaWdub3JlICovXG4gICAgICBmdW5jdGlvbiByZW5kZXJMaW5lc0F0T2Zmc2V0KG9mZnNldHMpIHtcbiAgICAgICAgdmFyIGksIGxpbmVIZWlnaHQgPSAwLCBsZW4sIGosIG9MZW4sIGxpbmVXaWR0aCxcbiAgICAgICAgICAgIGxpbmVMZWZ0T2Zmc2V0LCBoZWlnaHRPZkxpbmU7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gX3RoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICAgICAgbGluZVdpZHRoID0gX3RoaXMuX2dldExpbmVXaWR0aChjdHgsIGkpO1xuICAgICAgICAgIGxpbmVMZWZ0T2Zmc2V0ID0gX3RoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGxpbmVXaWR0aCk7XG4gICAgICAgICAgaGVpZ2h0T2ZMaW5lID0gX3RoaXMuX2dldEhlaWdodE9mTGluZShjdHgsIGkpO1xuXG4gICAgICAgICAgZm9yIChqID0gMCwgb0xlbiA9IG9mZnNldHMubGVuZ3RoOyBqIDwgb0xlbjsgaisrKSB7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICAgIF90aGlzLl9nZXRMZWZ0T2Zmc2V0KCkgKyBsaW5lTGVmdE9mZnNldCxcbiAgICAgICAgICAgICAgbGluZUhlaWdodCArIChfdGhpcy5fZm9udFNpemVNdWx0IC0gMSArIG9mZnNldHNbal0gKSAqIF90aGlzLmZvbnRTaXplIC0gaGFsZk9mVmVydGljYWxCb3gsXG4gICAgICAgICAgICAgIGxpbmVXaWR0aCxcbiAgICAgICAgICAgICAgX3RoaXMuZm9udFNpemUgLyAxNSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpbmVIZWlnaHQgKz0gaGVpZ2h0T2ZMaW5lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRleHREZWNvcmF0aW9uLmluZGV4T2YoJ3VuZGVybGluZScpID4gLTEpIHtcbiAgICAgICAgb2Zmc2V0cy5wdXNoKDAuODUpOyAvLyAxIC0gMy8xNlxuICAgICAgfVxuICAgICAgaWYgKHRoaXMudGV4dERlY29yYXRpb24uaW5kZXhPZignbGluZS10aHJvdWdoJykgPiAtMSkge1xuICAgICAgICBvZmZzZXRzLnB1c2goMC40Myk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCdvdmVybGluZScpID4gLTEpIHtcbiAgICAgICAgb2Zmc2V0cy5wdXNoKC0wLjEyKTtcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVuZGVyTGluZXNBdE9mZnNldChvZmZzZXRzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGZvbnQgZGVjbGFyYXRpb24gc3RyaW5nIGZvciBjYW52YXMgY29udGV4dFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IGZvbnQgZGVjbGFyYXRpb24gZm9ybWF0dGVkIGZvciBjYW52YXMgY29udGV4dC5cbiAgICAgKi9cbiAgICBfZ2V0Rm9udERlY2xhcmF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIC8vIG5vZGUtY2FudmFzIG5lZWRzIFwid2VpZ2h0IHN0eWxlXCIsIHdoaWxlIGJyb3dzZXJzIG5lZWQgXCJzdHlsZSB3ZWlnaHRcIlxuICAgICAgICAoZmFicmljLmlzTGlrZWx5Tm9kZSA/IHRoaXMuZm9udFdlaWdodCA6IHRoaXMuZm9udFN0eWxlKSxcbiAgICAgICAgKGZhYnJpYy5pc0xpa2VseU5vZGUgPyB0aGlzLmZvbnRTdHlsZSA6IHRoaXMuZm9udFdlaWdodCksXG4gICAgICAgIHRoaXMuZm9udFNpemUgKyAncHgnLFxuICAgICAgICAoZmFicmljLmlzTGlrZWx5Tm9kZSA/ICgnXCInICsgdGhpcy5mb250RmFtaWx5ICsgJ1wiJykgOiB0aGlzLmZvbnRGYW1pbHkpXG4gICAgICBdLmpvaW4oJyAnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0ZXh0IGluc3RhbmNlIG9uIGEgc3BlY2lmaWVkIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBub1RyYW5zZm9ybVxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4LCBub1RyYW5zZm9ybSkge1xuICAgICAgLy8gZG8gbm90IHJlbmRlciBpZiBvYmplY3QgaXMgbm90IHZpc2libGVcbiAgICAgIGlmICghdGhpcy52aXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuX3NldFRleHRTdHlsZXMoY3R4KTtcblxuICAgICAgaWYgKHRoaXMuX3Nob3VsZENsZWFyQ2FjaGUoKSkge1xuICAgICAgICB0aGlzLl9pbml0RGltZW5zaW9ucyhjdHgpO1xuICAgICAgfVxuICAgICAgdGhpcy5kcmF3U2VsZWN0aW9uQmFja2dyb3VuZChjdHgpO1xuICAgICAgaWYgKCFub1RyYW5zZm9ybSkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybShjdHgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudHJhbnNmb3JtTWF0cml4KSB7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0uYXBwbHkoY3R4LCB0aGlzLnRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLnR5cGUgPT09ICdwYXRoLWdyb3VwJykge1xuICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMubGVmdCwgdGhpcy50b3ApO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyKGN0eCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0ZXh0IGFzIGFuIGFycmF5IG9mIGxpbmVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gTGluZXMgaW4gdGhlIHRleHRcbiAgICAgKi9cbiAgICBfc3BsaXRUZXh0SW50b0xpbmVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQuc3BsaXQodGhpcy5fcmVOZXdsaW5lKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG9iamVjdCA9IGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSwge1xuICAgICAgICB0ZXh0OiAgICAgICAgICAgICAgICAgdGhpcy50ZXh0LFxuICAgICAgICBmb250U2l6ZTogICAgICAgICAgICAgdGhpcy5mb250U2l6ZSxcbiAgICAgICAgZm9udFdlaWdodDogICAgICAgICAgIHRoaXMuZm9udFdlaWdodCxcbiAgICAgICAgZm9udEZhbWlseTogICAgICAgICAgIHRoaXMuZm9udEZhbWlseSxcbiAgICAgICAgZm9udFN0eWxlOiAgICAgICAgICAgIHRoaXMuZm9udFN0eWxlLFxuICAgICAgICBsaW5lSGVpZ2h0OiAgICAgICAgICAgdGhpcy5saW5lSGVpZ2h0LFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogICAgICAgdGhpcy50ZXh0RGVjb3JhdGlvbixcbiAgICAgICAgdGV4dEFsaWduOiAgICAgICAgICAgIHRoaXMudGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFja2dyb3VuZENvbG9yOiAgdGhpcy50ZXh0QmFja2dyb3VuZENvbG9yLFxuICAgICAgICBjaGFyU3BhY2luZzogICAgICAgICAgdGhpcy5jaGFyU3BhY2luZ1xuICAgICAgfSk7XG4gICAgICBpZiAoIXRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRGVmYXVsdFZhbHVlcyhvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgaWYgKCF0aGlzLmN0eCkge1xuICAgICAgICB0aGlzLmN0eCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgfVxuICAgICAgdmFyIG1hcmt1cCA9IHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAoKSxcbiAgICAgICAgICBvZmZzZXRzID0gdGhpcy5fZ2V0U1ZHTGVmdFRvcE9mZnNldHModGhpcy5jdHgpLFxuICAgICAgICAgIHRleHRBbmRCZyA9IHRoaXMuX2dldFNWR1RleHRBbmRCZyhvZmZzZXRzLnRleHRUb3AsIG9mZnNldHMudGV4dExlZnQpO1xuICAgICAgdGhpcy5fd3JhcFNWR1RleHRBbmRCZyhtYXJrdXAsIHRleHRBbmRCZyk7XG5cbiAgICAgIHJldHVybiByZXZpdmVyID8gcmV2aXZlcihtYXJrdXAuam9pbignJykpIDogbWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRTVkdMZWZ0VG9wT2Zmc2V0czogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgbGluZVRvcCA9IHRoaXMuX2dldEhlaWdodE9mTGluZShjdHgsIDApLFxuICAgICAgICAgIHRleHRMZWZ0ID0gLXRoaXMud2lkdGggLyAyLFxuICAgICAgICAgIHRleHRUb3AgPSAwO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0TGVmdDogdGV4dExlZnQgKyAodGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLnR5cGUgPT09ICdwYXRoLWdyb3VwJyA/IHRoaXMubGVmdCA6IDApLFxuICAgICAgICB0ZXh0VG9wOiB0ZXh0VG9wICsgKHRoaXMuZ3JvdXAgJiYgdGhpcy5ncm91cC50eXBlID09PSAncGF0aC1ncm91cCcgPyAtdGhpcy50b3AgOiAwKSxcbiAgICAgICAgbGluZVRvcDogbGluZVRvcFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfd3JhcFNWR1RleHRBbmRCZzogZnVuY3Rpb24obWFya3VwLCB0ZXh0QW5kQmcpIHtcbiAgICAgIHZhciBub1NoYWRvdyA9IHRydWUsIGZpbHRlciA9IHRoaXMuZ2V0U3ZnRmlsdGVyKCksXG4gICAgICAgICAgc3R5bGUgPSBmaWx0ZXIgPT09ICcnID8gJycgOiAnIHN0eWxlPVwiJyArIGZpbHRlciArICdcIic7XG5cbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnXFx0PGcgJywgdGhpcy5nZXRTdmdJZCgpLCAndHJhbnNmb3JtPVwiJywgdGhpcy5nZXRTdmdUcmFuc2Zvcm0oKSwgdGhpcy5nZXRTdmdUcmFuc2Zvcm1NYXRyaXgoKSwgJ1wiJyxcbiAgICAgICAgICBzdHlsZSwgJz5cXG4nLFxuICAgICAgICAgIHRleHRBbmRCZy50ZXh0QmdSZWN0cy5qb2luKCcnKSxcbiAgICAgICAgICAnXFx0XFx0PHRleHQgJyxcbiAgICAgICAgICAgICh0aGlzLmZvbnRGYW1pbHkgPyAnZm9udC1mYW1pbHk9XCInICsgdGhpcy5mb250RmFtaWx5LnJlcGxhY2UoL1wiL2csICdcXCcnKSArICdcIiAnIDogJycpLFxuICAgICAgICAgICAgKHRoaXMuZm9udFNpemUgPyAnZm9udC1zaXplPVwiJyArIHRoaXMuZm9udFNpemUgKyAnXCIgJyA6ICcnKSxcbiAgICAgICAgICAgICh0aGlzLmZvbnRTdHlsZSA/ICdmb250LXN0eWxlPVwiJyArIHRoaXMuZm9udFN0eWxlICsgJ1wiICcgOiAnJyksXG4gICAgICAgICAgICAodGhpcy5mb250V2VpZ2h0ID8gJ2ZvbnQtd2VpZ2h0PVwiJyArIHRoaXMuZm9udFdlaWdodCArICdcIiAnIDogJycpLFxuICAgICAgICAgICAgKHRoaXMudGV4dERlY29yYXRpb24gPyAndGV4dC1kZWNvcmF0aW9uPVwiJyArIHRoaXMudGV4dERlY29yYXRpb24gKyAnXCIgJyA6ICcnKSxcbiAgICAgICAgICAgICdzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKG5vU2hhZG93KSwgJ1wiID5cXG4nLFxuICAgICAgICAgICAgdGV4dEFuZEJnLnRleHRTcGFucy5qb2luKCcnKSxcbiAgICAgICAgICAnXFx0XFx0PC90ZXh0PlxcbicsXG4gICAgICAgICdcXHQ8L2c+XFxuJ1xuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGV4dFRvcE9mZnNldCBUZXh0IHRvcCBvZmZzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGV4dExlZnRPZmZzZXQgVGV4dCBsZWZ0IG9mZnNldFxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBfZ2V0U1ZHVGV4dEFuZEJnOiBmdW5jdGlvbih0ZXh0VG9wT2Zmc2V0LCB0ZXh0TGVmdE9mZnNldCkge1xuICAgICAgdmFyIHRleHRTcGFucyA9IFtdLFxuICAgICAgICAgIHRleHRCZ1JlY3RzID0gW10sXG4gICAgICAgICAgaGVpZ2h0ID0gMDtcbiAgICAgIC8vIGJvdW5kaW5nLWJveCBiYWNrZ3JvdW5kXG4gICAgICB0aGlzLl9zZXRTVkdCZyh0ZXh0QmdSZWN0cyk7XG5cbiAgICAgIC8vIHRleHQgYW5kIHRleHQtYmFja2dyb3VuZFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAodGhpcy50ZXh0QmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgICAgdGhpcy5fc2V0U1ZHVGV4dExpbmVCZyh0ZXh0QmdSZWN0cywgaSwgdGV4dExlZnRPZmZzZXQsIHRleHRUb3BPZmZzZXQsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0U1ZHVGV4dExpbmVUZXh0KGksIHRleHRTcGFucywgaGVpZ2h0LCB0ZXh0TGVmdE9mZnNldCwgdGV4dFRvcE9mZnNldCwgdGV4dEJnUmVjdHMpO1xuICAgICAgICBoZWlnaHQgKz0gdGhpcy5fZ2V0SGVpZ2h0T2ZMaW5lKHRoaXMuY3R4LCBpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dFNwYW5zOiB0ZXh0U3BhbnMsXG4gICAgICAgIHRleHRCZ1JlY3RzOiB0ZXh0QmdSZWN0c1xuICAgICAgfTtcbiAgICB9LFxuXG4gICAgX3NldFNWR1RleHRMaW5lVGV4dDogZnVuY3Rpb24oaSwgdGV4dFNwYW5zLCBoZWlnaHQsIHRleHRMZWZ0T2Zmc2V0LCB0ZXh0VG9wT2Zmc2V0KSB7XG4gICAgICB2YXIgeVBvcyA9IHRoaXMuZm9udFNpemUgKiAodGhpcy5fZm9udFNpemVNdWx0IC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbilcbiAgICAgICAgLSB0ZXh0VG9wT2Zmc2V0ICsgaGVpZ2h0IC0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgaWYgKHRoaXMudGV4dEFsaWduID09PSAnanVzdGlmeScpIHtcbiAgICAgICAgLy8gaSBjYWxsIGZyb20gaGVyZSB0byBkbyBub3QgaW50ZWZlcmUgd2l0aCBJVGV4dFxuICAgICAgICB0aGlzLl9zZXRTVkdUZXh0TGluZUp1c3RpZmVkKGksIHRleHRTcGFucywgeVBvcywgdGV4dExlZnRPZmZzZXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0ZXh0U3BhbnMucHVzaChcbiAgICAgICAgJ1xcdFxcdFxcdDx0c3BhbiB4PVwiJyxcbiAgICAgICAgICB0b0ZpeGVkKHRleHRMZWZ0T2Zmc2V0ICsgdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQodGhpcy5fZ2V0TGluZVdpZHRoKHRoaXMuY3R4LCBpKSksIE5VTV9GUkFDVElPTl9ESUdJVFMpLCAnXCIgJyxcbiAgICAgICAgICAneT1cIicsXG4gICAgICAgICAgdG9GaXhlZCh5UG9zLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAnXCIgJyxcbiAgICAgICAgICAvLyBkb2luZyB0aGlzIG9uIDx0c3Bhbj4gZWxlbWVudHMgc2luY2Ugc2V0dGluZyBvcGFjaXR5XG4gICAgICAgICAgLy8gb24gY29udGFpbmluZyA8dGV4dD4gb25lIGRvZXNuJ3Qgd29yayBpbiBJbGx1c3RyYXRvclxuICAgICAgICAgIHRoaXMuX2dldEZpbGxBdHRyaWJ1dGVzKHRoaXMuZmlsbCksICc+JyxcbiAgICAgICAgICBmYWJyaWMudXRpbC5zdHJpbmcuZXNjYXBlWG1sKHRoaXMuX3RleHRMaW5lc1tpXSksXG4gICAgICAgICc8L3RzcGFuPlxcbidcbiAgICAgICk7XG4gICAgfSxcblxuICAgIF9zZXRTVkdUZXh0TGluZUp1c3RpZmVkOiBmdW5jdGlvbihpLCB0ZXh0U3BhbnMsIHlQb3MsIHRleHRMZWZ0T2Zmc2V0KSB7XG4gICAgICB2YXIgY3R4ID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgIHRoaXMuX3NldFRleHRTdHlsZXMoY3R4KTtcblxuICAgICAgdmFyIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbaV0sXG4gICAgICAgICAgd29yZHMgPSBsaW5lLnNwbGl0KC9cXHMrLyksXG4gICAgICAgICAgd29yZHNXaWR0aCA9IHRoaXMuX2dldFdpZHRoT2ZXb3JkcyhjdHgsIHdvcmRzLmpvaW4oJycpKSxcbiAgICAgICAgICB3aWR0aERpZmYgPSB0aGlzLndpZHRoIC0gd29yZHNXaWR0aCxcbiAgICAgICAgICBudW1TcGFjZXMgPSB3b3Jkcy5sZW5ndGggLSAxLFxuICAgICAgICAgIHNwYWNlV2lkdGggPSBudW1TcGFjZXMgPiAwID8gd2lkdGhEaWZmIC8gbnVtU3BhY2VzIDogMCxcbiAgICAgICAgICB3b3JkLCBhdHRyaWJ1dGVzID0gdGhpcy5fZ2V0RmlsbEF0dHJpYnV0ZXModGhpcy5maWxsKSxcbiAgICAgICAgICBsZW47XG5cbiAgICAgIHRleHRMZWZ0T2Zmc2V0ICs9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KHRoaXMuX2dldExpbmVXaWR0aChjdHgsIGkpKTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gd29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgd29yZCA9IHdvcmRzW2ldO1xuICAgICAgICB0ZXh0U3BhbnMucHVzaChcbiAgICAgICAgICAnXFx0XFx0XFx0PHRzcGFuIHg9XCInLFxuICAgICAgICAgICAgdG9GaXhlZCh0ZXh0TGVmdE9mZnNldCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksICdcIiAnLFxuICAgICAgICAgICAgJ3k9XCInLFxuICAgICAgICAgICAgdG9GaXhlZCh5UG9zLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgICdcIiAnLFxuICAgICAgICAgICAgLy8gZG9pbmcgdGhpcyBvbiA8dHNwYW4+IGVsZW1lbnRzIHNpbmNlIHNldHRpbmcgb3BhY2l0eVxuICAgICAgICAgICAgLy8gb24gY29udGFpbmluZyA8dGV4dD4gb25lIGRvZXNuJ3Qgd29yayBpbiBJbGx1c3RyYXRvclxuICAgICAgICAgICAgYXR0cmlidXRlcywgJz4nLFxuICAgICAgICAgICAgZmFicmljLnV0aWwuc3RyaW5nLmVzY2FwZVhtbCh3b3JkKSxcbiAgICAgICAgICAnPC90c3Bhbj5cXG4nXG4gICAgICAgICk7XG4gICAgICAgIHRleHRMZWZ0T2Zmc2V0ICs9IHRoaXMuX2dldFdpZHRoT2ZXb3JkcyhjdHgsIHdvcmQpICsgc3BhY2VXaWR0aDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NldFNWR1RleHRMaW5lQmc6IGZ1bmN0aW9uKHRleHRCZ1JlY3RzLCBpLCB0ZXh0TGVmdE9mZnNldCwgdGV4dFRvcE9mZnNldCwgaGVpZ2h0KSB7XG4gICAgICB0ZXh0QmdSZWN0cy5wdXNoKFxuICAgICAgICAnXFx0XFx0PHJlY3QgJyxcbiAgICAgICAgICB0aGlzLl9nZXRGaWxsQXR0cmlidXRlcyh0aGlzLnRleHRCYWNrZ3JvdW5kQ29sb3IpLFxuICAgICAgICAgICcgeD1cIicsXG4gICAgICAgICAgdG9GaXhlZCh0ZXh0TGVmdE9mZnNldCArIHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KHRoaXMuX2dldExpbmVXaWR0aCh0aGlzLmN0eCwgaSkpLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAnXCIgeT1cIicsXG4gICAgICAgICAgdG9GaXhlZChoZWlnaHQgLSB0aGlzLmhlaWdodCAvIDIsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICdcIiB3aWR0aD1cIicsXG4gICAgICAgICAgdG9GaXhlZCh0aGlzLl9nZXRMaW5lV2lkdGgodGhpcy5jdHgsIGkpLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAnXCIgaGVpZ2h0PVwiJyxcbiAgICAgICAgICB0b0ZpeGVkKHRoaXMuX2dldEhlaWdodE9mTGluZSh0aGlzLmN0eCwgaSkgLyB0aGlzLmxpbmVIZWlnaHQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAnXCI+PC9yZWN0PlxcbicpO1xuICAgIH0sXG5cbiAgICBfc2V0U1ZHQmc6IGZ1bmN0aW9uKHRleHRCZ1JlY3RzKSB7XG4gICAgICBpZiAodGhpcy5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgdGV4dEJnUmVjdHMucHVzaChcbiAgICAgICAgICAnXFx0XFx0PHJlY3QgJyxcbiAgICAgICAgICAgIHRoaXMuX2dldEZpbGxBdHRyaWJ1dGVzKHRoaXMuYmFja2dyb3VuZENvbG9yKSxcbiAgICAgICAgICAgICcgeD1cIicsXG4gICAgICAgICAgICB0b0ZpeGVkKC10aGlzLndpZHRoIC8gMiwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICAnXCIgeT1cIicsXG4gICAgICAgICAgICB0b0ZpeGVkKC10aGlzLmhlaWdodCAvIDIsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgJ1wiIHdpZHRoPVwiJyxcbiAgICAgICAgICAgIHRvRml4ZWQodGhpcy53aWR0aCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICAnXCIgaGVpZ2h0PVwiJyxcbiAgICAgICAgICAgIHRvRml4ZWQodGhpcy5oZWlnaHQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICdcIj48L3JlY3Q+XFxuJyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkb2JlIElsbHVzdHJhdG9yIChhdCBsZWFzdCBDUzUpIGlzIHVuYWJsZSB0byByZW5kZXIgcmdiYSgpLWJhc2VkIGZpbGwgdmFsdWVzXG4gICAgICogd2Ugd29yayBhcm91bmQgaXQgYnkgXCJtb3ZpbmdcIiBhbHBoYSBjaGFubmVsIGludG8gb3BhY2l0eSBhdHRyaWJ1dGUgYW5kIHNldHRpbmcgZmlsbCdzIGFscGhhIHRvIDFcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBfZ2V0RmlsbEF0dHJpYnV0ZXM6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgZmlsbENvbG9yID0gKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpID8gbmV3IGZhYnJpYy5Db2xvcih2YWx1ZSkgOiAnJztcbiAgICAgIGlmICghZmlsbENvbG9yIHx8ICFmaWxsQ29sb3IuZ2V0U291cmNlKCkgfHwgZmlsbENvbG9yLmdldEFscGhhKCkgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuICdmaWxsPVwiJyArIHZhbHVlICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnb3BhY2l0eT1cIicgKyBmaWxsQ29sb3IuZ2V0QWxwaGEoKSArICdcIiBmaWxsPVwiJyArIGZpbGxDb2xvci5zZXRBbHBoYSgxKS50b1JnYigpICsgJ1wiJztcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBzcGVjaWZpZWQgcHJvcGVydHkgdG8gYSBzcGVjaWZpZWQgdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5UZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0Jywga2V5LCB2YWx1ZSk7XG5cbiAgICAgIGlmIChrZXkgaW4gdGhpcy5fZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMpIHtcbiAgICAgICAgdGhpcy5faW5pdERpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb21wbGV4aXR5IG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBjb21wbGV4aXR5XG4gICAgICovXG4gICAgY29tcGxleGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLlRleHQuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dFxuICAgKiBAc2VlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvdGV4dC5odG1sI1RleHRFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuVGV4dC5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KFxuICAgICd4IHkgZHggZHkgZm9udC1mYW1pbHkgZm9udC1zdHlsZSBmb250LXdlaWdodCBmb250LXNpemUgdGV4dC1kZWNvcmF0aW9uIHRleHQtYW5jaG9yJy5zcGxpdCgnICcpKTtcblxuICAvKipcbiAgICogRGVmYXVsdCBTVkcgZm9udCBzaXplXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0XG4gICAqL1xuICBmYWJyaWMuVGV4dC5ERUZBVUxUX1NWR19GT05UX1NJWkUgPSAxNjtcblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuVGV4dCBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50ICg8Yj5ub3QgeWV0IGltcGxlbWVudGVkPC9iPilcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHRcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dH0gSW5zdGFuY2Ugb2YgZmFicmljLlRleHRcbiAgICovXG4gIGZhYnJpYy5UZXh0LmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5UZXh0LkFUVFJJQlVURV9OQU1FUyk7XG4gICAgb3B0aW9ucyA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoKG9wdGlvbnMgPyBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUob3B0aW9ucykgOiB7IH0pLCBwYXJzZWRBdHRyaWJ1dGVzKTtcblxuICAgIG9wdGlvbnMudG9wID0gb3B0aW9ucy50b3AgfHwgMDtcbiAgICBvcHRpb25zLmxlZnQgPSBvcHRpb25zLmxlZnQgfHwgMDtcbiAgICBpZiAoJ2R4JyBpbiBwYXJzZWRBdHRyaWJ1dGVzKSB7XG4gICAgICBvcHRpb25zLmxlZnQgKz0gcGFyc2VkQXR0cmlidXRlcy5keDtcbiAgICB9XG4gICAgaWYgKCdkeScgaW4gcGFyc2VkQXR0cmlidXRlcykge1xuICAgICAgb3B0aW9ucy50b3AgKz0gcGFyc2VkQXR0cmlidXRlcy5keTtcbiAgICB9XG4gICAgaWYgKCEoJ2ZvbnRTaXplJyBpbiBvcHRpb25zKSkge1xuICAgICAgb3B0aW9ucy5mb250U2l6ZSA9IGZhYnJpYy5UZXh0LkRFRkFVTFRfU1ZHX0ZPTlRfU0laRTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMub3JpZ2luWCkge1xuICAgICAgb3B0aW9ucy5vcmlnaW5YID0gJ2xlZnQnO1xuICAgIH1cblxuICAgIHZhciB0ZXh0Q29udGVudCA9ICcnO1xuXG4gICAgLy8gVGhlIFhNTCBpcyBub3QgcHJvcGVybHkgcGFyc2VkIGluIElFOSBzbyBhIHdvcmthcm91bmQgdG8gZ2V0XG4gICAgLy8gdGV4dENvbnRlbnQgaXMgdGhyb3VnaCBmaXJzdENoaWxkLmRhdGEuIEFub3RoZXIgd29ya2Fyb3VuZCB3b3VsZCBiZVxuICAgIC8vIHRvIGNvbnZlcnQgWE1MIGxvYWRlZCBmcm9tIGEgZmlsZSB0byBiZSBjb252ZXJ0ZWQgdXNpbmcgRE9NUGFyc2VyIChzYW1lIHdheSBsb2FkU1ZHRnJvbVN0cmluZygpIGRvZXMpXG4gICAgaWYgKCEoJ3RleHRDb250ZW50JyBpbiBlbGVtZW50KSkge1xuICAgICAgaWYgKCdmaXJzdENoaWxkJyBpbiBlbGVtZW50ICYmIGVsZW1lbnQuZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoJ2RhdGEnIGluIGVsZW1lbnQuZmlyc3RDaGlsZCAmJiBlbGVtZW50LmZpcnN0Q2hpbGQuZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgIHRleHRDb250ZW50ID0gZWxlbWVudC5maXJzdENoaWxkLmRhdGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0ZXh0Q29udGVudCA9IGVsZW1lbnQudGV4dENvbnRlbnQ7XG4gICAgfVxuXG4gICAgdGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5yZXBsYWNlKC9eXFxzK3xcXHMrJHxcXG4rL2csICcnKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG5cbiAgICB2YXIgdGV4dCA9IG5ldyBmYWJyaWMuVGV4dCh0ZXh0Q29udGVudCwgb3B0aW9ucyksXG4gICAgICAgIHRleHRIZWlnaHRTY2FsZUZhY3RvciA9IHRleHQuZ2V0SGVpZ2h0KCkgLyB0ZXh0LmhlaWdodCxcbiAgICAgICAgbGluZUhlaWdodERpZmYgPSAodGV4dC5oZWlnaHQgKyB0ZXh0LnN0cm9rZVdpZHRoKSAqIHRleHQubGluZUhlaWdodCAtIHRleHQuaGVpZ2h0LFxuICAgICAgICBzY2FsZWREaWZmID0gbGluZUhlaWdodERpZmYgKiB0ZXh0SGVpZ2h0U2NhbGVGYWN0b3IsXG4gICAgICAgIHRleHRIZWlnaHQgPSB0ZXh0LmdldEhlaWdodCgpICsgc2NhbGVkRGlmZixcbiAgICAgICAgb2ZmWCA9IDA7XG4gICAgLypcbiAgICAgIEFkanVzdCBwb3NpdGlvbmluZzpcbiAgICAgICAgeC95IGF0dHJpYnV0ZXMgaW4gU1ZHIGNvcnJlc3BvbmQgdG8gdGhlIGJvdHRvbS1sZWZ0IGNvcm5lciBvZiB0ZXh0IGJvdW5kaW5nIGJveFxuICAgICAgICB0b3AvbGVmdCBwcm9wZXJ0aWVzIGluIEZhYnJpYyBjb3JyZXNwb25kIHRvIGNlbnRlciBwb2ludCBvZiB0ZXh0IGJvdW5kaW5nIGJveFxuICAgICovXG4gICAgaWYgKHRleHQub3JpZ2luWCA9PT0gJ2xlZnQnKSB7XG4gICAgICBvZmZYID0gdGV4dC5nZXRXaWR0aCgpIC8gMjtcbiAgICB9XG4gICAgaWYgKHRleHQub3JpZ2luWCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgb2ZmWCA9IC10ZXh0LmdldFdpZHRoKCkgLyAyO1xuICAgIH1cbiAgICB0ZXh0LnNldCh7XG4gICAgICBsZWZ0OiB0ZXh0LmdldExlZnQoKSArIG9mZlgsXG4gICAgICB0b3A6IHRleHQuZ2V0VG9wKCkgLSB0ZXh0SGVpZ2h0IC8gMiArIHRleHQuZm9udFNpemUgKiAoMC4xOCArIHRleHQuX2ZvbnRTaXplRnJhY3Rpb24pIC8gdGV4dC5saW5lSGVpZ2h0IC8qIDAuMyBpcyB0aGUgb2xkIGxpbmVIZWlnaHQgKi9cbiAgICB9KTtcblxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5UZXh0IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlRleHQgaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dH0gSW5zdGFuY2Ugb2YgZmFicmljLlRleHRcbiAgICovXG4gIGZhYnJpYy5UZXh0LmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHRleHQgPSBuZXcgZmFicmljLlRleHQob2JqZWN0LnRleHQsIGNsb25lKG9iamVjdCkpO1xuICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHRleHQpO1xuICAgIHJldHVybiB0ZXh0O1xuICB9O1xuXG4gIGZhYnJpYy51dGlsLmNyZWF0ZUFjY2Vzc29ycyhmYWJyaWMuVGV4dCk7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGNsb25lID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lO1xuXG4gIC8qKlxuICAgKiBJVGV4dCBjbGFzcyAoaW50cm9kdWNlZCBpbiA8Yj52MS40PC9iPikgRXZlbnRzIGFyZSBhbHNvIGZpcmVkIHdpdGggXCJ0ZXh0OlwiXG4gICAqIHByZWZpeCB3aGVuIG9ic2VydmluZyBjYW52YXMuXG4gICAqIEBjbGFzcyBmYWJyaWMuSVRleHRcbiAgICogQGV4dGVuZHMgZmFicmljLlRleHRcbiAgICogQG1peGVzIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqXG4gICAqIEBmaXJlcyBjaGFuZ2VkXG4gICAqIEBmaXJlcyBzZWxlY3Rpb246Y2hhbmdlZFxuICAgKiBAZmlyZXMgZWRpdGluZzplbnRlcmVkXG4gICAqIEBmaXJlcyBlZGl0aW5nOmV4aXRlZFxuICAgKlxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLklUZXh0I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqXG4gICAqIDxwPlN1cHBvcnRlZCBrZXkgY29tYmluYXRpb25zOjwvcD5cbiAgICogPHByZT5cbiAgICogICBNb3ZlIGN1cnNvcjogICAgICAgICAgICAgICAgICAgIGxlZnQsIHJpZ2h0LCB1cCwgZG93blxuICAgKiAgIFNlbGVjdCBjaGFyYWN0ZXI6ICAgICAgICAgICAgICAgc2hpZnQgKyBsZWZ0LCBzaGlmdCArIHJpZ2h0XG4gICAqICAgU2VsZWN0IHRleHQgdmVydGljYWxseTogICAgICAgICBzaGlmdCArIHVwLCBzaGlmdCArIGRvd25cbiAgICogICBNb3ZlIGN1cnNvciBieSB3b3JkOiAgICAgICAgICAgIGFsdCArIGxlZnQsIGFsdCArIHJpZ2h0XG4gICAqICAgU2VsZWN0IHdvcmRzOiAgICAgICAgICAgICAgICAgICBzaGlmdCArIGFsdCArIGxlZnQsIHNoaWZ0ICsgYWx0ICsgcmlnaHRcbiAgICogICBNb3ZlIGN1cnNvciB0byBsaW5lIHN0YXJ0L2VuZDogIGNtZCArIGxlZnQsIGNtZCArIHJpZ2h0IG9yIGhvbWUsIGVuZFxuICAgKiAgIFNlbGVjdCB0aWxsIHN0YXJ0L2VuZCBvZiBsaW5lOiAgY21kICsgc2hpZnQgKyBsZWZ0LCBjbWQgKyBzaGlmdCArIHJpZ2h0IG9yIHNoaWZ0ICsgaG9tZSwgc2hpZnQgKyBlbmRcbiAgICogICBKdW1wIHRvIHN0YXJ0L2VuZCBvZiB0ZXh0OiAgICAgIGNtZCArIHVwLCBjbWQgKyBkb3duXG4gICAqICAgU2VsZWN0IHRpbGwgc3RhcnQvZW5kIG9mIHRleHQ6ICBjbWQgKyBzaGlmdCArIHVwLCBjbWQgKyBzaGlmdCArIGRvd24gb3Igc2hpZnQgKyBwZ1VwLCBzaGlmdCArIHBnRG93blxuICAgKiAgIERlbGV0ZSBjaGFyYWN0ZXI6ICAgICAgICAgICAgICAgYmFja3NwYWNlXG4gICAqICAgRGVsZXRlIHdvcmQ6ICAgICAgICAgICAgICAgICAgICBhbHQgKyBiYWNrc3BhY2VcbiAgICogICBEZWxldGUgbGluZTogICAgICAgICAgICAgICAgICAgIGNtZCArIGJhY2tzcGFjZVxuICAgKiAgIEZvcndhcmQgZGVsZXRlOiAgICAgICAgICAgICAgICAgZGVsZXRlXG4gICAqICAgQ29weSB0ZXh0OiAgICAgICAgICAgICAgICAgICAgICBjdHJsL2NtZCArIGNcbiAgICogICBQYXN0ZSB0ZXh0OiAgICAgICAgICAgICAgICAgICAgIGN0cmwvY21kICsgdlxuICAgKiAgIEN1dCB0ZXh0OiAgICAgICAgICAgICAgICAgICAgICAgY3RybC9jbWQgKyB4XG4gICAqICAgU2VsZWN0IGVudGlyZSB0ZXh0OiAgICAgICAgICAgICBjdHJsL2NtZCArIGFcbiAgICogICBRdWl0IGVkaXRpbmcgICAgICAgICAgICAgICAgICAgIHRhYiBvciBlc2NcbiAgICogPC9wcmU+XG4gICAqXG4gICAqIDxwPlN1cHBvcnRlZCBtb3VzZS90b3VjaCBjb21iaW5hdGlvbjwvcD5cbiAgICogPHByZT5cbiAgICogICBQb3NpdGlvbiBjdXJzb3I6ICAgICAgICAgICAgICAgIGNsaWNrL3RvdWNoXG4gICAqICAgQ3JlYXRlIHNlbGVjdGlvbjogICAgICAgICAgICAgICBjbGljay90b3VjaCAmIGRyYWdcbiAgICogICBDcmVhdGUgc2VsZWN0aW9uOiAgICAgICAgICAgICAgIGNsaWNrICYgc2hpZnQgKyBjbGlja1xuICAgKiAgIFNlbGVjdCB3b3JkOiAgICAgICAgICAgICAgICAgICAgZG91YmxlIGNsaWNrXG4gICAqICAgU2VsZWN0IGxpbmU6ICAgICAgICAgICAgICAgICAgICB0cmlwbGUgY2xpY2tcbiAgICogPC9wcmU+XG4gICAqL1xuICBmYWJyaWMuSVRleHQgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuVGV4dCwgZmFicmljLk9ic2VydmFibGUsIC8qKiBAbGVuZHMgZmFicmljLklUZXh0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2ktdGV4dCcsXG5cbiAgICAvKipcbiAgICAgKiBJbmRleCB3aGVyZSB0ZXh0IHNlbGVjdGlvbiBzdGFydHMgKG9yIHdoZXJlIGN1cnNvciBpcyB3aGVuIHRoZXJlIGlzIG5vIHNlbGVjdGlvbilcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvblN0YXJ0OiAwLFxuXG4gICAgLyoqXG4gICAgICogSW5kZXggd2hlcmUgdGV4dCBzZWxlY3Rpb24gZW5kc1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uRW5kOiAwLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2YgdGV4dCBzZWxlY3Rpb25cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbkNvbG9yOiAncmdiYSgxNywxMTksMjU1LDAuMyknLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGV4dCBpcyBpbiBlZGl0aW5nIG1vZGVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpc0VkaXRpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgYSB0ZXh0IGNhbiBiZSBlZGl0ZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBlZGl0YWJsZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEJvcmRlciBjb2xvciBvZiB0ZXh0IG9iamVjdCB3aGlsZSBpdCdzIGluIGVkaXRpbmcgbW9kZVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZWRpdGluZ0JvcmRlckNvbG9yOiAncmdiYSgxMDIsMTUzLDI1NSwwLjI1KScsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBjdXJzb3IgKGluIHB4KVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3Vyc29yV2lkdGg6IDIsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiBkZWZhdWx0IGN1cnNvciAod2hlbiBub3Qgb3ZlcndyaXR0ZW4gYnkgY2hhcmFjdGVyIHN0eWxlKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3Vyc29yQ29sb3I6ICcjMzMzJyxcblxuICAgIC8qKlxuICAgICAqIERlbGF5IGJldHdlZW4gY3Vyc29yIGJsaW5rIChpbiBtcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGN1cnNvckRlbGF5OiAxMDAwLFxuXG4gICAgLyoqXG4gICAgICogRHVyYXRpb24gb2YgY3Vyc29yIGZhZGVpbiAoaW4gbXMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjdXJzb3JEdXJhdGlvbjogNjAwLFxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IGNvbnRhaW5pbmcgY2hhcmFjdGVyIHN0eWxlc1xuICAgICAqICh3aGVyZSB0b3AtbGV2ZWwgcHJvcGVydGllcyBjb3JyZXNwb25kcyB0byBsaW5lIG51bWJlciBhbmQgMm5kLWxldmVsIHByb3BlcnRpZXMgLS0gdG8gY2hhciBudW1iZXIgaW4gYSBsaW5lKVxuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3R5bGVzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgaW50ZXJuYWwgdGV4dCBjaGFyIHdpZHRocyBjYW4gYmUgY2FjaGVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2FjaGluZzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlU3BhY2U6IC9cXHN8XFxuLyxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2N1cnJlbnRDdXJzb3JPcGFjaXR5OiAwLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2VsZWN0aW9uRGlyZWN0aW9uOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWJvcnRDdXJzb3JBbmltYXRpb246IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfX3dpZHRoT2ZTcGFjZTogW10sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRleHQgc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JVGV4dH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc3R5bGVzID0gb3B0aW9ucyA/IChvcHRpb25zLnN0eWxlcyB8fCB7IH0pIDogeyB9O1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCB0ZXh0LCBvcHRpb25zKTtcbiAgICAgIHRoaXMuaW5pdEJlaGF2aW9yKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NsZWFyQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19jbGVhckNhY2hlJyk7XG4gICAgICB0aGlzLl9fd2lkdGhPZlNwYWNlID0gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaGFzIG5vIHN0eWxpbmdcbiAgICAgKi9cbiAgICBpc0VtcHR5U3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0gdGhpcy5zdHlsZXM7XG5cbiAgICAgIGZvciAodmFyIHAxIGluIG9iaikge1xuICAgICAgICBmb3IgKHZhciBwMiBpbiBvYmpbcDFdKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgICAgZm9yICh2YXIgcDMgaW4gb2JqW3AxXVtwMl0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNlbGVjdGlvbiBzdGFydCAobGVmdCBib3VuZGFyeSBvZiBhIHNlbGVjdGlvbilcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggdG8gc2V0IHNlbGVjdGlvbiBzdGFydCB0b1xuICAgICAqL1xuICAgIHNldFNlbGVjdGlvblN0YXJ0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaW5kZXggPSBNYXRoLm1heChpbmRleCwgMCk7XG4gICAgICB0aGlzLl91cGRhdGVBbmRGaXJlKCdzZWxlY3Rpb25TdGFydCcsIGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzZWxlY3Rpb24gZW5kIChyaWdodCBib3VuZGFyeSBvZiBhIHNlbGVjdGlvbilcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggdG8gc2V0IHNlbGVjdGlvbiBlbmQgdG9cbiAgICAgKi9cbiAgICBzZXRTZWxlY3Rpb25FbmQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpbmRleCA9IE1hdGgubWluKGluZGV4LCB0aGlzLnRleHQubGVuZ3RoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUFuZEZpcmUoJ3NlbGVjdGlvbkVuZCcsIGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgJ3NlbGVjdGlvblN0YXJ0JyBvciAnc2VsZWN0aW9uRW5kJ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBuZXcgcG9zaXRpb24gb2YgcHJvcGVydHlcbiAgICAgKi9cbiAgICBfdXBkYXRlQW5kRmlyZTogZnVuY3Rpb24ocHJvcGVydHksIGluZGV4KSB7XG4gICAgICBpZiAodGhpc1twcm9wZXJ0eV0gIT09IGluZGV4KSB7XG4gICAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gaW5kZXg7XG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB0aGUgZXZlbiBvZiBzZWxlY3Rpb24gY2hhbmdlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZmlyZSgnc2VsZWN0aW9uOmNoYW5nZWQnKTtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6c2VsZWN0aW9uOmNoYW5nZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBzdHlsZSBvZiBhIGN1cnJlbnQgc2VsZWN0aW9uL2N1cnNvciAoYXQgdGhlIHN0YXJ0IHBvc2l0aW9uKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRJbmRleF0gU3RhcnQgaW5kZXggdG8gZ2V0IHN0eWxlcyBhdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kSW5kZXhdIEVuZCBpbmRleCB0byBnZXQgc3R5bGVzIGF0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBzdHlsZXMgU3R5bGUgb2JqZWN0IGF0IGEgc3BlY2lmaWVkIChvciBjdXJyZW50KSBpbmRleFxuICAgICAqL1xuICAgIGdldFNlbGVjdGlvblN0eWxlczogZnVuY3Rpb24oc3RhcnRJbmRleCwgZW5kSW5kZXgpIHtcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgdmFyIHN0eWxlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgICBzdHlsZXMucHVzaCh0aGlzLmdldFNlbGVjdGlvblN0eWxlcyhpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICAgIH1cblxuICAgICAgdmFyIGxvYyA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzdGFydEluZGV4KSxcbiAgICAgICAgICBzdHlsZSA9IHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCk7XG5cbiAgICAgIHJldHVybiBzdHlsZSB8fCB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzdHlsZSBvZiBhIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZXNdIFN0eWxlcyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0U2VsZWN0aW9uU3R5bGVzOiBmdW5jdGlvbihzdHlsZXMpIHtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgICB0aGlzLl9leHRlbmRTdHlsZXModGhpcy5zZWxlY3Rpb25TdGFydCwgc3R5bGVzKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5zZWxlY3Rpb25TdGFydDsgaSA8IHRoaXMuc2VsZWN0aW9uRW5kOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl9leHRlbmRTdHlsZXMoaSwgc3R5bGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyogbm90IGluY2x1ZGVkIGluIF9leHRlbmRTdHlsZXMgdG8gYXZvaWQgY2xlYXJpbmcgY2FjaGUgbW9yZSB0aGFuIG9uY2UgKi9cbiAgICAgIHRoaXMuX2ZvcmNlQ2xlYXJDYWNoZSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZXh0ZW5kU3R5bGVzOiBmdW5jdGlvbihpbmRleCwgc3R5bGVzKSB7XG4gICAgICB2YXIgbG9jID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKGluZGV4KTtcblxuICAgICAgaWYgKCF0aGlzLl9nZXRMaW5lU3R5bGUobG9jLmxpbmVJbmRleCkpIHtcbiAgICAgICAgdGhpcy5fc2V0TGluZVN0eWxlKGxvYy5saW5lSW5kZXgsIHt9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxvYy5saW5lSW5kZXgsIGxvYy5jaGFySW5kZXgpKSB7XG4gICAgICAgIHRoaXMuX3NldFN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCwge30pO1xuICAgICAgfVxuXG4gICAgICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCksIHN0eWxlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5vbGRXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICB0aGlzLm9sZEhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19yZW5kZXInLCBjdHgpO1xuICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgICAvLyBjbGVhciB0aGUgY3Vyc29yT2Zmc2V0Q2FjaGUsIHNvIHdlIGVuc3VyZSB0byBjYWxjdWxhdGUgb25jZSBwZXIgcmVuZGVyQ3Vyc29yXG4gICAgICAvLyB0aGUgY29ycmVjdCBwb3NpdGlvbiBidXQgbm90IGF0IGV2ZXJ5IGN1cnNvciBhbmltYXRpb24uXG4gICAgICB0aGlzLmN1cnNvck9mZnNldENhY2hlID0geyB9O1xuICAgICAgdGhpcy5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGN1cnNvciBvciBzZWxlY3Rpb24gKGRlcGVuZGluZyBvbiB3aGF0IGV4aXN0cylcbiAgICAgKi9cbiAgICByZW5kZXJDdXJzb3JPclNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuYWN0aXZlIHx8ICF0aGlzLmlzRWRpdGluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgY2hhcnMgPSB0aGlzLnRleHQuc3BsaXQoJycpLFxuICAgICAgICAgIGJvdW5kYXJpZXMsIGN0eDtcbiAgICAgIGlmICh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKSB7XG4gICAgICAgIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0uYXBwbHkoY3R4LCB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybSk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtKGN0eCk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtTWF0cml4ICYmIGN0eC50cmFuc2Zvcm0uYXBwbHkoY3R4LCB0aGlzLnRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICAgIHRoaXMuX2NsZWFyVGV4dEFyZWEoY3R4KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjdHggPSB0aGlzLmN0eDtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgICBib3VuZGFyaWVzID0gdGhpcy5fZ2V0Q3Vyc29yQm91bmRhcmllcyhjaGFycywgJ2N1cnNvcicpO1xuICAgICAgICB0aGlzLnJlbmRlckN1cnNvcihib3VuZGFyaWVzLCBjdHgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGJvdW5kYXJpZXMgPSB0aGlzLl9nZXRDdXJzb3JCb3VuZGFyaWVzKGNoYXJzLCAnc2VsZWN0aW9uJyk7XG4gICAgICAgIHRoaXMucmVuZGVyU2VsZWN0aW9uKGNoYXJzLCBib3VuZGFyaWVzLCBjdHgpO1xuICAgICAgfVxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICBfY2xlYXJUZXh0QXJlYTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICAvLyB3ZSBhZGQgNCBwaXhlbCwgdG8gYmUgc3VyZSB0byBkbyBub3QgbGVhdmUgYW55IHBpeGVsIG91dFxuICAgICAgdmFyIHdpZHRoID0gdGhpcy5vbGRXaWR0aCArIDQsIGhlaWdodCA9IHRoaXMub2xkSGVpZ2h0ICsgNDtcbiAgICAgIGN0eC5jbGVhclJlY3QoLXdpZHRoIC8gMiwgLWhlaWdodCAvIDIsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmV0dXJucyAyZCByZXByZXNlbnRhdGlvbiAobGluZUluZGV4IGFuZCBjaGFySW5kZXgpIG9mIGN1cnNvciAob3Igc2VsZWN0aW9uIHN0YXJ0KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc2VsZWN0aW9uU3RhcnRdIE9wdGlvbmFsIGluZGV4LiBXaGVuIG5vdCBnaXZlbiwgY3VycmVudCBzZWxlY3Rpb25TdGFydCBpcyB1c2VkLlxuICAgICAqL1xuICAgIGdldDJEQ3Vyc29yTG9jYXRpb246IGZ1bmN0aW9uKHNlbGVjdGlvblN0YXJ0KSB7XG4gICAgICBpZiAodHlwZW9mIHNlbGVjdGlvblN0YXJ0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICB9XG4gICAgICB2YXIgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0IDw9IHRoaXMuX3RleHRMaW5lc1tpXS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGluZUluZGV4OiBpLFxuICAgICAgICAgICAgY2hhckluZGV4OiBzZWxlY3Rpb25TdGFydFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uU3RhcnQgLT0gdGhpcy5fdGV4dExpbmVzW2ldLmxlbmd0aCArIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lSW5kZXg6IGkgLSAxLFxuICAgICAgICBjaGFySW5kZXg6IHRoaXMuX3RleHRMaW5lc1tpIC0gMV0ubGVuZ3RoIDwgc2VsZWN0aW9uU3RhcnQgPyB0aGlzLl90ZXh0TGluZXNbaSAtIDFdLmxlbmd0aCA6IHNlbGVjdGlvblN0YXJ0XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbXBsZXRlIHN0eWxlIG9mIGNoYXIgYXQgdGhlIGN1cnJlbnQgY3Vyc29yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBMaW5lIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleCBDaGFyIGluZGV4XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDaGFyYWN0ZXIgc3R5bGVcbiAgICAgKi9cbiAgICBnZXRDdXJyZW50Q2hhclN0eWxlOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgICAgdmFyIHN0eWxlID0gdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCA9PT0gMCA/IDAgOiBjaGFySW5kZXggLSAxKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZm9udFNpemU6IHN0eWxlICYmIHN0eWxlLmZvbnRTaXplIHx8IHRoaXMuZm9udFNpemUsXG4gICAgICAgIGZpbGw6IHN0eWxlICYmIHN0eWxlLmZpbGwgfHwgdGhpcy5maWxsLFxuICAgICAgICB0ZXh0QmFja2dyb3VuZENvbG9yOiBzdHlsZSAmJiBzdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yIHx8IHRoaXMudGV4dEJhY2tncm91bmRDb2xvcixcbiAgICAgICAgdGV4dERlY29yYXRpb246IHN0eWxlICYmIHN0eWxlLnRleHREZWNvcmF0aW9uIHx8IHRoaXMudGV4dERlY29yYXRpb24sXG4gICAgICAgIGZvbnRGYW1pbHk6IHN0eWxlICYmIHN0eWxlLmZvbnRGYW1pbHkgfHwgdGhpcy5mb250RmFtaWx5LFxuICAgICAgICBmb250V2VpZ2h0OiBzdHlsZSAmJiBzdHlsZS5mb250V2VpZ2h0IHx8IHRoaXMuZm9udFdlaWdodCxcbiAgICAgICAgZm9udFN0eWxlOiBzdHlsZSAmJiBzdHlsZS5mb250U3R5bGUgfHwgdGhpcy5mb250U3R5bGUsXG4gICAgICAgIHN0cm9rZTogc3R5bGUgJiYgc3R5bGUuc3Ryb2tlIHx8IHRoaXMuc3Ryb2tlLFxuICAgICAgICBzdHJva2VXaWR0aDogc3R5bGUgJiYgc3R5bGUuc3Ryb2tlV2lkdGggfHwgdGhpcy5zdHJva2VXaWR0aFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBmb250U2l6ZSBvZiBjaGFyIGF0IHRoZSBjdXJyZW50IGN1cnNvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggTGluZSBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXggQ2hhciBpbmRleFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gQ2hhcmFjdGVyIGZvbnQgc2l6ZVxuICAgICAqL1xuICAgIGdldEN1cnJlbnRDaGFyRm9udFNpemU6IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB7XG4gICAgICB2YXIgc3R5bGUgPSB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4ID09PSAwID8gMCA6IGNoYXJJbmRleCAtIDEpO1xuICAgICAgcmV0dXJuIHN0eWxlICYmIHN0eWxlLmZvbnRTaXplID8gc3R5bGUuZm9udFNpemUgOiB0aGlzLmZvbnRTaXplO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbG9yIChmaWxsKSBvZiBjaGFyIGF0IHRoZSBjdXJyZW50IGN1cnNvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggTGluZSBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXggQ2hhciBpbmRleFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gQ2hhcmFjdGVyIGNvbG9yIChmaWxsKVxuICAgICAqL1xuICAgIGdldEN1cnJlbnRDaGFyQ29sb3I6IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB7XG4gICAgICB2YXIgc3R5bGUgPSB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4ID09PSAwID8gMCA6IGNoYXJJbmRleCAtIDEpO1xuICAgICAgcmV0dXJuIHN0eWxlICYmIHN0eWxlLmZpbGwgPyBzdHlsZS5maWxsIDogdGhpcy5jdXJzb3JDb2xvcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjdXJzb3IgYm91bmRhcmllcyAobGVmdCwgdG9wLCBsZWZ0T2Zmc2V0LCB0b3BPZmZzZXQpXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjaGFycyBBcnJheSBvZiBjaGFyYWN0ZXJzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVPZkJvdW5kYXJpZXNcbiAgICAgKi9cbiAgICBfZ2V0Q3Vyc29yQm91bmRhcmllczogZnVuY3Rpb24oY2hhcnMsIHR5cGVPZkJvdW5kYXJpZXMpIHtcblxuICAgICAgLy8gbGVmdC90b3AgYXJlIGxlZnQvdG9wIG9mIGVudGlyZSB0ZXh0IGJveFxuICAgICAgLy8gbGVmdE9mZnNldC90b3BPZmZzZXQgYXJlIG9mZnNldCBmcm9tIHRoYXQgbGVmdC90b3AgcG9pbnQgb2YgYSB0ZXh0IGJveFxuXG4gICAgICB2YXIgbGVmdCA9IE1hdGgucm91bmQodGhpcy5fZ2V0TGVmdE9mZnNldCgpKSxcbiAgICAgICAgICB0b3AgPSB0aGlzLl9nZXRUb3BPZmZzZXQoKSxcblxuICAgICAgICAgIG9mZnNldHMgPSB0aGlzLl9nZXRDdXJzb3JCb3VuZGFyaWVzT2Zmc2V0cyhcbiAgICAgICAgICAgICAgICAgICAgICBjaGFycywgdHlwZU9mQm91bmRhcmllcyk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHRvcDogdG9wLFxuICAgICAgICBsZWZ0T2Zmc2V0OiBvZmZzZXRzLmxlZnQgKyBvZmZzZXRzLmxpbmVMZWZ0LFxuICAgICAgICB0b3BPZmZzZXQ6IG9mZnNldHMudG9wXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRDdXJzb3JCb3VuZGFyaWVzT2Zmc2V0czogZnVuY3Rpb24oY2hhcnMsIHR5cGVPZkJvdW5kYXJpZXMpIHtcbiAgICAgIGlmICh0aGlzLmN1cnNvck9mZnNldENhY2hlICYmICd0b3AnIGluIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGU7XG4gICAgICB9XG4gICAgICB2YXIgbGluZUxlZnRPZmZzZXQgPSAwLFxuICAgICAgICAgIGxpbmVJbmRleCA9IDAsXG4gICAgICAgICAgY2hhckluZGV4ID0gMCxcbiAgICAgICAgICB0b3BPZmZzZXQgPSAwLFxuICAgICAgICAgIGxlZnRPZmZzZXQgPSAwLFxuICAgICAgICAgIGJvdW5kYXJpZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zZWxlY3Rpb25TdGFydDsgaSsrKSB7XG4gICAgICAgIGlmIChjaGFyc1tpXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICBsZWZ0T2Zmc2V0ID0gMDtcbiAgICAgICAgICB0b3BPZmZzZXQgKz0gdGhpcy5fZ2V0SGVpZ2h0T2ZMaW5lKHRoaXMuY3R4LCBsaW5lSW5kZXgpO1xuXG4gICAgICAgICAgbGluZUluZGV4Kys7XG4gICAgICAgICAgY2hhckluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsZWZ0T2Zmc2V0ICs9IHRoaXMuX2dldFdpZHRoT2ZDaGFyKHRoaXMuY3R4LCBjaGFyc1tpXSwgbGluZUluZGV4LCBjaGFySW5kZXgpO1xuICAgICAgICAgIGNoYXJJbmRleCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZUxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldCh0aGlzLl9nZXRMaW5lV2lkdGgodGhpcy5jdHgsIGxpbmVJbmRleCkpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVPZkJvdW5kYXJpZXMgPT09ICdjdXJzb3InKSB7XG4gICAgICAgIHRvcE9mZnNldCArPSAoMSAtIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24pICogdGhpcy5fZ2V0SGVpZ2h0T2ZMaW5lKHRoaXMuY3R4LCBsaW5lSW5kZXgpIC8gdGhpcy5saW5lSGVpZ2h0XG4gICAgICAgICAgLSB0aGlzLmdldEN1cnJlbnRDaGFyRm9udFNpemUobGluZUluZGV4LCBjaGFySW5kZXgpICogKDEgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNoYXJTcGFjaW5nICE9PSAwICYmIGNoYXJJbmRleCA9PT0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0ubGVuZ3RoKSB7XG4gICAgICAgIGxlZnRPZmZzZXQgLT0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCk7XG4gICAgICB9XG4gICAgICBib3VuZGFyaWVzID0ge1xuICAgICAgICB0b3A6IHRvcE9mZnNldCxcbiAgICAgICAgbGVmdDogbGVmdE9mZnNldCA+IDAgPyBsZWZ0T2Zmc2V0IDogMCxcbiAgICAgICAgbGluZUxlZnQ6IGxpbmVMZWZ0T2Zmc2V0XG4gICAgICB9O1xuICAgICAgdGhpcy5jdXJzb3JPZmZzZXRDYWNoZSA9IGJvdW5kYXJpZXM7XG4gICAgICByZXR1cm4gdGhpcy5jdXJzb3JPZmZzZXRDYWNoZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBjdXJzb3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYm91bmRhcmllc1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggdHJhbnNmb3JtZWQgY29udGV4dCB0byBkcmF3IG9uXG4gICAgICovXG4gICAgcmVuZGVyQ3Vyc29yOiBmdW5jdGlvbihib3VuZGFyaWVzLCBjdHgpIHtcblxuICAgICAgdmFyIGN1cnNvckxvY2F0aW9uID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKCksXG4gICAgICAgICAgbGluZUluZGV4ID0gY3Vyc29yTG9jYXRpb24ubGluZUluZGV4LFxuICAgICAgICAgIGNoYXJJbmRleCA9IGN1cnNvckxvY2F0aW9uLmNoYXJJbmRleCxcbiAgICAgICAgICBjaGFySGVpZ2h0ID0gdGhpcy5nZXRDdXJyZW50Q2hhckZvbnRTaXplKGxpbmVJbmRleCwgY2hhckluZGV4KSxcbiAgICAgICAgICBsZWZ0T2Zmc2V0ID0gKGxpbmVJbmRleCA9PT0gMCAmJiBjaGFySW5kZXggPT09IDApXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQodGhpcy5fZ2V0TGluZVdpZHRoKGN0eCwgbGluZUluZGV4KSlcbiAgICAgICAgICAgICAgICAgICAgOiBib3VuZGFyaWVzLmxlZnRPZmZzZXQsXG4gICAgICAgICAgbXVsdGlwbGllciA9IHRoaXMuc2NhbGVYICogdGhpcy5jYW52YXMuZ2V0Wm9vbSgpLFxuICAgICAgICAgIGN1cnNvcldpZHRoID0gdGhpcy5jdXJzb3JXaWR0aCAvIG11bHRpcGxpZXI7XG5cbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmdldEN1cnJlbnRDaGFyQ29sb3IobGluZUluZGV4LCBjaGFySW5kZXgpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5fX2lzTW91c2Vkb3duID8gMSA6IHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5O1xuXG4gICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgIGJvdW5kYXJpZXMubGVmdCArIGxlZnRPZmZzZXQgLSBjdXJzb3JXaWR0aCAvIDIsXG4gICAgICAgIGJvdW5kYXJpZXMudG9wICsgYm91bmRhcmllcy50b3BPZmZzZXQsXG4gICAgICAgIGN1cnNvcldpZHRoLFxuICAgICAgICBjaGFySGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0ZXh0IHNlbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNoYXJzIEFycmF5IG9mIGNoYXJhY3RlcnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYm91bmRhcmllcyBPYmplY3Qgd2l0aCBsZWZ0L3RvcC9sZWZ0T2Zmc2V0L3RvcE9mZnNldFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggdHJhbnNmb3JtZWQgY29udGV4dCB0byBkcmF3IG9uXG4gICAgICovXG4gICAgcmVuZGVyU2VsZWN0aW9uOiBmdW5jdGlvbihjaGFycywgYm91bmRhcmllcywgY3R4KSB7XG5cbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnNlbGVjdGlvbkNvbG9yO1xuXG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24odGhpcy5zZWxlY3Rpb25TdGFydCksXG4gICAgICAgICAgZW5kID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHRoaXMuc2VsZWN0aW9uRW5kKSxcbiAgICAgICAgICBzdGFydExpbmUgPSBzdGFydC5saW5lSW5kZXgsXG4gICAgICAgICAgZW5kTGluZSA9IGVuZC5saW5lSW5kZXg7XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRMaW5lOyBpIDw9IGVuZExpbmU7IGkrKykge1xuICAgICAgICB2YXIgbGluZU9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KHRoaXMuX2dldExpbmVXaWR0aChjdHgsIGkpKSB8fCAwLFxuICAgICAgICAgICAgbGluZUhlaWdodCA9IHRoaXMuX2dldEhlaWdodE9mTGluZSh0aGlzLmN0eCwgaSksXG4gICAgICAgICAgICByZWFsTGluZUhlaWdodCA9IDAsIGJveFdpZHRoID0gMCwgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tpXTtcblxuICAgICAgICBpZiAoaSA9PT0gc3RhcnRMaW5lKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IGxpbmUubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChqID49IHN0YXJ0LmNoYXJJbmRleCAmJiAoaSAhPT0gZW5kTGluZSB8fCBqIDwgZW5kLmNoYXJJbmRleCkpIHtcbiAgICAgICAgICAgICAgYm94V2lkdGggKz0gdGhpcy5fZ2V0V2lkdGhPZkNoYXIoY3R4LCBsaW5lW2pdLCBpLCBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqIDwgc3RhcnQuY2hhckluZGV4KSB7XG4gICAgICAgICAgICAgIGxpbmVPZmZzZXQgKz0gdGhpcy5fZ2V0V2lkdGhPZkNoYXIoY3R4LCBsaW5lW2pdLCBpLCBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGogPT09IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBib3hXaWR0aCAtPSB0aGlzLl9nZXRXaWR0aE9mQ2hhclNwYWNpbmcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaSA+IHN0YXJ0TGluZSAmJiBpIDwgZW5kTGluZSkge1xuICAgICAgICAgIGJveFdpZHRoICs9IHRoaXMuX2dldExpbmVXaWR0aChjdHgsIGkpIHx8IDU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaSA9PT0gZW5kTGluZSkge1xuICAgICAgICAgIGZvciAodmFyIGoyID0gMCwgajJsZW4gPSBlbmQuY2hhckluZGV4OyBqMiA8IGoybGVuOyBqMisrKSB7XG4gICAgICAgICAgICBib3hXaWR0aCArPSB0aGlzLl9nZXRXaWR0aE9mQ2hhcihjdHgsIGxpbmVbajJdLCBpLCBqMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbmQuY2hhckluZGV4ID09PSBsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgYm94V2lkdGggLT0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlYWxMaW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMubGluZUhlaWdodCA8IDEgfHwgKGkgPT09IGVuZExpbmUgJiYgdGhpcy5saW5lSGVpZ2h0ID4gMSkpIHtcbiAgICAgICAgICBsaW5lSGVpZ2h0IC89IHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgYm91bmRhcmllcy5sZWZ0ICsgbGluZU9mZnNldCxcbiAgICAgICAgICBib3VuZGFyaWVzLnRvcCArIGJvdW5kYXJpZXMudG9wT2Zmc2V0LFxuICAgICAgICAgIGJveFdpZHRoID4gMCA/IGJveFdpZHRoIDogMCxcbiAgICAgICAgICBsaW5lSGVpZ2h0KTtcblxuICAgICAgICBib3VuZGFyaWVzLnRvcE9mZnNldCArPSByZWFsTGluZUhlaWdodDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lIENvbnRlbnQgb2YgdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVmdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b3BcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJPZmZzZXRcbiAgICAgKi9cbiAgICBfcmVuZGVyQ2hhcnM6IGZ1bmN0aW9uKG1ldGhvZCwgY3R4LCBsaW5lLCBsZWZ0LCB0b3AsIGxpbmVJbmRleCwgY2hhck9mZnNldCkge1xuXG4gICAgICBpZiAodGhpcy5pc0VtcHR5U3R5bGVzKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlckNoYXJzRmFzdChtZXRob2QsIGN0eCwgbGluZSwgbGVmdCwgdG9wKTtcbiAgICAgIH1cblxuICAgICAgY2hhck9mZnNldCA9IGNoYXJPZmZzZXQgfHwgMDtcblxuICAgICAgLy8gc2V0IHByb3BlciBsaW5lIG9mZnNldFxuICAgICAgdmFyIGxpbmVIZWlnaHQgPSB0aGlzLl9nZXRIZWlnaHRPZkxpbmUoY3R4LCBsaW5lSW5kZXgpLFxuICAgICAgICAgIHByZXZTdHlsZSxcbiAgICAgICAgICB0aGlzU3R5bGUsXG4gICAgICAgICAgY2hhcnNUb1JlbmRlciA9ICcnO1xuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdG9wIC09IGxpbmVIZWlnaHQgLyB0aGlzLmxpbmVIZWlnaHQgKiB0aGlzLl9mb250U2l6ZUZyYWN0aW9uO1xuICAgICAgZm9yICh2YXIgaSA9IGNoYXJPZmZzZXQsIGxlbiA9IGxpbmUubGVuZ3RoICsgY2hhck9mZnNldDsgaSA8PSBsZW47IGkrKykge1xuICAgICAgICBwcmV2U3R5bGUgPSBwcmV2U3R5bGUgfHwgdGhpcy5nZXRDdXJyZW50Q2hhclN0eWxlKGxpbmVJbmRleCwgaSk7XG4gICAgICAgIHRoaXNTdHlsZSA9IHRoaXMuZ2V0Q3VycmVudENoYXJTdHlsZShsaW5lSW5kZXgsIGkgKyAxKTtcblxuICAgICAgICBpZiAodGhpcy5faGFzU3R5bGVDaGFuZ2VkKHByZXZTdHlsZSwgdGhpc1N0eWxlKSB8fCBpID09PSBsZW4pIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJDaGFyKG1ldGhvZCwgY3R4LCBsaW5lSW5kZXgsIGkgLSAxLCBjaGFyc1RvUmVuZGVyLCBsZWZ0LCB0b3AsIGxpbmVIZWlnaHQpO1xuICAgICAgICAgIGNoYXJzVG9SZW5kZXIgPSAnJztcbiAgICAgICAgICBwcmV2U3R5bGUgPSB0aGlzU3R5bGU7XG4gICAgICAgIH1cbiAgICAgICAgY2hhcnNUb1JlbmRlciArPSBsaW5lW2kgLSBjaGFyT2Zmc2V0XTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGluZSBDb250ZW50IG9mIHRoZSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJDaGFyc0Zhc3Q6IGZ1bmN0aW9uKG1ldGhvZCwgY3R4LCBsaW5lLCBsZWZ0LCB0b3ApIHtcblxuICAgICAgaWYgKG1ldGhvZCA9PT0gJ2ZpbGxUZXh0JyAmJiB0aGlzLmZpbGwpIHtcbiAgICAgICAgdGhpcy5jYWxsU3VwZXIoJ19yZW5kZXJDaGFycycsIG1ldGhvZCwgY3R4LCBsaW5lLCBsZWZ0LCB0b3ApO1xuICAgICAgfVxuICAgICAgaWYgKG1ldGhvZCA9PT0gJ3N0cm9rZVRleHQnICYmICgodGhpcy5zdHJva2UgJiYgdGhpcy5zdHJva2VXaWR0aCA+IDApIHx8IHRoaXMuc2tpcEZpbGxTdHJva2VDaGVjaykpIHtcbiAgICAgICAgdGhpcy5jYWxsU3VwZXIoJ19yZW5kZXJDaGFycycsIG1ldGhvZCwgY3R4LCBsaW5lLCBsZWZ0LCB0b3ApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IF9jaGFyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSGVpZ2h0IEhlaWdodCBvZiB0aGUgbGluZVxuICAgICAqL1xuICAgIF9yZW5kZXJDaGFyOiBmdW5jdGlvbihtZXRob2QsIGN0eCwgbGluZUluZGV4LCBpLCBfY2hhciwgbGVmdCwgdG9wLCBsaW5lSGVpZ2h0KSB7XG4gICAgICB2YXIgY2hhcldpZHRoLCBjaGFySGVpZ2h0LCBzaG91bGRGaWxsLCBzaG91bGRTdHJva2UsXG4gICAgICAgICAgZGVjbCA9IHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBpKSxcbiAgICAgICAgICBvZmZzZXQsIHRleHREZWNvcmF0aW9uLCBjaGFycywgYWRkaXRpb25hbFNwYWNlLCBfY2hhcldpZHRoO1xuXG4gICAgICBpZiAoZGVjbCkge1xuICAgICAgICBjaGFySGVpZ2h0ID0gdGhpcy5fZ2V0SGVpZ2h0T2ZDaGFyKGN0eCwgX2NoYXIsIGxpbmVJbmRleCwgaSk7XG4gICAgICAgIHNob3VsZFN0cm9rZSA9IGRlY2wuc3Ryb2tlO1xuICAgICAgICBzaG91bGRGaWxsID0gZGVjbC5maWxsO1xuICAgICAgICB0ZXh0RGVjb3JhdGlvbiA9IGRlY2wudGV4dERlY29yYXRpb247XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY2hhckhlaWdodCA9IHRoaXMuZm9udFNpemU7XG4gICAgICB9XG5cbiAgICAgIHNob3VsZFN0cm9rZSA9IChzaG91bGRTdHJva2UgfHwgdGhpcy5zdHJva2UpICYmIG1ldGhvZCA9PT0gJ3N0cm9rZVRleHQnO1xuICAgICAgc2hvdWxkRmlsbCA9IChzaG91bGRGaWxsIHx8IHRoaXMuZmlsbCkgJiYgbWV0aG9kID09PSAnZmlsbFRleHQnO1xuXG4gICAgICBkZWNsICYmIGN0eC5zYXZlKCk7XG5cbiAgICAgIGNoYXJXaWR0aCA9IHRoaXMuX2FwcGx5Q2hhclN0eWxlc0dldFdpZHRoKGN0eCwgX2NoYXIsIGxpbmVJbmRleCwgaSwgZGVjbCB8fCBudWxsKTtcbiAgICAgIHRleHREZWNvcmF0aW9uID0gdGV4dERlY29yYXRpb24gfHwgdGhpcy50ZXh0RGVjb3JhdGlvbjtcblxuICAgICAgaWYgKGRlY2wgJiYgZGVjbC50ZXh0QmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVNoYWRvdyhjdHgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2hhclNwYWNpbmcgIT09IDApIHtcbiAgICAgICAgYWRkaXRpb25hbFNwYWNlID0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCk7XG4gICAgICAgIGNoYXJzID0gX2NoYXIuc3BsaXQoJycpO1xuICAgICAgICBjaGFyV2lkdGggPSAwO1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gY2hhcnMubGVuZ3RoLCBjaGFyOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICBjaGFyID0gY2hhcnNbal07XG4gICAgICAgICAgc2hvdWxkRmlsbCAmJiBjdHguZmlsbFRleHQoY2hhciwgbGVmdCArIGNoYXJXaWR0aCwgdG9wKTtcbiAgICAgICAgICBzaG91bGRTdHJva2UgJiYgY3R4LnN0cm9rZVRleHQoY2hhciwgbGVmdCArIGNoYXJXaWR0aCwgdG9wKTtcbiAgICAgICAgICBfY2hhcldpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGNoYXIpLndpZHRoICsgYWRkaXRpb25hbFNwYWNlO1xuICAgICAgICAgIGNoYXJXaWR0aCArPSBfY2hhcldpZHRoID4gMCA/IF9jaGFyV2lkdGggOiAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2hvdWxkRmlsbCAmJiBjdHguZmlsbFRleHQoX2NoYXIsIGxlZnQsIHRvcCk7XG4gICAgICAgIHNob3VsZFN0cm9rZSAmJiBjdHguc3Ryb2tlVGV4dChfY2hhciwgbGVmdCwgdG9wKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHREZWNvcmF0aW9uIHx8IHRleHREZWNvcmF0aW9uICE9PSAnJykge1xuICAgICAgICBvZmZzZXQgPSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uICogbGluZUhlaWdodCAvIHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgdGhpcy5fcmVuZGVyQ2hhckRlY29yYXRpb24oY3R4LCB0ZXh0RGVjb3JhdGlvbiwgbGVmdCwgdG9wLCBvZmZzZXQsIGNoYXJXaWR0aCwgY2hhckhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGRlY2wgJiYgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoY2hhcldpZHRoLCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJldlN0eWxlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRoaXNTdHlsZVxuICAgICAqL1xuICAgIF9oYXNTdHlsZUNoYW5nZWQ6IGZ1bmN0aW9uKHByZXZTdHlsZSwgdGhpc1N0eWxlKSB7XG4gICAgICByZXR1cm4gKHByZXZTdHlsZS5maWxsICE9PSB0aGlzU3R5bGUuZmlsbCB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUuZm9udFNpemUgIT09IHRoaXNTdHlsZS5mb250U2l6ZSB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUudGV4dEJhY2tncm91bmRDb2xvciAhPT0gdGhpc1N0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3IgfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLnRleHREZWNvcmF0aW9uICE9PSB0aGlzU3R5bGUudGV4dERlY29yYXRpb24gfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLmZvbnRGYW1pbHkgIT09IHRoaXNTdHlsZS5mb250RmFtaWx5IHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5mb250V2VpZ2h0ICE9PSB0aGlzU3R5bGUuZm9udFdlaWdodCB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUuZm9udFN0eWxlICE9PSB0aGlzU3R5bGUuZm9udFN0eWxlIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5zdHJva2UgIT09IHRoaXNTdHlsZS5zdHJva2UgfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLnN0cm9rZVdpZHRoICE9PSB0aGlzU3R5bGUuc3Ryb2tlV2lkdGhcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJDaGFyRGVjb3JhdGlvbjogZnVuY3Rpb24oY3R4LCB0ZXh0RGVjb3JhdGlvbiwgbGVmdCwgdG9wLCBvZmZzZXQsIGNoYXJXaWR0aCwgY2hhckhlaWdodCkge1xuXG4gICAgICBpZiAoIXRleHREZWNvcmF0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlY29yYXRpb25XZWlnaHQgPSBjaGFySGVpZ2h0IC8gMTUsXG4gICAgICAgICAgcG9zaXRpb25zID0ge1xuICAgICAgICAgICAgdW5kZXJsaW5lOiB0b3AgKyBjaGFySGVpZ2h0IC8gMTAsXG4gICAgICAgICAgICAnbGluZS10aHJvdWdoJzogdG9wIC0gY2hhckhlaWdodCAqICh0aGlzLl9mb250U2l6ZUZyYWN0aW9uICsgdGhpcy5fZm9udFNpemVNdWx0IC0gMSkgKyBkZWNvcmF0aW9uV2VpZ2h0LFxuICAgICAgICAgICAgb3ZlcmxpbmU6IHRvcCAtICh0aGlzLl9mb250U2l6ZU11bHQgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKSAqIGNoYXJIZWlnaHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlY29yYXRpb25zID0gWyd1bmRlcmxpbmUnLCAnbGluZS10aHJvdWdoJywgJ292ZXJsaW5lJ10sIGksIGRlY29yYXRpb247XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBkZWNvcmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZWNvcmF0aW9uID0gZGVjb3JhdGlvbnNbaV07XG4gICAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbi5pbmRleE9mKGRlY29yYXRpb24pID4gLTEpIHtcbiAgICAgICAgICBjdHguZmlsbFJlY3QobGVmdCwgcG9zaXRpb25zW2RlY29yYXRpb25dLCBjaGFyV2lkdGggLCBkZWNvcmF0aW9uV2VpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVmdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b3BcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICovXG4gICAgX3JlbmRlclRleHRMaW5lOiBmdW5jdGlvbihtZXRob2QsIGN0eCwgbGluZSwgbGVmdCwgdG9wLCBsaW5lSW5kZXgpIHtcbiAgICAgIC8vIHRvIFwiY2FuY2VsXCIgdGhpcy5mb250U2l6ZSBzdWJ0cmFjdGlvbiBpbiBmYWJyaWMuVGV4dCNfcmVuZGVyVGV4dExpbmVcbiAgICAgIC8vIHRoZSBhZGRpbmcgMC4wMyBpcyBqdXN0IHRvIGFsaWduIHRleHQgd2l0aCBpdGV4dCBieSBvdmVybGFwIHRlc3RcbiAgICAgIGlmICghdGhpcy5pc0VtcHR5U3R5bGVzKCkpIHtcbiAgICAgICAgdG9wICs9IHRoaXMuZm9udFNpemUgKiAodGhpcy5fZm9udFNpemVGcmFjdGlvbiArIDAuMDMpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19yZW5kZXJUZXh0TGluZScsIG1ldGhvZCwgY3R4LCBsaW5lLCBsZWZ0LCB0b3AsIGxpbmVJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0RGVjb3JhdGlvbjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAodGhpcy5pc0VtcHR5U3R5bGVzKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCdfcmVuZGVyVGV4dERlY29yYXRpb24nLCBjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dExpbmVzQmFja2dyb3VuZDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3JlbmRlclRleHRMaW5lc0JhY2tncm91bmQnLCBjdHgpO1xuXG4gICAgICB2YXIgbGluZVRvcE9mZnNldCA9IDAsIGhlaWdodE9mTGluZSxcbiAgICAgICAgICBsaW5lV2lkdGgsIGxpbmVMZWZ0T2Zmc2V0LFxuICAgICAgICAgIGxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMZWZ0T2Zmc2V0KCksXG4gICAgICAgICAgdG9wT2Zmc2V0ID0gdGhpcy5fZ2V0VG9wT2Zmc2V0KCksXG4gICAgICAgICAgbGluZSwgX2NoYXIsIHN0eWxlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGhlaWdodE9mTGluZSA9IHRoaXMuX2dldEhlaWdodE9mTGluZShjdHgsIGkpO1xuICAgICAgICBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2ldO1xuXG4gICAgICAgIGlmIChsaW5lID09PSAnJyB8fCAhdGhpcy5zdHlsZXMgfHwgIXRoaXMuX2dldExpbmVTdHlsZShpKSkge1xuICAgICAgICAgIGxpbmVUb3BPZmZzZXQgKz0gaGVpZ2h0T2ZMaW5lO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZVdpZHRoID0gdGhpcy5fZ2V0TGluZVdpZHRoKGN0eCwgaSk7XG4gICAgICAgIGxpbmVMZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQobGluZVdpZHRoKTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGxpbmUubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICAgICAgc3R5bGUgPSB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGksIGopO1xuICAgICAgICAgIGlmICghc3R5bGUgfHwgIXN0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfY2hhciA9IGxpbmVbal07XG5cbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gc3R5bGUudGV4dEJhY2tncm91bmRDb2xvcjtcblxuICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgIGxlZnRPZmZzZXQgKyBsaW5lTGVmdE9mZnNldCArIHRoaXMuX2dldFdpZHRoT2ZDaGFyc0F0KGN0eCwgaSwgaiksXG4gICAgICAgICAgICB0b3BPZmZzZXQgKyBsaW5lVG9wT2Zmc2V0LFxuICAgICAgICAgICAgdGhpcy5fZ2V0V2lkdGhPZkNoYXIoY3R4LCBfY2hhciwgaSwgaikgKyAxLFxuICAgICAgICAgICAgaGVpZ2h0T2ZMaW5lIC8gdGhpcy5saW5lSGVpZ2h0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lVG9wT2Zmc2V0ICs9IGhlaWdodE9mTGluZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q2FjaGVQcm9wOiBmdW5jdGlvbihfY2hhciwgc3R5bGVEZWNsYXJhdGlvbikge1xuICAgICAgcmV0dXJuIF9jaGFyICtcbiAgICAgICAgICAgICBzdHlsZURlY2xhcmF0aW9uLmZvbnRTaXplICtcbiAgICAgICAgICAgICBzdHlsZURlY2xhcmF0aW9uLmZvbnRXZWlnaHQgK1xuICAgICAgICAgICAgIHN0eWxlRGVjbGFyYXRpb24uZm9udFN0eWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb250RmFtaWx5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHJlZmVyZW5jZSB0byBjYWNoZVxuICAgICAqL1xuICAgIF9nZXRGb250Q2FjaGU6IGZ1bmN0aW9uKGZvbnRGYW1pbHkpIHtcbiAgICAgIGlmICghZmFicmljLmNoYXJXaWR0aHNDYWNoZVtmb250RmFtaWx5XSkge1xuICAgICAgICBmYWJyaWMuY2hhcldpZHRoc0NhY2hlW2ZvbnRGYW1pbHldID0geyB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhYnJpYy5jaGFyV2lkdGhzQ2FjaGVbZm9udEZhbWlseV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBfY2hhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtkZWNsXVxuICAgICAqL1xuICAgIF9hcHBseUNoYXJTdHlsZXNHZXRXaWR0aDogZnVuY3Rpb24oY3R4LCBfY2hhciwgbGluZUluZGV4LCBjaGFySW5kZXgsIGRlY2wpIHtcbiAgICAgIHZhciBjaGFyRGVjbCA9IGRlY2wgfHwgdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgICAgc3R5bGVEZWNsYXJhdGlvbiA9IGNsb25lKGNoYXJEZWNsKSxcbiAgICAgICAgICB3aWR0aCwgY2FjaGVQcm9wLCBjaGFyV2lkdGhzQ2FjaGU7XG5cbiAgICAgIHRoaXMuX2FwcGx5Rm9udFN0eWxlcyhzdHlsZURlY2xhcmF0aW9uKTtcbiAgICAgIGNoYXJXaWR0aHNDYWNoZSA9IHRoaXMuX2dldEZvbnRDYWNoZShzdHlsZURlY2xhcmF0aW9uLmZvbnRGYW1pbHkpO1xuICAgICAgY2FjaGVQcm9wID0gdGhpcy5fZ2V0Q2FjaGVQcm9wKF9jaGFyLCBzdHlsZURlY2xhcmF0aW9uKTtcblxuICAgICAgLy8gc2hvcnQtY2lyY3VpdCBpZiBubyBzdHlsZXMgZm9yIHRoaXMgY2hhclxuICAgICAgLy8gZ2xvYmFsIHN0eWxlIGZyb20gb2JqZWN0IGlzIGFsd2F5cyBhcHBseWVkIGFuZCBoYW5kbGVkIGJ5IHNhdmUgYW5kIHJlc3RvcmVcbiAgICAgIGlmICghY2hhckRlY2wgJiYgY2hhcldpZHRoc0NhY2hlW2NhY2hlUHJvcF0gJiYgdGhpcy5jYWNoaW5nKSB7XG4gICAgICAgIHJldHVybiBjaGFyV2lkdGhzQ2FjaGVbY2FjaGVQcm9wXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzdHlsZURlY2xhcmF0aW9uLnNoYWRvdyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3R5bGVEZWNsYXJhdGlvbi5zaGFkb3cgPSBuZXcgZmFicmljLlNoYWRvdyhzdHlsZURlY2xhcmF0aW9uLnNoYWRvdyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBmaWxsID0gc3R5bGVEZWNsYXJhdGlvbi5maWxsIHx8IHRoaXMuZmlsbDtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsLnRvTGl2ZVxuICAgICAgICA/IGZpbGwudG9MaXZlKGN0eCwgdGhpcylcbiAgICAgICAgOiBmaWxsO1xuXG4gICAgICBpZiAoc3R5bGVEZWNsYXJhdGlvbi5zdHJva2UpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gKHN0eWxlRGVjbGFyYXRpb24uc3Ryb2tlICYmIHN0eWxlRGVjbGFyYXRpb24uc3Ryb2tlLnRvTGl2ZSlcbiAgICAgICAgICA/IHN0eWxlRGVjbGFyYXRpb24uc3Ryb2tlLnRvTGl2ZShjdHgsIHRoaXMpXG4gICAgICAgICAgOiBzdHlsZURlY2xhcmF0aW9uLnN0cm9rZTtcbiAgICAgIH1cblxuICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0eWxlRGVjbGFyYXRpb24uc3Ryb2tlV2lkdGggfHwgdGhpcy5zdHJva2VXaWR0aDtcbiAgICAgIGN0eC5mb250ID0gdGhpcy5fZ2V0Rm9udERlY2xhcmF0aW9uLmNhbGwoc3R5bGVEZWNsYXJhdGlvbik7XG5cbiAgICAgIC8vaWYgd2Ugd2FudCB0aGlzLl9zZXRTaGFkb3cuY2FsbCB0byB3b3JrIHdpdGggc3R5bGVEZWNsYXJpb25cbiAgICAgIC8vd2UgaGF2ZSB0byBhZGQgdGhvc2UgcmVmZXJlbmNlc1xuICAgICAgaWYgKHN0eWxlRGVjbGFyYXRpb24uc2hhZG93KSB7XG4gICAgICAgIHN0eWxlRGVjbGFyYXRpb24uc2NhbGVYID0gdGhpcy5zY2FsZVg7XG4gICAgICAgIHN0eWxlRGVjbGFyYXRpb24uc2NhbGVZID0gdGhpcy5zY2FsZVk7XG4gICAgICAgIHN0eWxlRGVjbGFyYXRpb24uY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICAgIHN0eWxlRGVjbGFyYXRpb24uZ2V0T2JqZWN0U2NhbGluZyA9IHRoaXMuZ2V0T2JqZWN0U2NhbGluZztcbiAgICAgICAgdGhpcy5fc2V0U2hhZG93LmNhbGwoc3R5bGVEZWNsYXJhdGlvbiwgY3R4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmNhY2hpbmcgfHwgIWNoYXJXaWR0aHNDYWNoZVtjYWNoZVByb3BdKSB7XG4gICAgICAgIHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KF9jaGFyKS53aWR0aDtcbiAgICAgICAgdGhpcy5jYWNoaW5nICYmIChjaGFyV2lkdGhzQ2FjaGVbY2FjaGVQcm9wXSA9IHdpZHRoKTtcbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhcldpZHRoc0NhY2hlW2NhY2hlUHJvcF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlRGVjbGFyYXRpb25cbiAgICAgKi9cbiAgICBfYXBwbHlGb250U3R5bGVzOiBmdW5jdGlvbihzdHlsZURlY2xhcmF0aW9uKSB7XG4gICAgICBpZiAoIXN0eWxlRGVjbGFyYXRpb24uZm9udEZhbWlseSkge1xuICAgICAgICBzdHlsZURlY2xhcmF0aW9uLmZvbnRGYW1pbHkgPSB0aGlzLmZvbnRGYW1pbHk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0eWxlRGVjbGFyYXRpb24uZm9udFNpemUpIHtcbiAgICAgICAgc3R5bGVEZWNsYXJhdGlvbi5mb250U2l6ZSA9IHRoaXMuZm9udFNpemU7XG4gICAgICB9XG4gICAgICBpZiAoIXN0eWxlRGVjbGFyYXRpb24uZm9udFdlaWdodCkge1xuICAgICAgICBzdHlsZURlY2xhcmF0aW9uLmZvbnRXZWlnaHQgPSB0aGlzLmZvbnRXZWlnaHQ7XG4gICAgICB9XG4gICAgICBpZiAoIXN0eWxlRGVjbGFyYXRpb24uZm9udFN0eWxlKSB7XG4gICAgICAgIHN0eWxlRGVjbGFyYXRpb24uZm9udFN0eWxlID0gdGhpcy5mb250U3R5bGU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcmV0dXJuQ2xvbmVPckVtcHR5PWZhbHNlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFN0eWxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4LCByZXR1cm5DbG9uZU9yRW1wdHkpIHtcbiAgICAgIGlmIChyZXR1cm5DbG9uZU9yRW1wdHkpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnN0eWxlc1tsaW5lSW5kZXhdICYmIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4XSlcbiAgICAgICAgICA/IGNsb25lKHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4XSlcbiAgICAgICAgICA6IHsgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gJiYgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXhdID8gdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXhdIDogbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgc3R5bGUpIHtcbiAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4XSA9IHN0eWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGVsZXRlU3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRMaW5lU3R5bGU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3R5bGVzW2xpbmVJbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRMaW5lU3R5bGU6IGZ1bmN0aW9uKGxpbmVJbmRleCwgc3R5bGUpIHtcbiAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gPSBzdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RlbGV0ZUxpbmVTdHlsZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZUluZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX2dldFdpZHRoT2ZDaGFyOiBmdW5jdGlvbihjdHgsIF9jaGFyLCBsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgICAgaWYgKCF0aGlzLl9pc01lYXN1cmluZyAmJiB0aGlzLnRleHRBbGlnbiA9PT0gJ2p1c3RpZnknICYmIHRoaXMuX3JlU3BhY2VzQW5kVGFicy50ZXN0KF9jaGFyKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0V2lkdGhPZlNwYWNlKGN0eCwgbGluZUluZGV4KTtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLl9hcHBseUNoYXJTdHlsZXNHZXRXaWR0aChjdHgsIF9jaGFyLCBsaW5lSW5kZXgsIGNoYXJJbmRleCk7XG4gICAgICBpZiAodGhpcy5jaGFyU3BhY2luZyAhPT0gMCkge1xuICAgICAgICB3aWR0aCArPSB0aGlzLl9nZXRXaWR0aE9mQ2hhclNwYWNpbmcoKTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm4gd2lkdGggPiAwID8gd2lkdGggOiAwXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICovXG4gICAgX2dldEhlaWdodE9mQ2hhcjogZnVuY3Rpb24oY3R4LCBsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgICAgdmFyIHN0eWxlID0gdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCk7XG4gICAgICByZXR1cm4gc3R5bGUgJiYgc3R5bGUuZm9udFNpemUgPyBzdHlsZS5mb250U2l6ZSA6IHRoaXMuZm9udFNpemU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICovXG4gICAgX2dldFdpZHRoT2ZDaGFyc0F0OiBmdW5jdGlvbihjdHgsIGxpbmVJbmRleCwgY2hhckluZGV4KSB7XG4gICAgICB2YXIgd2lkdGggPSAwLCBpLCBfY2hhcjtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGFySW5kZXg7IGkrKykge1xuICAgICAgICBfY2hhciA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdW2ldO1xuICAgICAgICB3aWR0aCArPSB0aGlzLl9nZXRXaWR0aE9mQ2hhcihjdHgsIF9jaGFyLCBsaW5lSW5kZXgsIGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IGxpbmUgbnVtYmVyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBMaW5lIHdpZHRoXG4gICAgICovXG4gICAgX21lYXN1cmVMaW5lOiBmdW5jdGlvbihjdHgsIGxpbmVJbmRleCkge1xuICAgICAgdGhpcy5faXNNZWFzdXJpbmcgPSB0cnVlO1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJzQXQoY3R4LCBsaW5lSW5kZXgsIHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLmxlbmd0aCk7XG4gICAgICBpZiAodGhpcy5jaGFyU3BhY2luZyAhPT0gMCkge1xuICAgICAgICB3aWR0aCAtPSB0aGlzLl9nZXRXaWR0aE9mQ2hhclNwYWNpbmcoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2lzTWVhc3VyaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gd2lkdGggPiAwID8gd2lkdGggOiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICovXG4gICAgX2dldFdpZHRoT2ZTcGFjZTogZnVuY3Rpb24gKGN0eCwgbGluZUluZGV4KSB7XG4gICAgICBpZiAodGhpcy5fX3dpZHRoT2ZTcGFjZVtsaW5lSW5kZXhdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fd2lkdGhPZlNwYWNlW2xpbmVJbmRleF07XG4gICAgICB9XG4gICAgICB2YXIgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLFxuICAgICAgICAgIHdvcmRzV2lkdGggPSB0aGlzLl9nZXRXaWR0aE9mV29yZHMoY3R4LCBsaW5lLCBsaW5lSW5kZXgsIDApLFxuICAgICAgICAgIHdpZHRoRGlmZiA9IHRoaXMud2lkdGggLSB3b3Jkc1dpZHRoLFxuICAgICAgICAgIG51bVNwYWNlcyA9IGxpbmUubGVuZ3RoIC0gbGluZS5yZXBsYWNlKHRoaXMuX3JlU3BhY2VzQW5kVGFicywgJycpLmxlbmd0aCxcbiAgICAgICAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoRGlmZiAvIG51bVNwYWNlcywgY3R4Lm1lYXN1cmVUZXh0KCcgJykud2lkdGgpO1xuICAgICAgdGhpcy5fX3dpZHRoT2ZTcGFjZVtsaW5lSW5kZXhdID0gd2lkdGg7XG4gICAgICByZXR1cm4gd2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFyT2Zmc2V0XG4gICAgICovXG4gICAgX2dldFdpZHRoT2ZXb3JkczogZnVuY3Rpb24gKGN0eCwgbGluZSwgbGluZUluZGV4LCBjaGFyT2Zmc2V0KSB7XG4gICAgICB2YXIgd2lkdGggPSAwO1xuXG4gICAgICBmb3IgKHZhciBjaGFySW5kZXggPSAwOyBjaGFySW5kZXggPCBsaW5lLmxlbmd0aDsgY2hhckluZGV4KyspIHtcbiAgICAgICAgdmFyIF9jaGFyID0gbGluZVtjaGFySW5kZXhdO1xuXG4gICAgICAgIGlmICghX2NoYXIubWF0Y2goL1xccy8pKSB7XG4gICAgICAgICAgd2lkdGggKz0gdGhpcy5fZ2V0V2lkdGhPZkNoYXIoY3R4LCBfY2hhciwgbGluZUluZGV4LCBjaGFySW5kZXggKyBjaGFyT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gd2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9nZXRIZWlnaHRPZkxpbmU6IGZ1bmN0aW9uKGN0eCwgbGluZUluZGV4KSB7XG4gICAgICBpZiAodGhpcy5fX2xpbmVIZWlnaHRzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19saW5lSGVpZ2h0c1tsaW5lSW5kZXhdO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLFxuICAgICAgICAgIG1heEhlaWdodCA9IHRoaXMuX2dldEhlaWdodE9mQ2hhcihjdHgsIGxpbmVJbmRleCwgMCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBsaW5lLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJyZW50Q2hhckhlaWdodCA9IHRoaXMuX2dldEhlaWdodE9mQ2hhcihjdHgsIGxpbmVJbmRleCwgaSk7XG4gICAgICAgIGlmIChjdXJyZW50Q2hhckhlaWdodCA+IG1heEhlaWdodCkge1xuICAgICAgICAgIG1heEhlaWdodCA9IGN1cnJlbnRDaGFySGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9fbGluZUhlaWdodHNbbGluZUluZGV4XSA9IG1heEhlaWdodCAqIHRoaXMubGluZUhlaWdodCAqIHRoaXMuX2ZvbnRTaXplTXVsdDtcbiAgICAgIHJldHVybiB0aGlzLl9fbGluZUhlaWdodHNbbGluZUluZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX2dldFRleHRIZWlnaHQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIGxpbmVIZWlnaHQsIGhlaWdodCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxpbmVIZWlnaHQgPSB0aGlzLl9nZXRIZWlnaHRPZkxpbmUoY3R4LCBpKTtcbiAgICAgICAgaGVpZ2h0ICs9IChpID09PSBsZW4gLSAxID8gbGluZUhlaWdodCAvIHRoaXMubGluZUhlaWdodCA6IGxpbmVIZWlnaHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kIHRvT2JqZWN0XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBjbG9uZWRTdHlsZXMgPSB7IH0sIGksIGosIHJvdztcbiAgICAgIGZvciAoaSBpbiB0aGlzLnN0eWxlcykge1xuICAgICAgICByb3cgPSB0aGlzLnN0eWxlc1tpXTtcbiAgICAgICAgY2xvbmVkU3R5bGVzW2ldID0geyB9O1xuICAgICAgICBmb3IgKGogaW4gcm93KSB7XG4gICAgICAgICAgY2xvbmVkU3R5bGVzW2ldW2pdID0gY2xvbmUocm93W2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JywgcHJvcGVydGllc1RvSW5jbHVkZSksIHtcbiAgICAgICAgc3R5bGVzOiBjbG9uZWRTdHlsZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLklUZXh0IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JVGV4dFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGludm9rZWQgd2l0aCBuZXcgaW5zdGFuY2UgYXMgYXJndW1lbnRcbiAgICogQHJldHVybiB7ZmFicmljLklUZXh0fSBpbnN0YW5jZSBvZiBmYWJyaWMuSVRleHRcbiAgICovXG4gIGZhYnJpYy5JVGV4dC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHZhciBpVGV4dCA9IG5ldyBmYWJyaWMuSVRleHQob2JqZWN0LnRleHQsIGNsb25lKG9iamVjdCkpO1xuICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGlUZXh0KTtcbiAgICByZXR1cm4gaVRleHQ7XG4gIH07XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmU7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuSVRleHQucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5JVGV4dC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYWxsIHRoZSBpbnRlcmFjdGl2ZSBiZWhhdmlvciBvZiBJVGV4dFxuICAgICAqL1xuICAgIGluaXRCZWhhdmlvcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmluaXRBZGRlZEhhbmRsZXIoKTtcbiAgICAgIHRoaXMuaW5pdFJlbW92ZWRIYW5kbGVyKCk7XG4gICAgICB0aGlzLmluaXRDdXJzb3JTZWxlY3Rpb25IYW5kbGVycygpO1xuICAgICAgdGhpcy5pbml0RG91YmxlQ2xpY2tTaW11bGF0aW9uKCk7XG4gICAgICB0aGlzLm1vdXNlTW92ZUhhbmRsZXIgPSB0aGlzLm1vdXNlTW92ZUhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgXCJzZWxlY3RlZFwiIGV2ZW50IGhhbmRsZXJcbiAgICAgKi9cbiAgICBpbml0U2VsZWN0ZWRIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMub24oJ3NlbGVjdGVkJywgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBfdGhpcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgXCJhZGRlZFwiIGV2ZW50IGhhbmRsZXJcbiAgICAgKi9cbiAgICBpbml0QWRkZWRIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLm9uKCdhZGRlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2FudmFzID0gX3RoaXMuY2FudmFzO1xuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgaWYgKCFjYW52YXMuX2hhc0lUZXh0SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGNhbnZhcy5faGFzSVRleHRIYW5kbGVycyA9IHRydWU7XG4gICAgICAgICAgICBfdGhpcy5faW5pdENhbnZhc0hhbmRsZXJzKGNhbnZhcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbnZhcy5faVRleHRJbnN0YW5jZXMgPSBjYW52YXMuX2lUZXh0SW5zdGFuY2VzIHx8IFtdO1xuICAgICAgICAgIGNhbnZhcy5faVRleHRJbnN0YW5jZXMucHVzaChfdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBpbml0UmVtb3ZlZEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMub24oJ3JlbW92ZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IF90aGlzLmNhbnZhcztcbiAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgIGNhbnZhcy5faVRleHRJbnN0YW5jZXMgPSBjYW52YXMuX2lUZXh0SW5zdGFuY2VzIHx8IFtdO1xuICAgICAgICAgIGZhYnJpYy51dGlsLnJlbW92ZUZyb21BcnJheShjYW52YXMuX2lUZXh0SW5zdGFuY2VzLCBfdGhpcyk7XG4gICAgICAgICAgaWYgKGNhbnZhcy5faVRleHRJbnN0YW5jZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjYW52YXMuX2hhc0lUZXh0SGFuZGxlcnMgPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLl9yZW1vdmVDYW52YXNIYW5kbGVycyhjYW52YXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlZ2lzdGVyIGNhbnZhcyBldmVudCB0byBtYW5hZ2UgZXhpdGluZyBvbiBvdGhlciBpbnN0YW5jZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0Q2FudmFzSGFuZGxlcnM6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgY2FudmFzLl9jYW52YXNJVGV4dFNlbGVjdGlvbkNsZWFyZWRIYW5sZGVyID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmYWJyaWMuSVRleHQucHJvdG90eXBlLmV4aXRFZGl0aW5nT25PdGhlcnMoY2FudmFzKTtcbiAgICAgIH0pLmJpbmQodGhpcyk7XG4gICAgICBjYW52YXMuX21vdXNlVXBJVGV4dEhhbmRsZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChjYW52YXMuX2lUZXh0SW5zdGFuY2VzKSB7XG4gICAgICAgICAgY2FudmFzLl9pVGV4dEluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgb2JqLl9faXNNb3VzZWRvd24gPSBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSkuYmluZCh0aGlzKTtcbiAgICAgIGNhbnZhcy5vbignc2VsZWN0aW9uOmNsZWFyZWQnLCBjYW52YXMuX2NhbnZhc0lUZXh0U2VsZWN0aW9uQ2xlYXJlZEhhbmxkZXIpO1xuICAgICAgY2FudmFzLm9uKCdvYmplY3Q6c2VsZWN0ZWQnLCBjYW52YXMuX2NhbnZhc0lUZXh0U2VsZWN0aW9uQ2xlYXJlZEhhbmxkZXIpO1xuICAgICAgY2FudmFzLm9uKCdtb3VzZTp1cCcsIGNhbnZhcy5fbW91c2VVcElUZXh0SGFuZGxlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBjYW52YXMgZXZlbnQgdG8gbWFuYWdlIGV4aXRpbmcgb24gb3RoZXIgaW5zdGFuY2VzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVtb3ZlQ2FudmFzSGFuZGxlcnM6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgY2FudmFzLm9mZignc2VsZWN0aW9uOmNsZWFyZWQnLCBjYW52YXMuX2NhbnZhc0lUZXh0U2VsZWN0aW9uQ2xlYXJlZEhhbmxkZXIpO1xuICAgICAgY2FudmFzLm9mZignb2JqZWN0OnNlbGVjdGVkJywgY2FudmFzLl9jYW52YXNJVGV4dFNlbGVjdGlvbkNsZWFyZWRIYW5sZGVyKTtcbiAgICAgIGNhbnZhcy5vZmYoJ21vdXNlOnVwJywgY2FudmFzLl9tb3VzZVVwSVRleHRIYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdGljazogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jdXJyZW50VGlja1N0YXRlID0gdGhpcy5fYW5pbWF0ZUN1cnNvcih0aGlzLCAxLCB0aGlzLmN1cnNvckR1cmF0aW9uLCAnX29uVGlja0NvbXBsZXRlJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FuaW1hdGVDdXJzb3I6IGZ1bmN0aW9uKG9iaiwgdGFyZ2V0T3BhY2l0eSwgZHVyYXRpb24sIGNvbXBsZXRlTWV0aG9kKSB7XG5cbiAgICAgIHZhciB0aWNrU3RhdGU7XG5cbiAgICAgIHRpY2tTdGF0ZSA9IHtcbiAgICAgICAgaXNBYm9ydGVkOiBmYWxzZSxcbiAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuaXNBYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIG9iai5hbmltYXRlKCdfY3VycmVudEN1cnNvck9wYWNpdHknLCB0YXJnZXRPcGFjaXR5LCB7XG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCF0aWNrU3RhdGUuaXNBYm9ydGVkKSB7XG4gICAgICAgICAgICBvYmpbY29tcGxldGVNZXRob2RdKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gYW5pbWF0ZSBhIHNlbGVjdGlvbiwgb25seSBjdXJzb3JcbiAgICAgICAgICBpZiAob2JqLmNhbnZhcyAmJiBvYmouc2VsZWN0aW9uU3RhcnQgPT09IG9iai5zZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgIG9iai5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aWNrU3RhdGUuaXNBYm9ydGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aWNrU3RhdGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uVGlja0NvbXBsZXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2N1cnNvclRpbWVvdXQxKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9jdXJzb3JUaW1lb3V0MSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jdXJzb3JUaW1lb3V0MSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLl9jdXJyZW50VGlja0NvbXBsZXRlU3RhdGUgPSBfdGhpcy5fYW5pbWF0ZUN1cnNvcihfdGhpcywgMCwgdGhpcy5jdXJzb3JEdXJhdGlvbiAvIDIsICdfdGljaycpO1xuICAgICAgfSwgMTAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgZGVsYXllZCBjdXJzb3JcbiAgICAgKi9cbiAgICBpbml0RGVsYXllZEN1cnNvcjogZnVuY3Rpb24ocmVzdGFydCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICBkZWxheSA9IHJlc3RhcnQgPyAwIDogdGhpcy5jdXJzb3JEZWxheTtcblxuICAgICAgdGhpcy5hYm9ydEN1cnNvckFuaW1hdGlvbigpO1xuICAgICAgdGhpcy5fY3VycmVudEN1cnNvck9wYWNpdHkgPSAxO1xuICAgICAgdGhpcy5fY3Vyc29yVGltZW91dDIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5fdGljaygpO1xuICAgICAgfSwgZGVsYXkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBYm9ydHMgY3Vyc29yIGFuaW1hdGlvbiBhbmQgY2xlYXJzIGFsbCB0aW1lb3V0c1xuICAgICAqL1xuICAgIGFib3J0Q3Vyc29yQW5pbWF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzaG91bGRDbGVhciA9IHRoaXMuX2N1cnJlbnRUaWNrU3RhdGUgfHwgdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlO1xuICAgICAgdGhpcy5fY3VycmVudFRpY2tTdGF0ZSAmJiB0aGlzLl9jdXJyZW50VGlja1N0YXRlLmFib3J0KCk7XG4gICAgICB0aGlzLl9jdXJyZW50VGlja0NvbXBsZXRlU3RhdGUgJiYgdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlLmFib3J0KCk7XG5cbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9jdXJzb3JUaW1lb3V0MSk7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fY3Vyc29yVGltZW91dDIpO1xuXG4gICAgICB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eSA9IDA7XG4gICAgICAvLyB0byBjbGVhciBqdXN0IGl0ZXh0IGFyZWEgd2UgbmVlZCB0byB0cmFuc2Zvcm0gdGhlIGNvbnRleHRcbiAgICAgIC8vIGl0IG1heSBub3QgYmUgd29ydGggaXRcbiAgICAgIGlmIChzaG91bGRDbGVhcikge1xuICAgICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCB8fCB0aGlzLmN0eCk7XG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyBlbnRpcmUgdGV4dFxuICAgICAqL1xuICAgIHNlbGVjdEFsbDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gMDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHNlbGVjdGVkIHRleHRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U2VsZWN0ZWRUZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQuc2xpY2UodGhpcy5zZWxlY3Rpb25TdGFydCwgdGhpcy5zZWxlY3Rpb25FbmQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIG5ldyBzZWxlY3Rpb24gaW5kZXggcmVwcmVzZW50aW5nIHN0YXJ0IG9mIGN1cnJlbnQgd29yZCBhY2NvcmRpbmcgdG8gY3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRGcm9tIFN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBOZXcgc2VsZWN0aW9uIGluZGV4XG4gICAgICovXG4gICAgZmluZFdvcmRCb3VuZGFyeUxlZnQ6IGZ1bmN0aW9uKHN0YXJ0RnJvbSkge1xuICAgICAgdmFyIG9mZnNldCA9IDAsIGluZGV4ID0gc3RhcnRGcm9tIC0gMTtcblxuICAgICAgLy8gcmVtb3ZlIHNwYWNlIGJlZm9yZSBjdXJzb3IgZmlyc3RcbiAgICAgIGlmICh0aGlzLl9yZVNwYWNlLnRlc3QodGhpcy50ZXh0LmNoYXJBdChpbmRleCkpKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9yZVNwYWNlLnRlc3QodGhpcy50ZXh0LmNoYXJBdChpbmRleCkpKSB7XG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKC9cXFMvLnRlc3QodGhpcy50ZXh0LmNoYXJBdChpbmRleCkpICYmIGluZGV4ID4gLTEpIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGFydEZyb20gLSBvZmZzZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgbmV3IHNlbGVjdGlvbiBpbmRleCByZXByZXNlbnRpbmcgZW5kIG9mIGN1cnJlbnQgd29yZCBhY2NvcmRpbmcgdG8gY3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRGcm9tIEN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBOZXcgc2VsZWN0aW9uIGluZGV4XG4gICAgICovXG4gICAgZmluZFdvcmRCb3VuZGFyeVJpZ2h0OiBmdW5jdGlvbihzdGFydEZyb20pIHtcbiAgICAgIHZhciBvZmZzZXQgPSAwLCBpbmRleCA9IHN0YXJ0RnJvbTtcblxuICAgICAgLy8gcmVtb3ZlIHNwYWNlIGFmdGVyIGN1cnNvciBmaXJzdFxuICAgICAgaWYgKHRoaXMuX3JlU3BhY2UudGVzdCh0aGlzLnRleHQuY2hhckF0KGluZGV4KSkpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3JlU3BhY2UudGVzdCh0aGlzLnRleHQuY2hhckF0KGluZGV4KSkpIHtcbiAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoL1xcUy8udGVzdCh0aGlzLnRleHQuY2hhckF0KGluZGV4KSkgJiYgaW5kZXggPCB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhcnRGcm9tICsgb2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIG5ldyBzZWxlY3Rpb24gaW5kZXggcmVwcmVzZW50aW5nIHN0YXJ0IG9mIGN1cnJlbnQgbGluZSBhY2NvcmRpbmcgdG8gY3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRGcm9tIEN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBOZXcgc2VsZWN0aW9uIGluZGV4XG4gICAgICovXG4gICAgZmluZExpbmVCb3VuZGFyeUxlZnQ6IGZ1bmN0aW9uKHN0YXJ0RnJvbSkge1xuICAgICAgdmFyIG9mZnNldCA9IDAsIGluZGV4ID0gc3RhcnRGcm9tIC0gMTtcblxuICAgICAgd2hpbGUgKCEvXFxuLy50ZXN0KHRoaXMudGV4dC5jaGFyQXQoaW5kZXgpKSAmJiBpbmRleCA+IC0xKSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhcnRGcm9tIC0gb2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIG5ldyBzZWxlY3Rpb24gaW5kZXggcmVwcmVzZW50aW5nIGVuZCBvZiBjdXJyZW50IGxpbmUgYWNjb3JkaW5nIHRvIGN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0RnJvbSBDdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTmV3IHNlbGVjdGlvbiBpbmRleFxuICAgICAqL1xuICAgIGZpbmRMaW5lQm91bmRhcnlSaWdodDogZnVuY3Rpb24oc3RhcnRGcm9tKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMCwgaW5kZXggPSBzdGFydEZyb207XG5cbiAgICAgIHdoaWxlICghL1xcbi8udGVzdCh0aGlzLnRleHQuY2hhckF0KGluZGV4KSkgJiYgaW5kZXggPCB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhcnRGcm9tICsgb2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG51bWJlciBvZiBuZXdsaW5lcyBpbiBzZWxlY3RlZCB0ZXh0XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBOdW1iZXIgb2YgbmV3bGluZXMgaW4gc2VsZWN0ZWQgdGV4dFxuICAgICAqL1xuICAgIGdldE51bU5ld0xpbmVzSW5TZWxlY3RlZFRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGVjdGVkVGV4dCA9IHRoaXMuZ2V0U2VsZWN0ZWRUZXh0KCksXG4gICAgICAgICAgbnVtTmV3TGluZXMgID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlbGVjdGVkVGV4dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoc2VsZWN0ZWRUZXh0W2ldID09PSAnXFxuJykge1xuICAgICAgICAgIG51bU5ld0xpbmVzKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudW1OZXdMaW5lcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgaW5kZXggY29ycmVzcG9uZGluZyB0byBiZWdpbm5pbmcgb3IgZW5kIG9mIGEgd29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWxlY3Rpb25TdGFydCBJbmRleCBvZiBhIGNoYXJhY3RlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb24gMSBvciAtMVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gSW5kZXggb2YgdGhlIGJlZ2lubmluZyBvciBlbmQgb2YgYSB3b3JkXG4gICAgICovXG4gICAgc2VhcmNoV29yZEJvdW5kYXJ5OiBmdW5jdGlvbihzZWxlY3Rpb25TdGFydCwgZGlyZWN0aW9uKSB7XG4gICAgICB2YXIgaW5kZXggICAgID0gdGhpcy5fcmVTcGFjZS50ZXN0KHRoaXMudGV4dC5jaGFyQXQoc2VsZWN0aW9uU3RhcnQpKSA/IHNlbGVjdGlvblN0YXJ0IC0gMSA6IHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgIF9jaGFyICAgICA9IHRoaXMudGV4dC5jaGFyQXQoaW5kZXgpLFxuICAgICAgICAgIHJlTm9uV29yZCA9IC9bIFxcblxcLiw7IVxcP1xcLV0vO1xuXG4gICAgICB3aGlsZSAoIXJlTm9uV29yZC50ZXN0KF9jaGFyKSAmJiBpbmRleCA+IDAgJiYgaW5kZXggPCB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgIGluZGV4ICs9IGRpcmVjdGlvbjtcbiAgICAgICAgX2NoYXIgPSB0aGlzLnRleHQuY2hhckF0KGluZGV4KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZU5vbldvcmQudGVzdChfY2hhcikgJiYgX2NoYXIgIT09ICdcXG4nKSB7XG4gICAgICAgIGluZGV4ICs9IGRpcmVjdGlvbiA9PT0gMSA/IDAgOiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGEgd29yZCBiYXNlZCBvbiB0aGUgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2VsZWN0aW9uU3RhcnQgSW5kZXggb2YgYSBjaGFyYWN0ZXJcbiAgICAgKi9cbiAgICBzZWxlY3RXb3JkOiBmdW5jdGlvbihzZWxlY3Rpb25TdGFydCkge1xuICAgICAgc2VsZWN0aW9uU3RhcnQgPSBzZWxlY3Rpb25TdGFydCB8fCB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgdmFyIG5ld1NlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWFyY2hXb3JkQm91bmRhcnkoc2VsZWN0aW9uU3RhcnQsIC0xKSwgLyogc2VhcmNoIGJhY2t3YXJkcyAqL1xuICAgICAgICAgIG5ld1NlbGVjdGlvbkVuZCA9IHRoaXMuc2VhcmNoV29yZEJvdW5kYXJ5KHNlbGVjdGlvblN0YXJ0LCAxKTsgLyogc2VhcmNoIGZvcndhcmQgKi9cblxuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvblN0YXJ0O1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb25FbmQ7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICAgIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyBhIGxpbmUgYmFzZWQgb24gdGhlIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNlbGVjdGlvblN0YXJ0IEluZGV4IG9mIGEgY2hhcmFjdGVyXG4gICAgICovXG4gICAgc2VsZWN0TGluZTogZnVuY3Rpb24oc2VsZWN0aW9uU3RhcnQpIHtcbiAgICAgIHNlbGVjdGlvblN0YXJ0ID0gc2VsZWN0aW9uU3RhcnQgfHwgdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgIHZhciBuZXdTZWxlY3Rpb25TdGFydCA9IHRoaXMuZmluZExpbmVCb3VuZGFyeUxlZnQoc2VsZWN0aW9uU3RhcnQpLFxuICAgICAgICAgIG5ld1NlbGVjdGlvbkVuZCA9IHRoaXMuZmluZExpbmVCb3VuZGFyeVJpZ2h0KHNlbGVjdGlvblN0YXJ0KTtcblxuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvblN0YXJ0O1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb25FbmQ7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW50ZXJzIGVkaXRpbmcgc3RhdGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZW50ZXJFZGl0aW5nOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAodGhpcy5pc0VkaXRpbmcgfHwgIXRoaXMuZWRpdGFibGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5leGl0RWRpdGluZ09uT3RoZXJzKHRoaXMuY2FudmFzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pc0VkaXRpbmcgPSB0cnVlO1xuXG4gICAgICB0aGlzLmluaXRIaWRkZW5UZXh0YXJlYShlKTtcbiAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuZm9jdXMoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgICB0aGlzLl9zYXZlRWRpdGluZ1Byb3BzKCk7XG4gICAgICB0aGlzLl9zZXRFZGl0aW5nUHJvcHMoKTtcbiAgICAgIHRoaXMuX3RleHRCZWZvcmVFZGl0ID0gdGhpcy50ZXh0O1xuXG4gICAgICB0aGlzLl90aWNrKCk7XG4gICAgICB0aGlzLmZpcmUoJ2VkaXRpbmc6ZW50ZXJlZCcpO1xuXG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5jYW52YXMuZmlyZSgndGV4dDplZGl0aW5nOmVudGVyZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgIHRoaXMuaW5pdE1vdXNlTW92ZUhhbmRsZXIoKTtcbiAgICAgIHRoaXMuY2FudmFzLnJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGV4aXRFZGl0aW5nT25PdGhlcnM6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgaWYgKGNhbnZhcy5faVRleHRJbnN0YW5jZXMpIHtcbiAgICAgICAgY2FudmFzLl9pVGV4dEluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgIG9iai5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChvYmouaXNFZGl0aW5nKSB7XG4gICAgICAgICAgICBvYmouZXhpdEVkaXRpbmcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBcIm1vdXNlbW92ZVwiIGV2ZW50IGhhbmRsZXJcbiAgICAgKi9cbiAgICBpbml0TW91c2VNb3ZlSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNhbnZhcy5vbignbW91c2U6bW92ZScsIHRoaXMubW91c2VNb3ZlSGFuZGxlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbW91c2VNb3ZlSGFuZGxlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKCF0aGlzLl9faXNNb3VzZWRvd24gfHwgIXRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld1NlbGVjdGlvblN0YXJ0ID0gdGhpcy5nZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyKG9wdGlvbnMuZSksXG4gICAgICAgICAgY3VycmVudFN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICBjdXJyZW50RW5kID0gdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgICBpZiAobmV3U2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuX19zZWxlY3Rpb25TdGFydE9uTW91c2VEb3duKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdTZWxlY3Rpb25TdGFydCA+IHRoaXMuX19zZWxlY3Rpb25TdGFydE9uTW91c2VEb3duKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSB0aGlzLl9fc2VsZWN0aW9uU3RhcnRPbk1vdXNlRG93bjtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb25TdGFydDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5fX3NlbGVjdGlvblN0YXJ0T25Nb3VzZURvd247XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCAhPT0gY3VycmVudFN0YXJ0IHx8IHRoaXMuc2VsZWN0aW9uRW5kICE9PSBjdXJyZW50RW5kKSB7XG4gICAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgICAgIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0RWRpdGluZ1Byb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaG92ZXJDdXJzb3IgPSAndGV4dCc7XG5cbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcy5kZWZhdWx0Q3Vyc29yID0gdGhpcy5jYW52YXMubW92ZUN1cnNvciA9ICd0ZXh0JztcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib3JkZXJDb2xvciA9IHRoaXMuZWRpdGluZ0JvcmRlckNvbG9yO1xuXG4gICAgICB0aGlzLmhhc0NvbnRyb2xzID0gdGhpcy5zZWxlY3RhYmxlID0gZmFsc2U7XG4gICAgICB0aGlzLmxvY2tNb3ZlbWVudFggPSB0aGlzLmxvY2tNb3ZlbWVudFkgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVUZXh0YXJlYTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuaGlkZGVuVGV4dGFyZWEgfHwgdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmN1cnNvck9mZnNldENhY2hlID0geyB9O1xuICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZSA9IHRoaXMudGV4dDtcbiAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvbkVuZDtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLl9jYWxjVGV4dGFyZWFQb3NpdGlvbigpO1xuICAgICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnN0eWxlLmxlZnQgPSBzdHlsZS5sZWZ0O1xuICAgICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnN0eWxlLnRvcCA9IHN0eWxlLnRvcDtcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zdHlsZS5mb250U2l6ZSA9IHN0eWxlLmZvbnRTaXplO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gc3R5bGUgY29udGFpbnMgc3R5bGUgZm9yIGhpZGRlblRleHRhcmVhXG4gICAgICovXG4gICAgX2NhbGNUZXh0YXJlYVBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogMSwgeTogMSB9O1xuICAgICAgfVxuICAgICAgdmFyIGNoYXJzID0gdGhpcy50ZXh0LnNwbGl0KCcnKSxcbiAgICAgICAgICBib3VuZGFyaWVzID0gdGhpcy5fZ2V0Q3Vyc29yQm91bmRhcmllcyhjaGFycywgJ2N1cnNvcicpLFxuICAgICAgICAgIGN1cnNvckxvY2F0aW9uID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKCksXG4gICAgICAgICAgbGluZUluZGV4ID0gY3Vyc29yTG9jYXRpb24ubGluZUluZGV4LFxuICAgICAgICAgIGNoYXJJbmRleCA9IGN1cnNvckxvY2F0aW9uLmNoYXJJbmRleCxcbiAgICAgICAgICBjaGFySGVpZ2h0ID0gdGhpcy5nZXRDdXJyZW50Q2hhckZvbnRTaXplKGxpbmVJbmRleCwgY2hhckluZGV4KSxcbiAgICAgICAgICBsZWZ0T2Zmc2V0ID0gKGxpbmVJbmRleCA9PT0gMCAmJiBjaGFySW5kZXggPT09IDApXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQodGhpcy5fZ2V0TGluZVdpZHRoKHRoaXMuY3R4LCBsaW5lSW5kZXgpKVxuICAgICAgICAgICAgICAgICAgICA6IGJvdW5kYXJpZXMubGVmdE9mZnNldCxcbiAgICAgICAgICBtID0gdGhpcy5jYWxjVHJhbnNmb3JtTWF0cml4KCksXG4gICAgICAgICAgcCA9IHtcbiAgICAgICAgICAgIHg6IGJvdW5kYXJpZXMubGVmdCArIGxlZnRPZmZzZXQsXG4gICAgICAgICAgICB5OiBib3VuZGFyaWVzLnRvcCArIGJvdW5kYXJpZXMudG9wT2Zmc2V0ICsgY2hhckhlaWdodFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdXBwZXJDYW52YXMgPSB0aGlzLmNhbnZhcy51cHBlckNhbnZhc0VsLFxuICAgICAgICAgIG1heFdpZHRoID0gdXBwZXJDYW52YXMud2lkdGggLSBjaGFySGVpZ2h0LFxuICAgICAgICAgIG1heEhlaWdodCA9IHVwcGVyQ2FudmFzLmhlaWdodCAtIGNoYXJIZWlnaHQ7XG5cbiAgICAgIHAgPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChwLCBtKTtcbiAgICAgIHAgPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChwLCB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybSk7XG5cbiAgICAgIGlmIChwLnggPCAwKSB7XG4gICAgICAgIHAueCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAocC54ID4gbWF4V2lkdGgpIHtcbiAgICAgICAgcC54ID0gbWF4V2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAocC55IDwgMCkge1xuICAgICAgICBwLnkgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHAueSA+IG1heEhlaWdodCkge1xuICAgICAgICBwLnkgPSBtYXhIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCBjYW52YXMgb2Zmc2V0IG9uIGRvY3VtZW50XG4gICAgICBwLnggKz0gdGhpcy5jYW52YXMuX29mZnNldC5sZWZ0O1xuICAgICAgcC55ICs9IHRoaXMuY2FudmFzLl9vZmZzZXQudG9wO1xuXG4gICAgICByZXR1cm4geyBsZWZ0OiBwLnggKyAncHgnLCB0b3A6IHAueSArICdweCcsIGZvbnRTaXplOiBjaGFySGVpZ2h0IH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NhdmVFZGl0aW5nUHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fc2F2ZWRQcm9wcyA9IHtcbiAgICAgICAgaGFzQ29udHJvbHM6IHRoaXMuaGFzQ29udHJvbHMsXG4gICAgICAgIGJvcmRlckNvbG9yOiB0aGlzLmJvcmRlckNvbG9yLFxuICAgICAgICBsb2NrTW92ZW1lbnRYOiB0aGlzLmxvY2tNb3ZlbWVudFgsXG4gICAgICAgIGxvY2tNb3ZlbWVudFk6IHRoaXMubG9ja01vdmVtZW50WSxcbiAgICAgICAgaG92ZXJDdXJzb3I6IHRoaXMuaG92ZXJDdXJzb3IsXG4gICAgICAgIGRlZmF1bHRDdXJzb3I6IHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmRlZmF1bHRDdXJzb3IsXG4gICAgICAgIG1vdmVDdXJzb3I6IHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLm1vdmVDdXJzb3JcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc3RvcmVFZGl0aW5nUHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9zYXZlZFByb3BzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ob3ZlckN1cnNvciA9IHRoaXMuX3NhdmVkUHJvcHMub3ZlckN1cnNvcjtcbiAgICAgIHRoaXMuaGFzQ29udHJvbHMgPSB0aGlzLl9zYXZlZFByb3BzLmhhc0NvbnRyb2xzO1xuICAgICAgdGhpcy5ib3JkZXJDb2xvciA9IHRoaXMuX3NhdmVkUHJvcHMuYm9yZGVyQ29sb3I7XG4gICAgICB0aGlzLmxvY2tNb3ZlbWVudFggPSB0aGlzLl9zYXZlZFByb3BzLmxvY2tNb3ZlbWVudFg7XG4gICAgICB0aGlzLmxvY2tNb3ZlbWVudFkgPSB0aGlzLl9zYXZlZFByb3BzLmxvY2tNb3ZlbWVudFk7XG5cbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcy5kZWZhdWx0Q3Vyc29yID0gdGhpcy5fc2F2ZWRQcm9wcy5kZWZhdWx0Q3Vyc29yO1xuICAgICAgICB0aGlzLmNhbnZhcy5tb3ZlQ3Vyc29yID0gdGhpcy5fc2F2ZWRQcm9wcy5tb3ZlQ3Vyc29yO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGl0cyBmcm9tIGVkaXRpbmcgc3RhdGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZXhpdEVkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlzVGV4dENoYW5nZWQgPSAodGhpcy5fdGV4dEJlZm9yZUVkaXQgIT09IHRoaXMudGV4dCk7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5zZWxlY3RhYmxlID0gdHJ1ZTtcblxuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYSAmJiB0aGlzLmNhbnZhcyAmJiB0aGlzLmhpZGRlblRleHRhcmVhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5oaWRkZW5UZXh0YXJlYSk7XG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhID0gbnVsbDtcblxuICAgICAgdGhpcy5hYm9ydEN1cnNvckFuaW1hdGlvbigpO1xuICAgICAgdGhpcy5fcmVzdG9yZUVkaXRpbmdQcm9wcygpO1xuICAgICAgdGhpcy5fY3VycmVudEN1cnNvck9wYWNpdHkgPSAwO1xuXG4gICAgICB0aGlzLmZpcmUoJ2VkaXRpbmc6ZXhpdGVkJyk7XG4gICAgICBpc1RleHRDaGFuZ2VkICYmIHRoaXMuZmlyZSgnbW9kaWZpZWQnKTtcbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcy5vZmYoJ21vdXNlOm1vdmUnLCB0aGlzLm1vdXNlTW92ZUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmNhbnZhcy5maXJlKCd0ZXh0OmVkaXRpbmc6ZXhpdGVkJywgeyB0YXJnZXQ6IHRoaXMgfSk7XG4gICAgICAgIGlzVGV4dENoYW5nZWQgJiYgdGhpcy5jYW52YXMuZmlyZSgnb2JqZWN0Om1vZGlmaWVkJywgeyB0YXJnZXQ6IHRoaXMgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmVFeHRyYW5lb3VzU3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90ZXh0TGluZXNbcHJvcF0pIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVtb3ZlQ2hhcnNGcm9tVG86IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHdoaWxlIChlbmQgIT09IHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVNpbmdsZUNoYXJBbmRTdHlsZShzdGFydCArIDEpO1xuICAgICAgICBlbmQtLTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gc3RhcnQ7XG4gICAgfSxcblxuICAgIF9yZW1vdmVTaW5nbGVDaGFyQW5kU3R5bGU6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICB2YXIgaXNCZWdpbm5pbmdPZkxpbmUgPSB0aGlzLnRleHRbaW5kZXggLSAxXSA9PT0gJ1xcbicsXG4gICAgICAgICAgaW5kZXhTdHlsZSAgICAgICAgPSBpc0JlZ2lubmluZ09mTGluZSA/IGluZGV4IDogaW5kZXggLSAxO1xuICAgICAgdGhpcy5yZW1vdmVTdHlsZU9iamVjdChpc0JlZ2lubmluZ09mTGluZSwgaW5kZXhTdHlsZSk7XG4gICAgICB0aGlzLnRleHQgPSB0aGlzLnRleHQuc2xpY2UoMCwgaW5kZXggLSAxKSArXG4gICAgICAgIHRoaXMudGV4dC5zbGljZShpbmRleCk7XG5cbiAgICAgIHRoaXMuX3RleHRMaW5lcyA9IHRoaXMuX3NwbGl0VGV4dEludG9MaW5lcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGNoYXJhY3RlcnMgd2hlcmUgY3Vyc29yIGlzIChyZXBsYWNpbmcgc2VsZWN0aW9uIGlmIG9uZSBleGlzdHMpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IF9jaGFycyBDaGFyYWN0ZXJzIHRvIGluc2VydFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlQ29waWVkU3R5bGUgdXNlIGZhYnJpYy5jb3BpZWRUZXh0U3R5bGVcbiAgICAgKi9cbiAgICBpbnNlcnRDaGFyczogZnVuY3Rpb24oX2NoYXJzLCB1c2VDb3BpZWRTdHlsZSkge1xuICAgICAgdmFyIHN0eWxlO1xuXG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25FbmQgLSB0aGlzLnNlbGVjdGlvblN0YXJ0ID4gMSkge1xuICAgICAgICB0aGlzLl9yZW1vdmVDaGFyc0Zyb21Ubyh0aGlzLnNlbGVjdGlvblN0YXJ0LCB0aGlzLnNlbGVjdGlvbkVuZCk7XG4gICAgICB9XG4gICAgICAvL3Nob3J0IGNpcmN1aXQgZm9yIGJsb2NrIHBhc3RlXG4gICAgICBpZiAoIXVzZUNvcGllZFN0eWxlICYmIHRoaXMuaXNFbXB0eVN0eWxlcygpKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0Q2hhcihfY2hhcnMsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IF9jaGFycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAodXNlQ29waWVkU3R5bGUpIHtcbiAgICAgICAgICBzdHlsZSA9IGZhYnJpYy5jb3BpZWRUZXh0U3R5bGVbaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnNlcnRDaGFyKF9jaGFyc1tpXSwgaSA8IGxlbiAtIDEsIHN0eWxlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhIGNoYXJhY3RlciB3aGVyZSBjdXJzb3IgaXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gX2NoYXIgQ2hhcmFjdGVycyB0byBpbnNlcnRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNraXBVcGRhdGUgdHJpZ2dlciByZW5kZXJpbmcgYW5kIHVwZGF0ZXMgYXQgdGhlIGVuZCBvZiB0ZXh0IGluc2VydFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZU9iamVjdCBTdHlsZSB0byBiZSBpbnNlcnRlZCBmb3IgdGhlIG5ldyBjaGFyXG4gICAgICovXG4gICAgaW5zZXJ0Q2hhcjogZnVuY3Rpb24oX2NoYXIsIHNraXBVcGRhdGUsIHN0eWxlT2JqZWN0KSB7XG4gICAgICB2YXIgaXNFbmRPZkxpbmUgPSB0aGlzLnRleHRbdGhpcy5zZWxlY3Rpb25TdGFydF0gPT09ICdcXG4nO1xuICAgICAgdGhpcy50ZXh0ID0gdGhpcy50ZXh0LnNsaWNlKDAsIHRoaXMuc2VsZWN0aW9uU3RhcnQpICtcbiAgICAgICAgX2NoYXIgKyB0aGlzLnRleHQuc2xpY2UodGhpcy5zZWxlY3Rpb25FbmQpO1xuICAgICAgdGhpcy5fdGV4dExpbmVzID0gdGhpcy5fc3BsaXRUZXh0SW50b0xpbmVzKCk7XG4gICAgICB0aGlzLmluc2VydFN0eWxlT2JqZWN0cyhfY2hhciwgaXNFbmRPZkxpbmUsIHN0eWxlT2JqZWN0KTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgKz0gX2NoYXIubGVuZ3RoO1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgaWYgKHNraXBVcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5maXJlKCdjaGFuZ2VkJyk7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5maXJlKCd0ZXh0OmNoYW5nZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnJlbmRlckFsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIG5ldyBzdHlsZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IEluZGV4IG9mIGEgbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXggSW5kZXggb2YgYSBjaGFyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc0VuZE9mTGluZSBUcnVlIGlmIGl0J3MgZW5kIG9mIGxpbmVcbiAgICAgKi9cbiAgICBpbnNlcnROZXdsaW5lU3R5bGVPYmplY3Q6IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4LCBpc0VuZE9mTGluZSkge1xuXG4gICAgICB0aGlzLnNoaWZ0TGluZVN0eWxlcyhsaW5lSW5kZXgsICsxKTtcblxuICAgICAgaWYgKCF0aGlzLnN0eWxlc1tsaW5lSW5kZXggKyAxXSkge1xuICAgICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXggKyAxXSA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VycmVudENoYXJTdHlsZSA9IHt9LFxuICAgICAgICAgIG5ld0xpbmVTdHlsZXMgICAgPSB7fTtcblxuICAgICAgaWYgKHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gJiYgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXggLSAxXSkge1xuICAgICAgICBjdXJyZW50Q2hhclN0eWxlID0gdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXggLSAxXTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGFmdGVyIGN1cnNvcixcbiAgICAgIC8vIHdlIGNsb25lIGN1cnJlbnQgY2hhciBzdHlsZSBvbnRvIHRoZSBuZXh0IChvdGhlcndpc2UgZW1wdHkpIGxpbmVcbiAgICAgIGlmIChpc0VuZE9mTGluZSkge1xuICAgICAgICBuZXdMaW5lU3R5bGVzWzBdID0gY2xvbmUoY3VycmVudENoYXJTdHlsZSk7XG4gICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleCArIDFdID0gbmV3TGluZVN0eWxlcztcbiAgICAgIH1cbiAgICAgIC8vIG90aGVyd2lzZSB3ZSBjbG9uZSBzdHlsZXMgb2YgYWxsIGNoYXJzXG4gICAgICAvLyBhZnRlciBjdXJzb3Igb250byB0aGUgbmV4dCBsaW5lLCBmcm9tIHRoZSBiZWdpbm5pbmdcbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpbmRleCBpbiB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdKSB7XG4gICAgICAgICAgaWYgKHBhcnNlSW50KGluZGV4LCAxMCkgPj0gY2hhckluZGV4KSB7XG4gICAgICAgICAgICBuZXdMaW5lU3R5bGVzW3BhcnNlSW50KGluZGV4LCAxMCkgLSBjaGFySW5kZXhdID0gdGhpcy5zdHlsZXNbbGluZUluZGV4XVtpbmRleF07XG4gICAgICAgICAgICAvLyByZW1vdmUgbGluZXMgZnJvbSB0aGUgcHJldmlvdXMgbGluZSBzaW5jZSB0aGV5J3JlIG9uIGEgbmV3IGxpbmUgbm93XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleCArIDFdID0gbmV3TGluZVN0eWxlcztcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZvcmNlQ2xlYXJDYWNoZSA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgc3R5bGUgb2JqZWN0IGZvciBhIGdpdmVuIGxpbmUvY2hhciBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggSW5kZXggb2YgYSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleCBJbmRleCBvZiBhIGNoYXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0eWxlXSBTdHlsZSBvYmplY3QgdG8gaW5zZXJ0LCBpZiBnaXZlblxuICAgICAqL1xuICAgIGluc2VydENoYXJTdHlsZU9iamVjdDogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgsIHN0eWxlKSB7XG5cbiAgICAgIHZhciBjdXJyZW50TGluZVN0eWxlcyAgICAgICA9IHRoaXMuc3R5bGVzW2xpbmVJbmRleF0sXG4gICAgICAgICAgY3VycmVudExpbmVTdHlsZXNDbG9uZWQgPSBjbG9uZShjdXJyZW50TGluZVN0eWxlcyk7XG5cbiAgICAgIGlmIChjaGFySW5kZXggPT09IDAgJiYgIXN0eWxlKSB7XG4gICAgICAgIGNoYXJJbmRleCA9IDE7XG4gICAgICB9XG5cbiAgICAgIC8vIHNoaWZ0IGFsbCBjaGFyIHN0eWxlcyBieSAxIGZvcndhcmRcbiAgICAgIC8vIDAsMSwyLDMgLT4gKGNoYXJJbmRleD0yKSAtPiAwLDEsMyw0IC0+IChpbnNlcnQgMikgLT4gMCwxLDIsMyw0XG4gICAgICBmb3IgKHZhciBpbmRleCBpbiBjdXJyZW50TGluZVN0eWxlc0Nsb25lZCkge1xuICAgICAgICB2YXIgbnVtZXJpY0luZGV4ID0gcGFyc2VJbnQoaW5kZXgsIDEwKTtcblxuICAgICAgICBpZiAobnVtZXJpY0luZGV4ID49IGNoYXJJbmRleCkge1xuICAgICAgICAgIGN1cnJlbnRMaW5lU3R5bGVzW251bWVyaWNJbmRleCArIDFdID0gY3VycmVudExpbmVTdHlsZXNDbG9uZWRbbnVtZXJpY0luZGV4XTtcblxuICAgICAgICAgIC8vIG9ubHkgZGVsZXRlIHRoZSBzdHlsZSBpZiB0aGVyZSB3YXMgbm90aGluZyBtb3ZlZCB0aGVyZVxuICAgICAgICAgIGlmICghY3VycmVudExpbmVTdHlsZXNDbG9uZWRbbnVtZXJpY0luZGV4IC0gMV0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjdXJyZW50TGluZVN0eWxlc1tudW1lcmljSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleF0gPVxuICAgICAgICBzdHlsZSB8fCBjbG9uZShjdXJyZW50TGluZVN0eWxlc1tjaGFySW5kZXggLSAxXSk7XG4gICAgICB0aGlzLl9mb3JjZUNsZWFyQ2FjaGUgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIHN0eWxlIG9iamVjdChzKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBfY2hhcnMgQ2hhcmFjdGVycyBhdCB0aGUgbG9jYXRpb24gd2hlcmUgc3R5bGUgaXMgaW5zZXJ0ZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzRW5kT2ZMaW5lIFRydWUgaWYgaXQncyBlbmQgb2YgbGluZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVPYmplY3RdIFN0eWxlIHRvIGluc2VydFxuICAgICAqL1xuICAgIGluc2VydFN0eWxlT2JqZWN0czogZnVuY3Rpb24oX2NoYXJzLCBpc0VuZE9mTGluZSwgc3R5bGVPYmplY3QpIHtcbiAgICAgIC8vIHJlbW92ZWQgc2hvcnRjaXJjdWl0IG92ZXIgaXNFbXB0eVN0eWxlc1xuXG4gICAgICB2YXIgY3Vyc29yTG9jYXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oKSxcbiAgICAgICAgICBsaW5lSW5kZXggICAgICA9IGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleCxcbiAgICAgICAgICBjaGFySW5kZXggICAgICA9IGN1cnNvckxvY2F0aW9uLmNoYXJJbmRleDtcblxuICAgICAgaWYgKCF0aGlzLl9nZXRMaW5lU3R5bGUobGluZUluZGV4KSkge1xuICAgICAgICB0aGlzLl9zZXRMaW5lU3R5bGUobGluZUluZGV4LCB7fSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfY2hhcnMgPT09ICdcXG4nKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0TmV3bGluZVN0eWxlT2JqZWN0KGxpbmVJbmRleCwgY2hhckluZGV4LCBpc0VuZE9mTGluZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5pbnNlcnRDaGFyU3R5bGVPYmplY3QobGluZUluZGV4LCBjaGFySW5kZXgsIHN0eWxlT2JqZWN0KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hpZnRzIGxpbmUgc3R5bGVzIHVwIG9yIGRvd25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IEluZGV4IG9mIGEgbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgQ2FuIGJlIC0xIG9yICsxXG4gICAgICovXG4gICAgc2hpZnRMaW5lU3R5bGVzOiBmdW5jdGlvbihsaW5lSW5kZXgsIG9mZnNldCkge1xuICAgICAgLy8gc2hpZnQgYWxsIGxpbmUgc3R5bGVzIGJ5IDEgdXB3YXJkXG4gICAgICB2YXIgY2xvbmVkU3R5bGVzID0gY2xvbmUodGhpcy5zdHlsZXMpO1xuICAgICAgZm9yICh2YXIgbGluZSBpbiB0aGlzLnN0eWxlcykge1xuICAgICAgICB2YXIgbnVtZXJpY0xpbmUgPSBwYXJzZUludChsaW5lLCAxMCk7XG4gICAgICAgIGlmIChudW1lcmljTGluZSA+IGxpbmVJbmRleCkge1xuICAgICAgICAgIHRoaXMuc3R5bGVzW251bWVyaWNMaW5lICsgb2Zmc2V0XSA9IGNsb25lZFN0eWxlc1tudW1lcmljTGluZV07XG4gICAgICAgICAgaWYgKCFjbG9uZWRTdHlsZXNbbnVtZXJpY0xpbmUgLSBvZmZzZXRdKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbnVtZXJpY0xpbmVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9UT0RPOiBldmFsdWF0ZSBpZiBkZWxldGUgb2xkIHN0eWxlIGxpbmVzIHdpdGggb2Zmc2V0IC0xXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgc3R5bGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc0JlZ2lubmluZ09mTGluZSBUcnVlIGlmIGN1cnNvciBpcyBhdCB0aGUgYmVnaW5uaW5nIG9mIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4XSBPcHRpb25hbCBpbmRleC4gV2hlbiBub3QgZ2l2ZW4sIGN1cnJlbnQgc2VsZWN0aW9uU3RhcnQgaXMgdXNlZC5cbiAgICAgKi9cbiAgICByZW1vdmVTdHlsZU9iamVjdDogZnVuY3Rpb24oaXNCZWdpbm5pbmdPZkxpbmUsIGluZGV4KSB7XG5cbiAgICAgIHZhciBjdXJzb3JMb2NhdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihpbmRleCksXG4gICAgICAgICAgbGluZUluZGV4ICAgICAgPSBjdXJzb3JMb2NhdGlvbi5saW5lSW5kZXgsXG4gICAgICAgICAgY2hhckluZGV4ICAgICAgPSBjdXJzb3JMb2NhdGlvbi5jaGFySW5kZXg7XG5cbiAgICAgIHRoaXMuX3JlbW92ZVN0eWxlT2JqZWN0KGlzQmVnaW5uaW5nT2ZMaW5lLCBjdXJzb3JMb2NhdGlvbiwgbGluZUluZGV4LCBjaGFySW5kZXgpO1xuICAgIH0sXG5cbiAgICBfZ2V0VGV4dE9uUHJldmlvdXNMaW5lOiBmdW5jdGlvbihsSW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90ZXh0TGluZXNbbEluZGV4IC0gMV07XG4gICAgfSxcblxuICAgIF9yZW1vdmVTdHlsZU9iamVjdDogZnVuY3Rpb24oaXNCZWdpbm5pbmdPZkxpbmUsIGN1cnNvckxvY2F0aW9uLCBsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuXG4gICAgICBpZiAoaXNCZWdpbm5pbmdPZkxpbmUpIHtcbiAgICAgICAgdmFyIHRleHRPblByZXZpb3VzTGluZSAgICAgPSB0aGlzLl9nZXRUZXh0T25QcmV2aW91c0xpbmUoY3Vyc29yTG9jYXRpb24ubGluZUluZGV4KSxcbiAgICAgICAgICAgIG5ld0NoYXJJbmRleE9uUHJldkxpbmUgPSB0ZXh0T25QcmV2aW91c0xpbmUgPyB0ZXh0T25QcmV2aW91c0xpbmUubGVuZ3RoIDogMDtcblxuICAgICAgICBpZiAoIXRoaXMuc3R5bGVzW2xpbmVJbmRleCAtIDFdKSB7XG4gICAgICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4IC0gMV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNoYXJJbmRleCBpbiB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdKSB7XG4gICAgICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4IC0gMV1bcGFyc2VJbnQoY2hhckluZGV4LCAxMCkgKyBuZXdDaGFySW5kZXhPblByZXZMaW5lXVxuICAgICAgICAgICAgPSB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaGlmdExpbmVTdHlsZXMoY3Vyc29yTG9jYXRpb24ubGluZUluZGV4LCAtMSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGN1cnJlbnRMaW5lU3R5bGVzID0gdGhpcy5zdHlsZXNbbGluZUluZGV4XTtcblxuICAgICAgICBpZiAoY3VycmVudExpbmVTdHlsZXMpIHtcbiAgICAgICAgICBkZWxldGUgY3VycmVudExpbmVTdHlsZXNbY2hhckluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudExpbmVTdHlsZXNDbG9uZWQgPSBjbG9uZShjdXJyZW50TGluZVN0eWxlcyk7XG4gICAgICAgIC8vIHNoaWZ0IGFsbCBzdHlsZXMgYnkgMSBiYWNrd2FyZHNcbiAgICAgICAgZm9yICh2YXIgaSBpbiBjdXJyZW50TGluZVN0eWxlc0Nsb25lZCkge1xuICAgICAgICAgIHZhciBudW1lcmljSW5kZXggPSBwYXJzZUludChpLCAxMCk7XG4gICAgICAgICAgaWYgKG51bWVyaWNJbmRleCA+PSBjaGFySW5kZXggJiYgbnVtZXJpY0luZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICBjdXJyZW50TGluZVN0eWxlc1tudW1lcmljSW5kZXggLSAxXSA9IGN1cnJlbnRMaW5lU3R5bGVzQ2xvbmVkW251bWVyaWNJbmRleF07XG4gICAgICAgICAgICBkZWxldGUgY3VycmVudExpbmVTdHlsZXNbbnVtZXJpY0luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBuZXcgbGluZVxuICAgICAqL1xuICAgIGluc2VydE5ld2xpbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pbnNlcnRDaGFycygnXFxuJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc2VsZWN0aW9uU3RhcnQgYW5kIHNlbGVjdGlvbkVuZCBhY2NvcmRpbmcgdG8gdGhlIG5lIHBvc3Rpb24gb2YgY3Vyc29yXG4gICAgICogbWltaWMgdGhlIGtleSAtIG1vdXNlIG5hdmlnYXRpb24gd2hlbiBzaGlmdCBpcyBwcmVzc2VkLlxuICAgICAqL1xuICAgIHNldFNlbGVjdGlvblN0YXJ0RW5kV2l0aFNoaWZ0OiBmdW5jdGlvbihzdGFydCwgZW5kLCBuZXdTZWxlY3Rpb24pIHtcbiAgICAgIGlmIChuZXdTZWxlY3Rpb24gPD0gc3RhcnQpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gc3RhcnQpIHtcbiAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG5ld1NlbGVjdGlvbiA+IHN0YXJ0ICYmIG5ld1NlbGVjdGlvbiA8IGVuZCkge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIG5ld1NlbGVjdGlvbiBpcyA+IHNlbGVjdGlvbiBzdGFydCBhbmQgZW5kXG4gICAgICAgIGlmIChlbmQgPT09IHN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvbjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0U2VsZWN0aW9uSW5Cb3VuZGFyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsZW5ndGggPSB0aGlzLnRleHQubGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPiBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPCAwKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uRW5kID4gbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5zZWxlY3Rpb25FbmQgPCAwKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5JVGV4dC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLklUZXh0LnByb3RvdHlwZSAqLyB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBcImRiY2xpY2tcIiBldmVudCBoYW5kbGVyXG4gICAqL1xuICBpbml0RG91YmxlQ2xpY2tTaW11bGF0aW9uOiBmdW5jdGlvbigpIHtcblxuICAgIC8vIGZvciBkb3VibGUgY2xpY2tcbiAgICB0aGlzLl9fbGFzdENsaWNrVGltZSA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgLy8gZm9yIHRyaXBsZSBjbGlja1xuICAgIHRoaXMuX19sYXN0TGFzdENsaWNrVGltZSA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgdGhpcy5fX2xhc3RQb2ludGVyID0geyB9O1xuXG4gICAgdGhpcy5vbignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpKTtcbiAgfSxcblxuICBvbk1vdXNlRG93bjogZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgdGhpcy5fX25ld0NsaWNrVGltZSA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBuZXdQb2ludGVyID0gdGhpcy5jYW52YXMuZ2V0UG9pbnRlcihvcHRpb25zLmUpO1xuXG4gICAgaWYgKHRoaXMuaXNUcmlwbGVDbGljayhuZXdQb2ludGVyKSkge1xuICAgICAgdGhpcy5maXJlKCd0cmlwbGVjbGljaycsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc3RvcEV2ZW50KG9wdGlvbnMuZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuaXNEb3VibGVDbGljayhuZXdQb2ludGVyKSkge1xuICAgICAgdGhpcy5maXJlKCdkYmxjbGljaycsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc3RvcEV2ZW50KG9wdGlvbnMuZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fX2xhc3RMYXN0Q2xpY2tUaW1lID0gdGhpcy5fX2xhc3RDbGlja1RpbWU7XG4gICAgdGhpcy5fX2xhc3RDbGlja1RpbWUgPSB0aGlzLl9fbmV3Q2xpY2tUaW1lO1xuICAgIHRoaXMuX19sYXN0UG9pbnRlciA9IG5ld1BvaW50ZXI7XG4gICAgdGhpcy5fX2xhc3RJc0VkaXRpbmcgPSB0aGlzLmlzRWRpdGluZztcbiAgICB0aGlzLl9fbGFzdFNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZDtcbiAgfSxcblxuICBpc0RvdWJsZUNsaWNrOiBmdW5jdGlvbihuZXdQb2ludGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX19uZXdDbGlja1RpbWUgLSB0aGlzLl9fbGFzdENsaWNrVGltZSA8IDUwMCAmJlxuICAgICAgICB0aGlzLl9fbGFzdFBvaW50ZXIueCA9PT0gbmV3UG9pbnRlci54ICYmXG4gICAgICAgIHRoaXMuX19sYXN0UG9pbnRlci55ID09PSBuZXdQb2ludGVyLnkgJiYgdGhpcy5fX2xhc3RJc0VkaXRpbmc7XG4gIH0sXG5cbiAgaXNUcmlwbGVDbGljazogZnVuY3Rpb24obmV3UG9pbnRlcikge1xuICAgIHJldHVybiB0aGlzLl9fbmV3Q2xpY2tUaW1lIC0gdGhpcy5fX2xhc3RDbGlja1RpbWUgPCA1MDAgJiZcbiAgICAgICAgdGhpcy5fX2xhc3RDbGlja1RpbWUgLSB0aGlzLl9fbGFzdExhc3RDbGlja1RpbWUgPCA1MDAgJiZcbiAgICAgICAgdGhpcy5fX2xhc3RQb2ludGVyLnggPT09IG5ld1BvaW50ZXIueCAmJlxuICAgICAgICB0aGlzLl9fbGFzdFBvaW50ZXIueSA9PT0gbmV3UG9pbnRlci55O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3N0b3BFdmVudDogZnVuY3Rpb24oZSkge1xuICAgIGUucHJldmVudERlZmF1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uICYmIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGV2ZW50IGhhbmRsZXJzIHJlbGF0ZWQgdG8gY3Vyc29yIG9yIHNlbGVjdGlvblxuICAgKi9cbiAgaW5pdEN1cnNvclNlbGVjdGlvbkhhbmRsZXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluaXRTZWxlY3RlZEhhbmRsZXIoKTtcbiAgICB0aGlzLmluaXRNb3VzZWRvd25IYW5kbGVyKCk7XG4gICAgdGhpcy5pbml0TW91c2V1cEhhbmRsZXIoKTtcbiAgICB0aGlzLmluaXRDbGlja3MoKTtcbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgZG91YmxlIGFuZCB0cmlwbGUgY2xpY2sgZXZlbnQgaGFuZGxlcnNcbiAgICovXG4gIGluaXRDbGlja3M6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub24oJ2RibGNsaWNrJywgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5zZWxlY3RXb3JkKHRoaXMuZ2V0U2VsZWN0aW9uU3RhcnRGcm9tUG9pbnRlcihvcHRpb25zLmUpKTtcbiAgICB9KTtcbiAgICB0aGlzLm9uKCd0cmlwbGVjbGljaycsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc2VsZWN0TGluZSh0aGlzLmdldFNlbGVjdGlvblN0YXJ0RnJvbVBvaW50ZXIob3B0aW9ucy5lKSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIFwibW91c2Vkb3duXCIgZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgaW5pdE1vdXNlZG93bkhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5lZGl0YWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuY2FudmFzLmdldFBvaW50ZXIob3B0aW9ucy5lKTtcblxuICAgICAgdGhpcy5fX21vdXNlZG93blggPSBwb2ludGVyLng7XG4gICAgICB0aGlzLl9fbW91c2Vkb3duWSA9IHBvaW50ZXIueTtcbiAgICAgIHRoaXMuX19pc01vdXNlZG93biA9IHRydWU7XG5cbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgIHRoaXMuc2V0Q3Vyc29yQnlDbGljayhvcHRpb25zLmUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgICAgdGhpcy5fX3NlbGVjdGlvblN0YXJ0T25Nb3VzZURvd24gPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICB0aGlzLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2lzT2JqZWN0TW92ZWQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgcG9pbnRlciA9IHRoaXMuY2FudmFzLmdldFBvaW50ZXIoZSk7XG5cbiAgICByZXR1cm4gdGhpcy5fX21vdXNlZG93blggIT09IHBvaW50ZXIueCB8fFxuICAgICAgICAgICB0aGlzLl9fbW91c2Vkb3duWSAhPT0gcG9pbnRlci55O1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBcIm1vdXNldXBcIiBldmVudCBoYW5kbGVyXG4gICAqL1xuICBpbml0TW91c2V1cEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub24oJ21vdXNldXAnLCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLl9faXNNb3VzZWRvd24gPSBmYWxzZTtcbiAgICAgIGlmICghdGhpcy5lZGl0YWJsZSB8fCB0aGlzLl9pc09iamVjdE1vdmVkKG9wdGlvbnMuZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fX2xhc3RTZWxlY3RlZCAmJiAhdGhpcy5fX2Nvcm5lcikge1xuICAgICAgICB0aGlzLmVudGVyRWRpdGluZyhvcHRpb25zLmUpO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICB0aGlzLmluaXREZWxheWVkQ3Vyc29yKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoYW5nZXMgY3Vyc29yIGxvY2F0aW9uIGluIGEgdGV4dCBkZXBlbmRpbmcgb24gcGFzc2VkIHBvaW50ZXIgKHgveSkgb2JqZWN0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBzZXRDdXJzb3JCeUNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIG5ld1NlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uU3RhcnRGcm9tUG9pbnRlcihlKSxcbiAgICAgICAgc3RhcnQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0LCBlbmQgPSB0aGlzLnNlbGVjdGlvbkVuZDtcbiAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgdGhpcy5zZXRTZWxlY3Rpb25TdGFydEVuZFdpdGhTaGlmdChzdGFydCwgZW5kLCBuZXdTZWxlY3Rpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb247XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvbjtcbiAgICB9XG4gICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGluZGV4IG9mIGEgY2hhcmFjdGVyIGNvcnJlc3BvbmRpbmcgdG8gd2hlcmUgYW4gb2JqZWN0IHdhcyBjbGlja2VkXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqIEByZXR1cm4ge051bWJlcn0gSW5kZXggb2YgYSBjaGFyYWN0ZXJcbiAgICovXG4gIGdldFNlbGVjdGlvblN0YXJ0RnJvbVBvaW50ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgbW91c2VPZmZzZXQgPSB0aGlzLmdldExvY2FsUG9pbnRlcihlKSxcbiAgICAgICAgcHJldldpZHRoID0gMCxcbiAgICAgICAgd2lkdGggPSAwLFxuICAgICAgICBoZWlnaHQgPSAwLFxuICAgICAgICBjaGFySW5kZXggPSAwLFxuICAgICAgICBuZXdTZWxlY3Rpb25TdGFydCxcbiAgICAgICAgbGluZTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbaV07XG4gICAgICBoZWlnaHQgKz0gdGhpcy5fZ2V0SGVpZ2h0T2ZMaW5lKHRoaXMuY3R4LCBpKSAqIHRoaXMuc2NhbGVZO1xuXG4gICAgICB2YXIgd2lkdGhPZkxpbmUgPSB0aGlzLl9nZXRMaW5lV2lkdGgodGhpcy5jdHgsIGkpLFxuICAgICAgICAgIGxpbmVMZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQod2lkdGhPZkxpbmUpO1xuXG4gICAgICB3aWR0aCA9IGxpbmVMZWZ0T2Zmc2V0ICogdGhpcy5zY2FsZVg7XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcblxuICAgICAgICBwcmV2V2lkdGggPSB3aWR0aDtcblxuICAgICAgICB3aWR0aCArPSB0aGlzLl9nZXRXaWR0aE9mQ2hhcih0aGlzLmN0eCwgbGluZVtqXSwgaSwgdGhpcy5mbGlwWCA/IGpsZW4gLSBqIDogaikgKlxuICAgICAgICAgICAgICAgICB0aGlzLnNjYWxlWDtcblxuICAgICAgICBpZiAoaGVpZ2h0IDw9IG1vdXNlT2Zmc2V0LnkgfHwgd2lkdGggPD0gbW91c2VPZmZzZXQueCkge1xuICAgICAgICAgIGNoYXJJbmRleCsrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE5ld1NlbGVjdGlvblN0YXJ0RnJvbU9mZnNldChcbiAgICAgICAgICBtb3VzZU9mZnNldCwgcHJldldpZHRoLCB3aWR0aCwgY2hhckluZGV4ICsgaSwgamxlbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb3VzZU9mZnNldC55IDwgaGVpZ2h0KSB7XG4gICAgICAgIC8vdGhpcyBoYXBwZW5zIGp1c3Qgb24gZW5kIG9mIGxpbmVzLlxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TmV3U2VsZWN0aW9uU3RhcnRGcm9tT2Zmc2V0KFxuICAgICAgICAgIG1vdXNlT2Zmc2V0LCBwcmV2V2lkdGgsIHdpZHRoLCBjaGFySW5kZXggKyBpIC0gMSwgamxlbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2xpY2tlZCBzb21ld2hlcmUgYWZ0ZXIgYWxsIGNoYXJzLCBzbyBzZXQgYXQgdGhlIGVuZFxuICAgIGlmICh0eXBlb2YgbmV3U2VsZWN0aW9uU3RhcnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0TmV3U2VsZWN0aW9uU3RhcnRGcm9tT2Zmc2V0OiBmdW5jdGlvbihtb3VzZU9mZnNldCwgcHJldldpZHRoLCB3aWR0aCwgaW5kZXgsIGpsZW4pIHtcblxuICAgIHZhciBkaXN0YW5jZUJ0d0xhc3RDaGFyQW5kQ3Vyc29yID0gbW91c2VPZmZzZXQueCAtIHByZXZXaWR0aCxcbiAgICAgICAgZGlzdGFuY2VCdHdOZXh0Q2hhckFuZEN1cnNvciA9IHdpZHRoIC0gbW91c2VPZmZzZXQueCxcbiAgICAgICAgb2Zmc2V0ID0gZGlzdGFuY2VCdHdOZXh0Q2hhckFuZEN1cnNvciA+IGRpc3RhbmNlQnR3TGFzdENoYXJBbmRDdXJzb3IgPyAwIDogMSxcbiAgICAgICAgbmV3U2VsZWN0aW9uU3RhcnQgPSBpbmRleCArIG9mZnNldDtcblxuICAgIC8vIGlmIG9iamVjdCBpcyBob3Jpem9udGFsbHkgZmxpcHBlZCwgbWlycm9yIGN1cnNvciBsb2NhdGlvbiBmcm9tIHRoZSBlbmRcbiAgICBpZiAodGhpcy5mbGlwWCkge1xuICAgICAgbmV3U2VsZWN0aW9uU3RhcnQgPSBqbGVuIC0gbmV3U2VsZWN0aW9uU3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKG5ld1NlbGVjdGlvblN0YXJ0ID4gdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgbmV3U2VsZWN0aW9uU3RhcnQgPSB0aGlzLnRleHQubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdTZWxlY3Rpb25TdGFydDtcbiAgfVxufSk7XG5cblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuSVRleHQucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5JVGV4dC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBoaWRkZW4gdGV4dGFyZWEgKG5lZWRlZCB0byBicmluZyB1cCBrZXlib2FyZCBpbiBpT1MpXG4gICAqL1xuICBpbml0SGlkZGVuVGV4dGFyZWE6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNldEF0dHJpYnV0ZSgnYXV0b2NhcGl0YWxpemUnLCAnb2ZmJyk7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5fY2FsY1RleHRhcmVhUG9zaXRpb24oKTtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246IGFic29sdXRlOyB0b3A6ICcgKyBzdHlsZS50b3AgKyAnOyBsZWZ0OiAnICsgc3R5bGUubGVmdCArICc7J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgJyBvcGFjaXR5OiAwOyB3aWR0aDogMHB4OyBoZWlnaHQ6IDBweDsgei1pbmRleDogLTk5OTsnO1xuICAgIGZhYnJpYy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuaGlkZGVuVGV4dGFyZWEpO1xuXG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2tleWRvd24nLCB0aGlzLm9uS2V5RG93bi5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAna2V5dXAnLCB0aGlzLm9uS2V5VXAuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2lucHV0JywgdGhpcy5vbklucHV0LmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdjb3B5JywgdGhpcy5jb3B5LmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdjdXQnLCB0aGlzLmN1dC5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAncGFzdGUnLCB0aGlzLnBhc3RlLmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdjb21wb3NpdGlvbnN0YXJ0JywgdGhpcy5vbkNvbXBvc2l0aW9uU3RhcnQuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2NvbXBvc2l0aW9udXBkYXRlJywgdGhpcy5vbkNvbXBvc2l0aW9uVXBkYXRlLmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdjb21wb3NpdGlvbmVuZCcsIHRoaXMub25Db21wb3NpdGlvbkVuZC5iaW5kKHRoaXMpKTtcblxuICAgIGlmICghdGhpcy5fY2xpY2tIYW5kbGVySW5pdGlhbGl6ZWQgJiYgdGhpcy5jYW52YXMpIHtcbiAgICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuY2FudmFzLnVwcGVyQ2FudmFzRWwsICdjbGljaycsIHRoaXMub25DbGljay5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuX2NsaWNrSGFuZGxlckluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfa2V5c01hcDoge1xuICAgIDg6ICAncmVtb3ZlQ2hhcnMnLFxuICAgIDk6ICAnZXhpdEVkaXRpbmcnLFxuICAgIDI3OiAnZXhpdEVkaXRpbmcnLFxuICAgIDEzOiAnaW5zZXJ0TmV3bGluZScsXG4gICAgMzM6ICdtb3ZlQ3Vyc29yVXAnLFxuICAgIDM0OiAnbW92ZUN1cnNvckRvd24nLFxuICAgIDM1OiAnbW92ZUN1cnNvclJpZ2h0JyxcbiAgICAzNjogJ21vdmVDdXJzb3JMZWZ0JyxcbiAgICAzNzogJ21vdmVDdXJzb3JMZWZ0JyxcbiAgICAzODogJ21vdmVDdXJzb3JVcCcsXG4gICAgMzk6ICdtb3ZlQ3Vyc29yUmlnaHQnLFxuICAgIDQwOiAnbW92ZUN1cnNvckRvd24nLFxuICAgIDQ2OiAnZm9yd2FyZERlbGV0ZSdcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jdHJsS2V5c01hcFVwOiB7XG4gICAgNjc6ICdjb3B5JyxcbiAgICA4ODogJ2N1dCdcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jdHJsS2V5c01hcERvd246IHtcbiAgICA2NTogJ3NlbGVjdEFsbCdcbiAgfSxcblxuICBvbkNsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAvLyBObyBuZWVkIHRvIHRyaWdnZXIgY2xpY2sgZXZlbnQgaGVyZSwgZm9jdXMgaXMgZW5vdWdoIHRvIGhhdmUgdGhlIGtleWJvYXJkIGFwcGVhciBvbiBBbmRyb2lkXG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYSAmJiB0aGlzLmhpZGRlblRleHRhcmVhLmZvY3VzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhhbmRsZXMga2V5dXAgZXZlbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG9uS2V5RG93bjogZnVuY3Rpb24oZSkge1xuICAgIGlmICghdGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGUua2V5Q29kZSBpbiB0aGlzLl9rZXlzTWFwKSB7XG4gICAgICB0aGlzW3RoaXMuX2tleXNNYXBbZS5rZXlDb2RlXV0oZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChlLmtleUNvZGUgaW4gdGhpcy5fY3RybEtleXNNYXBEb3duKSAmJiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkpIHtcbiAgICAgIHRoaXNbdGhpcy5fY3RybEtleXNNYXBEb3duW2Uua2V5Q29kZV1dKGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMucmVuZGVyQWxsKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhhbmRsZXMga2V5dXAgZXZlbnRcbiAgICogV2UgaGFuZGxlIEtleVVwIGJlY2F1c2UgaWUxMSBhbmQgZWRnZSBoYXZlIGRpZmZpY3VsdGllcyBjb3B5L3Bhc3RpbmdcbiAgICogaWYgYSBjb3B5L2N1dCBldmVudCBmaXJlZCwga2V5dXAgaXMgZGlzbWlzc2VkXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBvbktleVVwOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCF0aGlzLmlzRWRpdGluZyB8fCB0aGlzLl9jb3B5RG9uZSkge1xuICAgICAgdGhpcy5fY29weURvbmUgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKChlLmtleUNvZGUgaW4gdGhpcy5fY3RybEtleXNNYXBVcCkgJiYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpKSB7XG4gICAgICB0aGlzW3RoaXMuX2N0cmxLZXlzTWFwVXBbZS5rZXlDb2RlXV0oZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgfSxcblxuICAvKipcbiAgICogSGFuZGxlcyBvbklucHV0IGV2ZW50XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBvbklucHV0OiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCF0aGlzLmlzRWRpdGluZyB8fCB0aGlzLmluQ29tcG9zaXRpb25Nb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0IHx8IDAsXG4gICAgICAgIG9mZnNldEVuZCA9IHRoaXMuc2VsZWN0aW9uRW5kIHx8IDAsXG4gICAgICAgIHRleHRMZW5ndGggPSB0aGlzLnRleHQubGVuZ3RoLFxuICAgICAgICBuZXdUZXh0TGVuZ3RoID0gdGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZS5sZW5ndGgsXG4gICAgICAgIGRpZmYsIGNoYXJzVG9JbnNlcnQsIHN0YXJ0O1xuICAgIGlmIChuZXdUZXh0TGVuZ3RoID4gdGV4dExlbmd0aCkge1xuICAgICAgLy93ZSBhZGRlZCBzb21lIGNoYXJhY3RlclxuICAgICAgc3RhcnQgPSB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdsZWZ0JyA/IG9mZnNldEVuZCA6IG9mZnNldDtcbiAgICAgIGRpZmYgPSBuZXdUZXh0TGVuZ3RoIC0gdGV4dExlbmd0aDtcbiAgICAgIGNoYXJzVG9JbnNlcnQgPSB0aGlzLmhpZGRlblRleHRhcmVhLnZhbHVlLnNsaWNlKHN0YXJ0LCBzdGFydCArIGRpZmYpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vd2Ugc2VsZWN0ZWQgYSBwb3J0aW9uIG9mIHRleHQgYW5kIHRoZW4gaW5wdXQgc29tZXRoaW5nIGVsc2UuXG4gICAgICAvL0ludGVybmV0IGV4cGxvcmVyIGRvZXMgbm90IHRyaWdnZXIgdGhpcyBlbHNlXG4gICAgICBkaWZmID0gbmV3VGV4dExlbmd0aCAtIHRleHRMZW5ndGggKyBvZmZzZXRFbmQgLSBvZmZzZXQ7XG4gICAgICBjaGFyc1RvSW5zZXJ0ID0gdGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZS5zbGljZShvZmZzZXQsIG9mZnNldCArIGRpZmYpO1xuICAgIH1cbiAgICB0aGlzLmluc2VydENoYXJzKGNoYXJzVG9JbnNlcnQpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXBvc2l0aW9uIHN0YXJ0XG4gICAqL1xuICBvbkNvbXBvc2l0aW9uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5Db21wb3NpdGlvbk1vZGUgPSB0cnVlO1xuICAgIHRoaXMucHJldkNvbXBvc2l0aW9uTGVuZ3RoID0gMDtcbiAgICB0aGlzLmNvbXBvc2l0aW9uU3RhcnQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb21wb3NpdGlvbiBlbmRcbiAgICovXG4gIG9uQ29tcG9zaXRpb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5Db21wb3NpdGlvbk1vZGUgPSBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogQ29tcG9zaXRpb24gdXBkYXRlXG4gICAqL1xuICBvbkNvbXBvc2l0aW9uVXBkYXRlOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGRhdGEgPSBlLmRhdGE7XG4gICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IHRoaXMuY29tcG9zaXRpb25TdGFydDtcbiAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuc2VsZWN0aW9uRW5kID09PSB0aGlzLnNlbGVjdGlvblN0YXJ0ID9cbiAgICAgIHRoaXMuY29tcG9zaXRpb25TdGFydCArIHRoaXMucHJldkNvbXBvc2l0aW9uTGVuZ3RoIDogdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgdGhpcy5pbnNlcnRDaGFycyhkYXRhLCBmYWxzZSk7XG4gICAgdGhpcy5wcmV2Q29tcG9zaXRpb25MZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgfSxcblxuICAvKipcbiAgICogRm9yd2FyZCBkZWxldGVcbiAgICovXG4gIGZvcndhcmREZWxldGU6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubW92ZUN1cnNvclJpZ2h0KGUpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUNoYXJzKGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb3BpZXMgc2VsZWN0ZWQgdGV4dFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgY29weTogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgLy9kbyBub3QgY3V0LWNvcHkgaWYgbm8gc2VsZWN0aW9uXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzZWxlY3RlZFRleHQgPSB0aGlzLmdldFNlbGVjdGVkVGV4dCgpLFxuICAgICAgICBjbGlwYm9hcmREYXRhID0gdGhpcy5fZ2V0Q2xpcGJvYXJkRGF0YShlKTtcblxuICAgIC8vIENoZWNrIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGJyb3dzZXJzXG4gICAgaWYgKGNsaXBib2FyZERhdGEpIHtcbiAgICAgIGNsaXBib2FyZERhdGEuc2V0RGF0YSgndGV4dCcsIHNlbGVjdGVkVGV4dCk7XG4gICAgfVxuXG4gICAgZmFicmljLmNvcGllZFRleHQgPSBzZWxlY3RlZFRleHQ7XG4gICAgZmFicmljLmNvcGllZFRleHRTdHlsZSA9IHRoaXMuZ2V0U2VsZWN0aW9uU3R5bGVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCk7XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5fY29weURvbmUgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQYXN0ZXMgdGV4dFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgcGFzdGU6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgY29waWVkVGV4dCA9IG51bGwsXG4gICAgICAgIGNsaXBib2FyZERhdGEgPSB0aGlzLl9nZXRDbGlwYm9hcmREYXRhKGUpLFxuICAgICAgICB1c2VDb3BpZWRTdHlsZSA9IHRydWU7XG5cbiAgICAvLyBDaGVjayBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBicm93c2Vyc1xuICAgIGlmIChjbGlwYm9hcmREYXRhKSB7XG4gICAgICBjb3BpZWRUZXh0ID0gY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0JykucmVwbGFjZSgvXFxyL2csICcnKTtcbiAgICAgIGlmICghZmFicmljLmNvcGllZFRleHRTdHlsZSB8fCBmYWJyaWMuY29waWVkVGV4dCAhPT0gY29waWVkVGV4dCkge1xuICAgICAgICB1c2VDb3BpZWRTdHlsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvcGllZFRleHQgPSBmYWJyaWMuY29waWVkVGV4dDtcbiAgICB9XG5cbiAgICBpZiAoY29waWVkVGV4dCkge1xuICAgICAgdGhpcy5pbnNlcnRDaGFycyhjb3BpZWRUZXh0LCB1c2VDb3BpZWRTdHlsZSk7XG4gICAgfVxuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDdXRzIHRleHRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIGN1dDogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY29weShlKTtcbiAgICB0aGlzLnJlbW92ZUNoYXJzKGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IENsaXBib2FyZCBkYXRhIG9iamVjdFxuICAgKi9cbiAgX2dldENsaXBib2FyZERhdGE6IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gKGUgJiYgZS5jbGlwYm9hcmREYXRhKSB8fCBmYWJyaWMud2luZG93LmNsaXBib2FyZERhdGE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSB3aWR0aCBpbiBwaXhlbHMgYmVmb3JlIHRoZSBjdXJzb3Igb24gdGhlIHNhbWUgbGluZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICogQHJldHVybiB7TnVtYmVyfSB3aWR0aEJlZm9yZUN1cnNvciB3aWR0aCBiZWZvcmUgY3Vyc29yXG4gICAqL1xuICBfZ2V0V2lkdGhCZWZvcmVDdXJzb3I6IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB7XG4gICAgdmFyIHRleHRCZWZvcmVDdXJzb3IgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XS5zbGljZSgwLCBjaGFySW5kZXgpLFxuICAgICAgICB3aWR0aE9mTGluZSA9IHRoaXMuX2dldExpbmVXaWR0aCh0aGlzLmN0eCwgbGluZUluZGV4KSxcbiAgICAgICAgd2lkdGhCZWZvcmVDdXJzb3IgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldCh3aWR0aE9mTGluZSksIF9jaGFyO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRleHRCZWZvcmVDdXJzb3IubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIF9jaGFyID0gdGV4dEJlZm9yZUN1cnNvcltpXTtcbiAgICAgIHdpZHRoQmVmb3JlQ3Vyc29yICs9IHRoaXMuX2dldFdpZHRoT2ZDaGFyKHRoaXMuY3R4LCBfY2hhciwgbGluZUluZGV4LCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpZHRoQmVmb3JlQ3Vyc29yO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHN0YXJ0IG9mZnNldCBvZiBhIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzUmlnaHRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0RG93bkN1cnNvck9mZnNldDogZnVuY3Rpb24oZSwgaXNSaWdodCkge1xuICAgIHZhciBzZWxlY3Rpb25Qcm9wID0gdGhpcy5fZ2V0U2VsZWN0aW9uRm9yT2Zmc2V0KGUsIGlzUmlnaHQpLFxuICAgICAgICBjdXJzb3JMb2NhdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzZWxlY3Rpb25Qcm9wKSxcbiAgICAgICAgbGluZUluZGV4ID0gY3Vyc29yTG9jYXRpb24ubGluZUluZGV4O1xuICAgIC8vIGlmIG9uIGxhc3QgbGluZSwgZG93biBjdXJzb3IgZ29lcyB0byBlbmQgb2YgbGluZVxuICAgIGlmIChsaW5lSW5kZXggPT09IHRoaXMuX3RleHRMaW5lcy5sZW5ndGggLSAxIHx8IGUubWV0YUtleSB8fCBlLmtleUNvZGUgPT09IDM0KSB7XG4gICAgICAvLyBtb3ZlIHRvIHRoZSBlbmQgb2YgYSB0ZXh0XG4gICAgICByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aCAtIHNlbGVjdGlvblByb3A7XG4gICAgfVxuICAgIHZhciBjaGFySW5kZXggPSBjdXJzb3JMb2NhdGlvbi5jaGFySW5kZXgsXG4gICAgICAgIHdpZHRoQmVmb3JlQ3Vyc29yID0gdGhpcy5fZ2V0V2lkdGhCZWZvcmVDdXJzb3IobGluZUluZGV4LCBjaGFySW5kZXgpLFxuICAgICAgICBpbmRleE9uT3RoZXJMaW5lID0gdGhpcy5fZ2V0SW5kZXhPbkxpbmUobGluZUluZGV4ICsgMSwgd2lkdGhCZWZvcmVDdXJzb3IpLFxuICAgICAgICB0ZXh0QWZ0ZXJDdXJzb3IgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XS5zbGljZShjaGFySW5kZXgpO1xuXG4gICAgcmV0dXJuIHRleHRBZnRlckN1cnNvci5sZW5ndGggKyBpbmRleE9uT3RoZXJMaW5lICsgMjtcbiAgfSxcblxuICAvKipcbiAgICogcHJpdmF0ZVxuICAgKiBIZWxwcyBmaW5kaW5nIGlmIHRoZSBvZmZzZXQgc2hvdWxkIGJlIGNvdW50ZWQgZnJvbSBTdGFydCBvciBFbmRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1JpZ2h0XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIF9nZXRTZWxlY3Rpb25Gb3JPZmZzZXQ6IGZ1bmN0aW9uKGUsIGlzUmlnaHQpIHtcbiAgICBpZiAoZS5zaGlmdEtleSAmJiB0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSB0aGlzLnNlbGVjdGlvbkVuZCAmJiBpc1JpZ2h0KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzUmlnaHRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0VXBDdXJzb3JPZmZzZXQ6IGZ1bmN0aW9uKGUsIGlzUmlnaHQpIHtcbiAgICB2YXIgc2VsZWN0aW9uUHJvcCA9IHRoaXMuX2dldFNlbGVjdGlvbkZvck9mZnNldChlLCBpc1JpZ2h0KSxcbiAgICAgICAgY3Vyc29yTG9jYXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oc2VsZWN0aW9uUHJvcCksXG4gICAgICAgIGxpbmVJbmRleCA9IGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleDtcbiAgICBpZiAobGluZUluZGV4ID09PSAwIHx8IGUubWV0YUtleSB8fCBlLmtleUNvZGUgPT09IDMzKSB7XG4gICAgICAvLyBpZiBvbiBmaXJzdCBsaW5lLCB1cCBjdXJzb3IgZ29lcyB0byBzdGFydCBvZiBsaW5lXG4gICAgICByZXR1cm4gLXNlbGVjdGlvblByb3A7XG4gICAgfVxuICAgIHZhciBjaGFySW5kZXggPSBjdXJzb3JMb2NhdGlvbi5jaGFySW5kZXgsXG4gICAgICAgIHdpZHRoQmVmb3JlQ3Vyc29yID0gdGhpcy5fZ2V0V2lkdGhCZWZvcmVDdXJzb3IobGluZUluZGV4LCBjaGFySW5kZXgpLFxuICAgICAgICBpbmRleE9uT3RoZXJMaW5lID0gdGhpcy5fZ2V0SW5kZXhPbkxpbmUobGluZUluZGV4IC0gMSwgd2lkdGhCZWZvcmVDdXJzb3IpLFxuICAgICAgICB0ZXh0QmVmb3JlQ3Vyc29yID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0uc2xpY2UoMCwgY2hhckluZGV4KTtcbiAgICAvLyByZXR1cm4gYSBuZWdhdGl2ZSBvZmZzZXRcbiAgICByZXR1cm4gLXRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXggLSAxXS5sZW5ndGggKyBpbmRleE9uT3RoZXJMaW5lIC0gdGV4dEJlZm9yZUN1cnNvci5sZW5ndGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZpbmQgZm9yIGEgZ2l2ZW4gd2lkdGggaXQgZm91bmRzIHRoZSBtYXRjaGluZyBjaGFyYWN0ZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0SW5kZXhPbkxpbmU6IGZ1bmN0aW9uKGxpbmVJbmRleCwgd2lkdGgpIHtcblxuICAgIHZhciB3aWR0aE9mTGluZSA9IHRoaXMuX2dldExpbmVXaWR0aCh0aGlzLmN0eCwgbGluZUluZGV4KSxcbiAgICAgICAgdGV4dE9uTGluZSA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLFxuICAgICAgICBsaW5lTGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KHdpZHRoT2ZMaW5lKSxcbiAgICAgICAgd2lkdGhPZkNoYXJzT25MaW5lID0gbGluZUxlZnRPZmZzZXQsXG4gICAgICAgIGluZGV4T25MaW5lID0gMCxcbiAgICAgICAgZm91bmRNYXRjaDtcblxuICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gdGV4dE9uTGluZS5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcblxuICAgICAgdmFyIF9jaGFyID0gdGV4dE9uTGluZVtqXSxcbiAgICAgICAgICB3aWR0aE9mQ2hhciA9IHRoaXMuX2dldFdpZHRoT2ZDaGFyKHRoaXMuY3R4LCBfY2hhciwgbGluZUluZGV4LCBqKTtcblxuICAgICAgd2lkdGhPZkNoYXJzT25MaW5lICs9IHdpZHRoT2ZDaGFyO1xuXG4gICAgICBpZiAod2lkdGhPZkNoYXJzT25MaW5lID4gd2lkdGgpIHtcblxuICAgICAgICBmb3VuZE1hdGNoID0gdHJ1ZTtcblxuICAgICAgICB2YXIgbGVmdEVkZ2UgPSB3aWR0aE9mQ2hhcnNPbkxpbmUgLSB3aWR0aE9mQ2hhcixcbiAgICAgICAgICAgIHJpZ2h0RWRnZSA9IHdpZHRoT2ZDaGFyc09uTGluZSxcbiAgICAgICAgICAgIG9mZnNldEZyb21MZWZ0RWRnZSA9IE1hdGguYWJzKGxlZnRFZGdlIC0gd2lkdGgpLFxuICAgICAgICAgICAgb2Zmc2V0RnJvbVJpZ2h0RWRnZSA9IE1hdGguYWJzKHJpZ2h0RWRnZSAtIHdpZHRoKTtcblxuICAgICAgICBpbmRleE9uTGluZSA9IG9mZnNldEZyb21SaWdodEVkZ2UgPCBvZmZzZXRGcm9tTGVmdEVkZ2UgPyBqIDogKGogLSAxKTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZWFjaGVkIGVuZFxuICAgIGlmICghZm91bmRNYXRjaCkge1xuICAgICAgaW5kZXhPbkxpbmUgPSB0ZXh0T25MaW5lLmxlbmd0aCAtIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4T25MaW5lO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciBkb3duXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBtb3ZlQ3Vyc29yRG93bjogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID49IHRoaXMudGV4dC5sZW5ndGggJiYgdGhpcy5zZWxlY3Rpb25FbmQgPj0gdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9tb3ZlQ3Vyc29yVXBPckRvd24oJ0Rvd24nLCBlKTtcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHVwXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBtb3ZlQ3Vyc29yVXA6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gMCAmJiB0aGlzLnNlbGVjdGlvbkVuZCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9tb3ZlQ3Vyc29yVXBPckRvd24oJ1VwJywgZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciB1cCBvciBkb3duLCBmaXJlcyB0aGUgZXZlbnRzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gJ1VwJyBvciAnRG93bidcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIF9tb3ZlQ3Vyc29yVXBPckRvd246IGZ1bmN0aW9uKGRpcmVjdGlvbiwgZSkge1xuICAgIC8vIGdldFVwQ3Vyc29yT2Zmc2V0XG4gICAgLy8gZ2V0RG93bkN1cnNvck9mZnNldFxuICAgIHZhciBhY3Rpb24gPSAnZ2V0JyArIGRpcmVjdGlvbiArICdDdXJzb3JPZmZzZXQnLFxuICAgICAgICBvZmZzZXQgPSB0aGlzW2FjdGlvbl0oZSwgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAncmlnaHQnKTtcbiAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgdGhpcy5tb3ZlQ3Vyc29yV2l0aFNoaWZ0KG9mZnNldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5tb3ZlQ3Vyc29yV2l0aG91dFNoaWZ0KG9mZnNldCk7XG4gICAgfVxuICAgIGlmIChvZmZzZXQgIT09IDApIHtcbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uSW5Cb3VuZGFyaWVzKCk7XG4gICAgICB0aGlzLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCk7XG4gICAgICB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eSA9IDE7XG4gICAgICB0aGlzLmluaXREZWxheWVkQ3Vyc29yKCk7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciB3aXRoIHNoaWZ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIG1vdmVDdXJzb3JXaXRoU2hpZnQ6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgIHZhciBuZXdTZWxlY3Rpb24gPSB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdsZWZ0J1xuICAgID8gdGhpcy5zZWxlY3Rpb25TdGFydCArIG9mZnNldFxuICAgIDogdGhpcy5zZWxlY3Rpb25FbmQgKyBvZmZzZXQ7XG4gICAgdGhpcy5zZXRTZWxlY3Rpb25TdGFydEVuZFdpdGhTaGlmdCh0aGlzLnNlbGVjdGlvblN0YXJ0LCB0aGlzLnNlbGVjdGlvbkVuZCwgbmV3U2VsZWN0aW9uKTtcbiAgICByZXR1cm4gb2Zmc2V0ICE9PSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgdXAgd2l0aG91dCBzaGlmdFxuICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XG4gICAqL1xuICBtb3ZlQ3Vyc29yV2l0aG91dFNoaWZ0OiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCArPSBvZmZzZXQ7XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgKz0gb2Zmc2V0O1xuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VsZWN0aW9uRW5kO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0ICE9PSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgbGVmdFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgbW92ZUN1cnNvckxlZnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gMCAmJiB0aGlzLnNlbGVjdGlvbkVuZCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9tb3ZlQ3Vyc29yTGVmdE9yUmlnaHQoJ0xlZnQnLCBlKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBhIGNoYW5nZSBoYXBwZW5lZFxuICAgKi9cbiAgX21vdmU6IGZ1bmN0aW9uKGUsIHByb3AsIGRpcmVjdGlvbikge1xuICAgIHZhciBuZXdWYWx1ZTtcbiAgICBpZiAoZS5hbHRLZXkpIHtcbiAgICAgIG5ld1ZhbHVlID0gdGhpc1snZmluZFdvcmRCb3VuZGFyeScgKyBkaXJlY3Rpb25dKHRoaXNbcHJvcF0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChlLm1ldGFLZXkgfHwgZS5rZXlDb2RlID09PSAzNSB8fCAgZS5rZXlDb2RlID09PSAzNiApIHtcbiAgICAgIG5ld1ZhbHVlID0gdGhpc1snZmluZExpbmVCb3VuZGFyeScgKyBkaXJlY3Rpb25dKHRoaXNbcHJvcF0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXNbcHJvcF0gKz0gZGlyZWN0aW9uID09PSAnTGVmdCcgPyAtMSA6IDE7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXdWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXNbcHJvcF0gIT09IG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzW3Byb3BdID0gbmV3VmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbW92ZUxlZnQ6IGZ1bmN0aW9uKGUsIHByb3ApIHtcbiAgICByZXR1cm4gdGhpcy5fbW92ZShlLCBwcm9wLCAnTGVmdCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21vdmVSaWdodDogZnVuY3Rpb24oZSwgcHJvcCkge1xuICAgIHJldHVybiB0aGlzLl9tb3ZlKGUsIHByb3AsICdSaWdodCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgbGVmdCB3aXRob3V0IGtlZXBpbmcgc2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICovXG4gIG1vdmVDdXJzb3JMZWZ0V2l0aG91dFNoaWZ0OiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGNoYW5nZSA9IHRydWU7XG4gICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ2xlZnQnO1xuXG4gICAgLy8gb25seSBtb3ZlIGN1cnNvciB3aGVuIHRoZXJlIGlzIG5vIHNlbGVjdGlvbixcbiAgICAvLyBvdGhlcndpc2Ugd2UgZGlzY2FyZCBpdCwgYW5kIGxlYXZlIGN1cnNvciBvbiBzYW1lIHBsYWNlXG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uRW5kID09PSB0aGlzLnNlbGVjdGlvblN0YXJ0ICYmIHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IDApIHtcbiAgICAgIGNoYW5nZSA9IHRoaXMuX21vdmVMZWZ0KGUsICdzZWxlY3Rpb25TdGFydCcpO1xuXG4gICAgfVxuICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICByZXR1cm4gY2hhbmdlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgbGVmdCB3aGlsZSBrZWVwaW5nIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqL1xuICBtb3ZlQ3Vyc29yTGVmdFdpdGhTaGlmdDogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdyaWdodCcgJiYgdGhpcy5zZWxlY3Rpb25TdGFydCAhPT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tb3ZlTGVmdChlLCAnc2VsZWN0aW9uRW5kJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IDApe1xuICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgcmV0dXJuIHRoaXMuX21vdmVMZWZ0KGUsICdzZWxlY3Rpb25TdGFydCcpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHJpZ2h0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBtb3ZlQ3Vyc29yUmlnaHQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA+PSB0aGlzLnRleHQubGVuZ3RoICYmIHRoaXMuc2VsZWN0aW9uRW5kID49IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbW92ZUN1cnNvckxlZnRPclJpZ2h0KCdSaWdodCcsIGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgcmlnaHQgb3IgTGVmdCwgZmlyZXMgZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRpcmVjdGlvbiAnTGVmdCcsICdSaWdodCdcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIF9tb3ZlQ3Vyc29yTGVmdE9yUmlnaHQ6IGZ1bmN0aW9uKGRpcmVjdGlvbiwgZSkge1xuICAgIHZhciBhY3Rpb25OYW1lID0gJ21vdmVDdXJzb3InICsgZGlyZWN0aW9uICsgJ1dpdGgnO1xuICAgIHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5ID0gMTtcblxuICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICBhY3Rpb25OYW1lICs9ICdTaGlmdCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYWN0aW9uTmFtZSArPSAnb3V0U2hpZnQnO1xuICAgIH1cbiAgICBpZiAodGhpc1thY3Rpb25OYW1lXShlKSkge1xuICAgICAgdGhpcy5hYm9ydEN1cnNvckFuaW1hdGlvbigpO1xuICAgICAgdGhpcy5pbml0RGVsYXllZEN1cnNvcigpO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgcmlnaHQgd2hpbGUga2VlcGluZyBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgbW92ZUN1cnNvclJpZ2h0V2l0aFNoaWZ0OiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ2xlZnQnICYmIHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW92ZVJpZ2h0KGUsICdzZWxlY3Rpb25TdGFydCcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbkVuZCAhPT0gdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgIHJldHVybiB0aGlzLl9tb3ZlUmlnaHQoZSwgJ3NlbGVjdGlvbkVuZCcpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHJpZ2h0IHdpdGhvdXQga2VlcGluZyBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG1vdmVDdXJzb3JSaWdodFdpdGhvdXRTaGlmdDogZnVuY3Rpb24oZSkge1xuICAgIHZhciBjaGFuZ2VkID0gdHJ1ZTtcbiAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAncmlnaHQnO1xuXG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICBjaGFuZ2VkID0gdGhpcy5fbW92ZVJpZ2h0KGUsICdzZWxlY3Rpb25TdGFydCcpO1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlbGVjdGlvbkVuZDtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgY2hhcmFjdGVycyBzZWxlY3RlZCBieSBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIHJlbW92ZUNoYXJzOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICB0aGlzLl9yZW1vdmVDaGFyc05lYXJDdXJzb3IoZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fcmVtb3ZlQ2hhcnNGcm9tVG8odGhpcy5zZWxlY3Rpb25TdGFydCwgdGhpcy5zZWxlY3Rpb25FbmQpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0U2VsZWN0aW9uRW5kKHRoaXMuc2VsZWN0aW9uU3RhcnQpO1xuXG4gICAgdGhpcy5fcmVtb3ZlRXh0cmFuZW91c1N0eWxlcygpO1xuXG4gICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMucmVuZGVyQWxsKCk7XG5cbiAgICB0aGlzLnNldENvb3JkcygpO1xuICAgIHRoaXMuZmlyZSgnY2hhbmdlZCcpO1xuICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6Y2hhbmdlZCcsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgX3JlbW92ZUNoYXJzTmVhckN1cnNvcjogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlLm1ldGFLZXkpIHtcbiAgICAgIC8vIHJlbW92ZSBhbGwgdGlsbCB0aGUgc3RhcnQgb2YgY3VycmVudCBsaW5lXG4gICAgICB2YXIgbGVmdExpbmVCb3VuZGFyeSA9IHRoaXMuZmluZExpbmVCb3VuZGFyeUxlZnQodGhpcy5zZWxlY3Rpb25TdGFydCk7XG5cbiAgICAgIHRoaXMuX3JlbW92ZUNoYXJzRnJvbVRvKGxlZnRMaW5lQm91bmRhcnksIHRoaXMuc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgdGhpcy5zZXRTZWxlY3Rpb25TdGFydChsZWZ0TGluZUJvdW5kYXJ5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZS5hbHRLZXkpIHtcbiAgICAgIC8vIHJlbW92ZSBhbGwgdGlsbCB0aGUgc3RhcnQgb2YgY3VycmVudCB3b3JkXG4gICAgICB2YXIgbGVmdFdvcmRCb3VuZGFyeSA9IHRoaXMuZmluZFdvcmRCb3VuZGFyeUxlZnQodGhpcy5zZWxlY3Rpb25TdGFydCk7XG5cbiAgICAgIHRoaXMuX3JlbW92ZUNoYXJzRnJvbVRvKGxlZnRXb3JkQm91bmRhcnksIHRoaXMuc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgdGhpcy5zZXRTZWxlY3Rpb25TdGFydChsZWZ0V29yZEJvdW5kYXJ5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9yZW1vdmVTaW5nbGVDaGFyQW5kU3R5bGUodGhpcy5zZWxlY3Rpb25TdGFydCk7XG4gICAgICB0aGlzLnNldFNlbGVjdGlvblN0YXJ0KHRoaXMuc2VsZWN0aW9uU3RhcnQgLSAxKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cbi8qIF9UT19TVkdfU1RBUlRfICovXG4oZnVuY3Rpb24oKSB7XG4gIHZhciB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZCxcbiAgICAgIE5VTV9GUkFDVElPTl9ESUdJVFMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFM7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuSVRleHQucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5JVGV4dC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHVGV4dExpbmVUZXh0OiBmdW5jdGlvbihsaW5lSW5kZXgsIHRleHRTcGFucywgaGVpZ2h0LCB0ZXh0TGVmdE9mZnNldCwgdGV4dFRvcE9mZnNldCwgdGV4dEJnUmVjdHMpIHtcbiAgICAgIGlmICghdGhpcy5fZ2V0TGluZVN0eWxlKGxpbmVJbmRleCkpIHtcbiAgICAgICAgZmFicmljLlRleHQucHJvdG90eXBlLl9zZXRTVkdUZXh0TGluZVRleHQuY2FsbCh0aGlzLFxuICAgICAgICAgIGxpbmVJbmRleCwgdGV4dFNwYW5zLCBoZWlnaHQsIHRleHRMZWZ0T2Zmc2V0LCB0ZXh0VG9wT2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9zZXRTVkdUZXh0TGluZUNoYXJzKFxuICAgICAgICAgIGxpbmVJbmRleCwgdGV4dFNwYW5zLCBoZWlnaHQsIHRleHRMZWZ0T2Zmc2V0LCB0ZXh0QmdSZWN0cyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR1RleHRMaW5lQ2hhcnM6IGZ1bmN0aW9uKGxpbmVJbmRleCwgdGV4dFNwYW5zLCBoZWlnaHQsIHRleHRMZWZ0T2Zmc2V0LCB0ZXh0QmdSZWN0cykge1xuXG4gICAgICB2YXIgY2hhcnMgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XSxcbiAgICAgICAgICBjaGFyT2Zmc2V0ID0gMCxcbiAgICAgICAgICBsaW5lTGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KHRoaXMuX2dldExpbmVXaWR0aCh0aGlzLmN0eCwgbGluZUluZGV4KSkgLSB0aGlzLndpZHRoIC8gMixcbiAgICAgICAgICBsaW5lT2Zmc2V0ID0gdGhpcy5fZ2V0U1ZHTGluZVRvcE9mZnNldChsaW5lSW5kZXgpLFxuICAgICAgICAgIGhlaWdodE9mTGluZSA9IHRoaXMuX2dldEhlaWdodE9mTGluZSh0aGlzLmN0eCwgbGluZUluZGV4KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoYXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBzdHlsZURlY2wgPSB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgaSkgfHwgeyB9O1xuXG4gICAgICAgIHRleHRTcGFucy5wdXNoKFxuICAgICAgICAgIHRoaXMuX2NyZWF0ZVRleHRDaGFyU3BhbihcbiAgICAgICAgICAgIGNoYXJzW2ldLCBzdHlsZURlY2wsIGxpbmVMZWZ0T2Zmc2V0LCBsaW5lT2Zmc2V0LmxpbmVUb3AgKyBsaW5lT2Zmc2V0Lm9mZnNldCwgY2hhck9mZnNldCkpO1xuXG4gICAgICAgIHZhciBjaGFyV2lkdGggPSB0aGlzLl9nZXRXaWR0aE9mQ2hhcih0aGlzLmN0eCwgY2hhcnNbaV0sIGxpbmVJbmRleCwgaSk7XG5cbiAgICAgICAgaWYgKHN0eWxlRGVjbC50ZXh0QmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgICAgdGV4dEJnUmVjdHMucHVzaChcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVRleHRDaGFyQmcoXG4gICAgICAgICAgICAgIHN0eWxlRGVjbCwgbGluZUxlZnRPZmZzZXQsIGxpbmVPZmZzZXQubGluZVRvcCwgaGVpZ2h0T2ZMaW5lLCBjaGFyV2lkdGgsIGNoYXJPZmZzZXQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoYXJPZmZzZXQgKz0gY2hhcldpZHRoO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRTVkdMaW5lVG9wT2Zmc2V0OiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHZhciBsaW5lVG9wT2Zmc2V0ID0gMCwgbGFzdEhlaWdodCA9IDA7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmVJbmRleDsgaisrKSB7XG4gICAgICAgIGxpbmVUb3BPZmZzZXQgKz0gdGhpcy5fZ2V0SGVpZ2h0T2ZMaW5lKHRoaXMuY3R4LCBqKTtcbiAgICAgIH1cbiAgICAgIGxhc3RIZWlnaHQgPSB0aGlzLl9nZXRIZWlnaHRPZkxpbmUodGhpcy5jdHgsIGopO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZVRvcDogbGluZVRvcE9mZnNldCxcbiAgICAgICAgb2Zmc2V0OiAodGhpcy5fZm9udFNpemVNdWx0IC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbikgKiBsYXN0SGVpZ2h0IC8gKHRoaXMubGluZUhlaWdodCAqIHRoaXMuX2ZvbnRTaXplTXVsdClcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZVRleHRDaGFyQmc6IGZ1bmN0aW9uKHN0eWxlRGVjbCwgbGluZUxlZnRPZmZzZXQsIGxpbmVUb3BPZmZzZXQsIGhlaWdodE9mTGluZSwgY2hhcldpZHRoLCBjaGFyT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAnXFx0XFx0PHJlY3QgZmlsbD1cIicsIHN0eWxlRGVjbC50ZXh0QmFja2dyb3VuZENvbG9yLFxuICAgICAgICAnXCIgeD1cIicsIHRvRml4ZWQobGluZUxlZnRPZmZzZXQgKyBjaGFyT2Zmc2V0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgJ1wiIHk9XCInLCB0b0ZpeGVkKGxpbmVUb3BPZmZzZXQgLSB0aGlzLmhlaWdodCAvIDIsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAnXCIgd2lkdGg9XCInLCB0b0ZpeGVkKGNoYXJXaWR0aCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICdcIiBoZWlnaHQ9XCInLCB0b0ZpeGVkKGhlaWdodE9mTGluZSAvIHRoaXMubGluZUhlaWdodCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICdcIj48L3JlY3Q+XFxuJ1xuICAgICAgXS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlVGV4dENoYXJTcGFuOiBmdW5jdGlvbihfY2hhciwgc3R5bGVEZWNsLCBsaW5lTGVmdE9mZnNldCwgbGluZVRvcE9mZnNldCwgY2hhck9mZnNldCkge1xuXG4gICAgICB2YXIgZmlsbFN0eWxlcyA9IHRoaXMuZ2V0U3ZnU3R5bGVzLmNhbGwoZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCh7XG4gICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgIGZpbGw6IHRoaXMuZmlsbCxcbiAgICAgICAgc3Ryb2tlOiB0aGlzLnN0cm9rZSxcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICBnZXRTdmdGaWx0ZXI6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmdldFN2Z0ZpbHRlclxuICAgICAgfSwgc3R5bGVEZWNsKSk7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgICdcXHRcXHRcXHQ8dHNwYW4geD1cIicsIHRvRml4ZWQobGluZUxlZnRPZmZzZXQgKyBjaGFyT2Zmc2V0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSwgJ1wiIHk9XCInLFxuICAgICAgICB0b0ZpeGVkKGxpbmVUb3BPZmZzZXQgLSB0aGlzLmhlaWdodCAvIDIsIE5VTV9GUkFDVElPTl9ESUdJVFMpLCAnXCIgJyxcbiAgICAgICAgICAoc3R5bGVEZWNsLmZvbnRGYW1pbHkgPyAnZm9udC1mYW1pbHk9XCInICsgc3R5bGVEZWNsLmZvbnRGYW1pbHkucmVwbGFjZSgvXCIvZywgJ1xcJycpICsgJ1wiICcgOiAnJyksXG4gICAgICAgICAgKHN0eWxlRGVjbC5mb250U2l6ZSA/ICdmb250LXNpemU9XCInICsgc3R5bGVEZWNsLmZvbnRTaXplICsgJ1wiICcgOiAnJyksXG4gICAgICAgICAgKHN0eWxlRGVjbC5mb250U3R5bGUgPyAnZm9udC1zdHlsZT1cIicgKyBzdHlsZURlY2wuZm9udFN0eWxlICsgJ1wiICcgOiAnJyksXG4gICAgICAgICAgKHN0eWxlRGVjbC5mb250V2VpZ2h0ID8gJ2ZvbnQtd2VpZ2h0PVwiJyArIHN0eWxlRGVjbC5mb250V2VpZ2h0ICsgJ1wiICcgOiAnJyksXG4gICAgICAgICAgKHN0eWxlRGVjbC50ZXh0RGVjb3JhdGlvbiA/ICd0ZXh0LWRlY29yYXRpb249XCInICsgc3R5bGVEZWNsLnRleHREZWNvcmF0aW9uICsgJ1wiICcgOiAnJyksXG4gICAgICAgICdzdHlsZT1cIicsIGZpbGxTdHlsZXMsICdcIj4nLFxuICAgICAgICBmYWJyaWMudXRpbC5zdHJpbmcuZXNjYXBlWG1sKF9jaGFyKSxcbiAgICAgICAgJzwvdHNwYW4+XFxuJ1xuICAgICAgXS5qb2luKCcnKTtcbiAgICB9XG4gIH0pO1xufSkoKTtcbi8qIF9UT19TVkdfRU5EXyAqL1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7fSksXG4gICAgICBjbG9uZSAgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmU7XG5cbiAgLyoqXG4gICAqIFRleHRib3ggY2xhc3MsIGJhc2VkIG9uIElUZXh0LCBhbGxvd3MgdGhlIHVzZXIgdG8gcmVzaXplIHRoZSB0ZXh0IHJlY3RhbmdsZVxuICAgKiBhbmQgd3JhcHMgbGluZXMgYXV0b21hdGljYWxseS4gVGV4dGJveGVzIGhhdmUgdGhlaXIgWSBzY2FsaW5nIGxvY2tlZCwgdGhlXG4gICAqIHVzZXIgY2FuIG9ubHkgY2hhbmdlIHdpZHRoLiBIZWlnaHQgaXMgYWRqdXN0ZWQgYXV0b21hdGljYWxseSBiYXNlZCBvbiB0aGVcbiAgICogd3JhcHBpbmcgb2YgbGluZXMuXG4gICAqIEBjbGFzcyBmYWJyaWMuVGV4dGJveFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSVRleHRcbiAgICogQG1peGVzIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5UZXh0Ym94fSB0aGlzQXJnXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5UZXh0Ym94I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuVGV4dGJveCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5JVGV4dCwgZmFicmljLk9ic2VydmFibGUsIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAndGV4dGJveCcsXG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIHdpZHRoIG9mIHRleHRib3gsIGluIHBpeGVscy5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1pbldpZHRoOiAyMCxcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gY2FsY3VsYXRlZCB3aWR0aCBvZiBhIHRleHRib3gsIGluIHBpeGVscy5cbiAgICAgKiBmaXhlZCB0byAyIHNvIHRoYXQgYW4gZW1wdHkgdGV4dGJveCBjYW5ub3QgZ28gdG8gMFxuICAgICAqIGFuZCBpcyBzdGlsbCBzZWxlY3RhYmxlIHdpdGhvdXQgdGV4dC5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGR5bmFtaWNNaW5XaWR0aDogMixcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBhcnJheSBvZiB0ZXh0IHdyYXBwaW5nLlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgX19jYWNoZWRMaW5lczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHN0YW5kYXJkIE9iamVjdCBjbGFzcyB2YWx1ZXNcbiAgICAgKi9cbiAgICBsb2NrU2NhbGluZ1k6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBzdGFuZGFyZCBPYmplY3QgY2xhc3MgdmFsdWVzXG4gICAgICovXG4gICAgbG9ja1NjYWxpbmdGbGlwOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IuIFNvbWUgc2NhbGluZyByZWxhdGVkIHByb3BlcnR5IHZhbHVlcyBhcmUgZm9yY2VkLiBWaXNpYmlsaXR5XG4gICAgICogb2YgY29udHJvbHMgaXMgYWxzbyBmaXhlZDsgb25seSB0aGUgcm90YXRpb24gYW5kIHdpZHRoIGNvbnRyb2xzIGFyZVxuICAgICAqIG1hZGUgYXZhaWxhYmxlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRleHQgc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5UZXh0Ym94fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24odGV4dCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5jdHggPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgdGV4dCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLnNldENvbnRyb2xzVmlzaWJpbGl0eShmYWJyaWMuVGV4dGJveC5nZXRUZXh0Ym94Q29udHJvbFZpc2liaWxpdHkoKSk7XG5cbiAgICAgIC8vIGFkZCB3aWR0aCB0byB0aGlzIGxpc3Qgb2YgcHJvcHMgdGhhdCBlZmZlY3QgbGluZSB3cmFwcGluZy5cbiAgICAgIHRoaXMuX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzLndpZHRoID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5saWtlIHN1cGVyY2xhc3MncyB2ZXJzaW9uIG9mIHRoaXMgZnVuY3Rpb24sIFRleHRib3ggZG9lcyBub3QgdXBkYXRlXG4gICAgICogaXRzIHdpZHRoLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byB1c2UgZm9yIG1lYXN1cmVtZW50c1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2luaXREaW1lbnNpb25zOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICh0aGlzLl9fc2tpcERpbWVuc2lvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghY3R4KSB7XG4gICAgICAgIGN0eCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB0aGlzLl9zZXRUZXh0U3R5bGVzKGN0eCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNsZWFyIGR5bmFtaWNNaW5XaWR0aCBhcyBpdCB3aWxsIGJlIGRpZmZlcmVudCBhZnRlciB3ZSByZS13cmFwIGxpbmVcbiAgICAgIHRoaXMuZHluYW1pY01pbldpZHRoID0gMDtcblxuICAgICAgLy8gd3JhcCBsaW5lc1xuICAgICAgdGhpcy5fdGV4dExpbmVzID0gdGhpcy5fc3BsaXRUZXh0SW50b0xpbmVzKCk7XG4gICAgICAvLyBpZiBhZnRlciB3cmFwcGluZywgdGhlIHdpZHRoIGlzIHNtYWxsZXIgdGhhbiBkeW5hbWljTWluV2lkdGgsIGNoYW5nZSB0aGUgd2lkdGggYW5kIHJlLXdyYXBcbiAgICAgIGlmICh0aGlzLmR5bmFtaWNNaW5XaWR0aCA+IHRoaXMud2lkdGgpIHtcbiAgICAgICAgdGhpcy5fc2V0KCd3aWR0aCcsIHRoaXMuZHluYW1pY01pbldpZHRoKTtcbiAgICAgIH1cblxuICAgICAgLy8gY2xlYXIgY2FjaGUgYW5kIHJlLWNhbGN1bGF0ZSBoZWlnaHRcbiAgICAgIHRoaXMuX2NsZWFyQ2FjaGUoKTtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5fZ2V0VGV4dEhlaWdodChjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbiBvYmplY3QgdGhhdCB0cmFuc2xhdGVzIHRoZSBzdHlsZSBvYmplY3Qgc28gdGhhdCBpdCBpc1xuICAgICAqIGJyb2tlbiB1cCBieSB2aXN1YWwgbGluZXMgKG5ldyBsaW5lcyBhbmQgYXV0b21hdGljIHdyYXBwaW5nKS5cbiAgICAgKiBUaGUgb3JpZ2luYWwgdGV4dCBzdHlsZXMgb2JqZWN0IGlzIGJyb2tlbiB1cCBieSBhY3R1YWwgbGluZXMgKG5ldyBsaW5lcyBvbmx5KSxcbiAgICAgKiB3aGljaCBpcyBvbmx5IHN1ZmZpY2llbnQgZm9yIFRleHQgLyBJVGV4dFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dlbmVyYXRlU3R5bGVNYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlYWxMaW5lQ291bnQgICAgID0gMCxcbiAgICAgICAgICByZWFsTGluZUNoYXJDb3VudCA9IDAsXG4gICAgICAgICAgY2hhckNvdW50ICAgICAgICAgPSAwLFxuICAgICAgICAgIG1hcCAgICAgICAgICAgICAgID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLnRleHRbY2hhckNvdW50XSA9PT0gJ1xcbicgJiYgaSA+IDApIHtcbiAgICAgICAgICByZWFsTGluZUNoYXJDb3VudCA9IDA7XG4gICAgICAgICAgY2hhckNvdW50Kys7XG4gICAgICAgICAgcmVhbExpbmVDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudGV4dFtjaGFyQ291bnRdID09PSAnICcgJiYgaSA+IDApIHtcbiAgICAgICAgICAvLyB0aGlzIGNhc2UgZGVhbHMgd2l0aCBzcGFjZSdzIHRoYXQgYXJlIHJlbW92ZWQgZnJvbSBlbmQgb2YgbGluZXMgd2hlbiB3cmFwcGluZ1xuICAgICAgICAgIHJlYWxMaW5lQ2hhckNvdW50Kys7XG4gICAgICAgICAgY2hhckNvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICBtYXBbaV0gPSB7IGxpbmU6IHJlYWxMaW5lQ291bnQsIG9mZnNldDogcmVhbExpbmVDaGFyQ291bnQgfTtcblxuICAgICAgICBjaGFyQ291bnQgKz0gdGhpcy5fdGV4dExpbmVzW2ldLmxlbmd0aDtcbiAgICAgICAgcmVhbExpbmVDaGFyQ291bnQgKz0gdGhpcy5fdGV4dExpbmVzW2ldLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZXR1cm5DbG9uZU9yRW1wdHk9ZmFsc2VdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgsIHJldHVybkNsb25lT3JFbXB0eSkge1xuICAgICAgaWYgKHRoaXMuX3N0eWxlTWFwKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgIHJldHVybiByZXR1cm5DbG9uZU9yRW1wdHkgPyB7IH0gOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVJbmRleCA9IG1hcC5saW5lO1xuICAgICAgICBjaGFySW5kZXggPSBtYXAub2Zmc2V0ICsgY2hhckluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCdfZ2V0U3R5bGVEZWNsYXJhdGlvbicsIGxpbmVJbmRleCwgY2hhckluZGV4LCByZXR1cm5DbG9uZU9yRW1wdHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFN0eWxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4LCBzdHlsZSkge1xuICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICBsaW5lSW5kZXggPSBtYXAubGluZTtcbiAgICAgIGNoYXJJbmRleCA9IG1hcC5vZmZzZXQgKyBjaGFySW5kZXg7XG5cbiAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4XSA9IHN0eWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RlbGV0ZVN0eWxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4XTtcbiAgICAgIGxpbmVJbmRleCA9IG1hcC5saW5lO1xuICAgICAgY2hhckluZGV4ID0gbWFwLm9mZnNldCArIGNoYXJJbmRleDtcblxuICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldExpbmVTdHlsZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4XTtcbiAgICAgIHJldHVybiB0aGlzLnN0eWxlc1ttYXAubGluZV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRMaW5lU3R5bGU6IGZ1bmN0aW9uKGxpbmVJbmRleCwgc3R5bGUpIHtcbiAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgdGhpcy5zdHlsZXNbbWFwLmxpbmVdID0gc3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZWxldGVMaW5lU3R5bGU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbWFwLmxpbmVdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXcmFwcyB0ZXh0IHVzaW5nIHRoZSAnd2lkdGgnIHByb3BlcnR5IG9mIFRleHRib3guIEZpcnN0IHRoaXMgZnVuY3Rpb25cbiAgICAgKiBzcGxpdHMgdGV4dCBvbiBuZXdsaW5lcywgc28gd2UgcHJlc2VydmUgbmV3bGluZXMgZW50ZXJlZCBieSB0aGUgdXNlci5cbiAgICAgKiBUaGVuIGl0IHdyYXBzIGVhY2ggbGluZSB1c2luZyB0aGUgd2lkdGggb2YgdGhlIFRleHRib3ggYnkgY2FsbGluZ1xuICAgICAqIF93cmFwTGluZSgpLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byB1c2UgZm9yIG1lYXN1cmVtZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSBzdHJpbmcgb2YgdGV4dCB0aGF0IGlzIHNwbGl0IGludG8gbGluZXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGxpbmVzXG4gICAgICovXG4gICAgX3dyYXBUZXh0OiBmdW5jdGlvbihjdHgsIHRleHQpIHtcbiAgICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQodGhpcy5fcmVOZXdsaW5lKSwgd3JhcHBlZCA9IFtdLCBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd3JhcHBlZCA9IHdyYXBwZWQuY29uY2F0KHRoaXMuX3dyYXBMaW5lKGN0eCwgbGluZXNbaV0sIGkpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHdyYXBwZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0byBtZWFzdXJlIGEgc3RyaW5nIG9mIHRleHQsIGdpdmVuIGl0cyBsaW5lSW5kZXggYW5kIGNoYXJJbmRleCBvZmZzZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2hhck9mZnNldFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWVhc3VyZVRleHQ6IGZ1bmN0aW9uKGN0eCwgdGV4dCwgbGluZUluZGV4LCBjaGFyT2Zmc2V0KSB7XG4gICAgICB2YXIgd2lkdGggPSAwO1xuICAgICAgY2hhck9mZnNldCA9IGNoYXJPZmZzZXQgfHwgMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0ZXh0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHdpZHRoICs9IHRoaXMuX2dldFdpZHRoT2ZDaGFyKGN0eCwgdGV4dFtpXSwgbGluZUluZGV4LCBpICsgY2hhck9mZnNldCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdyYXBzIGEgbGluZSBvZiB0ZXh0IHVzaW5nIHRoZSB3aWR0aCBvZiB0aGUgVGV4dGJveCBhbmQgYSBjb250ZXh0LlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byB1c2UgZm9yIG1lYXN1cmVtZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSBzdHJpbmcgb2YgdGV4dCB0byBzcGxpdCBpbnRvIGxpbmVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2YgbGluZShzKSBpbnRvIHdoaWNoIHRoZSBnaXZlbiB0ZXh0IGlzIHdyYXBwZWRcbiAgICAgKiB0by5cbiAgICAgKi9cbiAgICBfd3JhcExpbmU6IGZ1bmN0aW9uKGN0eCwgdGV4dCwgbGluZUluZGV4KSB7XG4gICAgICB2YXIgbGluZVdpZHRoICAgICAgICA9IDAsXG4gICAgICAgICAgbGluZXMgICAgICAgICAgICA9IFtdLFxuICAgICAgICAgIGxpbmUgICAgICAgICAgICAgPSAnJyxcbiAgICAgICAgICB3b3JkcyAgICAgICAgICAgID0gdGV4dC5zcGxpdCgnICcpLFxuICAgICAgICAgIHdvcmQgICAgICAgICAgICAgPSAnJyxcbiAgICAgICAgICBvZmZzZXQgICAgICAgICAgID0gMCxcbiAgICAgICAgICBpbmZpeCAgICAgICAgICAgID0gJyAnLFxuICAgICAgICAgIHdvcmRXaWR0aCAgICAgICAgPSAwLFxuICAgICAgICAgIGluZml4V2lkdGggICAgICAgPSAwLFxuICAgICAgICAgIGxhcmdlc3RXb3JkV2lkdGggPSAwLFxuICAgICAgICAgIGxpbmVKdXN0U3RhcnRlZCA9IHRydWUsXG4gICAgICAgICAgYWRkaXRpb25hbFNwYWNlID0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd29yZCA9IHdvcmRzW2ldO1xuICAgICAgICB3b3JkV2lkdGggPSB0aGlzLl9tZWFzdXJlVGV4dChjdHgsIHdvcmQsIGxpbmVJbmRleCwgb2Zmc2V0KTtcblxuICAgICAgICBvZmZzZXQgKz0gd29yZC5sZW5ndGg7XG5cbiAgICAgICAgbGluZVdpZHRoICs9IGluZml4V2lkdGggKyB3b3JkV2lkdGggLSBhZGRpdGlvbmFsU3BhY2U7XG5cbiAgICAgICAgaWYgKGxpbmVXaWR0aCA+PSB0aGlzLndpZHRoICYmICFsaW5lSnVzdFN0YXJ0ZWQpIHtcbiAgICAgICAgICBsaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICAgIGxpbmUgPSAnJztcbiAgICAgICAgICBsaW5lV2lkdGggPSB3b3JkV2lkdGg7XG4gICAgICAgICAgbGluZUp1c3RTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsaW5lV2lkdGggKz0gYWRkaXRpb25hbFNwYWNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsaW5lSnVzdFN0YXJ0ZWQpIHtcbiAgICAgICAgICBsaW5lICs9IGluZml4O1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgKz0gd29yZDtcblxuICAgICAgICBpbmZpeFdpZHRoID0gdGhpcy5fbWVhc3VyZVRleHQoY3R4LCBpbmZpeCwgbGluZUluZGV4LCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgbGluZUp1c3RTdGFydGVkID0gZmFsc2U7XG4gICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgbGFyZ2VzdCB3b3JkXG4gICAgICAgIGlmICh3b3JkV2lkdGggPiBsYXJnZXN0V29yZFdpZHRoKSB7XG4gICAgICAgICAgbGFyZ2VzdFdvcmRXaWR0aCA9IHdvcmRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpICYmIGxpbmVzLnB1c2gobGluZSk7XG5cbiAgICAgIGlmIChsYXJnZXN0V29yZFdpZHRoID4gdGhpcy5keW5hbWljTWluV2lkdGgpIHtcbiAgICAgICAgdGhpcy5keW5hbWljTWluV2lkdGggPSBsYXJnZXN0V29yZFdpZHRoIC0gYWRkaXRpb25hbFNwYWNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGluZXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXRzIGxpbmVzIG9mIHRleHQgdG8gcmVuZGVyIGluIHRoZSBUZXh0Ym94LiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXNcbiAgICAgKiB0ZXh0IHdyYXBwaW5nIG9uIHRoZSBmbHkgZXZlcnl0aW1lIGl0IGlzIGNhbGxlZC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGxpbmVzIGluIHRoZSBUZXh0Ym94LlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9zcGxpdFRleHRJbnRvTGluZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9yaWdpbmFsQWxpZ24gPSB0aGlzLnRleHRBbGlnbjtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuX3NldFRleHRTdHlsZXModGhpcy5jdHgpO1xuICAgICAgdGhpcy50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICB2YXIgbGluZXMgPSB0aGlzLl93cmFwVGV4dCh0aGlzLmN0eCwgdGhpcy50ZXh0KTtcbiAgICAgIHRoaXMudGV4dEFsaWduID0gb3JpZ2luYWxBbGlnbjtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuX3RleHRMaW5lcyA9IGxpbmVzO1xuICAgICAgdGhpcy5fc3R5bGVNYXAgPSB0aGlzLl9nZW5lcmF0ZVN0eWxlTWFwKCk7XG4gICAgICByZXR1cm4gbGluZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gcGFydCBvZiBhIGdyb3VwLCB3ZSBkb24ndCB3YW50IHRoZSBUZXh0Ym94J3Mgc2NhbGUgdG8gaW5jcmVhc2UgaWZcbiAgICAgKiB0aGUgZ3JvdXAncyBpbmNyZWFzZXMuIFRoYXQncyB3aHkgd2UgcmVkdWNlIHRoZSBzY2FsZSBvZiB0aGUgVGV4dGJveCBieVxuICAgICAqIHRoZSBhbW91bnQgdGhhdCB0aGUgZ3JvdXAncyBpbmNyZWFzZXMuIFRoaXMgaXMgdG8gbWFpbnRhaW4gdGhlIGVmZmVjdGl2ZVxuICAgICAqIHNjYWxlIG9mIHRoZSBUZXh0Ym94IGF0IDEsIHNvIHRoYXQgZm9udC1zaXplIHZhbHVlcyBtYWtlIHNlbnNlLiBPdGhlcndpc2VcbiAgICAgKiB0aGUgc2FtZSBmb250LXNpemUgdmFsdWUgd291bGQgcmVzdWx0IGluIGRpZmZlcmVudCBhY3R1YWwgc2l6ZSBkZXBlbmRpbmdcbiAgICAgKiBvbiB0aGUgdmFsdWUgb2YgdGhlIHNjYWxlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICovXG4gICAgc2V0T25Hcm91cDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGtleSA9PT0gJ3NjYWxlWCcpIHtcbiAgICAgICAgdGhpcy5zZXQoJ3NjYWxlWCcsIE1hdGguYWJzKDEgLyB2YWx1ZSkpO1xuICAgICAgICB0aGlzLnNldCgnd2lkdGgnLCAodGhpcy5nZXQoJ3dpZHRoJykgKiB2YWx1ZSkgL1xuICAgICAgICAgICh0eXBlb2YgdGhpcy5fX29sZFNjYWxlWCA9PT0gJ3VuZGVmaW5lZCcgPyAxIDogdGhpcy5fX29sZFNjYWxlWCkpO1xuICAgICAgICB0aGlzLl9fb2xkU2NhbGVYID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgMmQgcmVwcmVzZW50YXRpb24gKGxpbmVJbmRleCBhbmQgY2hhckluZGV4KSBvZiBjdXJzb3IgKG9yIHNlbGVjdGlvbiBzdGFydCkuXG4gICAgICogT3ZlcnJpZGVzIHRoZSBzdXBlcmNsYXNzIGZ1bmN0aW9uIHRvIHRha2UgaW50byBhY2NvdW50IHRleHQgd3JhcHBpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NlbGVjdGlvblN0YXJ0XSBPcHRpb25hbCBpbmRleC4gV2hlbiBub3QgZ2l2ZW4sIGN1cnJlbnQgc2VsZWN0aW9uU3RhcnQgaXMgdXNlZC5cbiAgICAgKi9cbiAgICBnZXQyREN1cnNvckxvY2F0aW9uOiBmdW5jdGlvbihzZWxlY3Rpb25TdGFydCkge1xuICAgICAgaWYgKHR5cGVvZiBzZWxlY3Rpb25TdGFydCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgfVxuXG4gICAgICB2YXIgbnVtTGluZXMgPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoLFxuICAgICAgICAgIHJlbW92ZWQgID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1MaW5lczsgaSsrKSB7XG4gICAgICAgIHZhciBsaW5lICAgID0gdGhpcy5fdGV4dExpbmVzW2ldLFxuICAgICAgICAgICAgbGluZUxlbiA9IGxpbmUubGVuZ3RoO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCA8PSByZW1vdmVkICsgbGluZUxlbikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5lSW5kZXg6IGksXG4gICAgICAgICAgICBjaGFySW5kZXg6IHNlbGVjdGlvblN0YXJ0IC0gcmVtb3ZlZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZW1vdmVkICs9IGxpbmVMZW47XG5cbiAgICAgICAgaWYgKHRoaXMudGV4dFtyZW1vdmVkXSA9PT0gJ1xcbicgfHwgdGhpcy50ZXh0W3JlbW92ZWRdID09PSAnICcpIHtcbiAgICAgICAgICByZW1vdmVkKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZUluZGV4OiBudW1MaW5lcyAtIDEsXG4gICAgICAgIGNoYXJJbmRleDogdGhpcy5fdGV4dExpbmVzW251bUxpbmVzIC0gMV0ubGVuZ3RoXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgc3VwZXJjbGFzcyBmdW5jdGlvbiBhbmQgdXNlcyB0ZXh0IHdyYXBwaW5nIGRhdGEgdG8gZ2V0IGN1cnNvclxuICAgICAqIGJvdW5kYXJ5IG9mZnNldHMgaW5zdGVhZCBvZiB0aGUgYXJyYXkgb2YgY2hhcnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gY2hhcnMgVW51c2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVPZkJvdW5kYXJpZXMgQ2FuIGJlICdjdXJzb3InIG9yICdzZWxlY3Rpb24nXG4gICAgICogQHJldHVybnMge09iamVjdH0gT2JqZWN0IHdpdGggJ3RvcCcsICdsZWZ0JywgYW5kICdsaW5lTGVmdCcgcHJvcGVydGllcyBzZXQuXG4gICAgICovXG4gICAgX2dldEN1cnNvckJvdW5kYXJpZXNPZmZzZXRzOiBmdW5jdGlvbihjaGFycywgdHlwZU9mQm91bmRhcmllcykge1xuICAgICAgdmFyIHRvcE9mZnNldCAgICAgID0gMCxcbiAgICAgICAgICBsZWZ0T2Zmc2V0ICAgICA9IDAsXG4gICAgICAgICAgY3Vyc29yTG9jYXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oKSxcbiAgICAgICAgICBsaW5lQ2hhcnMgICAgICA9IHRoaXMuX3RleHRMaW5lc1tjdXJzb3JMb2NhdGlvbi5saW5lSW5kZXhdLnNwbGl0KCcnKSxcbiAgICAgICAgICBsaW5lTGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KHRoaXMuX2dldExpbmVXaWR0aCh0aGlzLmN0eCwgY3Vyc29yTG9jYXRpb24ubGluZUluZGV4KSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3Vyc29yTG9jYXRpb24uY2hhckluZGV4OyBpKyspIHtcbiAgICAgICAgbGVmdE9mZnNldCArPSB0aGlzLl9nZXRXaWR0aE9mQ2hhcih0aGlzLmN0eCwgbGluZUNoYXJzW2ldLCBjdXJzb3JMb2NhdGlvbi5saW5lSW5kZXgsIGkpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY3Vyc29yTG9jYXRpb24ubGluZUluZGV4OyBpKyspIHtcbiAgICAgICAgdG9wT2Zmc2V0ICs9IHRoaXMuX2dldEhlaWdodE9mTGluZSh0aGlzLmN0eCwgaSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlT2ZCb3VuZGFyaWVzID09PSAnY3Vyc29yJykge1xuICAgICAgICB0b3BPZmZzZXQgKz0gKDEgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKSAqIHRoaXMuX2dldEhlaWdodE9mTGluZSh0aGlzLmN0eCwgY3Vyc29yTG9jYXRpb24ubGluZUluZGV4KVxuICAgICAgICAgIC8gdGhpcy5saW5lSGVpZ2h0IC0gdGhpcy5nZXRDdXJyZW50Q2hhckZvbnRTaXplKGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleCwgY3Vyc29yTG9jYXRpb24uY2hhckluZGV4KVxuICAgICAgICAgICogKDEgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiB0b3BPZmZzZXQsXG4gICAgICAgIGxlZnQ6IGxlZnRPZmZzZXQsXG4gICAgICAgIGxpbmVMZWZ0OiBsaW5lTGVmdE9mZnNldFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0TWluV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMubWluV2lkdGgsIHRoaXMuZHluYW1pY01pbldpZHRoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kIHRvT2JqZWN0XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpLCB7XG4gICAgICAgIG1pbldpZHRoOiB0aGlzLm1pbldpZHRoXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuVGV4dGJveCBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dGJveFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGZhYnJpYy5UZXh0Ym94IGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICogQHJldHVybiB7ZmFicmljLlRleHRib3h9IGluc3RhbmNlIG9mIGZhYnJpYy5UZXh0Ym94XG4gICAqL1xuICBmYWJyaWMuVGV4dGJveC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHZhciB0ZXh0Ym94ID0gbmV3IGZhYnJpYy5UZXh0Ym94KG9iamVjdC50ZXh0LCBjbG9uZShvYmplY3QpKTtcbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjayh0ZXh0Ym94KTtcbiAgICByZXR1cm4gdGV4dGJveDtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlZmF1bHQgY29udHJvbHMgdmlzaWJpbGl0eSByZXF1aXJlZCBmb3IgVGV4dGJveGVzLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgZmFicmljLlRleHRib3guZ2V0VGV4dGJveENvbnRyb2xWaXNpYmlsaXR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRsOiBmYWxzZSxcbiAgICAgIHRyOiBmYWxzZSxcbiAgICAgIGJyOiBmYWxzZSxcbiAgICAgIGJsOiBmYWxzZSxcbiAgICAgIG1sOiB0cnVlLFxuICAgICAgbXQ6IGZhbHNlLFxuICAgICAgbXI6IHRydWUsXG4gICAgICBtYjogZmFsc2UsXG4gICAgICBtdHI6IHRydWVcbiAgICB9O1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBfc2V0T2JqZWN0U2NhbGUgYW5kIGFkZCBUZXh0Ym94IHNwZWNpZmljIHJlc2l6aW5nIGJlaGF2aW9yLiBSZXNpemluZ1xuICAgKiBhIFRleHRib3ggZG9lc24ndCBzY2FsZSB0ZXh0LCBpdCBvbmx5IGNoYW5nZXMgd2lkdGggYW5kIG1ha2VzIHRleHQgd3JhcCBhdXRvbWF0aWNhbGx5LlxuICAgKi9cbiAgdmFyIHNldE9iamVjdFNjYWxlT3ZlcnJpZGRlbiA9IGZhYnJpYy5DYW52YXMucHJvdG90eXBlLl9zZXRPYmplY3RTY2FsZTtcblxuICBmYWJyaWMuQ2FudmFzLnByb3RvdHlwZS5fc2V0T2JqZWN0U2NhbGUgPSBmdW5jdGlvbihsb2NhbE1vdXNlLCB0cmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2tTY2FsaW5nWCwgbG9ja1NjYWxpbmdZLCBieSwgbG9ja1NjYWxpbmdGbGlwLCBfZGltKSB7XG5cbiAgICB2YXIgdCA9IHRyYW5zZm9ybS50YXJnZXQ7XG4gICAgaWYgKHQgaW5zdGFuY2VvZiBmYWJyaWMuVGV4dGJveCkge1xuICAgICAgdmFyIHcgPSB0LndpZHRoICogKChsb2NhbE1vdXNlLnggLyB0cmFuc2Zvcm0uc2NhbGVYKSAvICh0LndpZHRoICsgdC5zdHJva2VXaWR0aCkpO1xuICAgICAgaWYgKHcgPj0gdC5nZXRNaW5XaWR0aCgpKSB7XG4gICAgICAgIHQuc2V0KCd3aWR0aCcsIHcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gc2V0T2JqZWN0U2NhbGVPdmVycmlkZGVuLmNhbGwoZmFicmljLkNhbnZhcy5wcm90b3R5cGUsIGxvY2FsTW91c2UsIHRyYW5zZm9ybSxcbiAgICAgICAgbG9ja1NjYWxpbmdYLCBsb2NrU2NhbGluZ1ksIGJ5LCBsb2NrU2NhbGluZ0ZsaXAsIF9kaW0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0cyBjb250cm9scyBvZiB0aGlzIGdyb3VwIHRvIHRoZSBUZXh0Ym94J3Mgc3BlY2lhbCBjb25maWd1cmF0aW9uIGlmXG4gICAqIG9uZSBpcyBwcmVzZW50IGluIHRoZSBncm91cC4gRGVsZXRlcyBfY29udHJvbHNWaXNpYmlsaXR5IG90aGVyd2lzZSwgc28gdGhhdFxuICAgKiBpdCBnZXRzIGluaXRpYWxpemVkIHRvIGRlZmF1bHQgdmFsdWUgYXQgcnVudGltZS5cbiAgICovXG4gIGZhYnJpYy5Hcm91cC5wcm90b3R5cGUuX3JlZnJlc2hDb250cm9sc1Zpc2liaWxpdHkgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodHlwZW9mIGZhYnJpYy5UZXh0Ym94ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGktLTspIHtcbiAgICAgIGlmICh0aGlzLl9vYmplY3RzW2ldIGluc3RhbmNlb2YgZmFicmljLlRleHRib3gpIHtcbiAgICAgICAgdGhpcy5zZXRDb250cm9sc1Zpc2liaWxpdHkoZmFicmljLlRleHRib3guZ2V0VGV4dGJveENvbnRyb2xWaXNpYmlsaXR5KCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBjbG9uZSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZTtcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5UZXh0Ym94LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuSVRleHQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmVFeHRyYW5lb3VzU3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5fc3R5bGVNYXApIHtcbiAgICAgICAgaWYgKCF0aGlzLl90ZXh0TGluZXNbcHJvcF0pIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbdGhpcy5fc3R5bGVNYXBbcHJvcF0ubGluZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBzdHlsZSBvYmplY3QgZm9yIGEgZ2l2ZW4gbGluZS9jaGFyIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBJbmRleCBvZiBhIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4IEluZGV4IG9mIGEgY2hhclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVdIFN0eWxlIG9iamVjdCB0byBpbnNlcnQsIGlmIGdpdmVuXG4gICAgICovXG4gICAgaW5zZXJ0Q2hhclN0eWxlT2JqZWN0OiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgc3R5bGUpIHtcbiAgICAgIC8vIGFkanVzdCBsaW5lSW5kZXggYW5kIGNoYXJJbmRleFxuICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICBsaW5lSW5kZXggPSBtYXAubGluZTtcbiAgICAgIGNoYXJJbmRleCA9IG1hcC5vZmZzZXQgKyBjaGFySW5kZXg7XG5cbiAgICAgIGZhYnJpYy5JVGV4dC5wcm90b3R5cGUuaW5zZXJ0Q2hhclN0eWxlT2JqZWN0LmFwcGx5KHRoaXMsIFtsaW5lSW5kZXgsIGNoYXJJbmRleCwgc3R5bGVdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBuZXcgc3R5bGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBJbmRleCBvZiBhIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4IEluZGV4IG9mIGEgY2hhclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNFbmRPZkxpbmUgVHJ1ZSBpZiBpdCdzIGVuZCBvZiBsaW5lXG4gICAgICovXG4gICAgaW5zZXJ0TmV3bGluZVN0eWxlT2JqZWN0OiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgaXNFbmRPZkxpbmUpIHtcbiAgICAgIC8vIGFkanVzdCBsaW5lSW5kZXggYW5kIGNoYXJJbmRleFxuICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICBsaW5lSW5kZXggPSBtYXAubGluZTtcbiAgICAgIGNoYXJJbmRleCA9IG1hcC5vZmZzZXQgKyBjaGFySW5kZXg7XG5cbiAgICAgIGZhYnJpYy5JVGV4dC5wcm90b3R5cGUuaW5zZXJ0TmV3bGluZVN0eWxlT2JqZWN0LmFwcGx5KHRoaXMsIFtsaW5lSW5kZXgsIGNoYXJJbmRleCwgaXNFbmRPZkxpbmVdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hpZnRzIGxpbmUgc3R5bGVzIHVwIG9yIGRvd24uIFRoaXMgZnVuY3Rpb24gaXMgc2xpZ2h0bHkgZGlmZmVyZW50IHRoYW4gdGhlIG9uZSBpblxuICAgICAqIGl0ZXh0X2JlaGF2aW91ciBhcyBpdCB0YWtlcyBpbnRvIGFjY291bnQgdGhlIHN0eWxlTWFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBJbmRleCBvZiBhIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IENhbiBiZSAtMSBvciArMVxuICAgICAqL1xuICAgIHNoaWZ0TGluZVN0eWxlczogZnVuY3Rpb24obGluZUluZGV4LCBvZmZzZXQpIHtcbiAgICAgIC8vIHNoaWZ0IGFsbCBsaW5lIHN0eWxlcyBieSAxIHVwd2FyZFxuICAgICAgdmFyIGNsb25lZFN0eWxlcyA9IGNsb25lKHRoaXMuc3R5bGVzKSxcbiAgICAgICAgICBtYXAgICAgICAgICAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuXG4gICAgICAvLyBhZGp1c3QgbGluZSBpbmRleFxuICAgICAgbGluZUluZGV4ID0gbWFwLmxpbmU7XG5cbiAgICAgIGZvciAodmFyIGxpbmUgaW4gdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgdmFyIG51bWVyaWNMaW5lID0gcGFyc2VJbnQobGluZSwgMTApO1xuXG4gICAgICAgIGlmIChudW1lcmljTGluZSA+IGxpbmVJbmRleCkge1xuICAgICAgICAgIHRoaXMuc3R5bGVzW251bWVyaWNMaW5lICsgb2Zmc2V0XSA9IGNsb25lZFN0eWxlc1tudW1lcmljTGluZV07XG5cbiAgICAgICAgICBpZiAoIWNsb25lZFN0eWxlc1tudW1lcmljTGluZSAtIG9mZnNldF0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tudW1lcmljTGluZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL1RPRE86IGV2YWx1YXRlIGlmIGRlbGV0ZSBvbGQgc3R5bGUgbGluZXMgd2l0aCBvZmZzZXQgLTFcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlndXJlIG91dCBwcm9ncmFtYXRpY2FsbHkgdGhlIHRleHQgb24gcHJldmlvdXMgYWN0dWFsIGxpbmUgKGFjdHVhbCA9IHNlcGFyYXRlZCBieSBcXG4pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxJbmRleFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0VGV4dE9uUHJldmlvdXNMaW5lOiBmdW5jdGlvbihsSW5kZXgpIHtcbiAgICAgIHZhciB0ZXh0T25QcmV2aW91c0xpbmUgPSB0aGlzLl90ZXh0TGluZXNbbEluZGV4IC0gMV07XG5cbiAgICAgIHdoaWxlICh0aGlzLl9zdHlsZU1hcFtsSW5kZXggLSAyXSAmJiB0aGlzLl9zdHlsZU1hcFtsSW5kZXggLSAyXS5saW5lID09PSB0aGlzLl9zdHlsZU1hcFtsSW5kZXggLSAxXS5saW5lKSB7XG4gICAgICAgIHRleHRPblByZXZpb3VzTGluZSA9IHRoaXMuX3RleHRMaW5lc1tsSW5kZXggLSAyXSArIHRleHRPblByZXZpb3VzTGluZTtcblxuICAgICAgICBsSW5kZXgtLTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRleHRPblByZXZpb3VzTGluZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBzdHlsZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmVnaW5uaW5nT2ZMaW5lIFRydWUgaWYgY3Vyc29yIGlzIGF0IHRoZSBiZWdpbm5pbmcgb2YgbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXhdIE9wdGlvbmFsIGluZGV4LiBXaGVuIG5vdCBnaXZlbiwgY3VycmVudCBzZWxlY3Rpb25TdGFydCBpcyB1c2VkLlxuICAgICAqL1xuICAgIHJlbW92ZVN0eWxlT2JqZWN0OiBmdW5jdGlvbihpc0JlZ2lubmluZ09mTGluZSwgaW5kZXgpIHtcblxuICAgICAgdmFyIGN1cnNvckxvY2F0aW9uID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKGluZGV4KSxcbiAgICAgICAgICBtYXAgICAgICAgICAgICA9IHRoaXMuX3N0eWxlTWFwW2N1cnNvckxvY2F0aW9uLmxpbmVJbmRleF0sXG4gICAgICAgICAgbGluZUluZGV4ICAgICAgPSBtYXAubGluZSxcbiAgICAgICAgICBjaGFySW5kZXggICAgICA9IG1hcC5vZmZzZXQgKyBjdXJzb3JMb2NhdGlvbi5jaGFySW5kZXg7XG4gICAgICB0aGlzLl9yZW1vdmVTdHlsZU9iamVjdChpc0JlZ2lubmluZ09mTGluZSwgY3Vyc29yTG9jYXRpb24sIGxpbmVJbmRleCwgY2hhckluZGV4KTtcbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBvdmVycmlkZSA9IGZhYnJpYy5JVGV4dC5wcm90b3R5cGUuX2dldE5ld1NlbGVjdGlvblN0YXJ0RnJvbU9mZnNldDtcbiAgLyoqXG4gICAqIE92ZXJyaWRlcyB0aGUgSVRleHQgaW1wbGVtZW50YXRpb24gYW5kIGFkanVzdHMgY2hhcmFjdGVyIGluZGV4IGFzIHRoZXJlIGlzIG5vdCBhbHdheXMgYSBsaW5lYnJlYWtcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1vdXNlT2Zmc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwcmV2V2lkdGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gamxlblxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgZmFicmljLklUZXh0LnByb3RvdHlwZS5fZ2V0TmV3U2VsZWN0aW9uU3RhcnRGcm9tT2Zmc2V0ID0gZnVuY3Rpb24obW91c2VPZmZzZXQsIHByZXZXaWR0aCwgd2lkdGgsIGluZGV4LCBqbGVuKSB7XG4gICAgaW5kZXggPSBvdmVycmlkZS5jYWxsKHRoaXMsIG1vdXNlT2Zmc2V0LCBwcmV2V2lkdGgsIHdpZHRoLCBpbmRleCwgamxlbik7XG5cbiAgICAvLyB0aGUgaW5kZXggcGFzc2VkIGludG8gdGhlIGZ1bmN0aW9uIGlzIHBhZGRlZCBieSB0aGUgYW1vdW50IG9mIGxpbmVzIGZyb20gX3RleHRMaW5lcyAodG8gYWNjb3VudCBmb3IgXFxuKVxuICAgIC8vIHdlIG5lZWQgdG8gcmVtb3ZlIHRoaXMgcGFkZGluZywgYW5kIHBhZCBpdCBieSBhY3R1YWwgbGluZXMsIGFuZCAvIG9yIHNwYWNlcyB0aGF0IGFyZSBtZWFudCB0byBiZSB0aGVyZVxuICAgIHZhciB0bXAgICAgID0gMCxcbiAgICAgICAgcmVtb3ZlZCA9IDA7XG5cbiAgICAvLyBhY2NvdW50IGZvciByZW1vdmVkIGNoYXJhY3RlcnNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdG1wICs9IHRoaXMuX3RleHRMaW5lc1tpXS5sZW5ndGg7XG5cbiAgICAgIGlmICh0bXAgKyByZW1vdmVkID49IGluZGV4KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50ZXh0W3RtcCArIHJlbW92ZWRdID09PSAnXFxuJyB8fCB0aGlzLnRleHRbdG1wICsgcmVtb3ZlZF0gPT09ICcgJykge1xuICAgICAgICByZW1vdmVkKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4IC0gaSArIHJlbW92ZWQ7XG4gIH07XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBET01QYXJzZXIgPSByZXF1aXJlKCd4bWxkb20nKS5ET01QYXJzZXIsXG4gICAgICBVUkwgPSByZXF1aXJlKCd1cmwnKSxcbiAgICAgIEhUVFAgPSByZXF1aXJlKCdodHRwJyksXG4gICAgICBIVFRQUyA9IHJlcXVpcmUoJ2h0dHBzJyksXG5cbiAgICAgIENhbnZhcyA9IHJlcXVpcmUoJ2NhbnZhcycpLFxuICAgICAgSW1hZ2UgPSByZXF1aXJlKCdjYW52YXMnKS5JbWFnZTtcblxuICAvKiogQHByaXZhdGUgKi9cbiAgZnVuY3Rpb24gcmVxdWVzdCh1cmwsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIHZhciBvVVJMID0gVVJMLnBhcnNlKHVybCk7XG5cbiAgICAvLyBkZXRlY3QgaWYgaHR0cCBvciBodHRwcyBpcyB1c2VkXG4gICAgaWYgKCAhb1VSTC5wb3J0ICkge1xuICAgICAgb1VSTC5wb3J0ID0gKCBvVVJMLnByb3RvY29sLmluZGV4T2YoJ2h0dHBzOicpID09PSAwICkgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICAvLyBhc3NpZ24gcmVxdWVzdCBoYW5kbGVyIGJhc2VkIG9uIHByb3RvY29sXG4gICAgdmFyIHJlcUhhbmRsZXIgPSAob1VSTC5wcm90b2NvbC5pbmRleE9mKCdodHRwczonKSA9PT0gMCApID8gSFRUUFMgOiBIVFRQLFxuICAgICAgICByZXEgPSByZXFIYW5kbGVyLnJlcXVlc3Qoe1xuICAgICAgICAgIGhvc3RuYW1lOiBvVVJMLmhvc3RuYW1lLFxuICAgICAgICAgIHBvcnQ6IG9VUkwucG9ydCxcbiAgICAgICAgICBwYXRoOiBvVVJMLnBhdGgsXG4gICAgICAgICAgbWV0aG9kOiAnR0VUJ1xuICAgICAgICB9LCBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgIHZhciBib2R5ID0gJyc7XG4gICAgICAgICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICAgICAgICByZXNwb25zZS5zZXRFbmNvZGluZyhlbmNvZGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3BvbnNlLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhib2R5KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXNwb25zZS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDIwMCkge1xuICAgICAgICAgICAgICBib2R5ICs9IGNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmIChlcnIuZXJybm8gPT09IHByb2Nlc3MuRUNPTk5SRUZVU0VEKSB7XG4gICAgICAgIGZhYnJpYy5sb2coJ0VDT05OUkVGVVNFRDogY29ubmVjdGlvbiByZWZ1c2VkIHRvICcgKyBvVVJMLmhvc3RuYW1lICsgJzonICsgb1VSTC5wb3J0KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmYWJyaWMubG9nKGVyci5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH0pO1xuXG4gICAgcmVxLmVuZCgpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGZ1bmN0aW9uIHJlcXVlc3RGcyhwYXRoLCBjYWxsYmFjaykge1xuICAgIHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gICAgZnMucmVhZEZpbGUocGF0aCwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBmYWJyaWMubG9nKGVycik7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLmxvYWRJbWFnZSA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGVJbWFnZUFuZENhbGxCYWNrKGRhdGEpIHtcbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGltZy5zcmMgPSBuZXcgQnVmZmVyKGRhdGEsICdiaW5hcnknKTtcbiAgICAgICAgLy8gcHJlc2VydmluZyBvcmlnaW5hbCB1cmwsIHdoaWNoIHNlZW1zIHRvIGJlIGxvc3QgaW4gbm9kZS1jYW52YXNcbiAgICAgICAgaW1nLl9zcmMgPSB1cmw7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgaW1nKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpbWcgPSBudWxsO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGNvbnRleHQsIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgaWYgKHVybCAmJiAodXJsIGluc3RhbmNlb2YgQnVmZmVyIHx8IHVybC5pbmRleE9mKCdkYXRhJykgPT09IDApKSB7XG4gICAgICBpbWcuc3JjID0gaW1nLl9zcmMgPSB1cmw7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGltZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHVybCAmJiB1cmwuaW5kZXhPZignaHR0cCcpICE9PSAwKSB7XG4gICAgICByZXF1ZXN0RnModXJsLCBjcmVhdGVJbWFnZUFuZENhbGxCYWNrKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodXJsKSB7XG4gICAgICByZXF1ZXN0KHVybCwgJ2JpbmFyeScsIGNyZWF0ZUltYWdlQW5kQ2FsbEJhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgdXJsKTtcbiAgICB9XG4gIH07XG5cbiAgZmFicmljLmxvYWRTVkdGcm9tVVJMID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaywgcmV2aXZlcikge1xuICAgIHVybCA9IHVybC5yZXBsYWNlKC9eXFxuXFxzKi8sICcnKS5yZXBsYWNlKC9cXD8uKiQvLCAnJykudHJpbSgpO1xuICAgIGlmICh1cmwuaW5kZXhPZignaHR0cCcpICE9PSAwKSB7XG4gICAgICByZXF1ZXN0RnModXJsLCBmdW5jdGlvbihib2R5KSB7XG4gICAgICAgIGZhYnJpYy5sb2FkU1ZHRnJvbVN0cmluZyhib2R5LnRvU3RyaW5nKCksIGNhbGxiYWNrLCByZXZpdmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJlcXVlc3QodXJsLCAnJywgZnVuY3Rpb24oYm9keSkge1xuICAgICAgICBmYWJyaWMubG9hZFNWR0Zyb21TdHJpbmcoYm9keSwgY2FsbGJhY2ssIHJldml2ZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGZhYnJpYy5sb2FkU1ZHRnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0cmluZywgY2FsbGJhY2ssIHJldml2ZXIpIHtcbiAgICB2YXIgZG9jID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzdHJpbmcpO1xuICAgIGZhYnJpYy5wYXJzZVNWR0RvY3VtZW50KGRvYy5kb2N1bWVudEVsZW1lbnQsIGZ1bmN0aW9uKHJlc3VsdHMsIG9wdGlvbnMpIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3VsdHMsIG9wdGlvbnMpO1xuICAgIH0sIHJldml2ZXIpO1xuICB9O1xuXG4gIGZhYnJpYy51dGlsLmdldFNjcmlwdCA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcbiAgICByZXF1ZXN0KHVybCwgJycsIGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1ldmFsXG4gICAgICBldmFsKGJvZHkpO1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50ID0gZnVuY3Rpb24oXywgd2lkdGgsIGhlaWdodCkge1xuICAvLyAgIHJldHVybiBuZXcgQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAvLyB9XG5cbiAgLyoqXG4gICAqIE9ubHkgYXZhaWxhYmxlIHdoZW4gcnVubmluZyBmYWJyaWMgb24gbm9kZS5qc1xuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggQ2FudmFzIHdpZHRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgQ2FudmFzIGhlaWdodFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0byBGYWJyaWNDYW52YXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbbm9kZUNhbnZhc09wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0byBOb2RlQ2FudmFzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHdyYXBwZWQgY2FudmFzIGluc3RhbmNlXG4gICAqL1xuICBmYWJyaWMuY3JlYXRlQ2FudmFzRm9yTm9kZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMsIG5vZGVDYW52YXNPcHRpb25zKSB7XG4gICAgbm9kZUNhbnZhc09wdGlvbnMgPSBub2RlQ2FudmFzT3B0aW9ucyB8fCBvcHRpb25zO1xuXG4gICAgdmFyIGNhbnZhc0VsID0gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLFxuICAgICAgICBub2RlQ2FudmFzID0gbmV3IENhbnZhcyh3aWR0aCB8fCA2MDAsIGhlaWdodCB8fCA2MDAsIG5vZGVDYW52YXNPcHRpb25zKSxcbiAgICAgICAgbm9kZUNhY2hlQ2FudmFzID0gbmV3IENhbnZhcyh3aWR0aCB8fCA2MDAsIGhlaWdodCB8fCA2MDAsIG5vZGVDYW52YXNPcHRpb25zKTtcblxuICAgIC8vIGpzZG9tIGRvZXNuJ3QgY3JlYXRlIHN0eWxlIG9uIGNhbnZhcyBlbGVtZW50LCBzbyBoZXJlIGJlIHRlbXAuIHdvcmthcm91bmRcbiAgICBjYW52YXNFbC5zdHlsZSA9IHsgfTtcblxuICAgIGNhbnZhc0VsLndpZHRoID0gbm9kZUNhbnZhcy53aWR0aDtcbiAgICBjYW52YXNFbC5oZWlnaHQgPSBub2RlQ2FudmFzLmhlaWdodDtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG4gICAgb3B0aW9ucy5ub2RlQ2FudmFzID0gbm9kZUNhbnZhcztcbiAgICBvcHRpb25zLm5vZGVDYWNoZUNhbnZhcyA9IG5vZGVDYWNoZUNhbnZhcztcbiAgICB2YXIgRmFicmljQ2FudmFzID0gZmFicmljLkNhbnZhcyB8fCBmYWJyaWMuU3RhdGljQ2FudmFzLFxuICAgICAgICBmYWJyaWNDYW52YXMgPSBuZXcgRmFicmljQ2FudmFzKGNhbnZhc0VsLCBvcHRpb25zKTtcbiAgICBmYWJyaWNDYW52YXMubm9kZUNhbnZhcyA9IG5vZGVDYW52YXM7XG4gICAgZmFicmljQ2FudmFzLm5vZGVDYWNoZUNhbnZhcyA9IG5vZGVDYWNoZUNhbnZhcztcbiAgICBmYWJyaWNDYW52YXMuY29udGV4dENvbnRhaW5lciA9IG5vZGVDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBmYWJyaWNDYW52YXMuY29udGV4dENhY2hlID0gbm9kZUNhY2hlQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgZmFicmljQ2FudmFzLkZvbnQgPSBDYW52YXMuRm9udDtcbiAgICByZXR1cm4gZmFicmljQ2FudmFzO1xuICB9O1xuXG4gIHZhciBvcmlnaW5hSW5pdFN0YXRpYyA9IGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLl9pbml0U3RhdGljO1xuICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5faW5pdFN0YXRpYyA9IGZ1bmN0aW9uKGVsLCBvcHRpb25zKSB7XG4gICAgZWwgPSBlbCB8fCBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdGhpcy5ub2RlQ2FudmFzID0gbmV3IENhbnZhcyhlbC53aWR0aCwgZWwuaGVpZ2h0KTtcbiAgICB0aGlzLm5vZGVDYWNoZUNhbnZhcyA9IG5ldyBDYW52YXMoZWwud2lkdGgsIGVsLmhlaWdodCk7XG4gICAgb3JpZ2luYUluaXRTdGF0aWMuY2FsbCh0aGlzLCBlbCwgb3B0aW9ucyk7XG4gICAgdGhpcy5jb250ZXh0Q29udGFpbmVyID0gdGhpcy5ub2RlQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdGhpcy5jb250ZXh0Q2FjaGUgPSB0aGlzLm5vZGVDYWNoZUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRoaXMuRm9udCA9IENhbnZhcy5Gb250O1xuICB9XG5cbiAgLyoqIEBpZ25vcmUgKi9cbiAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuY3JlYXRlUE5HU3RyZWFtID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZUNhbnZhcy5jcmVhdGVQTkdTdHJlYW0oKTtcbiAgfTtcblxuICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5jcmVhdGVKUEVHU3RyZWFtID0gZnVuY3Rpb24ob3B0cykge1xuICAgIHJldHVybiB0aGlzLm5vZGVDYW52YXMuY3JlYXRlSlBFR1N0cmVhbShvcHRzKTtcbiAgfTtcblxuICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5faW5pdFJldGluYVNjYWxpbmcgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2lzUmV0aW5hU2NhbGluZygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5sb3dlckNhbnZhc0VsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLndpZHRoICogZmFicmljLmRldmljZVBpeGVsUmF0aW8pO1xuICAgIHRoaXMubG93ZXJDYW52YXNFbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuaGVpZ2h0ICogZmFicmljLmRldmljZVBpeGVsUmF0aW8pO1xuICAgIHRoaXMubm9kZUNhbnZhcy53aWR0aCA9IHRoaXMud2lkdGggKiBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICB0aGlzLm5vZGVDYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICB0aGlzLmNvbnRleHRDb250YWluZXIuc2NhbGUoZmFicmljLmRldmljZVBpeGVsUmF0aW8sIGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgaWYgKGZhYnJpYy5DYW52YXMpIHtcbiAgICBmYWJyaWMuQ2FudmFzLnByb3RvdHlwZS5faW5pdFJldGluYVNjYWxpbmcgPSBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5faW5pdFJldGluYVNjYWxpbmc7XG4gIH1cblxuICB2YXIgb3JpZ1NldEJhY2tzdG9yZURpbWVuc2lvbiA9IGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLl9zZXRCYWNrc3RvcmVEaW1lbnNpb247XG4gIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLl9zZXRCYWNrc3RvcmVEaW1lbnNpb24gPSBmdW5jdGlvbihwcm9wLCB2YWx1ZSkge1xuICAgIG9yaWdTZXRCYWNrc3RvcmVEaW1lbnNpb24uY2FsbCh0aGlzLCBwcm9wLCB2YWx1ZSk7XG4gICAgdGhpcy5ub2RlQ2FudmFzW3Byb3BdID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGlmIChmYWJyaWMuQ2FudmFzKSB7XG4gICAgZmFicmljLkNhbnZhcy5wcm90b3R5cGUuX3NldEJhY2tzdG9yZURpbWVuc2lvbiA9IGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLl9zZXRCYWNrc3RvcmVEaW1lbnNpb247XG4gIH1cblxufSkoKTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2ZhYnJpYy9kaXN0L2ZhYnJpYy5qc1xuICoqIG1vZHVsZSBpZCA9IDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9idWZmZXIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICByZXR1cm4gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIHJldHVybiBiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgcGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxuXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cblxuICB2YXIgTCA9IDBcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJ1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPT0nXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSlcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9J1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpXG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vYmFzZTY0LWpzL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vaWVlZTc1NC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9pc2FycmF5L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vcHJvY2Vzcy9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIChpZ25vcmVkKSAqL1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKioganNkb20gKGlnbm9yZWQpXG4gKiogbW9kdWxlIGlkID0gMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIChpZ25vcmVkKSAqL1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogY2FudmFzIChpZ25vcmVkKVxuICoqIG1vZHVsZSBpZCA9IDE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiAoaWdub3JlZCkgKi9cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIHhtbGRvbSAoaWdub3JlZClcbiAqKiBtb2R1bGUgaWQgPSAxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiBpc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIWlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnkgY29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgdGhlIHBhcnQgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhcyBub24gQVNDSUkgY2hhcmFjdGVycy4gSS5lLiBpdCBkb3NlbnQgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBpbiBBU0NJSS5cbiAgICAgIHZhciBkb21haW5BcnJheSA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgIHZhciBuZXdPdXQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9tYWluQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHMgPSBkb21haW5BcnJheVtpXTtcbiAgICAgICAgbmV3T3V0LnB1c2gocy5tYXRjaCgvW15BLVphLXowLTlfLV0vKSA/XG4gICAgICAgICAgICAneG4tLScgKyBwdW55Y29kZS5lbmNvZGUocykgOiBzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBuZXdPdXQuam9pbignLicpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAoaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKGlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICBPYmplY3Qua2V5cyh0aGlzKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICByZXN1bHRba10gPSB0aGlzW2tdO1xuICB9LCB0aGlzKTtcblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIE9iamVjdC5rZXlzKHJlbGF0aXZlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIGlmIChrICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICB9KTtcblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICBPYmplY3Qua2V5cyhyZWxhdGl2ZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfSk7XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCFpc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCFpc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0KSAmJiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8XG4gICAgICBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCFpc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiAgYXJnID09IG51bGw7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vdXJsL3VybC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjMuMiBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS4zLjInLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi91cmwvfi9wdW55Y29kZS9wdW55Y29kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi93ZWJwYWNrL2J1aWxkaW4vbW9kdWxlLmpzXG4gKiogbW9kdWxlIGlkID0gMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3F1ZXJ5c3RyaW5nL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9xdWVyeXN0cmluZy9kZWNvZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBvYmpba10ubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9xdWVyeXN0cmluZy9lbmNvZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGh0dHAgPSBtb2R1bGUuZXhwb3J0cztcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgUmVxdWVzdCA9IHJlcXVpcmUoJy4vbGliL3JlcXVlc3QnKTtcbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKVxuXG5odHRwLnJlcXVlc3QgPSBmdW5jdGlvbiAocGFyYW1zLCBjYikge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXJhbXMgPSB1cmwucGFyc2UocGFyYW1zKVxuICAgIH1cbiAgICBpZiAoIXBhcmFtcykgcGFyYW1zID0ge307XG4gICAgaWYgKCFwYXJhbXMuaG9zdCAmJiAhcGFyYW1zLnBvcnQpIHtcbiAgICAgICAgcGFyYW1zLnBvcnQgPSBwYXJzZUludCh3aW5kb3cubG9jYXRpb24ucG9ydCwgMTApO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcy5ob3N0ICYmIHBhcmFtcy5ob3N0bmFtZSkge1xuICAgICAgICBwYXJhbXMuaG9zdCA9IHBhcmFtcy5ob3N0bmFtZTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5wcm90b2NvbCkge1xuICAgICAgICBpZiAocGFyYW1zLnNjaGVtZSkge1xuICAgICAgICAgICAgcGFyYW1zLnByb3RvY29sID0gcGFyYW1zLnNjaGVtZSArICc6JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcy5wcm90b2NvbCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFyYW1zLmhvc3QpIHtcbiAgICAgICAgcGFyYW1zLmhvc3QgPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgfHwgd2luZG93LmxvY2F0aW9uLmhvc3Q7XG4gICAgfVxuICAgIGlmICgvOi8udGVzdChwYXJhbXMuaG9zdCkpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMucG9ydCkge1xuICAgICAgICAgICAgcGFyYW1zLnBvcnQgPSBwYXJhbXMuaG9zdC5zcGxpdCgnOicpWzFdO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5ob3N0ID0gcGFyYW1zLmhvc3Quc3BsaXQoJzonKVswXTtcbiAgICB9XG4gICAgaWYgKCFwYXJhbXMucG9ydCkgcGFyYW1zLnBvcnQgPSBwYXJhbXMucHJvdG9jb2wgPT0gJ2h0dHBzOicgPyA0NDMgOiA4MDtcbiAgICBcbiAgICB2YXIgcmVxID0gbmV3IFJlcXVlc3QobmV3IHhockh0dHAsIHBhcmFtcyk7XG4gICAgaWYgKGNiKSByZXEub24oJ3Jlc3BvbnNlJywgY2IpO1xuICAgIHJldHVybiByZXE7XG59O1xuXG5odHRwLmdldCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNiKSB7XG4gICAgcGFyYW1zLm1ldGhvZCA9ICdHRVQnO1xuICAgIHZhciByZXEgPSBodHRwLnJlcXVlc3QocGFyYW1zLCBjYik7XG4gICAgcmVxLmVuZCgpO1xuICAgIHJldHVybiByZXE7XG59O1xuXG5odHRwLkFnZW50ID0gZnVuY3Rpb24gKCkge307XG5odHRwLkFnZW50LmRlZmF1bHRNYXhTb2NrZXRzID0gNDtcblxudmFyIHhockh0dHAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHdpbmRvdyBvYmplY3QgcHJlc2VudCcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5YTUxIdHRwUmVxdWVzdDtcbiAgICB9XG4gICAgZWxzZSBpZiAod2luZG93LkFjdGl2ZVhPYmplY3QpIHtcbiAgICAgICAgdmFyIGF4cyA9IFtcbiAgICAgICAgICAgICdNc3htbDIuWE1MSFRUUC42LjAnLFxuICAgICAgICAgICAgJ01zeG1sMi5YTUxIVFRQLjMuMCcsXG4gICAgICAgICAgICAnTWljcm9zb2Z0LlhNTEhUVFAnXG4gICAgICAgIF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBheCA9IG5ldyh3aW5kb3cuQWN0aXZlWE9iamVjdCkoYXhzW2ldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBheF8gPSBheDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBheF87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHdpbmRvdy5BY3RpdmVYT2JqZWN0KShheHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYWpheCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FqYXggbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICB9XG59KSgpO1xuXG5odHRwLlNUQVRVU19DT0RFUyA9IHtcbiAgICAxMDAgOiAnQ29udGludWUnLFxuICAgIDEwMSA6ICdTd2l0Y2hpbmcgUHJvdG9jb2xzJyxcbiAgICAxMDIgOiAnUHJvY2Vzc2luZycsICAgICAgICAgICAgICAgICAvLyBSRkMgMjUxOCwgb2Jzb2xldGVkIGJ5IFJGQyA0OTE4XG4gICAgMjAwIDogJ09LJyxcbiAgICAyMDEgOiAnQ3JlYXRlZCcsXG4gICAgMjAyIDogJ0FjY2VwdGVkJyxcbiAgICAyMDMgOiAnTm9uLUF1dGhvcml0YXRpdmUgSW5mb3JtYXRpb24nLFxuICAgIDIwNCA6ICdObyBDb250ZW50JyxcbiAgICAyMDUgOiAnUmVzZXQgQ29udGVudCcsXG4gICAgMjA2IDogJ1BhcnRpYWwgQ29udGVudCcsXG4gICAgMjA3IDogJ011bHRpLVN0YXR1cycsICAgICAgICAgICAgICAgLy8gUkZDIDQ5MThcbiAgICAzMDAgOiAnTXVsdGlwbGUgQ2hvaWNlcycsXG4gICAgMzAxIDogJ01vdmVkIFBlcm1hbmVudGx5JyxcbiAgICAzMDIgOiAnTW92ZWQgVGVtcG9yYXJpbHknLFxuICAgIDMwMyA6ICdTZWUgT3RoZXInLFxuICAgIDMwNCA6ICdOb3QgTW9kaWZpZWQnLFxuICAgIDMwNSA6ICdVc2UgUHJveHknLFxuICAgIDMwNyA6ICdUZW1wb3JhcnkgUmVkaXJlY3QnLFxuICAgIDQwMCA6ICdCYWQgUmVxdWVzdCcsXG4gICAgNDAxIDogJ1VuYXV0aG9yaXplZCcsXG4gICAgNDAyIDogJ1BheW1lbnQgUmVxdWlyZWQnLFxuICAgIDQwMyA6ICdGb3JiaWRkZW4nLFxuICAgIDQwNCA6ICdOb3QgRm91bmQnLFxuICAgIDQwNSA6ICdNZXRob2QgTm90IEFsbG93ZWQnLFxuICAgIDQwNiA6ICdOb3QgQWNjZXB0YWJsZScsXG4gICAgNDA3IDogJ1Byb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkJyxcbiAgICA0MDggOiAnUmVxdWVzdCBUaW1lLW91dCcsXG4gICAgNDA5IDogJ0NvbmZsaWN0JyxcbiAgICA0MTAgOiAnR29uZScsXG4gICAgNDExIDogJ0xlbmd0aCBSZXF1aXJlZCcsXG4gICAgNDEyIDogJ1ByZWNvbmRpdGlvbiBGYWlsZWQnLFxuICAgIDQxMyA6ICdSZXF1ZXN0IEVudGl0eSBUb28gTGFyZ2UnLFxuICAgIDQxNCA6ICdSZXF1ZXN0LVVSSSBUb28gTGFyZ2UnLFxuICAgIDQxNSA6ICdVbnN1cHBvcnRlZCBNZWRpYSBUeXBlJyxcbiAgICA0MTYgOiAnUmVxdWVzdGVkIFJhbmdlIE5vdCBTYXRpc2ZpYWJsZScsXG4gICAgNDE3IDogJ0V4cGVjdGF0aW9uIEZhaWxlZCcsXG4gICAgNDE4IDogJ0lcXCdtIGEgdGVhcG90JywgICAgICAgICAgICAgIC8vIFJGQyAyMzI0XG4gICAgNDIyIDogJ1VucHJvY2Vzc2FibGUgRW50aXR5JywgICAgICAgLy8gUkZDIDQ5MThcbiAgICA0MjMgOiAnTG9ja2VkJywgICAgICAgICAgICAgICAgICAgICAvLyBSRkMgNDkxOFxuICAgIDQyNCA6ICdGYWlsZWQgRGVwZW5kZW5jeScsICAgICAgICAgIC8vIFJGQyA0OTE4XG4gICAgNDI1IDogJ1Vub3JkZXJlZCBDb2xsZWN0aW9uJywgICAgICAgLy8gUkZDIDQ5MThcbiAgICA0MjYgOiAnVXBncmFkZSBSZXF1aXJlZCcsICAgICAgICAgICAvLyBSRkMgMjgxN1xuICAgIDQyOCA6ICdQcmVjb25kaXRpb24gUmVxdWlyZWQnLCAgICAgIC8vIFJGQyA2NTg1XG4gICAgNDI5IDogJ1RvbyBNYW55IFJlcXVlc3RzJywgICAgICAgICAgLy8gUkZDIDY1ODVcbiAgICA0MzEgOiAnUmVxdWVzdCBIZWFkZXIgRmllbGRzIFRvbyBMYXJnZScsLy8gUkZDIDY1ODVcbiAgICA1MDAgOiAnSW50ZXJuYWwgU2VydmVyIEVycm9yJyxcbiAgICA1MDEgOiAnTm90IEltcGxlbWVudGVkJyxcbiAgICA1MDIgOiAnQmFkIEdhdGV3YXknLFxuICAgIDUwMyA6ICdTZXJ2aWNlIFVuYXZhaWxhYmxlJyxcbiAgICA1MDQgOiAnR2F0ZXdheSBUaW1lLW91dCcsXG4gICAgNTA1IDogJ0hUVFAgVmVyc2lvbiBOb3QgU3VwcG9ydGVkJyxcbiAgICA1MDYgOiAnVmFyaWFudCBBbHNvIE5lZ290aWF0ZXMnLCAgICAvLyBSRkMgMjI5NVxuICAgIDUwNyA6ICdJbnN1ZmZpY2llbnQgU3RvcmFnZScsICAgICAgIC8vIFJGQyA0OTE4XG4gICAgNTA5IDogJ0JhbmR3aWR0aCBMaW1pdCBFeGNlZWRlZCcsXG4gICAgNTEwIDogJ05vdCBFeHRlbmRlZCcsICAgICAgICAgICAgICAgLy8gUkZDIDI3NzRcbiAgICA1MTEgOiAnTmV0d29yayBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZCcgLy8gUkZDIDY1ODVcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2h0dHAtYnJvd3NlcmlmeS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vZXZlbnRzL2V2ZW50cy5qc1xuICoqIG1vZHVsZSBpZCA9IDIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG52YXIgUmVzcG9uc2UgPSByZXF1aXJlKCcuL3Jlc3BvbnNlJyk7XG52YXIgQmFzZTY0ID0gcmVxdWlyZSgnQmFzZTY0Jyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG52YXIgUmVxdWVzdCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHhociwgcGFyYW1zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgIHNlbGYueGhyID0geGhyO1xuICAgIHNlbGYuYm9keSA9IFtdO1xuICAgIFxuICAgIHNlbGYudXJpID0gKHBhcmFtcy5wcm90b2NvbCB8fCAnaHR0cDonKSArICcvLydcbiAgICAgICAgKyBwYXJhbXMuaG9zdFxuICAgICAgICArIChwYXJhbXMucG9ydCA/ICc6JyArIHBhcmFtcy5wb3J0IDogJycpXG4gICAgICAgICsgKHBhcmFtcy5wYXRoIHx8ICcvJylcbiAgICA7XG4gICAgXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMud2l0aENyZWRlbnRpYWxzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwYXJhbXMud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0cnkgeyB4aHIud2l0aENyZWRlbnRpYWxzID0gcGFyYW1zLndpdGhDcmVkZW50aWFscyB9XG4gICAgY2F0Y2ggKGUpIHt9XG4gICAgXG4gICAgaWYgKHBhcmFtcy5yZXNwb25zZVR5cGUpIHRyeSB7IHhoci5yZXNwb25zZVR5cGUgPSBwYXJhbXMucmVzcG9uc2VUeXBlIH1cbiAgICBjYXRjaCAoZSkge31cbiAgICBcbiAgICB4aHIub3BlbihcbiAgICAgICAgcGFyYW1zLm1ldGhvZCB8fCAnR0VUJyxcbiAgICAgICAgc2VsZi51cmksXG4gICAgICAgIHRydWVcbiAgICApO1xuXG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdOZXR3b3JrIGVycm9yJykpO1xuICAgIH07XG5cbiAgICBzZWxmLl9oZWFkZXJzID0ge307XG4gICAgXG4gICAgaWYgKHBhcmFtcy5oZWFkZXJzKSB7XG4gICAgICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhwYXJhbXMuaGVhZGVycyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoIXNlbGYuaXNTYWZlUmVxdWVzdEhlYWRlcihrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcmFtcy5oZWFkZXJzW2tleV07XG4gICAgICAgICAgICBzZWxmLnNldEhlYWRlcihrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAocGFyYW1zLmF1dGgpIHtcbiAgICAgICAgLy9iYXNpYyBhdXRoXG4gICAgICAgIHRoaXMuc2V0SGVhZGVyKCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBCYXNlNjQuYnRvYShwYXJhbXMuYXV0aCkpO1xuICAgIH1cblxuICAgIHZhciByZXMgPSBuZXcgUmVzcG9uc2U7XG4gICAgcmVzLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScpO1xuICAgIH0pO1xuICAgIFxuICAgIHJlcy5vbigncmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZW1pdCgncmVzcG9uc2UnLCByZXMpO1xuICAgIH0pO1xuXG4gICAgcmVzLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfSk7XG4gICAgXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRml4IGZvciBJRTkgYnVnXG4gICAgICAgIC8vIFNDUklQVDU3NTogQ291bGQgbm90IGNvbXBsZXRlIHRoZSBvcGVyYXRpb24gZHVlIHRvIGVycm9yIGMwMGMwMjNmXG4gICAgICAgIC8vIEl0IGhhcHBlbnMgd2hlbiBhIHJlcXVlc3QgaXMgYWJvcnRlZCwgY2FsbGluZyB0aGUgc3VjY2VzcyBjYWxsYmFjayBhbnl3YXkgd2l0aCByZWFkeVN0YXRlID09PSA0XG4gICAgICAgIGlmICh4aHIuX19hYm9ydGVkKSByZXR1cm47XG4gICAgICAgIHJlcy5oYW5kbGUoeGhyKTtcbiAgICB9O1xufTtcblxuaW5oZXJpdHMoUmVxdWVzdCwgU3RyZWFtKTtcblxuUmVxdWVzdC5wcm90b3R5cGUuc2V0SGVhZGVyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl9oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlXG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5nZXRIZWFkZXIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldXG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5yZW1vdmVIZWFkZXIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgZGVsZXRlIHRoaXMuX2hlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldXG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgdGhpcy5ib2R5LnB1c2gocyk7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKHMpIHtcbiAgICB0aGlzLnhoci5fX2Fib3J0ZWQgPSB0cnVlO1xuICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScpO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKHMpIHtcbiAgICBpZiAocyAhPT0gdW5kZWZpbmVkKSB0aGlzLmJvZHkucHVzaChzKTtcblxuICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyh0aGlzLl9oZWFkZXJzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2hlYWRlcnNba2V5XTtcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy54aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbHVlW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ib2R5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnhoci5zZW5kKCcnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuYm9keVswXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy54aHIuc2VuZCh0aGlzLmJvZHkuam9pbignJykpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FycmF5KHRoaXMuYm9keVswXSkpIHtcbiAgICAgICAgdmFyIGJvZHkgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJvZHkucHVzaC5hcHBseShib2R5LCB0aGlzLmJvZHlbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueGhyLnNlbmQoYm9keSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKC9BcnJheS8udGVzdChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpcy5ib2R5WzBdKSkpIHtcbiAgICAgICAgdmFyIGxlbiA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZW4gKz0gdGhpcy5ib2R5W2ldLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYm9keSA9IG5ldyh0aGlzLmJvZHlbMF0uY29uc3RydWN0b3IpKGxlbik7XG4gICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuYm9keVtpXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGJvZHlbaysrXSA9IGJbal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54aHIuc2VuZChib2R5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNYSFIyQ29tcGF0aWJsZSh0aGlzLmJvZHlbMF0pKSB7XG4gICAgICAgIHRoaXMueGhyLnNlbmQodGhpcy5ib2R5WzBdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBib2R5ID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBib2R5ICs9IHRoaXMuYm9keVtpXS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueGhyLnNlbmQoYm9keSk7XG4gICAgfVxufTtcblxuLy8gVGFrZW4gZnJvbSBodHRwOi8vZHhyLm1vemlsbGEub3JnL21vemlsbGEvbW96aWxsYS1jZW50cmFsL2NvbnRlbnQvYmFzZS9zcmMvbnNYTUxIdHRwUmVxdWVzdC5jcHAuaHRtbFxuUmVxdWVzdC51bnNhZmVIZWFkZXJzID0gW1xuICAgIFwiYWNjZXB0LWNoYXJzZXRcIixcbiAgICBcImFjY2VwdC1lbmNvZGluZ1wiLFxuICAgIFwiYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1oZWFkZXJzXCIsXG4gICAgXCJhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LW1ldGhvZFwiLFxuICAgIFwiY29ubmVjdGlvblwiLFxuICAgIFwiY29udGVudC1sZW5ndGhcIixcbiAgICBcImNvb2tpZVwiLFxuICAgIFwiY29va2llMlwiLFxuICAgIFwiY29udGVudC10cmFuc2Zlci1lbmNvZGluZ1wiLFxuICAgIFwiZGF0ZVwiLFxuICAgIFwiZXhwZWN0XCIsXG4gICAgXCJob3N0XCIsXG4gICAgXCJrZWVwLWFsaXZlXCIsXG4gICAgXCJvcmlnaW5cIixcbiAgICBcInJlZmVyZXJcIixcbiAgICBcInRlXCIsXG4gICAgXCJ0cmFpbGVyXCIsXG4gICAgXCJ0cmFuc2Zlci1lbmNvZGluZ1wiLFxuICAgIFwidXBncmFkZVwiLFxuICAgIFwidXNlci1hZ2VudFwiLFxuICAgIFwidmlhXCJcbl07XG5cblJlcXVlc3QucHJvdG90eXBlLmlzU2FmZVJlcXVlc3RIZWFkZXIgPSBmdW5jdGlvbiAoaGVhZGVyTmFtZSkge1xuICAgIGlmICghaGVhZGVyTmFtZSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBpbmRleE9mKFJlcXVlc3QudW5zYWZlSGVhZGVycywgaGVhZGVyTmFtZS50b0xvd2VyQ2FzZSgpKSA9PT0gLTE7XG59O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICAgIHJldHVybiBrZXlzO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudmFyIGluZGV4T2YgPSBmdW5jdGlvbiAoeHMsIHgpIHtcbiAgICBpZiAoeHMuaW5kZXhPZikgcmV0dXJuIHhzLmluZGV4T2YoeCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xuXG52YXIgaXNYSFIyQ29tcGF0aWJsZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHJldHVybiB0cnVlO1xuICAgIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyAmJiBvYmogaW5zdGFuY2VvZiBGb3JtRGF0YSkgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2h0dHAtYnJvd3NlcmlmeS9saWIvcmVxdWVzdC5qc1xuICoqIG1vZHVsZSBpZCA9IDI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuaWYgKCFwcm9jZXNzLmJyb3dzZXIgJiYgcHJvY2Vzcy5lbnYuUkVBREFCTEVfU1RSRUFNID09PSAnZGlzYWJsZScpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdzdHJlYW0nKTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9zdHJlYW0tYnJvd3NlcmlmeS9+L3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbmlmICghRUUubGlzdGVuZXJDb3VudCkgRUUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJpbmdEZWNvZGVyO1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWcgPSByZXF1aXJlKCd1dGlsJyk7XG5pZiAoZGVidWcgJiYgZGVidWcuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Zy5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gb3B0aW9ucy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IChod20gfHwgaHdtID09PSAwKSA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuXG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleClcbiAgICB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXG4gIHRoaXMucmFuT3V0ID0gZmFsc2U7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSlcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKHV0aWwuaXNTdHJpbmcoY2h1bmspICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICBlbmNvZGluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgJycsIHRydWUpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcbiAgdmFyIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIGlmICh1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKVxuICAgICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoc3RhdGUuZW5kZWQgJiYgIWFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRFbWl0dGVkICYmIGFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFhZGRUb0Zyb250ICYmICFlbmNvZGluZylcbiAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgICAgaWYgKCFhZGRUb0Zyb250KVxuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgIC8vIGlmIHdlIHdhbnQgdGhlIGRhdGEgbm93LCBqdXN0IGVtaXQgaXQuXG4gICAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgIHN0cmVhbS5yZWFkKDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgICBpZiAoYWRkVG9Gcm9udClcbiAgICAgICAgICBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSlcbiAgICAgICAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgICAgIH1cblxuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuXG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmXG4gICAgICAgICAoc3RhdGUubmVlZFJlYWRhYmxlIHx8XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24oZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMTI4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiByb3VuZFVwVG9OZXh0UG93ZXJPZjIobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMlxuICAgIG4tLTtcbiAgICBmb3IgKHZhciBwID0gMTsgcCA8IDMyOyBwIDw8PSAxKSBuIHw9IG4gPj4gcDtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZClcbiAgICByZXR1cm4gMDtcblxuICBpZiAoc3RhdGUub2JqZWN0TW9kZSlcbiAgICByZXR1cm4gbiA9PT0gMCA/IDAgOiAxO1xuXG4gIGlmIChpc05hTihuKSB8fCB1dGlsLmlzTnVsbChuKSkge1xuICAgIC8vIG9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICByZXR1cm4gc3RhdGUuYnVmZmVyWzBdLmxlbmd0aDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgaWYgKG4gPD0gMClcbiAgICByZXR1cm4gMDtcblxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgdGFyZ2V0IGJ1ZmZlciBsZXZlbCxcbiAgLy8gdGhlbiByYWlzZSB0aGUgd2F0ZXIgbWFyay4gIEJ1bXAgdXAgdG8gdGhlIG5leHQgaGlnaGVzdFxuICAvLyBwb3dlciBvZiAyLCB0byBwcmV2ZW50IGluY3JlYXNpbmcgaXQgZXhjZXNzaXZlbHkgaW4gdGlueVxuICAvLyBhbW91bnRzLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspXG4gICAgc3RhdGUuaGlnaFdhdGVyTWFyayA9IHJvdW5kVXBUb05leHRQb3dlck9mMihuKTtcblxuICAvLyBkb24ndCBoYXZlIHRoYXQgbXVjaC4gIHJldHVybiBudWxsLCB1bmxlc3Mgd2UndmUgZW5kZWQuXG4gIGlmIChuID4gc3RhdGUubGVuZ3RoKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBuO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKCF1dGlsLmlzTnVtYmVyKG4pIHx8IG4gPiAwKVxuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiZcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSAmJlxuICAgICAgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKVxuICAgICAgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgZWxzZVxuICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxuICAgICAgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfVxuXG4gIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICBpZiAoZG9SZWFkICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKVxuICAgIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtcbiAgZWxzZVxuICAgIHJldCA9IG51bGw7XG5cbiAgaWYgKHV0aWwuaXNOdWxsKHJldCkpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9XG5cbiAgc3RhdGUubGVuZ3RoIC09IG47XG5cbiAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuZW5kZWQpXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgZW5kUmVhZGFibGUodGhpcyk7XG5cbiAgaWYgKCF1dGlsLmlzTnVsbChyZXQpKVxuICAgIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyID0gbnVsbDtcbiAgaWYgKCF1dGlsLmlzQnVmZmVyKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNTdHJpbmcoY2h1bmspICYmXG4gICAgICAhdXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykgJiZcbiAgICAgICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYylcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztcbiAgICBlbHNlXG4gICAgICBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpXG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbmRGbik7XG4gIGVsc2VcbiAgICBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmXG4gICAgICAgICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpXG4gICAgICBvbmRyYWluKCk7XG4gIH1cblxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0KSB7XG4gICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJyxcbiAgICAgICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMClcbiAgICAgIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cbiAgLy8gVGhpcyBpcyBhIGJydXRhbGx5IHVnbHkgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlclxuICAvLyBpcyBhdHRhY2hlZCBiZWZvcmUgYW55IHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLlxuICBpZiAoIWRlc3QuX2V2ZW50cyB8fCAhZGVzdC5fZXZlbnRzLmVycm9yKVxuICAgIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGVsc2UgaWYgKGlzQXJyYXkoZGVzdC5fZXZlbnRzLmVycm9yKSlcbiAgICBkZXN0Ll9ldmVudHMuZXJyb3IudW5zaGlmdChvbmVycm9yKTtcbiAgZWxzZVxuICAgIGRlc3QuX2V2ZW50cy5lcnJvciA9IFtvbmVycm9yLCBkZXN0Ll9ldmVudHMuZXJyb3JdO1xuXG5cblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pXG4gICAgICBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUUubGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24oZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpXG4gICAgICBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KVxuICAgICAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpLCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICAvLyBJZiBsaXN0ZW5pbmcgdG8gZGF0YSwgYW5kIGl0IGhhcyBub3QgZXhwbGljaXRseSBiZWVuIHBhdXNlZCxcbiAgLy8gdGhlbiBjYWxsIHJlc3VtZSB0byBzdGFydCB0aGUgZmxvdyBvZiBkYXRhIG9uIHRoZSBuZXh0IHRpY2suXG4gIGlmIChldiA9PT0gJ2RhdGEnICYmIGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICB0aGlzLnJlc3VtZSgpO1xuICB9XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnICYmIHRoaXMucmVhZGFibGUpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICAgICAgICAgIHNlbGYucmVhZCgwKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgICB0aGlzLnJlYWQoMCk7XG4gICAgfVxuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpXG4gICAgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIGlmIChzdGF0ZS5mbG93aW5nKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIGNodW5rID0gc3RyZWFtLnJlYWQoKTtcbiAgICB9IHdoaWxlIChudWxsICE9PSBjaHVuayAmJiBzdGF0ZS5mbG93aW5nKTtcbiAgfVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpXG4gICAgICAgIHNlbGYucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgc2VsZi5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcilcbiAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgaWYgKCFjaHVuayB8fCAhc3RhdGUub2JqZWN0TW9kZSAmJiAhY2h1bmsubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHV0aWwuaXNGdW5jdGlvbihzdHJlYW1baV0pICYmIHV0aWwuaXNVbmRlZmluZWQodGhpc1tpXSkpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbihtZXRob2QpIHsgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgfX0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICB2YXIgZXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24oZXYpIHtcbiAgICBzdHJlYW0ub24oZXYsIHNlbGYuZW1pdC5iaW5kKHNlbGYsIGV2KSk7XG4gIH0pO1xuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5cblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICB2YXIgbGlzdCA9IHN0YXRlLmJ1ZmZlcjtcbiAgdmFyIGxlbmd0aCA9IHN0YXRlLmxlbmd0aDtcbiAgdmFyIHN0cmluZ01vZGUgPSAhIXN0YXRlLmRlY29kZXI7XG4gIHZhciBvYmplY3RNb2RlID0gISFzdGF0ZS5vYmplY3RNb2RlO1xuICB2YXIgcmV0O1xuXG4gIC8vIG5vdGhpbmcgaW4gdGhlIGxpc3QsIGRlZmluaXRlbHkgZW1wdHkuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAobGVuZ3RoID09PSAwKVxuICAgIHJldCA9IG51bGw7XG4gIGVsc2UgaWYgKG9iamVjdE1vZGUpXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICBlbHNlIGlmICghbiB8fCBuID49IGxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgYXJyYXkuXG4gICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICByZXQgPSBsaXN0LmpvaW4oJycpO1xuICAgIGVsc2VcbiAgICAgIHJldCA9IEJ1ZmZlci5jb25jYXQobGlzdCwgbGVuZ3RoKTtcbiAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBqdXN0IHNvbWUgb2YgaXQuXG4gICAgaWYgKG4gPCBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8ganVzdCB0YWtlIGEgcGFydCBvZiB0aGUgZmlyc3QgbGlzdCBpdGVtLlxuICAgICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgIHJldCA9IGJ1Zi5zbGljZSgwLCBuKTtcbiAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgfSBlbHNlIGlmIChuID09PSBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8gZmlyc3QgbGlzdCBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29tcGxleCBjYXNlLlxuICAgICAgLy8gd2UgaGF2ZSBlbm91Z2ggdG8gY292ZXIgaXQsIGJ1dCBpdCBzcGFucyBwYXN0IHRoZSBmaXJzdCBidWZmZXIuXG4gICAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgICAgcmV0ID0gJyc7XG4gICAgICBlbHNlXG4gICAgICAgIHJldCA9IG5ldyBCdWZmZXIobik7XG5cbiAgICAgIHZhciBjID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsICYmIGMgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICAgIHZhciBjcHkgPSBNYXRoLm1pbihuIC0gYywgYnVmLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgICAgcmV0ICs9IGJ1Zi5zbGljZSgwLCBjcHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYnVmLmNvcHkocmV0LCBjLCAwLCBjcHkpO1xuXG4gICAgICAgIGlmIChjcHkgPCBidWYubGVuZ3RoKVxuICAgICAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2UoY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcblxuICAgICAgICBjICs9IGNweTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZFJlYWRhYmxlIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mICh4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3N0cmVhbS1icm93c2VyaWZ5L34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9zdHJlYW0tYnJvd3NlcmlmeS9+L2lzYXJyYXkvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qc1xuICoqIG1vZHVsZSBpZCA9IDMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiAoaWdub3JlZCkgKi9cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIHV0aWwgKGlnbm9yZWQpXG4gKiogbW9kdWxlIGlkID0gMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleXM7XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbmZvckVhY2gob2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pXG4gICAgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG59KTtcblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSlcbiAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpXG4gICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHByb2Nlc3MubmV4dFRpY2sodGhpcy5lbmQuYmluZCh0aGlzKSk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9zdHJlYW0tYnJvd3NlcmlmeS9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanNcbiAqKiBtb2R1bGUgaWQgPSAzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IG9wdGlvbnMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpXG4gICAgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbihlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdGhvdWdoIHRoZXkncmUgbm90XG4gIC8vIGluc3RhbmNlb2YgV3JpdGFibGUsIHRoZXkncmUgaW5zdGFuY2VvZiBSZWFkYWJsZS5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdyaXRhYmxlKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLiBOb3QgcmVhZGFibGUuJykpO1xufTtcblxuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBjYihlcik7XG4gIH0pO1xufVxuXG4vLyBJZiB3ZSBnZXQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCxcbi8vIGFuZCB3ZSdyZSBub3QgaW4gb2JqZWN0TW9kZSwgdGhlbiB0aGF0J3MgYW4gZXJyb3IuXG4vLyBPdGhlcndpc2Ugc3RyZWFtIGNodW5rcyBhcmUgYWxsIGNvbnNpZGVyZWQgdG8gYmUgb2YgbGVuZ3RoPTEsIGFuZCB0aGVcbi8vIHdhdGVybWFya3MgZGV0ZXJtaW5lIGhvdyBtYW55IG9iamVjdHMgdG8ga2VlcCBpbiB0aGUgYnVmZmVyLCByYXRoZXIgdGhhblxuLy8gaG93IG1hbnkgYnl0ZXMgb3IgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIGlmICghdXRpbC5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzU3RyaW5nKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIHZhciBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGNiKGVyKTtcbiAgICB9KTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbihlbmNvZGluZykpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmICh1dGlsLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICBlbHNlIGlmICghZW5jb2RpbmcpXG4gICAgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKCF1dGlsLmlzRnVuY3Rpb24oY2IpKVxuICAgIGNiID0gZnVuY3Rpb24oKSB7fTtcblxuICBpZiAoc3RhdGUuZW5kZWQpXG4gICAgd3JpdGVBZnRlckVuZCh0aGlzLCBzdGF0ZSwgY2IpO1xuICBlbHNlIGlmICh2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiZcbiAgICAgICAgIXN0YXRlLmNvcmtlZCAmJlxuICAgICAgICAhc3RhdGUuZmluaXNoZWQgJiZcbiAgICAgICAgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiZcbiAgICAgICAgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiZcbiAgICAgIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmXG4gICAgICB1dGlsLmlzU3RyaW5nKGNodW5rKSkge1xuICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICBpZiAodXRpbC5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldClcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZClcbiAgICBzdGF0ZS5idWZmZXIucHVzaChuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikpO1xuICBlbHNlXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldilcbiAgICBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7XG4gIGVsc2VcbiAgICBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICBpZiAoc3luYylcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gIGVsc2Uge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVyKTtcbiAgfVxuXG4gIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKVxuICAgIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO1xuICBlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmXG4gICAgICAgICFzdGF0ZS5jb3JrZWQgJiZcbiAgICAgICAgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiZcbiAgICAgICAgc3RhdGUuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpXG4gICAgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoID4gMSkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgY2JzID0gW107XG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoOyBjKyspXG4gICAgICBjYnMucHVzaChzdGF0ZS5idWZmZXJbY10uY2FsbGJhY2spO1xuXG4gICAgLy8gY291bnQgdGhlIG9uZSB3ZSBhcmUgYWRkaW5nLCBhcyB3ZWxsLlxuICAgIC8vIFRPRE8oaXNhYWNzKSBjbGVhbiB0aGlzIHVwXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmJ1ZmZlciwgJycsIGZ1bmN0aW9uKGVycikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICAgIGNic1tpXShlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2xlYXIgYnVmZmVyXG4gICAgc3RhdGUuYnVmZmVyID0gW107XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aDsgYysrKSB7XG4gICAgICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJbY107XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBjKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIHN0YXRlLmJ1ZmZlciA9IHN0YXRlLmJ1ZmZlci5zbGljZShjKTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZS5idWZmZXIubGVuZ3RoID0gMDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG5cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKGNodW5rKSkge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh1dGlsLmlzRnVuY3Rpb24oZW5jb2RpbmcpKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspKVxuICAgIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpXG4gICAgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIHJldHVybiAoc3RhdGUuZW5kaW5nICYmXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICAgIXN0YXRlLndyaXRpbmcpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkKSB7XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfSBlbHNlXG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKTtcbiAgICBlbHNlXG4gICAgICBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9zdHJlYW0tYnJvd3NlcmlmeS9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIGlzQnVmZmVyRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZ1xuICB8fCBmdW5jdGlvbihlbmNvZGluZykge1xuICAgICAgIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgY2FzZSAnaGV4JzogY2FzZSAndXRmOCc6IGNhc2UgJ3V0Zi04JzogY2FzZSAnYXNjaWknOiBjYXNlICdiaW5hcnknOiBjYXNlICdiYXNlNjQnOiBjYXNlICd1Y3MyJzogY2FzZSAndWNzLTInOiBjYXNlICd1dGYxNmxlJzogY2FzZSAndXRmLTE2bGUnOiBjYXNlICdyYXcnOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICAgIH1cblxuXG5mdW5jdGlvbiBhc3NlcnRFbmNvZGluZyhlbmNvZGluZykge1xuICBpZiAoZW5jb2RpbmcgJiYgIWlzQnVmZmVyRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB9XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy4gQ0VTVS04IGlzIGhhbmRsZWQgYXMgcGFydCBvZiB0aGUgVVRGLTggZW5jb2RpbmcuXG4vL1xuLy8gQFRPRE8gSGFuZGxpbmcgYWxsIGVuY29kaW5ncyBpbnNpZGUgYSBzaW5nbGUgb2JqZWN0IG1ha2VzIGl0IHZlcnkgZGlmZmljdWx0XG4vLyB0byByZWFzb24gYWJvdXQgdGhpcyBjb2RlLCBzbyBpdCBzaG91bGQgYmUgc3BsaXQgdXAgaW4gdGhlIGZ1dHVyZS5cbi8vIEBUT0RPIFRoZXJlIHNob3VsZCBiZSBhIHV0Zjgtc3RyaWN0IGVuY29kaW5nIHRoYXQgcmVqZWN0cyBpbnZhbGlkIFVURi04IGNvZGVcbi8vIHBvaW50cyBhcyB1c2VkIGJ5IENFU1UtOC5cbnZhciBTdHJpbmdEZWNvZGVyID0gZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IChlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWy1fXS8sICcnKTtcbiAgYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIC8vIENFU1UtOCByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMy1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgLy8gVVRGLTE2IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAyLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAyO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgLy8gQmFzZS02NCBzdG9yZXMgMyBieXRlcyBpbiA0IGNoYXJzLCBhbmQgcGFkcyB0aGUgcmVtYWluZGVyLlxuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gcGFzc1Rocm91Z2hXcml0ZTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEVub3VnaCBzcGFjZSB0byBzdG9yZSBhbGwgYnl0ZXMgb2YgYSBzaW5nbGUgY2hhcmFjdGVyLiBVVEYtOCBuZWVkcyA0XG4gIC8vIGJ5dGVzLCBidXQgQ0VTVS04IG1heSByZXF1aXJlIHVwIHRvIDYgKDMgYnl0ZXMgcGVyIHN1cnJvZ2F0ZSkuXG4gIHRoaXMuY2hhckJ1ZmZlciA9IG5ldyBCdWZmZXIoNik7XG4gIC8vIE51bWJlciBvZiBieXRlcyByZWNlaXZlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSAwO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhckxlbmd0aCA9IDA7XG59O1xuXG5cbi8vIHdyaXRlIGRlY29kZXMgdGhlIGdpdmVuIGJ1ZmZlciBhbmQgcmV0dXJucyBpdCBhcyBKUyBzdHJpbmcgdGhhdCBpc1xuLy8gZ3VhcmFudGVlZCB0byBub3QgY29udGFpbiBhbnkgcGFydGlhbCBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuIEFueSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGlzIGJ1ZmZlcmVkIHVwLCBhbmQgd2lsbCBiZVxuLy8gcmV0dXJuZWQgd2hlbiBjYWxsaW5nIHdyaXRlIGFnYWluIHdpdGggdGhlIHJlbWFpbmluZyBieXRlcy5cbi8vXG4vLyBOb3RlOiBDb252ZXJ0aW5nIGEgQnVmZmVyIGNvbnRhaW5pbmcgYW4gb3JwaGFuIHN1cnJvZ2F0ZSB0byBhIFN0cmluZ1xuLy8gY3VycmVudGx5IHdvcmtzLCBidXQgY29udmVydGluZyBhIFN0cmluZyB0byBhIEJ1ZmZlciAodmlhIGBuZXcgQnVmZmVyYCwgb3Jcbi8vIEJ1ZmZlciN3cml0ZSkgd2lsbCByZXBsYWNlIGluY29tcGxldGUgc3Vycm9nYXRlcyB3aXRoIHRoZSB1bmljb2RlXG4vLyByZXBsYWNlbWVudCBjaGFyYWN0ZXIuIFNlZSBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzEyMTE3MzAwOS8gLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIGNoYXJTdHIgPSAnJztcbiAgLy8gaWYgb3VyIGxhc3Qgd3JpdGUgZW5kZWQgd2l0aCBhbiBpbmNvbXBsZXRlIG11bHRpYnl0ZSBjaGFyYWN0ZXJcbiAgd2hpbGUgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGRldGVybWluZSBob3cgbWFueSByZW1haW5pbmcgYnl0ZXMgdGhpcyBidWZmZXIgaGFzIHRvIG9mZmVyIGZvciB0aGlzIGNoYXJcbiAgICB2YXIgYXZhaWxhYmxlID0gKGJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQpID9cbiAgICAgICAgdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQgOlxuICAgICAgICBidWZmZXIubGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoZSBuZXcgYnl0ZXMgdG8gdGhlIGNoYXIgYnVmZmVyXG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCB0aGlzLmNoYXJSZWNlaXZlZCwgMCwgYXZhaWxhYmxlKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBhdmFpbGFibGU7XG5cbiAgICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQgPCB0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAgIC8vIHN0aWxsIG5vdCBlbm91Z2ggY2hhcnMgaW4gdGhpcyBidWZmZXI/IHdhaXQgZm9yIG1vcmUgLi4uXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGJ5dGVzIGJlbG9uZ2luZyB0byB0aGUgY3VycmVudCBjaGFyYWN0ZXIgZnJvbSB0aGUgYnVmZmVyXG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGF2YWlsYWJsZSwgYnVmZmVyLmxlbmd0aCk7XG5cbiAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyBzcGxpdFxuICAgIGNoYXJTdHIgPSB0aGlzLmNoYXJCdWZmZXIuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoY2hhclN0ci5sZW5ndGggLSAxKTtcbiAgICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoICs9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICAgIGNoYXJTdHIgPSAnJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IHRoaXMuY2hhckxlbmd0aCA9IDA7XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBieXRlcyBpbiB0aGlzIGJ1ZmZlciwganVzdCBlbWl0IG91ciBjaGFyXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjaGFyU3RyO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGRldGVybWluZSBhbmQgc2V0IGNoYXJMZW5ndGggLyBjaGFyUmVjZWl2ZWRcbiAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpO1xuXG4gIHZhciBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICBpZiAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gYnVmZmVyIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlciBieXRlcyB3ZSBnb3RcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCwgZW5kKTtcbiAgICBlbmQgLT0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gIH1cblxuICBjaGFyU3RyICs9IGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBlbmQpO1xuXG4gIHZhciBlbmQgPSBjaGFyU3RyLmxlbmd0aCAtIDE7XG4gIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChlbmQpO1xuICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgdGhpcy5jaGFyTGVuZ3RoICs9IHNpemU7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJCdWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHNpemUsIDAsIHNpemUpO1xuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgMCwgc2l6ZSk7XG4gICAgcmV0dXJuIGNoYXJTdHIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gIH1cblxuICAvLyBvciBqdXN0IGVtaXQgdGhlIGNoYXJTdHJcbiAgcmV0dXJuIGNoYXJTdHI7XG59O1xuXG4vLyBkZXRlY3RJbmNvbXBsZXRlQ2hhciBkZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGFuIGluY29tcGxldGUgVVRGLTggY2hhcmFjdGVyIGF0XG4vLyB0aGUgZW5kIG9mIHRoZSBnaXZlbiBidWZmZXIuIElmIHNvLCBpdCBzZXRzIHRoaXMuY2hhckxlbmd0aCB0byB0aGUgYnl0ZVxuLy8gbGVuZ3RoIHRoYXQgY2hhcmFjdGVyLCBhbmQgc2V0cyB0aGlzLmNoYXJSZWNlaXZlZCB0byB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4vLyB0aGF0IGFyZSBhdmFpbGFibGUgZm9yIHRoaXMgY2hhcmFjdGVyLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IGJ5dGVzIHdlIGhhdmUgdG8gY2hlY2sgYXQgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlclxuICB2YXIgaSA9IChidWZmZXIubGVuZ3RoID49IDMpID8gMyA6IGJ1ZmZlci5sZW5ndGg7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBvbmUgb2YgdGhlIGxhc3QgaSBieXRlcyBvZiBvdXIgYnVmZmVyIGFubm91bmNlcyBhblxuICAvLyBpbmNvbXBsZXRlIGNoYXIuXG4gIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIGMgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIGldO1xuXG4gICAgLy8gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cblxuICAgIC8vIDExMFhYWFhYXG4gICAgaWYgKGkgPT0gMSAmJiBjID4+IDUgPT0gMHgwNikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTBYWFhYXG4gICAgaWYgKGkgPD0gMiAmJiBjID4+IDQgPT0gMHgwRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTEwWFhYXG4gICAgaWYgKGkgPD0gMyAmJiBjID4+IDMgPT0gMHgxRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGk7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpXG4gICAgcmVzID0gdGhpcy53cml0ZShidWZmZXIpO1xuXG4gIGlmICh0aGlzLmNoYXJSZWNlaXZlZCkge1xuICAgIHZhciBjciA9IHRoaXMuY2hhclJlY2VpdmVkO1xuICAgIHZhciBidWYgPSB0aGlzLmNoYXJCdWZmZXI7XG4gICAgdmFyIGVuYyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgcmVzICs9IGJ1Zi5zbGljZSgwLCBjcikudG9TdHJpbmcoZW5jKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBwYXNzVGhyb3VnaFdyaXRlKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAyO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDIgOiAwO1xufVxuXG5mdW5jdGlvbiBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMztcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAzIDogMDtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9zdHJpbmdfZGVjb2Rlci9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24oZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoZGF0YSkpXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgaWYgKGNiKVxuICAgIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpXG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAodXRpbC5pc0Z1bmN0aW9uKHRoaXMuX2ZsdXNoKSlcbiAgICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uKGVyKSB7XG4gICAgICAgIGRvbmUoc3RyZWFtLCBlcik7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fFxuICAgICAgICBycy5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaylcbiAgICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICghdXRpbC5pc051bGwodHMud3JpdGVjaHVuaykgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgaWYgKGVyKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAodHMudHJhbnNmb3JtaW5nKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9zdHJlYW0tYnJvd3NlcmlmeS9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanNcbiAqKiBtb2R1bGUgaWQgPSAzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSlcbiAgICByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9zdHJlYW0tYnJvd3NlcmlmeS9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qc1xuICoqIG1vZHVsZSBpZCA9IDM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXCIpXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vc3RyZWFtLWJyb3dzZXJpZnkvfi9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSAzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV9kdXBsZXguanNcIilcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9zdHJlYW0tYnJvd3NlcmlmeS9+L3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanNcbiAqKiBtb2R1bGUgaWQgPSAzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanNcIilcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9zdHJlYW0tYnJvd3NlcmlmeS9+L3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanNcbiAqKiBtb2R1bGUgaWQgPSAzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qc1wiKVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3N0cmVhbS1icm93c2VyaWZ5L34vcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzXG4gKiogbW9kdWxlIGlkID0gNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIgUmVzcG9uc2UgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG59O1xuXG51dGlsLmluaGVyaXRzKFJlc3BvbnNlLCBTdHJlYW0pO1xuXG52YXIgY2FwYWJsZSA9IHtcbiAgICBzdHJlYW1pbmcgOiB0cnVlLFxuICAgIHN0YXR1czIgOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMgKHJlcykge1xuICAgIHZhciBsaW5lcyA9IHJlcy5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKS5zcGxpdCgvXFxyP1xcbi8pO1xuICAgIHZhciBoZWFkZXJzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICBpZiAobGluZSA9PT0gJycpIGNvbnRpbnVlO1xuICAgICAgICBcbiAgICAgICAgdmFyIG0gPSBsaW5lLm1hdGNoKC9eKFteOl0rKTpcXHMqKC4qKS8pO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IG1bMV0udG9Mb3dlckNhc2UoKSwgdmFsdWUgPSBtWzJdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoaGVhZGVyc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGhlYWRlcnNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1trZXldLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1trZXldID0gWyBoZWFkZXJzW2tleV0sIHZhbHVlIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZWFkZXJzW2xpbmVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbn1cblxuUmVzcG9uc2UucHJvdG90eXBlLmdldFJlc3BvbnNlID0gZnVuY3Rpb24gKHhocikge1xuICAgIHZhciByZXNwVHlwZSA9IFN0cmluZyh4aHIucmVzcG9uc2VUeXBlKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChyZXNwVHlwZSA9PT0gJ2Jsb2InKSByZXR1cm4geGhyLnJlc3BvbnNlQmxvYiB8fCB4aHIucmVzcG9uc2U7XG4gICAgaWYgKHJlc3BUeXBlID09PSAnYXJyYXlidWZmZXInKSByZXR1cm4geGhyLnJlc3BvbnNlO1xuICAgIHJldHVybiB4aHIucmVzcG9uc2VUZXh0O1xufVxuXG5SZXNwb25zZS5wcm90b3R5cGUuZ2V0SGVhZGVyID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldO1xufTtcblxuUmVzcG9uc2UucHJvdG90eXBlLmhhbmRsZSA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICBpZiAocmVzLnJlYWR5U3RhdGUgPT09IDIgJiYgY2FwYWJsZS5zdGF0dXMyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gcGFyc2VIZWFkZXJzKHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2FwYWJsZS5zdGF0dXMyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChjYXBhYmxlLnN0YXR1czIpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChjYXBhYmxlLnN0cmVhbWluZyAmJiByZXMucmVhZHlTdGF0ZSA9PT0gMykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IHBhcnNlSGVhZGVycyhyZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7fVxuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXREYXRhKHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2FwYWJsZS5zdHJlYW1pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChyZXMucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gcmVzLnN0YXR1cztcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbWl0RGF0YShyZXMpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHJlcy5lcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHRoaXMuZ2V0UmVzcG9uc2UocmVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB0aGlzLmVtaXQoJ2VuZCcpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuICAgIH1cbn07XG5cblJlc3BvbnNlLnByb3RvdHlwZS5fZW1pdERhdGEgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgdmFyIHJlc3BCb2R5ID0gdGhpcy5nZXRSZXNwb25zZShyZXMpO1xuICAgIGlmIChyZXNwQm9keS50b1N0cmluZygpLm1hdGNoKC9BcnJheUJ1ZmZlci8pKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIG5ldyBVaW50OEFycmF5KHJlc3BCb2R5LCB0aGlzLm9mZnNldCkpO1xuICAgICAgICB0aGlzLm9mZnNldCA9IHJlc3BCb2R5LmJ5dGVMZW5ndGg7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlc3BCb2R5Lmxlbmd0aCA+IHRoaXMub2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIHJlc3BCb2R5LnNsaWNlKHRoaXMub2Zmc2V0KSk7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gcmVzcEJvZHkubGVuZ3RoO1xuICAgIH1cbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vaHR0cC1icm93c2VyaWZ5L2xpYi9yZXNwb25zZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vdXRpbC91dGlsLmpzXG4gKiogbW9kdWxlIGlkID0gNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi91dGlsL34vaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI7KGZ1bmN0aW9uICgpIHtcblxuICB2YXIgb2JqZWN0ID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpczsgLy8gIzg6IHdlYiB3b3JrZXJzXG4gIHZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cbiAgZnVuY3Rpb24gSW52YWxpZENoYXJhY3RlckVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG4gIEludmFsaWRDaGFyYWN0ZXJFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3I7XG4gIEludmFsaWRDaGFyYWN0ZXJFcnJvci5wcm90b3R5cGUubmFtZSA9ICdJbnZhbGlkQ2hhcmFjdGVyRXJyb3InO1xuXG4gIC8vIGVuY29kZXJcbiAgLy8gW2h0dHBzOi8vZ2lzdC5naXRodWIuY29tLzk5OTE2Nl0gYnkgW2h0dHBzOi8vZ2l0aHViLmNvbS9uaWduYWddXG4gIG9iamVjdC5idG9hIHx8IChcbiAgb2JqZWN0LmJ0b2EgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBmb3IgKFxuICAgICAgLy8gaW5pdGlhbGl6ZSByZXN1bHQgYW5kIGNvdW50ZXJcbiAgICAgIHZhciBibG9jaywgY2hhckNvZGUsIGlkeCA9IDAsIG1hcCA9IGNoYXJzLCBvdXRwdXQgPSAnJztcbiAgICAgIC8vIGlmIHRoZSBuZXh0IGlucHV0IGluZGV4IGRvZXMgbm90IGV4aXN0OlxuICAgICAgLy8gICBjaGFuZ2UgdGhlIG1hcHBpbmcgdGFibGUgdG8gXCI9XCJcbiAgICAgIC8vICAgY2hlY2sgaWYgZCBoYXMgbm8gZnJhY3Rpb25hbCBkaWdpdHNcbiAgICAgIGlucHV0LmNoYXJBdChpZHggfCAwKSB8fCAobWFwID0gJz0nLCBpZHggJSAxKTtcbiAgICAgIC8vIFwiOCAtIGlkeCAlIDEgKiA4XCIgZ2VuZXJhdGVzIHRoZSBzZXF1ZW5jZSAyLCA0LCA2LCA4XG4gICAgICBvdXRwdXQgKz0gbWFwLmNoYXJBdCg2MyAmIGJsb2NrID4+IDggLSBpZHggJSAxICogOClcbiAgICApIHtcbiAgICAgIGNoYXJDb2RlID0gaW5wdXQuY2hhckNvZGVBdChpZHggKz0gMy80KTtcbiAgICAgIGlmIChjaGFyQ29kZSA+IDB4RkYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRDaGFyYWN0ZXJFcnJvcihcIididG9hJyBmYWlsZWQ6IFRoZSBzdHJpbmcgdG8gYmUgZW5jb2RlZCBjb250YWlucyBjaGFyYWN0ZXJzIG91dHNpZGUgb2YgdGhlIExhdGluMSByYW5nZS5cIik7XG4gICAgICB9XG4gICAgICBibG9jayA9IGJsb2NrIDw8IDggfCBjaGFyQ29kZTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSk7XG5cbiAgLy8gZGVjb2RlclxuICAvLyBbaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTAyMDM5Nl0gYnkgW2h0dHBzOi8vZ2l0aHViLmNvbS9hdGtdXG4gIG9iamVjdC5hdG9iIHx8IChcbiAgb2JqZWN0LmF0b2IgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoLz0rJC8sICcnKTtcbiAgICBpZiAoaW5wdXQubGVuZ3RoICUgNCA9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZENoYXJhY3RlckVycm9yKFwiJ2F0b2InIGZhaWxlZDogVGhlIHN0cmluZyB0byBiZSBkZWNvZGVkIGlzIG5vdCBjb3JyZWN0bHkgZW5jb2RlZC5cIik7XG4gICAgfVxuICAgIGZvciAoXG4gICAgICAvLyBpbml0aWFsaXplIHJlc3VsdCBhbmQgY291bnRlcnNcbiAgICAgIHZhciBiYyA9IDAsIGJzLCBidWZmZXIsIGlkeCA9IDAsIG91dHB1dCA9ICcnO1xuICAgICAgLy8gZ2V0IG5leHQgY2hhcmFjdGVyXG4gICAgICBidWZmZXIgPSBpbnB1dC5jaGFyQXQoaWR4KyspO1xuICAgICAgLy8gY2hhcmFjdGVyIGZvdW5kIGluIHRhYmxlPyBpbml0aWFsaXplIGJpdCBzdG9yYWdlIGFuZCBhZGQgaXRzIGFzY2lpIHZhbHVlO1xuICAgICAgfmJ1ZmZlciAmJiAoYnMgPSBiYyAlIDQgPyBicyAqIDY0ICsgYnVmZmVyIDogYnVmZmVyLFxuICAgICAgICAvLyBhbmQgaWYgbm90IGZpcnN0IG9mIGVhY2ggNCBjaGFyYWN0ZXJzLFxuICAgICAgICAvLyBjb252ZXJ0IHRoZSBmaXJzdCA4IGJpdHMgdG8gb25lIGFzY2lpIGNoYXJhY3RlclxuICAgICAgICBiYysrICUgNCkgPyBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUgJiBicyA+PiAoLTIgKiBiYyAmIDYpKSA6IDBcbiAgICApIHtcbiAgICAgIC8vIHRyeSB0byBmaW5kIGNoYXJhY3RlciBpbiB0YWJsZSAoMC02Mywgbm90IGZvdW5kID0+IC0xKVxuICAgICAgYnVmZmVyID0gY2hhcnMuaW5kZXhPZihidWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9KTtcblxufSgpKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9CYXNlNjQvYmFzZTY0LmpzXG4gKiogbW9kdWxlIGlkID0gNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuXG52YXIgaHR0cHMgPSBtb2R1bGUuZXhwb3J0cztcblxuZm9yICh2YXIga2V5IGluIGh0dHApIHtcbiAgICBpZiAoaHR0cC5oYXNPd25Qcm9wZXJ0eShrZXkpKSBodHRwc1trZXldID0gaHR0cFtrZXldO1xufTtcblxuaHR0cHMucmVxdWVzdCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNiKSB7XG4gICAgaWYgKCFwYXJhbXMpIHBhcmFtcyA9IHt9O1xuICAgIHBhcmFtcy5zY2hlbWUgPSAnaHR0cHMnO1xuICAgIHJldHVybiBodHRwLnJlcXVlc3QuY2FsbCh0aGlzLCBwYXJhbXMsIGNiKTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9odHRwcy1icm93c2VyaWZ5L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIChpZ25vcmVkKSAqL1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZnMgKGlnbm9yZWQpXG4gKiogbW9kdWxlIGlkID0gNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImltcG9ydCB7ZmFicmljfSBmcm9tICdmYWJyaWMnO1xuaW1wb3J0IERyYXdUb29sIGZyb20gJy4vRHJhd1Rvb2wnO1xuaW1wb3J0IFNpZGUgZnJvbSAnLi9TaWRlJztcbmltcG9ydCBlc2NhcGVKU09OIGZyb20gJy4vdXRpbHMvZXNjYXBlSlNPTic7XG5cbi8qKlxuICogU2lkZXMgY2xhc3NcbiAqL1xuY2xhc3MgU2lkZXN7XG5cbiAgY29uc3RydWN0b3IoKXtcbiAgICB0aGlzLl9jb2xsZWN0aW9uID0gW107XG4gICAgLyoqXG4gICAgICogQ3VycmVudGx5IHNlbGVjdGVkIHNpZGVcbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQHR5cGUge1NpZGV9XG4gICAgICovXG4gICAgdGhpcy5zZWxlY3RlZCA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQWRkaW5nIGEgc2lkZVxuICAgKiBAcGFyYW0gaWRcbiAgICogQHJldHVybiB7U2lkZX1cbiAgICovXG4gIGFkZFNpZGUoaWQpe1xuICAgIGxldCBuZXdTaWRlID0gbmV3IFNpZGUoaWQpO1xuICAgIHRoaXMuX2NvbGxlY3Rpb24ucHVzaChuZXdTaWRlKTtcbiAgICByZXR1cm4gbmV3U2lkZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgc2lkZSBhcyBwbGFpbiBKQXZhU2NyaXB0IG9iamVjdC5cbiAgICogQHBhcmFtIGlkIHtTdHJpbmd9IElkIG9mIHNpZGVcbiAgICogQHJldHVybiBzaWRlcyB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0U2lkZShpZCl7XG4gICAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24uZmluZCgoc2lkZSkgPT4gc2lkZS5pZCA9PT0gaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBzaWRlXG4gICAqIEBwYXJhbSBpZCB7U3RyaW5nfVxuICAgKi9cbiAgc2VsZWN0KGlkKSB7XG5cbiAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5fY29sbGVjdGlvbi5maW5kKChzaWRlKSA9PiBzaWRlLmlkID09PSBpZCk7XG5cbiAgICBpZighdGhpcy5zZWxlY3RlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX2NvbGxlY3Rpb24uZm9yRWFjaCgoc2lkZSkgPT4gc2lkZS5GYWJyaWNDYW52YXMud3JhcHBlckVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZScpO1xuICAgIHRoaXMuc2VsZWN0ZWQuRmFicmljQ2FudmFzLndyYXBwZXJFbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgIHJldHVybiB0aGlzLnNlbGVjdGVkO1xuXG4gIH1cblxuICAvKipcbiAgICogR2V0dGluZyB3aG9sZSBjb2xsZWN0aW9uIGFzIEpTT05cbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgdG9KU09OKCl7XG5cbiAgICBsZXQgc2lkZXMgPSBbXTtcblxuICAgIHRoaXMuX2NvbGxlY3Rpb24uZm9yRWFjaChzaWRlID0+IHtcbiAgICAgIHNpZGVzLnB1c2goc2lkZS50b09iamVjdCgpKVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHNpZGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgc2lkZSBieSBpZFxuICAgKiBAcGFyYW0gaWRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHJlbW92ZVNpZGUoaWQpe1xuICAgIGxldCBzaWRlID0gdGhpcy5fY29sbGVjdGlvbi5maW5kKChzaWRlKSA9PiBzaWRlLmlkID09PSBpZCk7XG4gICAgbGV0IGluZGV4ID0gdGhpcy5fY29sbGVjdGlvbi5maW5kSW5kZXgoKHNpZGUpID0+IHNpZGUuaWQgPT09IGlkKTtcblxuICAgIGlmKCFzaWRlKSByZXR1cm4gZmFsc2U7XG5cbiAgICBzaWRlLkZhYnJpY0NhbnZhcy5jbGVhcigpO1xuICAgIHNpZGUuRmFicmljQ2FudmFzID0gdW5kZWZpbmVkO1xuICAgIHNpZGUuY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2lkZS5jYW52YXMpO1xuXG4gICAgdGhpcy5zZWxlY3RlZCA9IG51bGw7XG5cbiAgICB0aGlzLl9jb2xsZWN0aW9uLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbXB0eSBzaWRlc1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGVtcHR5KCl7XG5cbiAgICBsZXQgY29sbGVjdGlvbiA9IHRoaXMuX2NvbGxlY3Rpb24ubWFwKHNpZGUgPT4gc2lkZS5pZCk7XG5cbiAgICBjb2xsZWN0aW9uLmZvckVhY2goaWQgPT4ge1xuICAgICAgdGhpcy5yZW1vdmVTaWRlKGlkKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNpZGVzO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kcmF3VG9vbC9TaWRlcy5qc1xuICoqLyIsImltcG9ydCB7ZmFicmljfSBmcm9tICdmYWJyaWMnO1xuaW1wb3J0IERyYXdUb29sIGZyb20gJy4vRHJhd1Rvb2wnO1xuaW1wb3J0IEl0ZW1zIGZyb20gJy4vSXRlbXMnO1xuaW1wb3J0IExheWVycyBmcm9tICcuL0xheWVycyc7XG5pbXBvcnQgZXJyb3JzIGZyb20gJy4vdXRpbHMvZXJyb3JzJztcbmltcG9ydCBlc2NhcGVKU09OIGZyb20gJy4vdXRpbHMvZXNjYXBlSlNPTic7XG5pbXBvcnQgY29sb3JQaWNrZXIgZnJvbSAnLi91dGlscy9jb2xvclBpY2tlcic7XG5cbi8qKlxuICogU2lkZSBjbGFzc1xuICovXG5jbGFzcyBTaWRle1xuXG4gIC8qKlxuICAgKiBTaWRlIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSBpZCB7U3RyaW5nfVxuICAgKi9cbiAgY29uc3RydWN0b3IoaWQpe1xuXG4gICAgbGV0IHRoYXQgPSB0aGlzO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBpZDtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBhZGRpbmcgPSAxMDtcblxuICAgIC8qKlxuICAgICAqIENhbnZhcyBwYW5uaW5nXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLl9wYW5uaW5nID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBCYWNrZHJvcCBpbWFnZSB1cmxcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VVcmwgPSBudWxsO1xuXG4gICAgdGhpcy5jb250YWluZXIud2lkdGggPSBEcmF3VG9vbC5jb250YWluZXIuc2l6ZS53aWR0aCB8fCBEcmF3VG9vbC5jb250YWluZXIudGFyZ2V0LmNsaWVudFdpZHRoO1xuICAgIHRoaXMuY29udGFpbmVyLmhlaWdodCA9IERyYXdUb29sLmNvbnRhaW5lci5zaXplLmhlaWdodCB8fCBEcmF3VG9vbC5jb250YWluZXIudGFyZ2V0LmNsaWVudEhlaWdodDtcbiAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgdGhpcy5jb250YWluZXIuc3R5bGUudG9wID0gJzAnO1xuICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmxlZnQgPSAnMCc7XG5cbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IERyYXdUb29sLmNvbnRhaW5lci5zaXplLndpZHRoIHx8IERyYXdUb29sLmNvbnRhaW5lci50YXJnZXQuY2xpZW50V2lkdGg7XG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gRHJhd1Rvb2wuY29udGFpbmVyLnNpemUuaGVpZ2h0IHx8IERyYXdUb29sLmNvbnRhaW5lci50YXJnZXQuY2xpZW50SGVpZ2h0O1xuXG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuXG4gICAgRHJhd1Rvb2wuY29udGFpbmVyLnRhcmdldC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG5cbiAgICB0aGlzLl9pbml0RmFicmljKCk7XG4gICAgdGhpcy5faW5pdEV2ZW50cygpO1xuXG4gICAgdGhpcy5pdGVtcyA9IG5ldyBJdGVtcyh0aGlzKTtcblxuICAgIHRoaXMubGF5ZXJzID0gbmV3IExheWVycyh0aGlzKTtcblxuICAgIHRoaXMuY3VycmVudEJydXNoID0gJ1BlbmNpbEJydXNoJztcblxuICAgIHRoaXMuY29sb3JQaWNrZXIgPSBuZXcgY29sb3JQaWNrZXIodGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9XG5cbiAgc2V0IHBhbm5pbmcodmFsKXtcbiAgICBpZihCb29sZWFuKHZhbCkgPT09IHRydWUgJiYgdGhpcy5GYWJyaWNDYW52YXMuaXNEcmF3aW5nTW9kZSA9PT0gdHJ1ZSl7XG4gICAgICByZXR1cm4gdGhpcy5fcGFubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLml0ZW1zLnNlbGVjdGVkLmRlYWN0aXZhdGUoKTtcbiAgICB0aGlzLml0ZW1zLl9jb2xsZWN0aW9uLmZvckVhY2gob2JqZWN0ID0+IG9iamVjdC5zZWxlY3RhYmxlID0gIXZhbCk7XG4gICAgcmV0dXJuIHRoaXMuX3Bhbm5pbmcgPSB2YWw7XG4gIH1cblxuICBnZXQgcGFubmluZygpe1xuICAgIHJldHVybiB0aGlzLl9wYW5uaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBzaWRlIGltYWdlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAgICogQHBhcmFtIHNpemUge09iamVjdH0gc2l6ZVxuICAgKiBAcGFyYW0gc2l6ZS53aWR0aCB7TnVtYmVyfSBXaWR0aCBvZiBpbWFnZSBpbiBjZW50aW1ldGVyc1xuICAgKiBAcGFyYW0gc2l6ZS5oZWlnaHQge051bWJlcn0gSGVpZ2h0IG9mIGltYWdlIGluIGNlbnRpbWV0ZXJzXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBzZXRJbWFnZSh1cmwsIHNpemUpe1xuXG4gICAgdGhpcy5pbWFnZSA9IHsuLi5zaXplfTtcblxuICAgIHRoaXMuaW1hZ2VVcmwgPSB1cmw7XG5cbiAgICBsZXQgY2VudGVyID0gdGhpcy5GYWJyaWNDYW52YXMuZ2V0Q2VudGVyKCk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICB0aGlzLkZhYnJpY0NhbnZhcy5zZXRCYWNrZ3JvdW5kQ29sb3IoJyNmZmZmZmYnKTtcblxuICAgICAgdGhpcy5GYWJyaWNDYW52YXMuc2V0QmFja2dyb3VuZEltYWdlKHVybCwgaW1nID0+IHtcblxuICAgICAgICB0aGlzLmJhY2tkcm9wID0gdGhpcy5GYWJyaWNDYW52YXMuYmFja2dyb3VuZEltYWdlO1xuXG4gICAgICAgIHRoaXMuYmFja2Ryb3AuZXhjbHVkZUZyb21FeHBvcnQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0aGlzLkZhYnJpY0NhbnZhcy53aWR0aCA+PSB0aGlzLkZhYnJpY0NhbnZhcy5oZWlnaHQpIHtcbiAgICAgICAgICB0aGlzLmJhY2tkcm9wLnNjYWxlVG9XaWR0aCh0aGlzLkZhYnJpY0NhbnZhcy5oZWlnaHQgLSAodGhpcy5wYWRkaW5nICogd2luZG93LmRldmljZVBpeGVsUmF0aW8pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJhY2tkcm9wLnNjYWxlVG9IZWlnaHQodGhpcy5GYWJyaWNDYW52YXMud2lkdGggLSAodGhpcy5wYWRkaW5nICogd2luZG93LmRldmljZVBpeGVsUmF0aW8pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY21TaXplID0gdGhpcy5fY2FsY3VsYXRlU2l6ZSgpO1xuXG4gICAgICAgIHRoaXMuX2luaXRHcmlkKCk7XG4gICAgICAgIHRoaXMuX2luaXRSdWxlcigpO1xuXG4gICAgICAgIHRoaXMuRmFicmljQ2FudmFzLnJlbmRlckFsbCgpO1xuXG4gICAgICAgIERyYXdUb29sLnRyaWdnZXIoJ2JhY2tkcm9wOmxvYWRlZCcsIHtzaWRlOiB7aWQ6IHRoaXMuaWR9fSk7XG5cbiAgICAgICAgRHJhd1Rvb2wuaGlzdG9yeS5wdXNoU3RhdGUodGhpcy5pZCk7XG4gICAgICAgIHJlc29sdmUoe3NpZGU6IHtpZDogdGhpcy5pZH19KTtcbiAgICAgIH0sIHtcbiAgICAgICAgdG9wOiBjZW50ZXIudG9wLFxuICAgICAgICBsZWZ0OiBjZW50ZXIubGVmdCxcbiAgICAgICAgb3JpZ2luWDogJ2NlbnRlcicsXG4gICAgICAgIG9yaWdpblk6ICdjZW50ZXInLFxuICAgICAgICBvcGFjaXR5OiAwLjUsXG4gICAgICAgIGNyb3NzT3JpZ2luOiAnYW5vbnltb3VzJ1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGltYWdlIHNpemVcbiAgICogQHBhcmFtIHNpemVcbiAgICogQHBhcmFtIHNpemUge09iamVjdH0gc2l6ZVxuICAgKiBAcGFyYW0gc2l6ZS53aWR0aCB7TnVtYmVyfSBXaWR0aCBvZiBpbWFnZSBpbiBjZW50aW1ldGVyc1xuICAgKiBAcGFyYW0gc2l6ZS5oZWlnaHQge051bWJlcn0gSGVpZ2h0IG9mIGltYWdlIGluIGNlbnRpbWV0ZXJzXG4gICAqL1xuICB1cGRhdGVTaXplKHNpemUpe1xuXG4gICAgdGhpcy5pbWFnZSA9IHsuLi5zaXplfTtcblxuICAgIHRoaXMuY21TaXplID0gdGhpcy5fY2FsY3VsYXRlU2l6ZSgpO1xuXG4gICAgdGhpcy5faW5pdEdyaWQoKTtcbiAgICB0aGlzLl9pbml0UnVsZXIoKTtcblxuICAgIGlmKHRoaXMuRmFicmljQm9yZGVyKSB7XG4gICAgICB0aGlzLl9pbml0V29ya3NwYWNlR3JpZCgpO1xuICAgICAgdGhpcy5faW5pdFdvcmtzcGFjZVJ1bGVyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGltYWdlXG4gICAqL1xuICByZW1vdmVJbWFnZSgpe1xuICAgIHRoaXMuRmFicmljQ2FudmFzLnJlbW92ZSh0aGlzLmJhY2tkcm9wKTtcbiAgICB0aGlzLmJhY2tkcm9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuRmFicmljQ2FudmFzLnJlbmRlckFsbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMud2lkdGgge051bWJlcn0gV2lkdGggb2YgYm9yZGVyXG4gICAqIEBwYXJhbSBvcHRpb25zLmhlaWdodCB7TnVtYmVyfSBIZWlnaHQgb2YgYm9yZGVyXG4gICAqIEBwYXJhbSBvcHRpb25zLnRvcCB7TnVtYmVyfSBUb3AgcG9zaXRpb25cbiAgICogQHBhcmFtIG9wdGlvbnMubGVmdCB7TnVtYmVyfSBMZWZ0IHBvc2l0aW9uXG4gICAqL1xuICBzZXRCb3JkZXIob3B0aW9ucyl7XG5cbiAgICBpZighdGhpcy5jbVNpemUpe1xuICAgICAgdGhyb3cgKCBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoe2Vycm9yOiBlcnJvcnMuc2lkZU5vU2l6ZX0pKSApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmKCFvcHRpb25zKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZih0aGlzLkZhYnJpY0JvcmRlcikge1xuICAgICAgdGhpcy5GYWJyaWNCb3JkZXIucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5ib3JkZXIgPSBvcHRpb25zO1xuXG4gICAgbGV0IF9vcHRzID0ge1xuICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICBzdHJva2U6ICdyZ2JhKDEwMCwyMDAsMjAwLDEpJyxcbiAgICAgIGZpbGw6ICcnLFxuICAgICAgaGFzUm90YXRpbmdQb2ludDogZmFsc2UsXG4gICAgICBsb2NrUm90YXRpb246IHRydWVcbiAgICB9O1xuXG4gICAgbGV0IHBhZGRpbmdUb3AgPSAodGhpcy5GYWJyaWNDYW52YXMuaGVpZ2h0IC0gKHRoaXMuYmFja2Ryb3AuaGVpZ2h0ICogdGhpcy5iYWNrZHJvcC5zY2FsZVkpKSAvIDI7XG4gICAgbGV0IHBhZGRpbmdMZWZ0ID0gKHRoaXMuRmFicmljQ2FudmFzLndpZHRoIC0gKHRoaXMuYmFja2Ryb3Aud2lkdGggKiB0aGlzLmJhY2tkcm9wLnNjYWxlWCkpIC8gMjtcblxuICAgIGxldCBfb3B0aW9ucyA9IHtcbiAgICAgIHdpZHRoOiBvcHRpb25zLndpZHRoICogdGhpcy5jbVNpemUud2lkdGgsXG4gICAgICBoZWlnaHQ6IG9wdGlvbnMuaGVpZ2h0ICogdGhpcy5jbVNpemUuaGVpZ2h0LFxuICAgICAgdG9wOiBvcHRpb25zLnRvcCAqIHRoaXMuY21TaXplLmhlaWdodCArIHBhZGRpbmdUb3AsXG4gICAgICBsZWZ0OiBvcHRpb25zLmxlZnQgKiB0aGlzLmNtU2l6ZS53aWR0aCArIHBhZGRpbmdMZWZ0XG4gICAgfTtcblxuICAgIHRoaXMuRmFicmljQm9yZGVyID0gbmV3IGZhYnJpYy5SZWN0KHtcbiAgICAgIC4uLl9vcHRzLFxuICAgICAgLi4uX29wdGlvbnNcbiAgICB9KTtcblxuICAgIHRoaXMuRmFicmljQm9yZGVyLnNldENvb3JkcygpO1xuICAgIHRoaXMuRmFicmljQm9yZGVyLmlkID0gJ0ZhYnJpY0JvcmRlcic7XG5cbiAgICB0aGlzLkZhYnJpY0JvcmRlci5leGNsdWRlRnJvbUV4cG9ydCA9IHRydWU7XG4gICAgdGhpcy5GYWJyaWNCb3JkZXIuc2VsZWN0YWJsZSA9IERyYXdUb29sLmVkaXRhYmxlO1xuICAgIHRoaXMuRmFicmljQm9yZGVyLmhvdmVyQ3Vyc29yID0gJ2RlZmF1bHQnO1xuXG4gICAgdGhpcy5GYWJyaWNDYW52YXMuYWRkKHRoaXMuRmFicmljQm9yZGVyKTtcbiAgICB0aGlzLmNlbnRlciA9IHRoaXMuRmFicmljQm9yZGVyLmdldENlbnRlclBvaW50KCk7XG5cbiAgICB0aGlzLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcblxuICAgIHRoaXMuX2luaXRXb3Jrc3BhY2VHcmlkKCk7XG4gICAgdGhpcy5faW5pdFdvcmtzcGFjZVJ1bGVyKCk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBib3JkZXJcbiAgICogQHJldHVybiB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX1cbiAgICovXG4gIGdldEJvcmRlcigpe1xuXG4gICAgbGV0IHBhZGRpbmdUb3AgPSAodGhpcy5GYWJyaWNDYW52YXMuaGVpZ2h0IC0gKHRoaXMuYmFja2Ryb3AuaGVpZ2h0ICogdGhpcy5iYWNrZHJvcC5zY2FsZVkpKSAvIDI7XG4gICAgbGV0IHBhZGRpbmdMZWZ0ID0gKHRoaXMuRmFicmljQ2FudmFzLndpZHRoIC0gKHRoaXMuYmFja2Ryb3Aud2lkdGggKiB0aGlzLmJhY2tkcm9wLnNjYWxlWCkpIC8gMjtcblxuICAgIGxldCBib3JkZXIgPSB7XG4gICAgICBsZWZ0OiAodGhpcy5GYWJyaWNCb3JkZXIubGVmdCAtIHBhZGRpbmdMZWZ0KSAvIHRoaXMuY21TaXplLndpZHRoLFxuICAgICAgdG9wOiAodGhpcy5GYWJyaWNCb3JkZXIudG9wICAtIHBhZGRpbmdUb3ApIC8gdGhpcy5jbVNpemUuaGVpZ2h0LFxuICAgICAgd2lkdGg6ICh0aGlzLkZhYnJpY0JvcmRlci53aWR0aCAqIHRoaXMuRmFicmljQm9yZGVyLnNjYWxlWCkgLyB0aGlzLmNtU2l6ZS53aWR0aCxcbiAgICAgIGhlaWdodDogKHRoaXMuRmFicmljQm9yZGVyLmhlaWdodCAqIHRoaXMuRmFicmljQm9yZGVyLnNjYWxlWSkgLyB0aGlzLmNtU2l6ZS5oZWlnaHQsXG4gICAgICBfcmVhbDoge1xuICAgICAgICBsZWZ0OiB0aGlzLkZhYnJpY0JvcmRlci5sZWZ0IC0gcGFkZGluZ0xlZnQsXG4gICAgICAgIHRvcDogdGhpcy5GYWJyaWNCb3JkZXIudG9wICAtIHBhZGRpbmdUb3AsXG4gICAgICAgIHdpZHRoOiB0aGlzLkZhYnJpY0JvcmRlci53aWR0aCAqIHRoaXMuRmFicmljQm9yZGVyLnNjYWxlWCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLkZhYnJpY0JvcmRlci5oZWlnaHQgKiB0aGlzLkZhYnJpY0JvcmRlci5zY2FsZVksXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvcmRlcjtcbiAgfVxuXG4gIHpvb21Ub1ZhbCh2YWwpe1xuICAgIGxldCBjZW50ZXIgPSB0aGlzLkZhYnJpY0JvcmRlci5nZXRDZW50ZXJQb2ludCgpO1xuICAgIHRoaXMuRmFicmljQ2FudmFzLnpvb21Ub1BvaW50KGNlbnRlciwgdmFsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBab29tIHJlbGF0aXZlIHRvIGJvcmRlclxuICAgKiBAcmV0dXJuIHtTaWRlfVxuICAgKi9cbiAgem9vbUluKCl7XG4gICAgbGV0IHpvb20gPSB0aGlzLkZhYnJpY0NhbnZhcy5nZXRab29tKCk7XG4gICAgaWYoem9vbSA8PSAyKSB7XG4gICAgICBsZXQgY2VudGVyID0gdGhpcy5GYWJyaWNCb3JkZXIuZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICAgIHRoaXMuRmFicmljQ2FudmFzLnpvb21Ub1BvaW50KGNlbnRlciwgem9vbSArIDAuMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFpvb20gcmVsYXRpdmUgdG8gYm9yZGVyXG4gICAqIEByZXR1cm4ge1NpZGV9XG4gICAqL1xuICB6b29tT3V0KCl7XG4gICAgbGV0IHpvb20gPSB0aGlzLkZhYnJpY0NhbnZhcy5nZXRab29tKCk7XG4gICAgaWYoem9vbSA+PSAwLjIpIHtcbiAgICAgIGxldCBjZW50ZXIgPSB0aGlzLkZhYnJpY0JvcmRlci5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgdGhpcy5GYWJyaWNDYW52YXMuem9vbVRvUG9pbnQoY2VudGVyLCB6b29tIC0gMC4xKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogWm9vbSByZWxhdGl2ZSB0byB2aWV3cG9ydFxuICAgKiBAcmV0dXJuIHtTaWRlfVxuICAgKi9cbiAgem9vbUluVlAoKXtcbiAgICBsZXQgem9vbSA9IHRoaXMuRmFicmljQ2FudmFzLmdldFpvb20oKTtcbiAgICBsZXQgY2VudGVyID0gdGhpcy5GYWJyaWNDYW52YXMuZ2V0VnBDZW50ZXIoKTtcbiAgICB0aGlzLkZhYnJpY0NhbnZhcy56b29tVG9Qb2ludChjZW50ZXIsIHpvb20gKyAwLjEpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogWm9vbSByZWxhdGl2ZSB0byB2aWV3cG9ydFxuICAgKiBAcmV0dXJuIHtTaWRlfVxuICAgKi9cbiAgem9vbU91dFZQKCl7XG4gICAgbGV0IHpvb20gPSB0aGlzLkZhYnJpY0NhbnZhcy5nZXRab29tKCk7XG4gICAgbGV0IGNlbnRlciA9IHRoaXMuRmFicmljQ2FudmFzLmdldFZwQ2VudGVyKCk7XG4gICAgdGhpcy5GYWJyaWNDYW52YXMuem9vbVRvUG9pbnQoY2VudGVyLCB6b29tIC0gMC4xKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICB0b09iamVjdCgpe1xuXG4gICAgbGV0IF9mb3JtYXR0ZWRTaWRlID0ge1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBpbWFnZVVybDogdGhpcy5pbWFnZVVybCxcbiAgICAgIHNpemU6IHRoaXMuaW1hZ2UsXG4gICAgICBjYW52YXM6IHRoaXMuRmFicmljQ2FudmFzLnRvT2JqZWN0KFsnYnJ1c2gnLCAnZWRpdGFibGUnLCAndmVydGljYWwnXSlcbiAgICB9O1xuXG4gICAgX2Zvcm1hdHRlZFNpZGUuY2FudmFzLm9iamVjdHMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIGl0ZW0ubGVmdCA9IGl0ZW0ubGVmdCAtIHRoaXMuY2VudGVyLng7XG4gICAgICBpdGVtLnRvcCA9IGl0ZW0udG9wIC0gdGhpcy5jZW50ZXIueTtcblxuICAgICAgaWYoaXRlbS5zZWxlY3RlZCl7XG4gICAgICAgIGl0ZW0uc2VsZWN0YWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYodGhpcy5iYWNrZHJvcCl7XG5cbiAgICAgIF9mb3JtYXR0ZWRTaWRlLmltYWdlVXJsID0gdGhpcy5pbWFnZVVybFxuXG4gICAgfVxuXG4gICAgaWYodGhpcy5GYWJyaWNCb3JkZXIpe1xuXG4gICAgICBfZm9ybWF0dGVkU2lkZS5ib3JkZXIgPSB0aGlzLmdldEJvcmRlcigpO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIF9mb3JtYXR0ZWRTaWRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICB0b0pTT04oKXtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b09iamVjdCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ganNvblxuICAgKi9cbiAgZnJvbUpTT04oanNvbil7XG4gICAgbGV0IGRhdGEgPSBKU09OLnBhcnNlKGVzY2FwZUpTT04oanNvbikpO1xuXG4gICAgdGhpcy5fcmVtb3ZlRXZlbnRzKCk7XG5cbiAgICB0aGlzLml0ZW1zLl9jb2xsZWN0aW9uID0gW107XG5cbiAgICBsZXQgY2FudmFzRGF0YSA9IEpTT04uc3RyaW5naWZ5KHtvYmplY3RzOiBkYXRhLmNhbnZhcy5vYmplY3RzfSk7XG5cbiAgICB0aGlzLkZhYnJpY0NhbnZhcy5sb2FkRnJvbUpTT04oY2FudmFzRGF0YSwgKCkgPT4ge1xuICAgICAgdGhpcy5zZXRCb3JkZXIodGhpcy5ib3JkZXIpO1xuICAgICAgdGhpcy5GYWJyaWNCb3JkZXIuc2VuZFRvQmFjaygpO1xuICAgICAgdGhpcy5GYWJyaWNDYW52YXMucmVuZGVyQWxsLmJpbmQodGhpcy5GYWJyaWNDYW52YXMpO1xuICAgICAgdGhpcy5faW5pdEV2ZW50cygpO1xuICAgIH0sIChvLCBpdGVtKSA9PiB7XG5cbiAgICAgIGxldCBkaWZmVyA9IHRoaXMuRmFicmljQm9yZGVyLndpZHRoIC8gZGF0YS5ib3JkZXIuX3JlYWwud2lkdGg7XG4gICAgICBsZXQgZGlmZkggPSB0aGlzLkZhYnJpY0JvcmRlci5oZWlnaHQgLyBkYXRhLmJvcmRlci5fcmVhbC5oZWlnaHQ7XG4gICAgICBsZXQgZGlmZlggPSB0aGlzLkZhYnJpY0JvcmRlci53aWR0aCAvIGRhdGEuYm9yZGVyLl9yZWFsLndpZHRoO1xuICAgICAgbGV0IGRpZmZZID0gdGhpcy5GYWJyaWNCb3JkZXIuaGVpZ2h0IC8gZGF0YS5ib3JkZXIuX3JlYWwuaGVpZ2h0O1xuXG4gICAgICBpdGVtLnNldCh7XG4gICAgICAgIGxlZnQ6IHRoaXMuY2VudGVyLnggKyAoaXRlbS5sZWZ0ICogZGlmZlgpLFxuICAgICAgICB0b3A6IHRoaXMuY2VudGVyLnkgKyAoaXRlbS50b3AgKiBkaWZmWSksXG4gICAgICAgIHdpZHRoOiBpdGVtLndpZHRoICogZGlmZlcsXG4gICAgICAgIGhlaWdodDogaXRlbS5oZWlnaHQgKiBkaWZmSFxuICAgICAgfSk7XG5cbiAgICAgIGlmKGl0ZW0udHlwZSA9PT0gJ3RleHRib3gnKXtcbiAgICAgICAgaXRlbS5zZXQoe1xuICAgICAgICAgIHNjYWxlWDogZGlmZlgsXG4gICAgICAgICAgc2NhbGVZOiBkaWZmWSxcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLml0ZW1zLl9jb2xsZWN0aW9uLnB1c2goaXRlbSk7XG4gICAgfSk7XG5cblxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqL1xuICB0b1NWRyhjYWxsYmFjayl7XG5cbiAgICBpZighdGhpcy5jbVNpemUpe1xuICAgICAgdGhyb3cgKCBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoe2Vycm9yOiBlcnJvcnMuc2lkZU5vU2l6ZX0pKSApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmKCF0aGlzLkZhYnJpY0JvcmRlcil7XG4gICAgICB0aHJvdyAoIG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeSh7ZXJyb3I6IGVycm9ycy5zaWRlTm9Cb3JkZXJ9KSkgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLkZhYnJpY0NhbnZhcy5jbG9uZShjbG9uZSA9PiB7XG5cbiAgICAgIGNsb25lLmZvckVhY2hPYmplY3QoaXRlbSA9PiB7XG4gICAgICAgIGlmIChpdGVtLnR5cGUgPT09ICd0ZXh0Ym94Jykge1xuICAgICAgICAgIGl0ZW0uY2xpcFRvID0gbnVsbDtcbiAgICAgICAgICBsZXQgYmFzZTY0ID0gaXRlbS50b0RhdGFVUkwoe2VuYWJsZVJldGluYTogdHJ1ZX0pO1xuICAgICAgICAgIGxldCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgIGltYWdlLnNyYyA9IGJhc2U2NDtcbiAgICAgICAgICBsZXQgZmFicmljSW1hZ2UgPSBuZXcgZmFicmljLkltYWdlKGltYWdlLCB7XG4gICAgICAgICAgICB0b3A6IGl0ZW0udG9wLFxuICAgICAgICAgICAgbGVmdDogaXRlbS5sZWZ0LFxuICAgICAgICAgICAgd2lkdGg6IGl0ZW0ud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGl0ZW0uaGVpZ2h0LFxuICAgICAgICAgICAgb3JpZ2luWDogJ2NlbnRlcicsXG4gICAgICAgICAgICBvcmlnaW5ZOiAnY2VudGVyJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGl0ZW0gPSBmYWJyaWNJbWFnZTtcbiAgICAgICAgICBmYWJyaWNJbWFnZS5zZXRDb29yZHMoKTtcbiAgICAgICAgICBjbG9uZS5yZW5kZXJBbGwoKTtcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgbGV0IHN2ZyA9IGNsb25lLnRvU1ZHKHtcbiAgICAgICAgc3VwcHJlc3NQcmVhbWJsZTogdHJ1ZSxcbiAgICAgICAgdmlld0JveDoge1xuICAgICAgICAgIHg6IHRoaXMuRmFicmljQm9yZGVyLmxlZnQsXG4gICAgICAgICAgeTogdGhpcy5GYWJyaWNCb3JkZXIudG9wLFxuICAgICAgICAgIHdpZHRoOiB0aGlzLkZhYnJpY0JvcmRlci53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHRoaXMuRmFicmljQm9yZGVyLmhlaWdodFxuICAgICAgICB9XG4gICAgICB9LCBlbCA9PiB7XG4gICAgICAgIGlmICghZWwuaW5jbHVkZXModGhpcy5pbWFnZVVybCkpIHtcbiAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBsZXQgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgbGV0IGRvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoc3ZnLCBcImltYWdlL3N2Zyt4bWxcIik7XG5cbiAgICAgIGxldCBzdmdPYmogPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N2ZycpWzBdO1xuXG4gICAgICBzdmdPYmouc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuRmFicmljQm9yZGVyLndpZHRoKTtcbiAgICAgIHN2Z09iai5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuRmFicmljQm9yZGVyLmhlaWdodCk7XG5cbiAgICAgIGxldCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHN2Z09iaik7XG5cbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGNvbnRhaW5lci5pbm5lckhUTUwpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ30gQmFzZSA2NCByZXByZXNlbnRhdGlvbiBvZiBjYW52YXNcbiAgICovXG4gIGdldFByZXZpZXcoKXtcblxuICAgIHRoaXMuRmFicmljQm9yZGVyLnNldFZpc2libGUoZmFsc2UpO1xuXG4gICAgbGV0IHByZXZpZXcgPSB0aGlzLkZhYnJpY0NhbnZhcy50b0RhdGFVUkwoe1xuICAgICAgbXVsdGlwbGllcjogMC41XG4gICAgfSk7XG4gICAgdGhpcy5GYWJyaWNCb3JkZXIuc2V0VmlzaWJsZSh0cnVlKTtcblxuICAgIHRoaXMuRmFicmljQ2FudmFzLnJlbmRlckFsbCgpO1xuXG4gICAgcmV0dXJuIHByZXZpZXc7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfSBCYXNlIDY0IHJlcHJlc2VudGF0aW9uIG9mIGNhbnZhc1xuICAgKi9cbiAgZ2V0SW1hZ2VQcmV2aWV3KCl7XG5cbiAgICB0aGlzLkZhYnJpY0JvcmRlci5zZXRWaXNpYmxlKGZhbHNlKTtcbiAgICB0aGlzLmJhY2tkcm9wLnNldFZpc2libGUoZmFsc2UpO1xuXG4gICAgbGV0IHByZXZpZXcgPSB0aGlzLkZhYnJpY0NhbnZhcy50b0RhdGFVUkwoe1xuICAgICAgbXVsdGlwbGllcjogMC41XG4gICAgfSk7XG4gICAgdGhpcy5GYWJyaWNCb3JkZXIuc2V0VmlzaWJsZSh0cnVlKTtcbiAgICB0aGlzLmJhY2tkcm9wLnNldFZpc2libGUodHJ1ZSk7XG5cbiAgICB0aGlzLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcblxuICAgIHJldHVybiBwcmV2aWV3O1xuICB9XG5cbiAgZHJhd2luZ01vZGUodmFsKXtcbiAgICBpZih2YWwgPT09IHVuZGVmaW5lZCl7XG4gICAgICByZXR1cm4gdGhpcy5GYWJyaWNDYW52YXMuaXNEcmF3aW5nTW9kZTtcbiAgICB9XG5cbiAgICBpZih0aGlzLnBhbm5pbmcgPT09IHRydWUpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuRmFicmljQ2FudmFzLmlzRHJhd2luZ01vZGUgPSB2YWw7XG4gICAgdGhpcy5GYWJyaWNDYW52YXMuZnJlZURyYXdpbmdCcnVzaCA9IG5ldyBmYWJyaWMuUGVuY2lsQnJ1c2hDKHRoaXMuRmFicmljQ2FudmFzLCB7Y29sb3I6ICcjMDAwMDAwJ30pO1xuICAgIHRoaXMuY3VycmVudEJydXNoID0gJ1BlbmNpbEJydXNoJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRGYWJyaWMoKXtcblxuICAgIHRoaXMuRmFicmljQ2FudmFzID0gbmV3IGZhYnJpYy5DYW52YXModGhpcy5jYW52YXMsIHtcbiAgICAgIHNlbGVjdGlvbjogZmFsc2UsXG4gICAgICBlbmFibGVSZXRpbmFTY2FsaW5nOiB0cnVlLFxuICAgICAgY29udHJvbHNBYm92ZU92ZXJsYXk6IHRydWVcbiAgICB9KTtcblxuICAgIHRoaXMuRmFicmljQ2FudmFzLndyYXBwZXJFbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgdGhpcy5GYWJyaWNDYW52YXMudXBwZXJDYW52YXNFbC5zdHlsZVsnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJ10gPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgdGhpcy5GYWJyaWNDYW52YXMubG93ZXJDYW52YXNFbC5zdHlsZVsnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJ10gPSAncmdiYSgwLDAsMCwwKSc7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRFdmVudHMoKXtcbiAgICB0aGlzLkZhYnJpY0NhbnZhcy5vbih7XG4gICAgICAnb2JqZWN0OmFkZGVkJzogKGUpID0+IHtcbiAgICAgICAgRHJhd1Rvb2wudHJpZ2dlcignb2JqZWN0OmFkZGVkJywge3NpZGU6IHtpZDogdGhpcy5pZH19KTtcbiAgICAgIH0sXG4gICAgICAnc2VsZWN0aW9uOmNsZWFyZWQnOiAoZSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5pdGVtcy5zZWxlY3RlZC5pdGVtKSB7XG4gICAgICAgICAgdGhpcy5pdGVtcy5zZWxlY3RlZC5pdGVtLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pdGVtcy5zZWxlY3RlZC5pdGVtID0gbnVsbDtcbiAgICAgICAgRHJhd1Rvb2wudHJpZ2dlcignc2VsZWN0aW9uOmNsZWFyZWQnLCBlKTtcbiAgICAgIH0sXG4gICAgICAnc2VsZWN0aW9uOmNyZWF0ZWQnOiAoZSkgPT4ge1xuICAgICAgICBEcmF3VG9vbC50cmlnZ2VyKCdzZWxlY3Rpb246Y3JlYXRlZCcsIGUpO1xuICAgICAgfSxcbiAgICAgICdvYmplY3Q6c2VsZWN0ZWQnOiAoZSkgPT4ge1xuICAgICAgICBpZiAoZS50YXJnZXQuaWQgPT09ICdGYWJyaWNCb3JkZXInKSB7XG4gICAgICAgICAgZS50YXJnZXQuc2V0Q29vcmRzKCk7XG4gICAgICAgICAgdGhpcy5jZW50ZXIgPSB0aGlzLkZhYnJpY0JvcmRlci5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXRlbXMuc2VsZWN0ZWQuaXRlbSA9IGUudGFyZ2V0O1xuICAgICAgICB0aGlzLml0ZW1zLnNlbGVjdGVkLml0ZW0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICBEcmF3VG9vbC50cmlnZ2VyKCdvYmplY3Q6c2VsZWN0ZWQnLCB7c2lkZToge2lkOiB0aGlzLmlkfSwgaXNXb3JrU3BhY2VCb3JkZXI6IGUudGFyZ2V0LmlkID09PSAnRmFicmljQm9yZGVyJ30pO1xuICAgICAgfSxcbiAgICAgICdvYmplY3Q6bW9kaWZpZWQnOiAoZSkgPT4ge1xuICAgICAgICBpZiAoZS50YXJnZXQuaWQgPT09ICdGYWJyaWNCb3JkZXInKSB7XG4gICAgICAgICAgZS50YXJnZXQuc2V0Q29vcmRzKCk7XG4gICAgICAgICAgdGhpcy5jZW50ZXIgPSB0aGlzLkZhYnJpY0JvcmRlci5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgICAgIHRoaXMuX2luaXRXb3Jrc3BhY2VHcmlkKCk7XG4gICAgICAgICAgdGhpcy5faW5pdFdvcmtzcGFjZVJ1bGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgRHJhd1Rvb2wudHJpZ2dlcignb2JqZWN0Om1vZGlmaWVkJywge3NpZGU6IHtpZDogdGhpcy5pZH0sIGlzV29ya1NwYWNlQm9yZGVyOiBlLnRhcmdldC5pZCA9PT0gJ0ZhYnJpY0JvcmRlcid9KTtcbiAgICAgICAgRHJhd1Rvb2wudHJpZ2dlcignaGlzdG9yeTp1cGRhdGUnLCB7c2lkZToge2lkOiB0aGlzLmlkfX0pO1xuICAgICAgfSxcbiAgICAgICdvYmplY3Q6cmVtb3ZlZCc6ICgpID0+IHtcbiAgICAgICAgRHJhd1Rvb2wudHJpZ2dlcignb2JqZWN0OnJlbW92ZWQnLCB7c2lkZToge2lkOiB0aGlzLmlkfX0pO1xuICAgICAgICBEcmF3VG9vbC50cmlnZ2VyKCdoaXN0b3J5OnVwZGF0ZScsIHtzaWRlOiB7aWQ6IHRoaXMuaWR9fSk7XG4gICAgICB9LFxuICAgICAgJ2VkaXRpbmc6ZXhpdGVkJzogKCkgPT4ge1xuICAgICAgICBEcmF3VG9vbC50cmlnZ2VyKCdlZGl0aW5nOmV4aXRlZCcsIHtzaWRlOiB7aWQ6IHRoaXMuaWR9fSk7XG4gICAgICB9LFxuICAgICAgJ2VkaXRpbmc6ZW50ZXJlZCc6ICgpID0+IHtcbiAgICAgICAgRHJhd1Rvb2wudHJpZ2dlcignZWRpdGluZzplbnRlcmVkJywge3NpZGU6IHtpZDogdGhpcy5pZH19KTtcbiAgICAgIH0sXG4gICAgICAnbW91c2U6dXAnOiAoZSkgPT4ge1xuICAgICAgICB0aGlzLl9wYW5uaW5nRG93biA9IGZhbHNlO1xuICAgICAgfSxcbiAgICAgICdtb3VzZTpkb3duJzogKGUpID0+IHtcbiAgICAgICAgdGhpcy5fcGFubmluZ0Rvd24gPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX3Bhbl94MCA9IGUuZS5sYXllclg7XG4gICAgICAgIHRoaXMuX3Bhbl95MCA9IGUuZS5sYXllclk7XG5cbiAgICAgICAgaWYodGhpcy5jb2xvclBpY2tlci5hY3RpdmUpe1xuICAgICAgICAgIHRoaXMuY29sb3JQaWNrZXIubW92ZShlKTtcbiAgICAgICAgICBEcmF3VG9vbC50cmlnZ2VyKCdjb2xvcnBpY2tlcjp1cGRhdGUnLCB0aGlzLmNvbG9yUGlja2VyLmNvbG9yKTtcbiAgICAgICAgfVxuXG4gICAgICB9LFxuICAgICAgJ21vdXNlOm1vdmUnOiAoZSkgPT4ge1xuICAgICAgICBpZiAoISEodGhpcy5fcGFubmluZyAmJiB0aGlzLl9wYW5uaW5nRG93biAmJiBlICYmIGUuZSkpIHtcblxuICAgICAgICAgIGxldCB4ID0gZS5lLmxheWVyWDtcbiAgICAgICAgICBsZXQgeSA9IGUuZS5sYXllclk7XG4gICAgICAgICAgdGhpcy5GYWJyaWNDYW52YXMucmVsYXRpdmVQYW4oeyB4OiB4IC0gdGhpcy5fcGFuX3gwLCB5OiB5IC0gdGhpcy5fcGFuX3kwfSk7XG4gICAgICAgICAgdGhpcy5fcGFuX3gwID0gZS5lLmxheWVyWDtcbiAgICAgICAgICB0aGlzLl9wYW5feTAgPSBlLmUubGF5ZXJZO1xuICAgICAgICAgIC8vIHZhciBkZWx0YSA9IG5ldyBmYWJyaWMuUG9pbnQoZS5lLm1vdmVtZW50WCwgZS5lLm1vdmVtZW50WSk7XG4gICAgICAgICAgLy8gdGhpcy5GYWJyaWNDYW52YXMucmVsYXRpdmVQYW4oZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuY29sb3JQaWNrZXIuYWN0aXZlKXtcbiAgICAgICAgICB0aGlzLmNvbG9yUGlja2VyLm1vdmUoZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnb2JqZWN0OnNjYWxpbmcnOiAoZSkgPT4ge1xuICAgICAgICBsZXQgb2JqID0gZS50YXJnZXQ7XG5cbiAgICAgICAgaWYob2JqLnR5cGUgPT09ICdwYXRoLWdyb3VwJyl7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHcgPSBvYmoud2lkdGggKiBvYmouc2NhbGVYO1xuICAgICAgICBsZXQgaCA9IG9iai5oZWlnaHQgKiBvYmouc2NhbGVZO1xuICAgICAgICBsZXQgcyA9IG9iai5zdHJva2VXaWR0aDtcblxuICAgICAgICBvYmouc2V0KHtcbiAgICAgICAgICAnaGVpZ2h0JyAgICAgOiBoLFxuICAgICAgICAgICd3aWR0aCcgICAgICA6IHcsXG4gICAgICAgICAgJ3NjYWxlWCcgICAgIDogMSxcbiAgICAgICAgICAnc2NhbGVZJyAgICAgOiAxXG4gICAgICAgIH0pO1xuXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfcmVtb3ZlRXZlbnRzKCl7XG4gICAgdGhpcy5GYWJyaWNDYW52YXMub2ZmKCk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0R3JpZCgpe1xuXG4gICAgaWYoIXRoaXMuY21TaXplKXtcbiAgICAgIHRocm93ICggbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KHtlcnJvcjogZXJyb3JzLnNpZGVOb1NpemV9KSkgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc3RhdGU7XG5cbiAgICBpZih0aGlzLmdyaWQpe1xuICAgICAgc3RhdGUgPSB0aGlzLmdyaWQudmlzaWJsZTtcbiAgICAgIHRoaXMuZ3JpZC5kZXN0cm95KCk7XG4gICAgICB0aGlzLkZhYnJpY0NhbnZhcy5yZW1vdmUodGhpcy5ncmlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgY20gPSB0aGlzLmNtU2l6ZTtcblxuICAgIGxldCBzdGVwWCA9IGNtLndpZHRoO1xuICAgIGxldCBzdGVwWSA9IGNtLmhlaWdodDtcblxuICAgIHRoaXMuZ3JpZCA9IG5ldyBmYWJyaWMuR3JvdXAobnVsbCwge1xuICAgICAgZXhjbHVkZUZyb21FeHBvcnQ6IHRydWUsXG4gICAgICBoYXNDb250cm9sczogZmFsc2UsXG4gICAgICBob3ZlckN1cnNvcjogJ2RlZmF1bHQnLFxuICAgICAgc2VsZWN0YWJsZTogZmFsc2VcbiAgICB9KTtcblxuICAgIGZvciAodmFyIHggPSAwOyB4IDw9IHRoaXMuRmFicmljQ2FudmFzLndpZHRoOyB4ICs9IHN0ZXBYKSB7XG4gICAgICB0aGlzLmdyaWQuYWRkKG5ldyBmYWJyaWMuTGluZShbIHgsIDAsIHgsIHRoaXMuRmFicmljQ2FudmFzLmhlaWdodF0sIHsgc3Ryb2tlOiAncmdiYSgxNTAsIDE1MCwgMTUwLCAwLjEpJywgc2VsZWN0YWJsZTogZmFsc2UsIGhvdmVyQ3Vyc29yOiAnZGVmYXVsdCcgfSkpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHkgPSAwOyB5IDw9IHRoaXMuRmFicmljQ2FudmFzLmhlaWdodDsgeSArPSBzdGVwWSkge1xuICAgICAgdGhpcy5ncmlkLmFkZChuZXcgZmFicmljLkxpbmUoWyAwLCB5LCB0aGlzLkZhYnJpY0NhbnZhcy53aWR0aCwgeV0sIHsgc3Ryb2tlOiAncmdiYSgxNTAsIDE1MCwgMTUwLCAwLjEpJywgc2VsZWN0YWJsZTogZmFsc2UsIGhvdmVyQ3Vyc29yOiAnZGVmYXVsdCcgfSkpO1xuICAgIH1cblxuICAgIHRoaXMuRmFicmljQ2FudmFzLmFkZCh0aGlzLmdyaWQpO1xuXG4gICAgdGhpcy5ncmlkLnNlbmRUb0JhY2soKTtcblxuICAgIHRoaXMuZ3JpZC5lbmFibGUgPSBmdW5jdGlvbih2YWwgPSB0cnVlKSB7XG4gICAgICB0aGlzLnNldFZpc2libGUodmFsKTtcbiAgICAgIHRoaXMuY2FudmFzLnJlbmRlckFsbCgpO1xuICAgIH07XG5cbiAgICB0aGlzLmdyaWQuc2V0VmlzaWJsZShzdGF0ZSk7XG4gICAgdGhpcy5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRSdWxlcigpe1xuXG4gICAgaWYoIXRoaXMuY21TaXplKXtcbiAgICAgIHRocm93ICggbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KHtlcnJvcjogZXJyb3JzLnNpZGVOb1NpemV9KSkgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc3RhdGU7XG5cbiAgICBpZih0aGlzLnJ1bGVyKXtcbiAgICAgIHN0YXRlID0gdGhpcy5ydWxlci52aXNpYmxlO1xuICAgICAgdGhpcy5ydWxlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLkZhYnJpY0NhbnZhcy5yZW1vdmUodGhpcy5ydWxlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IGNtID0gdGhpcy5jbVNpemU7XG5cbiAgICBsZXQgc3RlcFggPSBjbS53aWR0aDtcbiAgICBsZXQgc3RlcFkgPSBjbS5oZWlnaHQ7XG5cbiAgICB0aGlzLnJ1bGVyID0gbmV3IGZhYnJpYy5Hcm91cChudWxsLCB7XG4gICAgICBleGNsdWRlRnJvbUV4cG9ydDogdHJ1ZSxcbiAgICAgIGhhc0NvbnRyb2xzOiBmYWxzZSxcbiAgICAgIGhvdmVyQ3Vyc29yOiAnZGVmYXVsdCcsXG4gICAgICBzZWxlY3RhYmxlOiBmYWxzZVxuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgeCA9IHN0ZXBYKjI7IHggPD0gdGhpcy5GYWJyaWNDYW52YXMud2lkdGg7IHggKz0gc3RlcFgpIHtcbiAgICAgIHRoaXMucnVsZXIuYWRkKG5ldyBmYWJyaWMuTGluZShbIHgsIDAsIHgsIHN0ZXBZKjJdLCB7IHN0cm9rZTogJ3JnYmEoMCwgMCwgMCwgMC4yKScsIHNlbGVjdGFibGU6IGZhbHNlLCBob3ZlckN1cnNvcjogJ2RlZmF1bHQnIH0pKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciB5ID0gc3RlcFkqMjsgeSA8PSB0aGlzLkZhYnJpY0NhbnZhcy5oZWlnaHQ7IHkgKz0gc3RlcFkpIHtcbiAgICAgIHRoaXMucnVsZXIuYWRkKG5ldyBmYWJyaWMuTGluZShbIDAsIHksIHN0ZXBYKjIsIHldLCB7IHN0cm9rZTogJ3JnYmEoMCwgMCwgMCwgMC4yKScsIHNlbGVjdGFibGU6IGZhbHNlLCBob3ZlckN1cnNvcjogJ2RlZmF1bHQnIH0pKTtcbiAgICB9XG5cbiAgICB0aGlzLkZhYnJpY0NhbnZhcy5hZGQodGhpcy5ydWxlcik7XG5cbiAgICB0aGlzLnJ1bGVyLmVuYWJsZSA9IGZ1bmN0aW9uKHZhbCA9IHRydWUpIHtcbiAgICAgIHRoaXMuc2V0VmlzaWJsZSh2YWwpO1xuICAgICAgdGhpcy5jYW52YXMucmVuZGVyQWxsKCk7XG4gICAgfTtcblxuICAgIHRoaXMucnVsZXIuc2V0VmlzaWJsZShzdGF0ZSk7XG4gICAgdGhpcy5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0V29ya3NwYWNlR3JpZCgpe1xuXG4gICAgaWYoIXRoaXMuY21TaXplKXtcbiAgICAgIHRocm93ICggbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KHtlcnJvcjogZXJyb3JzLnNpZGVOb1NpemV9KSkgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc3RhdGU7XG5cbiAgICBpZih0aGlzLndvcmtzcGFjZUdyaWQpe1xuICAgICAgc3RhdGUgPSB0aGlzLndvcmtzcGFjZUdyaWQudmlzaWJsZTtcbiAgICAgIHRoaXMud29ya3NwYWNlR3JpZC5kZXN0cm95KCk7XG4gICAgICB0aGlzLkZhYnJpY0NhbnZhcy5yZW1vdmUodGhpcy53b3Jrc3BhY2VHcmlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgY20gPSB0aGlzLmNtU2l6ZTtcblxuICAgIHRoaXMud29ya3NwYWNlR3JpZCA9IG5ldyBmYWJyaWMuR3JvdXAobnVsbCwge1xuICAgICAgZXhjbHVkZUZyb21FeHBvcnQ6IHRydWUsXG4gICAgICBoYXNDb250cm9sczogZmFsc2UsXG4gICAgICBob3ZlckN1cnNvcjogJ2RlZmF1bHQnLFxuICAgICAgc2VsZWN0YWJsZTogZmFsc2VcbiAgICB9KTtcblxuICAgIGZvciAodmFyIHggPSB0aGlzLkZhYnJpY0JvcmRlci5sZWZ0OyB4IDw9IHRoaXMuRmFicmljQm9yZGVyLmxlZnQrdGhpcy5GYWJyaWNCb3JkZXIud2lkdGg7IHggKz0gY20ud2lkdGgpIHtcbiAgICAgIHRoaXMud29ya3NwYWNlR3JpZC5hZGQobmV3IGZhYnJpYy5MaW5lKFsgeCwgdGhpcy5GYWJyaWNCb3JkZXIudG9wLCB4LCB0aGlzLkZhYnJpY0JvcmRlci50b3ArdGhpcy5GYWJyaWNCb3JkZXIuaGVpZ2h0XSwgeyBzdHJva2U6ICdyZ2JhKDE1MCwgMTUwLCAxNTAsIDAuMiknLCBzZWxlY3RhYmxlOiBmYWxzZSwgaG92ZXJDdXJzb3I6ICdkZWZhdWx0JyB9KSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgeSA9IHRoaXMuRmFicmljQm9yZGVyLnRvcDsgeSA8PSB0aGlzLkZhYnJpY0JvcmRlci50b3ArdGhpcy5GYWJyaWNCb3JkZXIuaGVpZ2h0OyB5ICs9IGNtLmhlaWdodCkge1xuICAgICAgdGhpcy53b3Jrc3BhY2VHcmlkLmFkZChuZXcgZmFicmljLkxpbmUoWyB0aGlzLkZhYnJpY0JvcmRlci5sZWZ0LCB5LCB0aGlzLkZhYnJpY0JvcmRlci5sZWZ0K3RoaXMuRmFicmljQm9yZGVyLndpZHRoLCB5XSwgeyBzdHJva2U6ICdyZ2JhKDE1MCwgMTUwLCAxNTAsIDAuMiknLCBzZWxlY3RhYmxlOiBmYWxzZSwgaG92ZXJDdXJzb3I6ICdkZWZhdWx0JyB9KSk7XG4gICAgfVxuXG4gICAgdGhpcy5GYWJyaWNDYW52YXMuYWRkKHRoaXMud29ya3NwYWNlR3JpZCk7XG5cbiAgICB0aGlzLmdyaWQuc2VuZFRvQmFjaygpO1xuXG4gICAgdGhpcy53b3Jrc3BhY2VHcmlkLmVuYWJsZSA9IGZ1bmN0aW9uKHZhbCA9IHRydWUpIHtcbiAgICAgIHRoaXMuc2V0VmlzaWJsZSh2YWwpO1xuICAgICAgdGhpcy5jYW52YXMucmVuZGVyQWxsKCk7XG4gICAgfTtcblxuICAgIHRoaXMud29ya3NwYWNlR3JpZC5zZXRWaXNpYmxlKHN0YXRlKTtcbiAgICB0aGlzLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcblxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdFdvcmtzcGFjZVJ1bGVyKCl7XG5cbiAgICBpZighdGhpcy5jbVNpemUpe1xuICAgICAgdGhyb3cgKCBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoe2Vycm9yOiBlcnJvcnMuc2lkZU5vU2l6ZX0pKSApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZTtcblxuICAgIGlmKHRoaXMud29ya3NwYWNlUnVsZXIpe1xuICAgICAgc3RhdGUgPSB0aGlzLndvcmtzcGFjZVJ1bGVyLnZpc2libGU7XG4gICAgICB0aGlzLndvcmtzcGFjZVJ1bGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuRmFicmljQ2FudmFzLnJlbW92ZSh0aGlzLndvcmtzcGFjZVJ1bGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgY20gPSB0aGlzLmNtU2l6ZTtcblxuICAgIHRoaXMud29ya3NwYWNlUnVsZXI9IG5ldyBmYWJyaWMuR3JvdXAobnVsbCwge1xuICAgICAgZXhjbHVkZUZyb21FeHBvcnQ6IHRydWUsXG4gICAgICBoYXNDb250cm9sczogZmFsc2UsXG4gICAgICBob3ZlckN1cnNvcjogJ2RlZmF1bHQnLFxuICAgICAgc2VsZWN0YWJsZTogZmFsc2VcbiAgICB9KTtcblxuICAgIGZvciAodmFyIHggPSB0aGlzLkZhYnJpY0JvcmRlci5sZWZ0OyB4IDw9IHRoaXMuRmFicmljQm9yZGVyLmxlZnQrdGhpcy5GYWJyaWNCb3JkZXIud2lkdGg7IHggKz0gY20ud2lkdGgpIHtcbiAgICAgIHRoaXMud29ya3NwYWNlUnVsZXIuYWRkKG5ldyBmYWJyaWMuTGluZShbIHgsIGNtLmhlaWdodCwgeCwgY20uaGVpZ2h0KjJdLCB7IHN0cm9rZTogJ3JnYmEoMCwgMCwgMCwgMC4yKScsIHNlbGVjdGFibGU6IGZhbHNlLCBob3ZlckN1cnNvcjogJ2RlZmF1bHQnIH0pKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciB5ID0gdGhpcy5GYWJyaWNCb3JkZXIudG9wOyB5IDw9IHRoaXMuRmFicmljQm9yZGVyLnRvcCt0aGlzLkZhYnJpY0JvcmRlci5oZWlnaHQ7IHkgKz0gY20uaGVpZ2h0KSB7XG4gICAgICB0aGlzLndvcmtzcGFjZVJ1bGVyLmFkZChuZXcgZmFicmljLkxpbmUoWyBjbS53aWR0aCwgeSwgY20ud2lkdGgqMiwgeV0sIHsgc3Ryb2tlOiAncmdiYSgwLCAwLCAwLCAwLjIpJywgc2VsZWN0YWJsZTogZmFsc2UsIGhvdmVyQ3Vyc29yOiAnZGVmYXVsdCcgfSkpO1xuICAgIH1cblxuICAgIHRoaXMud29ya3NwYWNlUnVsZXIuYWRkKG5ldyBmYWJyaWMuTGluZShbIHRoaXMuRmFicmljQm9yZGVyLmxlZnQsIGNtLmhlaWdodCoxLjUsIHRoaXMuRmFicmljQm9yZGVyLmxlZnQrdGhpcy5GYWJyaWNCb3JkZXIud2lkdGgsIGNtLmhlaWdodCoxLjVdLCB7IHN0cm9rZTogJ3JnYmEoMCwgMCwgMCwgMC4yKScsIHNlbGVjdGFibGU6IGZhbHNlLCBob3ZlckN1cnNvcjogJ2RlZmF1bHQnIH0pKTtcbiAgICB0aGlzLndvcmtzcGFjZVJ1bGVyLmFkZChuZXcgZmFicmljLkxpbmUoWyBjbS53aWR0aCoxLjUsIHRoaXMuRmFicmljQm9yZGVyLnRvcCwgY20ud2lkdGgqMS41LCB0aGlzLkZhYnJpY0JvcmRlci50b3ArdGhpcy5GYWJyaWNCb3JkZXIuaGVpZ2h0XSwgeyBzdHJva2U6ICdyZ2JhKDAsIDAsIDAsIDAuMiknLCBzZWxlY3RhYmxlOiBmYWxzZSwgaG92ZXJDdXJzb3I6ICdkZWZhdWx0JyB9KSk7XG5cblxuICAgIHRoaXMuRmFicmljQ2FudmFzLmFkZCh0aGlzLndvcmtzcGFjZVJ1bGVyKTtcblxuICAgIHRoaXMud29ya3NwYWNlUnVsZXIuZW5hYmxlID0gZnVuY3Rpb24odmFsID0gdHJ1ZSkge1xuICAgICAgdGhpcy5zZXRWaXNpYmxlKHZhbCk7XG4gICAgICB0aGlzLmNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICB9O1xuXG4gICAgdGhpcy53b3Jrc3BhY2VSdWxlci5zZXRWaXNpYmxlKHN0YXRlKTtcbiAgICB0aGlzLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgcGl4ZWxzIGluIGNlbnRpbWV0ZXJcbiAgICogQHJldHVybiB7T2JqZWN0fSB7d2lkdGg6IE51bWJlciwgaGVpZ2h0OiBOdW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2FsY3VsYXRlU2l6ZSgpe1xuICAgIHRoaXMuY21TaXplID0ge1xuICAgICAgd2lkdGg6ICh0aGlzLmJhY2tkcm9wLndpZHRoICogdGhpcy5iYWNrZHJvcC5zY2FsZVgpIC8gdGhpcy5pbWFnZS53aWR0aCxcbiAgICAgIGhlaWdodDogKHRoaXMuYmFja2Ryb3AuaGVpZ2h0ICogdGhpcy5iYWNrZHJvcC5zY2FsZVkpIC8gdGhpcy5pbWFnZS5oZWlnaHRcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY21TaXplO1xuICB9XG5cbiAgc2V0UGFkZGluZyhudW1iZXIpe1xuICAgIGlmKHR5cGVvZiBudW1iZXIgIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG5cbiAgICB0aGlzLnBhZGRpbmcgPSBudW1iZXI7XG5cbiAgICBpZih0aGlzLmJhY2tkcm9wKXtcblxuICAgICAgaWYgKHRoaXMuYmFja2Ryb3Aud2lkdGggPj0gdGhpcy5iYWNrZHJvcC5oZWlnaHQpIHtcbiAgICAgICAgdGhpcy5iYWNrZHJvcC5zY2FsZVRvV2lkdGgodGhpcy5GYWJyaWNDYW52YXMud2lkdGggLSAodGhpcy5wYWRkaW5nICogd2luZG93LmRldmljZVBpeGVsUmF0aW8pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYmFja2Ryb3Auc2NhbGVUb0hlaWdodCh0aGlzLkZhYnJpY0NhbnZhcy5oZWlnaHQgLSAodGhpcy5wYWRkaW5nICogd2luZG93LmRldmljZVBpeGVsUmF0aW8pKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2FsY3VsYXRlU2l6ZSgpO1xuXG4gICAgICB0aGlzLl9pbml0R3JpZCgpO1xuICAgICAgdGhpcy5faW5pdFJ1bGVyKCk7XG5cbiAgICAgIGlmKHRoaXMuRmFicmljQm9yZGVyKSB7XG4gICAgICAgIHRoaXMuX2luaXRXb3Jrc3BhY2VHcmlkKCk7XG4gICAgICAgIHRoaXMuX2luaXRXb3Jrc3BhY2VSdWxlcigpO1xuXG4gICAgICAgIHRoaXMuc2V0Qm9yZGVyKHRoaXMuYm9yZGVyKVxuICAgICAgfVxuXG4gICAgICB0aGlzLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcblxuICAgIH1cblxuICB9XG5cbiAgbG9hZEZyb21KU09OKGpzb24pe1xuXG4gICAgdGhpcy5GYWJyaWNDYW52YXMubG9hZEZyb21KU09OKGpzb24sICgpID0+IHRoaXMuX3VwZGF0ZSgpKTtcblxuICB9XG5cbiAgX3VwZGF0ZSgpe1xuICAgIGlmKHRoaXMuYmFja2Ryb3ApIHtcbiAgICAgIHRoaXMuRmFicmljQ2FudmFzLmJhY2tncm91bmRJbWFnZS5zY2FsZVggPSB0aGlzLmJhY2tkcm9wLnNjYWxlWDtcbiAgICAgIHRoaXMuRmFicmljQ2FudmFzLmJhY2tncm91bmRJbWFnZS5zY2FsZVkgPSB0aGlzLmJhY2tkcm9wLnNjYWxlWTtcbiAgICB9XG4gICAgaWYodGhpcy5GYWJyaWNCb3JkZXIpIHtcbiAgICAgIHRoaXMuRmFicmljQ2FudmFzLmFkZCh0aGlzLkZhYnJpY0JvcmRlcik7XG4gICAgICB0aGlzLkZhYnJpY0JvcmRlci5zZW5kVG9CYWNrKCk7XG4gICAgfVxuICAgIGlmKHRoaXMucnVsZXIpIHtcbiAgICAgIHRoaXMuRmFicmljQ2FudmFzLmFkZCh0aGlzLnJ1bGVyKTtcbiAgICAgIHRoaXMucnVsZXIuc2V0VmlzaWJsZSh0aGlzLnJ1bGVyLnZpc2libGUpO1xuICAgIH1cbiAgICBpZih0aGlzLmdyaWQpIHtcbiAgICAgIHRoaXMuRmFicmljQ2FudmFzLmFkZCh0aGlzLmdyaWQpO1xuICAgICAgdGhpcy5ncmlkLnNldFZpc2libGUodGhpcy5ncmlkLnZpc2libGUpO1xuICAgIH1cblxuICAgIHRoaXMuRmFicmljQ2FudmFzLnJlbmRlckFsbCgpO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2lkZTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZHJhd1Rvb2wvU2lkZS5qc1xuICoqLyIsImltcG9ydCB7ZmFicmljfSBmcm9tICdmYWJyaWMnO1xuaW1wb3J0IERyYXdUb29sIGZyb20gJy4vRHJhd1Rvb2wnO1xuaW1wb3J0IEl0ZW0gZnJvbSAnLi9JdGVtJztcbmltcG9ydCBjbGlwIGZyb20gJy4vdXRpbHMvY2xpcCc7XG5cbi8qKlxuICogSXRlbXMgY29sbGVjdGlvblxuICovXG5jbGFzcyBJdGVtc3tcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHNpZGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNpZGUpe1xuICAgIHRoaXMuc2lkZSA9IHNpZGU7XG4gICAgdGhpcy5fY29sbGVjdGlvbiA9IFtdO1xuXG4gICAgdGhpcy5zZWxlY3RlZCA9IG5ldyBJdGVtKHRoaXMuc2lkZSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBMb2FkIGEgU1ZHIGltYWdlIGFuZCBwYXJzZSBhcyBGYWJyaWNKUyBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICAgKi9cbiAgYWRkU1ZHKHVybCwgZmlsbCl7XG5cbiAgICBmYWJyaWMubG9hZFNWR0Zyb21VUkwodXJsLCAob2JqZWN0cywgb3B0aW9ucykgPT4ge1xuXG4gICAgICBsZXQgbG9hZGVkT2JqZWN0ID0gZmFicmljLnV0aWwuZ3JvdXBTVkdFbGVtZW50cyhvYmplY3RzLCBvcHRpb25zKTtcblxuICAgICAgbG9hZGVkT2JqZWN0LnNldCh7XG4gICAgICAgICdsZWZ0JzogdGhpcy5zaWRlLmNlbnRlci54LFxuICAgICAgICAndG9wJzogdGhpcy5zaWRlLmNlbnRlci55LFxuICAgICAgICAnb3JpZ2luWCc6ICdjZW50ZXInLFxuICAgICAgICAnb3JpZ2luWSc6ICdjZW50ZXInLFxuICAgICAgICAnZmlsbCc6IGZpbGwgfHwgJyMwMDAwMDAnLFxuICAgICAgICBjbGlwVG86IGNsaXAoRHJhd1Rvb2wuc2lkZXMuc2VsZWN0ZWQuRmFicmljQm9yZGVyKVxuICAgICAgfSlcblxuICAgICAgaWYgKGxvYWRlZE9iamVjdC53aWR0aCA+PSBsb2FkZWRPYmplY3QuaGVpZ2h0KSB7XG4gICAgICAgIGxvYWRlZE9iamVjdC5zY2FsZVRvV2lkdGgodGhpcy5zaWRlLkZhYnJpY0JvcmRlci53aWR0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkZWRPYmplY3Quc2NhbGVUb0hlaWdodCh0aGlzLnNpZGUuRmFicmljQm9yZGVyLmhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGxvYWRlZE9iamVjdC5zZXRDb29yZHMoKTtcblxuICAgICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5hZGQobG9hZGVkT2JqZWN0KTtcblxuICAgICAgdGhpcy5fY29sbGVjdGlvbi5wdXNoKGxvYWRlZE9iamVjdCk7XG5cbiAgICAgIHRoaXMudHJpZ2dlckNyZWF0ZWQoKTtcblxuICAgICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcblxuICAgIH0pO1xuXG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhIGltYWdlIGFuZCBwYXJzZSBhcyBGYWJyaWNKUyBvYmplY3RcbiAgICogQHBhcmFtIHVybFxuICAgKi9cbiAgYWRkSW1hZ2UodXJsKXtcbiAgICBmYWJyaWMuSW1hZ2UuZnJvbVVSTCh1cmwsIChvSW1nKSA9PiB7XG5cbiAgICAgIG9JbWcuc2V0KHtcbiAgICAgICAgJ2xlZnQnOiB0aGlzLnNpZGUuY2VudGVyLngsXG4gICAgICAgICd0b3AnOiB0aGlzLnNpZGUuY2VudGVyLnksXG4gICAgICAgICdvcmlnaW5YJzogJ2NlbnRlcicsXG4gICAgICAgICdvcmlnaW5ZJzogJ2NlbnRlcicsXG4gICAgICAgIGNyb3NzT3JpZ2luOiAnYW5vbnltb3VzJyxcbiAgICAgICAgY2xpcFRvOiBjbGlwKERyYXdUb29sLnNpZGVzLnNlbGVjdGVkLkZhYnJpY0JvcmRlcilcbiAgICAgIH0pO1xuXG4gICAgICBpZiAob0ltZy53aWR0aCA+PSBvSW1nLmhlaWdodCkge1xuICAgICAgICBvSW1nLnNjYWxlVG9XaWR0aCh0aGlzLnNpZGUuRmFicmljQm9yZGVyLndpZHRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9JbWcuc2NhbGVUb0hlaWdodCh0aGlzLnNpZGUuRmFicmljQm9yZGVyLmhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIG9JbWcuc2V0Q29vcmRzKCk7XG5cbiAgICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuYWRkKG9JbWcpO1xuXG4gICAgICB0aGlzLl9jb2xsZWN0aW9uLnB1c2gob0ltZyk7XG5cbiAgICAgIHRoaXMudHJpZ2dlckNyZWF0ZWQoKTtcblxuICAgICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcblxuICAgIH0sIHtcbiAgICAgIGNyb3NzT3JpZ2luOiAnYW5vbnltb3VzJyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5mb250U2l6ZSB7TnVtYmVyfSBGb250IHNpemUgcHhcbiAgICogQHBhcmFtIG9wdGlvbnMuZmlsbCB7U3RyaW5nfSBGb250IGNvbG9yOiBSZ2IsIGhleFxuICAgKiBAcGFyYW0gb3B0aW9ucy5mb250RmFtaWx5IHtTdHJpbmd9IEZvbnQgZmFtaWx5XG4gICAqIEBwYXJhbSBvcHRpb25zLmZvbnRTdHlsZSB7U3RyaW5nfSBGb250IHN0eWxlLiBQb3NzaWJsZSB2YWx1ZXM6IFwiXCIsIFwibm9ybWFsXCIsIFwiaXRhbGljXCIgb3IgXCJvYmxpcXVlXCIuXG4gICAqIEBwYXJhbSBvcHRpb25zLmZvbnRXZWlnaHQge1N0cmluZ30gRm9udCB3ZWlnaHQgKGUuZy4gYm9sZCwgbm9ybWFsLCA0MDAsIDYwMCwgODAwKVxuICAgKiBAcGFyYW0gb3B0aW9ucy50ZXh0QWxpZ24ge1N0cmluZ30gVGV4dCBhbGlnbm1lbnQuIFBvc3NpYmxlIHZhbHVlczogXCJsZWZ0XCIsIFwiY2VudGVyXCIsIFwicmlnaHRcIiBvciBcImp1c3RpZnlcIi5cbiAgICogQHBhcmFtIG9wdGlvbnMuZWRpdGFibGUge0Jvb2xlYW59IFRleHQgY2FuIGJlIGVkaXRlZCBieSBkb3VibGUgY2xpY2suXG4gICAqIEBwYXJhbSB0eHQge1N0cmluZ30gVGV4dCBjb250ZW50XG4gICAqXG4gICAqL1xuICBhZGRUZXh0KG9wdGlvbnMsIHR4dCl7XG5cbiAgICBsZXQgX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGZvbnRTaXplOiAyNCxcbiAgICAgIGZvbnRGYW1pbHk6ICdzZXJpZicsXG4gICAgICBmb250U3R5bGU6ICdub3JtYWwnLFxuICAgICAgZm9udFdlaWdodDogJ25vcm1hbCcsXG4gICAgICBmaWxsOiAnIzAwMDAwMCcsXG4gICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgZWRpdGFibGU6IHRydWUsXG4gICAgICB2ZXJ0aWNhbDogZmFsc2UsXG4gICAgfSwgb3B0aW9ucylcblxuXG4gICAgbGV0IHRleHQgPSBuZXcgZmFicmljLlRleHRib3godHh0IHx8ICdUZXh0Jywge1xuICAgICAgbGVmdDogdGhpcy5zaWRlLmNlbnRlci54LFxuICAgICAgdG9wOiB0aGlzLnNpZGUuY2VudGVyLnksXG4gICAgICBvcmlnaW5YOiAnY2VudGVyJyxcbiAgICAgIG9yaWdpblk6ICdjZW50ZXInLFxuICAgICAgLy8gd2lkdGg6IHRoaXMuc2lkZS5GYWJyaWNCb3JkZXIud2lkdGgsXG4gICAgICBlZGl0YWJsZTogdHJ1ZSxcbiAgICAgIGNsaXBUbzogY2xpcChEcmF3VG9vbC5zaWRlcy5zZWxlY3RlZC5GYWJyaWNCb3JkZXIpLFxuICAgICAgLi4uX29wdGlvbnNcbiAgICB9KTtcblxuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuYWRkKHRleHQpO1xuXG4gICAgdGV4dC52ZXJ0aWNhbCA9IF9vcHRpb25zLnZlcnRpY2FsO1xuXG4gICAgdGhpcy5fY29sbGVjdGlvbi5wdXNoKHRleHQpO1xuXG4gICAgdGhpcy50cmlnZ2VyQ3JlYXRlZCgpO1xuXG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcblxuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuc2V0QWN0aXZlT2JqZWN0KHRleHQpO1xuXG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cblxuXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBpdGVtc1xuICAgKi9cbiAgZW1wdHkoKXtcbiAgICB0aGlzLl9jb2xsZWN0aW9uLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBpdGVtLnJlbW92ZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy50cmlnZ2VyKCdvYmplY3Q6cmVtb3ZlZCcpO1xuICAgIHRoaXMuX2NvbGxlY3Rpb24gPSBbXTtcblxuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG4gIH1cblxuICBlcmFzZXJFbmFibGUoKXtcbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLmlzRHJhd2luZ01vZGUgPSB0cnVlO1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZnJlZURyYXdpbmdCcnVzaCA9IG5ldyBmYWJyaWMuRXJhc2VyKHRoaXMuc2lkZS5GYWJyaWNDYW52YXMpO1xuICB9XG5cbiAgZXJhc2VyRGlzYWJsZSgpe1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZnJlZURyYXdpbmdCcnVzaCA9IG5ldyBmYWJyaWMuUGVuY2lsQnJ1c2hDKHRoaXMuc2lkZS5GYWJyaWNDYW52YXMpO1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuaXNEcmF3aW5nTW9kZSA9IGZhbHNlO1xuICB9XG5cbiAgcGVuY2lsQnJ1c2gob3B0aW9ucyl7XG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5mcmVlRHJhd2luZ0JydXNoID0gbmV3IGZhYnJpYy5QZW5jaWxCcnVzaEModGhpcy5zaWRlLkZhYnJpY0NhbnZhcywgb3B0aW9ucyk7XG4gICAgdGhpcy5zaWRlLmN1cnJlbnRCcnVzaCA9ICdQZW5jaWxCcnVzaCc7XG5cbiAgfVxuXG4gIGNyYXlvbkJydXNoKG9wdGlvbnMpe1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZnJlZURyYXdpbmdCcnVzaCA9IG5ldyBmYWJyaWMuQ3JheW9uQnJ1c2godGhpcy5zaWRlLkZhYnJpY0NhbnZhcywgb3B0aW9ucyk7XG4gICAgdGhpcy5zaWRlLmN1cnJlbnRCcnVzaCA9ICdDcmF5b25CcnVzaCc7XG5cbiAgfVxuXG4gIGlua0JydXNoKG9wdGlvbnMpe1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZnJlZURyYXdpbmdCcnVzaCA9IG5ldyBmYWJyaWMuSW5rQnJ1c2godGhpcy5zaWRlLkZhYnJpY0NhbnZhcywgb3B0aW9ucyk7XG4gICAgdGhpcy5zaWRlLmN1cnJlbnRCcnVzaCA9ICdJbmtCcnVzaCc7XG5cbiAgfVxuXG4gIG1hcmtlckJydXNoKG9wdGlvbnMpe1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZnJlZURyYXdpbmdCcnVzaCA9IG5ldyBmYWJyaWMuTWFya2VyQnJ1c2godGhpcy5zaWRlLkZhYnJpY0NhbnZhcywgb3B0aW9ucyk7XG4gICAgdGhpcy5zaWRlLmN1cnJlbnRCcnVzaCA9ICdNYXJrZXJCcnVzaCc7XG5cbiAgfVxuXG4gIHNwcmF5QnJ1c2gob3B0aW9ucyl7XG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5mcmVlRHJhd2luZ0JydXNoID0gbmV3IGZhYnJpYy5TcHJheUJydXNoKHRoaXMuc2lkZS5GYWJyaWNDYW52YXMsIG9wdGlvbnMpO1xuICAgIHRoaXMuc2lkZS5jdXJyZW50QnJ1c2ggPSAnU3ByYXlCcnVzaCc7XG5cbiAgfVxuXG4gIGN1c3RvbUJydXNoKG9wdGlvbnMpe1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZnJlZURyYXdpbmdCcnVzaCA9IG5ldyBmYWJyaWMuQ3VzdG9tQnJ1c2godGhpcy5zaWRlLkZhYnJpY0NhbnZhcywgb3B0aW9ucyk7XG4gICAgdGhpcy5zaWRlLmN1cnJlbnRCcnVzaCA9ICdDdXN0b21CcnVzaCc7XG4gIH1cblxuICBmaW5hbGl6ZUJydXNoKCl7XG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5mcmVlRHJhd2luZ0JydXNoLmZpbmFsaXplKCk7XG4gIH1cblxuICBicnVzaE9wdGlvbnMob3B0aW9ucyl7XG4gICAgbGV0IF9vID0ge1xuICAgICAgY29sb3I6IHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZnJlZURyYXdpbmdCcnVzaC5jb2xvcixcbiAgICAgIHdpZHRoOiB0aGlzLnNpZGUuRmFicmljQ2FudmFzLmZyZWVEcmF3aW5nQnJ1c2gud2lkdGgsXG4gICAgICBvcGFjaXR5OiB0aGlzLnNpZGUuRmFicmljQ2FudmFzLmZyZWVEcmF3aW5nQnJ1c2gub3BhY2l0eVxuICAgIH1cblxuICAgIGlmKG9wdGlvbnMgPT09IHVuZGVmaW5lZCl7XG4gICAgICByZXR1cm4gX287XG4gICAgfVxuXG4gICAgbGV0IG8gPSB7Li4uX28sIC4uLm9wdGlvbnN9O1xuXG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5mcmVlRHJhd2luZ0JydXNoLmNoYW5nZUNvbG9yKG8uY29sb3IpO1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZnJlZURyYXdpbmdCcnVzaC5jaGFuZ2VPcGFjaXR5KG8ub3BhY2l0eSk7XG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5mcmVlRHJhd2luZ0JydXNoLndpZHRoID0gby53aWR0aDtcbiAgfVxuXG4gIHRyaWdnZXJDcmVhdGVkKCl7XG4gICAgRHJhd1Rvb2wudHJpZ2dlcignaGlzdG9yeTp1cGRhdGUnLCB7c2lkZToge2lkOiB0aGlzLnNpZGUuaWR9fSk7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBJdGVtcztcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZHJhd1Rvb2wvSXRlbXMuanNcbiAqKi8iLCJpbXBvcnQge2ZhYnJpY30gZnJvbSAnZmFicmljJztcbmltcG9ydCBEcmF3VG9vbCBmcm9tICcuL0RyYXdUb29sJztcblxuY2xhc3MgSXRlbSB7XG5cbiAgY29uc3RydWN0b3Ioc2lkZSl7XG5cbiAgICB0aGlzLnNpZGUgPSBzaWRlO1xuXG4gICAgdGhpcy5pdGVtID0gbnVsbDtcblxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm4ge3t0eXBlOiBzdHJpbmcsIHRvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX1cbiAgICovXG4gIHRvT2JqZWN0KCl7XG5cbiAgICBpZighdGhpcy5pdGVtKSByZXR1cm4gZmFsc2U7XG5cbiAgICBsZXQgZGF0YSA9IHtcbiAgICAgIHR5cGU6IHRoaXMuaXRlbS50eXBlLFxuICAgICAgdG9wOiAodGhpcy5pdGVtLnRvcCAtIHRoaXMuc2lkZS5GYWJyaWNCb3JkZXIudG9wKSAvIHRoaXMuc2lkZS5jbVNpemUuaGVpZ2h0LFxuICAgICAgbGVmdDogKHRoaXMuaXRlbS5sZWZ0IC0gdGhpcy5zaWRlLkZhYnJpY0JvcmRlci5sZWZ0KSAvIHRoaXMuc2lkZS5jbVNpemUud2lkdGgsXG4gICAgICB3aWR0aDogdGhpcy5pdGVtLndpZHRoIC8gdGhpcy5zaWRlLmNtU2l6ZS53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5pdGVtLmhlaWdodCAvIHRoaXMuc2lkZS5jbVNpemUuaGVpZ2h0LFxuICAgICAgYW5nbGU6IHRoaXMuaXRlbS5hbmdsZSxcbiAgICAgIHNjYWxlOiB0aGlzLml0ZW0uc2NhbGVYLFxuICAgICAgb3BhY2l0eTogdGhpcy5pdGVtLm9wYWNpdHlcbiAgICB9XG5cbiAgICBpZih0aGlzLml0ZW0udHlwZSA9PT0gJ3BhdGgnKXtcbiAgICAgIGRhdGEuZmlsbCA9IHRoaXMuaXRlbS5maWxsO1xuICAgIH1cblxuICAgIGlmKHRoaXMuaXRlbS50eXBlID09PSAndGV4dGJveCcpe1xuICAgICAgZGF0YS5mb250RmFtaWx5ID0gdGhpcy5pdGVtLmZvbnRGYW1pbHk7XG4gICAgICBkYXRhLmZvbnRTdHlsZSA9IHRoaXMuaXRlbS5mb250U3R5bGU7XG4gICAgICBkYXRhLmZvbnRXZWlnaHQgPSB0aGlzLml0ZW0uZm9udFdlaWdodDtcbiAgICAgIGRhdGEuZm9udFNpemUgPSB0aGlzLml0ZW0uZm9udFNpemU7XG4gICAgICBkYXRhLnRleHRBbGlnbiA9IHRoaXMuaXRlbS50ZXh0QWxpZ247XG4gICAgICBkYXRhLmZpbGwgPSB0aGlzLml0ZW0uZmlsbDtcbiAgICB9XG5cbiAgICBpZih0aGlzLml0ZW0uYnJ1c2gpe1xuICAgICAgZGF0YS50eXBlID0gJ2JydXNoJztcbiAgICAgIGRhdGEuZmlsbCA9IHRoaXMuaXRlbS5jb2xvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IEpTT04gcmVwcmVzZW50YXRpb24gb2YgdG9PYmplY3QoKVxuICAgKi9cbiAgdG9KU09OKCl7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9PYmplY3QoKSk7XG4gIH1cblxuICBkZWFjdGl2YXRlKCl7XG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5kZWFjdGl2YXRlQWxsKCk7XG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICB0aGlzLml0ZW0gPSBudWxsO1xuICAgIERyYXdUb29sLnRyaWdnZXIoJ3NlbGVjdGlvbjpjbGVhcmVkJyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHNlbGVjdGVkIGl0ZW1cbiAgICovXG4gIHJlbW92ZSgpe1xuICAgIGlmKCF0aGlzLml0ZW0pIHJldHVybjtcblxuICAgIHRoaXMuaXRlbS5yZW1vdmUoKTtcbiAgICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQvc2V0IHJvdGF0aW9uIGFuZ2xlIG9mIHNlbGVjdGVkIGVsZW1lbnRcbiAgICogQHBhcmFtIHZhbFxuICAgKiBAcmV0dXJuXG4gICAqL1xuICByb3RhdGlvbih2YWwpe1xuICAgIGlmKCF0aGlzLml0ZW0pIHJldHVybjtcblxuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCl7XG4gICAgICByZXR1cm4gdGhpcy5pdGVtLmFuZ2xlO1xuICAgIH1cblxuICAgIHRoaXMuaXRlbS5zZXRBbmdsZShwYXJzZUludCh2YWwpKTtcbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbmRlckFsbCgpO1xuXG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy50cmlnZ2VyKCdvYmplY3Q6bW9kaWZpZWQnLCB7dGFyZ2V0OiB0aGlzLml0ZW19KTtcbiAgICByZXR1cm4gdGhpcy5pdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldC9zZXQgcG9zaXRpb24gb2Ygc2VsZWN0ZWQgZWxlbWVudFxuICAgKiBAcGFyYW0gb2JqXG4gICAqIEByZXR1cm5cbiAgICovXG4gIHBvc2l0aW9uKG9iail7XG5cbiAgICBpZighdGhpcy5pdGVtKSByZXR1cm47XG5cbiAgICBsZXQgcG9zaXRpb24gPSB7XG4gICAgICB0b3A6ICh0aGlzLml0ZW0udG9wIC0gdGhpcy5zaWRlLkZhYnJpY0JvcmRlci50b3ApIC8gdGhpcy5zaWRlLmNtU2l6ZS5oZWlnaHQsXG4gICAgICBsZWZ0OiAodGhpcy5pdGVtLmxlZnQgLSB0aGlzLnNpZGUuRmFicmljQm9yZGVyLmxlZnQpIC8gdGhpcy5zaWRlLmNtU2l6ZS53aWR0aCxcbiAgICB9XG5cbiAgICBpZighb2JqKXtcbiAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICBsZXQgX3Bvc2l0aW9uID0gey4uLnBvc2l0aW9uLCAuLi5vYmp9O1xuXG4gICAgbGV0IHRvcCA9IHRoaXMuc2lkZS5GYWJyaWNCb3JkZXIudG9wICsgX3Bvc2l0aW9uLnRvcCAqIHRoaXMuc2lkZS5jbVNpemUuaGVpZ2h0O1xuICAgIGxldCBsZWZ0ID0gdGhpcy5zaWRlLkZhYnJpY0JvcmRlci5sZWZ0ICsgX3Bvc2l0aW9uLmxlZnQgKiB0aGlzLnNpZGUuY21TaXplLndpZHRoO1xuXG4gICAgdGhpcy5pdGVtLmFuaW1hdGUoJ3RvcCcsIHRvcCwge1xuICAgICAgb25DaGFuZ2U6IHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsLmJpbmQodGhpcy5zaWRlLkZhYnJpY0NhbnZhcylcbiAgICB9KTtcbiAgICB0aGlzLml0ZW0uYW5pbWF0ZSgnbGVmdCcsIGxlZnQsIHtcbiAgICAgIG9uQ2hhbmdlOiB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbmRlckFsbC5iaW5kKHRoaXMuc2lkZS5GYWJyaWNDYW52YXMpXG4gICAgfSk7XG5cbiAgICB0aGlzLml0ZW0uc2V0Q29vcmRzKCk7XG5cbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbmRlckFsbCgpO1xuXG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy50cmlnZ2VyKCdvYmplY3Q6bW9kaWZpZWQnLCB7dGFyZ2V0OiB0aGlzLml0ZW19KTtcbiAgICByZXR1cm4gdGhpcy5pdGVtO1xuXG4gIH1cblxuICBzY2FsZSh2YWwpe1xuXG4gICAgaWYoIXRoaXMuaXRlbSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYodmFsID09PSB1bmRlZmluZWQpe1xuICAgICAgcmV0dXJuIHRoaXMuaXRlbS5zY2FsZVg7XG4gICAgfVxuXG4gICAgdGhpcy5pdGVtLnNjYWxlKHBhcnNlSW50KHZhbCkpO1xuXG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcblxuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMudHJpZ2dlcignb2JqZWN0Om1vZGlmaWVkJywge3RhcmdldDogdGhpcy5pdGVtfSk7XG4gICAgcmV0dXJuIHRoaXMuaXRlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgc2V0IHNpemUgb2Ygc2VsZWN0ZWQgZWxlbWVudFxuICAgKiBAcGFyYW0gb2JqXG4gICAqIEByZXR1cm5cbiAgICovXG4gIHNpemUob2JqKXtcblxuICAgIGlmKCF0aGlzLml0ZW0pIHJldHVybjtcblxuICAgIGxldCBzaXplID0ge1xuICAgICAgd2lkdGg6IHRoaXMuaXRlbS53aWR0aCAvIHRoaXMuc2lkZS5jbVNpemUud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaXRlbS5oZWlnaHQgLyB0aGlzLnNpZGUuY21TaXplLmhlaWdodFxuICAgIH1cblxuICAgIGlmKCFvYmope1xuICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuXG4gICAgbGV0IF9zaXplID0gey4uLnNpemUsIC4uLm9ian07XG5cbiAgICB0aGlzLml0ZW0uYW5pbWF0ZSgnaGVpZ2h0JywgX3NpemUuaGVpZ2h0ICogdGhpcy5zaWRlLmNtU2l6ZS5oZWlnaHQsIHtcbiAgICAgIG9uQ2hhbmdlOiB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbmRlckFsbC5iaW5kKHRoaXMuc2lkZS5GYWJyaWNDYW52YXMpXG4gICAgfSk7XG4gICAgdGhpcy5pdGVtLmFuaW1hdGUoJ3dpZHRoJywgX3NpemUud2lkdGggKiB0aGlzLnNpZGUuY21TaXplLndpZHRoLCB7XG4gICAgICBvbkNoYW5nZTogdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwuYmluZCh0aGlzLnNpZGUuRmFicmljQ2FudmFzKVxuICAgIH0pO1xuXG4gICAgdGhpcy5pdGVtLnNldENvb3JkcygpO1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG5cblxuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMudHJpZ2dlcignb2JqZWN0Om1vZGlmaWVkJywge3RhcmdldDogdGhpcy5pdGVtfSk7XG4gICAgcmV0dXJuIHRoaXMuaXRlbTtcblxuICB9XG5cbiAgZmlsbChjb2xvcil7XG5cbiAgICBpZighdGhpcy5pdGVtKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZihjb2xvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZih0aGlzLml0ZW0uYnJ1c2gpe1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtLmNvbG9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMuaXRlbS5icnVzaCl7XG4gICAgICB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLlRpbnQoe1xuICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLml0ZW0uZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAgICB0aGlzLml0ZW0uYXBwbHlGaWx0ZXJzKHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsLmJpbmQodGhpcy5zaWRlLkZhYnJpY0NhbnZhcykpO1xuICAgICAgdGhpcy5pdGVtLmNvbG9yID0gY29sb3I7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pdGVtLnNldENvbG9yKGNvbG9yKTtcbiAgICB9XG5cbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbmRlckFsbCgpO1xuXG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy50cmlnZ2VyKCdvYmplY3Q6bW9kaWZpZWQnLCB7dGFyZ2V0OiB0aGlzLml0ZW19KTtcblxuICAgIHJldHVybiB0aGlzLml0ZW07XG4gIH1cblxuICBvcGFjaXR5KHZhbCl7XG4gICAgaWYodmFsID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLml0ZW0ub3BhY2l0eTtcbiAgICB0aGlzLml0ZW0uc2V0T3BhY2l0eShOdW1iZXIodmFsKSk7XG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcblxuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMudHJpZ2dlcignb2JqZWN0Om1vZGlmaWVkJywge3RhcmdldDogdGhpcy5pdGVtfSk7XG4gICAgcmV0dXJuIHRoaXMuaXRlbTtcbiAgfVxuXG4gIC8vIFRFWFQgT1BUSU9OU1xuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gZm9udEZhbWlseSB7U3RyaW5nfVxuICAgKi9cbiAgZm9udEZhbWlseShmb250RmFtaWx5KXtcblxuICAgIGlmKCF0aGlzLml0ZW0pIHJldHVybiBmYWxzZTtcblxuICAgIGlmKHRoaXMuaXRlbS50eXBlICE9PSAndGV4dGJveCcpIHJldHVybiBmYWxzZTtcbiAgICBpZighZm9udEZhbWlseSl7XG4gICAgICByZXR1cm4gdGhpcy5pdGVtLmdldEZvbnRGYW1pbHkoKTtcbiAgICB9XG4gICAgdGhpcy5pdGVtLnNldEZvbnRGYW1pbHkoZm9udEZhbWlseSk7XG4gICAgdGhpcy5pdGVtLl9pbml0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG5cbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnRyaWdnZXIoJ29iamVjdDptb2RpZmllZCcsIHt0YXJnZXQ6IHRoaXMuaXRlbX0pO1xuICAgIHJldHVybiB0aGlzLml0ZW07XG4gIH1cblxuICBmb250U3R5bGUoZm9udFN0eWxlKXtcblxuICAgIGlmKCF0aGlzLml0ZW0pIHJldHVybiBmYWxzZTtcblxuICAgIGlmKHRoaXMuaXRlbS50eXBlICE9PSAndGV4dGJveCcpIHJldHVybiBmYWxzZTtcbiAgICBpZighZm9udFN0eWxlKXtcbiAgICAgIHJldHVybiB0aGlzLml0ZW0uZ2V0Rm9udFN0eWxlKCk7XG4gICAgfVxuICAgIHRoaXMuaXRlbS5zZXRGb250U3R5bGUoZm9udFN0eWxlKTtcbiAgICB0aGlzLml0ZW0uX2luaXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcblxuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMudHJpZ2dlcignb2JqZWN0Om1vZGlmaWVkJywge3RhcmdldDogdGhpcy5pdGVtfSk7XG4gICAgcmV0dXJuIHRoaXMuaXRlbTtcbiAgfVxuXG4gIGZvbnRXZWlnaHQoZm9udFdlaWdodCl7XG4gICAgaWYoIXRoaXMuaXRlbSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYodGhpcy5pdGVtLnR5cGUgIT09ICd0ZXh0Ym94JykgcmV0dXJuIGZhbHNlO1xuICAgIGlmKCFmb250V2VpZ2h0KXtcbiAgICAgIHJldHVybiB0aGlzLml0ZW0uZ2V0Rm9udFdlaWdodCgpO1xuICAgIH1cbiAgICB0aGlzLml0ZW0uc2V0Rm9udFdlaWdodChmb250V2VpZ2h0KTtcbiAgICB0aGlzLml0ZW0uX2luaXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcblxuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMudHJpZ2dlcignb2JqZWN0Om1vZGlmaWVkJywge3RhcmdldDogdGhpcy5pdGVtfSk7XG4gICAgcmV0dXJuIHRoaXMuaXRlbTtcbiAgfVxuXG4gIGZvbnRTaXplKGZvbnRTaXplKXtcbiAgICBpZighdGhpcy5pdGVtKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZih0aGlzLml0ZW0udHlwZSAhPT0gJ3RleHRib3gnKSByZXR1cm4gZmFsc2U7XG4gICAgaWYoZm9udFNpemUgPT09IHVuZGVmaW5lZCl7XG4gICAgICByZXR1cm4gdGhpcy5pdGVtLmdldEZvbnRTaXplKCk7XG4gICAgfVxuICAgIHRoaXMuaXRlbS5zZXRGb250U2l6ZShmb250U2l6ZSk7XG4gICAgdGhpcy5pdGVtLl9pbml0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG5cbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnRyaWdnZXIoJ29iamVjdDptb2RpZmllZCcsIHt0YXJnZXQ6IHRoaXMuaXRlbX0pO1xuICAgIHJldHVybiB0aGlzLml0ZW07XG4gIH1cblxuICB0ZXh0QWxpZ24odGV4dEFsaWduKXtcbiAgICBpZighdGhpcy5pdGVtKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZih0aGlzLml0ZW0udHlwZSAhPT0gJ3RleHRib3gnKSByZXR1cm4gZmFsc2U7XG4gICAgaWYoIXRleHRBbGlnbil7XG4gICAgICByZXR1cm4gdGhpcy5pdGVtLmdldFRleHRBbGlnbigpO1xuICAgIH1cbiAgICB0aGlzLml0ZW0uc2V0VGV4dEFsaWduKHRleHRBbGlnbik7XG4gICAgdGhpcy5pdGVtLl9pbml0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG5cbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnRyaWdnZXIoJ29iamVjdDptb2RpZmllZCcsIHt0YXJnZXQ6IHRoaXMuaXRlbX0pO1xuICAgIHJldHVybiB0aGlzLml0ZW07XG4gIH1cblxuICB0ZXh0KHRleHQpe1xuICAgIGlmKCF0aGlzLml0ZW0pIHJldHVybiBmYWxzZTtcblxuICAgIGlmKHRoaXMuaXRlbS50eXBlICE9PSAndGV4dGJveCcpIHJldHVybiBmYWxzZTtcbiAgICBpZih0ZXh0ID09PSB1bmRlZmluZWQpe1xuICAgICAgcmV0dXJuIHRoaXMuaXRlbS5nZXRUZXh0KCk7XG4gICAgfVxuICAgIHRoaXMuaXRlbS5zZXRUZXh0KHRleHQpO1xuICAgIHRoaXMuaXRlbS5faW5pdERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbmRlckFsbCgpO1xuXG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy50cmlnZ2VyKCdvYmplY3Q6bW9kaWZpZWQnLCB7dGFyZ2V0OiB0aGlzLml0ZW19KTtcbiAgICByZXR1cm4gdGhpcy5pdGVtO1xuICB9XG5cbiAgcmVtb3ZlQ29sb3IoY29sb3IsIGRpc3RhbmNlKXtcbiAgICBpZighdGhpcy5pdGVtKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZih0aGlzLml0ZW0udHlwZSA9PT0gJ3RleHRib3gnIHx8IHRoaXMuaXRlbS50eXBlID09PSAncGF0aCcpIHtcbiAgICAgIGlmKHRoaXMuaXRlbS5maWxsID09PSBjb2xvcil7XG4gICAgICAgIHRoaXMuZmlsbCgncmdiYSgwLCAwLCAwLCAwKScpXG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZXQgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZUNvbG9yKHtcbiAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZVxuICAgIH0pO1xuXG4gICAgdGhpcy5pdGVtLmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgIHRoaXMuaXRlbS5hcHBseUZpbHRlcnModGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwuYmluZCh0aGlzLnNpZGUuRmFicmljQ2FudmFzKSk7XG4gIH1cblxuICBlbnRlckVkaXRpbmcoKXtcbiAgICBpZighdGhpcy5pdGVtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYodGhpcy5pdGVtLnR5cGUgIT09ICd0ZXh0Ym94JykgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMuaXRlbS5lbnRlckVkaXRpbmcoKTtcbiAgfVxuXG4gIGV4aXRFZGl0aW5nKCl7XG4gICAgaWYoIXRoaXMuaXRlbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmKHRoaXMuaXRlbS50eXBlICE9PSAndGV4dGJveCcpIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLml0ZW0uZXhpdEVkaXRpbmcoKTtcbiAgfVxuXG4gIHRvVkNlbnRlcigpe1xuICAgIGlmKCF0aGlzLml0ZW0pIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLml0ZW0uc2V0KCd0b3AnLCB0aGlzLnNpZGUuRmFicmljQm9yZGVyLnRvcCArIHRoaXMuc2lkZS5GYWJyaWNCb3JkZXIuaGVpZ2h0IC8gMik7XG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcbiAgfVxuXG4gIHRvSENlbnRlcigpe1xuICAgIGlmKCF0aGlzLml0ZW0pIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLml0ZW0uc2V0KCdsZWZ0JywgdGhpcy5zaWRlLkZhYnJpY0JvcmRlci5sZWZ0ICsgdGhpcy5zaWRlLkZhYnJpY0JvcmRlci53aWR0aCAvIDIpO1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG4gIH1cblxuICB0b0xlZnQoKXtcbiAgICB0aGlzLml0ZW0uc2V0KCdsZWZ0JywgdGhpcy5zaWRlLkZhYnJpY0JvcmRlci5sZWZ0ICsgKHRoaXMuaXRlbS53aWR0aCp0aGlzLml0ZW0uc2NhbGVYKSAvIDIpO1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG4gIH1cblxuICB0b1JpZ2h0KCl7XG4gICAgaWYoIXRoaXMuaXRlbSkgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMuaXRlbS5zZXQoJ2xlZnQnLCB0aGlzLnNpZGUuRmFicmljQm9yZGVyLmxlZnQgKyB0aGlzLnNpZGUuRmFicmljQm9yZGVyLndpZHRoIC0gKHRoaXMuaXRlbS53aWR0aCp0aGlzLml0ZW0uc2NhbGVYKSAvIDIpO1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG4gIH1cblxuICB0b1RvcCgpe1xuICAgIGlmKCF0aGlzLml0ZW0pIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLml0ZW0uc2V0KCd0b3AnLCB0aGlzLnNpZGUuRmFicmljQm9yZGVyLnRvcCArICh0aGlzLml0ZW0uaGVpZ2h0KnRoaXMuaXRlbS5zY2FsZVkpIC8gMik7XG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcbiAgfVxuXG4gIHRvQm90dG9tKCl7XG4gICAgaWYoIXRoaXMuaXRlbSkgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMuaXRlbS5zZXQoJ3RvcCcsIHRoaXMuc2lkZS5GYWJyaWNCb3JkZXIudG9wICsgdGhpcy5zaWRlLkZhYnJpY0JvcmRlci5oZWlnaHQgLSAodGhpcy5pdGVtLmhlaWdodCp0aGlzLml0ZW0uc2NhbGVZKSAvIDIpO1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBJdGVtO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kcmF3VG9vbC9JdGVtLmpzXG4gKiovIiwiaW1wb3J0IERyYXdUb29sIGZyb20gJy4vRHJhd1Rvb2wnO1xuXG5jbGFzcyBMYXllcnMge1xuXG4gIGNvbnN0cnVjdG9yKHNpZGUpe1xuICAgIHRoaXMuc2lkZSA9IHNpZGU7XG4gICAgdGhpcy5saXN0ID0gbnVsbDtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgdXBkYXRlKCl7XG4gICAgbGV0IGxheWVycyA9IFtdO1xuXG4gICAgbGV0IG9wdCA9IHtcbiAgICAgIHF1YWxpdHk6IDAuNSxcbiAgICAgIGVuYWJsZVJldGluYTogZmFsc2VcbiAgICB9XG5cbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLmZvckVhY2hPYmplY3QoIChvYmopID0+IHtcbiAgICAgIGlmKCFvYmouZXhjbHVkZUZyb21FeHBvcnQpIHtcbiAgICAgICAgbGV0IGNsaXB0byA9IG9iai5nZXRDbGlwVG8oKTtcbiAgICAgICAgb2JqLnNldENsaXBUbyhudWxsKTtcbiAgICAgICAgbGF5ZXJzLnB1c2goe2luZGV4OiBvYmoudXVpZCwgcHJldmlldzogb2JqLnRvRGF0YVVSTChvcHQpfSlcbiAgICAgICAgb2JqLnNldENsaXBUbyhjbGlwdG8pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5saXN0ID0gbGF5ZXJzO1xuXG4gICAgcmV0dXJuIGxheWVycztcbiAgfVxuXG4gIF9nZXRJdGVtc0J5SW5kZXgoLi4uaW5kZXhlcyl7XG4gICAgbGV0IG9iamVjdHMgPSB0aGlzLnNpZGUuRmFicmljQ2FudmFzLmdldE9iamVjdHMoKS5maWx0ZXIob2JqID0+IGluZGV4ZXMuaW5jbHVkZXMob2JqLnV1aWQpICk7XG4gICAgcmV0dXJuIG9iamVjdHM7XG4gIH1cblxuICBicmluZ1RvRnJvbnQoLi4uaW5kZXhlcyl7XG4gICAgbGV0IGl0ZW1zID0gdGhpcy5fZ2V0SXRlbXNCeUluZGV4KC4uLmluZGV4ZXMpO1xuICAgIGl0ZW1zLmZvckVhY2goIGl0ZW0gPT4gaXRlbS5icmluZ1RvRnJvbnQoKSApO1xuICAgIERyYXdUb29sLnRyaWdnZXIoJ2hpc3Rvcnk6dXBkYXRlJywge3NpZGU6IHtpZDogRHJhd1Rvb2wuc2lkZXMuc2VsZWN0ZWQuaWR9fSk7XG4gIH1cblxuICBicmluZ0ZvcndhcmQoLi4uaW5kZXhlcyl7XG4gICAgbGV0IGl0ZW1zID0gdGhpcy5fZ2V0SXRlbXNCeUluZGV4KC4uLmluZGV4ZXMpO1xuICAgIGl0ZW1zLmZvckVhY2goIGl0ZW0gPT4gaXRlbS5icmluZ0ZvcndhcmQodHJ1ZSkgKTtcbiAgICBEcmF3VG9vbC50cmlnZ2VyKCdoaXN0b3J5OnVwZGF0ZScsIHtzaWRlOiB7aWQ6IERyYXdUb29sLnNpZGVzLnNlbGVjdGVkLmlkfX0pO1xuICB9XG5cbiAgc2VuZEJhY2t3YXJkcyguLi5pbmRleGVzKXtcbiAgICBsZXQgaXRlbXMgPSB0aGlzLl9nZXRJdGVtc0J5SW5kZXgoLi4uaW5kZXhlcyk7XG4gICAgaXRlbXMuZm9yRWFjaCggaXRlbSA9PiBpdGVtLnNlbmRCYWNrd2FyZHModHJ1ZSkgKTtcbiAgICBEcmF3VG9vbC50cmlnZ2VyKCdoaXN0b3J5OnVwZGF0ZScsIHtzaWRlOiB7aWQ6IERyYXdUb29sLnNpZGVzLnNlbGVjdGVkLmlkfX0pO1xuICB9XG5cbiAgc2VuZFRvQmFjayguLi5pbmRleGVzKXtcbiAgICBsZXQgaXRlbXMgPSB0aGlzLl9nZXRJdGVtc0J5SW5kZXgoLi4uaW5kZXhlcyk7XG4gICAgaXRlbXMuZm9yRWFjaCggaXRlbSA9PiBpdGVtLnNlbmRUb0JhY2soKSApO1xuICAgIERyYXdUb29sLnRyaWdnZXIoJ2hpc3Rvcnk6dXBkYXRlJywge3NpZGU6IHtpZDogRHJhd1Rvb2wuc2lkZXMuc2VsZWN0ZWQuaWR9fSk7XG4gIH1cblxuICB0b1ZDZW50ZXIoLi4uaW5kZXhlcyl7XG4gICAgbGV0IGl0ZW1zID0gdGhpcy5fZ2V0SXRlbXNCeUluZGV4KC4uLmluZGV4ZXMpO1xuXG4gICAgaXRlbXMuZm9yRWFjaCggaXRlbSA9PiBpdGVtLnNldCgndG9wJywgdGhpcy5zaWRlLkZhYnJpY0JvcmRlci50b3AgKyB0aGlzLnNpZGUuRmFicmljQm9yZGVyLmhlaWdodCAvIDIpICk7XG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcbiAgfVxuXG4gIHRvSENlbnRlciguLi5pbmRleGVzKXtcbiAgICBsZXQgaXRlbXMgPSB0aGlzLl9nZXRJdGVtc0J5SW5kZXgoLi4uaW5kZXhlcyk7XG5cbiAgICBpdGVtcy5mb3JFYWNoKCBpdGVtID0+IGl0ZW0uc2V0KCdsZWZ0JywgdGhpcy5zaWRlLkZhYnJpY0JvcmRlci5sZWZ0ICsgdGhpcy5zaWRlLkZhYnJpY0JvcmRlci53aWR0aCAvIDIpICk7XG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcbiAgfVxuXG4gIHRvTGVmdCguLi5pbmRleGVzKXtcbiAgICBsZXQgaXRlbXMgPSB0aGlzLl9nZXRJdGVtc0J5SW5kZXgoLi4uaW5kZXhlcyk7XG5cbiAgICBpdGVtcy5mb3JFYWNoKCBpdGVtID0+IGl0ZW0uc2V0KCdsZWZ0JywgdGhpcy5zaWRlLkZhYnJpY0JvcmRlci5sZWZ0ICsgKGl0ZW0ud2lkdGgqaXRlbS5zY2FsZVgpIC8gMikgKTtcbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbmRlckFsbCgpO1xuICB9XG5cbiAgdG9SaWdodCguLi5pbmRleGVzKXtcbiAgICBsZXQgaXRlbXMgPSB0aGlzLl9nZXRJdGVtc0J5SW5kZXgoLi4uaW5kZXhlcyk7XG5cbiAgICBpdGVtcy5mb3JFYWNoKCBpdGVtID0+IGl0ZW0uc2V0KCdsZWZ0JywgdGhpcy5zaWRlLkZhYnJpY0JvcmRlci5sZWZ0ICsgdGhpcy5zaWRlLkZhYnJpY0JvcmRlci53aWR0aCAtIChpdGVtLndpZHRoKml0ZW0uc2NhbGVYKSAvIDIpICk7XG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcbiAgfVxuXG4gIHRvVG9wKC4uLmluZGV4ZXMpe1xuICAgIGxldCBpdGVtcyA9IHRoaXMuX2dldEl0ZW1zQnlJbmRleCguLi5pbmRleGVzKTtcblxuICAgIGl0ZW1zLmZvckVhY2goIGl0ZW0gPT4gaXRlbS5zZXQoJ3RvcCcsIHRoaXMuc2lkZS5GYWJyaWNCb3JkZXIudG9wICsgKGl0ZW0uaGVpZ2h0Kml0ZW0uc2NhbGVZKSAvIDIpICk7XG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcbiAgfVxuXG4gIHRvQm90dG9tKC4uLmluZGV4ZXMpe1xuICAgIGxldCBpdGVtcyA9IHRoaXMuX2dldEl0ZW1zQnlJbmRleCguLi5pbmRleGVzKTtcblxuICAgIGl0ZW1zLmZvckVhY2goIGl0ZW0gPT4gaXRlbS5zZXQoJ3RvcCcsIHRoaXMuc2lkZS5GYWJyaWNCb3JkZXIudG9wICsgdGhpcy5zaWRlLkZhYnJpY0JvcmRlci5oZWlnaHQgLSAoaXRlbS5oZWlnaHQqaXRlbS5zY2FsZVkpIC8gMikgKTtcbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbmRlckFsbCgpO1xuICB9XG5cbn1cbmV4cG9ydCBkZWZhdWx0IExheWVycztcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZHJhd1Rvb2wvTGF5ZXJzLmpzXG4gKiovIiwiaW1wb3J0IHtmYWJyaWN9IGZyb20gJ2ZhYnJpYyc7XG5cbmNsYXNzIGNvbG9yUGlja2VyIHtcblxuICBjb25zdHJ1Y3RvcihzaWRlKXtcblxuICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgIHRoaXMuc2lkZSA9IHNpZGU7XG5cbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblxuICAgIHRoaXMuX2NvbG9yID0gJyMwMDAwMDAnO1xuXG4gICAgdGhpcy5jdXJzb3IgPSBuZXcgZmFicmljLkNpcmNsZSh7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgcmFkaXVzOiAyMCxcbiAgICAgIHN0cm9rZVdpZHRoOiAzLFxuICAgICAgc3Ryb2tlOiAnI2ZmZmZmZicsXG4gICAgICBvcmlnaW5YOiAnY2VudGVyJyxcbiAgICAgIG9yaWdpblk6ICdjZW50ZXInLFxuICAgICAgc2VsZWN0YWJsZTogZmFsc2UsXG4gICAgICBleGNsdWRlRnJvbUV4cG9ydDogdHJ1ZSxcbiAgICAgIGV2ZW50ZWQ6IGZhbHNlLFxuICAgICAgc2hhZG93OiBuZXcgZmFicmljLlNoYWRvdygnMnB4IDJweCAxMHB4IHJnYmEoMCwwLDAsMC4yKScpLFxuICAgICAgbG9ja1VuaVNjYWxpbmc6IHRydWVcbiAgICB9KVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXQgYWN0aXZlKHZhbHVlKSB7XG4gICAgdGhpcy5fYWN0aXZlID0gdmFsdWU7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIXZhbHVlKSB7XG4gICAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbW92ZSh0aGlzLmN1cnNvcik7XG4gICAgICB0aGlzLnNpZGUuaXRlbXMuX2NvbGxlY3Rpb24uZm9yRWFjaChvYmplY3QgPT4gb2JqZWN0LnNlbGVjdGFibGUgPSAhdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuc2lkZS5pdGVtcy5fY29sbGVjdGlvbi5mb3JFYWNoKG9iamVjdCA9PiBvYmplY3Quc2VsZWN0YWJsZSA9ICF2YWx1ZSk7XG4gICAgICB0aGlzLnNpZGUuaXRlbXMuc2VsZWN0ZWQuZGVhY3RpdmF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgfVxuXG4gIHNldCBjb2xvcihjb2xvcikge1xuICAgIGlmIChjb2xvciAhPT0gdW5kZWZpbmVkICYmIGNvbG9yKSB7XG4gICAgICB0aGlzLl9jb2xvciA9IGNvbG9yO1xuICAgICAgdGhpcy5jdXJzb3Iuc2V0RmlsbChjb2xvcik7XG5cbiAgICB9XG4gIH1cblxuICBnZXQgY29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbG9yO1xuICB9XG5cbiAgbW92ZShlKXtcbiAgICBsZXQgcG9pbnRlciA9IHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZ2V0UG9pbnRlcihlLmUpO1xuXG4gICAgdGhpcy5jb2xvciA9IHRoaXMuZ2V0Q29sb3IoZS5lLmxheWVyWCp3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbywgZS5lLmxheWVyWSp3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG5cbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbW92ZSh0aGlzLmN1cnNvcik7XG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5hZGQodGhpcy5jdXJzb3IpO1xuICAgIHRoaXMuY3Vyc29yLmJyaW5nVG9Gcm9udCgpO1xuXG4gICAgaWYoZS5lLmxheWVyWCA8IDUwIHx8IGUuZS5sYXllclkgPCA1MCl7XG4gICAgICB0aGlzLmN1cnNvci50b3AgPSBwb2ludGVyLnkgKyAzMDtcbiAgICAgIHRoaXMuY3Vyc29yLmxlZnQgPSBwb2ludGVyLnggKyAzMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdXJzb3IudG9wID0gcG9pbnRlci55IC0gMzA7XG4gICAgICB0aGlzLmN1cnNvci5sZWZ0ID0gcG9pbnRlci54IC0gMzA7XG4gICAgfVxuXG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKVxuICB9XG5cbiAgZ2V0Q29sb3IoeCwgeSl7XG5cbiAgICBsZXQgcHggPSB0aGlzLnNpZGUuRmFicmljQ2FudmFzLmNvbnRleHRDb250YWluZXIuZ2V0SW1hZ2VEYXRhKHgsIHksIDEsIDEpLmRhdGE7XG5cbiAgICByZXR1cm4gJyMnICsgbmV3IGZhYnJpYy5Db2xvcigncmdiKCcgKyBweFswXSArICcsICcgKyBweFsxXSArICcsICcgKyBweFsyXSArICcpJykudG9IZXgoKTtcbiAgfVxuXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjb2xvclBpY2tlcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2RyYXdUb29sL3V0aWxzL2NvbG9yUGlja2VyLmpzXG4gKiovIiwiaW1wb3J0IERyYXdUb29sIGZyb20gJy4vRHJhd1Rvb2wnO1xuXG5jbGFzcyBEcmF3SGlzdG9yeXtcblxuICBjb25zdHJ1Y3Rvcigpe1xuICAgIHRoaXMuaGlzdG9yeSA9IHt9O1xuICB9XG5cbiAgcHVzaFN0YXRlKGlkKXtcblxuICAgIGlmKHR5cGVvZiB0aGlzLmhpc3RvcnlbaWRdID09PSAndW5kZWZpbmVkJyl7XG4gICAgICB0aGlzLmhpc3RvcnlbaWRdID0ge1xuICAgICAgICBjb2xsZWN0aW9uOiBbXSxcbiAgICAgICAgY3VycmVudEluZGV4OiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIGxldCBzaWRlID0gRHJhd1Rvb2wuc2lkZXMuZ2V0U2lkZShpZCk7XG4gICAgbGV0IHN0YXRlID0gSlNPTi5zdHJpbmdpZnkoc2lkZS5GYWJyaWNDYW52YXMpO1xuXG5cbiAgICB0aGlzLmhpc3RvcnlbaWRdLmNvbGxlY3Rpb24gPSB0aGlzLmhpc3RvcnlbaWRdLmNvbGxlY3Rpb24uc2xpY2UoMCwgdGhpcy5oaXN0b3J5W2lkXS5jdXJyZW50SW5kZXggKyAxKVxuICAgIHRoaXMuaGlzdG9yeVtpZF0uY29sbGVjdGlvbi5wdXNoKHN0YXRlKTtcbiAgICB0aGlzLmhpc3RvcnlbaWRdLmN1cnJlbnRJbmRleCA9IHRoaXMuaGlzdG9yeVtpZF0uY29sbGVjdGlvbi5sZW5ndGggLSAxO1xuXG4gIH1cblxuICB1bmRvKGlkKXtcblxuICAgIGxldCBzaWRlID0gRHJhd1Rvb2wuc2lkZXMuZ2V0U2lkZShpZCk7XG5cbiAgICBpZighdGhpcy5oaXN0b3J5W2lkXS5jb2xsZWN0aW9uLmxlbmd0aCl7XG4gICAgICB0aGlzLmhpc3RvcnlbaWRdLmN1cnJlbnRJbmRleCA9IDA7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYodGhpcy5oaXN0b3J5W2lkXS5jdXJyZW50SW5kZXggPD0gMCl7XG4gICAgICB0aGlzLmhpc3RvcnlbaWRdLmN1cnJlbnRJbmRleCA9IDA7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHN0YXRlID0gdGhpcy5oaXN0b3J5W2lkXS5jb2xsZWN0aW9uW3RoaXMuaGlzdG9yeVtpZF0uY3VycmVudEluZGV4IC0gMV07XG4gICAgdGhpcy5oaXN0b3J5W2lkXS5jdXJyZW50SW5kZXggLT0gMTtcblxuICAgIHNpZGUubG9hZEZyb21KU09OKHN0YXRlKTtcblxuICB9XG5cbiAgcmVkbyhpZCl7XG5cbiAgICBsZXQgc2lkZSA9IERyYXdUb29sLnNpZGVzLmdldFNpZGUoaWQpO1xuXG4gICAgaWYoIXRoaXMuaGlzdG9yeVtpZF0uY29sbGVjdGlvbi5sZW5ndGgpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmKHRoaXMuaGlzdG9yeVtpZF0uY3VycmVudEluZGV4ID49IHRoaXMuaGlzdG9yeVtpZF0uY29sbGVjdGlvbi5sZW5ndGggLSAxKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgc3RhdGUgPSB0aGlzLmhpc3RvcnlbaWRdLmNvbGxlY3Rpb25bdGhpcy5oaXN0b3J5W2lkXS5jdXJyZW50SW5kZXggKyAxXTtcbiAgICB0aGlzLmhpc3RvcnlbaWRdLmN1cnJlbnRJbmRleCArPSAxO1xuXG4gICAgc2lkZS5sb2FkRnJvbUpTT04oc3RhdGUpO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgRHJhd0hpc3Rvcnk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2RyYXdUb29sL0RyYXdIaXN0b3J5LmpzXG4gKiovIiwiaW1wb3J0IHtmYWJyaWN9IGZyb20gJ2ZhYnJpYyc7XG5cbmZhYnJpYy5FcmFzZXIgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuQmFzZUJydXNoLCB7XG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gIH0sXG5cbiAgb25Nb3VzZURvd246IGZ1bmN0aW9uKHBvaW50ZXIpe1xuICAgIHRoaXMucmVtb3ZlKHBvaW50ZXIpO1xuICB9LFxuXG4gIG9uTW91c2VNb3ZlOiBmdW5jdGlvbihwb2ludGVyKXtcbiAgICB0aGlzLnJlbW92ZShwb2ludGVyKTtcbiAgfSxcblxuICBvbk1vdXNlVXA6IGZ1bmN0aW9uKHBvaW50ZXIpe1xuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24ocG9pbnRlcil7XG4gICAgbGV0IHRhcmdldHMgPSB0aGlzLmNhbnZhcy5nZXRPYmplY3RzKCkuZmlsdGVyKG9iaiA9PiB7XG4gICAgICByZXR1cm4gb2JqLmNvbnRhaW5zUG9pbnQocG9pbnRlcikgJiYgIXRoaXMuY2FudmFzLmlzVGFyZ2V0VHJhbnNwYXJlbnQob2JqLCBwb2ludGVyLngsIHBvaW50ZXIueSk7XG4gICAgfSk7XG5cbiAgICB0YXJnZXRzLmZvckVhY2gob2JqID0+IHtcblxuICAgICAgaWYob2JqLmlkICE9PSAnRmFicmljQm9yZGVyJykge1xuICAgICAgICBvYmoucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICB9KTtcbiAgfVxuXG5cbn0pO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kcmF3VG9vbC9FcmFzZXIuanNcbiAqKi8iLCJpbXBvcnQge2ZhYnJpY30gZnJvbSAnZmFicmljJztcblxuZmFicmljLnV0aWwuZ2V0UmFuZG9tID0gZnVuY3Rpb24obWF4LCBtaW4pe1xuICBtaW4gPSBtaW4gPyBtaW4gOiAwO1xuICByZXR1cm4gTWF0aC5yYW5kb20oKSAqICgobWF4ID8gbWF4IDogMSkgLSBtaW4pICsgbWluO1xufTtcblxuZmFicmljLnV0aWwuY2xhbXAgPSBmdW5jdGlvbiAobiwgbWF4LCBtaW4pIHtcbiAgaWYgKHR5cGVvZiBtaW4gIT09ICdudW1iZXInKSBtaW4gPSAwO1xuICByZXR1cm4gbiA+IG1heCA/IG1heCA6IG4gPCBtaW4gPyBtaW4gOiBuO1xufTtcblxuZmFicmljLnV0aWwudHJpbSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgdmFyIGNvcHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpLFxuICAgIHBpeGVscyA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNvbnRleHQuY2FudmFzLndpZHRoLCBjb250ZXh0LmNhbnZhcy5oZWlnaHQpLFxuICAgIGwgPSBwaXhlbHMuZGF0YS5sZW5ndGgsXG4gICAgaSxcbiAgICBib3VuZCA9IHtcbiAgICAgIHRvcDogbnVsbCxcbiAgICAgIGxlZnQ6IG51bGwsXG4gICAgICByaWdodDogbnVsbCxcbiAgICAgIGJvdHRvbTogbnVsbFxuICAgIH0sXG4gICAgeCwgeSwgaW1nO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsOyBpICs9IDQpIHtcbiAgICBpZiAocGl4ZWxzLmRhdGFbaSArIDNdICE9PSAwKSB7XG4gICAgICB4ID0gKGkgLyA0KSAlIGNvbnRleHQuY2FudmFzLndpZHRoO1xuICAgICAgeSA9IH5+KChpIC8gNCkgLyBjb250ZXh0LmNhbnZhcy53aWR0aCk7XG5cbiAgICAgIGlmIChib3VuZC50b3AgPT09IG51bGwpIHtcbiAgICAgICAgYm91bmQudG9wID0geTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJvdW5kLmxlZnQgPT09IG51bGwpIHtcbiAgICAgICAgYm91bmQubGVmdCA9IHg7XG4gICAgICB9IGVsc2UgaWYgKHggPCBib3VuZC5sZWZ0KSB7XG4gICAgICAgIGJvdW5kLmxlZnQgPSB4O1xuICAgICAgfVxuXG4gICAgICBpZiAoYm91bmQucmlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgYm91bmQucmlnaHQgPSB4O1xuICAgICAgfSBlbHNlIGlmIChib3VuZC5yaWdodCA8IHgpIHtcbiAgICAgICAgYm91bmQucmlnaHQgPSB4O1xuICAgICAgfVxuXG4gICAgICBpZiAoYm91bmQuYm90dG9tID09PSBudWxsKSB7XG4gICAgICAgIGJvdW5kLmJvdHRvbSA9IHk7XG4gICAgICB9IGVsc2UgaWYgKGJvdW5kLmJvdHRvbSA8IHkpIHtcbiAgICAgICAgYm91bmQuYm90dG9tID0geTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgdHJpbUhlaWdodCA9IGJvdW5kLmJvdHRvbSAtIGJvdW5kLnRvcDtcbiAgdmFyIHRyaW1XaWR0aCA9IGJvdW5kLnJpZ2h0IC0gYm91bmQubGVmdDtcbiAgaWYoIXRyaW1IZWlnaHQgfHwgIXRyaW1XaWR0aCl7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0cmltbWVkID0gY29udGV4dC5nZXRJbWFnZURhdGEoYm91bmQubGVmdCwgYm91bmQudG9wLCB0cmltV2lkdGgrMTAsIHRyaW1IZWlnaHQrMTApO1xuXG4gIGNvcHkuY2FudmFzLndpZHRoID0gdHJpbVdpZHRoO1xuICBjb3B5LmNhbnZhcy5oZWlnaHQgPSB0cmltSGVpZ2h0O1xuICBjb3B5LnB1dEltYWdlRGF0YSh0cmltbWVkLCAwLCAwKTtcbiAgaW1nID0gY29weS5jYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcblxuICByZXR1cm4ge1xuICAgIGltZzogaW1nLFxuICAgIGxlZnQ6IGJvdW5kLmxlZnQsXG4gICAgdG9wOiBib3VuZC50b3AsXG4gICAgd2lkdGg6IHRyaW1XaWR0aCxcbiAgICBoZWlnaHQ6IHRyaW1IZWlnaHRcbiAgfVxufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZHJhd1Rvb2wvYnJ1c2hlcy91dGlsL3V0aWwuZXh0ZW5kLmpzXG4gKiovIiwiaW1wb3J0IHtmYWJyaWN9IGZyb20gJ2ZhYnJpYyc7XG5pbXBvcnQgY2xpcCBmcm9tICcuLi8uLi91dGlscy9jbGlwJztcbmltcG9ydCBEcmF3VG9vbCBmcm9tICcuLi8uLi9EcmF3VG9vbCc7XG5cbmZhYnJpYy5CYXNlQnJ1c2gucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24oKXtcbiAgaWYoIXRoaXMubW92ZWQpIHJldHVybiBmYWxzZTtcbiAgdmFyIG9yaWdpbmFsUmVuZGVyT25BZGRSZW1vdmUgPSB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZTtcblxuICB2YXIgdnQgPSB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybTtcbiAgdmFyIHJhc3RlciA9IGZhYnJpYy51dGlsLnRyaW0odGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG5cbiAgZmFicmljLkltYWdlLmZyb21VUkwocmFzdGVyLmltZywgKG9JbWcpID0+IHtcblxuICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICB0aGlzLl9yZXNldFNoYWRvdygpO1xuXG4gICAgb0ltZy5zZXQoe1xuICAgICAgdG9wOiAocmFzdGVyLnRvcCAvIHZ0WzBdKSAtIHZ0WzVdIC8gdnRbMF0sXG4gICAgICBsZWZ0OiAocmFzdGVyLmxlZnQgLyB2dFswXSkgLSB2dFs0XSAvIHZ0WzBdLFxuICAgICAgd2lkdGg6IG9JbWcud2lkdGggLyB2dFswXSxcbiAgICAgIGhlaWdodDogb0ltZy5oZWlnaHQgLyB2dFswXSxcbiAgICAgIGJydXNoOiB0cnVlLFxuICAgICAgY29sb3I6IHRoaXMuY29sb3JcbiAgICB9KVxuXG4gICAgb0ltZy5zZXQoe1xuICAgICAgb3JpZ2luWDogJ2NlbnRlcicsXG4gICAgICBvcmlnaW5ZOiAnY2VudGVyJyxcbiAgICAgIHRvcDogb0ltZy50b3AgKyBvSW1nLmhlaWdodC8yLFxuICAgICAgbGVmdDogb0ltZy5sZWZ0ICsgb0ltZy53aWR0aC8yLFxuICAgICAgY2xpcFRvOiBjbGlwKERyYXdUb29sLnNpZGVzLnNlbGVjdGVkLkZhYnJpY0JvcmRlcilcbiAgICB9KVxuXG4gICAgdGhpcy5jYW52YXMuYWRkKG9JbWcpO1xuXG4gICAgRHJhd1Rvb2wuc2lkZXMuc2VsZWN0ZWQuaXRlbXMuX2NvbGxlY3Rpb24ucHVzaChvSW1nKTtcblxuICAgIHRoaXMuY2FudmFzLnJlbmRlckFsbCgpO1xuXG4gICAgRHJhd1Rvb2wudHJpZ2dlcignaGlzdG9yeTp1cGRhdGUnLCB7c2lkZToge2lkOiBEcmF3VG9vbC5zaWRlcy5zZWxlY3RlZC5pZH19KTtcblxuICAgIHRoaXMuY2FudmFzLnJlbmRlck9uQWRkUmVtb3ZlID0gb3JpZ2luYWxSZW5kZXJPbkFkZFJlbW92ZTtcblxuICAgIHRoaXMubW92ZWQgPSBmYWxzZTtcblxuICB9LFxuICB7XG4gICAgY3Jvc3NPcmlnaW46ICdBbm9ueW1vdXMnXG4gIH0pO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kcmF3VG9vbC9icnVzaGVzL3V0aWwvYmFzZUJydXNoLmV4dGVuZC5qc1xuICoqLyIsImltcG9ydCB7ZmFicmljfSBmcm9tICdmYWJyaWMnO1xuXG5mYWJyaWMuUG9pbnQucHJvdG90eXBlLmFuZ2xlQmV0d2VlbiA9IGZ1bmN0aW9uKHRoYXQpe1xuICByZXR1cm4gTWF0aC5hdGFuMiggdGhpcy54IC0gdGhhdC54LCB0aGlzLnkgLSB0aGF0LnkpO1xufTtcblxuZmFicmljLlBvaW50LnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbih0aGlja25lc3MpIHtcbiAgaWYgKG51bGwgPT09IHRoaWNrbmVzcyB8fCB1bmRlZmluZWQgPT09IHRoaWNrbmVzcykge1xuICAgIHRoaWNrbmVzcyA9IDE7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gdGhpcy5kaXN0YW5jZUZyb20oeyB4OiAwLCB5OiAwIH0pO1xuXG4gIGlmIChsZW5ndGggPiAwKSB7XG4gICAgdGhpcy54ID0gdGhpcy54IC8gbGVuZ3RoICogdGhpY2tuZXNzO1xuICAgIHRoaXMueSA9IHRoaXMueSAvIGxlbmd0aCAqIHRoaWNrbmVzcztcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2RyYXdUb29sL2JydXNoZXMvdXRpbC9wb2ludC5leHRlbmQuanNcbiAqKi8iLCJpbXBvcnQge2ZhYnJpY30gZnJvbSAnZmFicmljJztcblxuZmFicmljLlN0cm9rZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3Qse1xuICBjb2xvcjogbnVsbCxcbiAgaW5rQW1vdW50OiBudWxsLFxuICBsaW5lV2lkdGg6IG51bGwsXG4gIF9wb2ludDogbnVsbCxcbiAgX2xhc3RQb2ludDogbnVsbCxcbiAgX2N1cnJlbnRMaW5lV2lkdGg6IG51bGwsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oY3R4LCBwb2ludGVyLCByYW5nZSwgY29sb3IsIGxpbmVXaWR0aCwgaW5rQW1vdW50KXtcblxuICAgIHZhciByeCA9IGZhYnJpYy51dGlsLmdldFJhbmRvbShyYW5nZSksXG4gICAgICBjID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tKE1hdGguUEkgKiAyKSxcbiAgICAgIGMwID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tKE1hdGguUEkgKiAyKSxcbiAgICAgIHgwID0gcnggKiBNYXRoLnNpbihjMCksXG4gICAgICB5MCA9IHJ4IC8gMiAqIE1hdGguY29zKGMwKSxcbiAgICAgIGNvcyA9IE1hdGguY29zKGMpLFxuICAgICAgc2luID0gTWF0aC5zaW4oYyk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgdGhpcy5fcG9pbnQgPSBuZXcgZmFicmljLlBvaW50KHBvaW50ZXIueCArIHgwICogY29zIC0geTAgKiBzaW4sIHBvaW50ZXIueSArIHgwICogc2luICsgeTAgKiBjb3MpO1xuICAgIHRoaXMubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgIHRoaXMuaW5rQW1vdW50ID0gaW5rQW1vdW50O1xuICAgIHRoaXMuX2N1cnJlbnRMaW5lV2lkdGggPSBsaW5lV2lkdGg7XG5cbiAgICBjdHgubGluZUNhcCA9IFwicm91bmRcIjtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uKHBvaW50ZXIsIHN1YnRyYWN0UG9pbnQsIGRpc3RhbmNlKSB7XG4gICAgdGhpcy5fbGFzdFBvaW50ID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKHRoaXMuX3BvaW50KTtcbiAgICB0aGlzLl9wb2ludCA9IHRoaXMuX3BvaW50LmFkZEVxdWFscyh7IHg6IHN1YnRyYWN0UG9pbnQueCwgeTogc3VidHJhY3RQb2ludC55IH0pO1xuXG4gICAgdmFyIG4gPSB0aGlzLmlua0Ftb3VudCAvIChkaXN0YW5jZSArIDEpO1xuICAgIHZhciBwZXIgPSAobiA+IDAuMyA/IDAuMiA6IG4gPCAwID8gMCA6IG4pO1xuICAgIHRoaXMuX2N1cnJlbnRMaW5lV2lkdGggPSB0aGlzLmxpbmVXaWR0aCAqIHBlcjtcbiAgfSxcblxuICBkcmF3OiBmdW5jdGlvbigpe1xuICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIHRoaXMubGluZShjdHgsIHRoaXMuX2xhc3RQb2ludCwgdGhpcy5fcG9pbnQsIHRoaXMuY29sb3IsIHRoaXMuX2N1cnJlbnRMaW5lV2lkdGgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH0sXG5cbiAgbGluZTogZnVuY3Rpb24oY3R4LCBwb2ludDEsIHBvaW50MiwgY29sb3IsIGxpbmVXaWR0aCkge1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8ocG9pbnQxLngsIHBvaW50MS55KTtcbiAgICBjdHgubGluZVRvKHBvaW50Mi54LCBwb2ludDIueSk7XG5cbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn0pO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZHJhd1Rvb2wvYnJ1c2hlcy9icnVzaGVzL3N0cm9rZS5qc1xuICoqLyIsImltcG9ydCB7ZmFicmljfSBmcm9tICdmYWJyaWMnO1xuXG5mYWJyaWMuUGVuY2lsQnJ1c2hDID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLkJhc2VCcnVzaCwge1xuXG4gIGNvbG9yOiBcIiMwMDAwMDBcIixcbiAgb3BhY2l0eTogMSxcbiAgd2lkdGg6IDEsXG5cbiAgX2Jhc2VXaWR0aDogMSxcbiAgX2xhc3RQb2ludDogbnVsbCxcbiAgX2xpbmVXaWR0aDogMSxcbiAgX3BvaW50OiBudWxsLFxuICBfc2l6ZTogMCxcbiAgbW92ZWQ6IGZhbHNlLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGNhbnZhcywgb3B0ID0ge30pIHtcblxuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMud2lkdGggPSBvcHQud2lkdGggfHwgY2FudmFzLmZyZWVEcmF3aW5nQnJ1c2gud2lkdGg7XG4gICAgdGhpcy5jb2xvciA9IG9wdC5jb2xvciB8fCBjYW52YXMuZnJlZURyYXdpbmdCcnVzaC5jb2xvcjtcbiAgICB0aGlzLm9wYWNpdHkgPSBvcHQub3BhY2l0eSB8fCBjYW52YXMuY29udGV4dFRvcC5nbG9iYWxBbHBoYTtcbiAgICB0aGlzLl9wb2ludCA9IG5ldyBmYWJyaWMuUG9pbnQoKTtcblxuICAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AubGluZUpvaW4gPSAncm91bmQnO1xuICAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AubGluZUNhcCA9ICdyb3VuZCc7XG5cbiAgfSxcblxuICBjaGFuZ2VDb2xvcjogZnVuY3Rpb24oY29sb3IpIHtcbiAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gIH0sXG5cbiAgY2hhbmdlT3BhY2l0eTogZnVuY3Rpb24odmFsdWUpe1xuICAgIHRoaXMub3BhY2l0eSA9IHZhbHVlO1xuICAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZ2xvYmFsQWxwaGEgPSB2YWx1ZTtcbiAgfSxcblxuICBfcmVuZGVyOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdmFyIGN0eCwgbGluZVdpZHRoRGlmZiwgaSwgbGVuO1xuICAgIHZhciB2dCA9IHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtO1xuXG4gICAgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcDtcblxuICAgIGN0eC5zYXZlKCk7XG5cbiAgICBjdHgudHJhbnNmb3JtKHZ0WzBdLCB2dFsxXSwgdnRbMl0sIHZ0WzNdLCB2dFs0XSwgdnRbNV0pO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMub3BhY2l0eTtcbiAgICBmb3IoaSA9IDAsIGxlbiA9ICh0aGlzLl9zaXplIC8gdGhpcy5fbGluZVdpZHRoKSAvIDI7IGkgPCBsZW47IGkrKykge1xuICAgICAgbGluZVdpZHRoRGlmZiA9ICh0aGlzLl9saW5lV2lkdGggLSAxKSAqIGk7XG4gICAgICBjdHgubW92ZVRvKHRoaXMuX2xhc3RQb2ludC54ICsgbGluZVdpZHRoRGlmZiwgdGhpcy5fbGFzdFBvaW50LnkgKyBsaW5lV2lkdGhEaWZmKTtcbiAgICAgIGN0eC5saW5lVG8ocG9pbnRlci54ICsgbGluZVdpZHRoRGlmZiwgcG9pbnRlci55ICsgbGluZVdpZHRoRGlmZik7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuXG4gICAgY3R4LnJlc3RvcmUoKTtcblxuICAgIHRoaXMuX2xhc3RQb2ludCA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRlci54LCBwb2ludGVyLnkpO1xuICB9LFxuXG4gIG9uTW91c2VEb3duOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdGhpcy5fbGFzdFBvaW50ID0gcG9pbnRlcjtcbiAgICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmxpbmVXaWR0aCA9IHRoaXMuX2xpbmVXaWR0aDtcbiAgICB0aGlzLl9zaXplID0gdGhpcy53aWR0aCArIHRoaXMuX2Jhc2VXaWR0aDtcbiAgICB0aGlzLm1vdmVkID0gZmFsc2U7XG4gIH0sXG5cbiAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICBpZiAodGhpcy5jYW52YXMuX2lzQ3VycmVudGx5RHJhd2luZykge1xuICAgICAgdGhpcy5fcmVuZGVyKHBvaW50ZXIpO1xuICAgIH1cbiAgICB0aGlzLm1vdmVkID0gdHJ1ZTtcbiAgfSxcblxuICBvbk1vdXNlVXA6IGZ1bmN0aW9uKCkge31cbn0pO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZHJhd1Rvb2wvYnJ1c2hlcy9icnVzaGVzL3BlbmNpbEJydXNoLmpzXG4gKiovIiwiaW1wb3J0IHtmYWJyaWN9IGZyb20gJ2ZhYnJpYyc7XG5cbmZhYnJpYy5DcmF5b25CcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5CYXNlQnJ1c2gsIHtcblxuICBjb2xvcjogXCIjMDAwMDAwXCIsXG4gIG9wYWNpdHk6IDEsXG4gIHdpZHRoOiAzMCxcblxuICBfYmFzZVdpZHRoOiAyMCxcbiAgX2lua0Ftb3VudDogMTAsXG4gIF9sYXRlc3RTdHJva2VMZW5ndGg6IDAsXG4gIF9wb2ludDogbnVsbCxcbiAgX3NlcDogNSxcbiAgX3NpemU6IDAsXG4gIG1vdmVkOiBmYWxzZSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihjYW52YXMsIG9wdCA9IHt9KSB7XG5cbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLndpZHRoID0gb3B0LndpZHRoIHx8IGNhbnZhcy5mcmVlRHJhd2luZ0JydXNoLndpZHRoO1xuICAgIHRoaXMuY29sb3IgPSBvcHQuY29sb3IgfHwgY2FudmFzLmZyZWVEcmF3aW5nQnJ1c2guY29sb3I7XG4gICAgdGhpcy5vcGFjaXR5ID0gb3B0Lm9wYWNpdHkgfHwgY2FudmFzLmNvbnRleHRUb3AuZ2xvYmFsQWxwaGE7XG4gICAgdGhpcy5fcG9pbnQgPSBuZXcgZmFicmljLlBvaW50KDAsIDApO1xuICB9LFxuXG4gIGNoYW5nZUNvbG9yOiBmdW5jdGlvbihjb2xvcil7XG4gICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICB9LFxuXG4gIGNoYW5nZU9wYWNpdHk6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICB0aGlzLm9wYWNpdHkgPSB2YWx1ZTtcbiAgICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmdsb2JhbEFscGhhID0gdmFsdWU7XG4gIH0sXG5cbiAgb25Nb3VzZURvd246IGZ1bmN0aW9uKHBvaW50ZXIpe1xuICAgIHRoaXMuX3NpemUgPSB0aGlzLndpZHRoIC8gMiArIHRoaXMuX2Jhc2VXaWR0aDtcbiAgICB0aGlzLnNldChwb2ludGVyKTtcbiAgICB0aGlzLm1vdmVkID0gZmFsc2U7XG4gIH0sXG5cbiAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKHBvaW50ZXIpe1xuICAgIHRoaXMudXBkYXRlKHBvaW50ZXIpO1xuICAgIHRoaXMucmVuZGVyKHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICB9LFxuXG4gIG9uTW91c2VVcDogZnVuY3Rpb24ocG9pbnRlcil7fSxcblxuICBzZXQ6IGZ1bmN0aW9uKHApIHtcbiAgICBpZiAodGhpcy5fbGF0ZXN0KSB7XG4gICAgICB0aGlzLl9sYXRlc3Quc2V0RnJvbVBvaW50KHRoaXMuX3BvaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbGF0ZXN0ID0gbmV3IGZhYnJpYy5Qb2ludChwLngsIHAueSk7XG4gICAgfVxuICAgIGZhYnJpYy5Qb2ludC5wcm90b3R5cGUuc2V0RnJvbVBvaW50LmNhbGwodGhpcy5fcG9pbnQsIHApO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24ocCkge1xuICAgIHRoaXMuc2V0KHApO1xuICAgIHRoaXMuX2xhdGVzdFN0cm9rZUxlbmd0aCA9IHRoaXMuX3BvaW50LnN1YnRyYWN0KHRoaXMuX2xhdGVzdCkuZGlzdGFuY2VGcm9tKHsgeDogMCwgeTogMCB9KTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuICAgIHZhciB2dCA9IHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgIHZhciBpLCBqLCBwLCByLCBjLCB4LCB5LCB3LCBoLCB2LCBzLCBzdGVwTnVtLCBkb3RTaXplLCBkb3ROdW0sIHJhbmdlO1xuICAgIHYgPSB0aGlzLl9wb2ludC5zdWJ0cmFjdCh0aGlzLl9sYXRlc3QpO1xuICAgIHMgPSBNYXRoLmNlaWwodGhpcy5fc2l6ZSAvIDIpO1xuICAgIHN0ZXBOdW0gPSBNYXRoLmZsb29yKHYuZGlzdGFuY2VGcm9tKHsgeDogMCwgeTogMCB9KSAvIHMpICsgMTtcbiAgICB2Lm5vcm1hbGl6ZShzKTtcblxuICAgIGRvdFNpemUgPSB0aGlzLl9zZXAgKiBmYWJyaWMudXRpbC5jbGFtcCh0aGlzLl9pbmtBbW91bnQgLyB0aGlzLl9sYXRlc3RTdHJva2VMZW5ndGggKiAzLCAxLCAwLjUpO1xuICAgIGRvdE51bSA9IE1hdGguY2VpbCh0aGlzLl9zaXplICogdGhpcy5fc2VwKTtcblxuICAgIHJhbmdlID0gdGhpcy5fc2l6ZSAvIDI7XG5cbiAgICBjdHguc2F2ZSgpO1xuICAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZ2xvYmFsQWxwaGEgPSB0aGlzLm9wYWNpdHk7XG4gICAgY3R4LnRyYW5zZm9ybSh2dFswXSwgdnRbMV0sIHZ0WzJdLCB2dFszXSwgdnRbNF0sIHZ0WzVdKTtcbiAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgZm9yIChpID0gMDsgaSA8IGRvdE51bTsgaSsrKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgc3RlcE51bTsgaisrKSB7XG4gICAgICAgIHAgPSB0aGlzLl9sYXRlc3QuYWRkKHYubXVsdGlwbHkoaikpO1xuICAgICAgICByID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tKHJhbmdlKTtcbiAgICAgICAgYyA9IGZhYnJpYy51dGlsLmdldFJhbmRvbShNYXRoLlBJICogMik7XG4gICAgICAgIHcgPSBmYWJyaWMudXRpbC5nZXRSYW5kb20oZG90U2l6ZSwgZG90U2l6ZSAvIDIpO1xuICAgICAgICBoID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tKGRvdFNpemUsIGRvdFNpemUgLyAyKTtcbiAgICAgICAgeCA9IHAueCArIHIgKiBNYXRoLnNpbihjKSAtIHcgLyAyO1xuICAgICAgICB5ID0gcC55ICsgciAqIE1hdGguY29zKGMpIC0gaCAvIDI7XG4gICAgICAgIGN0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN0eC5maWxsKCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG5cbn0pO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kcmF3VG9vbC9icnVzaGVzL2JydXNoZXMvY3JheW9uQnJ1c2guanNcbiAqKi8iLCJpbXBvcnQge2ZhYnJpY30gZnJvbSAnZmFicmljJztcblxuZmFicmljLklua0JydXNoID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLkJhc2VCcnVzaCwge1xuXG4gIGNvbG9yOiBcIiMwMDAwMDBcIixcbiAgb3BhY2l0eTogMSxcbiAgd2lkdGg6IDMwLFxuXG4gIF9iYXNlV2lkdGg6IDIwLFxuICBfaW5rQW1vdW50OiA3LFxuICBfbGFzdFBvaW50OiBudWxsLFxuICBfcG9pbnQ6IG51bGwsXG4gIF9yYW5nZTogMTAsXG4gIF9zdHJva2VDb3VudDogMCxcbiAgX3N0cm9rZUlkOiBudWxsLFxuICBfc3Ryb2tlTnVtOiA0MCxcbiAgX3N0cm9rZXM6IG51bGwsXG4gIG1vdmVkOiBmYWxzZSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihjYW52YXMsIG9wdCA9IHt9KSB7XG5cbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLndpZHRoID0gb3B0LndpZHRoIHx8IGNhbnZhcy5mcmVlRHJhd2luZ0JydXNoLndpZHRoO1xuICAgIHRoaXMuY29sb3IgPSBvcHQuY29sb3IgfHwgY2FudmFzLmZyZWVEcmF3aW5nQnJ1c2guY29sb3I7XG4gICAgdGhpcy5vcGFjaXR5ID0gb3B0Lm9wYWNpdHkgfHwgY2FudmFzLmNvbnRleHRUb3AuZ2xvYmFsQWxwaGE7XG5cbiAgICB0aGlzLl9wb2ludCA9IG5ldyBmYWJyaWMuUG9pbnQoKTtcbiAgfSxcblxuICBjaGFuZ2VDb2xvcjogZnVuY3Rpb24oY29sb3Ipe1xuICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgfSxcblxuICBjaGFuZ2VPcGFjaXR5OiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgdGhpcy5vcGFjaXR5ID0gdmFsdWU7XG4gICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5nbG9iYWxBbHBoYSA9IHZhbHVlO1xuICB9LFxuXG4gIF9yZW5kZXI6IGZ1bmN0aW9uKHBvaW50ZXIpe1xuICAgIHZhciBzdWJ0cmFjdFBvaW50LCBkaXN0YW5jZSwgcG9pbnQsIGksIGxlbiwgc3Ryb2tlcywgc3Ryb2tlO1xuICAgIHRoaXMuX3N0cm9rZUNvdW50Kys7XG5cbiAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcDtcbiAgICB2YXIgdnQgPSB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybTtcblxuICAgIHBvaW50ID0gdGhpcy5zZXRQb2ludGVyKHBvaW50ZXIpO1xuICAgIHN1YnRyYWN0UG9pbnQgPSBwb2ludC5zdWJ0cmFjdCh0aGlzLl9sYXN0UG9pbnQpO1xuICAgIGRpc3RhbmNlID0gcG9pbnQuZGlzdGFuY2VGcm9tKHRoaXMuX2xhc3RQb2ludCk7XG4gICAgc3Ryb2tlcyA9IHRoaXMuX3N0cm9rZXM7XG5cbiAgICBjdHguc2F2ZSgpXG4gICAgY3R4LnRyYW5zZm9ybSh2dFswXSwgdnRbMV0sIHZ0WzJdLCB2dFszXSwgdnRbNF0sIHZ0WzVdKTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBzdHJva2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzdHJva2UgPSBzdHJva2VzW2ldO1xuICAgICAgc3Ryb2tlLnVwZGF0ZShwb2ludCwgc3VidHJhY3RQb2ludCwgZGlzdGFuY2UpO1xuICAgICAgc3Ryb2tlLmRyYXcoKTtcbiAgICB9XG5cbiAgICBpZiAoZGlzdGFuY2UgPiAzMCkge1xuICAgICAgdGhpcy5kcmF3U3BsYXNoKHBvaW50LCB0aGlzLl9pbmtBbW91bnQpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpXG4gIH0sXG5cbiAgb25Nb3VzZURvd246IGZ1bmN0aW9uKHBvaW50ZXIpe1xuICAgIHRoaXMuX3Jlc2V0VGlwKHBvaW50ZXIpO1xuICAgIHRoaXMuX3N0cm9rZUlkID0gK25ldyBEYXRlKCk7XG4gICAgdGhpcy5tb3ZlZCA9IGZhbHNlO1xuICB9LFxuXG4gIG9uTW91c2VNb3ZlOiBmdW5jdGlvbihwb2ludGVyKXtcbiAgICBpZih0aGlzLmNhbnZhcy5faXNDdXJyZW50bHlEcmF3aW5nKXtcbiAgICAgIHRoaXMuX3JlbmRlcihwb2ludGVyKTtcbiAgICB9XG4gICAgdGhpcy5tb3ZlZCA9IHRydWU7XG4gIH0sXG5cbiAgb25Nb3VzZVVwOiBmdW5jdGlvbigpe1xuICAgIHRoaXMuX3N0cm9rZUNvdW50ID0gMDtcbiAgICB0aGlzLl9zdHJva2VJZCA9IG51bGw7XG4gIH0sXG5cbiAgZHJhd1NwbGFzaDogZnVuY3Rpb24ocG9pbnRlciwgbWF4U2l6ZSkge1xuICAgIHZhciBjLCByLCBpLCBwb2ludCxcbiAgICAgIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3AsXG4gICAgICBudW0gPSBmYWJyaWMudXRpbC5nZXRSYW5kb20oMTIpLFxuICAgICAgcmFuZ2UgPSBtYXhTaXplICogMTAsXG4gICAgICBjb2xvciA9IHRoaXMuY29sb3I7XG5cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMub3BhY2l0eTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICAgIHIgPSBmYWJyaWMudXRpbC5nZXRSYW5kb20ocmFuZ2UsIDEpO1xuICAgICAgYyA9IGZhYnJpYy51dGlsLmdldFJhbmRvbShNYXRoLlBJICogMik7XG4gICAgICBwb2ludCA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRlci54ICsgciAqIE1hdGguc2luKGMpLCBwb2ludGVyLnkgKyByICogTWF0aC5jb3MoYykpO1xuXG4gICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKHBvaW50LngsIHBvaW50LnksIGZhYnJpYy51dGlsLmdldFJhbmRvbShtYXhTaXplKSAvIDIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9LFxuXG4gIHNldFBvaW50ZXI6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB2YXIgcG9pbnQgPSBuZXcgZmFicmljLlBvaW50KHBvaW50ZXIueCwgcG9pbnRlci55KTtcblxuICAgIHRoaXMuX2xhc3RQb2ludCA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZSh0aGlzLl9wb2ludCk7XG4gICAgdGhpcy5fcG9pbnQgPSBwb2ludDtcblxuICAgIHJldHVybiBwb2ludDtcbiAgfSxcblxuICBfcmVzZXRUaXA6IGZ1bmN0aW9uKHBvaW50ZXIpe1xuICAgIHZhciBzdHJva2VzLCBwb2ludCwgbGVuLCBpO1xuXG4gICAgcG9pbnQgPSB0aGlzLnNldFBvaW50ZXIocG9pbnRlcik7XG4gICAgc3Ryb2tlcyA9IHRoaXMuX3N0cm9rZXMgPSBbXTtcbiAgICB0aGlzLnNpemUgPSB0aGlzLndpZHRoIC8gNSArIHRoaXMuX2Jhc2VXaWR0aDtcbiAgICB0aGlzLl9zdHJva2VOdW0gPSB0aGlzLnNpemU7XG4gICAgdGhpcy5fcmFuZ2UgPSB0aGlzLnNpemUgLyAyO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5fc3Ryb2tlTnVtOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHN0cm9rZXNbaV0gPSBuZXcgZmFicmljLlN0cm9rZSh0aGlzLmNhbnZhcy5jb250ZXh0VG9wLCBwb2ludCwgdGhpcy5fcmFuZ2UsIHRoaXMuY29sb3IsIHRoaXMud2lkdGgsIHRoaXMuX2lua0Ftb3VudCk7XG4gICAgfVxuICB9XG59KTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2RyYXdUb29sL2JydXNoZXMvYnJ1c2hlcy9pbmtCcnVzaC5qc1xuICoqLyIsImltcG9ydCB7ZmFicmljfSBmcm9tICdmYWJyaWMnO1xuXG5mYWJyaWMuU3ByYXlCcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5CYXNlQnJ1c2gsIHtcblxuICBjb2xvcjogXCIjMDAwMDAwXCIsXG4gIG9wYWNpdHk6IDEsXG4gIHdpZHRoOiAzMCxcblxuICBfYmFzZVdpZHRoOiA0MCxcbiAgX2RyaXBzOiBbXSxcbiAgX2RyaXBUaHJlc2hvbGQ6IDE1LFxuICBfaW5rQW1vdW50OiAwLFxuICBfaW50ZXJ2YWw6IDIwLFxuICBfbGFzdFBvaW50OiBudWxsLFxuICBfcG9pbnQ6IG51bGwsXG4gIF9zdHJva2VJZDogMCxcbiAgYnJ1c2g6IG51bGwsXG4gIHNwcmF5QnJ1c2hEYXRhVXJsOiBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBVmNBQUFGdENBWUFBQUhFMXhsRkFBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFLVDJsRFExQlFhRzkwYjNOb2IzQWdTVU5ESUhCeWIyWnBiR1VBQUhqYW5WTm5WRlBwRmozMzN2UkNTNGlBbEV0dlVoVUlJRkpDaTRBVWtTWXFJUWtRU29naG9ka1ZVY0VSUlVVRUc4aWdpQU9Pam9DTUZWRXNESW9LMkFma0lhS09nNk9JaXNyNzRYdWphOWE4OStiTi9yWFhQdWVzODUyenp3ZkFDQXlXU0ROUk5ZQU1xVUllRWVDRHg4VEc0ZVF1UUlFS0pIQUFFQWl6WkNGei9TTUJBUGgrUER3cklzQUh2Z0FCZU5NTENBREFUWnZBTUJ5SC93L3FRcGxjQVlDRUFjQjBrVGhMQ0lBVUFFQjZqa0ttQUVCR0FZQ2RtQ1pUQUtBRUFHRExZMkxqQUZBdEFHQW5mK2JUQUlDZCtKbDdBUUJibENFVkFhQ1JBQ0FUWlloRUFHZzdBS3pQVm9wRkFGZ3dBQlJtUzhRNUFOZ3RBREJKVjJaSUFMQzNBTURPRUF1eUFBZ01BREJSaUlVcEFBUjdBR0RJSXlONEFJU1pBQlJHOGxjODhTdXVFT2NxQUFCNG1iSTh1U1E1UllGYkNDMXhCMWRYTGg0b3pra1hLeFEyWVFKaG1rQXV3bm1aR1RLQk5BL2c4OHdBQUtDUkZSSGdnL1A5ZU00T3JzN09ObzYyRGw4dDZyOEcveUppWXVQKzVjK3JjRUFBQU9GMGZ0SCtMQyt6R29BN0JvQnQvcUlsN2dSb1hndWdkZmVMWnJJUFFMVUFvT25hVi9OdytINDhQRVdoa0xuWjJlWGs1TmhLeEVKYlljcFhmZjVud2wvQVYvMXMrWDQ4L1BmMTRMN2lKSUV5WFlGSEJQamd3c3owVEtVY3o1SUpoR0xjNW85SC9MY0wvL3dkMHlMRVNXSzVXQ29VNDFFU2NZNUVtb3p6TXFVaWlVS1NLY1VsMHY5azR0OHMrd00rM3pVQXNHbytBWHVSTGFoZFl3UDJTeWNRV0hUQTR2Y0FBUEs3YjhIVUtBZ0RnR2lENGM5My8rOC8vVWVnSlFDQVprbVNjUUFBWGtRa0xsVEtzei9IQ0FBQVJLQ0JLckJCRy9UQkdDekFCaHpCQmR6QkMveGdOb1JDSk1UQ1FoQkNDbVNBSEhKZ0theUNRaWlHemJBZEttQXYxRUFkTk1CUmFJYVRjQTR1d2xXNERqMXdEL3BoQ0o3QktMeUJDUVJCeUFnVFlTSGFpQUZpaWxnampnZ1htWVg0SWNGSUJCS0xKQ0RKaUJSUklrdVJOVWd4VW9wVUlGVklIZkk5Y2dJNWgxeEd1cEU3eUFBeWd2eUd2RWN4bElHeVVUM1VETFZEdWFnM0dvUkdvZ3ZRWkhReG1vOFdvSnZRY3JRYVBZdzJvZWZRcTJnUDJvOCtROGN3d09nWUJ6UEViREF1eHNOQ3NUZ3NDWk5qeTdFaXJBeXJ4aHF3VnF3RHU0bjFZOCt4ZHdRU2dVWEFDVFlFZDBJZ1lSNUJTRmhNV0U3WVNLZ2dIQ1EwRWRvSk53a0RoRkhDSnlLVHFFdTBKcm9SK2NRWVlqSXhoMWhJTENQV0VvOFRMeEI3aUVQRU55UVNpVU15SjdtUUFrbXhwRlRTRXRKRzBtNVNJK2tzcVpzMFNCb2prOG5hWkd1eUJ6bVVMQ0FyeUlYa25lVEQ1RFBrRytRaDhsc0tuV0pBY2FUNFUrSW9Vc3BxU2hubEVPVTA1UVpsbURKQlZhT2FVdDJvb1ZRUk5ZOWFRcTJodGxLdlVZZW9FelIxbWpuTmd4WkpTNld0b3BYVEdtZ1hhUGRwcitoMHVoSGRsUjVPbDlCWDBzdnBSK2lYNkFQMGR3d05oaFdEeDRobktCbWJHQWNZWnhsM0dLK1lUS1laMDRzWngxUXdOekhybU9lWkQ1bHZWVmdxdGlwOEZaSEtDcFZLbFNhVkd5b3ZWS21xcHFyZXFndFY4MVhMVkkrcFhsTjlya1pWTTFQanFRblVscXRWcXAxUTYxTWJVMmVwTzZpSHFtZW9iMVEvcEg1Wi9Za0dXY05NdzA5RHBGR2dzVi9qdk1ZZ0MyTVpzM2dzSVdzTnE0WjFnVFhFSnJITjJYeDJLcnVZL1IyN2l6MnFxYUU1UXpOS00xZXpVdk9VWmo4SDQ1aHgrSngwVGdubktLZVg4MzZLM2hUdktlSXBHNlkwVExreFpWeHJxcGFYbGxpclNLdFJxMGZydlRhdTdhZWRwcjFGdTFuN2dRNUJ4MG9uWENkSFo0L09CWjNuVTlsVDNhY0tweFpOUFRyMXJpNnFhNlVib2J0RWQ3OXVwKzZZbnI1ZWdKNU1iNmZlZWIzbitoeDlMLzFVL1czNnAvVkhERmdHc3d3a0J0c016aGc4eFRWeGJ6d2RMOGZiOFZGRFhjTkFRNlZobFdHWDRZU1J1ZEU4bzlWR2pVWVBqR25HWE9NazQyM0diY2FqSmdZbUlTWkxUZXBON3BwU1RibW1LYVk3VER0TXg4M016YUxOMXBrMW16MHgxekxubStlYjE1dmZ0MkJhZUZvc3RxaTJ1R1ZKc3VSYXBsbnV0cnh1aFZvNVdhVllWVnBkczBhdG5hMGwxcnV0dTZjUnA3bE9rMDZybnRabnc3RHh0c20ycWJjWnNPWFlCdHV1dG0yMmZXRm5ZaGRudDhXdXcrNlR2Wk45dW4yTi9UMEhEWWZaRHFzZFdoMStjN1J5RkRwV090NmF6cHp1UDMzRjlKYnBMMmRZenhEUDJEUGp0aFBMS2NScG5WT2IwMGRuRjJlNWM0UHppSXVKUzRMTExwYytMcHNieHQzSXZlUktkUFZ4WGVGNjB2V2RtN09id3UybzI2L3VOdTVwN29mY244dzBueW1lV1ROejBNUElRK0JSNWRFL0M1K1ZNR3Zmckg1UFEwK0JaN1huSXk5akw1RlhyZGV3dDZWM3F2ZGg3eGMrOWo1eW4rTSs0enczM2pMZVdWL01OOEMzeUxmTFQ4TnZubCtGMzBOL0kvOWsvM3IvMFFDbmdDVUJad09KZ1VHQld3TDcrSHA4SWIrT1B6cmJaZmF5MmUxQmpLQzVRUlZCajRLdGd1WEJyU0ZveU95UXJTSDM1NWpPa2M1cERvVlFmdWpXMEFkaDVtR0x3MzRNSjRXSGhWZUdQNDV3aUZnYTBUR1hOWGZSM0VOejMwVDZSSlpFM3B0bk1VODVyeTFLTlNvK3FpNXFQTm8zdWpTNlA4WXVabG5NMVZpZFdFbHNTeHc1TGlxdU5tNXN2dC84N2ZPSDRwM2lDK043RjVndnlGMXdlYUhPd3ZTRnB4YXBMaElzT3BaQVRJaE9PSlR3UVJBcXFCYU1KZklUZHlXT0NubkNIY0puSWkvUk50R0kyRU5jS2g1TzhrZ3FUWHFTN0pHOE5Ya2t4VE9sTE9XNWhDZXBrTHhNRFV6ZG16cWVGcHAySUcweVBUcTlNWU9Ta1pCeFFxb2hUWk8yWitwbjVtWjJ5NnhsaGJMK3hXNkx0eThlbFFmSmE3T1FyQVZaTFFxMlFxYm9WRm9vMXlvSHNtZGxWMmEvelluS09aYXJuaXZON2N5enl0dVFONXp2bi8vdEVzSVM0WksycFlaTFZ5MGRXT2E5ckdvNXNqeHhlZHNLNHhVRks0WldCcXc4dUlxMkttM1ZUNnZ0VjVldWZyMG1lazFyZ1Y3QnlvTEJ0UUZyNnd0VkN1V0ZmZXZjMSsxZFQxZ3ZXZCsxWWZxR25ScytGWW1LcmhUYkY1Y1ZmOWdvM0hqbEc0ZHZ5citaM0pTMHFhdkV1V1RQWnRKbTZlYmVMWjViRHBhcWwrYVhEbTROMmRxMERkOVd0TzMxOWtYYkw1Zk5LTnU3ZzdaRHVhTy9QTGk4WmFmSnpzMDdQMVNrVlBSVStsUTI3dExkdFdIWCtHN1I3aHQ3dlBZMDdOWGJXN3ozL1Q3SnZ0dFZBVlZOMVdiVlpmdEorN1AzUDY2SnF1bjRsdnR0WGExT2JYSHR4d1BTQS8wSEl3NjIxN25VMVIzU1BWUlNqOVlyNjBjT3h4KysvcDN2ZHkwTk5nMVZqWnpHNGlOd1JIbms2ZmNKMy9jZURUcmFkb3g3ck9FSDB4OTJIV2NkTDJwQ212S2FScHRUbXZ0YllsdTZUOHcrMGRicTNucjhSOXNmRDV3MFBGbDVTdk5VeVduYTZZTFRrMmZ5ejR5ZGxaMTlmaTc1M0dEYm9yWjc1MlBPMzJvUGIrKzZFSFRoMGtYL2krYzd2RHZPWFBLNGRQS3kyK1VUVjdoWG1xODZYMjNxZE9vOC9wUFRUOGU3bkx1YXJybGNhN251ZXIyMWUyYjM2UnVlTjg3ZDlMMTU4UmIvMXRXZU9UM2R2Zk42Yi9mRjkvWGZGdDErY2lmOXpzdTcyWGNuN3EyOFQ3eGY5RUR0UWRsRDNZZlZQMXYrM05qdjNIOXF3SGVnODlIY1IvY0doWVBQL3BIMWp3OURCWStaajh1R0RZYnJuamcrT1RuaVAzTDk2ZnluUTg5a3p5YWVGLzZpL3N1dUZ4WXZmdmpWNjlmTzBaalJvWmZ5bDVPL2JYeWwvZXJBNnhtdjI4YkN4aDYreVhnek1WNzBWdnZ0d1hmY2R4M3ZvOThQVCtSOElIOG8vMmo1c2ZWVDBLZjdreG1Uay84RUE1anovR016TGRzQUFBQWdZMGhTVFFBQWVpVUFBSUNEQUFENS93QUFnT2tBQUhVd0FBRHFZQUFBT3BnQUFCZHZrbC9GUmdBQThtdEpSRUZVZU5yVW1WbHY2ellRaFllVXZDYk43UWIwLy8rOEFyZDdFdHNTS2ZhaFo5TFBFOGwya055SEdCQ3NoU0puaG9kbnpsQ3B0V2FmNVpmdEUvMzZXeHVtbE40MTBFZk1ZTHFsay9jYStsSEdYelgyQXd4Tlp0WXVYTjlzZkg2bm9Rbi84YkNaLzNqK2JUQWJvaEtqMCtSNEN2Y2F6djAzWFFyTXBRajNiNGhxTklUM09oaVhaVkNuLzRaMk5INFdEbStHd1FWRGU3MlRaVXpTdlU3MzduUzlOYk0xeGtobXR0SjVNN1A5RWp3dVFTOWZ3YUpoMEE0Um8vRS93NkFzUS8zNVJ1MVhlTGMzczJQbzR3d3FTd2EvWW9QUU1HRzZNcUxqQSs3TnJPcTYxL2xheDJCbUo5MS9raE9EbVJVZDB3S21GeGtpWDFsTVBEb001RkRZeWJBbVkzNVNPMU83SCtYZ0NwRmM0MzhsWis1dllZcitTbFF0VE4vV3pKNDF2Zjc4WG0xOHFyZHdwb2RCRDJaMjBIdFZ6d2M5TzJBMlhsZ25wWFFXM1JjWUxCanFVZG9wVW5jYXZLbHpYMWlqN204Qm13SWNtNkF3eXFHcVp3YzU3N1BXY1A0S0R2MkY2VGNaZDlRQUh0bW1hQjZ4ZU81bVdNT3hQS0t2Wm1hUGlMb0g0cURyWjcxM0U4OFNuMWtHN1hSdnA2T2l6UVkweHY0bUdPSDNQVnJmNlowLzFPNms2eWM1UGk1eGNKNlorZ3hNWlVUR2dEbVBiaTg0T0dZN09PWnRITU5PWTZPT2pkN3h0aXNzdnBpMi80OUUrZyt3TGVSeXg2aWZyMkg4QTlvN1ZqMWhuSkFvSFBjbnRlL1Y1NmgzT2pQN0MrMk9nTkFyU3V0RCtzdEltd2tlUndvYUZKRWVOTVRNeGhueHhVZ1cyR0RhdlovZmtYaDZVT1FVWVpDQzhNakFqNy93QkNlWVN2ZWdxQTRPTVlIME11b2VZL1hxZDZPSXJ0QjNnYU9icFFYbTFORXBDbCtRdmZiUUFqMDh6aUVGRzJZb2c2b21HRmNSd1NkQkk0c3BIaEVvRTRUT0l0c0hpZWRpNHhHODZzcXFBakk3VEh0Y0ZOUUxhMEJoQWtaWE1uNFNiUlhBWlpFTnlHMittSHpGL2dDb2RHSEJUUXNwY2s2VWQyQ0VMYktpS1REM2l2QUVXS1U1WTZmQXJ3WFIvUldwdEEvdmRtK29BQklXVjFSeDd2aWZ3THFMblpmc21tZTR0VVBPSDh6c0YwUW5neUZNTUxFTHltbU9MeHV5bXkrMEJKNTlRR1RQZ3BDRFdLbFFWbi9yK2grMVdjbDQ1ODBSYWZaYVJlSG4wMHc2YlRnMnltd1dlVCtsZEpiQktzVHpGckt0QkhxYnE2RjR2MTBSOUQ3dEZUTmFGSWdLSHMvQmtSY01Pc1dNd1hCaTV4azZ3UWMvZ3ZTWHRIRUxSV1VKZFZzTzRuMEx3WE9tRVFpRGpKVytEZUNuU2lxNlB5Q05IckVvbzZFY3NDQ1NGcUo2UkwrUGdTSlRGRElOZ3VSWkwva2dYM1UrS1BvVmk2TUE3OVBNMUU4d3pNK0g0RndOc0dnQmRtM08yQVNSNFZ6cmxjRlhxUDZLeFJJSGJzaFdFeUxuampMVmpxRE5BVWEzT2EyZFp3ckRDYXFlU1dOclpyL0JDSU9SQjdGR3dXcWZ3dUNNWEEyT0ZLaXhpcUF0cWk0TGFYTFU4d0hZNlpFY1JvaU9OZm9ZQWp4R3BPd0pFUzA0VGdyUUVLQndWdHJNaWU4R0xYREFGSTBDdnVmd0VhcStncE1UdUxsQXB4NGcrd29Ncm9BZXRXeU9OVmhxclMwVml5dThzQUpwcjFBbFRNZzhPZFJlTmRDaVlab0xERDBwQUh6MmtqeFkzZlorWTJZWGhBUnRadmE5T3ZSaU1VTXhGZWlIbUtFS3l1NkNxQTZZd1VkZ2VscmN2RHVyeTgvTG00YW9SbTJ3UTdXN2h3QTZ5WmthMHZnSUk0NG92dytRaFNYUTVhc2RtYVh0b3dTdnExYXFZMnN2QjA3QVdRYzRWQ3k0QVZGTldFeUd5cGZDdkY3YVBwcmQrWWJCVlAzYzg5cGdNNklMdUUwUTg5ek1jSVk1Z1phbUpiRTlhOWZTNW0wd09FRStscUJGSjVRL3NhSnduVHFFemJnR0JWZHUvZVp3NnplRkZBcTlnckptQ0JLUDFYRUZOTWFRSENiVVd1Mldid3Z2K1ZxVGd1TFBNNEs3b1N4dm9TcXhXNmIremNiZTRFQ2FLZWw3UkpHNDdLNHRwQTgzZHNHQnRMQVA4U0VmOE5LMytIYTd3TmZ2L3RLWVB0T0g1bjhCQUFELy8reWJXMjhiT1F5RktXa3VzZE1HYUlFKzdmLy9jd3NzRm0xYXgzT1Q5cUhpOWh1T1pJK2Q1S2sxRU5nSmJGbWl5RVB5SE1iOVVjWGY2ZEhjRWZrM1A5N3E5cHIzZERFTkx1ZmMzWEIxVHdZcnVVOHNiZXc5TFgrdktwNEszWVVZN3V1YWNubXptMTByWlBaOG9iMWlYeXVlcFN3Njc3YXczK2w3QXJvekZYZ0JCeG96b1JnWGxJK3U4dm5kRnZZM1dKVnlmQU4rMVJ1NlZDbDUxc0p6UlF4OFhZQ1pUc0ViSWpuS2VyYWdOVDFUaDljdE5DNW5TSTJMdlZiVk5hK280dGI2RFh5MEFjZktPblpCblJweUcvUjNGdXUrdzIwbTR3YnhwdUliRzZXc3BCczR3Q0tQS0o3SFRBQVBSbmJxTTMrZ0t1V0V1cFlGKzFSQmxub1BaamJxWVlFV0hVRUV3L2dCaXoraVJWSEI0d1ZXZjg0ZGJaczNML21aMHRXbVN0dTdXWUV3TVVIak91S2FIOUNwUHFCSDZ3cFhQTXV2NlkwWCtMSmtocjBEMTF2ZGNDbmRCcnhaYVIxQmZ4L1JqcmZvZG1jRTB3R2NsN2JhK3JkUDJYZDEwd2RZKzNwdGdHS1pnTTVaZ1M1dld0bStCaTZSSUZnc1Jpa2NjYUFGeVVQUjVTbTdTRENkNy85eHd3R0pwcEErazlHb25rQm9IRTJDYUhGb3R1RlVFdlVBTXc2c24vc0JsSGlTbi9ydFVzdHdqUUh2Z0d2V2lQMmFlYTRHb08vZ0VnMFltQVNzVFVDQkJmNVB6VlpaR3ZveDIvaFY2bTV5WU9tSFIxQ1VLbUVlREcrbGh6dm05L1htSmlJZ3o3SXREbjZxRUhZU2tiK3lwSFF5N1h3c0JaZzNwUEdFZkQva0t4cU55RFlBdmdMVUhRcHpFUWxqTkhGQVBQNEhmajVKWmZURW05U3ExdWpsNTR3QnYrd0pCVWtBVkQwQTJnaC9EWDVtZk9hWTErbmhBcG9WQTF4cFU3czBGMkRyR1ZGTWpxdXIrSzhybElNZXFERVpQWUd6Q2twL0ttMjZsRkt3TndqQTdQVWxuNzdISmprR0ZYQVRwVTdCRzBLdnp4dnJFWkFlYVZnUm9wZktxQitGNWdsKzg1ajlTS0RHT0ZtUG1YVG1zSHZLL1dDdU9wcDFUOGhrbTNyWEkyaFVtRGhsL0ZQaWQwQkFUSUMzQWRKU3JRZExCYktPb3dBQkZqM0tyMkVMbHFjYkNaLzZWWURROFRGYjRMTkJBV1locVd4ME1RRXl3d2Y1ck83eEFzanpOVFFnQXgxUTZTdkd0b2pZVU9KVXpldlJCS3RONVkzQjVRbXcxeG5ZUzBRWlgxQVhsd3pRaThHN0NJcmRHK0dOais1Q0w4ZHh2eG4xaEtiaWYyVTdkeE90WlJrZ1U3NytNZWRxaFp5enJHVjkxYkJTeGRMSkNCMFJpV0UwZ29mUFVObmgvWnZaV2wrNFN2VWZoUmxheFU1dWZzZTFueXA4UW84REJWaVdnMnFqV1Y4S3o2dUcwSnZUVGdEb0VXNUNDVi9ibWdYWFQwQlgxeGx4RXhNc3ZrREVvOHpFNjk5WWxwTnl6RmlxMTlKaXM3SHduSzl3Z1A5UzBvejRYYTA3NE5CcUVJNmpMaVU0REJXV1pRYXNIQ0FONlFJUDZIQzlySWZZS1NZNytDbG5FM2xUWitCN05CekZxclh4K1VXUzdWQ09Ob2JmWkQzVG1oQUVWTFdqc1JZdEtiSVdvTlU5dnVhMXpxYVZWMHl2OW1EMmZ3WUdRSTNQQzM5QXBYVkdBZDBZNllqdXBKMXNRTDFLUDJXNWVDcFpkclhacklvbncxOEZCSW1XZXQrQWc2T3Bxcnp4TmJ2T2hBNTN4dFZycGp1YjlIMVp1eTJRSE02UWF2cS9Cc2Y4TStTV0o1Z3VJbUtORXpLVHB0UWYrZlVFSzBmajk3dFVjV2RLUHdyT0xkaVpnRXIvakJUYUczQm5nZVFSK1FMTGJsSjNpVDVxTGxSS0REeVBzbzd0eVRPaVg2OTVrTFZHeTVvMUdsUW8xU2h2UWlhM0tMb2Y4NlkvZ3VQU0RFUWhtbnlCUndjN1lxMzVHbTIwUzFNb1VFcXNTUzI3NkJGTUl1czVtZEZrcFZocVc2NngzN2VxNHM1a093NjJPOFBOdHZEYnppUVdNZVdqU3pzMjhocFYzRlUyUzhKa01uRDRLbzNzemVSUVkzMTNLVmp1L2M0M2swTlRTbUpTZDFGSyttMVU4ZjhBQUFELy8reWRXM1BiUmd5RnNieklraTlwbStuLy80T2RKRE9KeDVZb2NyY1BGc3B2ajNZcHlaYWJ1Rk8vMklydGtBS3hCOEFCY1B5aGJ2WWpmVFQvbStCOVBxN2F3SCtQOWZlM1lOT0hob0ozTW1hSk9IdlRRTU8vL1NDYW4yelVrclJBWDZGUGxUKytLcFJkMjBHdU5ZWjRyaEd0a0JscXlXYVNwS254Sjhrd2E2TTZaNGxWdkpmM05sYzJhamp4YjQwZGIvbTJoV1pCUURtcUQ2TkhIVTErdkNTaUVXeGhHbWZwL2IzVmc1c0xEUm9xUGY0R3BVR1JweFEyT29ER1lTdUhkT1lnaHZiUDkxTGtrWXRkZ3h0b0N2Um9hU1AwWGVEaFVtV2VVditBcFlzV2pHN0FQWGlyVHFyaXp2SXA1bVR6TE1JQTBtUnYrWmhXWnk4RDhUOXdQNVBsNDlxbDdlemFBMDlMeHIwVUhpNGRRUXgyUEpJUXhDaDZ6TG55Zld2eld0a2tCYkFiMFp0QVBoR3dFK093QzliaklXM3R1TnNhTEo4Q0lHRjVZMWlTdHJ5Wk5MMFZmOC9sWVVvWGowSnZjUDE5c3JuWEhXQXdicGF2YmU2cStTYVpzNzArTGJNQ0FaVU9IdnFJNndSNzZTUDVydlVqanZ6TzhybVJyZVdMaHY1d29zMERBMm5CZ1M0eThMbHNYQTFzZWptRzNGNm5nSUV6ZDNzWTBjbGRYeWwxUXoxWTNzV0xNUFNEelIxb1p3U2Q3UDBOR1A3RjV0NkNONTQ1enpYQ3lJMFFIRDBJdVZjYmQybFRhU255ay9Kc0JSWVk2VzhGejMyYjN5ZnJSaGl4QTY5N0IyeWQ4R2FUR0trWFdQaUJyT0VKUjM5OThHd0ttYmhEY0dPYXN4TlJIR2gvQ1RSMEZhTUd5U1BaY0ltNEFVYjZEcDVKK1lObmU5RnY4dXVSWi9aZE9BOXN0K0w1dkFaMzRWb3BKQnd2TjhCNmh4WTMwcDNsUWhXTzZhNG9NMXErNHN0SmhuRUpMaThaUWxWNm1KV1BCeFR2MjNpZ2NlRVdHaWNpVUhpYm1lUEJhM3RwVU4xYXJ1UVJwWERRYVFVZTRjYnlzU0F1SCs0UkdBMDQ2ak41enpaM2tybUh6VzNpcGFuMXF1ZldES3VMaXIzbFU0NWNqV3ZnTmU0WmZsTnIrWDZTbEl0amRTdDRSNHNBNktOSXBlWEdaUGw4VEFLOHFINlJhOGw0LzhyeC9hdEFnUmNuM3kwZmhBeUZiT0VmN0ZYRGRoVmFYZGY2YUlRaytNa1U2RStiSjVBLzJUeTQ2MGVVbnE0YUcxUk5DekErUjJBWVdLaFJGOFhvbE9GcWdjK081VDN3MmxQQUZZS3JTbmFOY29Mc1ZEV25VOU04OXIxNFJDY0o5d3FleE5IQmU3emVXTjRHYTVIK2VHUDlzODB0WVQ4WkxrR245eEtBZlF4b0NnbEpnazJ3dkl2MWRQajZtODFkWFovbEdBNG41Ukh2M2VHdnRlTWgxVlNGZ29OUjJheE1oWnErczF4Rmk0VEl2UngvLy84MjhPNUJLakl2QUxndmt2Q3dHam1HVVg2Zk02QTdnUUtlTk1mYUZTckFBYWVFQTYrZUk5L1ppOXdPQnhhOHkzd2tORk1OWGlBQWt1Q29JYVh5Vk1uVGw4SG05ZnBQTm10V3RYTGtvdVdqYjF4MTdwRnArTVA2Y3ZCaUdqWVZ5SmlJRTZXQnpTVHc3UEE5ZWp3MU5aNXNuZ256OFNwL0hlVEV4Q1Z2VmNPVzFweVV1T0JRVDROODFFVVg5M2FzTGtIQ1kxWHdWcjJHUWxKdFgweXhMbG8rbGtWbzhOLy9KaEFUY1pKOG1PT2J6Y01kVzhzM0FnYkF3aituWW1sb28xVGpkemd5dmVXVGRoSFlkQ00vUHdGUGt4UU1RY2pxVUdDY2t0VjMyWlJSbzBPMEFsY1JIdWJmZjRBM2t3QnFBUzg5dlBoM213VlhJZ0paU2RLc2FGaTkrUVlSM0FTWHFGbldpTEU3bTFYbktNK2d4WWJPR1ljVGhQU1RWSEhLdFVZNVpYelRQUjQ2UHhNdVBOLzljZmkvUHRtOHB1UXA1Q091eGVsaUx4SlNpWS9WSWV5OTVkTTRudXIwZUhxK3plT0xNTjhSVFgxc2pxcU52VlJUbWlJdHNScTN0YnhjN2x2VmZGZVdUODBseVc0YVFKSlB6ZjF4TVBCblFNRm91UVlTaDgzTURwdEpKY05TaVlRZXRFZndpaWdCbVpkNkVMZy9wRThicEM5SkFneWZlRWxPdTBhVVQ1WE9RSTFYWlRhd3QxeS90dlFRS2REcm80Wi9BZFlNNWJFL3NFNnF0Y0JHUUNNM28zdGtJM0pJUDBKUHVHRTdlS3YvN2dQd2JRVk93RWtNRjRtSzBqRklGWXpWN2UzYStIZ292RzV3elpWNE1EbUlBVG5zaUFweWtKOGY0TzJqOU42T3NwZW0wREpocWRoSkJHUysyRXBTclVwek84dUhUS2xidlVWeVA0bVhuYUlxVCsyVWtHZTlBWGV4eDlIdXJhejE3c0hzUWJLV1p4aDFhOGNTNnVGVXowdkgyclRWL0FRbWlhbVY1MzJENVZwc1VUQ0pmYWhua005N1NmaVg4RFpWUENVSXpkY0tqZGtpMFdleVB3azVIb1hNM3hZWXJxYm1xU1dNMWVOSDQ3cDNiY1JUM2RndW1XbUNvL3JtdHBJZDdDMFhhWm9zbDJ4TEM4WlZ5T0RYRGdFN0JGdkN5Z0JqQlVCYkMyeW0yRmtwZHc1TERkbXUwdWNQY1B2Vzh2bHlUMUU2M01DZDVUcU9HL0hhRHJnNkZucGlXOUNPaEtXMk1GdVFDaFhZVkVuQnlLdHl0bGdYVVZUa2NoVFk4K3hIbTZkbVN5cHlsWEZkNmpoTWx1OHA5N2lSRzVEUWF3UXRxblJIRUN3S01VeDNuS0JaRjRvTFZWbW02Q2FwUnU3N05aS0g2ejcvRmhCR0xtSTRHREpZTHU0ZGhTT3BTazExbFFtUzBqUUtuNHp6bVNOdXlqbFBhc0VITUZ5ajVmc0IycDExellHOVVJTXNURVlyNjJBdy9lSXBISVgyYzBQNGhzWXpVaWNTTThUVkhhNVBpZVBGVWVxbFAwRVFKS0F4MXcwb0VQeWlmeHh1MUJmZmJ4QVExaEs0dVBFY0VIRWpjc1ZPK21tVEhlL3lNZ013S1Z3U0FxektabmlYNFJIdnhadWJYd3V3c3dOeEhrdUdQVWZGWW1sRWFHWEhrdkpza1ZBaVpvOXBselh5d2cwZ0pBbXAzVmd1bHNJVWFMTDhqd2RNZHF6c0hTWGxZbHFvbWNEZThpVy9hTWNyUHlZUC9LUXN5RGs5cjFKRnRNYlJKOUhCMVYyT0cvRXZmQVI4ZllmQTErSG54Z0l4WTVaci9EbDhyQXRGVFZPQUN3YW1aUGtlS3dzRGg3Sjc0T3RnWlMzWHE3Uy9hNE51MGZJVjVnSDBZV3U1ZXVobmVQQUdHTHFCTWU4RVlxSk0wcGhncWtuMU05cXg5bkdTR1lFQTVtb0xqOS9ic1pyMG9pajV0UVkyTlBmbDJwTkt1eExrVjlMTGN1YUlQYVVFK3JFcEVCemNNT1VzZ1VrM0lRa3ZtK1Q0YzEyV3VmTW94enhXb0dXUjJMNTRkcXZTRDlQNVZOWEJJZis2d3VjR1BhVU8zcmtEd2NPTzdUT0k2UjdCcVJGNnNMTmp6WEtuRzN1VXBEc2Mrd0dUT2s5eS83RVcrZDlGVXJRQ0VZMVVXc1JqRGtZa3kzV25lbmhyQTdhb2x6WjBrQ05OVFArT1hEa0ppeFVzWDFXT2t1a3d4ZXFFV3JUWEhQOVhHN2Jnd2VrRUJtdUxaNUphM2wvZlMvZTBLOEJDQytPdVVMR3RKWXF2TFI4YlRWSnBwUVh5eHE1aDFGY2I5Z1FXMS9RUGRXT1VXSzBDQ3oyQ0hlazZRMW5OQ202UVlFY3FsTE5ZSmZuRHF4bnpxb2E5SU9qcGxFMGpxWXoycjBZcFRWMnhyUU8yOHVlU2NBYnBESzg4S3lmOUpRejd4Z2VoQ1g5dGQxUjEvRXBFMHJzYjc1YzI3Q3VDWlZyZ045SzFqL1IvMHJDdmdKbWY0cDBmM3JBZjZlTnY5czUxdDQwa2g4THM2bTVKdHV6TXptSjMzdi8xRmxoZ05wT01kZW5iL29nSWYzV2ExWkpzMlhBQ0d4Z2tHZHRTaThYaTVaQTgvQlRzRzMxOVRuOS9DdlpUc0o5ZjlndnhGWHcwWC9FV0REWWY0dXVuSjRKNHBWQnZUZTZ3K0hydktleVB5ckR4MDJ0NCtnQkNMZkVNbEw2MzlQdVgvUDlmSmlxNDVnTnFtMVBFeW5IcFFwRHBtbWU0OWMxTDc2Q3QwNEpHOHZ1TlBGTnR5OVFqT3R5MnBPblRUNkd4VjU2dTlsM1ZCV0d6dUtpN2Rwc3p6Njg5WjJjUnI5TG51cFhtcGplKzhqcjd5dm1zZEVhYkhOeld5VWdPaUxBYXNUVHplbitOV2JxRmNHOHBXTFdMcWZBelZYQ04yV1hOUDFsT0lTT3BOM2x3bG9DL3Exd3d1dzl0Q3VTcVZJVXJyK1FLMFhya1pQRStCZGRTSDdaVFJsWDJYN0gwenE3dzFzN3p2NXgxYXE4MUMra0dHaG81aU9uTVZhZmQ5UVlNWjlKd0ltc2Yxdk9mV1ZuZVRHZVdGd1RKRTYwT01ObWNKdUJqYU95WnRxTXEwTXhSek1QSzVsTXZhenlIVjF0WjVxWnd2QmRNT3c3ZDNuYVdELys1K1RDYkU2YVZKaUZ2Wm0vVEM0U2FMS2FDNWdPT2xyZkpONWEzZkxKVm5zM0laRFpxOGUrdFBiZnBQNXordnJWOG10RC9VMGZuV3Z3UWFQbjBnczkvdTVSMllXMXhGTlpFUVR4M016Y1NRbWxqcnlKdjNvTGtyVVRLNmJVL2VmMnZsbys5c3ptWnJVZlJ0T1RObXpiU2hVS05TQnI1THQ2WHRiWjhBYUJldTFIQ0tHK3YvMTNzcWZmVmVoY2pYNWUzd3J2R24vQjY5M0pyL0ZrWWtpV0xxZnZlRDRRNXMyUTdDclhJUEtUc0dVZkxwNy9wOVRrckZrMUQrbmk4OThDeWM3dUhBSS9RWkIvV0lOdlNMdEJzc3d0NFg2N1Iya3NJelVvajkycG5kUmxTYS9uMlBBNDFrMzV2c0IvcnJ2NjA1eTd4MnZLaGo1M2wvYTEzMEZDLzZrZUppMzNFeVBmTWJleVpybyt0OWJURE4wUENybVdLNCtrbW0yOVk3U1NySWpkTFpYa0g5d2FDMlZrK0x1b0NkN0tkZ3owUFFLOWdNcnhqMEplWWJVNy83eXNPeFJ1TnVTZUh3eDdhQzN0Ukt2eml2YnJWWEtxYTcxZHkvUTlpSjN2UllyZkI3cUc5WmI0NWFTeEovdGNTVlhpTSttOW9xMGNOZmdBZUpmaWlpeWNJemcvKzN2SmhGVTBrYW91bk1tOFRiZ1hNbTh6NWxYMlRjN2YzOHJvK1ZiMnhINTNjTGlULzgvdEpVNy9DT2ZsbVJqcXJCOHZiOHg4UXIvNkI2TVBEdXQ5UFArUDBLRnZZNmNieVptaE9PWktUc1FSZlhoU0NYVVBCbDhRMmp2aWdHL3N4RUxGR09NV1poTUh5dVFMUDkzZjRmUSs3ZkM4TXU2OTlzTG0xK2NSNkIvUGlwSkZQK04yL0VHVk00Z0FIZVMyek9RdHpiVmZ3YlJVMXRpRFUxdkxwUWc0alQ5Q3dCaC9VTmRVZFVpZEJ2STk1UHB6Ky9RaWN3TTBLOXpZMkF1TDRMWG1FeWVoaGFuNno1N2I3ZjV6K1Rlby9iZW12Qk5neHkwZGRTK244WlJvYjdBdFJaSDlsOC9sWXQxbGJhQTJ2cjdmTit6VzdQLzNjSFY3Ynd6R3VGU1VSbVhJcUpoeHFpK2pBV2Q1SVZHSDJ6QkJIemdYeUdYTEprSUkraStPZDBWZXpFRjVOY2kxTUJFQzZKTStPL0JvN04reldjakllbnZ6V2NxYTNHcUZXaHhDTmc4SXJ1YjQ2MDN1UXYzT1hrSWQ1Qjh0SmVlc2dJdUJNeGJnazNCSnBaRnBBclJyeG5yNm1lZ2ZEUCtERGs4K1Z6QlMwYjBlWUI2YWRianM5TEx1WFRFa0JjNDZkSm9SdXV2cVNvMUdQdUQzT0F2cUlBL2VEMHVWazloSmtMSnBNTE5IZEs0czdVU2EzanpzSVp5Tk9ZVzF6amkxbVFCdkxkOWVOTnVlSEhhR2hCTXk1ZzVTOEEvNzZPMmprTjJqamQ5eVVKOHRueFpRMWI3akdKQ3pOMGxZQmVNM0J1QkVCdVUrcGZKRlQ5eEdrRWIrWEFnZWhReG0xelhscnlVMUFBS1ZHR3R0SnFNVE5oNlBFdVdSRTVsYkZKR1prZkltdFRRdkllaXVsRU0vRkh5MGZCenBZdm1QYWMvUzlDSEZsK1pCeEpMd0dkcjhKbktnZnpscjhBMWRMS3ZlczM0WTFYdjlmbGs4dHJ1QS90T0JaWFZDZlczWmVZbWM3c1ZHRy9EdmhBeWFrcEI1RGtzQjNqZXZLdExKREprYm5SdEt6VHFBL09xK0UxK2JxNnhVMFRkbVBhcGdEOGlxTUVsWU53UzJLekVGUjJBM1MxMmtCWngzeHdNNmNRVy9MSVdRU256MUtXWVFZcVVZYWpkaFc4bmV2SklZbHBrcWNsa1ZFM1p0QVVvbU5IQVpYaTBjM3Q1TlVlRGlud1ZGZGZwSlQ2b0hlYzR4VHFaYjk5TmVXODhLTWtvNVdZbU1iU1VmcGxWdng4UHFNdmFCbE9zNmt5cEdrRlA1aytXTFlTUklGMXVVcStUelRwVmhCSmNBdldTME9TRC9KQkxlQmxrN1E1RUVFU1ErL0VkdElUZTNGQm04UVVqVVFOa084R3Y4L3lkOGJZQVFrYnYvdDlMdjNNRnRISEs0dW8rZ3NaMmllemlVSmpRaDVGUEMzc1h5anhoNG8wUUJ2MmdERnZ3c09xN1U1ZjBCak9RbHZFcnZvNXVNeHFBalFyS3hGSTVWT2tPU1hkb3BjRHBhdjRhYmpHdUNvRDJKMzEySXl5cVlBc2F2eXNWYVdUMkNQbHRNNmN5dHdPajN3RmcrNWhwMmJKRk9xTGQ5ZjMrRHdGUFNwQWdndkJmLzJaR1FsNzJ2eS9rZUJCMnZjZ2p0RUVRbmFYdGw4Ly9sRnBtQ3ltTGYxaUpQbHFoTUhPaVlwMXBIZTdvQ3N5NlIwblVTcmVIV3RBRmN5U2FrbDNhNmszRTJnZkdYemFYTkgwVmFXVXd2Nk9wWUdEbFViVUdxTDZXRm5ncTBLOXRad0JWY0FULzRuSDNwQTJHWElnRFpCVFltMmRySTVNOUlrMmppSnR0SVAxUEt6bzhVc3lCV3U5cjNFem1UWGJQSDhJN0NFYUlxOHQrVm12UmxzUm43VkhtK21ZTWthS2VZZHdyQUpNR0N5K2NieWhIUzN0Zm5pOEdxaElVUmJNNStrWUpra1M2cHR6dVo1dEh6NzBpaUZ6d3FKUmlNcHJsZUFPMEtLUzNpc2ZnaDY5RjYwcVRsaG16Mktmd2NwMEhVMkg1RzNRSU9UL0gwQ3ZLY3BkU1RnYmFIMHM0TFF5RlBBcnBpTmhIUTlpcFFyVkhPcG5lNjhzOGlnVkVsb2dpdFh5N1ZsTGw3QlB0M2p5cE9pZWJDY3JHeVNqcFZTTGFrQ3NxWDhoYVZTTzIrZXJqTWg4SzJJV0F2SDI0bERUa0RuV0dKdnhEd3NabC9SdXZFZW5uSUV1azhtakozbGhPYzdjVFFrWmpqZ2U1MGNuSjFCNXF1RkErRHZhTk15S3dvYkNGS1RFZTJwZGNhNER1R2tCYWpYV1pJSlhrVTJOZ3hTaHQ1REN6WndIcXpFYmdOa2l4bU53V1kzUWZwcEN6WjJXdERhcU9KcUVtMW9JMG1Ic2pocmNPM3B4dHhaVHRiRy9vTmVNdFBRSEpEeXJvSkhKMFMyZ2UyZDdNY0NpRHZMbVpDM2x1OE1NQWlaM3JtUktLQ1MrTFowdGFvRmpZMVFPdDNIV0VrVXdoYW9ScW9HUk9Hb0NPUytqV0wvMlFNTUJkT2d6UTRlSVArRzJwUS96RGNjakhKZmtiMmRETzFIbXpjbW01MmZkb20wTjNKeTdNQWh3ZTRvZVBKb09iWGdkL0VMbllSYityNXRwTFVwYUZiUW1nL1hrZm9hRkVPVmRVSjh1RUVrd1RZZjB2NVBsalBPUjJUbnRwRGRSRkZNRllTTnZXQ3VUS01IeTVkUEVKbmJJSHRrbUJYZEdwcUdUTGhKSGxEN21VaWMrT1gwQnYreGZEY3NLZXM2bkg0blBRYnNOdVRxcDVMZ1ZBdi90REp4OENUbzAyRHhtcFJPaXBIdVdOY0lzeW84ZjR2K0J5MlRUeGJ6ZzJkeDdDUVlKOWt4dmI3L1A1emVIaldpUmlvTkEyenBJQkhCSkJxVWdxdGM4cmkvRjNCaXBaL1dENm9ESVFrSHZjYm42UVgvNEx3RDkrSTJsdk1sSmp2REtzODlydVFROUNLaFl3VC9QZG1oUHl6bnNkWmxFQlJ3SlJXSXlzcExJaTRwZjFTMnZGTEZQd09URFZhSDEzakc3M2ltZ3oydmJXM1Izc1Rpb3ZZZWhLRmpzako3bXAveU43eVJiNWJ6Um9rcThLcXRORlpvN0xjU3dNU0NITnpFM3BlYUtLcUNJNXVRbmEyQ2VGVXhCb1VibmFPN1BSM09RUkllVGI5bldodWRPSy9uVnNLTkFaam1UcTcyM3ZKOUxwM0ZleEFPU0NpMFZha09iRzFhQ01VbU9SaFdGaHJMRjFjYzROMzVlU3J4RlJyMzFwWnYwak9ic3lQUE9CTkx0aTFKdWppZXdpeC91SCtlVHZJTGZuY3JQUWRWVU8raTl0eEpMSjBLNGRPNVRSMVZRYk43T2ZpRXcyYm81ZjIzL05NQTNKdk5XZWVIVXYrRmd6S3BrTVdNY2wxYWUyNzY5ZldqM2tia0RxNUQzWXZYbURzWFdjZC9zdm1HajFMdHJRVEdsQnplS0lyQm5nUldualZ4WWV2OUpzQ1JJL3hpdXFTWU9BVWdDUkV1bjFDaHgrZlkwRjRxQm53dFhrZHFWSkxDb0JWc2FtbTdKcS9oMy9KYUI0bG5UVXJkSkVFZmcxdmFTTE9IQ2ZCZEJMdFRZUGhITWVxMU5EWWt5NGNtdU1Ka1pYbWJaaEloNnp3Q3l4MXN6K3dMY2EwVmdHeXpmT2ZDSUVtT1dkNmpwV2FRZUhPTC9naVRkSjVNeU5WU3RUWnlER3pmSVVqaFR1bTdPQ0ttaHJVOTkyKzFObDlYWXBiM3RpckplQVY3ZGpoVFc2b3NIb1licFJMUncySCtLVzFKdllEeFp2a0dwYjNsczJtMVJEa1hiVWZpRDlhQ1BBMldrNCtQTVBRVDRsT21pQ1p4N2lBZmhCblJQckN0SzRzWEM2a2RuY1NNY05NemVic2R1ZHJadkFXVUk2ZUdqSXh6QzB2NDhMUlUvcTRDWUVadElJY3ZPTlRoMzN1UzJ2NWVURXNkQ0lqN1pBa3lXd0hqbmFUZXJ3STJIS0p1ZjJva0J1OHQzME5UUzdmTklJZHVsdmZ2VmxiZzlXNENoOUFqRW1DSTBVb0xrR3ZzRjZuZmo2TGwzQWpLZmErajVidHVuMncrMmNLREhZTCtxVkV3NGQ3eVZsQVQyejFBd0VjeGU1MjhuOVlEQjVzdjM3eW9FOGJPcEpsY0hjTHVsTVBKN25LWnp4aGdvUjBlT01rSDZ2SHdUeUtJVVRUVUpEeExBWGcwSUJMUkJHU0FmYVdtNm5hbHZlRFJadk5wbW1KVW9HdW5MSURma2xSdDEzaFluL3JiV3Q1SnpZS2U5aFlrQ1duWUJqOUpQMERFdXowSU1ONUorOUFvbXFYckF6dlkzOTdtQzlIK2xvTTZTdE5HY1NzcEs3YWwvbGhsdHlBU3RZZU5ZV0d1eFlPM2NFcWQ1ZXVlUm9IY0dzbUMyUHpSU1RyTWF6bEJJTi9FVTlOSERDSklPcjREVEVJdGRyZVhtSGV4KzBYTDRFMUJwZFcyMGRFa09jV0RPRFhmUXUrZ01hL2lTalRKZjI5bCtTcS9Qcmc1blRScEtKL01JYmp5Q21oUElqanVGT3NFUEtxZ0pGRm1XQlJxeVhsWmtJWHhXdHhKVUg2UUQrTS96K1plNVgxaHEzcUREekJZUG9aRXNKMmd0aTcxSWVUWjJYemkyN1BDVnJSdmxJT2VBdXhoa2pLVDJRVTg0T2RvVHNjQUpodUNRSjhQOXBjOXMyQ3NCSDMzZ2VRN2VhMDJTQm9xaVE0R2FIY25nYjVXWnJuZVpJREpxRzIraExnU0V6RUdFT1RWMno3U2d0UTFHQjdrejdXOHlSM1MyTDlPQXZ5T3pJVnpWVDJjSEl1VnZXaWZpZllsWkVOSDNKWUVMV2RyZldkNVIvb1JBdTdnQTQ2Vzh4NGNSYXVqaGNQVnhmdThBdXFuS0t5b3hVeHNMTjhQN3RPQjdDcjB6ZThWcm1PSEtHRXQzcjhKd0k1azg4WHNRNkRodWdtNmsrK05BSXQyY0pnamNGcGxxaHZPUlFHWG1vSWwwa2JGSW5lUzFiU1dyeTd4dy9oMjZxaGhmTWpkNHVTTjRUNWM3ZnMzRVpJRlFwNmttUGtrd3VXd1Jpc1J5Q0NnVEZRU3VvNnZJUGhoamhtcDl2akJyQ3p2MlNmdXViZm5nYlVHMXkvaGcwK1dkL2p0QkQvUTl4NGwzUEkycGdNd0MySVlCOXlNSjlqaHI5RFFMb2hBcm1JNldqUUYyVGZLK3hQcE1SdWJOeElQOHU5YTJwQjBUdFlqalVaS0p4eFkxazF3TllUWHk4R3g0dXpESmsvUVdxN1czc09Sc2N1eUU5UnJ1TlFFWEJvVnFHM1RMWE42bFZnT3AwZG0xYk5CQllJbGs0VHFCRWtiZEJsa0w1QmdDalQ1SUE2dGwycHh0SEhPcE80MUJHV1ltNUx0TEZVZGxISnBrSXJDT3Npd25LRE04L1V2SjhIZVExZ3J5N2ZKNmVxK0pPRmd0Qk9STVMwUG9rYmFhampVUWVMeFZ5MEV1cFFlU2d0blZkQy9wTDFhSTRxR1BSSUxEcVVwRDR0SEdRbGdDV0ZJczd3Ym0weEczTjdNdll0N0tRWk9pQWlxUUhPTFVPRE5WL3VkMlEydWZVeU0rVnBKaDdYNXVBYlk0aHE4dG53QWVyVDVwUGdZMkhxdXRqNVlUcC9DdVMwT0JtcnR6T3k5ZHlZdUNIZVNHand4VzNicHRSSXhWS0xGVENScTFOQzBzc0gzSEtHVm5VQ1NrUllQZ3F5TkZqZENoOTNhYjdxTXNyQWpmQlRoVGtHQ1FHU0tEbTRMWjVORXlCTzhPcWZRbVdhM3dDV1lxQndGRzk0TDhESUdwWlhLYnJSczdUV0NUVlplb3hkVlF0a0Z2b0xkN2FDOWY0dlExd0dBM29xMzd1VzFqd0hlMnhXU25adlM3cjFLc0JmYTNRZDczZ1JmQ2NDaWpKdTlORkdRY0dJckRtd0ltam4weng3T3k4M0FHcS9UWHdPb3ZGZytiN0M1STJxOXFRb0gwQVFwOGdNeXBCcEFERWwzOTVhM2pJNENFS2xYWndwYkY5TFZtd24xSm9KZGlIZE5zQUlPRmlzeFE0L1NkQkpRZkJDc1Z2a1RPNm5pYXFRd0JUMElKV1Y0dFVCdkt0Z3JCWjBzYm1tS2hLUGNnNE1nL0dieEFuUVYycHZaMHRla3RGZC9uY25tUnNtb2Vra24xWFNRN3ErVllxRTJQU2RCcDZKeXl2U1dBbjFUalgyRkEyd0VCNDNhM3QxTUhBSW5wSzAvazMwdS9KMmwwSnBtTHFYVWk5dVQzMU9nSDFhd1orejBFaGRMOVY3WC9LY1c3QlVSeDdzNG8xOU9zQzhWOGkreE0vSHpxd3hhZjM3ZCtPdi83RjFyYzl4R2tzeHVZREJEaWhLOVBqdmk0djcvajd1STNiMjFiSkh6QU5COUg0VHlaQ2VxTVJnK0pNb21JeHlXcUhrQzFWVlpXVlZaN3hiNy92UHVDZDUvM24vZURmYjk1LzNuM1dEZmYzNjBuL2F0ZnJDL3lxTDJwYStJVjloNjk1NTB2UnZxbS9wWjJLend0ekRzTjJHd1A0aVJQbmZmL2JYUHYzb2QvRk1QZ0YzL0g4SGcvMjRZOWprbkl6L3hmVHpEYTNCWnFERy90ckdxcy9nUkhNZDM4N0J2Nk9Jc2ViSzFYakdzZkg1NFJTTzhldjNyajRpYjJ4L01VSjl6d3kvSmRxbngxb3pOdXZWUHVOenpwL0xrdW5ieEphMWlWWC9mTzRaOW0xNDFyRFJLZzBXZXBFTXIzcXIyR3FybHpNOGZLa2F0QnA2dS9GNUwzNmUyTi9BdjRXM2ZFb1lOVi82N0t1RHc4a1hyc2VkSk9kMVA2TDBmYnhFZUtqaFNzYWRPZzdEOFVVMURLamlIWlcyRThEUUhjK1c3TlMvbGFONEtoUHRtSG5haGpmNjVSdTdOMSthVjc4R3FJZXlsZUl1ZDd1VGwyUVdidGp6S2E3SjNUdkIxekpZNkk3Y0VPWllnU25BOGUxN3BxSjRNSDc2bng0M2Z3bENmWUt3dDZqSmczcTRoRnZxc0NXUHkwR1FycjhNTDdWaXN5WXpyZzROUFRTbUFCM2tDNmxxVURSa2pqMkVBY3pXQ28yT0FHWmNsSmZJRjVzR1QxNjJ0a1FpMXFQYzlQZTZyZWRnTFg4Z1RuL0xDYjF5Z2R4cjRFNjhzTmdYeGxLcWZ4UCt1bnBxWEMzb2pkNndxQzRFQU5pT3BHTmFVRitEZzZGSGdoSDFIRmhwZ1lkVmNTUlQ1ZFQrZ0ZHakZncGYrSWJ6dHQ1by9XdFBUWGhNSDE2bms1SVJwRHdKc0JJdGFFbVNMY1hnTG5Da0NtWTZLeVhtWVVJSU5seVY2dm1rRFBxTGM4R09IWU1UWFpRMWY2SGVzbjgyc0EwOWdzNTQxZTFwV2VXc2NHTUtIRC9BMUFwNEZCZDZDOGI2NHdUNGhWSGpHckxyZXF2R3RraW1EUUFMMlRPekZHNVM2THV6ZFZXMk9sWkpZZDhiVGQyU1pBQmF0RFBpcTFQUUY1Y1puM2lhVk1KOEFTbzczVE9MVmVla2JlM0FWYXVQdnRFTzUzQzJJTXhpZWkzRmYyMmpqU3hycVNtUFZCM1hPWTFoWFVvY1RWWmh1Rk96SkhvVVZVL205ZGQra0xXSG1QWEdNYTNsMFY3ZFRiOFJvdG9KbjJWdmZvOVNaMExXTlppaTJ6ZERFbkxZb1JhQjRJalk0VE1HSVVpY2pvaFFhWWN4dHhzc1VYbm9xbS9QYTJQYWxaNzJYVG1hdG9xU0pFeHVsU3Erek45cWcxRVhtcFZXbXpqV2duTG8xRDhQTEJySjRGLzZ6S1J6b1NzMGs3MmZlWEpjUTlCS3VUVml3UjduNlo0ZFNzUHVFK2ZwNXhzUlIyQXhWRkI5UUNtK3JVQUdyUUN5dDhuaHo4Q0Mrc0ZkZE9wbDVnZi9rNTN1Y1pxeGcxU2pjSzZ1a0hWQXFtL09TaGh1VUFqSU5lVFM3b2FhRmZUODk5aDVuUFJWZXI3ZWh6M0tIVWt5WGxTeGJNZFM3eVlCTjMvVlgrb3dzNXRnSXphYnF5T3hSZC9UY2hMbk90YTZTMXVzVDhVTEZodGRpRXA3bFljUFhUN1MyMXE0WjlsakJVSXEvdkd6ZitNL0JJZEUvNGF3Snl5dGNEUGNOWW1TODFma0x6Z0kvTnlqbHBqa1pNdS9MSHBTM2Z3N0VDTmlmV1ZIL2hISzd0Q1ZVdXZMS3d2OGU4MlhKL0I2YjZURWR5bFczN0FSYW91QThGVlZ2c1Nid3hxcGxMeUZZZENtWml2RGxCYllveFlWNDA1L3UrR2xSTG1yMk5xeHVIY3FJTllLM0V0N1pjd0ZuQWRBSDRtbk4rNW9CTTQxbG1UcXJBWjR3My8zTGxhbEJjUE5wK255MkJtMC8vYWVReUR6NWI4VGpIaHkrOXlpSDgwUk1oOG84ZUltWHQ2WW5Yb2llWG1uWXBjcGV3bWpqQ3h0cnVNRHhiZVJtWmZGRVBUM09qR1VyM29hVGp5MUsrVnhiUVRHZ3JFS1pSNzJmL3Y5UkdJSkFoNmFkNkNnN0xDeitaOG1aUGVlV0RKaFh5OTlQUnRiUjkrZ2tVV0tGY0tQSGh1bTl1K2w5UHVLODhmZDNnaUlOdldhZzc4d2VQbEJpR3VudktsWEVjRUYzVm9WS01TWXM4THJaWVRsZURDWThWOFFRRjRqK3BiWHl3VWtxVk9BUVJDV3g4R3hQb1h5THN6QVhHNTJxOWRyckhpanpadDZ5SitQNlBCbkxmaksrbmd5TGpXSWpGTmJqWkxDajNPekh5ZkNPeEZpY1VEYklHRHZ3eDJTc0Q1U29XV0oxbUQ1UHdsbnN0cVhYM2RQQkhsQ3F6djhmWFZlbTRIVEZWSFNnMldxUm5kZUdDRStSTThYSzBBREpWTDBzdFhVU3RrWXlXejcxbnlnOEd5LzZDZVZlQTYxQ0daWTFkYzh0aGM4TkhSWUxzejlQM2l3UnE5Q2gxS3RscnZna1JZTk1uNTByYUI5d1hnUFFTb0hEaE4wN01ucGV5bmxMMzJWRXFjYmNFb3hKd2dVUEtLVzFPUGtFU3JWb3J5OEJtTytGckhXZGVWNDR2YlRSUGxkL3QxYVJDaEp5bzRPZmdzT2Rjbk1KaytFYjhReEgrdjB0M1lBZ0hxL0JmTGVrcnRZOWtLY0tUbFdwbFVwWEVCSS9DS1ZuMnBWYmxBdWcrWG05SE5xQjNvOHByaFBLbGVJczdHeVllNC96Nm9na2hzaDdpbXp6cXkyeWFoenFqNVBmNEZDTEp5Y1Joc01GNTlmeXRHc2x6ajB2dXJRa05EdkdDTUp4Rm40NXRBZEtqQm9LWlZHU20wVEZnR0VLdGVhRjlrTFdzd0ppa0FJQTl4c28yOUFLcGpQUDF4Q1pmOEo4eDRkeW5MclVhb055bTIrV1VuQlBCek9TbCtYU0xyTWp0dmVFUzh5MnpUR1I4VE1YUEJBcnNuZkt3M3VoeXpUZmFSMGo5M3B4VnpNTUx5ckV2VExCVW55cTRVTUZ1UmttTU43cXlPZzZ1cGwyc1Q2ZzNLakxPdjUyTTI2RXptRWo0WDJwd0h6ZFhTTHZ5anh3alZjT0RuOXNhK3cxV1FSNXZaYThaeVl2eVFmblFGNXhSN3p5S0kvTDRxMzdDU0xZdFdPTjdrVGVXYU1nbDVTanZFOUxDWEZ3U3VhMUpxVVhIMlZmdTA4R0M4YnB3WVBvaEJZT3NhMTR1TWJ4UEd5VWVmS2tuT3o4UWJDQUtiS1dXQUlPL2F5SUhDVFphcHd5OFVoSlQwYlp2Qkl4MTdUZENMNVV5RFBTNXhqa2hvNENNMFk1VUMwWmxUWGRLRzYxYTJBWStJQ3YyNkYvd3JsankzS0d2UnhnL2h6TTQ3TDYvOTV4UnJWQ3c4VTlrazgxMm1zV0lHWG5WTUx4b3IyRFMzbVZESWZKbGtML1FMVFhWaElIMHp5M3grNEEvSE5La0RoY05RNnBINFdWYU9DdkFZTVVFbGpqTjR1M2pSWE1GdVE5K1RFSjg4MHJvME12NmxpT3Q1ZEkxNHR0aURtSVZFUXdlZk9EUUFtN2h3OENZNUx6blh2NlRDM0tSWDZLWlpkbTRWN1BZQ3NKbG9iMEpZNU8xNStQUk5Wa0tnYU1VcGZQNUlVMmNsTzVSczlMVVprdjNaRm41YTI0MFVuRVJ1RTBQZUk3d1YvanpzWVZuU3c3WU40c3pWc2VkTCtJOTIrOUdPcEEzek1LcGgwcEorQ2sxSXpxQzhxZGdMY290d0FuZ2pLY0lMWVNTYnhGNEZxVjVINFByM2YzV1pzbExobXM5OU5pM2hMSGU2VzRlUU5DbXV2Tk4rLzVoVEFjZC81SG9aMk9STmp6dHJVUGtpaU1naUYxUktXVkVCZ3JCeFJTUW8zeStDZ2VweFc0d0FjeVNwUVp4UU16WklMRGdmYUNmd2N4cUNCSjRIK21memY4YTd0bHZ4RDBHUWdyWStLZWVTSDZrYTdIamp3NE1GOS9vdDFpY1BqMnBZSE1weG5zaWttQjJ1UW1uM3Bla1RwUUJxcXJuTzRJYzNGWjhVNDR3ZzdsQ3NBZTV3VS94K254aVl6UnlQUWJsTDJ2V1pJMW5VUklCQVVhWWpNZ1JRYnV4UEkyZlk1VXBOaGgzbGlTNUxBMDVCbTl4aFh0NFIza1pvOVVRR21GL2tvbzF4a21sQk1NQi9yY3A4a1o5QTQ5eHJSV0ZwNWJLVDV2dWR5THdJS2xmYjRaNjlZTFdKWitBdkJmVTcyYk0xY2w4cG5Pc2ovZlRjKy94M25UYVVkMFVwd0tCSTBROHh2eUhMeTRnejJJZW1yMVpsayttM0t0N0RuWWc5ck5PMUtmZ1RhUlo4SEpVVEFzZStoUkRKQ3JZbEg0MDBGS3Jrd1ZEa0xWUlVyR0VwVzBQMU5FSE1sSWU0cUtCL0tnVWJoZWpxNVppaWJNdmVNbEthNmF3UUxMTS9CTWRXVHlnbHlUM2hJazJFL2hoaE1IN3YrOElmcUtEUS9UaVUvU2VOS2kzRXZIbUxQRGZLRXJWNmk4WkpCaFFKVC9rdkNlZGxON3djQ3RlRVJPekpLd0lpZk11OUpHQit2cTR0alJTZUw0TUdoMzJFQ3NBRGZ5N0tuQTBVaEZjS1RFYlVNUjhtNnFBRzVRN3VzTHdydG4xT2ZvbnIzSGI4bGdVZkdvT2dYSzc5Q2hITFM3SXkrSjZVdDJ4QW93NGQxUzJOdVJkekdPY2lQUHNhM0FONUt0dHBnUEdFSThXcFlieWl4R1I4ODVFU1FJVHZUUjdEZzYzT3dvOUJ4N2Z0NTQzRHE5QlZvOVRKSUVaZUZOZVpTSGs3SXZFdEZPQkZtNDcvWnh1dDQvVGMvL2pmb0tCdUxDSCtSd1pvSjNQRExVdzI5WmZCSitMUXgyWVNPeWNtNDhNOTlJV0dFUHdZb29PNVNEY0Z2Q1REdmhMUStUTng2by9MZ1ZIQnlkc04zSkNXYVNYcjBmbkVPMko0eXNKSCtVUThxWXR3YjZQV3liaE1kdENGTUdnUWlaRHJqSFhveU9CemRzSHloNVl1cU1FNlFCNVVSd3hMa2o3RERCdTMrU2g3Y3V0UWZLSGJpY3Jsd3lmK2Q4QVJxRXZMSnl3QWJMM25TRCtaQ2U1OUlqR2RQb1BQWW5hZWF3NXBWbStyY0RIUUJ1RHp4U1VqVlMrTzhFRi9PMGFZUS9QdTdWeEJzNVZDTVZIdTdFRzJyL1FhM2FCZktlRGVhN0wydENHRmxDc1g2SExDUytIY2FUR0MwY3FKQ2R4QzBTcDkxT2YrNEZTaVdVM1dRbmdtcWZKY25tMSszbFFIcmpPVzVSNGFwS2wreHpRNFYrOEg1VUVNSSsvQ2M1cmEwa0h6OWgzazFsQjhYYThIaVlqME56US9DQnc3dTE4RVhKOXEzUHRoV1AyV0krMTlSS1FvUktnZVNhN3FWVThielpxUXJ4SkVaeXFsOVp1RjQ5YkEzbXJZMGpzUUU3bFAycWZ4QzdBRXE4dUtIK1JLelBrUkswSThHSnZYTWdkY2JNeTR2K2pPQnJEYloxUElabnRGazZtcmp5b1dSeXBDL3dTQmZYMnVzYU9xbkdFMXFMSFBDMWI3T2ovZ0JRZjRBbUs0eDlieHd2MVF0K2pFSnBhVitDMXp1UUhTOWJTMFFCZjhzbEpBbnhRbU4yUEdxU0pGRzllT3RRYTYxVEpXdFJqc0tNZEM4YTZ1RmdPTUZUSHVabGU0SVZURVVhVThSVUh4K2kxbW1rU1U4cDM3S0g1YWxNRFZ0YVJ1VE1lME9obXkrQURkTjluSDYzbTR5MGtmREROWHl1Y2cwb1d3bzNBdWdicDhUWk9lRk54VFdDUStTcnpGREFPdkhqWEdrR1NndVJhVVJkWFpHWmdCSGw0dUt4VWhJZW5XSUR2OWRCSWdQenFROUVYMjNvLzlhUXc4V1YzeWVuTTVMSDFMYk9BK2I2RFF3TmF0ZHVOU1RRVTFzckVpU0hXa25TSk1LajFYWlNQMUpTY1pUa1pTK1Ztb0Z1MGtoMEY2dXlRTjdIMDJYZE9KV29TTW5iVmpKak5VNFZyd2hPdVZXdmtkY1VvZ1o3eEh6T3kyTmxXb29hblZQa2lJNjNQcEtENElYVEovR3dRUTdFTGQyUFFGNTFRNGZlQ2piM09Ldlk4RHdiejVCMTh2N3M3Q0xtWTBsWC8zZ1lOa3Y0OEZSSVd2blFIK2xpTVg3OEZjQy95TE54WnZvci9FNHZyaXpaUklFYUFvY1pWV2VKbU10U1JzZkR3dUZtUjRGSjE2Z0Nlb1VWVk1KK3JNQUg3L1VTNXFJaW8xU3hBdWJqUHFOejc1aUZhSWkzYllSYk5paHhKR003RVhUZ1NZc2tEcTJ2bEdPOWVhLzAzS1FyTDNqaTRGUytHc0dObHVrL0FQaGxxbWZmRXY2OG9SUGVDVjNWVDQ4OUVXYmxpaFliSlhjSzZlOVpNNnR6dXJFaTZ0TUllQVlNV0NwbmV3a2FMaHlHN0NScGltOVovRVB6Q3A0NEdLWDZ0a2Zaa21sSnJqRXhKNXhIaUFZSy9YdVVVa2pHV3o4SVN4RGs4emJ3eGFILy9QMVRJSUdPcnFqaVNnTi9Sb2MvbEpVby8zdkNQTVpyL2tKSjFHYkNRbHY2MGtjeXJrOWlxQnVVK2dLYURHVXhidlplUFh6Ti83QmdVTGtTN21zd0lGeHBxR0hCWUQwWlRLMjhlUkFsRWlYSTkyMlFqSHhEOEVqbG1FN1N1SFNrUDBmS0crNVFqakY5bmo3M0o4SFNqWk9zZG5JUC84VHo0ZXZQMVI0Mk9CYzRMdHlNSVBTRjRTQTdkUzFLN2FsUEV3NHlnSDlMRjRLNzNZMDF1SkhEdzUzMTJlRkwrWEJ0NVBBdDNmQ3dBbHRkR3Z0SUY2N1ZwVzc4SlhpUUpJU21pbkZ6eU8zbHVWazRVVzV3NGVhYmxxZ3I3a3NZcGZDUXBSSzVwMGlaSEFoUTQvSTdTZ0l2ZWxwUFFBME8vdE15bkpMZG1aSWpURVo1aC9OUW5YMzVQUm14R2VEajVJMy9NejMza1U1MUwzaTFkWXoxMzNUYWszQ3RqWFBvK1BNL09sQm5YRWltOHNwcjZlRldPQldybWdDeE9nUXZpV3VjUTVpSXp0S2tjY1JjU0k0OW5aWEVJWVdjVVR4a29zSkZ4bG00Ymt2WVYwVkthaHcyTitrQVFMemtaZG5Ed21sa2FCMTZKVXZtUFlpaG5BZ2FhTmVVWlpKR2U5MU92N3VYY3F2cEJ2eEdqRU9rNUtCMUxqcnJaRVdudkp6a3h1M2tBb1lGWG5WTmhRc1hHanRDeFp0NlNWWndFclEvcUR6cUhhSVJwUllEUTR5R2pKajdpaGs2SlhGSzF2dVJoUHovVExsSW90NEUxakxRS1FrK1hMMDRoM3F5NFBWcVR3WmJremxYck1nRU1JZm9EMFE3UWVpbFg2YUxuUWxqbmVnRW1zYzEvR01xS0xkRWJ4M3BNVnlIUDVDUkFuUGRBRHRBdDVpTHpDa3U5TEN0aGkvN1hKZmdRVmlab09XRjZpS2tBVWY3V3lHR0dxU21yNU1mSjVTU1Njb3FaRWxjVDVTZ0RSSlZ0UXovUVBoMDcwQ1doSHB2YkxoMERkaHdZd1ZYOEJ2eXNCcTM4QTMwSVU5UzFlQXUrUWM2K1hheUxRSDdpSEk2TnVNOFhOaFJUOE1XWmRkVXBqQUVoMExobXJzMnhUUU9RN0JXTitwMndVUFdZRUNOYy8xTlBGZnRBR3prOWJMY295QmhmMFE1eU1oc1FwWi9ZNFpsUzNDb2wyYVpSc3JqbVdpd25qNGpxK05vc3VqUmlHRWwzS3BDQXNDZnhXbWxBUVB5NXlpWi9QMzBaZmZrYVZ1cVFuWGtQWnZKRUI2SUp1a29BYmdoanp3NnBiNk5jN2hZNWNTYkU0c0xCWU93SXJ4ZjRtRXZ5Zm9rek9WRHNaQ0FxZUR3Z0hLeXRSSCtXQTJUcy9wUmpKbjFjUWN5eGhNWmFwd2N5YzlUenNDZGVBOVR2dEtqbkVpQUV3MjRNVVpIeDZzUnkvT3dldE84c09OdDkrUHlLbmZ6LzQ2eVB6T1NzZHFnSUxmdG5TWll3VHdoSzFnbndXVUpwYmhaUWptTTE4bE5UZ3RVMHhMT1RGY1k2OUxmUTRYWDlqckJhdlA5c1FJem1JbHBISjU1Rk13NE9BZGhRTmxnRTV5ZWdDM2xIVWtTc1FlVUNqb0o5VUhGdENLeVZET3YxZ216Y05nQjltaGJxV0Y3T3E4OTBSVTl2blpuOGNubFh0TlJjRnFrcE9nb0ljaWJuKy9saHA2RXM5V1pxWTBEQ1lMakdkYjJFMXhLdFBLRndvRkg5MmhwV0Qwc093RHRZV0FqNitFck5HcHorWUI1aDFvbkhwSFZ5MW5pU2JYQ1RuTGQ5ZUI3SFc2Nkp6ZGZNdGk4Y05QWVdCb3hJbFpkVVJvbGl0ZGx3UWVtV0d5SUVISVI5NVM4NlFGaXZPVHhmY3AyY0ZkL0k5bXNYbHlkRGxocnNFdWVOMThvOVdaY0hrblN6N1NUZTZVSm1iRTQyY0d5RUNQandja2pPWkNlUE9hQklxdGQrNU5BeUtOOEI5WDY5WmFxWEJYTlBKYUE4YWdaM1Y2QThrYU1lQ1JEM0FxVHdLVlVWcEUyUTd3aC9NUWwxVVIvNXJGdGxZZGtlVTFPdUxoZmdMbEpIWVBSMFpZR3ZuYll0UjYzWm55NVFvMnRHU1ZKNG1tRHc0ZHo1dDlqTHFqTTB3YXMwZnRBbGE1bVNnbzNsSHlCSE5ZZzlCVVhLVnJNcHlKVVlPWFM5NjlpV0UyNlZMaWljYnhYaDNJbVhwdFNtRTI0cDdyMERmVUwyR3RvajZ5Rm5rZmhTdUZ3cTZPRWZ2Vkc0NFdFa2JjUGFxK0UwbDNYR3V4YTJCQ2NCQ1ZXUExRK1RwbWNCSDhiakE1VDh1aTllbWR1Z3JIa3JzZDVpUFFMR2FVZGdCUEt4U2dIeHhBSFlXNnVvUU1MZzIyZEVxRFhRTUZlWnBEVHhKalVSSG10N01wNGNpREtCRlJwaWtKYWd3b1AzczNONHJGSGh3Wks4UFc1a2tNUnFiRUg0VGRWdmdpVlJDa3NsR25EQ3FpZzZvY0tiNUo0cmxFaURHKzM0U25qVEJHTTFXU3laT244N3g3dFovQmdvS2pMY2xJR3UyNVF6cGhwYTZwM1Q2T1Q2SyttdGJDQXQxUmJheU5Hemlmb2prNmZYVXpiaGZVRjV3YVkzM0VlaTJtcHloWEZXN2RrNVBlT1Y5OWpQcGUwd1Z6dlNnM1AyeWJEUnFLRG1DMldHMWh3Z1JSZkN2L2U0Y3dvMnphOUpMa1JnMDd3SlQvWjBGbmRKYUljN1U1Q1V4a2I4RytVQ3QvV29QOFpaU04vbEFvb01CY0h4Qm80Y0FrU0xJV3lPd3JWSS94WktPMUhzTlBhRWE3aXl0UTlmVW5EczN1VXk5UjRVOHRIbkFYTVdzd1Z2aFBoN3RHcG8ydURkNUJ5WWVkZ2JVNGU3TGtQMDJkSGhjdGRZZ29DNnR0YVZDOExEZ3pRaVlVajVrTFFURWMybUE4NzJqVTlFdWNkeUVBRGxjVkJQUjg5UWIyQnNHMUdPYWpJMkRaV29zN3FUWXVYRExZMkt1TnRFL0Z3WmFCVCttbjZVblpCZnNaWjZ0RTY4SGVUdDIwRndBY3AyZktxbjQ2S0NicENVOVZJTm1Jc2ZPSjU5cXVoSksrQlA0U3A1ZHk4NHFCemN2Z0Y1NFVnV243TkFQNFh3UDlnUHRqSkhqSmgzbElabk9jd2RtU3ZleEp2ejlPM2c1TWtqVGpyUDNEakN3UldNRHprOGFVZTEzV216UTU2eldERFFsYXJpdEdqY0dmc3NUb2k5WDhuNnNzeTBJNjh3cEZxODl5djhCSG5EaS96N0I5UXFrZHo4V0FrN3gyRjZmREdNcUpUbWd5T0lmQ1NqK0JVcDlTampnNWRDUGdqemtxdUp5ZGh6T0k4c2xTdkd1ZjFNbDBUYnZEdXBkSjF3bnhVKzVHOE5yOWZMd3pLMGZIb2hsOGY1VHRvMlp3TnRyblVBSE10SktndDJtQk15WjdaTHRndDBTT044S0FiQXU0ZktKUWNpZUxhb2x3QTl3bm5lZm9OVVZ5cVpoMFcvdk5BZnVmOFhqbEx4dE9ONDUyOXRzS3hBcDBhQ2Y4SnZzSkxGcU5ORmRhRzcwbkdmRGxKUzllWEQyNFNianlSRVk0VTdqc0o3Y1lZMkd6Y1hrcTRRWG9HQnJFZjdwZGR4YVRNeEFvZDVaZWxicG9HODAwdFdzb3podUhqOU4rL3lLQlBrdFVHTVhBMW9vNE0xeWdUbG9UdnFPclNDUXpncFd5OXNCOHQ2bTE2amZESG1teHRGZzUyVTZuajgzdEd4eUE5OGVQczREM3VJV1hNeStWejF2L2kxejFLanNFRzI2TVU2TE1WUzNkVEQwR1BlVXZvQWZObWJkQzFPbUZabitIRkRQYVNkMlZCdHl4aExLTmNXc3poMXFvak82RkR6SUJ2NmNLWlZ1d25ZaEdZaldESnpTUEtEZHV0NDJGMjhLWG90ZDhCVXFGajNwTDdINkxUd3dDaGhJQ3llNHFOSHNJQTZCSm9Oa3B2VjVhM255QUtPWitFRFdqRWlFWktwbllDQllENXhFRjA2TDRlWjdWMFhyU2kxS0ZxUUtScllNQmFnd1hxYXplRGc4bDBJSEYwdktSS3BITkd6dEpEZ1o0VHBWSnpLeDZ3Sis4YXhDaGFTVHdhK0VzNUF1WmoxQ1BLcHVRdHlrMk9LcVdwa1NnNzFKaGVUNjc3SnpJY2JVVEpEdDJtT3lHU2VOb3NobVpKSDBNeU0zRGRFMlpjK0FHbGZteW1pRmFyM0kwVkNuUVZ6L3BjOWNJYXlldnhmOHAzS3ZEMjFzTUg0dlB1TU5kbURjSWV0T1E1T3pIRW5ub0w0SGkwZ0ZKTE5ndnV0UkRvclo2TVVzdHZLNDFETENpeXJSUmVQUG5KVVhvdWdQa3lFMjJBOXFpNVViaHdybXJ4MzNzcG9Wc1N4cE1odmRPY2NoQVB5YUhmbTNTSWpqZk4xeHJwVXczV005NVE4Y2lzcWJTVENzd2dIbEU3dnlJbFZselNaVG1kU0o3Q05MVjJRbitaVkhxRCtUVG5oa0pka1BmV2djVHNOSXMwVXZabHo4S2pLQkZ6YlFUdkJucjlzVXhqc2ZIcWhFUVNLakNnbkJibUhvb1QvTlpSNER6ZnhoUE1lL3JjTnhPZTFYVlNLanNhTVI5TkIzekorT2N2bGx1aFVhREpGdUMzaUVYTVplVDV4aWNIMDNGM3ZZbm9zb0poSXE3dkk0WHBQWGxkeGxXZEdHb1d2TnNJbHduTU5XU2pFL3E1NU9rVlJMd0JRNTN3VlIzWlJzck91aktVKzBpRFZMKzBxdFZMaHQ1THliYVgrN2FuNjdpVGZnSXorcCttU2xjUUQ1cWR4TXBUTGN4TC9PcVREWFlsTktpVkdNTkNTVmZWdFRmQzc3R29iNE81bnBZVkdUajhXeGZaQjhKbExUWFpHRld6RlpKZStWV3Y2d3VTc2JjQ2I2S0ROUnVuV3FXdkVaMWtpajN4cVVKdmVXUGRXZzJ6dng4b2QyRGo1b1VlQThFWDI4Q1RKVEd6UTM5QTJkMlZNTitwNXZXOE5rdlk5Y1YzelY3Z1o1ZjZObnZKeHBtYmpISUNlZGRxUjFpMXBXcFlTNFp0bnRTNmd4N3BkZS9JSTdRVXlqalRiVEVYb3ZPaWdvWnQxWlJOWW5ESkNmOWFqR2d3bjhIeU9OcVIrRTFVbk1OWTRXQjExYWNaMnA0OGJZZHlSNWR1VGorU3MrQkpnaWlISUZjcWV4ZFhlTDdxTnUrRlpSMVlTQ1lDeXYycDNQQjlKQy9WbzF3ejJaQ241TTU1bzdEK2diTzBqbGEzZW1FREdxcU1tZEhzNkhVN3pQZkRkdUlkQTJIcExHRVowakNEQ2hVSXdhaTZMbE9UV2U3SzRuNktYbUFYMDB0YU1lTU9MSzJZNmRUclFaSzlVWmdRajYwSXFHdmRWbUhsVXczMUtvTjlRbElHSjB2VVUrZVZPcE5RVWx4czZPUm1talRQSDRSbG1VcmFvV3o4dnB0dWpQYkVxbmRUM1ZWT0lCdVU0KzQ4MHFQaHVRYWI0c0pOMXRDdWMxak1wWTcwZHd2MVRCMGVpZnZtaWhiREF2YnlhcUJhdEVpVis3c2tINHJ2YXJBVncxMWFpWVJLb3d3Y0xqYzQ5QWhuNzRhSGZzSlgwZU03OG54N0t1dDJsZUxBUnFCQ0t3bU42U3M4RWd1aEEzWEI2YW1JbGRKcGcvbDJ4T3drck13VWNIbjdRQWRIYS9talFBenVOUjdFa05pQUd6bjBRUXkza3g2RDdDUlNjTzUzYzRsbmZhNmhQc3RnSjZPOXRGTlV0d2NPbFNwYWtQSm5UNTcxUmhJWENQbmZrMUZ2cENvRmxPTEloNmx5WnRuM1JwbzRkdlI1TnBKOHFJQXlxMU56U1hvUUptUkUyVzZuNHoxTTV5VW5JUnZwTVN3aXpKL1BNeTd1cW1JOWh4TzlYaEMyZ0ZjY1JTY3BWRGkwZXAvc1N4bnJzd3gyWldLMkJCV3lrNUZyeDM4alhrVjV6MFlhYWpqYzNxRHNlR2VkTFRacUxpbERYbytyU1pZSUhsQk9rbklJMThuVEFhWGd4K0FrYlZ6cTVvTnQyZnZvY05iczFZOG8rNEJaVzhDREtJTmpaRW5lV3h2QUd6bU1JL0N5YStXL21jR3VwTUZxK0NZNFdYbWdDM1NEVWdlS1dRZWVBWHNRbm5WUGo5c0s1YlJCS2FPK3c3eUp2SmZEMGppbDJnN2xMdG5POGJwSlBuZHlrdEpFaVJHekJvTWtaQzNtYzFrZEpVd1I1ZmcxTHpOSlFzdDVZc2h3UW54YXlQampjM29DdnF2QlhqRGNKVldQNkRSSktBYjIraGtDSlY1WnN2b29SUXliWGhncW5naVVtQmhQYSs5N1EyVmJsbUhhRVZOeHdueTBSdVY5ckRXeUUwL0hqZU1RYk1vODlJbVlGTWIxTFVvRlJ2YWdvL081Z0huajBvaTY5aTh3MzR1V0x6QkdyMktvcjJLd1QyQVVhbDlhSjFhOWJkV2NWR3drOHo4SkpQQ3k5QzJGODQxZzVaWitGeVZwTVFQbWJlRTdxclZ2cEZLbUpVclFhN1QwWFErWUt6SWVoZjlzQ1FJWUJvZEFIbFY2OFR4cEM3OGh4YU1tbHhMcGIrSlZ2NG5CTG5DNG5zSHFmaWtGL2Z4Y3ZxSC9tTXFGRzZGbkl1YWRaTHFtblhVUHRMbm1TQWtmZDJzbFNsWnVNRzhQMUhIckxURVlqWlJPZ1hLdFBLdXk4UENmSHBvTjVxTTd2YkFkeWFucEs0OEtwMHFaRjVKaWZHOWovU1lHdThMejFocHA0QkR0a0t5NnhYeXV5Zk1VRzRlYWlVN0NjeEtENEsySlBWRS9saW5iWmtmZTI5QlFtZmhBeFlxVFl3eGNxdTZsZkF1VWl5KzRPclpGdVNVbVU0bjZLTWtUNFBmU0xta2tSRnloS1BndGJlaWJHK3dWbUJkeWs3aVRIWlZLMGxqQldCM20rcXFjMEhqcjVzMnIydmd6RndoMGpsNXh0aklTdXVGd2NEeGxMOHhGeEx5SnU1R1FEOHdYWEhpelVzRXB6cVRuM3IvdllUdmYxV0JYNHQyMlFzVXM4YitCT04wc2RGaDJ1RWZHdDF3UXVLRXMzQlBtR01oN2ZpQkdJNlBzSHpVSjBVZkMyRnkxQ2xLbHlnN0RNR0plQ3ZXcWlubUJtYm1LUDMwclJ2cm1EUGFKVk5rU3Z2TFdBSG1OMDFFODRSS3VEa0wrbTlGeHY0UzNneXFTMFo2SVlkQjFVUVBCZzlIaFBHc2lHaDVtZmJKQnZqVUQvV0VNOXBrRmk3eVNCMjR3bjBvMTJLRmgxN0RsRVdWakQrTmluY3BsZk5rUmplVUpZcWdJU2MyVGN2U29mUytzTU55TEEzOXY4cjcvcUFiN1RFT1BGUUtjVlJsMXJDVTVNS0oyS0RUUjhXUjZ0RVByVWxoSEJYdStDYnJwM1dEZmhtSFgrR0VOL2J4alRQY0gxSXdzWFdCR1FvVVBYV1dzZjlYNyttNncxeHR5elhpaWs2RjdpaTlMbE42MVlmMXZZYVR2QnZ2dEVrUDFycldTOHlWanJScnczdzdTdlJ2c056UGcxY25QM3dXUHZodnMrODlmL2llK1g0TDNueC9wNS8vWk8vZm11SkZjeXlPVFpEMGtQM3BtYit4Ky8yKzNjV1BuVG5mYmtxcUtqOXcvbWpuNjVTR1N4WkpsVzkydGluRFlsdXJCU2lLUkJ3Y0h3THVIZlgrOGU5ZjN4L3ZqM1ZqZkgrL0crdjU0Zjd3YjYvdmovZkZ1ck8rUGQyTjlmN3cvM28zMS9mSCsrTFpIKzFZdjdBVjl1bjc2SmRzM2lxSE4vcjRwMVUwTC9CWVg1MDlvcU4vMThXN0FiOVJZM3czMTNXai9GTWI2YnFqZlpzZ2hoTCswUWNlL3VhRys1ZDNSdkdUOVFnai8rZk5YY3dMdDM5UkkvK09RYmdpVVlrcHBXcGxOdHJtSnhNOVlXKys2T1lMMXZaand6M0gwYjQzaWExMzN3bHN6MHI4cUpvNS9NME1ORzd4cjdhS215dS9UQytCRmZJdHc1SzNEaGZnblhaaVh2amh0ZUY4dGtRNHZXTk4wNWZVMC9LMmVPWHdycnYyekcyejhrKzdnOUVwRzNsUitsMVkrNjlwblQxY2dRdGp3WG1IbHVmelpLUGZ5TDAybi9OM1NyZHJVWXBUZnFWZU5WN3hzV1BrM20vMTZvMG05ZmdGNm5lbUdqWm9xQnYyWDhhNC8zRmgvMHZFZlZtN3MycnA0WGFMM3RwemNwNjhMemxIL21rRloyTGdwLzFLUEg4b0cvT0FkcTBmbzFpWVQ0WW9CTkhMY3B3cm1mVW1IUDI4RHBDdXYrNjVzeEZ0aUNQNHFNTUREb3NFNVVqMFBGOHdmWjdrMjRwS2V1YTBZbXVkOTErQ0FYbXZheURSNHZXL2ZNZXNQTnJpWFBGb3IrL0d6Q2JEWEZqTlZzR3F5SmFmS2ViRTBJbzR3eWpnMVZvSWk5YkRURlM4Yk5teTZhUU1FZVBIYXZpWDgrc09NZFdQbmtsc1gxMnNweWZtd09xQlhQYW1PK0d4c09lWTlWYUo4L2sxOHl0R2M0WW9oeGcyNGs4YlppQUdIRlFnUjdlV3RpaGIzN2kwWWJYd2pocXJHa0ZhdWJ3MVQ1cjZvazlWYmxxc24xYUc5bzJNWU9rWXllM0hPamQzYnN1ZS9HcEZPNGFZWGJxOGM1WHBpbU1NK3hCVXZHMzdRZmZ4ekcrdEdrQjZ1R0hEdEJtaUFvV01oZzNQazA2aDJ0dXhzSGNRQThyOWJNZklEUE9pVFhGY3J4cjF6QWo3UDZ6VmllRFd1MW12NlZqc0phcGo5WmtqMk13MzJSNDRqdWhXL2JwMHZPMVUyWUc0SzNNdk40a0JmemlWUU1Rb0h0M0drSjRkM2pPWnptOXBFMlBzTWNyeDVZb3hpNkxVRUFxSEw5Q01wcTUvRkVNUTNhS2c4RXIwSTM1dFNvZ0ZIL3ZsRmJueCt6UTdlSzFXQ0lZNm16eE1OMmZLZDgxdTVhZklFbUU0TU0zZkdwdUZ5bW1LUXo2VEg5SVlaeHhWb0VKeDFpUnZZQkxJZzhhMTUxKy9xV1ZmR0RLV05ualRhY3B5NlZiQ3RGd0NseW1zVmd5cE8xUkZEMmZqeVRLckdsbE5pck9MQmRVaUhldkFvUjdmSEFPUTVDRjV5UXlGUHpkTmJKUmhMZnhZUEczK2lWdzBPTFdRckFjcTBja3hPRlVOdm5DQkVQWFZDc0JUTW54OTdzZWVCYlFvamptSmNCN3kyczNKS2RlTjhEODd5Nm9DN0dkSDM0b0U5K3Mzem1LMTRZVFh5UDFYQTlWMDhhNlZQL3pYRGpSdDRSODhnMHhWYXlhTitldm1aRjR5cFVYQXVMSS96dkZrYWVlMkVUWEN4NWVDTFNUYk9pTS9KczdYNEhUbWFxRFpaVUUra3RVbVAxNlppdjdtaEcvRTdldFIwdytmWGh1WFNrK3hzbVZWS2d2OTRZL1pXVnk5RmVCNVNUM3ZuOTJRRWRtYjJHUjZRczZ5aWxhT01qamkrT1o0K3ljWXhNZEl3RzJyakdNd0VMbmcwZjFSUnJEQUhlbCttSzlnMXZUVVArK3FlOWNyOHFyV0ZDQTdONU0wZjlVUWlTVHcwcHhEeS9UbUh0Y056ZEh6OEpKSC9YaUwvWVlVRHpzYzVuek00SHByNE5EK2ZBNUwxKytuSVMxMmphT1ZNV2NJSkR4OTNza1k2YnZQTllkajRnd3hWZWM3YU5URHliY1F6ZWpud1ZqeHdFTU5UR29ySDk2T1YwN2RiOFhBakRQUWk5TklPcjd1RFp6YWh0SWlGczBmOEJDNzFNTCtteCtuaFVYRkt0YlhpbmJPblA1bWZhdmJXc0xmbHNPY2Z5ci8vTkdOOXdWSGdHVmxZSWM3SENpbXVBVlUyb0ZGSTlud01LOWJqVk93OFQzYVNvTytmczNFSCsyT1dhdyt2Mjh2M3lKOS9tRC9qYnY3Y1BQcjljZjdkd1o1bndOTHpkZkR3cEx0YThkTDgzaHlVekJsZWswQ0RxUktnRGlzQjdwc0p1RjROQnJ6d1FsczVYdGZnQXdPQ1JxaWVGaEZ6MXB5ZXdha09NTnJKd1lEdC9Kb3ZNSUo3R0JNaFF0NDRuWEMzVVNKN1RhTVNhejZLQjk2RGk2WGg1ZTk1eHJHZDhXL3ZCSUZSdkdvU2lvME1RVyt2T0VubVI4Q0JWekhXR3cxVktTdGR6TWw4VVVzREQ1QmdaTDJWZzRQNVhqMmdBcjFVd3Q4Nyt5TlZPanJITUxOVk9Xakw4MTMzOC92OVltYS95YVpUNDJubGVvaFh6L1k4MUhpWS8zK2NyNGtCbWdsbTVtajYwUWtlUjZ2TEQydWM3elZHWUpNdzVuc1o2MnR6YlRWOHBGOCtPZHhwc0tVT05lRm1relZvZ1RlVDRDOUcrUjErMW9IK21XUURNT04wRkk3VHdBU01adlpWUFBRWlhqQWIveDZSZlJDc200MjloeUh1UWZydmhTWFpBVXNUcTNmT3o2UERXM2ZPL1E3Tzk5czZzak85c3ZQNktRSFdGdEk1T2ZSVGpTdjlET3FJVTZhcGRzcEdmaERxS0IrWm8zaWFmTnpuaUh5QXdkL04vMzZRNi9rbmp1d2prZ0Q1czA4d2pvTXR0UU1IclBWNWZ2NGVSaGpCVUZ4QVhkSEwzMXM1R3A2QllTOEJYTExuSWNrNU9FeEMvMDNDS3NRS1IzMUw5ZTEzTjlqNGlsNVZkOTI0MGNBOUlmTTBlekN2Vm4vRVRkVjhmNDdreitKaG1JbWE0TkZ5UUhNM0c4Z0h2T2Y5YkdqNU9MNmYvLzBabjNlUXdHWVBuSnJ3R3VvTEduajFiRFFmUWJtZHNZR3lRWjdnSVJOZTJ6aFFLZ3FPSmdkOWNvTGF4dXJTd2pmVlplYkZtUFVGTzBmcjZWUGxaK2FRK3owOFdZZU5jSnh2Z0VtRTI4RXdJL0RsQVVmOUYrRVhnNUR0SDRVUGZZSlg3aVZRYVhBOWhzMDB3V3NtZUhKQ21SMjhZNDhOMnNwYVRFSy9uZWJYbmh3ZU90cHpGb3l2alk0VENjNDkyRkl1L3NPRHJkYzIxbXZGY0RYK05jcS9WZEdrSkhtVXdDY2JCajNkSUpFMitjWEQvUGM5T05SSEhKTVhlTUVIZU9zOU5rTTIxRTQyRHEvNUFrUFpXeW53SHF3VXV3ejR0MkdqNWFEckhpY0NYOXZBRysveGZ3MVdQYjFyMkdDMGI2WkJjbndGUTczV2lNSEVHTDFxelNTZXRoR3FxQkZqMWRLVC9XeUFveERzQjNpNTdNVXlUOHFnNW1sKzdoRkJUUTdHN3VlZi8zUCszUHY1ZHg5aDBOMXM3QjJ3TFhuZFNRTEV2WlhpN0lpTm9rRVpzMTc5L1BPOVVFK2ZFUUNTOGRDTnI4Yy8xMzEzNWVqLzZYVmNML0tzR3o4OHJFU1VPUUxPNnZwc0tMODVwSFgyS0Qxd0hZT29KRGVQUitJUk4vc0JSSHgrVGI2R1FUWlFoOWZtNi84NkcyaisvU0JCM3dqY1BXS2ozTUh3QmhnZVBkd09ucmlYQUM4SzlDQWU3K1g5SnF6UFlLWGNrVG9LVFNJb2JaZ3EzTzFXQnpoOUR3Lzd2WXpWRTBqVFM1QzJDb0lkRzNpV1JnSVc1dW9INE1NUE1BeTlxUW5VMHdGZTl3SHZsNC83QnNHT0NWTnhnVmQ5UVBROUlWTGZ6VWFlMDduNVd1N205OHBCM01QOHZLL3pOUTI0bnM3S3RPb0VYSnFOUFFLejltQkxXQldSM3lkdjBFa3lXNFJRZWFObmZuZXRkdXRhSDRQdkJnZGVpN29LSzRTL1NmYUVhY0RXV1loT2dvek8vSUs5S0h3cVBURHJvVDdNdnovZ0dEWEphbzN6ODNid09xZjVPVS93ZWgyTTZvaWpOS2RQS2VNN2dPWmkxY0tqNE4ySWpOak95dFJ3Wmo0dTJHUjVjL0RZenBoM2gvWFl3L3VPVnBibjBHaDVxanhXN3VkYWk2TXRWT2Fyd0lINFNsN1ZFMUpQOHFXWlhpUW5ha0xybk9WNDZvVlFIOFVnYkRhb2pCay9nWTc2TlAvdVNRSzV4eG1ESm5qY0JIcnJJdDQ0ODc1QkNQVVIzK1VqQWh1RGw2VndKbVBMZndBdTBHQ3lrUjBSdUIzbTU1K0V0U0I3TVdMalJsc0tya2xudFk3eE5VNnlJSWd6dVNhTWViSEU4THZBZ0lxb2VpMTFwN2hJTjBnUzR4M0ZjSjhrQ01rNE1BY1JPM2lzVHJCck94dklIdlRWSTZKeWVxT3piSjRKNzUrczFLVHU0YUh5RVp1OStnT0Nxd2JjNW9nZ0pzcHhuYjA0Tjh4WjFtdWMxK0lPa0lXTVFRQlVZT0I1Z0RHZmJka25ZWFR1NGVoQUlMM3ZDdk4rQ0RzUVgrQlIxMXBBcHNwT1RaVjBxNVk4UjNpWjdKbjJraDBpbDVvTjdtNSs3bmsrempPWjMxbXBJempBV0h2Qmhna1k4NERvZkp5TmNZL0FLc0NRRFp2Z0U0NzBPd1IxR2Fad2MrYWc2VFBnd1AvTTF4M243NUhmNjRSVDVBS1BkNGRyYW9HakQ4RHRWSkVSQ2d4WWk4bVd1b2JSV1o4MVF3MWI3ZW1sY0dDelo3MGhxUExVL2lTNUJ4aDBoMkJxa2dDc0YwOFpFVm1Ud3RwSkVIU0EwVFU0YnZkV0t1MVBzMEgwa2dIcjVvUUJiM0FEZmpaN3oyaGxVNHpQTTV2UlNTbzBZOUVCaGtabVk4VHBrSU93eGtyQlRQYm1KNnh2ajZUQUlNYXB3dkVUTmpaVHZJT1RuR21FU1FpVmxQaGE0bWVUeDczVncyNHkxaGRxVlJVbUhPYkZiSzB1VzJ0bno5TEFrd3d3cEJPTUlOK1FqM2pmdkVoM2M2U2RNVjhPSmo3UDczZkNzWnc5MmYzOEhyL2JzOW8vay9vZmhLSmkwTlRJeGppSkJ4dk43SC9oNTAvd3BEME1JK0tVNk9mcjJBa2o4aFY0M1NTQmtmQzlBckpjREtoWUQyWlc2bmkxVHN6andyMmdLODMzNEt0dDd5eitVNDFWdGFhMTdFaHc0RWVMSGQ0SmQ5akNLMFZraVlncFd3a3lFcnhYUHkva01QLzlpR3ZJSHJESHpXWWppMVlvTllNUmU5MWJKdHgwcGxOYllVWGEyVHQzc2w0bnNBZG5HQzgzMVpOc21NbVdBblZtdFF6dmR3LzhUVU0xSjNFd09BRVZVODlNVVNmSnFtM0dzTGNhYTl4b3FHR2pCMlhFNzNYdWkrSXBKZ2tHQXNqNFBhZ2VBNFliSlVkUHZHWmdCdzd6RFFvdzFBY0VaUUZwMHNieGxBbTBEeld4TFF4c0JFeUlFcHd4VDgvaXZ3RlUxdzdIL0JGWS9HQ2xrUHNKakVNRGFORktkaTQvSjhzVDgrZDhFb3FzdFQ5MHVLcURaVVZHSzBrT3ZjZDhzSmZDZDN0c0RiQzhvUkRCY2UwVUZZOE8rWHlRWklDbVlVbGQ1WnY2eS95N1g0RWJCekdpbkhISzBmbG5LMHViZjUwTjRuL1BQNmZLaVl6RlJ5dEZ5K1F3THdobU92Q1pLdWFtREpIRzFNT2dHcUhnVGxaS0lYTkFHV0hNUFFLbndVclZGNnNoSG5DQ1hLeXNDZ2o0SGw4UVBPMWcvQ2I0MXB4TjErRittL3c3YkUzUDN0cWRNTjU0L0d0MGJ6QUlMUWYyaEJGUDJQVXMwYUJjam5uekhZN0VlNlJRR2FsZjRMSGk3RVh5ZS80VHRFK0FFU2d1WXpmQU95dmxobzFneDg3S1dxbUxjME1IOFQ0dE1EZzljV2RsaVF5RE5ncXo3NENoNDd5Qjg2WStDQnphemMvL0tEOTd4RFZkQUFQVUtCc0psbHFIYXV5dFB2Y2cvUlNlRmNicVlSRXZ1eEdjTDBiOE44a05wTzVTZzVjSWVpVkgwUjltajVCNXpjOEl0bks2TmNtUk4wa2VuZDFQR2l1MXJZMXpRZ1RCbHZxWUVMejhObC9UU1F3dzJyTEY1UUFzNnBXVVAyTGpScHdPSXhpSjBVcFJTcHgvTjRJcFlDbDMvbjRuVy9ac1lKWnJrZ1NPM3MrMGN2cmVuSTdkaWwyM050OWFhejFKOFVlUUw5aElSdXV6SkFCWXNEZkNnREp0eFZZOGQxYTI0Ym5EOFhZQmxvczQybnA4emxFU0JvMEVVd3dnZGc1dmVERy9FMkdMOS9zbk50VU9TWUJKMW1NRUxtMUVGNkhhZ0I2UUtIdStUNEFXZTFCdWhtTTZNeXAzVmpaSlBzdTkyZ2xHVlMrcnlaNXBoYXBNM3pPREZWL3B0ZHFQcVJHRHlEZjZOOGxRSGMxdkoza0E5eG9rYjU0SitqT09za3hKbmFFUElQRWR4WnQyVmhiVlRiamhqWENLR2FmdGNZMzB3dHhrazVVbE9FbldoTFRTRTR5a2tYU3k0a1p0TlQrSk5vSnA1Q1ArZllLV0lDRnc3YkZ4bjRSYlZaM3d6cm5YdGFFZld0dTFtY1BmZ2wxdk1kWWcza0dEcEFpREhhMXNOTllnMGlmbGNnWk5rbytkTzJERG5IR2kxbk9jajhRRERPV0MxMUhsOUVHOFlPZkFFRzFibVNSRDV2R055bkFNUXFCcno5UkdJSU1HbDl6Z0ppZEVRSEExQ3Q3UGpNcFhQQ2Z6ek96MHNyT3kxZWNSbVRPcXNMUlRqTmVtcUZsSkJuaEpJVnY1LzAxUXdNV3NsY0RLdzZmNkpaSkUwMUVpYUtyZk00VzBsMENOaHE4WWxCclYzKzFaWE5MQzQremdLYnlrQXpkWkw1b0E3U3lZd0ZkMkFtOEdmTzlIS3dzRHRTUjhjcnl1MmJJblFuSTgyMW1vdFU0WWhFYUN1aWZvSUhqY1V4c3d3YlBuU2dtVzJGRDE5aWpZZTVJc29xMWcyTTI4NnhaampUZDRWYTgyUjRNSE5pU3JIVjJqcEMremQvZ0liTG9YVDJyQVY5azdmOEJDak1qREozaDRzN0szNlNqYWhkYkIyUkdZMVJCZDAxaEg4S2tHRHo0NWFjZUk5VWlDY1pQZ1RDM2hKbW5QZGtNaldCSG03Yk9pYTRLaDlsYVc1RVFKZUR2Uld6RGI5UVQ0NC9VWFMrWVhkWG85eWI0NVN4bzNwa3hUeGRYellpZnMxRW5vb1Z3TzBndDFNeURmL1hWZTFIL2JjL09JRWZpcmd3ZFJDbWl5c2lSRk0yU005anZrNEFrM1duaGw3V2t3Q2Zac3dHa0dCOGVhR0hhUElGUTNSU2VCYkNNZWQyOWw1NXBSVG9CRzZMVzhhZlBQUG9wKzRvVDMyY3Z2dmxoWjd0STQ4VVFTenJWV3U5WGNHbXhkTTlpdE1FQzk2MXI1cjBiTDlHUTArcDNjRklvck9uQ011U3FBbGF4WmdHTHdTS3kxVDRJM0J5dkZ5dEZKa3lZSFJ3NU80TUEvelBOSEJ5YnBQQU42bXkvd3lFeC9kZ2grQmttbEh1UklIMEMvSFdkb3RMZXlCOWVqbFNMeGJNd1g4TFlCcWR6TVdmY3crQ3oyZmdCazBPN2dvOEREcldPTk51c0Y0b1kzMHQzUnlBWHdHR0l1bis5L3RGSWxwZG1lSHA3eElBdENQV1l2UmpEaTc3MHM0Q1JRSW9wb3hEdWlpQzFiaWZnbjRTb0RqSTFHVCtOalJOMVoyWVAxRXp3WWl3TUhTWlkwZ2xrSGVPcEdVcDVITWRSb1p2K0ZOWC9BcGlldWY3Q3lBamZDNkVkd3MwR0M1NTN3MG11am9LNk5HYjJLV3hlZTFhbGM5U1IvNUFVOUE0Z09hNURmdUJjU095S1NQMW5aTVUvLzV2VmtMMFA1M0FGWnNDd01HU1NqeHFBdnlMV1BWc29PdldDSW1nWnpCRFRNcHdkSjZ4SVdHRGIveGNySk1jU0ViR0daSkdFeVNZQVdjRHJsd1BKWGZKOWtwWEp0SjB6S282VEoyVGp1MFo1bGlJMlZGUTVSQWlwVjFXMmVQL3N0bnJYMnlrRnVXQlJQdHBPb3VSZURVeVgrazZRejc3QWdSM2lBdS9sMVIxd0xWZmo4bk1haHEwTGw4NGxIdFgxbEI1cUlnYU0zTFdWMGFMc2tYcHRHMnVMN3NPZXJHbWFFWjA2aWU2QkhENEJQQmtNTWN1UlBzMmZQZ2VqWE9WWmd4UVRiZWo3WXNwbnlib1cyQ3M3djF1eHBFNmFORzdHcUoyaUo0aDA3d1dyRVFmUVVPK1RLQXdRdUp6a3ljNDMvZzBBSHJlZ2tianBJQmtoNTA1MGp2R25FQy9KWWE4UmdXaGh3SzRJVGsyTTh5UEdkaEtMckJPK2FFd1RTOHlxMDZaRGxDMDZLTklxUkhpVmoySXNXNFJjbnlUQklnTXIyUXllSDFoeHQyZGRoQzhUYzlHZ3JCcnpXYjE1YmY5TkljMitud2NFckp4elpDYlRJRGhncEUveFBWdXBHazNoVDFtTkZXNDZEVktxRm5wK01Bc3RGV3ZOcjZLMUNpRDlKc2lKSjJqUGFVbTFsdHBUYmtXMklWdGI4RzhRNUYyZWo5YmJzSDh2RVJhWVJUekRRVDdNSGZVSnNjR2VsL3ZVQXBtWVV3MU9XaDVDcXQ2V0VNRndSdkd6bVdsdkhxMm9rbDV5VTJzNUtPWnNodW16bXdPT0VtOFBhb0xPVmd1ZDg0Ky90dWNudXB6bGEzbHVwVGhxRjVPOXMyWVRYUk9BeHlXdUlRNC9BMEwzd3U2MXNVR0pDblo1eXhQc3JSby95dDJJNG5nNmpiTHJKRWFGTTVvK0gzd21IM2NwcDFBa2Q5d240TlFlbkYyVEVDSWUwdS9jT20wV0h4bm1PcWpaTnB5Z3dEU0dzR215NzBRTnJJMW9HU1JkNG5VbU9GcVpFZVVRcXVaM2t1U2Z6ZTBEMUVyQWszSnhKYUREVzErdmdDazdQM3RteXBRNW50STYyN0dYYVM3UWVuY1VQRW5CNDlKVU80R0RTUkU4NXZrYWJIalBidHNQNmpMYnNwSjJBUXkreitPYmZWdmJSMmdta2FPR1FzaVBxOFY1TTVmYTJiRmlzUFNSZUpIUzVOa0s4TlY5MEhaeThNRXMrTHVCSEk0UVRKdEVralQwLzl3SWpJZ0U5U05hSnRCWFZUeXBnL3QzS3hyczVzRG81UVl4SnNPTGx2d01nUytPc2hXYnR6QWt5a3FSWEU2NnRjUkl1bXVsU1BwZC9XaUgxOTFqWFVVNk56S0hlV1ZuWXVCTlBUaFhhazNNQ0hDWHcwM0w3VjBtNXhoVkQxWXdGRjdvenZ5VGlnNER0TEFMT0dTeTI5TW5seVRUd0hTTCtmMGdHaXFYR2htd001NXhlQkRmbXFEYzQrb2FqbFJXZVNZNHRHbkluMkpoQlZ1dGtiblJpWXVkNDUwNk93OGFXNHVkSlJDNmtCSHNybFY3TTR0RjRTYVB0NWYxR2V5NU0vR0RQL1dlUG9BRWJVRnFOK1UwMG5oREFLVE14V1gyTzdFMlAvL0Nzd0t4ZTA0cW1vamJpNGc0T084Qkl2WlhuSGlXdzRPSmNSSFdVZCtaZWpoeHZ1blVqMTd1elpRT0x5ZEV5akJMMTdoMDZ5OXY2eW91MnRweXRwV003cWVtOU9KZzB5RFVtSzZ0aE93ZS9ubXc1WStza3A0VmhnN0xLbFEyUFQvWmMwdjdGeXFaenZVUEJkYUF5V3lzTEo1Vm5yWXBiTmd0Wm5BN1dKc2FwcWRQb1VEMTdvVXp5am1ZZGU4N0o3MjNaY3BGdDFkbEczVVRBb29XSnZCbWRRMHlibGYxYVZSZ1RIVDZRd3lpVURkQzhPQVhocmNNejF2cjNxOWRVeldzdldvb0c2NkJIN0NDTUJMdHJqd2lHZnNjRzZaQUlhTUVhWk8vYVdTbUs3K1pzV0dmTGZycUs3d2RoWlVJbEZmdGl6MXJyMnpuS0lwdHpUSm1WamRmSWg3SStLSHZYRStpUm5mQ1Z2K09ZNW5IS2RwVWZ4Q2oya3N2WFkvMENyR3JpdFNrWGJHMDVnNkNwZlAvYXJGZk40S2hoUGMzUXlBUzNha0NsMDE4b2d4eHQyYWdpU1c2Zk5CbFRxeWNyNjc3K2JjL05ReVlyMnhNcHMzSUN6aDFGUkhTMlVsOGNoUEVJNXJjcGVyRm5EVTdXSlRvY0kvUHRYb3JRZ0ZsTmpwTEgrV1o5bmpIclIrVCsyems2L1FWa2R3SVdPK0xmeEdhalVGY0tQUTRTdWJmaUljOVk0QWQ1VG5ROG8xbTlLWm1lT0pOd3ZuY09oYWIzaEtkRTR5UXFDQWxNdk5ZZ0cyaXlzZ2ZEUGI0Ymc5NDdQTzlnZnpUbVlCTEV3THg0RkZ4QTVzdHNPY2JUeEZERExZYjZIOC9xNEZWdHBLQkgyeVJIWEN2SHVDR25mRVFnTkFydGRNQ1hPMW81V3pYLzdBbXc0RjVvS0M4aVYrWDlDU0tPejg1eEc2MXM2YzZvOTJCK20vaTFvcm44K0cwTzdpYnpDKzFVbUIxWDh1ZG5XODVZVFFLVmtpaXhtRndnSFhWR3NQVW9WTjd2VnBZbnhSbTNVZ2VpNHo0VEdCNmROajQ0SjQ4bWxNYVUwaWEyb0lhalBQR0tkM000KzJtVW5Qdlp5ckhuSnJuL0VRdDJtYU4vbGxsd3FqVTdTT2RlcXJ4NVgrZWZ0VlkySWM0bHlJMFlxUnE1RHAxb1ZyNnoxd1hSNi9LZEhBRktxdVRSSndjM0V4b01UckJGU01CQkc2UHoreE9vd0E1cDB4NUIwMG13OXlqNHRzZjlHaVVaY0pHMDlXUmw4N2xKTmxyaEhEZFh0K0tKMDBwYWJITHkxOEhKUHlkYkR1ZzkySE5uUDlJeTUza24zK0Y0UHdtSEY2eHMzTnVDdjIxRWxFRktTR2tUZXR1bTRpMVZ6SjBoQ3pmTW1zenRVdkd3MGZrK1pzditxVFVqMTF3L053YzFDaW9VNG4yZ3NHaVNnRmZwT1JyZ0UxaWFNd3d2NjR4SCtYNVJndEhMRmZoMFcxSmdoZ0Jwd3h1cFByUVZJajQzRll0Z0FBWXI2K096a1owbHk3SzNQOW85anZZOFA5WGdTVE9MTUFsZFFxLzFLRDhiWkpQVnB1VnBXeVArKzE2MENONmt2U0FjcHFmdzBzbCswV0VLaVBHbWlnZU9UaWJPSko1UXNRMTVaenFSWDZIbkdLeHNJTkxqOVpvZTE0N1p1ajZkY1BTdDJGQzhWVzFsem83MnFBaUZDNU5nbzVORS9FeS9rWUxLbmFaM1ZyYUxKTmQ0QUdXaTFhR0RsUjFOOUVnMzhLVmVqajBLcFRVNUFwaTFsdVJiRnpkVW9GSXRJQXZtRjk2cHdhcUF4T011TzhuZG0rRFdIYlFaemJ6VytmUWcxNXp4NndPU0E4U2duRUhMY2FKZlpjMGJKR3FVR1dqc0JTWGJHUVpFT1FLSkI5bDBySE9JN1QxMjJtQmwveWl6NTlia09aRDZYZkRpQWJ2NFpNOXQxcWRLMm81RXVvSGdEbFpPckRZaDI2T3dBYUZ5UEp1VEJjckUrWllqTFRpc1NZMXRxY1VIclhoQ2p1MXNSTEFUbmU4WEJCYlFnWHdBejAyT2VpOUI1ajl4QXVySkd1QmdvcVNCTDNKcWRaWE02SFNyWncwVkpZeEo5aWs2T0dvdjBlRWVrU1NiUmhBMkJGRTRzV296UHlkM2pON2phR29rd1JDZDRLK1JSZFh1MjQyRDFkUWdhMjJRYWtkWERUNXBvTlFJZk9qbEpucGFnRUdNVGV1ZEZxb2x1YSsvUzhCNHNXVjVPS2N3VGc2OCtSVnIzc3Y3cTZaanRHVzd6T3c0em83RzRqL3I5SklBS3pqV0hvUmVZY2FvdDFJTE9zRlROcUoyYW9GLzJONG55QmZQTkEzTGpIT2tPamdhQlcrODV0Nlc1Y0phbUtpRTk5cjRuTGlpRlBJOGNuS3lYbnFFN3lyNDE0TXVYaURHUncvT2xSNzRJSWJaQ2U3TVlxR2RjT1A1dVRtejlRRU9vN2V5TFpPWlA0LzJJRUlqVmFiZGpGZHR4YVBvOGVXMWo5RUNzUllHdFVlcWtDVVdQTDZPOEpJNWtyNEREUllFaHdYQnJMeXVWa1FVVkRheG4xVmp5OUlWYzk0dklUQ3NlY0ZiSDF0bU1hU0t4MlMrLytKRS9kNkdtUVM3VDVJSXlCQ0tzMmNmNElUeSszK1ZvSldTMEJGQk1ObVhLR3hFZEtpNm03SlhIcjVTeXFWV1Z0dEsxTDl6Y3M1N1pJZnVoRVk2SUFqWXo0djBBUXQxeGdMYzRXaWZoSHFhSEFyR2JGbHl3NDdULzdEbHBPeDk1VGpmVWs2Y0hFcXA1cTFUeGV1bkNxVFFSaEltR2dmTkhFYVE5TW5CMzRvYldXbHh0bkxlMWlPY3dCTkpmRUNNb2FJSldPT1FKMi9EYmsyM2hwWFVHYk1VeEgwRExtd1NUcFUxVjJ4WkdaQXNDSE9HSjBlamJGK1RCQzQ4U0JwdmxHQ0RXYlFrT2dWbERuNXhqdEpkWmVOZU05UzBNZjNxR1l4M3NrVW5RZzRyUXBqb1lIZHRpcWZjYVJRTmdNN0VPdHF5K3VJSjMrRTBlOXA3Z1Z0Um9FVWpqQUFaanNaZU9CbytWckJma21BZ1NoVFhDa1loZUwvWXNodzY0Nm9INEZMdHUwUmE2UjY3dlhXMENaUGpyYlE4V2hNWXlhR0ExZ3d4cmFSVTB3MjBTN2hDV3cwcnNNeTdCcDBRR0J6T1ZqVzRsRHEybFF5VUJsK05uSnFkUFZjaGY3Vm4vWEVRL2wyVFFwUGNyOUhoalRjOTJrb3c0QjF4eEtRNUswTEQxTFJybGdKK3NlZjI2RGsvenhRZ2k5bFlMdElKOW0yZExJOVZOaEZMVDNhMmxCU0dGU3JwMnZGL2k1RjZBWmM1a0lvNHVSWGhTblJTd3ROS2hteXlaUzJhT1ViTWF6cmJzaGRCd2ltWGxWUWZyU3hkT2tzY0VlQmR6MVlPeCtPMXA1ZDRWNlZrUmdmd2MrNVNFT3pFM0hVKzdqbG9MVWVUQTNMMEZ6QUdUekQrdlQxWEZSeXQxSEY2R0ZJRkxHMkZidEo4ZW5CdVZuQys5N2VrQnJkMGZWNUxJRmhGYzJBT2JFam05enhnRzg2MVdWWnM2dFpZT1dVNzExeFJyM29XTGpWRHdrLzQzTE9WYzJrTldUNTM4OTdhbUsyMVpZL1MxdUZaUnlkdGVKaVBoaEVSWlMrVUNEdWpETFlzT2U1bmc3NlhLUDlneTE1WUNsK1V4OVJDdmlpUTRNRXh5bkRGT05kK3B6TUV0aHBxYmFNa0ovUGxxYlpZN3FMbE9Fclg2VHdCdGdTbDRDUklVSnJiZWQ1RHcwR29jQy9wOEp4UTZCM2E3MUZvdW5DTFExQWhpMGVYOEFnS2xhT01OK3F6bGExMlR2WThaTmZnWmJNbi9qUjcxTTVKbDE2Y1BQaE9zalNOUTl5SEsrVC92UkR4YTloMHkwTlBBTHV5Q2RLRzFMZUh6eldRMHVKQ0ZjZFQ1TkpZV1pnWUJZcU1raXBsdVhsdVZ2ekZ5ajVYT2Q3SXd2amNidlBmdGhSaDEyS0RacXQzalhPRmdBTDJJUFNQdGkwbnlOK0QxakI3YnNYK0VkUklSRmFLQW9tY2FUbGJPVXZwTWkrUTR0VFd1YW5VZGlhNTdzWUpNRFNyNVRYd01QUEhKNTF1OUxwYkRkNExxSkxjQjRVdlRTV1JZMVl2Q1U4T2JSWUU3eHVZZ2R3VWc5MWNUclpzZzVRRHI5L0IrbmduWUhLdVo3aVZEYkNLQjlBcWdTVEhTUWJnSi9DbmpaVnptVFE5bUJmbmlQZjlhbVdiblp5OUltOGJuV0JqTUxQL2RneXZkWXh3bEt6S3Y4MGZaYjZXbFRyY2lFT2ZIRThhbk5TbVJ5VnFvenNQczVJZW9ocEsyMUZxbndOQ293dFMzUjBvd3F5UHBaYTJzM0xlN2NIS1NvTEp5aklXTFJsdkhQaFcwRzlyM2pWV0Fvc28wZjBvNmJLOThKTXRQSS8yQXpqWmM4M1JHVUZZcmdJWTV1UERLL25OV1JYMmJkV3hQLzhIQzBWaGRhclFUUmxmZnFyUVVOTUtyci9tVGRVb2o1SVdmYlJsZjlnYWRQQ1NERUZPRnhOY1BqblpPTmJFQmFIMU9pdDF4cG9WeTRhY3UyZi93L3lPaUhROG95MGJlM2pKamNhV25jSlhLVUdXdFhoY0lBVU1LdHRyclZTbUJ5c3JXZGt1aUJIcUhUaTZmSkVmUVhkUVlOMGo1Ym9Uc3Rva05hdmwzc21XODdlSWU3c0twcXpoOHEyUEN6YnlXcExBS3BILzVGQlE2a3dtd2ZiWk9IcUhDU0c5eDlrRHFobjJ4RE1udWUrL1MwRCtKTUdsZDEzQllTazRyN2NPYUNXcjFUcUx5WFNtNW9IWmYzU3lzdEVDeXhoVXRKQ05laTg1Nnp3QjhIL21YWnVQL2QrdzY4OTR2NzB0cTFaVkpERTVYb25IVTd1U0VsWHlQYTZrVjJ1UDNRYU5nS1pkUnlmNmp4WG9vSU15UnZQN3RIb3NRMi9MQm11akxkdXk1eE55WitYbytGWXlXeHoweGlMRUtIWlFTOFI0SXA5cTc2dlc2Umt3eVhHaGdsbjJ1UnFGQkk2U0pXSFBVU1lkY2xydnkvd1pIK2N2LzhIS29XSlpjWFhuWkh1aXBQQkdXL2IvejNUSkJ5dTFvTTJLUHNJcXhwSXEwT2xhd0dSQytuZVZ4RWF3NjUzMmRPREVKRHh5ZE5LYW1qVHhDa0NWTGp1S1E5S080aWZBTGRYVWNxUFhvRmhmQ2ZSVzE3VVZFbDBsWEswRUpkb1RnQnhuS3lReUZVTGo3RGwvblYvM3dVcjlZMWF4OTdJVDQvdzZUVXgwRXNucWlIVU9zZmhndmdRdnJlVHQweFZjdW1Xc2p2ZmFycklCUEl6cVZRbE1EcDNsZVNhV24rajhCNVpzYzBQdXJleUhwZjF2RTlpZFJ1Q0R2bWNTWE16cE9iMnp6a2tTUGVsYVVvQ0wwanVMejFia3ZZRDVqSldPYzBDVUE2bEh2Tjkvd3d1ZkVGMW5JODhnUGhQZHYxaFpTa0Z1Y2JMMVpsL2VOQm5sUGJYelg2MmlOOW5MaHVtbUcvTDkxelpLclRKQnk4b244eHRqNk9iNGF1VmMyT2hBazRzNG8xeVZ6TnEyUnZDMVRwbWtJRjhURVZiUlBheXlBWjdxaWdHVEt2QVpEVjZFbjcwNHRFVnVmZmtCUnNuYS9EMmVld2VzUkduWjZOd2s5bDJsNXpuSmFUQ2EzeHc1M0hDRXJ4bmtMU2xaTCtMOTk0b2hoMHJpSWovL1pLVnNrbjg2SzdzcjZ1VHdVU2dyR2xQV0cwZmc4QVFJeUk0eXhNR2RsUjJ4QjF2T01nc081M3F0SDhNQ3IzalZuOEZLNlY0V1BaQzM2Mkc0dVpId1VUSVVlY1lTTDJiQWEvZWdydTdBM1FZcm03TWxXeGFiVWJySXhtOU02VTdPWXExTjhqWUh5bmk1LzdCQlQxQXp2dng5L2xISmRxMTUyTW1XMHhFcEQyeWRyRlkyU3AzT1BWclpMTU1jZGlISEdUdWtZQm1YN0FRTFU0N29jY21OTFdma1hrMmd4Q3VwdnVSd2xJcXYva3ZBZG8rb1BxZmplbVJCRHRpWjkxWjJaMkgvZkZYdEowQ0cwWmJDYXJPeTQ0c21BbXdEdHhrY0w3ZHpkQURmNHBHdjZSQTg3NnVhMW9TMTFxeWpidWJKQ2N5bzh6ampoT1NZKzBHKzh3bTAwK1JjbHlyYkpsdDJnZVJHdlVWTFVRUllHbUdxNGZheVVCeUEreTk3RnVKeWhsVEduOGQ1Si9iMkxERWpkdm1YL1NFaEhNQXE2Q1pwSlBKa0pxYTNzdkZYczVLVjg0SU5zM3FKY3cwamJpa2EzSUpod3dvR3JzM0oxVVJNSzVHL0ZoWXlCVDJzWk8wbVczYnFOamdQN2RXUTRkcWpRMU1xZEd1RUlYalJlUGRZT2ZwMThWdUg5c203NldobHNSNmJmK1d1SFhmSUlmTklHV1lEenNKc1J2TlVzbXVqT0pNam12emZJRG9HanlwYTA1Z21KN1Y4elFNTXRoM2pYc3Q2WFhzdVU1Vjd1OTdOeFFRK2RWWXEzMHhPekFHblhJUzN2U0E0MjhGQmRjTEdOT0paYmNOUjM5Z0dCVmFzTEVaYzJYazZuL1JpeXlLOUIvek5CbTNaTS8xTDhzUkpqcCtEbGFKZzFRUFFZN0JWams2NDVqVU53aG1teXBGTDZXS3pJYzFLS20yTG9hWVZqMXByWU9ZMTV4Z2N2cFZzenRueHBHc2pmM1MyRnpVWjdQQjlQLy8rSzRMWGd5MkxQL2VWN3hVYytpOXM4Ymh0WlFFcFBobWR2SG9XcTF4czJkMjV0K1ZzMUNjckpYM25PZUE2ekY3M0VXUzBXYW5XMGpvaERtb3dCNTgxRmE4WG5JQk5LMmExcktNV1dHMTloSTFlMDlzc1dzV2hFcjdnOEpUY21FMGxtQmtjMkJkd0t1bmttSjB0QjNVd2dNdmxMaTJTQ1Jwcm1DMGxqTHluNDZiRm5MVUJvUksxZW8zQU9HYW1RMUJFNVEwbFpXZjdROHQ2c1dWVHNqdGJLcnJ1UUgrd216Ynp6UlJUajdZczZXZ2NUekxoK05MSnoxNUIzbFlzV3V0cGUrc2pyWGdZNVlzbmgwdFdzWFBqUENkSk1tWjBVcmNxa003S2Z6b2puYVJEaWxBSFBiUHhTU3RVNTJUTENUWlZmUUFiczhXVkZLTzJhdytTVlRLSnhudmtqalBWd2JxZHJFaDZ3bnVjeGRObDcva2tHNmExcGI1VzgrdnN5dExZY2xDRlFvRnhCVmR0bmpaU2dWWnJCbC9OaTYrUS94Nk5SZHpPTVo5bVpWdE1wbUc5cE1oWlB1c3NNSTJ0OXdPZWY0QzM1OGg1aFZORFpYMXZYdGpKd1RmUmxyVk5RWGJ2SklJRWZSMjlZUWNqekhWYnVYS0FROUFDTkFLZGM3Mk44SGdVM3pTMjFJV3Ezck5HdnFkS0d2Q2EyajFkb2FacWZRVGlCaU5WWGU2ai9DNUtVb0NueGlBNGw0bWNKS2VTRGlKNUV1L00rNWhMNUxOQmY3VlNFWmNxY01YTUh3SjRVek5oVzFsTUJjbU5YSFMrdUhzYzM5bmxINnpzakpJa09pZmw4azk3N25KTjQzeXc1eEZFbzBNZlJRa0tHMW1rUnJBVEE0YW1rczJyVFFPOFpvQnJVNS90Q2oyMWxzWlZScVFtRUprY0xqTWllVVBlT1FkREYwQ2pKeXNIWmxBcVNDei9ZTXVxWnpvWnhkcHJCWm1iWllLeHd2bHA5V2lOU0w4QWR6emFjZ0tLMlZLSW13VVR2d0REN0t3Y1QvTVYxL0NMay8xUWRaWFhkcjJISngwbG9QQUV3a3BhbTYxWFVWd1RYMS96d0lwM2h5dnZyYkJzc0ZKY05BcDFwK25vS0I1eUVBNDA4K0luSWZrZnhTRFBWbFlINURxNVRweEhJeW56cmVzVnJzRUFUd2M2Mm5Lc29jZVBFZk45QUZWMXNMS3VuTkhnTU9mRWM1VUFCdzlQQ0x4TytOMWd5d2JBNm5HVTVobWM1eWFyVCtnekdIa3ZSOXI1aXRmYk9xcmMrOTNGdVE5bVpWbk1LSC95aGh3cVdKZ2svR2hsdFhFbndXNk9PeDV0MlE1MEp6Q0xmVmtwb3I1WTJSZHNkT0RPdFdtVk4vR3NTZ1hWQWc1bXNiU0ZZcjdJQi9DbFBaaUJDNko4RnVHTkVtUmRzS2djelQ3WnNuM09XRWtCN216Wll6WUpUdElvZVdmTE1VRWM5YmtGVzY0OXh5UHVkK2JyUDQvT2Mwa3hUVTRRMWxvNVJzbmpwMGRza01IS0hnNG05RjVycFRTUTdVNVo1RGtnTHZsZ3p4WEU2dnhTSlpWL1ZSOFFIYU1kVnlKWGxxSDB0aXhjT3dGMHMzOXI1bVNUNVBZekxaTDd0VDRnb2VCTkNNa2VqM1FJRFRRNWVYQzltWjB0NTZjT0Zib3FPZStaTmh4YjF6UVd0cEt5RFJYYWFoSnVXUnNocHhWTXFFRW9EZEtzYkRNZndjQndBdmdJQnVkWDRGejJ6QjF4RHgrRm1Ra3JjQ3JkNGxrOXd0WWJ5a2F2T1RtY3E4SHdtRjNLQnZmUnlyYmY3QUNTSS8rY3d0VzI3eGNyVzQ1ekdpR0Z3Wk5RYmFOejdIaENGKyttQjlFZlRGWVhyQ1JiMTc5NjRwUnJXWnZKbGxPemd5M25lZEY3OXJic3JLTjRucDNLaytEY25aVWlHUjdqWDZ3VXlyUHFnKzNoRzFzS1lieWkxRnN3ZjlIa1FxMTlMZU9nbVo5R2VNNEwwbjFtWlFmQlIxczJRT0M0bThIS3VaOGNwSEJuNWVqTWhNaDBaMHZoaThuUk9ZbVhOY25lZU41ekZPeXEzVmNHWnpNRVczYUtEamRBaGhvbDVqRTFJOWFzRjhQOVRlNVJjSGhXczdMd2NyU3kvZE1UOFByZXl1azhaOXpyaVB0bXR1dytIall3SHpkalZ1OEl5cmhSMnpJT2NxT1RnSC9TVmwrc25MekNLWDhuM0p3RHNORG9CSGdQVnJaL2J5cGVkQlRjcVo1SzU3cWV4SnVvcDUzRU1Fem9OMzEwVi9RQit2TlJQT3EwY2dxcTNxSFdVTzZJKzNDcGZQY09HNDZ3TEF0V2ZyR3lDeVRueDNiQXlheGk1bURpMW9rcGFsNTBrelpnQy85M3FieWVhZEJHZ3E4V0Y5ekJLKzRRNVdldGEzNlAzN0dEY3dCMmhKR3p5VUlqeVFldjByT3g1ZVM5V1BtT3RRN1VPdWRwWjNXeHV0bDZnMkN0bWxYc25NeWZ4RTNoZGlPd2hOSk1zZ0ZrRVpRNzdpVjRva2ZOVHVCeE50bzdKR2tlNWY1ekd1UEZsa09VQjd1dCttS1RaMVZDWEdraVhZamdNQWdYOFV3NXVQcUNLREsvOTIvMkxFckpOK2VEbGFQZkRmajFJbGl0bGFOWk9WS1Y3V20yaUdxdDRBZzRHSmgwVnBhTHJBVkRIbnVpbmtVcHQ4SE0vcTh0aGRLRExVdXdUWGhtYjdadWN2UU9QQmxZL1pHd2tVK0FiMWtwOTBtMEh3TW94Z3RnMk9qY2UwM2phOE81V3hxSXVJQi9UVWxmazVaMThKaTZpUFFFclJ6djJnR1BHbGdkczdPM1pYbE50R1ZKaFpuZlhrZDdoR3FFbXF3K0JidXA0RTR2b28rVjRFbG5FMHkyN1AydlhuMHl2eFJta09oZVBhZTI4ZW5GdzFITVlnaTJjZ2NkZWt6RFdrL0NPMGVCSWF5TTdmQmRMbFl2MDVtMlpyRGFGZHdRekMvTm5weW9tQU50UCtMR25FRHlENEpwY2dyd0RsNlQvWmkwWElQQnd3RUxvajFiOWJXVDgzM2lDaDVramIwR2F0ZnkrdVBLa2RlSjkvV0dzbm5lbndZN3l2TzRtWHBKMW95eUR1U0pMMDV3MkNKZ1lnditrNXdtRnptRldpdm5NbkJpOStRNHdpRHdaZk1qYkh4T2NuQnVzbVV6REM0Syt3dmtRUlk1SzhOdTFBVHIrVXNlb1NzZ21Yd1BEcGVUdTRsUDJWeHNzcVVHMUt1QTBHTjhzSElFVW1PK2FEaFc4dDdlZUV2V2pFMlZBSkRHcXNRL2xVdXhnbnNISnpBZTVhUmg0bWFZTVdtT0NiNWFXUTZUQUEvTW50c0o3UUVYdkdvQ3F5UUFhbExVYmRxQXJXTmQ4T2FEbFFKY2tzck15SERDWUc1dHlZSzA3SEdmNWovL3o1NzFyRi9ubjMyQmtVWmdKNzJaTEwwK1dTa25qQlVjenFPcnQrVkU4RUdZamRHVzNjRVZvdzRPZTFEclFWRHI0SmdjQjJDU0RQQzZzWGdNams1aEhCMWorbXpQVlIxNTgxNWdlQnhHMGxrNWRJNzZoSk1FcnAxY1cxdkpqbTQzUGpSbVc3UDA2RVRHWHJxUFlwTTcyWDNhK1Bkc3p5M2NSd1F4T1NQeWl6MnJzRGg3Z041d0VrL2Yyckw4V05WQlNUSXVyUzFidVNkNGtvOVdDczFyMk5pY1FHMnRrZkM0a3M0ZWJhbFhUYllVUUVkYmxxcHo4N1k0MWozOEd5U0M1eEUrU1BMa1pNOGlKRzdNdmFPalVFKzZxV3hsemF0Nm1MVm1xR3c4b1NtL3libGg3UExIOXV4UDJISEVsa2VobDdJbmpwSUtKVzlIUWJDV3ZKaWpBeGdGRHBBTDFPL2U0Ym1VTi9MZnlXRWJUSUlnN1NTdEJsZ0xYcVBWNjVSMFFrdVM5TFNPVDZjMys5M0s5azREb3ZxRGxVMUxjcm5SeVVyVi8xNm96Q2ZKZU82RU9udVJvVjdqV1QzQ2xtQzRsNFdrMkpwMFQ5NXh2MXRaQi9RRWNjTUYrRlBIYWg3c3ViSmdEd0ZNSXhoc0JINWlFa0U5bnRkc3dSdVRTU0d6VjlvY0hQWkErMEUxRXNReElQRm1YSmt0Sjgwazg2V0syc05VWjBCRWgvcmkrNC8yWE95WHF3SjI4STZUODltY3pOSWg5Nyt6WmNrMWJXRVBuSnVjMC9sYVhPUU9jV3Z6THlwMVdCNmxkWTJDMk1IYjVhUDNxWkpNbUVRVGtETW9SMW13blVTdUZHYWNiTmtNYklDSGZKQklPTW5SMlRpbmhOZlhQemhCbGllY1VVb3BPRnl1UnZkZXEzWFZPQ2dMRUJ5YXlvVHJ2TWdtNm9XNnUrRC9JOVkxdDhuWHp6bklKdWlFVmFDMk9WVFlqcHN6VjE1U1lFMllVZU1VYXpPcGVNendHRDlicVJjbEM5RGdDR0hubFFUNFFIeDBzZWVxMlFkYkNveTFrTkVrQWFFQmlZcVlPZFZrY2p4UEw5aXZNVjlScEtVbXlRbkNwamxKc3RiNFFvMzNZbVhCSGgzRzZMeE8yUnZlcjR0RS9uc3dOajNXL0dUTDJiRVhKeEdnbjZ1YTQ3Q0dVMnRCZjd3UytZY3J5WUpZQ1NUb1ZScDg4Y21XdXNiOHZOK0FpUjlzV2QrVldZT0k3TW9FU0RISWtjY0dERStJK3RlRU96U2dmenZYTzVsZlRxT1ZCdVprenBvVmJVQVdyaytPY01aczJZKy8xb3RXWWRMa1VGdkV0NXdwY0xaeXhsVjJMRG9JeFFUcjdtMnBFZGJxNTAwc3dEVm1hcTBTMHh1QnJxQi9xQmd2dTZsUUp6QTZScEduRWViQTZKTUVQU2ZKakoxQnJUU2dWNEpFcVJRWWs1RDNJbGVkWlpybTZ6QW5rSmxzT1RzMk9HSVg3OGJvU2NZWnExNWRQNFhXeXU4U3dxaVJORmJxVlM4NHZRSU1rMW0xVHVnNVhrdHJ5NGt1N0NYUmdoOW52TkE3Rzg5ZVlxZzFZMDFXbHdqcTN4Nmh6dTdXalpYU05iYno0ZERpQnFUeWIxWU9OMmFxcjdmbDREaHpLSjU4bzNZaWRqRW5HNVlON1l0QUFmV01VeVV6UThoemtZZzZPWUtTU1pJUEQrSXhQWVhTSkh4dmtLeFNJNEVZczFlRFlPamZyV3dqbE5mbkVYejVrNVZENGZqOUtBYzl3a0hrVFpCc3ZicjExZGdBcTJSamFzMTBKOGV6QkZCUG5RUmFiRGVUdFFRWDBRWjB1Q21mbk9DQlI3M09SR2pncVE5VzFyeFRmZFE1Qm5lMHNqdmg2QVFGbzhPU2VCQ0FyMVhpWHRmekExN1hpN2NlYkNsWkRBNmJ3R05mQjBOM29KOUd3Q2ZHQTRPVlBWaGJ2SGJBUGJxMzU5YjZJMFFzMnZBdXlocWxiL1dxYThacVZ3SXZlbFp2T0pkRyt5cXptNEJqRDBKL0RHQUk4dlBPOE14N2NJSkphS2VzbS8wSVQzVEFVYm9UdUhLQjkvVzYzTVVWTDFwTHQ0NXlSS3RoV1NYcTEzeS9CbTlqSlREVVFzcTlCS2VrOWJRVU8wbFdpaTJCTG5JUGU0ZjdidVc2dE4rWXNnQ2JLS3JWRE5aLy9oTzJqOUcwVWszbFZSQ1k1THlKYlNoUGErRnRCeUhpNyt5UGVwL01LZDdESSsrUmFLRHk2MmlsS0x0eG1BQm1md2JCdERyemxFS2RLRG42emttbEt1SGZPZDVZT3lIV2hCNWVHM01OWGtkNW44Rkt6ZkFrUi9XRFpQTk9EdHpnbVBjRzN2WXNtVXpsaWhXNnhCVkc2V1pqamM0THJ4WEFjUzdTNUxBR3JHbjMzdThnUjlzZFBEUTdGZzdnU0EwcDF5ellmckt5NmpTbmVJUGowWUl0YStWMW1vblhNaWc1SHRSZzZEMXdiQkw4U0lXVHdoZXVrNUwrRE9KMHJVZlJhSndBRlRRVmZBRmZlaEdZd2VadE84azgzWWt4bm9UMXNjb0dyY1UvMVg2M04rcFNOaGR0SlFjak5RNm5GcDJvMUp4VTR4Ni8vMkxMTG5VN3BQUW1DQ1VHSzZ0VGYzVVdKQS9FSmVUb3JON1VvcTlRVTBtQ09zV0xGNkdLT0x5M2RSZ0lMWDcwMmxpYUJIR2pYTmZrQkg4cTRqYWhpdzY0Ynl4em9hQzlSVkQxQ0NxTE90bFJJSjd5N1FxSm92blZGQzh5MUFVTTJBQUZ0TzNQNUJ4ZGhBSmp4VE4zdUdrYTdIQnlJWTE5SjJtOElGVFRIaDZpQnl5NHQxSVRhL2JjbXBFcFF4YkQ3V3c1eUtPVFNGeVZWZG9iVm11L1d1ZkdhZmNiSFQwNm1OOFlPRlkyVnJLeVREM0pjVDQ2Q1lWT3ZMaDJKT3dseUdVQko5ZmpYT0hlcDIvRnFsVmp2V0t3Q3ZDYnlzWHNKZE5CZk5vS09kL0JDRnRncXdPZWwxdTg5NUl0eWtabW9Mayt3UkNqNkFkYUt6dVRaQ01mSmRBeUIxOXFXMDN2T0l5MkhQc1lLaDV2c21YSmltTFh3ZnltYjJhbHJKRXRLNVd0eWQvM0FYcU1IVkxnbzV3dW1XNk15QmhlNUR2M3NrWnB3K244VFlaYU5kYU53WlkzOVpoenN0U28yTmRLVTdTRDgxelNLQng4ekpRc3A5WGQyM01MSWpJT3JTMG5iQWZCbUVHOGpFYndyTkdQNHZGcUxYRzhySkpPdko1V3ZPc29iSVE1TkI2TDhnWTUzYks4TVdmdkhvWDd6Sk1idjJERHNrYUxUaVZZV1M3dkRZVHplaXEwdG13ZzhtSmpqZDlnL1RVdHdTRFJxNG5YT1F0Mk8wa3d3aDVMZVFEeG5SRGJUN2hCSDYwc1ZzeHo3ek5OOVFqU24xRXhaelNkYk5tcmxYU1lPU0tSdFVGdm8xQkhRVks2bzhDSTFwWXRPb09EU3pXenBLT2VpS01iYUNieUpyN0gvVGpNMy9zVG9BRjdaekVnN01Yb1VzV3pLczg2MkNzK3dqV2ozT2hoUFVPT1ZxckpBNDRWNGlRVlF1eWRvNUN2WnprMDhYRW11SStBQjVrT08wQ2dNUUVtY0pqWkVYQmdCTVYyc2VWRWxONUp0WHBsM2NGaENLSWNwUjdKcjhXQ3Fnbmdaak54RWxFTWpnYWVqYnNWaDNNUzdNdHJ2amluYVMzTHFaajZtK21xbTR4MWc4Rkd3VXUxbWFRcWREallzdUtTazVVUDhKaWY0U0ViZkc1dWxyR3pjdlRpVHA3WFNrQzNsNnliSVl2RmxDMFY4NTB0OWJMSzV5YnoreFlNOGpydEVUQktRS05TdWxFZ0NZTS9acHhhZUZmR0JZTzhkOTZNOTJCWnRPUmxKN1NiSHZuWHhnUjVnKzFlYktpYmpYWEZZQlZUbVhNc2VydFBkWktORXgxek1uUE9kRDNCOExLWFBWblpWSXdDbDB6YjNGdlpndndyNEFQMXN0cVRRTnVUN3h3UlJ5TWNhVEMvemVaYVk0MVk4WjVxS0ZFQ1VTcW90UG5GeWNyNVlab0tKdDd2RVJRcnd6T3RRSjdKb1RmVGEzdlVxNWoxeWdkNTVSbWVJWHJ0RFpYUGJPVkc2c1M2L0JrUEVnMGZFTmxTNk5FQk11VG5mQlhQWStMWmxOQS93Uk5mUkFCenNuSWNhRm9ScmlRbjZMcFkyUXd0YzVxUGNvd09EbDFsb3FmSWMzSHp4TWFuZVoxTXVPcVRlT1lKMzR0RzNBbDhNRUNnc0pJMDJaay9nK0xWRFBVbXozb0RCN3RXVWFEVFZjenh2c3pHdExZY3IyaENKZTBRUUpoNFdZcSsyYXNyWTJYU1l5Mk1oQTEwZTJFNnRQemJ6RmVnQlNmZzhESmxKdENEd2VjZVhqM0tKakE1NW9NYzV4Znh3Qm9rSmlzckxmSm1QY3RKMDB0YWQzSTQ5Mm1Ocm5vTlE3M1pXQ3NHV3hzcHFVOXNKZStzSGtNZk85eXdUTlJIQkVla3d3eXBXeG9QQTdyc1lSaUFKU3VMNExnQkVtQkZFSzJBaWNHTzhPaFJVcUNqbkJRdGpHbG55MXFuS05rekRyUGJDWDFrd24xcTNaWTJJTllJZmJKU3h6bzVtMEliZzNpRytWMlAveGNiS3d3MjJucG51TFdSM1ByOFJnS1dBVjdTY1BOM0VtR1BWcFlEMytPWVpkc2hGdVgxOXR6Y2pTT0pEclpVMXB1VjNiQTU5T05reitxdnpwYlRxWHZKN1FjSDNwQVphSVhtMGtZZHZlRGtpeTM3SERTT0hvRmlIV0wrRnM5alk1REdvWndDTnZ5MEZhTytwcUcrMkZnZEQ3dDIwUW9EQnZGS05LeFdibEluM3ZSaVpYTzBSbzdCVEgwOTJiSlJjVGEwTTVpSTA4dzBaQ2dSQk85UklVWkRuTVFySzltZnNlekpTcVdXMTlPS1JaRm55YXJ4Q0Ird2ZoMzRWYk5TeUU1YzJzdXBjTVoxWkxydUl1dW5NQ05hZlJ6N0xYSE96elBXRzlLeWE3L1h3V3ZhazdXVG5INk8xSi9nalltdldOY2ZiVGtFamtkdUk1Q0RrNTRaMWF1K2x0cllSbzdNRHNmbzJVb05ieEx2YnJKaG1XTVA4bG1qY01JNk0zZDA0b1ZCZ2pWNnhsZzVDUWVoM25Rc2Fsd0pyTCs3d2NadmVmRksxMnlQQmRDY3RRWWhyZmsxWGhkaENFNHdQRlh6YzlMSW5aWHp1aklrNk1SVFpTcHJRclRQemlSN0s1dHBaRU42bUEzcndjcTVVNk40NGx3ek5nb0xrUnpTbnA3djRrVGhyTW5mQVNicGZJQ3paQXpabFpyNkI4SXZpdG1aRG00cjhPaUhQOEtyVUFyWGt3YTF3UXpSeVliUUkxSm40TFdnM01ISWRFNnJJV0dRa3d6NXVPK3RuRjQ0SXRORkQwMGV1TGV5OG9INmhYc3JaeWRvRmtzWmdjYko2ek1McFgwWDJDcjBKRG9DYW1tcGlEcmJzaDlxRUdxTlNRUnZsbXFxd0x5cldQWE53WUFOR05ac3ZiR0I0amN5Qnl3UDhjcDhHMXNXcC9INTJRdC9zTExMY3lzQkNvc0tjKzFXSTU2R0FkTk9BamJTV1JURU1QRGk2QjJlQm52SlF0R2JQMkhENVB6OGVUNHhlbmpOZzVWS2ZpckZCdG5vSHUybFBWYVRQUC9GamRSZTIxampkL0xZWHFzZWIyaGFxbVJIVlA0MjJIS3lzOVpNRFhMVU1tSFFpcEZ3VE9RQWpKbWxkRitFN0g2RTExVk85VkZ3NEpQd240em9PNlI3YzJGanhxOHNHWGtVV2l2RG1Ec3JWV0N0c0FXc3B4b0ZMMnRDUm9zODZVQlVCaGx1Tm9CWE5sU3piUVdETjEyY0F3blNTb28yU3Fha3QyWGpCZzVvMEFrZzJ2enNBZzk2RU82eG1ZL3JSeWVDRGc2L3l2ci9uSG5xcld3M1JNcXBGNktkeFhjVERKbVZ0aFRqTURkL0JrSGZTaUtGRTZmWmZxakQ2eFJmVWk3SkVoZXlIOXJQZFhBY2pxMVFsZC85MGI2NlN5MWJhSG9QN2VRY3JPeEtwK1VqR3VsNkhwS2k1N1BRVFFidjlTQTM1d21RNGdrR3JOcldDWUVlNmFpTSs0NlM2ZUVJK1NpY0s0L2lDNUlYR1h0VEJENUlPdmhKMHRRMElwM0FTR2FCNDlhOUNUTm5jSzJLUld2S3FoL3FWYjhiREZqcFYxUkx4UWFoa2JSZXltdW13Ym9uazRoYzJ6azJRaE0xVmxZTkVCZXp2Q1dBcHNvYjV6T08xajAyL0tNRVNsL3RXWmRnOXF3M1lKa0plV0V0S3grRWgyV0dMc2hHUGNMenMyZFZjdWdvRmJoVDlwZ3FtY1YwNnduN1p0bUFEVUhYMXRIbW9SS05hak5qQTRaOEV0YWdBeHhnSXNIcmlXcklRa1ZKUnJCMC9BQURVaDByUjMrMnRpem9veGVraWtvSFIreUYraG9kaUtEQkQ0djVrdmt0NHMyV3paODlvVkZObC92VHNlb1BNZFlLVTlCYUtSU3VOZEZOVmxmeVJQUEhnK3VBRFcxRnlZRHFLTVI1bGhGU2RwZmhBSS84RXd5THh5VDdDRERWU1o0M3lNYklFSVhpR3FaZ003NDlXOWxQWVVKQzVGR0NPSjB6RzYxZUVuMVRmLytmWmFRLzFGaFgrTmphUUFTdk13cWZNd24rMGpMaGFNdmhhSXorVzRuWWR5RE8yYjgwQXN1ZHhjT3lxREhqd2FOa2ZITDU4MW1TRUZtTXdpN1NPUjE2aEtlODRQOG1XYllSMTh0WkRyMHRXMHpTVXpMbGZVMDR2Y21JZjVRTi9WQmp2Y0xIMXZBMHgyUXE1cHZFVXljWXdVbjQyR3hBZC9hczd6U0hydzBPZk5nN01FSnBJNjJoWWdxNGtRaTdGV2JoQkM5S3FxMEJwY1dmbVpVNlcrb3JldlA3anhHekRnNjhlck1lOWFjWjY0Yk1seWQ4SWU0YkhhTU9GUTZYUnRVSmFlNGxMZFN3RHpBWUU0d1liTmtiaWhvRWVya2REUElpMlN0SzlEaVdpVlFTYThIT3dvR09rcmp3T0ZQRGV6UzJUQW1udDJ5a2I5RlkxeFJiTmYyazlsSXlXNVpjYUtjWWxtbFRUcWdUc1R0YnRzVVpyV3dxZDRHeFJjRzZqV1NUc3FSUWEvdDVMQSsyN0dIRmRIUm5aYnZPdFZaT2cyVDFXQUQ1YXJ6NjM4WllWN3lyWjZ4clFZRWEraEhCVWtCMG44U29OQmhySEZ3WWJka0IydXVOd0dabTdBSGJTV0tEZkRPN3VWQ1IxUUsvbmdXclg3dGhxa2VZS3NGc3VOVzcvblJiK2RrWDhJSWdiSTB6MXBLTG5aVlZudG9sTUVra2JsWlcyR3EvTHF0RTF3cGJPQ2h1QUk2K0NGN1ZGa0gweE95YVFnTnZ6Ty9nWXJjUTl4c294ZlNXRFBWTkd1c1ZiN3NselZjYnFlNE5mL0RFMjE2clJqV2lNekN0anJhTVZsYlpzdTZNcVZiQ2tsNDhQUVBGczBQV2o4N0pzallJT3IzUWFPMHQyY2ViTk5hYUFXOUk1ZFp1UkhBSWRmMjlkc3Z6NnExR1c3YW5iRzA1WDVVaWFYcHliZUxHaWRhTTFLTXRld1FFcTdlUDlBcjUvblNZZE12UithZDQ1TVZiR3oxekJjZHB5MGppeldSbEx3SXp2eldPQ1hUUVJtNXN1UlBsNkE0T2RhUlZxNE9jSEtxSTR1VHYydlBXMkJYMzUxelBGNjd2dTJmOVZpOThoWEZRN05tSWh4ek5IOUttTUVUTFZwUXlNMXZLRk0yV0VzVm9kZG5lV24zYnphUFFhWmhjcXpkL1gvK0t4cm9CRDZ0bVUyY0llT3ArUXdBMk9CQ0RCdXRsME5LVnFEeFdETldMN1A5MGtmeTdzYjVlRU9mZGNCMnlWdlBJV2duaEJYWlVqL1cyN0JkbEZhT3VkVGdKSzNUZVg4cEEzNDMxNVJRYU1XZFR3YWJUbFUyZ25Weld0S0xYRkZEZnRhbkV1N0grdVEwM1ZDTHYybFRHMmxGOVUrR2QrYUtkdit4eC82ZG5BMzQyRXpFYlFiSjZyeXB6Y0diR3VPWXdDbHM1T08yZ2ZlMGEvN3BPNDkyenZncEU4STVsdDBXNWJldGVVNTF5OG5menB1L0crbjBNMXV2OTVRVmMwMHVpK2IremtiN0RnRmVBQmxmV05EbHN3dVI0eXEwNS9MKzFvYjU3MWg4TEVkYTZoRytLOHYvT2h2cHVyRC9IYUwrWFIzODMxdmZIKytNZHM3NC8zaC92eHZyK2VEZlc5OGY3NHljLy9qOTc3N0xrT0xJc0NhbzdBSklSbWFkTzM3NjltZG0weVB6L0o4MXVGcjNva2I3M1ZGVm1CSW1IOTZMb0hRcUZHZ0RHcXpLclNKRWpkVEtDUWVMaFVGZFRNMU83YzliNzYvNjZ2KzZ2T3hPNHYrNnYrK3YrdW9Qci9YVi8zVi8zMXgxYzc2Lzc2LzY2dis2dk83amVYL2ZYL1hWLzNjSDEvcnEvN3EvNzZ3NnU5OWY5ZFgvZFgvZlhIVnp2ci92ci9ycS9mc1JYZTc4RXQ3MCtxa0hRdlY1cHF2eVh1TXo0NU9IR1cvZkFXYXZlYThUdnI5VkZmRjhnUHg2bzNnSHk1MzNkbjZmNzZ3NnVkMEM5ZytFbmcrM1BaSmgvZjkzQjllOEVycnY4TWYvRXovdTdiQ29mZnQzMnlrSDNaL2NPcm5jd3ZiUFd6enlPTjQrdTMvSDVQT1R2aDJMR2QwQytnK3NkVkg5Y0lJdGM1cmVjNSt2UDZqem5DN3lML2EzSDhyT3o2NS95SE82NGNBZlhkd0hWdjNGVy91KzJtY3p3NDROWTcxOUt1NzZEN0IxYy8wNXM5WmFIOTdVUHVwdFk5OUdoK251QzB0N1JPVHhFRjNpbkFSRS9rSVJ4QjlnN3VONUI5UjFZMTJjQU5YKy9BaGl3ZjVqZG44a0cwdzF5eGRiZnZoVWM5OGdoUHdRVHZnUHNIVnovREhCOXI4WC9XUTlSTkhJMkFzYm85M3k4WmNkM3ZlZng2NHpvdmZPZGdYMDY4NThOYUQrc1Ruc0gyVHU0L2xVa2dOZUV2VnNnc2hkZzl2NU5KQjJrblorL2Rpd0tva25ZSXIrbi9yNEIwTXYxU2ZTMzAvVi9aWU9aZjliOSs2bmtnanU0M3NIMVJ3SFdMUWFTM3ZDN05jYjVWZ1lXSGJjeTJqMGduUUY4dWY3c0dYK1VNS204a09Hbk4vT3hzQzVhZGdMOHJXendsdnVsd1AvUkRQV0hTcFRkUWZadkRxNC9NR085cFF4cWpRMHF3RHJ3U3h2djN3czR6UlVZRTRIY3JRQ1hWd0JKQVhreXgxZUJlTHdCbU5JTzFyMEc2cmZxeUdzTU9OM0FtSCtLRXE0N3lON0I5VWRtcjlIN2FzM29ZRUJvNzRtVkt5aVdEWWFWQ1BoS0VEWXo4T1hyY2FVTmxqdHRYSU1zb095WWJQMjdiRDZqckFCM2VjZDdzK2N6c0xLeHZVVUwxcy8rcklxTE84amV3ZlhkUWJVK3BPTW5zVmVuTDZhTjl5dHdGY01jMHcwUHVHUEZFYXRMMk5aUDYyZFYxN1VlTDNyb2lHMjlXS1dBMFREWDErakdEcWl6YkNaN0FTb1pjTnpTbmJIeFBXbkhlOTRxTjkxQjlnNnVQelZqM2N0WWtqQTI5d0EyeEdESEZURGx6YUhBWi96MUlYZE1Td0h0bHBCYk53RDluaVFnT1JrbXlwdGJBdEFSVTJhR08yMWM1OGFBcGg2elhxUEpITnN0N0xZeExIeE5obkgvNW8ycFgxa1QwNG9NODZmcnMzZVEvWXVCNnh0QjlTMExNbTJFMFk3WjNIcXdaWVBCN2dHKzZETWp3STgyaEJ5RS9NV2NkNFpQWWgzeGt0a2ZCTXdVZFBJT2RzZ2JTaXZSUjlrNFp4aHdaUUNQcm90THhFVmFMWGFBZEpaTmJ0ejVkei8wNjIvYnFQUlhPUEZxNWZiT2pIVnZQLzNXNzlJR2k5bDZlTklPNElzcUJGeW5sUU11RHRmM2hOYWFXSEtaL0V4Z3NjYVdpd0cxdFd2TTJtb2hGcGZOOVdYR3E0QTFCZGQzQ2xndVpEUExocFVua1RCMDg5TjdNKzNjWkQrNkkrOE9zSGR3ZlJOYmZldkMyMXYrZEl0TXNDZmt6RHVBZDB1blJTQW5wQUJVMkh5RkFiZ1BaSWlHem1PU01Ma2pTUVB3M1YxVHNBbEU4Z0pXUUlyRDVvbk9aeTJwNTFwZ05kRzJ0Vm5DaFBiVHl2cEo1anBPT3dIVjZkNnY3WTdibzk5R1RQeFZ6OVBmQldoL2FuQjlKNmI2bW9UUEdqdnRpRlZOR3d5bTNCQ09Gd0cvWWVNNHVHKytCQ0U4djdmQlN3VUFnK1lnWUZGMXhaSGUxd0w0QmNDdksweU4yZVZvanNjVnpydUVYM1A5YjAvZjcxaGdNUUEvNGFYNlFqZVZMT2ZwWkkrR1FGQTNDNWNZYy9mYlNSeVJCcjFGRXQ3UytMRDNieitFRGY4dG1wZCt4cE84a2EzdUNaLzM3dUN1OUtlc0FNcDdMdFprMkt4cWtvNTV3YndIbUdmZEl5Qkk1bmVUaFB4RlF2UldBSGhBWEJPYmhGVk93Y2JURUpnMWlQWFFVYzV6SzFsWWYzNjYvdi92SzBCWS85dlNkK24xYVFSNDNmZHBJczRsMEZ4N3I2NkR6bHhickp4citVaXd2SVByWHdCY1g4Rld0eFpiQk1UWXNVajNNZ1lHZ0JZK0V4OXBqWm85ejRpVEhVa2VXR1phUThDa1d3SUZpSGFxekxPUkRVVzF5VW1PR2ZRZEY4eXJBZmphSFBCSDkxYVI4MHNDd0lNSjQ3T0FIUXp3cjkzWEFsL25tK25ZY2YxdUJkdEp3TDdRKzR0c1lGSHAybFpsUlE3V1MwS2NKTjFhazQzYzV6OVZ0LzJyQXUxUEE2NENxbnNOblcvdDBZNFNRTGYrZlRZZ2xlVmhUd1MwVTNDOHJweXFEVUxYNkc4ZXI4QndOb3l0SlNBWlJmdWJ6SGt3b1AwVHdPOTAvUFg5SFgzZVFLQ2x2ZjNINnpFeDRJOGlTVXowdjhZQWF3dmdLNERmaFBXcVhzcE1kREpTd2xwbld6MVdUcHlkQ1RSVmRubTgvdTZabUh4UG1yVldKeWlyejlpdXZ5MGI2MjJQTHZzV0dlMjlyQ2ovRDdqK0ZlZUwvYXpndXJYRDNxSW51YkFyQXVVU2hMYjZnTFMwMEk5WDFqYnQwR3R6d0xTeVlWaWprUUlnN0tvVmxxbXN1VEVQck5NdWxjMWwrQktvaGpUVit2MUh2UGdLRkFwcEsxdnR6V2JXQlJwdEpwbWd1NEtjYXNMRk1QNHN3SzRBeXQxd0RURlZtRTNoUUw5djVQNlBjbzhHc3psR3VxemJmQ3VvWDY2ZjFXRnVQRk0yb3JPMU5idW03K3VtZjJleGZ6VncvWUhhVjFuM203RGVsNjRQRjFiQXRDR1c1M1JKWGZEdEZaQWlnTkIvSy91cExPeHdCYldMK1Q3V1Q1Tm9qS1Bvb016YUdnSDFaL3I1U0V5elhMODdFOU9kNkJwd21NMWdQV0dlWkt2ZjA1SGtNQW53ajVpWGE3RXVlaUtndWdqTFRNRzl6aWFjVDZJSDY3bU9CanpYb3FJS3FrY0EzN0JzUjA2SUxTSDVQUjE5djJQSFVXWENXM01HNzJiZitOTlhNdjJvSjNBanNMNjFBV0JQbU5NWUZsc0I0ckxDaHBzVkJ0QVEwREVRRk1NSUsyajBFcjZyakpHRmZYV2lEMTRFcUNvSW5ER2ZnUVhNTzRTWVNUYkUzQW9kNDhQMXY3OFRvMndJZENvNzdLL0hsUVQ4am5LdGV2cmV5dUtlNkhPT3hMSUcrV3plQ0w3UXRTdDB2cnpKZ1ZndTY5RURmUDBxMytNRDVtVnFkV082eUJyZ2hGY3hrVUFTeHN6QWZLVHJBY1JsZFdzNWdiS1JYM0FkYXpEU3c1M0ovcXpnK3Nxa1ZWVEtzdVdLaEdCQnJkWDNiZFVSdW5Jb0xUcWZCQ1Q1K3pwaFg4MzE0UnBJNzRNSjlUV3Nib21kalJMMlovcGZvcEMzRUFBM0JzZ2ZUSmlmQ2NRVnZCK3ZuL3NyTWN4T3J0RW9qUGxJNE1vSnE0WUFhaUI1SUJIcnZGeC9Wcy85TFBleEk3WmFNSzh5T0luKzNGM1BrNU5hOWR4cWt1NkFsenJleXFZUGRQeWEwT0pOMEZXYk9HbUxxeTlVdzNmdlQxaDZPRVFBbXo0WU1OOXNqdk96QXV3UEI2NGZKQVZFRm56UmJueExRWFZHWFBMa3ltUzZRSXRUNlNFTFkyd0lNSHJNRXoyc0diTDIyV0NaTU5PZSsxb3RjSmJqaXhKZFNZNkZHZXJGU0I0Rjh5cUpjZ1d4OC9YM2grdS92NG5XeVl4L0VNa2hxaHV1MTRHVGVQMTFRNWhNbUQ0U1NETjc1TzlsTUR0aVdkWEFKV1NjK0J2TlJqNEZJWHdXa0MrSVM4SmNOMTJTNzA4YkFGcndPbXZFUHcwc2ZrYUFiWDh5VUgxdHB0THQ4QkZEVFlFT0NheWJPeWNDSncwUm1iWDBac0ZPQXFTc0cvSkRmQkhHZWlBdE5Fblkza3I0blFnSVdnR2pBZk4rL0JiTCt0RWhlRmlMQUhXbWEzQzYvdTQ3NWdtMlZvQjZvR3QzcE05N3hrdkZRWVp2ZitYNjJucnMzekFmN1gyNS9rMWwvYjlnWGpuQUcrTkF6UGRDOTJ6QXZJSkJBWEtralc0a2hneTUvMVUrNlFtb2xZMjZFcXRXcEExZ2FTbkpESmNmS0szL2hVaElJN2E3dzI2dENjZDdnakZQYXI0ejE3Y0RhMTVoZjloeDgxengrOTdRSldHWnZJQ0V3WnBkYjRSWmpFYTIwQUwwUmtKOExSdktKdlJ1Q0t6MGQ0WEFzeUZRMFdRT3YzL0FzamMvWTVuRU9WejF6cEZDKzU0ZWZOQkRXcE52RDFkQWV5TFpvS1BqWXVlbmtZQjFvT3MxMGVkZnJ2Ly9oSmVFR1VRZmJqQXZWenNiWmpzSzR6eEt0T0c2di9pYTFOOGZSZU10b3BVeTRMSWN3MHo4ZUgxZmoyVkNMZ1ZzUGlJTHZJazJ4TWlmNFV2NkpnUE16THozdXJ2ZDYySi9OSEI5QjkvVkNXL2JKZGM2dUZwNno0QmxKdGI5M0NVUUd2bDVLdytEbHZ4MDlMTXNUSEl3U1laQ0R4SXowQ0toZXNaTHZXVVdtZUNBbDdJbWxUQXFRQjNwK0R2OGtiUnE2VnFjNlVFOTBQRTg0cVY2NE5sSUZseGlOTkw1UDlJNTkzS2ZXUGZFZGJPcEFIRWlkbmVRVFM1ajNveFFrMmhjUHZjcyttMEYwY3Yxczc3UTc4OTB6L1J2SmdIMGx2UmZYSS96Z25sNVdFZWdkcnB1U3E0a3pVVlJKU0FuQlV2VDllbUc1MkRyOTdlQzY3dXgyaDhkWlA4MGNQM2dNcXNNNzJ6dkZrM1VFKzdzN3R5QzR1ejhKTHYrRkxEb1JHeVFtV3dGQkMwQkd1Z2hQY08zU3haaHdueCtqZEZ6RzNyd1dDTjh2djc3NnhWVWZyMytyREs4RTRIcjhmcmU3d1NxaVlDb2hzQTE2Zk1iWGhKV3pBZ3Z4T2pxdGZnM1luT1ZKZmZDc2hvSjJ6TUIxNGlYSmdYV2I3OFF5RjJ1eDFmL3JnTDZiOFJFZFFNZEpQdy8wWHNuTEtzdFdFK2RaUE5PbUNmRElHdUtKWUFqUlVUWk1PQXR2NEcxNmhXV1hRYk1teU5lR3ptK1Y2NmsvS3dBKzZlQTZ3Y21yU0wvVDZmVlJsNEJNT3h3Q2lTR0pBbVdDY3R5bUN4NlpxYUhEZ0orWndLY0F6MElaOHdUU1NPQklJZUNCM29vT2dJdXJoWmc1cGlJUFQ1aVh0QS8wa1BOb0h1Z0I1djE1SkhlKzBSTXJCNURaY2pBdkd1SmRkR1JBUHlDdVZFMloreEh1b1pWSXFqQS9veDVEVzB0MFhxV3phdUM0Qm56N1BvL3JodkhaTlpHMWIxUEpHL1VqWU9QbjdYclNVQ1IyV3dqYkhjMCtuMU54ajFoN29YN2pUYVlnOUZ2ZVcwM3N2YTFZc1JWa2dDeGYrNTdSSXp2Q2p3L1pOWFREdzZ1dC9idjY4MTNiRFJ0TEJZWWx1bDI4Z3p2cWpRWXJiUUlleHlERFVHMXU5WWtYbm9KMlNjQitVYkFiU1RnSGVYbmpXaWNEWVg0QnpybWNnV2Nqc0FFSkR2MEJLek9VckNUOTRBWTUwVDZiOVdrTDNROWp3UStyTDBPZUNrTE81dE5KWkVjd1FrK25XaFEyU3ZMRkVlNmw3VWNhOFE4Y2FVeUJVYy9GZWlmOEZJdTFzc21ER0xWbWU3UElCdFhROThadFVxUG9xTnF1N0krRDFGQ21LK1RjeWNEdHIwMWJyRTcvRXRyc3A4S3JodWdldXZzb21MQy83S3g2N2JDekZ3b3htQUFZcHF1UHBXUHB6SHNOUkdRWmN4clI1Vzk4a1BKRHpDSDJmeWVnWmhiWlhPUEVpS2ZNTy9mSHdTczJiUkZTNmtlaVlVeTgyd2t1WlJKcnZoS204ZElUQkZ5UHFNQVprTWcyeEpUTG5LdEh2R1MwS3Nza3J1UmFtbllGMko3SFlFMHI1TUxsaDFxM2ZVY3VBbGlFZzMzTEJ2YVdSSk5YK2tlQVBQNlZ5N2RHdWo4T1Jyb1JSWVk2TGllOEZJeGNCRUppVXZpRWpGeWx5aU4ybWNiSTFkTUs1cXJtNWp3MXVoelRmTXRQeFBBZmhxNHZvTVVrRlpBZU11Skh4SUtaN003TjFoNm0wNmlWVGxBNXFMeGdZQzBvWWRZcmZnWVpKS0FGek9yRnZOU0pjNndkOEtxT21Lb0V6MlUvTEExa3FpclFGVjEwQ2NLWnc4QS9wUFlhNE81MDVZbTZtb1lYNEh4U0N5U3ovbE1ja05QUUh6RTB2V0tJd05tNE14NkM0RitwbXY0VEFrcmxrY2cxK2dnbWlsWE1oVE16VmFZd1dWekx3b0JwTHBvTlpoWEJPaS90UVJzRkQyMGx6VTltdlVNekNmenV1bS9haUxFNjlxUkRUV1hLVUdPUTNNWEJlK1h2RXBCVlBSREEreW4xYm0rd3hnV04zUnYycUc1UnFZWnpGVFZZV29VUm53a1JzR2dlQ0JRWU9iQU8vNkpBSk5ETm00RmJURjNrNnAvZDhCTDJkVkVEOUVnQU1PSkZpN0Q0V0w0amhqNUJmTU1zdHJsVlQzdkFmTzZ6UVBtNVZzZ1lPWFNxWXg1UjlYaG1pVFNEYStlTXllNHRQM3pTS3p6akpjU0xBWlNCaG9RMERFTFBCS3daeXlyS3JRdVZiVnAwTDNVOVZSL2Y2YWZQV0xlRnEzbnFKRkxTNTlSdjZzM2E1NUJQWWxHbWlqcTZHWFRRQkRXajFpYW9oY0R5QkZJYWdQRGU0SnFsSmpiOWZsL3R0UFdqOFpjWFpMSmpYVk84Tk12TTlhZDRGUHdlYU9FaHBtU0pra1lKeWdoa2lReGxNeUR6c21mYk43VGl6Wlo1SGRzc3NKdG5iMkVjdzJ4cUNPeDBvRUE2cG5BOTBBUDhrQ2dkTDQrMkRYa3JjRDZEd0szQ1g5WURnNVkyaFBXNi9aNERXVUxnSDhSV0QzU3BqRlJZa3VOWW1wWWY2VE5nWFZiMWgvUHdyU2VKUkpwSlRMZ0h2MTZYWjhrNHFnZ2RwVE5rUk9OQTRIK1JKdk1TT0RQZGJPMXJwVjF6WjdlZTVaajZ3VGsxTXRBazdBY1diVUVzSkhUVlJUVzd6RmZhWXhzdHNaNnk0M1Avayt2djM0NHVBWldnVnNYMnhYWVR6dkNCZDFKRlZoWmc1cXdMUEJtUFJRQ25wTXdMdFlXazRCREs3cVgrcFJDUXZoZUdKU0drNE1rb0hoUmQ4SmdPdEpQdjJQZXpjV0pOMjV6YlFoMEt0ajlnNjdEaEhsTmFtVmlYekgzTzJoRWZ4NE5veDBJN0lCNWVSbEhVdDlGMnFnU3k2TmhXTDB3NFYrdjd6c1pmZjBzNEpnd04xbnBDT3kvMDJkeTZBMjZid2RKdm4yL2d2c1pmM1NDVllEaFNwQWFKZFFtaTBLYjJDZ1JTWkxRZjZBTmhrM1FId2ljZFlCa1IvZlBPYWxwaDFpV1JGMzBqREl3NzVuS3ExRnplVWU5OW9jRDJROEYxeXV3dm1aSDJzcEVBdk9PR2VjUTFBZ2oxVjd0c3FJemFlS2lpRjU1SW9ZVURkbzdFWGcrbWZQaExxbFJRdjhqbHIzL1NYUkcxWXJyNXp6UWczcVJVTDUrWDJjU00zcTl2bDJQcGRhQlZtMzJoTGx4U3UwQTZqQXY3K2xGYzlWa1NrZXNlWkpRUFZOeXJUR2JZOTBNL2xNMkZHMFJiVVViZGttZWxqYUo3NUtjMG1qbEl1eVRLME11MTJ0Mk1CRUYzK05CSksxV29wbEprbUhKYUtXc0N6TVFudUhIeUhEbmx5YTQxUEdMVGIzWnlLY0kwU2hZYnk1WXF5bkhob2I3WVpVR241ckFmKzh2ZTZmRWxSb1dSN3RoTnYrZjlUWTNJZFFWOUxjVVJrM3didmI4WGk3WDZTVjBPMTVaWDMwWUI4eXp6UkNXeVMya2RZNVRUY0xVREh4RG4zZkcwbXFQMlNGbm5nY0NXL1krSFNYeHhobnNFekc4RTE3S2xQNEQ4emJYYkI3WUIyS3lsVTBWU25BbGtWbFlnNndWQlBYNlhlaGU5eWJFNytWK0YyRjVYS0lGdWdZTlhSc3V3eHBJaSthSC9uZjZYcTQ0NkdVejRpaURQNE8xK0FQbVhWbmFianBLcE1JNmZTT2dNNHJ1ckczTUxFOUFHT0lBNzBmY1lqNk9YTm10SXo3YXFqdGhlenJ1M3FxZ3lNUGpUWHJ1cDBtaFB4aTQzbUswcTczd3pBWTB2QUY4UGVsRUlmT1RTYllNOGplVGFLc1p5Nnd3bDJEVnhvQXZSa090d1BCSVNhc0RzZDBpRHdXem1LTTh1TngrZXFTL2VjRGNiSmsxeXdxOG9PLytSc3c4aTd6eExDRW1leGZ3ZTZjZ1NRUjRNNWhPa21iOGdFL3l3QlppekNvOThMVzdZRG5XSlJPQWdyUlQxa3paaVB0SXNrb3RBZnVYaVp5eWdINDk3dDlvMHdaZDIwNTAwQWx6aTBjR2xUUG1IaE9hNldkRyttd0l3MFhJQ09jQjJISlJ5K1NVV1hZaWdla3pPbUhiZUFiWUhoQzYxa2tKN0orUSs5Y0QxM2NBMW1pbmN4Yyttd3dpU3dMc2FzU0Y3MFcweThab2RqMDlGTDNaMlRramZ5WVFnM2xJR3RIQ3VEYnhSR0ZrSVdiYUVBQ0EyT1ovRmFiSEppMnVNUDFDakRHTHpESFFkWGtpSm55azgxU1hwU0pnM3NsNVFoNTYzdUI2QVpzUjNoOVhwN3R5QzJvcllTc1gwZXRuYXdrZHMrQ1d3T0lnMzN1V2hFMkxwUVVoaC9kYzkvdEFhL0o4QmRoTzFsM2RZS3QzQURPeW5qYkhRZGl2eW1EcTZaQWwwWG1pRGVWWmpzRVpEdzByb05mSXVldEdxZEhraEhpeVJwVDVieW5wT3VKMWpRZy9WSm5XdTRCckFLcTM5Q0JIdnBPUnlXOG5JYmxyMlhPZWxWcklYWWoxOUhJTW1oeml6NW1JbVhHbXVhUEZ5L3JZUU4rakVnTWs4OHZnT0VvaTZrblk0Mi9YRUxvVnpaZ05UNWhSanZMZ3FaTlRvYzJDR2N5QkpBV1dJRWJNamErenNESUdJTTRxTSt0bTdSbWs0UjR4OXh0d0hnL1YxcERMaXRUQkNoSjJ0N0lXQmdLbFRPRitTMkNlWlROajM0SWo1dVYzendLQWhUYlZieVEvOVFTOFNjTCtRWktjOVZWOUVYN0YzQnVDUWZad2ZkOTN2RlJDNkxESUFjc1NMZlhIWURQeU0rTG1tZWhaS3l2SlpsZW4vdWtacHc5UDVyLzFDemFBMWJWQ1lpVkV5SWg3LzkxdUdzMlNtaVNaVVJkZlM2ejJLUUIxSG9BM1NOS0h3OU9qWkg3UHdXYkJKdEcxVE9wQ3dQUGZyZy9MU0tESDU4czF0RWR6YlpNSmp4TUJJYlBIR29iemUwQ01pUXZRVDdKNU5aSVF5cGlYZ3oxaVhnNmtQcXNIMGNJYnlSeTd0dVdlZ0N0ajZZM0xJZjlFWURKSitKek1BejdRY2RXVzRSNS9aUGhITEtzZFFBRFZZOTRTZXhBdzVhYUlDeDNqYjFmZ0s2TFJzalJ3b1BYM1JOZm5Hd0YvSm9JeFNkak9EUXIxMnJFdlJFT2JTUjhRR1MxMzFJWUd0Y3djVGVJeXcvc3BYTEE5MFhhdGp2M2R2V0kvQ21UZkJLNXZrQUVTbGozemE5TldBVCtlbW04NGoyb3VFcHFQQWhKY2w1b2xwSzY3K0NQcFh0eDNYcGtsVCtiVWNKU3RBaC9wTzdpY0tzdjNueWlaOUN3YlNJL2xhSS82QUg2blVQSzNLK3Y4YXJUWVVmVGdUcTUxajNuOXJZYmlhazdEWVdaMWh1cEZPMldHMnBuRURUY3ZxR2NEUnlDOWJHYUQzQ3Z1RWp2SVpqM0Mxenp6dWhzbFlpZ0NaRG9PaHlVR3Ruc0VzZE9XN2srUis5NFQ2NzFnM2dUQ0RGdmJVSTlHZjJadmhvdXdTL1ljR0xBMDVWRU5uQk9yL04wUWljajlQYTh0OVN3ZVJJYjRzMTh6Z1A3aHdQV0dwZ0FFR292TFFpbzdkTnFybXcrVXpjNDNtUVdRamJnUEkreHplWXhteHV2dkh6RHZrVDlMb2tUTlhCNUVrcmhnWGozUWt1N2JZemtmaTQrWlBSQW1MQ3NqaXJBYkVMaTNBdTVWa3pzWVlHdUVNUTd3WFZqcWNqL0taN2tKQXBNdzZrbDB6eS9DWkNkenY3U2xHTUxrdFlTdXlFYkZuVlVYU29vVitaL3FraE9XdGNVSFdnOFhjMHpjQWZVTkw5NE5TVFJ0SmgwWEE2UTFVWG1oNCtncDhobG9NMUtyeW1LeStWbVk1Z1hMcmtiV3BGa0RUeXVKTFBWR0hnM3pMRGRFdlQrZFBQQXFjSzF0WmVrRllZdGs4L2E4TXVMSmxHbmovU1hJem1kaElVZTZxV01BcGtrWVFBMWRUdlRnczd1U3V0WlA5TjZlZ09GRUQ4NlpQcWVPK0hna1BTdVI3anRRaVBrZ3lTQU5sU2NCR2o2bkEybUFMSk4wa29Ibnp6ektOVzNsZ2F5YnovZEF3dURFREc5U1dsK3M0TVNBQ0xNNUFmT3l2Q0pNdW9FZk9Kbk12VW9HVUZ6ZlBuc1pzQ3pBb0hZSXpvMy9QWW9Fa3luYWVhTE5pVHZCTXVaanhKOUoxK2VFVnhIOVc2ZEMxUHYzbTlGS0p5eEhtZXVvOGtZMmxTS0pQUVJ5U3lRdlJCSUV6SE85aFIwZndvTGZOY0YvNjRkOXNNazFQMURzU2w4bzFPS1NrQ1RocGN0UVpyTUluRVdlRGdUVUVwNkJqa0V6eUNkaUJwVlpQTkREK1J1RnRjL0NDQTZZRjRQL1RnbWtCdlArZUg1Z08zZ1RtRGJJNmtZK3RMMWhGRHlTUnE4alA5Z0hvMXZyU0cydDdoaXc5QTJ0OS9RQjgyR0hPcDZteDd4ZXRoaWcxV3FOak9VNGE2N2xIRVNibnloUnFNTW11WlpValdzWXBQaTdMaElGOUFLNFhJNTN3b3VCempjc1IzM3pzMUVyRWI1ZS8vdXJiQ0JmSktHcThsVTk1Z09XdGRnc1MzRitRazJQT0pKVHlhQXhFYVpPNHhqaFJ5ZXArOXhlMEwyNWFrQ0I5VDM5Q0c0QzExZjZzRG8zcXlRWjljamFEQVJBSnl4TmpGdlp3ZHhVVXc3ZEptRXBMVEVYdGdaOHhMd09jNlFIQlJSQzg0amxrUlkxaCtUZk1IYzg0anBOM2lRcUV6eGpQbzZGazBZUHdnUjZDa203NjNjZFpXR3BOV0FqaWFXUktnUWFzOG14djJzaDV2b1FSQmFUaVNJMFNWRTJOdFpua2t5S1lUL0tTdFczTklzMG9mNm1OWm56Vlk1VG96QnRGdEROZHNLeVJib1JyWktQbFpONWpTU2Flc3diVXJpRTdDUkF5WFhTR2ZPUk05eXNNZ2locUpITE0rYmowSjlFbndYbU5kUmMvWEV4K1E0ZUJ6U1o2Q0VKcUxzaG9DNlhrb3htamhYWjRNMHl3cy9BWEoxYzBKZ0xwVzJSeWJBTENIc3BFam9lTUxjSGJHUTNIWXpXMmdqVHpKU1VtUWdnSG9RTjlQUytnN0JJU0JoZEUwMEhTY1R3enQ2U1JNRGhPWmNKY1NLRVM4WW1BekFUNW5XVldVTE5KSHB5Z1c4bmhtaHlFTzI1d2J5TXlZMFc1NGtMM0hXbkRtUXc5MTYvdjVqamNaR0sra2xvOVVHR0g2K2RaWTNwNU5SQm1QZ2t6QlIwN2V1NmZLTFA1T3ZYWTJrSnFGTVJCcm1uenhReGFTMHVNN3RuaWI0NjBuZ2Y1QnBkUlA5djVMb2U1SmkwWHJpeTdIL0pkZGRjUjR2bEtCdG5KcS81RkNjWDNDSTcvdW55d0hzeDF6MDFyUW5ibG1XZ2NQMkNwWnVWRnY4UDh1QzYrVkZaUXBCQyttSUYzaS9YUlpKRi82cWY4OVhzNkZ3TCtZeDUxOUZYTEx1a1FDeEJod1FXQXV4bjBVZDFHSitHL0Z6OW9BdFBtYWpUMlpqZDlRUVFrTkJkN1NsL280ZU14Nlk0a0hNVGJST1c1VFVKdnNPSHZRZ2lqWDZVRFRrYWZlNGVZUFdmZ0FCTk1sb3FKQUpvZ3cyOEF2WVR5Vnc4ME5CSlUzWFRPZ3BqVGFLam4yZ04vazk2ZHVveDFiWDNTRDk3cHZXYVNhcGliNFo2N01mcjMvNy9tTmZ1TWpnN2p3RjJPZVBOODdJaXc2MTFka1c0RW9IdEQ5RWl1eHRjWDFFZG9EdFRDWGJ5dFF0YUgrb0Q1bDBtekJKYnllb2VTQ2ZpQjViOU5DOEVvaDFwU2p5VGlDY0FIR21oZnBka1YzMmdqeFErY3dqV1lON2kyUWNoYldVZTFkMm9sbkcxbVB1M2F2WmJROWdrUU5qS05ZdVNDOHpDdFp3dHF2RFE2S014U1N0ZzZkZnduVFJCYlNNdEV0TG1nTFZHNjJVeXpEd0hiRlpyaGJXWUgvTFFLL3RTUGRlNXJ6SERIbzIycUo4RGtneFltN3hnN3RkYkpGazd5aVo5eHJ3TExRczQ4M3JnU2JSVjhuZ1VXV2VVWkhFamljc1J2cEtuU0VRMzdnQk5Oazl5K0xESGUrUlBaNit2QlZjSGlwQ3M5OW9RTXlkU3AwQ3ZUZVloZ0doY0hlWUdKaHF1NnBqaEUybUpGYkFlc0RRWGZxQUh0aGRHV2R0R0Q1SVUrRUtaK296NThEZ3VOOHNTeWsrWU96ZnhTSlZzR0R6YjhCMEp1Tm52dEpFUS9rSk0rNGhsWFdNbWh0VUdPcGRxM0Fwd2pUQUtuZFE2QmdCNUp0MjVtQ3g4bHNoak1nQ284b0tXY2VudlZIS2FhQjJwL0JBTitSdmtPTmdrUnlzVjFJUDN5V2pMdFpiMVA2NFJVTlV5bnpBZmMvTlZ3bTJPOUViYTJOVkVQUkVyZmNLeVlhS2E3M3pIc3I2NkVwS0xyTk1zei93bzh0d2dmLytNZVlmZWlLVnJHdnNyWC9CK3BWazNmY2FiK2dEMi9QRXJqYTRoRDVlNzBOckoweHZ3UFdBKzdYTXlvVzZSSGEweDRNb3U5VWwrenA5VGQrM3F5Zm1JdVgzZVNMdDlJMXFWTTlaZ2N4aDJwZUtLZ3hPOXB6ZGFJak1JQnVJV3ZxZy95ZDlwOXA4SDhVM21HaVg0S1E2dVRUTktUUEhEMGhvUTF1dmtITXRjZzhtSTJMekVmUVl6NXhKc0VobkwyV3JNdXZMSzU2aEg4Q2pWQWF5MzkxZ09sbVJ0dDhlOHZFczlMOWpqdGdqei9ZNWwyVnVpRFp2cnI3OWpiaGJ6UU45ZkpZZGZNSjlJM0FxNzVlZTZJM0QvTjFQdG9HVnFSNUZVc3RIS1ZXZDFKdmNSd1h1TlBQbkRnZXZXK0lmSW1jcEpDSnE0T0ZBb2xPUkdOQ2FKY3BUd3FNRzhGNXhIbmZCTjFLenZBMmxLL09CcG9xZ2xMYXlsckwyVytYQVpXUVh1YUhEaWhMbVo5RWpNVnJPcURLeWNBR05RK3BXcUY5UVVoZGx6a3F6OEtISkxscVNQQWswaE5wUk1ZcXlCSDhPam5nZkpoTjBhWHVzRVZHYkxMdExSalU3QnRXRGRwVDhaaGo3Q1R3VFdEUzFMRkRGaWFRTjRsdkMva1UyN3RxOTJGTTZmNU5rWkpOeCtKZ1k2VUVUd0s1YmpqZGk3NFVSTStwdklCMFUyOU8rVUkwbVNJQzZpdlY2d3JCNXhHMXdXdG55UUpMRHpIWW4wMmpjejJFK1JCVjRCcnNwUWttUm5tV2s2TjU3SWNhZkZzaHVJSFo0MEU4OUd2NURzWlNPZjJZck04RHNKK056elhTaThMc1E0R1JpQnBWRnlmWEJPRWg1eUEwUUp3dGo2c3dmTTJ5TTd1ZDY5WWRBd0xHckMwdU0yRytiQVFLZjF2V3VXY2lsZ3NwT1JkYmp6SzhuOTVYOWZCTkF1a3AxM1lNei9mNUNrRkovMzczaVpHakNhOTdudU1HWEdFL3c0SVdjVXpvbkZTZFkzU3cwNlVWaEx0WktSRzNneUFYY1Bha0p6eEx4dW5GbG9iKzZqSGxPaUJCbVhaRFhYWkdlaXhMQ1dxTFZtdmJvNjZ3SHhjTVIzOXhqNGRPYTZReExZMmdFYVdXUnVBYktaOElpbHVjZUVaY2ZPa2NLVVZuUWozazMxNzludGlFT1RBekdGRWZNU0dmN3ZpTG03bGh1UjNkUGlPZ2hqWVovTmhqVFRWdGhOVDJ5QzllWXo1bVZWV2tYUUlHNHhaT1o2Tk1rbW1IdkY5OGVab0RRcitybjdYcGVOTDZJTnBoWE50Slhrb0t0QWNBa3cxN1dsWVNhd3RIUjAxOU5WRHRUbWcvOGlpWjNJejVhOWJIc3N2U1JVMjM3Q3kweXkwY2dZbzF3NzN1d3JBRmFkOUo4RW1HZlJ3ZG1JbkNXd0ozcE9IQU9GZVdZQmJ6K1lKYktML0VYU1NuNEhQelc0RXJEdW1mNFlUWDdVUXU3R0pFT09KcVRpTVNDamhBQ2NIZWNhV3MyK0gyUVJac09PYXNqeTVmb2VyZ2JnMGhNZG9jM2dQQkFRdGxqNkFCVE1XeWNmUkdzN0JHRjROckpLQ1VDQkdXQnJ3SEtTejI2dllQQUlYKy9xeXBRbWtXYW1nS2ttcytGQW1LRzZ6T3Z4SnJxdWt3bi9DN3lSREd2dmtBMEVodTBYYzN6TzlkNHhlazNpT2FEVHBCWmZYNjBHeUtMVHE0ekFySmJucjUxbG5XVzV6ZzkwYmx4bnF4YUhtU0tpWjh3YlFyZ0VrWnNyZWttK0ZzeEhnd1B6UVl0YWUzMHlzc1lrRVZZT1pKazFEZlpQTDhjS3dWV0FOUXI3azFsRVplT0UxOFpFZEJLV0pRbnhKd0VMSFkxOG9RWHhCUzlUVTFuUGFUR2ZaejllQWVZczRQSjQzYTBIV3NpTmdQclJzS0duSzN1WjZHK0xiQnE4Y3o4VEtHZlJIek44TGFpQ1NnTnZtNmlkVGNyZ0ZWUnErZGxYbzEyQ3N0dU4wY2lWT1hPM1ZXdUFYa1B2YkRiaXFOTVA4RVloQ2JHSlRGblpNQ0RIcENFL1ZwaTN5Z3lPc1UyaXFRSno0eHJWbjdXbm4zMFF0QkdGSXlpK0JnT3RQOURmMW9xU0h2TXBGd2RLWUdtSjF5TjlCK3ZDZkQ3ZmhhRzZjRDZicUxYRnZCRklQWVl6dkdlcys5eDNhekI0ajFaWUM2NGJHbXZDUGtjYllGazZsRXhpSVVzMnRwRUx6UDNMajNncGdYSkY2SzFvaEVVVzlUTXhSL1lZZUxqK3JnNm8reWRlNmdFSEN1K1B0RUJQb25seElxSStDTi93VW1SZlcyT1RQRmpWMGI4MXUzcHJkdDlpRW51VDBWY1ZwTFFNcVZrSnI3UUJRNHY0K2I1YzZKNDkwWHUvWUdseHAvV1lyUUJUQTEvTHVoYldGOFJlQ2pBQTZkWm5NVWt1bUlTTFM4WncrWnNteXlhc2x4QnBpZUZrN3FsNk1FekNmR3YweEtPQ1RyUjI2OC9PNXY1ZTZPZnFDVHRLY3ZNc2xRS2R1YmVjSE5SS0lHNGlLSUd1WFl5TXFKSkNZOGhDMlpBSmRCSUhEQkRiZS9TUjRKcE1Wcjdjb0hza2swVHBoQzI1N0Ird05NUFdjTG1UM1hYQ2ZDb241SE4weGp2Mzc3TU5uOXJIMWI4N1lON3FlS0lGMlFxTC9JNTVEYURPR09La0YzdWdBc3VSSjlFR3gxTmFuNjlzR1NacjdqNHpZMm5ENk5wcHMwbitBTjRHY0FvcUJHQTIxTkVrUEIyNHJwVTl1WkIrQ3BLb1dyeGVBZ0JGQU55NmZoeGIwbHJYZ3FWNXlkN25obGtxTUIrZlBrbHlLV0ZldHRXVHRLVk0rb0w1bVBiNmVzRGN2L1k3NXBVdmtFaWtDUE5rWDRJR2N5YzRMaC9VWjc2WURjUjEzQldwSU9nbEVjNS9zN3NhNE5ObGdSdk5XZFk2WGRRdENBUmFXck9vSnNRTmhRdG55YXdteWVLemVZV2FJN2VZbDZNa0FkdGV3S2JCZkJ4R2kvbE1LMUFJMDJFK1REQWJnQnlrZW9GbEJYNlF0RUJkQjhacHdvYVRJZXFiQ1FNQUhENmQ2WnJweHRaZ1dScWpaVTR1RXo0WlJsdVA4enYrY0poeUdtZ3kwbENWSHg0UjIxSkc5YWFEMGJ4ZHlGOWYzMGlQMUxyUkxJa2VCZlF4QUh3bnhTQ1F3aFJja2tnSTZubDdrR29CWnBJNmMwczMwNTUwLzZxcG5pbEp4dE9NMlpHc04xRVNseHFxUjdDckFoamgvU2Y0dXVzVTN6R1FhV0RXSDdEZkIzYTNGdnRuZ2F1RzVLcjFyUW5PQ0RMS3p2Yk9tVGNYQWNsV3NwZ0pTOE1KOWpNOVVnYVZ5N0l1bUUvNkxMSlkyU00yRzNiSlUyRFpacTZXWG5VQzdEclRLUmxOaW1zU0kyRExKbEhuT3BsS3dQb1lRTFZYVzN2RWV3UHFlY2M5cmQvLzdRcTBEakNyZ1hRS2dOcTFvMDZtU2lBSHJKcUI3eEJVQnFoSFFsbDVtQkVBZG9HdnIrVjdOSnJqekZpV2dwMkNoSnVDT0RjS1pNeEh5SXpDNnFyYzFRbWg0VmxaV1hJVlRCUk9sQ3NZS0dIVzQ4VnpsaXQzc2pEckxNZmptaVpnRXFJamxxV0NlVWRVb0pOSHltY0E2eTNnNmlvQW1DVnlFVDdQQmVLNjBzblFlR1VMeFRBRHpjcUNNdUs5SkxUcURUdWFNSkNOcVpNd3N3bHpmOU1Iek9jajFUSExrSEFva1paMElFbmdRUmpmQmZQU3JraU0xNUIrRW5idTlNZkdBUEJra2dIc1RjQ0xyaEVwaHNQYXppVFNkSFpWRHNLNmFDRnZNWXNwMEUwVmtDdkRlakFBcjVsOWwzQlNIWE15aVM5T2ltbTJlcEkxNlNaZjlDc2tZeEpteWd3MThubGdNT2ZaYWxxUERHR1FvSFhJT215UHVlTlhyVHc0MGVjOFkyNERlYVI4QXBlTWRaS01xL2ZwU2U0cGx5U3E4Wkp1SHR4RTRLS3dZcDd6REYrTGpRMk5OUU9ZUHN4eU1OQmEwd2FsanRob0Z0QWFUWFdCVGczdHNHd2ZITEYwZjJJbTBacnZjNk9ESzRPY0pNem5ZMnhwTis1SWh6cGdYa0RmQ0tnUFdJNXowWWV3RTUzWVdlczFJaEc0eEl2T0hXTTJkc0c4R1lJM05pM3RTcVlxZ1dlQ3JmbHhZa011eVBEMXBKSFdXRmJXbWJKRzl3QlA1amg0dU43L0MrRC93Ykt6Q1VHb3I1dTlodmFzaDdid05kdDZ6THB4YU5XRUdwdGtvMEd6ajhFRmZvUTdPM0UxQXNSdWZ0ejVTZ2gra1NpTm42VXo1Z013Qjh3OWJUa1ovWlVTbTFYbi9VSXlSRGJKdnVqZXNkUTFHaExpVElTMHp0bkpOK1dqMk9wZWNJWEpRSS95OTYzUlJnQmY2cUpKTHJWK0s4UTZHOHhkZ0ZTajdXVDN5c0k4Y1Ywc3ZZandEM1JjUFpaZExwa3FBeWJNL1Z4L3ZYN3VWN25KT25lcityTStFekN6TE5Hc2JGeXRDZVVWaEtZQXZLTFd3eFF3eTB4aHZrNVUxZEU1UUZ4V3AvUEZvbk1ySzlyajJ1dDN6T2VQWVNYejd6UlBtRkRUVlFvb0VHYkVMbHlUcVVJb3dmY0F2b3hyTXVBYWRTbEdtaTkzZmVsZ1FHYkN6L0paSFlGaERlZDVqRHNud0xRcGdYMEcrSjV3SlEwd0graVppV0NvK2ZoRVRQcDRaY1FzcjJVQlNXQSs4cHQvTm1MZENHcVZ6WDRZdUJvNXdMbFRaZmdoWnhFRGNaTThWVnM4U0daMXdMekVKQVZoUUVjM1RIZFRIcGZCOHNSQjJLZWFUNHp5ZnRZOUIvcWUydmdBdkpSdlBVZ1lkVElQR1dqQlF4YXoyNWl3QWhKT1gwekJKcmFXOFhkVFVEbkVyQnZQMTVVczd4WklKZ0VFN0FEWHJkbjJ5V2l2Z0hkY3k5Z3VpWXJxc2FOamMwMGF2WHpIaFNLV1VXUVZ4NG9WQkhUTnF5VmpsQmpqeE9RZ0ZRS1ZCSnhGcnJyUWMxVkJ0NmZjQUNldnZoSVRIVEQzOVdBem9zc1ZMRHVSYURnYTdVMVkzNWlLZ0J4VWZLelYzRWRSRU9pWi96OFI1b2VBcTJHczJHQVpCY3ZhTVhleXJpQTd5VW14aDZycVNFcnh0ZmlZUVo0SEF2WVN4ajdpeGUyLzd0cFBGTzcvanBjNjJBZEtETlRrMVNBQy9TamcxbERJdzM5WHYrZkJoSXA2azdONVNDWjRMMVZ1eVdValpUWS9QbUplSXBhdzdOeks4S00yMUExS1FmK0pydmVhanBvMmdHcHJOVy8xa2hkc2x3YnVrU0RVc2pDYnRhL3ZnV3hPck4xdTVTMktrUVVtazd4TldKckU4SEgxRWdWT1pzTlVnNTBPOHhGQlZUL2xEc1JDalBaTXowbGRwMCtZVHpsNEpzTENSa2twWU5Yc1M5d1RlUmtDNElUUnhKTmg5QnJkYkZVTnpHcGVQd05jQzk3V091YmNyaUlOSkp1TUg0ZXNMRC93akNsZDZBMWVSakVQUm5LWXJsbHFEb080ZHJDbHYzMmdCQmFYdnB6b1BSM20vZ1JPUStaNVV0cWhwWlVXL0REOVR3RC9EWE5uSkpnc1BvZDlQWmErQXZWYUh3TUc2OHFWTkdHWmI2Z0t3STVGakJVMlduWXc5alhnZGJXNlpVVkNLQUhZc3JISW1rbUxTZ0RGeUNzd1NaZ2N5REJhQjlvR1lhNlRiNVFSTjZKdFp0Rjd1VXFpdHF0T1JwTHFNUy83NC9JdkdNQUdsbDRKT3N5d3AydndqSG1iTzQ4Q0g4MUdwdm1HYk9RWkNMYU0yR2xOK0pteXdGNGdkUWZkSWk3U2RnWEJ6dE9UZ2FtQnIxdHNSWFEvVW1Jc1N3aitGZk9aN0djQzdlcitQeEhUL1M3TTRFaGFEODhGMHB1cGhkOTgvcTJFYkpCa1hWMzR2K1BGNitBa0N6bWI3UHBnRWxRTmxxVlV6cll3cWdSWkE5TzB3akNxTkhKYXlmYmZVb2U0WmxPcFRDMHFWM01SV0pRSUsrYjZ1aHBXWnlhazJ1a0k3K3NBekIydklFeFBueDJ0RngweHI4Y3VJcjBrazZ6dHNUU1Q0ZVFuejlTcVhWc1A5SHg5eDl3a2FTQ1N3bUUrZTF6VXlJMGJmd2JNVGNrWmtBZXFWSGpDY21yQnRDR0ZGZmphWXdUNW40L1hYSy9BbWhCUFZMemxBVkZuSTdkWW0rQmtpOGxvcXg1V2EwMG4yZmtTZ0grblVJVWRrN2kxbE11VUdnTFlYakw1UEkrb2hrWUhrakRVdXEraHo1c2ttOHhodHBZSWRiSXdlMG1XTllFMmwrQ0g5WTFZTmtabzJaU1dLT1dWVUQ3ZENJcHBneWxHTCs0YVNqdkNhMkRkNm5Lcm5yRnNBTHBhSkpaQXk0MCtZekxoZW9MM2ZlQjJZUFdlemViWm5FekdIU1lua2swRkFEZTI2RDBhS0JITFprcGFybFVUeEVkS1VyRVA2eURmQzh6YjRMc3JXSE9Eam9JdERGdU8yb05WZGx6TFZZU3kwa2ZMQXBGV3VoVUNSdUZjVkFqT3V3NWJtR2tIeWordU8rcjNJSlN0OWFVUHRDQUdZYTFaR081Z3NwajF1QitJVVVNVzF4Y0t3VnZhWlYxb3FPMmxYRldnNWl3TmxvWVZHVXZENUFMdlZnVXM2eVk1TEd3M2tscHA1WE9qenF1dEJNK0ZyaUhNdGRhLy9RMHZYVnhwUXo3WVNvUnRKY1gyU0JrdTJUVEJlOUpteEUwT3F0VTZQNGZKQUxVeVVQVVg0QXFYMGR3blhtOFhJaUhzK2FvYkJBTWhqOSt1WFpKbldkdWpzTitSM3NmZGRmbDZmN2w1Z3AvTGl4ejdhTmE3T3JKTm9rM3JWTitvWW1WVmovMW9jR1czbTdKak4xQXpFTDdvMmV6T1BCZW42cXBzb3FMdS95d1BjQmNWendZNnlLN1VTZ0lLRk5aZmhOVU5BcVpzSEZFVFZQK2d6Q2NMOTBtWWFtT0U5UW5MUW4xTkpHbHRJN0FjOUFmTXU3VktvRkZxM1dydFJHdUlpV0FGVE5OT0FJdXFSUFp1eG11Wis5Y2t2LzRYZ1A4S1gvTGxraDU3Z2RpRm42UElRVHJnY1V0Q3lRRUl1L0h5VTNETlZETUY1cVYxbzZ6VFloSnByTk0vWTk0VW96YWZ6R3dMUGEvZmhSUlY3TGhnV1d2T1ZRcDh2cjFFdWhuenlvVzZRVENZTzFsdXduYUozMm9EeTJjdzErZ1ZUV3JOcENVK1N3Sm5DZ0E1Qjd1eG1sSG9zRGgzZ1hueEhtaHgvUk12TTRlcTV2cUVsNkptTHZhdTNTZlpuRy9OYUI0SjZIa29XelZJYmttcU9KcmRWNDIvT1JtZ2M0S3ExdXJxV2pQaWJxSlcvZ3NzSjdoR2dKcHVCTlJiM3JlVjBhL01kWXNWNzFuOWExSkUyZkUzQ3F6WlJBZk9nV3N5ek1rQmVUUnF4cG5KdTgzNEdTOFpkbDFmcmhraFVkSktXM0IxeWdGUDVxaXN1RFlZVEpqN0hUTklId2hvZGVMRlNPRDdUSnM5KzNnOGlpVEc0OG9iaWhoWmdxdTJpU2ZTZjBzUWZidEVmZmxNY0kzS1U3WWVsclFqMGVFK295VTlrdGxBSjZ4U0dXVjlIVWluTzJCZWhuV2dNSVVaWDYwNy9JVVNXT3pueW9ZdlBEM3pRUG9vRjIrcnZzeVdiZXBUcWlGekZKSzdHVkk1MkhrNTJjR3RvTFg4NndEdkI2dXRpQTRJdG9EMmlaSi90NFRtZThBeFlmOFlHYWVWdXJXY051U0I2UHNjODR1T1c0RXlHOTFXWlJmMUg0RFJUOW5mdFZrSm5aT3dWZ1pPdlgramZONGtNbFJQZ01nREN5K1lWeHc4QzJHcXVZNXZXSmIwWFV6VXhtU2pOL2RzTlByclpCSitKU0NBR1hGVHlaL0NYTk1LSTVsV21LMEsxMjRlVVRFaFVpSkE2d1BCZXJ5eXoxYU9nVXRXT2xvWWJJeGRBZmFCZ0tnbkFEclNZdUJrUXliUmZwUnM2Q1E2TFk5aGVjQnlQajJmWnpMYUhVU25BcFlORnk3Y3plYmFNekJYNXBITXZVb3I0SmsyMkIxMmdPRFd6ei9pVmQ3eFBXWGpPcFJBYTRWSUJXNERnSkVYU3NCNko1TWdjbElRc0p5UHhuL2ZpT1k2WVZtNjF4T1E4MVFENEdWcTZ5REpLNjJnNEdUeWYyQnVySzJtOW5YVWpFdUt1amxteFlCc2RLK1MwVnZEWk9sbkpiVFc5RlZnV2ZUZllEbG5QdW9hYXVITmdMOFlrWjY5Vk0rMGdBN1g5LzlPbi9NTFhzbzNPdEpaZTVJclRsak9jSGRtdmN5S0dhUVlZRnZSWEJQOGdEeVdGM1R4YUlnWmpZam1FSDhyc2FVVkFwd1oxbnU0dHFtbWQ5SkRYd3VPYVNWaGRxc2NzTVYyWHd2K2E5MVZrRTIwSUxaTWpHUVFIY1dpc2tRMm41Vk0wc2xOeE9Wb2thY0xUSlJBVmpDcWNnRlBySDJteE80Wjh3WVQ3cmhNeEhJaDJtMHlFZ3g3S2RUSThSbnpKaUkyaVdxd3JPQzVlZTdXdXh1M3JKaGo3MjBxU0lGbUNyeVVPZlZtQVJUNTc1SFkzeWhBVjVscHJUZjlSa0w1UHpFM2htaUZPWXhYTnZrRkwvWnNKeXhIVk5UeitDK1kxeFYycE9tMHBHZnh3TUpXd3BJRzNrRytEUlp1YXhiWGhLWGpWV04yWlUwdVlnV29jeURYRkd4M1ZBSHJwVkRZQUlzdFdlbWpHT3g3YkFwYlREYjY3eFF3M0NrNFJoMXhwQk5zbmZ6bXZFKzVZdVNDZVlhZXMvTE1paytpejNZRXRyVmU5WVI1YmU0Rjgya0hXcEV3VWg3bU96M25YTHJGNVljRGxyUDJPS29kTWE5MllIYjdRRkhwbWcrc012MlpGUFZlQUx0V2loVzUyYS81S0hLQ3E5NGtZRGtENjBCZ3c3c1R1eDQ5MHNrL21XUVNqN1VBc1VpSW5zVityeTB0Z0ZyQ05kQnhhbXNwVE9pZFJaOUtBcmFSQjIyQnQxcEVBSXB1OGVpSThNaVZ5akZoM2dUL0YvN29BZ051cnhSNGE1aitVV0Q2RnVDTjJvd2p4bHMya202Um1UZ25lZFNVZkcxUzdRVGZnY2FqV01yS2ZSL2hiZmdtQWNFRTMrM0VMUGhDSktqUTg2bjYvZThFZU94UjBHTHBXWHlXWStlYWM2N2tHVXpFd09Sc1dKR2p5b3BVOENIc2RRdGNjNUF4ZFU3dG9GMXBNSUk3MTdtMWNzUFZEN2IrWFhXWEd1UmlQcEFPT3BDZXlwcFBMUzg1WWQ0eGxvUXAxenE4ZWw0ODNxTHFzVS8wUFVkaXlCMkZRMGVSR3Rha2xpaUo5RXk2TU14R3BqM3ZqVEQxWlBUc0tMRzJObVk2S2xtNmxiVisxR3VybVdGdjYreGFwNWxXQzBUZUJtczJuTTRKeTNWdE9VQUVsa2xkdGxGMFdxKzZSbzFCd28yanVwcWJxS1dRNDFWaXV4QzdURVJDYW9MckpBbXdla3gxZmhld0xOOWl3QnpsdWVKdXpBdWRmeVZuQS94TU1wNWJ4eVZiZVNXYVdGc3I2UTk4TFI4Q3JpN1UxTVhrS0RYZ2grWnBDVkhVV1pTSTBXYTZTWldsVlZEcjZTWnl2V25OK0g4WFRiSHVoSTk0OFR5dEk2VmJrZ3pPUnF1c3JhNVBtSnU0NkdnS1lHNnVyUzgyMzJpd05MSE9XTlk2UnY2bzJURFJ4Z0JsQTEvNzZzQTE3UVRQVzJwWlgvT2FibURUNVJXQWpJMkhUVUd3RGM1WGE2aExBTEJPRW5BYXFicy8wUmdiSlNWcnBZNWNMb1dBRGJzcUIyYXJFMm1iZGFBaHkyczhhWUJuelhIVVZ0Mnp1QTYzSlFtUTlmOS91Nzd2Vjh6YnV0dEFvdWtEdlQzVHBqRWhMdFA2TVAwMVlxNmQyV214OFNBMklxUW56QjNLWFdhVHk1cEEyVU1RNDJSOTVTeEpwSU1jTTVjNThjTlJKQUYzbEIyTy83YWpHOUpoV1hiMWROM1pZUklIMmt6QmsxMDE4Ky9ZckpaSVRmQytxZG5vY3NDeXltRHRuam5Bekc5a2pWdEowYTNYU0JHREs0ZEs3M1JzT2hWNExlVGZPK2pPU1FHUkU1YTdMMmxGUytXTmQ4U3lQYmV1alNkS0xvMmlmK2JnT0l2a0Y0clJmVmwrdUppMXp5NVo3SExWazI3TDkvVk0zOUVURUhZazkxV251Ky9FWGhQbVByS2ppYUlUMWljUkpDTUI2b2laZHdmWExXOVd0N2l6MFlDaWg5WTU4N0M5M1lGQ0F2NmNqbll0dGY1THBPRmVSSzk5a0J1VkpFbkVGb1Avb1BBRVdJNmxQdEROSEFoNE5UbVZEUXM3R2xZV21ZbW5JRlJOa2d4emJhek8zRG15Ym95WW5IYkcvWXFYcWJKYllQVmFadmxhcWVFdERIck4xM1VySVJhVm5ya3hMekNzRUVidmpaS0xrY0YyZEx4WnRGQ3N5QUpqb090ckNWWWpRRjRCYmpMeTNyT3NOWGE2NmlpNVZxdDV2dFB6eUxtVW1nUTcwcjhMbHZQem92SzN0RU03UjZDeHZ4dkFPbkJkNnl1UERvYkJiakk3bjRJRm0rYTJ4Q3F6U1VZMXRDTWU4VkpyQndMVUUrMm9EY2tJN0NERTdqMUhlbSs5K2MvQ1VnOEVxa2Y2dmxySGVqTHlpUmFISjJHL3pKVE9wRjhCZjFROE5NR2lpSXhZVktweDBRRTJtTkphZmVCSHNOUFhhcXhiMzdWVmwxdHVTTElWN0RlZGlicCtpcXdGdHU3alBFUGttekFhd3FJaHZNcHhBM3k3T1l5VU1CcVpUNnNLdUpMZ2dyazlad2tBN29KNStWZ3QxUnBJbTIwb1ltVExRM1VxZzRUMkhUM3pXeVpTYXg3VHQwNk1mUlhJc3VWZ3hGd2JMQzBCaTBtUWpCdXNLWnFSMDRob25nbllOSlA1bFhhL1FnQlhXV2R2R0MrREc0K05PR00rWDZ1Ni9IQ3BTclZCZXhTOTlKa2VsZ3JtYkdEUlllbmRPVW9ZQW5uSXN0bGMrTUZ4RlF4clBmNXVHSjlqdVdsRE9waXczblR3WnlhMmJtR3B0OHl4MzJ1UGlBMGROOEU3bGdGeE00QXowVll6YlJqdzFLR0pHWEdwRmxld3NCbVJTbndqNXFPMjJhT1l1N1Q0MldMVGwwZk03UW01dXlzYmhzNURFL21ZbmVYb0dHeHdrVU5ZOUY2M0FkblcySlRTVFNEci9GejMxamkyY29HakltYlZPTFRrcW9qMnFSMG1hcHJMM3BCMWpnNUxBNnhQdFpqWCsvRXhQSW5lYzZTa0Z6UGVnY0R6UUR2dFJUVGRMa2hRcUMrQ25nZk1neE5aQmJyRVJXMTFqY2FVOE05NW85Z0MxV2c5dkJmQXBnOEM1dmRzZElpa2c1NDJjR0RkZkZ1VFdjbHNyTzU5YWowWWRlaEIxcnh6N05kTXV6T2NHZVE1WmNCMkZvWnMwcTY1QW82a0xuVGNaN3c0M2ZVRXlzcEVHemx1VGQ3cHZEeWVKdXZXZzg3c1FpREh2ZXZZYlFYWHRJSHdHa3JyUFBEVzZKVzY2eWJTTVZPZ0ExVWc0NzdsTDNSVHVVRUJXQnIrdGdMY0RZVW1kWkdjTURmdjVUcTVXdjlhUzZ3ZUVCc3dOMWk2dlo4TTgzT05BWmxBR2xpZkdKQ0NxQUpHOTROY3p3YmVQRHZqdHE2czErcWp0d3drZkc5UWRheHlyUnJtcmVCZkVGY1BNSml0ZW90aVdYS1ZzTzVYcTZ4WDJkdGs5UFVwK0QxWFM3Qm5oZ0l2cnpsdUJPZ0ZoRnVTNVo0b2Vpc0NkdnIrd1lEaFpEWUJIZjgwR2tEbTVOemVjZStyY3RRV3lHNGx0TERDY3RRcVQ3dU5uTDQ2QlVteGprS0NIc3NSMmVwL1duLzI3OWUvclJOQ24vRGljS1htS0d5cVVtdnRIa25IVVpaOGtPK3JvYzRENW1iYkJjdXhNUTBCdkpiUU5GaVdzalVTeWcyWVQxUFE4RjdITHJ0Rm9nOTVoMlczMTYwZFdXL1JXUXYrYUY3NDkwOEMxeHBlUHV6Y0VKNnZ4L2QvSVRhS3VjV1RvQVJKcUxYN0JKUDNVSE4xSjhXcE0xZVJrSHN5REs3QWp5RWZyOWZpcTN3bSt4Q2ZNZmRONERXZTZWbGhsN1pua2grNElZQ2p5RTVraTlGc0FNVThFeG0rbk14ZGMwajBQYXpjeHpmcHNHdDFybTZhWm1ORTU4aVJTSHYyM2Z3Z0NJQng4b3N0QmRremxjT2tmeExEZmFJa1ZnWFhieVRHLzBKL3p6dmpkMkxqSjJLNEhQTFh6MjRvMU9rd0wrTnE0QXZCbmM2cEQrRmE2Mm1MZFpQcnloSytJSFpmY3FiT1VlRjZXbG1NRS9aTmJ5MDdBZEM5VjQyMmIwbHViYmxuYllYN2U4cTkxczdQQVd2WllMYXVQSXZ2MVFoZi82dGxXTVV3ek1Za3IvVGZLdDh4T2FyZndSTmFMNkxKUHNrNjFKcGNtSFY0eHR3N2hHdHhlUnB6RXAzMmdtVjd2Vlk4ckZWTWJLM044aHBaS1FMWnJTWUNOMHNkUmpQVTNubVlKSmc2WmJYbUJqT1Q1ZmU1eWdYMmVqMFNJQjVrWVhNVHdZQzV5eitQNDM3QWNwWlYzYlVmWlBkL0ZNMnNrK3VpcGhPalhMTXN3bndTclVrVEUydlovd1p4V1ZjMkQydFVXN2xYWDkzeUNYaHJPZFJlZHZvZVVzUFdaSUk5cmE4UnNDcTRiZzFRakVaRlJ3WWtya05TSzNnZ0RMTjZhbkRPb3pKTk5pUlNtZUVpei9SM0lWQmNjVlA5akJsSXVjeXgxc0ZXOE9SWldSeHRWbmJNWFpwOExxMW92SU1RZ0tQb3d2cGNiRmxJNXJkcXNGRVR3VnJKQW9JYkdKV0c2QW1wVTA5SDc2OUZ4SnI0R29tZGdiUVlCdE5IdkxTOXNxN0w5bWIxNHZNc3JIb2psYUV6b0IzeFI4M25MN1J3ZXN6TFpSakFHaXpiZnFNdUVnZFF5VERldktHVHVzYUJSdTVWbE1RcXdYZHZnZWw3aFBHL1gwUFE4c2JQUVpCY1lyYjk2L1c3bWgzblVuWUNlVm5SVEIyVGRiYWJKWWdNMU5BNlM5Sm5Dc0o3SGxyWm1OOXJlV1JqNUlNQlMzY3FacG82ajY0UThKNHdyNVA5eldqTVRHb0d6QjN4bUdSb2l5MnZ5eG8xS2hCR2pVOFoyeE1MSEJDdk9XeWxxRmQyenlTQ2RBUHJVRjhDMVRSVWsrWGU0Uk9GR05ra3V6ck1XK2Q2QXpnSDJjMTVGK1NhMlJZdkUxNGJ6R3R0ZFNwcWcyVzlMcGVUdEVZV1VGOU9YZURLL2xVK2lXU0RGckZWWUZwSmlPVWJORllIMnUvbEtlQTI2UUh6MXNiMzBsejNndU9lNU51ZWVWdDdaQURYK2xyZ3UvVFdrbU5heTlvWWpWYVBSU2NUY0lLb016TEVZQkpjdFVPUng5anpCbmFteUs0WFlnVE1XMTRyK0o1bEUrRE95cHJ3WmJ2RjFqeUgyc1duRFVNODdYaHQxSGI1S09hNk5tQ3dvNHNYMWZNMWdaNlVUV0tKTDBJci8zL0F2QmU2eFVzdk0wc0MzekNmR01EVEtIK1RIYSs5c3M3NjJUcUdwZXFwVHhTS3NPdldWOHlyQ25oeWE0ZjVHQXBnV1llYTRKM2xFOWFIRzA3QlRxb1Bwa292blBCeWtrRGVBVTViSFMxQTNGZS81MiszQUM3ZGtybGQwWXVkU2NxdFRsMWIwd29pL1p6RDhvRTIrUUhMRExjMmg3anlybUtTWE1XRThaRDFwc25hWkVCR1AvOENieUhLSlZiY3JUaFNSSGNpUVA2VndKc1RZejJCYktKSWxRMVlHc3g5SEM2VW9Id1NvZ1lzS3l3MDJSYzFFNVJiQWZVOXdGWFo2SnBNMEppd1pzTFNBWW9OSFFZQkJaM2Z3emU4OXYxemlVZEh2NnU2VU5WTzJXZUF4M0gzdEdBT2xMQTZFQk05U05nRDBWYXpiQm84Wk8wZzRSWkljM0xHMlFWTGI0SUMzMlF4YlFqeXJIVTE4UFd4R2R2VkFTa0EwdmVVQmZheXhsdWpxcjFKTmFjVkYyeDNhMm1DenpGY25WUTZpWWJQSU1icnZqVlIxMlFBZGhSd3pBRWpuWVRoOFRtTUpwSXFwSXN5QTZ4SjQrOEJtQ1hKWC94RElzWkUyaXRIWndOcHdXNXpZc3pvemFiVkdrMFZFbGxPN3lScmhZWXZyMGxvTWZORHdBaHVYZlJKZHJHUkZwZmUyRWJZTUFNa0wyd2U0MUozM0NvelZGQ3I5YXBmTUhkRWJ5a3NQVkhZMG91NHp3dUJ3L0lPODVLb0pBdEhwWUg2ODVQSUpDTzhEd0J2Uk01em9JVTN3ODd3OW9kN3BJR3RKSmEyOGU2UkdkWkFjNUtOT04wSXNIdUI4elZNdXJ3Q3FGMDR2bFlWb1BkdENwZ3haSU1kakpTa1lEelFPbVlHM3hNcGFPQnREZmw5bW9ubmFTR2NlSzZmZDdwR2xoY3MyM0k3dVViZnNXdzg0UGMvWWo0ZHVnaGpWVitIRWx5M2pIVkRsMWZuRjFiQkZaZzFFZXo1NGhRY2ZNYlNOTGZEdkp5RHBZWXpBVmJWYXJTdWp4ZktDUytPNTdXVzdnc0JLUTg2RzRoSnRuSXo2ZzFoc080TVkxRDNxZGF3Z0NSYWJSUHN3THhJVy9naThZeDk1VzM2UUxva1Z6VGdjSzNqYTB0WGpCanRIbkRkOHg2VlRWNnJ1VHE3dnJRemliRW51UlgxcTA5bTA5QnppNWpabW9XaGxtUk5KdEdWemZPcGM2TUdBZnVDcFpkQndySzJYTC9yVE84NzQ4WDk3VUJNZE1DOE5SMUVuaHA1bjBxSEZ3T1lYQkhBMFZsWllhOU85b2dHVnFvaHpQdUFxNUVGSWlrZ21ya2VaWjBuWWF4c2lsMUxRSUM1a1VyVllVNTBNM29LVCtwM1BWT1lYbWRxSFRBMzZ1V3lFTDRDQjFra3A2dE8rd3Q5QnBlTG5PbjdUMWpXSG1iNGNjdkZNSFRuSWFDZ054aGRkS3NreTIyQW5mek5Xa2RXOU5tUVk4MHIwa0xDKzNRNXZWVU9LTGk5akF5SXpWb0dJM3RGNXRyRENxQlBSQ2c2TER2czlGaDcrRW14VWNKVXF5QzQybUFRNXFZSkxvMk9CcEUyRklndThweHhFbnNVZlptOWtpdkFkM1NNdlNTczlGZ1BtQnZqODNOVkNVMi9JMExac3piZHo1MjhjRE56WFRzd0p3d2p5TEM1dWt2T2l0ZkpBUXc4M0xIQmRYaThZR3ZYU0JXei80R1hqcElIMFdMMCtDK1NKRHZRTVhXWWQ2RHdBcTYvKzA0c2VNQjhRS0dPcVo3Z3kxK3k2S2hSdjdleWhRYnhQQ3hnT1Vxa1lHNG8wMkxiem5BTlhOZUs4L2ZJQzU5bDd2TGVZSDVyY3FNWXJSUHdWU0NxMFNvQVRJYTlEa1pHUXhCUmNKWi9GSVk0d3J1NGpTYXB3MFgrV3RldWJkMjlNT2tMNXJXbUhHa044cHlybVhaOVRwL3BlL3VBdk93ZHAxNENCdXVhcEQ0c29aVTIyRkYwQVByZ2M2TEpuYVNHcnFONTMwRVNRYnpybldsQlBPS2xSQ1JMYUZFWHoxZk1KN3RXSGFjV0trK2s4ZkRDN2pCdk9uQmxUeTNtMW9JS1d0ckRyVklGZ2xCN011Q1hoZlhvUXdMSlByY0JjSllWWGZZMUlQb2VUUFN6Z0xqc1BKZHl3N0dWRFlCbWpUMnZnS2pUcExOWlIyc0cySk1oUkdrbHVhWWJNK3VjWnl6TEs3bFU4UnNkVDNYRmVzSzgxbnlnMy9QY3JCNHZkZWZzOGFyRFBKK0lmTlh5UndlNmJuT0RiSEpKc09adEN5a0ExM2Jud2lubVFkVHByWk1KaDg2RzdUUjBZbzk0S2JzWTZTTDNtSGRUSmN3bnd3NVhJT1dRLzVsMlB2V0JyV3o1aVc3YUUrbXVYSXhjRjg2djE5Ly9rMWgyb2ZlMmtrUWJSWE9OV21HYkFEZ2hySUtCVVhmWHJkRXRFL3lvSFpjb2NhTmxDdUw2MXEwUjFlbWRnTzZqZ1RwaGZ6SDUzZ1Nha3duS1ZYTDZoeVFwSXlsQS85MGdybnVOZ0xrSXM0U3dTdTBXVTBZS2VnYVA5SjZlUUM1SkluSVFvdE5oUG8zamlQbmd3ZnEzWC9BeXZxbkJmSElCVHczaGx0dExRQkE2aVZEZE1NSnBCOHU5WlUyRzBaSWJyWTFBUDV3TSttdUdOTU8zcW5LdlB4ODhYM0F1KytpSWVTWlphRnhpd1oxY0RCQnNybHVyRHI2UUJ2a3JYbXJtRHJUZ1J3SXcwSTE4d053aGlNdGIySTM5SUlteGNqM25MMWcySVFDK2VGeUhBMDd3OW9PYTlKc01zR3AwMEdBK2lRRUdtS1BtZ1QwR0xuc3ovUVd2SzdjcU43eDNqVW51MVc3WEdHelU1UllORG96MDZCSnNVdTVhai9CTkFseG5EcEcxV0hkdFpGMk5JbjlWL2ZOMEJieUxSRmgxUUdGcklxcG5paW9yUWZxT3BidlZBRy9EeVpVSWsyaTBTZGhxVDdqQ0xINE1FbUZZa2VHbVlGM3MzdkJ2TGNWcU1aL2NpT0JCekN1N3FFdUNhWWxYTWtCeENES1VGd25ULzQwdU10LzBCOHp0Q3RuSXV1N2VENWhYQlBRU2JqK0s4RjVyWVJzNlJyYnZ1MkRlV0RDWmtDNFpWcEVSVDRiVjVvQU1YM0xTd0pla3VJMlNmUlZjTjFBS2R2Mm9mQ3NxeUU5djFFSGZPdnFsdk9HN3B4MmJ5TjRrV2xrQjBLM3ptMVprQlFoUVpLTi9hcnZvWklDZTVRRmVZNDFJQnMvMCt5YzV6d3RGbExWaTRDbVEwNnEzd1loNVk0UFdBM05Pd2hsOVR4dHlXakdNOWJXZXc1dC8rNW9tZ3EyeUxHY0U3Y0pESFhiWVlONDFBdmlNKzFIQ0R2NmJhbTQ5R04wbzBVNWI5WjBqTFF5dXRlTm1BajZlS3BlY1JOZmhZNmpqWHJUT3RaV05vUTFDeFFhK2oxK05KUm9SNy9XQmE4eWlpbGdaNjY5YXZwTkZtdURCYmYzMVhOZnFVTmVZN2kxdVExRXRiTWIrZVVpM2huT0Y3bW0wK1d3eDJDZzBYNXVCQlNNWnVZNnZ5WHlHTm9xNDF0YzEzNE5oSmFHV01jL2dqK1o2akpqWGhITXp3UVEvd3FWS2dUMUZoVnl6ZllhZnlLRGtRNjFJc1JKRmJFVU1lNk93bStkczdmVVdpRHFFa3BFSDNNbnJkQUF1QkI1RVorU0Y4d3VKM0hVV0QxY1F0TUswTlFsVkYwVWQwMzBtSnN1VkF1eUJVTUhsS09mQ0p1R05YUGc2TWJZK25DY3NlNXRkMGtpMTdCU0U5TkVRTmxjV3BhSG9KQkZKaTlmN3Vpb1R5MGI3dmFWNllJOTk0SmJtdTBjUzJOUDU1V28vMS9UbnRNSTBKeVBUQU43bFNxZjdJbUNxWlVVNjRBMWloSjlGeGUvdjRidXNHS3c0bW5OenRYaGdKOHR3a3pCbmxzdXFzUXNEYW8rNTNhQWJPZDVoNlZPclhXcVI1TE9uNHVPbVNRU3ZCZGRiV2h5MWJ6N3E2UzJTekFJbGlIcVR0VlBXeGswSW5NbFhJMTdlclZ2NnVSWWNWOWJiMHM2cDQ3UjUwVFY0bVE3TG1jWURTUVRzTmNuandIbVRVZGtEQnZ4Z2R1bTZJUndNWTIwMnN0UDZlV3hjazFjWTV4WllUbWJEeUR1WTdGN2pGRjZIL3dQQS83MlJVTnN5bDVsMkpLQWluNFMxM3p2L2dqWG1xS0UrbDFZMVFiSXhNdFVlZzZTaW1xNEFTemVyMFFBbER4VzhpSmJMRTFzSGlVUzFrWWFuR05SbmtBY2NOcGlYTWo1aFhzdktrdzlnOGhES3VEbXkweHJaQnN0Uk9hNVU5RTJ0M2JkYURtNkZiRnR0c0FuTExIVEdmSktqZG5WTkpqdXFKaFNWaFRKNEhRa2dhOWFSZ2VPQXVlY2t0NTd5UWp2UTMzSUdzNTdySSthejB6c2pBZWlEendtQ2hHWDVWVEk2MHByVm53NHRaRm1teFg2emsyeVNhQVhMTVRCclF3djF3UzFCdEpPd2JuRzRsVkM2MWNQMVZyMjE3QVQ2cldUWFpFTDU2QncwR2FteVdER2dweXc2U3FDTksydUd3M2hlTzRNaFFEM21sUTI5RUlFTGxxTmZzaVMrdnVDbG5Dc1JDMVp2WjY1M2gwbFN3VVFCUmJUaHRNSklBZS9MOFM0bGdIdEtzZlpxWUZHTHFKdi8wMkJwQWVnbW45Ynd2Sk1MRWRXRjFxVFVFLzdJeHJNUGJCYXRzMnBwZFdmOGpwY1Nya1Q2RXRlL05wVGxyRVlVSFh5ZEtlKzJXVUF1eTkrcC9acTZFK1dBalNVc1oyOXBlRDRKRzRuR2FHTWp1ZUpxWDZQMTRYeEVsVlZIV3ZEZWFvRmIyMnkzOU50YjZsYlhkTGZJdTlXQjZwNUtDOVZMZGJycEtCSlRXZG5nOUcrNVB0c1p2R2hKVmkvSnBJTVFnSjRpdFk0aXg1YklURXNNT0JQQWNvZGxmWTdQY2kxYjBtQ1pvVFpZSnRuNW5OeGtYUmNadzJqTkNmdTlVL2FKK2pzNnROWVdoUVBlWmlVVVU0YkcvMVBEWGljVk1OQ2NTQ3cvQ1R2V3NLV2xtODNBeThYL1o5RWlLM2lmOGRLY3dHMkdYQlhBWmpPRk5vcmFlODBUWkVmRE9oV1FvdlpHVnc1WFZ1NUpSandpQnVaQmpabzc5bWlhekNDMEhiT0doUStZMSszVzF1SUxYdXBBWCtNcGNNdkk3SWpaYXNkU0JLelJiS1VwU0VaaEl4SngwMTBuRXgzVThkUy80R1VlMmY4QThOL3hSeTIyNnBGRjVBZWRORHVhMEpuWkxVd3lxWFpEOGhnZU5kV3VVZDFCbmtPZVFNekFuVVZlR0FPOU9TbzMwN1dnaWUwUjYyNXl0K0RkbTJVQnZIRnh0eElDSExDY3c4TWE0QmhRZVg0d2dXVjIreXRlZkFRbVlaTTlsbG4wSk5ybEtGblFXcjdWVVZielNYU2lFd0ZuSmtid1JBbXdJNWJlQWN5K0c4UzFqTWxzVE1td3orakJ6eXZBN1BSVVprV1RXY2d0bG81Rk1MdTlXak82Wk51MFU3cFlZN2EzQXVtV25EQnRnRzgwSnk3eWJIWEE2VXJzSm9sa2RPWlZUZng4WFVtYWpZaEw3aWI0eG9DQzVXZ2hIVFphcy9nSGtmYXFGRkNIQ1hMZTRobkw4ZDZqSkkwckJnd0Nra1h5Q2JXc2F6TEVndDNqM0h5dWNXTmRmVWozMzF1OEJUSzJTeHZXNUFQMWZOVm1nMkxDL2pQbWMzQjB0azk5Y1NLS2ZRMk9CTnc5NWhsLzdySmlKeXMydjFaN3RETnRFcXA1YWx1ZitreTJXQm9PTTdCemVWUXhDNzROTkNTVkZ5SXo4bWdNakFMV2FQVFhOdEJuMDRxYzRMTGZ6aU5XNWFGbWcwRkU0RmtRbXc3dDBXOGRpL3ovOE1lVTJvZVZSRjlaMGNTZFZPSzB2N0tTc2M3bS92QjNEWEpkZTNPdjNhWTNZajdvVHpWWVpabzZLcWIrUGRkMmo0SVhBNWFOQTdWaWdIME9DdjMveVpBeHJSTlhReU91aUltd1pvS3ZReTZmQXE0YkF3cHpBSml1V1dCdFhoUUMxc1U3YlFkZmRjQ1NRdFZHZVNoaHdueEVUSU81NjA0eHgvWWc0VU5scmR3TnBkbFUxWkRyY1IxRUR0RFI0QnpHUHdsN1BzakMxWENmcnc4dnZveGx2YXJhc2tWdHVKRWpmNVpJUU11MnNKSEUzR284ZUl1NWRmVDkwd1lZcHhXTkZFR0VvWnZSdEpLWWNoR0hrMHMwS1pOWGtzTlJmZTNhcUJkSWdvamQreHVqaDQraTcvWVNjZXBuMUUzK2pMbDV6RUFBV3B0dW51aTRPQ0ljaGVVbWtTMGFPWThTck1zc1FMN1ZuTEhXNmx3K0cxeTNYcXA5dUlkcDJuR2lDUFEvWUY2aXdwTlVlWWMvR3pEb3NCd1ozR0ZwV0tIK3NSMEJ5VGU4R0VRY0NOQzV1SjRaeENPV2c5N1VYS1dWaFpUcEhCRWsrYmF5OWhESnhOV2hBcjcwSkFkQVVnTE5WaDNSR3ZQOWF3d2I1cnpXMmxPbjRMUGY4a0JFVEtZRUQ3Tmo1aEhZdWM5ZnE3L01oczJ1QVlwS2FKTWhNU09XTTZVMEVocU4xcS9IZDViY0FEY0NWREx6VE1tdHlqUnJtV052RXRrdzRNM1JXWTBtcS95V0pWRUd6SWNYRG1ZekdoSFh5aW9RWjNPOXA0OEcxN1FEREozMmhrQVdVSTF2REVBNGFzUHNpS1ZXcHFxVEtvRVhJMjB1QjJFejNhT0VVdHlmWFBXakovci90VjJ2U2c4bnpIME1RSURNcFNZOUhVOGpTYlhHUEJnSExOM3F1ZVUxaVpZTXhCMVphK1VvYVlObFpxd2JUay9CKzdXaktWb25VZFBFV3JpUGxmTmJZNkxSZTZjVllKcFdOb0tDMkROZ0RaU25sZXVHRlQzWFNRb05sbDFZWEVmZENkdUVmTjVrZ0ZkZC81blVmQ00yZThIY3E1VWpwR0lpdEo2ZUM3WVRyUlVBL0Y2T1ZnZlplSGpLd1NTU0YxZm9URVlpY05mM3RmcjlwekhYMTNUYUtQUGhVU1FEdkt1NmEybGxVNVlEZldkSHNnQ0RZMlBZQXJ0WGNXbkpTY0N4dzN4aVFMMnhEM2pwd0JybysvbkJ1ZEQ1UFdFK1Byd05raHc2QlZZcktZckpaSStpaHhXVHhJb2FDdFNLTURKTmRnOHA2SnhhK0FtekVRdGVreEwwYjU3cFdrZU1tRUZweExKV0dpdkE2TmdtZ2lTaVk3ak9lak9ML3U4bWEyd2xocU5CaEc1c2lXUElhdERDdGVWdXh0WXo1aVpLaldUemozaXBuS2wvYzVLMWNLYlFmcnFDTTBlT25TU29COUpRUjJIcEJYNUFvMkxRaU9VSWx5bVF2Y29PN2YxVEUxcDc1MlZ0RlZ0bkxDZkVUZ0VqVG9IT3k2WWpYTWpmVU5LSmk0b2ZKUnlDaExTZCtSbjd3eDR3OTQ2dFFQb0xYbndLZW1LK0IxclVUN0xJR3dGcUNCQXdNQTJpYzQ1WW1tMWpoVzAySm9QdHFnNjB5UU5HTm9pRzN2Rm1lWkRqYXVEOURyS0pUdmFPK2w2Yks1V0RCTmRhKytNWXNPUzFwcG5Jdzdpc0pNMnlDVmNuSS9XNGFwRnBoVzBEeTRMN1FkNnJteTRmNThVOGN5UG05YWlxL2ZjaUsvQW0va3lzbHVkdTlaSi9HQ1dmY1NGNXJoclNUNFpzcENEU2lKS2thU1dpZWZlS2dVMXczYWdZV0FQV3RGSWQ0S1lVWkxsd0k3YU51clhqcXBHc1pJLzVXSk5HWklVczRjeDNDdk43dkV3eWFPUjRHdmlaNkhVM0IrYnRnU0EyenFiQVh5V1V5Z2JrZEZKdU1lZXZQMnZndTcyeTJjUWk3VEx0U0E0bGVaaFRFSmxvald2a3V1VTBzYjBKblZIWVNUSWFJckRlSGFXenBSd1lxeFkzbWZkSG5nOE8wQ2VUUk9vUSs3VWlPS2FhYlg4dzkzZ3dWUVFJY2lBOXZBZUlubmUxRGp4aVh0YkYxN3hxcFVjaUYwdzJCcm1PdlVsV002dmxTZ1l0eTF6TCttKzFNRzloMlUyVGppTlF2UVZjdDc0b3NyWUQxcWNWRkFNaXFzODV5ekMyQmRScGtKQ0VVWllkTlp0RUdRdjFqUWw3UjlGNUx5VGNhKzkxbFEyKzBlOU9ocUd4RHBzSmhMT3dRaTdGU2xpTzBja2k5bC9vdUYydi80VHRNaXFYekFLOGw2d2J1S2ZWQzAyd09VU3NNa3A4RmNOWUlQSkl4cklvUGNGN3E2NXB2R3ZkYkk2cE9rMWFwWlNJTkRnUFZraUNWSk5TeWt4SFliR2ppWlNTZ0J0N29UNWhQbDZsb3d3L0o2L3FjM1dpOVRiUVBXaUYrUUp6ay9sRXowWXhPUml0cEZBM0x2NThCSnZibm5EL1RReDJDMVF0dUJxQTNRTFdCdXM5dTVGQmdwNWdJM3FuS3p4WHoxVmxlblZTd1RQZGxJN1lxSHF0Tm9ZSlpLUGJWYlo4cHBCOW9Db0NyalRnTEdpdElEZ1Q0RTNDNEErUytVekNQQ01kdEF0Q0phN2xkZGU4TmJxdXpqYlQ3MndrQkN6Qi93YUpLZ0EvbWRRbGUyQkF4RGx1RlhNTWJGVEM4dEZXVFdxUmg3OEVtd2dDNWh2cGVkbVFBdmQ4alBBZGVaRW1IRTJaWGZ2WktCdFBEK0IzSVJoYzMreEdvUEFVMXhyQ0QzZ3haRGtTK0xibTJtVE1SM2tQbEJkUkNZM3JibE9BTndQaThzNElSRCs4cHZVMTRIb0xvSzVWRjJCbDhVVWhWaEt0Y1RUc2lzYzZNQk5OeEN4NTNDOTdCdlNZMTg1bUFyejJHZ294VUIxSWErM2tuQTlHVCtyTVF3U1QvSEhUQkxMUnFRZlpGRURuZFNUbXZLWm41aUFSaytHZHNIU29uTlpUT3BiUUd0MDF5dHc3YTcwOVZvZ3VvNzcyOTY0Slpnb1NWTkc0Y21BK0xCTXJ3S3VKTFRkK3BaRklDL0N6MW1DdWswb2hMbXMvbWMwMkVRRkp3ZzQ1VXJ4Z1BpdHJrdXk5T3I3MXRIR2ZUZktaVFlIVVRXczA5OTl0TE5xc0VNbU83NjZ4M2dLb3ErQjZvL2FhTjVJQk9kakpuRGZtbXYyWGhvaE5FQUswd243cXp6ck1pNWpyaUpsTXpKTEJnY1B0YjNpWlhOQmdYdStxSnNVTjVyVzRJeVc3ZUFFK2t5NTdGSmJBK2krd2JHTjBsb1hhbDUyTkJocVZGUUhMbG1NWWtNZ0JVeXdtbWRWaTMzd3ZJSzdsVFlIdUhtWDlnZGlrQmdFNHV4SWxKMlZrU1JLTzV1ZHJ6UXhSUDN4R1BNV0FiZnpHNE43cDMwK1NnT0pTUkVnazEyTStyK3FKam1tZ1NQQ0NlZFVBLzB5MTZNbHNVclg4cWhLT25wNHQ3cTRjSlZlaUp2aU4rWTYwUTYrT2JEMC9GRmozTXRlMXNwcHhZNWR3VEtnMUdWdDExWGZPVG00eEthdHRLY3pYc0ZUYitVYkRNTGpob0M2TXFpOXhKVUVydXo0UFdqelFleC9sOHc1R1F4NE1hS3JHbXVGTlZRWUJyVUhBbWorakNUUTh2VS9aaE9iSmdKTGJJQnQ0MjBJMWdvN0tZaUlnakVxMkltREtLM0tXYml3amxtVktlUVBNbllHTFNobVRBYndKNjBZOWtkd3dtUTFxelRONG9MOWpRM3FuVlhOOU5vZms5Vm1xZ3p4UHRMWitwMFRXaUhuWFlFOVIyeVRScEhxeUZpUGZSRE91Z09XY3JMWEMvemRwcWltbE53SHJyY3gxVDIxWVdzbkNwdURpUlhQSEd3cDFPU0dsTmFwczNWZkxvdXJFemNGb3RHeW96ZHBVcHQzNVJDQjlFVFozdklMbUtDSG1GOUtmbnVsWVdaTmlac3NNcU1XOGEwdzdZVnFqWTdyTTdnVXZmclhxRzVxTnR1WTJ6MllqZ3owRkVVeFVyY0NmV1ZiQ2RkWGFveUY4S3FGZ0pTRzJGcjd2bVpUTG1xd2pDNVBJTlNvaHBPQjR0WTF6a3J4Q2dmYzNkZjN5UmJSUjltZHRDQVFQbUkrYnowSkVOTGRSbTJncTQrWG41WXpsdElOQ0xKV05rN2dkdHBPTmgzMlkrVDVvbmJMVDVyY016VCtWcGI2WDVucnJ5VVN1UjlwRW9ESkRSanlxb2k2aUI3elV1SExDcWhoOXE4TzhOMytpY1AxTUM1MUgrV29kMzVFeXBBZlJrTDdJNHVUSnNGeG8vMVhDb1VIWU1IZkRjTUpMZDJvRlhHWnNGOHIyUG1CWjZwVTJ0TW05QXdZMU5HNk43c2M2N05wMFdYNTRSaE91YzZXSFpwVUh6RXQ2b3I3OUVtejB6aVZLbloxZ2lNS3RkbmJaNUJ4VUloaUVUYTlKQ2lPdE4wZDhKaUVtU1VKLzF4WUxJUnZjTERQQXQyWVhZY3ZzQWFMU2l5YWxlN3F2T29HZ0ZaYmJDUm5UeU9WTmt3VStHMXhmQTU1NzN4TTkwR3VPUVEyOE5SNlBoS21sVWIzY0pQWjJiRXpDUUl1bmovQkcxcG1BdmFHL1BSaHc0UkV5YkFyT2tzcElRTTBzczZIRmRNRjgvbnNXU1lFN3BSS1dReERWK20wSVFCcUkvWFludzZRMEFhVDNkY0p5ek01YW80aGpaYzVuRm9IRTR4NzZTQkpRVmprRnlaUWNKT1VtTEkxWkVHalpXdlV3R1pBdlprTUJBYzRvVWNGa2twd014RDNtRFRWY0dkTmdPV2tBOU56d2dOQm56Q3RvQml4NzlFZjU5NFZrTUdiQ1daTFFHWEh0Y1RIbjFRUkpzRTNjL0V4UWZhK0UxaTBNZHcxY1M4QmNOVkVGRWVTMUE2b1BicnJLQ1ZuQVlRd2Vna0Vld2taMHRmcnZad0xKMnBmZFl0NW93Tm5VSXdIbnIzZ3BDQWRlcWhzcWMzNm04em1Za0xXVlRHb0RQL1RRNmRtOHNEdlJBSk9SWGtvUTJydWhpbHNhYUJPc2o4aXR5aVhIc21IdHlRQzFNd2lQSm94R1RsNEY4ZlFCQlhabm5sSldOaTIyb0lSc01JM29tMHdZWENjWFpEMzNlQmtMMzRvOE5tSFpQZllzVVNXSC9BM21VMXRWQW1rSVBBczlqOHE0cDBCQ1hFc01ScTJ3WlNYQnZrbjhQZ3BZUTNBMVFQc1dMV050ZEcwMjJtRFpTSkJsK0dMeVZyVE1xQVFvRzdBNG1jWFBuMU9UVkEyQlppWkpZU1E5OXArMCs3TVhiRjJvWCtoNEw4SktkS3JDUk15akZuc25TVTUxbVB0aVp0TEppakJUTjhxY2RlbTFqUkNHaWZKck1PL1RpZ1hIZWwxR053VnMyc2tSYVlWZGxrQ25WZ0IyMlgrcy9DeGl4NjZ5UUV1SnhoV1d5K3VmTzZncVFCNGxnbE4vNEc0bGNjZmpyTE9FN2p3UGkxdkRMMWlhYjEvbzcrb3hQOUcvSDJRajBHU2J5Z3BaRW5RcEFOZ1NhTjlsQlVoRGNQMUlVTjBGcmpzbGdpM2dYVnVjQmJGM3JJWUl5ZzYwSFZORHl4Wkw3MGZXdEZxajRkYWIrb0M1RTA4aXJmYVp0RkFYR2g3cDV3ZlJTMXVwQURqUzkvU1lEMVRVTGhVTnZUcDRCekd0UlhSdHFBMzhsTTFrd3E4Y1pPN1huTTJpa0poN3poMmc2dDlFakhHQU43ckpnZHdVTVVhMzhjSUFyekwwQnZNeW94Um9xY09PWkYweU91UVliQklYMmZ4WmQyMFJkNi8xaHJGemFlQms5TlRmS1pMaTl3eFlqbVNxOStOMGZYWit4OXkvQUZpYXVDdVJHdVErYXMyd1MyN3RNV0pKUHlTNHZrSW1TSy9ZVGRZWXBwdlZualpZYlRhWlI0amV5ZU1tSWgvVWJHNnN1NmxzR1RoUTZGNG54dFphMnZwZy9FSUFXRm5BZ2ZTd2IxZjJXM1d4VGpUU1g3Q3NYNnhNdFNPR2tpVEwzR0UrdzRzNzFEUXBwcVYyQ1V1SE1OZXgxUmlRY1VYNWtRMWVNdmNSQVZ1SkhQMXpvUGtDeThMMVpEUlkzZGpHbGNRcXNKeEFBTGwyQlhIVlROVHVxdWJSdFV6cUdCeS8ydkZCRXFSY3pNL3JubVdrSjVIUWVDeUxhdXFqM05lblFNNWh4dTQ4THRiTW0wb2dzNnc5aTd0YVhqOERXSGVENnc2Z2pjQXVHYmJWSSs0SmptcHFlV2RYVnluVmJZQ2xONlV6cDlCYVdkWnNKOUY1dVZXMUFxS0daSkRqYkVVSGJiRXNqT2FDYlM3VjRqRHBKQnZHU1pJS0hlYmxYWTNKZWtPU2E1a3lzYTB3aFFiTGtpZk5IaGZFTllhYXZDckJ6MU93ZVFMTGpweHNIbFNZcE5Rb1VrZ3lHdCtJWlU5L01xRjlXWW1hMXVwU3A0QkJ1MlJZMUVXbDREd0VnSjZNUmx2WDR4Riswc0FrVERXYjc1NklqRlRkdnpmRWg2ZDRxRmw4MmFHWGpvYk1ESUdzT0cxSWlydmx5eDhTWEd0aDdRYVQzV3AvalRSWllObUYwV0xwbnFYaEg5Zi82VEREUXVGNUx3eEZRK2ZSc0s5ZXdrQXRoQjR4TDlFYWlVRW1MSDFHSCtROGFodnVBNEY1Rm1aN3dud1VlRS9mZTVMemJHVFJ0Z1FtalFIY0pOYzRNbXFaNEpzUGRCT04ya2JYM05LMlpuRTVZSE5TQWpOaG5WN3JwZzY0VEgxWlljazYzY0pKRmk3NlVwOEI5YzlvaEN4TVJxNVJBNkdSSkNYdU9xeVZLOXBRTXVDUEVzQkoxalJYQTJqWDRZWFdQZjhkWDg4Unl3NnhEa3VQVmlEdUROeXFXOFZHeUsrU1ZmbXpRZlhWelBVVlVzSGVoQmNNeUpaZ1p5MG14RkRXTUdGZWhqWEE5NWdubzhtMm1EY2F0Q2JNNVE2WlVYUk1pR3hRbXc1NHpIWWptZjZSd3I5L1VzTHNJRUNlNlp5WUlWUjU0WnNrSm5TRXNtNUsyakducFYwamxpWTVUcmNjQXhtQUFXNE1Icks4RWJWRXM3NWM4bVl0NHgrTmRRRzhNYm1HdVk0MWwwQytpSXlzbzdIb2JqS3JtZ3dCODRrY2V0MDRrWFRHdkVLRzdUVjVmbHZHM0Z5RkFacXJaaVlUV2FrSEF2dGhqTExwVDdLQllFWHkwWW9mSURaYTMxMW4vTk9BNndhYmpVYVFURHZCRlJMT1pjeGJXcE5KUXJpYmNKUy81Y3lrYW80TmZHOCtLR3lmTUI4RERBTHVYaDY0R3BZOWlKN0ZZSDZVYzlRSGRhS2tBcmNhY3ZjTEErS0pIcDc2K1NQaTN2WFdQTlNkWEpzVzN1U2NOZGNCODNJdWwyeFNIMVlGbWJVSUtOTGJkRjAxQWN0eHhmL1JaN214NHpwQ215Y1NzLzd0ekZNU2ZCMXRNa3pRdGNweTUxUWpVcFRLWkpDb3FxNkhXdjdYRU9neVlXQ1AxVUZ5QUc3emFPREhoeXN4aWphVExkOEhyU1Fvd1dmalJ3VFZkd1BYZ01tdWdXbkVYcU9iRXZXUDF3VnlRZXp1cmplem9iOWpObnNSelZXSHcra0lETzJVT2hNd01jTm84REs3aXplQmswZ1doWkpYOWYxbjBrY2Y1QUU2d3ZlL2N3ZUxTZ0hKU0J6TTlobWdFdW03Q2ZPcG5aMTVYMzBRT3puUFpEWS9sL0JTMEhHWjl6WHYxNjJPTEU2UVRRSDdqRWF4TUxpTUFhTjJsb0ZUQUJvc1g3V1l6NkxTSkNSRTd4NGxUR2ROVnNlKzFBMTVNSWxlalJJbWtadDRFMjJ4Yk96Z1d1b0J2a3dxQjV1S215TzNWWDY1SlFmOFVLRDY3dUQ2RGxKQlZFVXdyWVFGTHR4YVMwWmtXVERxSk1YWjJTU0pHMllZRC9LOTdKaCtrTENLeDRiWHYra3dIN2ZCMmQxT1dOSVJjMk9hRmt1VGtQcWdmY0c4djF3WGRKM0EwQm9ReWlheHhiS0Y5dlludzdKMXVPSmF4WWlXVUxtNWFScWF1MnFSY1dWVGo0WXVUaVl4bzdJU2YrOWcyR1YwZkxySlh3UnNSZ25GcDBCdTZjengxbU9wRlFBbnpDdEVYUGxaSnBtQW13SzBQVFZoNlhrd1N1VGpxaSs0Q21GUE42ZVNseTJ0OVZVQTlXY0Q2N3VENnpzQWJkcXhrMFVYZjh2UE1abVFlQW9Zai92ZWhrQ1NhL3Q2MFRoNWVPSTNMR3RIdVgyMUFmQXZ2RlFqWlBOd2pBSnFQVDBBUENpeFRtZm9qVVF5RVRQbmM5QmhoZzJXTlpGdWxEWS9rSnJBNEdxTElndzJHdkd0RFNSYTNRSEU1aW5LREpVeE9lOWdDRVBVU2hMMUc4MkJWS0gyaVUwZ0l3RGV4MENIU21ZQ1RqWldTU1FQY1Q4K2cyTXJ1bllUNkpjRFJYd2EyVTJZbHhlT3dwaVRhUE9hdCtEbnduVm1yWGtCdUtHTHIycGUraEdBOVVQQjlRYUFkZnBzeG5yMmRnL2dKc09VdURLZ01UYzZZVjZ1bEkxVTRBQlF1MWhZSy8yQ1B4eTY2Z054d3JLMms4dGFWTnQ3b0FlWFI4cTA4cUJWNEgya1krN01Cc1NUR1k3RXBxcHZiVTFtZGZKd0YwbDB1UkttVGg3MnFMWXltUkI4REpobXBMa3l1MnBXTnVqSkpMb2NpOWFSMVozUlN6bTVrNFdOOHZmcGdFbjJNaTJCcE5DWjVHWnRseTUwVHdZQlBrNUNhYVBJSUNEYm15VG1pT1VVVmE1MTFWWnpCdFZHN20vQ3NuRmlUOXRxZ25mQnVvUHJPd0ZzRkFha0ZjSGJnU2RXSGlUWFp4Nng0QVJmRzZ1K3FNNytMNXVRNlFCdmZGSWZtbXFnL1VqYTE0R1lCai9FLzhDTFd4ZFBTZWhOQXBDUGwyM2oxTWdtQzdnOFlGNSt3ODc1N0hLbFEvZTRTa0haSVB1OW5yRStidHI1UEV4WUh6bVRSYnZmTWdYU3pINFdnQnl4Tkt3WlJGZDBwV293bjNjeGY4TnNuZzJvdWJxQ1J4UnhtTjZKck1UWGFBb2tzaXo2L3JUQ2ROblFtdGY5WUJLQ1U1QU0zRXBnSmZqcWpyVW1wQjhlVkQ4TlhIY0NiTUp0ODI1MGFtUTBlQS93SmlOcFpVRUE4NEovU0hLQkMrMmQyVVF5SUp4TkdLWFZDcFhwMXFKc25wN1FZdW11eFlDcENSSU9NWXZJRUtQUmdIdGhyTUI4MW4xOS8xbllOUU1zbjNPa2RYUFNSSHZ3T2ZNK21hU1lTNHpwRUR3dCs2cXp6TFFJL3lLaCtCUWt0U2F6Y1krVXdIVDZvenJuUDVQR21VVFBWOTMzSWxLUTFvRU9zbGtWczlFQTgzSXFmVTdjTTZIM21TY2dnRFo1MWJralQxNzFTbllhL1dzbHdaOENXRDhOWEN2QTdtaEFBUFkxSFVSOTQ3cGdzMGxVUkx0cDlCQURmc0luZHpLTldCb2FRNUpWRFMzVW5yNmpnemYrcnM1WnYyTmUxNmlKa3hielNvVTYrK3NMc1JsbWRVZjhVUnBXeHlXcnJzenNzQ0hnN2dnc2F2S016WlFQQVF0c1JFL2xFU1BjVEFFRGFoeXFzamFzanZrWCt2ZlJ5QUd0aE00S2lxTmhlSkJ3RjdKdWVpeGQzRGlCeGYzNE9oaXlGMjJlL1dqckd2eE8xNjgxaVZadVNHZ01ZOWRKQmEwNWZ0ZU41b3h0ZEtvdWhDUWs4eHhFSTNqV3hrTHQ4Z1g0R1lEMVU4SDFEWW11Qkc5WkJyTUxUeXNhYllQWUNrNzFTTWlEZXBha2dQcXVha21LMXBDcUZzWkpxaVQ2S1RjRkFNdWUva2U4T0hUeEp0Qmg2U01iR1JCcitOc0VFc21JZWZuYWhZRDhzcUtWZy9UYzNteUVCeXpOdExsMWxjR1hTOXU0TE80aVVVSm4yTklZYUtkRk5zTElaeGFZRDhEVTdqeGVjNE9ScTdRenNKSFF2YWRyZThaeTBtNXY1QjUydHVKNzM4c21lakVKS0sweDFra0dUdVpLOE5NWU5ML2dvZ2dZU2UvVld1clBCS3gvQ3JqZUFMUXB1Q2xZU1c1dC9RM2dTMzdVTUNLTDV1WVdVd3MvTWtaSHF2QTQ3aUtKSmpiRjVoRHVnbm1iWTYxOUhmQ0hjUXQ3ZE9xbzdVY0N3bWNzdTNzZ3dNNFB6b01BVkpIa2pNN3UwZ2ZuU09lbG9TUzNkVFpHQXVEanljS2VXWWU4aUxUUlk5azg0TnBiZFJOT1J0Wnc0OTZmSmZUT0JPNFh2RlIvMUtqaEY4T0VHOXFrUjh6cm4wZEtYRFh5L2lTYm1PdEFtekNmc0FGYUR4ZjZqa2JXdEZhNFRQQVRXU1B0T2dXYmtqYjd0SmdiRDkzTVRPL2crcmxzZGt0R1NDdmdHbldPNmFRREJXUU9lOWpzaEFGcmJVNFlHN3Fjc1N6QkdZd1cxbUUraWdhWXo4aGk4NDM2NEh6QjNIR3JQdWhuQTFqY2U5NExBNjZlQnhPRmtRY0p4ZFdzWEFHTkozMW1MRzNvT0d0OXhOd0lQV09aaVc0TWVJN0NSRHVzejJqVEJONG9Na0pVVGNEdS8vWGZYNHhNMFJBQUQ1Z2IrTlQ3VURmTUMrYXRwVndkb0phU2cveDNNb2xhZnIvNkFtQWxnZWpxVFoyeGVTUWRSRVFuTW5PYTNpb0YvT2pBK3NPQTZ6dUI3QjY5bHRsbmkzbG1kQkw5S3dWaGtDN1FaQVQrR3ZwbUFrVU95YmtzcTJiOUwxaWF0eWhiTEJKYW5rUWJIWXhlbW9ROUgwUUw1a3cwWjhNUGRKeWF0QmxOa3U2QWVmODlqNWJoOFBoQTRNK0pyaXpBeUkwTW8yaSsybFhGQmZHdUw3OWVneU14VVdiUDNMN01VY2gzT3E2V0VuSzZLU3JBY1k5L1EreVQrL3lMckRlT0J1cW05ZzN6RWtEV1R5K3lRYW5GWmk4eUZFZHNMbG9vSmlub1FEc3kzVUVRWFU0ZmdSVS9PckQrY09CNkk5QnlUUjZ3UGg3Q3RlTW14TFo1MnNMSFlkaG9tUEZXYmFhR20ydjJqRnJLdzVKQmZjaWZSU003Q0lOa0U1Z0tCQWNzWncrcHB5eFhLQlJKcXRSS0FSN2d5R3kvSnJvZXJ6LzdIUysxbTBmTU05aFpOclFPODQ2bFRoSXBQQUdYUWJURmNoeUphdTdjUFRjSzAzV2xWQjJXRm9VNllmVWdtdlNBNWZETEdpbWNNSjkzeFlrdjNrQTcwY2RabGxDN3hFYkFXSnN3R3RHR3Mza2VKcXliVSt0QVFRVmZWMzZHRGVEZGsxTzVnK3NQeEdMVGpidWttNldrblZvdGxnNU9LUUR0cUJ4SWdUT2JaRlpsdHBNa1BCajhHTUFtekR2RXVBb2hZMTdHeGZhRU5iblNyR3d3T3REeGdua1RBdXZJSjh4N3kwZDRjK29XOHpIUERJYjFNNTR4YjR4b0NKeDVQUFNKbUNJWHYxY1Q2UVBtcnZ5cXd6SUFuUW4wZ1dXNTBDaWJxRVk4UFcxTVI5R1ZJVW0vRWN2S2k0TDVJTCtFZVlNQkcxMXpaY3BGTkh2MTY5VUl5OVVBNitRTVhiTWFpUUcrcTI2U0hFSXl6OHdXdS8xTGd1b1BENjZmb011dS9UeHFwVzJEbitzWUZ0VnFOZEdTek9Ka0l4bHVHbUNObEYyU2RES3Rka1psMHZXWTdYQ0pGUCtzSTRhcVk0MjF1bUV5R21ZdmV0OWtvb1lqZ1JzRGJvZTVmZU5GUXRsV1BwZXZLUTl5MU5JczE2NzhHK203UmE0Rk0vQ0pRTDNIdk82M2JyNERzZjBCODFIcGJGOEp6RHUxSnRuUStMcDJFbjNvUUVIMTVXMkVWVTlZMm1pT21Gc0Y2ajFTSU5XcW1SSDcvSmpYd1BRdm03ajY2Y0gxSFhWWm1NVVZ6V3RTUWIrWXNDbkpnbTlJcXl5WTk2YVhGWmFkaEtXb1dVaVNSRWhQR2lLRFFTdVNDUmVGMTg4WWhJRkJORk8rRGljQmJ3YUpEdk9NT3lmRnVIVzJKYTJ6STUwNVVkZ00rdDIvOEZMblc4ZUlUTUxRdGZSS2dhOWUveU1saVNDL3ErM0NtdG12RWNWWjdzc2dEUDRzUU0wMXFVOVg3ZlNiSk9nNmtXZjAzT3NhK2dyZ1A3RTBqMmM3UXNobnVQSW83alJVQnF6Z2R3c1kzRXBZY0FmWG54dGtNMjRmK3hCNVJ3SkxQd0dYVVhZZFh2dytaaW9NV0kvWFJmNGR5K21rSTN4Q2pUdXlNdGJOTFZpZnJNa3pCcGN6ZmM0Qjg5WlJmbWpad2F2RDB2ZFdyM2NuQ1pYNitUeklUemVubmxodHRUYzhZSjdnNjdFYzJzaWE2Z0hlcUxyRFBCbW9lamdueTdTd2ZzVFNRakhKY1RlU21PTGFXWjF3MFVweXl5VXJSemwrbDF4eTB4dDBMVHBtNmpUVWNrTVNLcjBSak12ZkFWUi9lbkRkQWJRNmVxU3NMTFkxT3F4allLS2hlTkZDVjU5Uy9WdVdDbHI0b1gzTlJnSUNXUHFnY3FMcklzZlh5RVBJR2YxUndscm5OdDlnNlVVNmt2WlpFem90bG8wWXdMd292c095ZGpYTEJzRkdOdHo0MEZKb3JwTEVFTnpiQ2Q2b20yVVZCcEVuWW94Y1BhRWpveG13QnNPMHVXT0xOOTRCeStTVWE4OVdjSFVhYXljU2hKdTBBYXo3cUs0eDB0ZUE2cXVBOVMrQlMzK0ZrOWdCdGdueHFKQzlMbHQ1SmR5SnpHVDA1OUVJYW1aeU9wcGxOSEpFcE9OcWc0S1czakJicW15eUYrM3hTR0Z4UXdEUWtINEx6Sk5RV2NKY040aVF2V2VyUFNMWDEwN20vZHFQWHplZ3MwbkdGQ083SEFXWXRmaStndmt6NW9uSCtuN1dtbHZaSkhnYVJNR0x2V1FUTU10Rzd1RkkxemJKOVhQbGY2TnNJRzZpd3RyUVR4aVFmZzBRdmx0MzFWOFpXUCt5NFByTytxd2I5NnZHTGhweXVZbVZCWEZwUzdUdytXRlZsc1daZEMwemlnYno2WGlWU1I3VURzdCtjaDFEQXRIL2RQd05sMyt4aXhJejRnTUJ5MWxDZDk0RUFPOWtwaE5DVDVobitMVVVLN0luN0FTME9PSEg1VlY2andlUkN2UmFEU1pDNEExVzUwczVHOHVxRld0NWxCdFo3VUJVbVdveERCUTM2S05yV3VxYmRkYS9KTW43SzRPckE5cWQ1akVSZzNXL1U2Tm9ua1BGeGVuUmlPWU95NXBDVjlMQ1lCVjVLL0RET2hKZ3NyYW9kWitnc0pVN3FMUjl0Y29HNnZyRXg2eE9UaG91TjZLaDF1UG9zZXh3WXpiYzBma09zdW00Y2RZamxoMWN2Q25xQ0c5bXQ0MHcwOEhJT0RxMVFwTmhESGc4UlNKamFXYnVuS3F5eUFnSTFvNjZXbWtreEp2Z3NCTHVBNi92KzM4MWsvMnJZOC9mQmx4M01OdlhMQ3JYN3JyWDZEZnRBRzVsa2Nsb29JNnBaSGkvV1M1ckdnSTJyRk1EMURZdWlmWmFYM1VRNDJTT2s1MnR1QWExOXRxM1dOYjBEaUlGY01kUkJTcjJlR1ZkVkV1c2VwRUIxQmVWUFFQYzhNVUtVcHo0VXNib3hyRS9YcS9KaUxodEZMS1piRGxIUlVENElESUxzRFNDajlobDFFeHpEL252NFBxblNRZEpRdHExaStrNnlmYUVXazViUkJEdXRWaTZHYmxSSEMyVzVoeXRBSkZqaHhDZ0grUm5BNVorRFF6cUN1WU1Xb09Fdk55T3FsTUNkTzVaSXlFM2x4N3ArYnNTS0VqME1Kcjd3dzBRWEdJMndKdXBBTjZKUDVLRDFzQlRqWVJLc0VZMDhYbEwySDhIMGp1NGZoN1Frb1N3bFFEUUJieW5zRnExMXoyZjZidzBSNnhuZW5WaVFEUVFNSnNRVXhtcWE2Q1lBajJ2R0thcmp2Z3U2YVgyZ1lNSjVWa3ZadnREYnBaZ05qa0t3KzFGa21FVzIySGVOZWZPVFlFdUd4QjNIWHZqamtocFQyTkx3ZHV6OS9pSXY3dmp5UjFjUDR2bHJwbGVyQzNjYkJoUVFselRpQTFXcTkvQjRiZHFoSTc1OEh5dlVVQWlCK2VwTFpXUU1Gc0hJSTV5M001WEZQQU8vc3pTSHpCM3FkSnI0UVlPYmlXSGxQVlB3b0FqZ0ZzckJRUzgvd1ZXUXZuOFNqQ052dS9ORHovbk1PNVljZ2ZYUDF0S2VOZER3YkpTSVFMV05aYVU0U2VrSm5nN3VvZzFKNUVJWEJmY2dIZ1M3MlRDWXE2bmRRTURYV1hCR09pYmVtNFFqUkx3bzNoMHRwV0crMXBQcXZmQXVVdHRzY0x5enV2azNjeXA3MkI2QjllL0NoaEhZMjMyK05VQ2N5L2F0WWNiQm95cUE5YUF1UTFpTXN4S0FWSDFRVTQ2c1VTUnpMbHhFbzh0Q2lmRGpMbFZtQXYydVhQcmd2WFJQbHNqMXFNa2t5dk1Ud1owTTlZYlRMRHlHZS9aVHVyYzRYWUI2UjFNNytENlU0S3VLUTliQU9wS0NWblV2S0RsVEJHb09IczUvVHMzTFRXU0tuTEFlRjI5YWpiTVY1TkJyc3hJTzVnNHdWWGJpdnRndzRrbUFEc0c2Z1pRQWo1aFZBSXBhQlcvRUZ0bTNzSTYveFpqVSs3Z2VuLzlpS0N0WFdCUk1vVERYalVZWVIxMEZIQjBtaXUvSHdhSVhLZ08rQW11Q29hY1lIT2V2dFhKU3FzTFhPanVnQzJ2U0NMQXR2YVpOdjRlOEJyckduaHFRZ3Q0bzNWZkhScDZmOTNCOWY1Nk8rQTZWcVZNZDZ1WTNKVjJJV0M2Q3V6S0VOM2tYZ1V4d0R1TDhZQkd4eEsxTVNKaTRXdUFCcXduRWZYOUUyNnZBbmd6MDd5RDVCMWM3NjhmbE9HNmgzUkRnbEFQMjhoTUptS0FrUWFwMDNxZE9ZMEQvb3gxQ3oxWGJ4cUY5M3ZyUTE4RGxsSGJNL1orMXYxNXZZUHIvZlUzQStlTmtCY3JvTEtsVDI1bDJwMVY1TmJuUldHM3ExYTR4Zno1N21WNmY5M0I5Zjc2V05DVkJOeGFvOFhhTk41cVAzakdkc1hFTGJXYnJoUHF0UVg1MFdkWDZXTEx4Yi9jQWZVT3J2ZlgvZlhlREhjTCtOSUt1MTJUR1c3NXJxM1J6cCtXcmI4L2kzZHd2Yi91cjQrVUV6aTc3OEJMNjNadkFla3RlZURkVDNXSHhIQUgxVHU0M2wvMzE2Y0JyZGJadWltc2U5aXFZNkVLM3A5cGNKSmU4UFQrM04zQjlmNjZ2ejRSYUUyMXdsNWZocDltSWQrZnVUdTQzbC8zMTQ4dUkwU3ZhRFQ2aDg5K3VvUHAvWFVIMS92ci9ycS83cThQZk9YN0piaS83cS83Ni82NmcrdjlkWC9kWC9mWEhWenZyL3ZyL3JxLy9xNnYvejBBSWRwN0Ewb01rMmNBQUFBQVNVVk9SSzVDWUlJPVwiLFxuICBtb3ZlZDogZmFsc2UsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKGNhbnZhcywgb3B0ID0ge30pIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXM7XG5cbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLndpZHRoID0gb3B0LndpZHRoIHx8IGNhbnZhcy5mcmVlRHJhd2luZ0JydXNoLndpZHRoO1xuICAgIHRoaXMub3BhY2l0eSA9IG9wdC5vcGFjaXR5IHx8IGNhbnZhcy5jb250ZXh0VG9wLmdsb2JhbEFscGhhO1xuICAgIHRoaXMuY29sb3IgPSBvcHQuY29sb3IgfHwgY2FudmFzLmZyZWVEcmF3aW5nQnJ1c2guY29sb3I7XG5cbiAgICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmxpbmVKb2luID0gXCJyb3VuZFwiO1xuICAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AubGluZUNhcCA9IFwicm91bmRcIjtcblxuICAgIHRoaXMuX3Jlc2V0KCk7XG5cbiAgICBmYWJyaWMuSW1hZ2UuZnJvbVVSTCh0aGlzLnNwcmF5QnJ1c2hEYXRhVXJsLCBmdW5jdGlvbiAoYnJ1c2gpIHtcbiAgICAgIGNvbnRleHQuYnJ1c2ggPSBicnVzaDtcbiAgICAgIGNvbnRleHQuYnJ1c2guZmlsdGVycyA9IFtdO1xuICAgICAgY29udGV4dC5jaGFuZ2VDb2xvcihjb250ZXh0LmNvbG9yIHx8IHRoaXMuY29sb3IpO1xuICAgIH0sIHtjcm9zc09yaWdpbjogXCJhbm9ueW1vdXNcIn0pO1xuXG4gIH0sXG5cbiAgY2hhbmdlQ29sb3I6IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLmJydXNoLmZpbHRlcnNbMF0gPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuVGludCh7Y29sb3I6IGNvbG9yfSk7XG4gICAgdGhpcy5icnVzaC5hcHBseUZpbHRlcnModGhpcy5jYW52YXMucmVuZGVyQWxsLmJpbmQodGhpcy5jYW52YXMpKTtcbiAgfSxcblxuICBjaGFuZ2VPcGFjaXR5OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLm9wYWNpdHkgPSB2YWx1ZTtcbiAgICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmdsb2JhbEFscGhhID0gdmFsdWU7XG4gIH0sXG5cbiAgb25Nb3VzZURvd246IGZ1bmN0aW9uIChwb2ludGVyKSB7XG4gICAgdGhpcy5fcG9pbnQgPSBuZXcgZmFicmljLlBvaW50KHBvaW50ZXIueCwgcG9pbnRlci55KTtcbiAgICB0aGlzLl9sYXN0UG9pbnQgPSB0aGlzLl9wb2ludDtcblxuICAgIHRoaXMuc2l6ZSA9IHRoaXMud2lkdGggKyB0aGlzLl9iYXNlV2lkdGg7XG4gICAgdGhpcy5fc3Ryb2tlSWQgPSArbmV3IERhdGUoKTtcbiAgICB0aGlzLl9pbmtBbW91bnQgPSAwO1xuXG4gICAgdGhpcy5jaGFuZ2VDb2xvcih0aGlzLmNvbG9yKTtcbiAgICB0aGlzLl9yZW5kZXIoKTtcbiAgfSxcblxuICBvbk1vdXNlTW92ZTogZnVuY3Rpb24gKHBvaW50ZXIpIHtcbiAgICB0aGlzLm1vdmVkID0gdHJ1ZTtcbiAgICB0aGlzLl9sYXN0UG9pbnQgPSB0aGlzLl9wb2ludDtcbiAgICB0aGlzLl9wb2ludCA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRlci54LCBwb2ludGVyLnkpO1xuICB9LFxuXG4gIG9uTW91c2VVcDogZnVuY3Rpb24gKHBvaW50ZXIpIHt9LFxuXG4gIF9yZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXM7XG5cbiAgICBzZXRUaW1lb3V0KGRyYXcsIHRoaXMuX2ludGVydmFsKTtcblxuICAgIGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAgICB2YXIgcG9pbnQsIGRpc3RhbmNlLCBhbmdsZSwgYW1vdW50LCB4LCB5O1xuXG4gICAgICB2YXIgY3R4ID0gY29udGV4dC5jYW52YXMuY29udGV4dFRvcDtcbiAgICAgIHZhciB2dCA9IGNvbnRleHQuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0odnRbMF0sIHZ0WzFdLCB2dFsyXSwgdnRbM10sIHZ0WzRdLCB2dFs1XSk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLm9wYWNpdHk7XG4gICAgICBwb2ludCA9IG5ldyBmYWJyaWMuUG9pbnQoY29udGV4dC5fcG9pbnQueCB8fCAwLCBjb250ZXh0Ll9wb2ludC55IHx8IDApO1xuICAgICAgZGlzdGFuY2UgPSBwb2ludC5kaXN0YW5jZUZyb20oY29udGV4dC5fbGFzdFBvaW50KTtcbiAgICAgIGFuZ2xlID0gcG9pbnQuYW5nbGVCZXR3ZWVuKGNvbnRleHQuX2xhc3RQb2ludCk7XG4gICAgICBhbW91bnQgPSAoMTAwIC8gY29udGV4dC5zaXplKSAvIChNYXRoLnBvdyhkaXN0YW5jZSwgMikgKyAxKTtcblxuICAgICAgY29udGV4dC5faW5rQW1vdW50ICs9IGFtb3VudDtcbiAgICAgIGNvbnRleHQuX2lua0Ftb3VudCA9IE1hdGgubWF4KGNvbnRleHQuX2lua0Ftb3VudCAtIGRpc3RhbmNlIC8gMTAsIDApO1xuXG4gICAgICB4ID0gY29udGV4dC5fbGFzdFBvaW50LnggKyBNYXRoLnNpbihhbmdsZSkgLSBjb250ZXh0LnNpemUgLyAyO1xuICAgICAgeSA9IGNvbnRleHQuX2xhc3RQb2ludC55ICsgTWF0aC5jb3MoYW5nbGUpIC0gY29udGV4dC5zaXplIC8gMjtcbiAgICAgIGNvbnRleHQuY2FudmFzLmNvbnRleHRUb3AuZHJhd0ltYWdlKGNvbnRleHQuYnJ1c2guX2VsZW1lbnQsIHgsIHksIGNvbnRleHQuc2l6ZSwgY29udGV4dC5zaXplKTtcblxuICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgaWYgKGNvbnRleHQuY2FudmFzLl9pc0N1cnJlbnRseURyYXdpbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmF3LCBjb250ZXh0Ll9pbnRlcnZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0Ll9yZXNldCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wb2ludCA9IG51bGw7XG4gICAgdGhpcy5fbGFzdFBvaW50ID0gbnVsbDtcbiAgfVxufSk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kcmF3VG9vbC9icnVzaGVzL2JydXNoZXMvc3ByYXlCcnVzaC5qc1xuICoqLyIsImltcG9ydCB7ZmFicmljfSBmcm9tICdmYWJyaWMnO1xuXG5mYWJyaWMuTWFya2VyQnJ1c2ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuQmFzZUJydXNoLCB7XG5cbiAgY29sb3I6IFwiIzAwMDAwMFwiLFxuICBvcGFjaXR5OiAxLFxuICB3aWR0aDogMzAsXG5cbiAgX2Jhc2VXaWR0aDogMTAsXG4gIF9sYXN0UG9pbnQ6IG51bGwsXG4gIF9saW5lV2lkdGg6IDMsXG4gIF9wb2ludDogbnVsbCxcbiAgX3NpemU6IDAsXG4gIG1vdmVkOiBmYWxzZSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihjYW52YXMsIG9wdCA9IHt9KSB7XG5cbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLndpZHRoID0gb3B0LndpZHRoIHx8IGNhbnZhcy5mcmVlRHJhd2luZ0JydXNoLndpZHRoO1xuICAgIHRoaXMuY29sb3IgPSBvcHQuY29sb3IgfHwgY2FudmFzLmZyZWVEcmF3aW5nQnJ1c2guY29sb3I7XG4gICAgdGhpcy5vcGFjaXR5ID0gb3B0Lm9wYWNpdHkgfHwgY2FudmFzLmNvbnRleHRUb3AuZ2xvYmFsQWxwaGE7XG4gICAgdGhpcy5fcG9pbnQgPSBuZXcgZmFicmljLlBvaW50KCk7XG5cbiAgICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmxpbmVKb2luID0gJ3JvdW5kJztcbiAgICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmxpbmVDYXAgPSAncm91bmQnO1xuICB9LFxuXG4gIGNoYW5nZUNvbG9yOiBmdW5jdGlvbihjb2xvcikge1xuICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgfSxcblxuICBjaGFuZ2VPcGFjaXR5OiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgdGhpcy5vcGFjaXR5ID0gdmFsdWU7XG4gICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5nbG9iYWxBbHBoYSA9IHZhbHVlO1xuICB9LFxuXG4gIF9yZW5kZXI6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB2YXIgY3R4LCBsaW5lV2lkdGhEaWZmLCBpLCBsZW47XG4gICAgdmFyIHZ0ID0gdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm07XG5cbiAgICBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuXG4gICAgY3R4LnNhdmUoKTtcblxuICAgIGN0eC50cmFuc2Zvcm0odnRbMF0sIHZ0WzFdLCB2dFsyXSwgdnRbM10sIHZ0WzRdLCB2dFs1XSk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5nbG9iYWxBbHBoYSA9IHRoaXMub3BhY2l0eTtcbiAgICBmb3IoaSA9IDAsIGxlbiA9ICh0aGlzLl9zaXplIC8gdGhpcy5fbGluZVdpZHRoKSAvIDI7IGkgPCBsZW47IGkrKykge1xuICAgICAgbGluZVdpZHRoRGlmZiA9ICh0aGlzLl9saW5lV2lkdGggLSAxKSAqIGk7XG5cbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuOCAqIHRoaXMub3BhY2l0eTtcbiAgICAgIGN0eC5tb3ZlVG8odGhpcy5fbGFzdFBvaW50LnggKyBsaW5lV2lkdGhEaWZmLCB0aGlzLl9sYXN0UG9pbnQueSArIGxpbmVXaWR0aERpZmYpO1xuICAgICAgY3R4LmxpbmVUbyhwb2ludGVyLnggKyBsaW5lV2lkdGhEaWZmLCBwb2ludGVyLnkgKyBsaW5lV2lkdGhEaWZmKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgdGhpcy5fbGFzdFBvaW50ID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSk7XG4gIH0sXG5cbiAgb25Nb3VzZURvd246IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB0aGlzLl9sYXN0UG9pbnQgPSBwb2ludGVyO1xuICAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3Auc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AubGluZVdpZHRoID0gdGhpcy5fbGluZVdpZHRoO1xuICAgIHRoaXMuX3NpemUgPSB0aGlzLndpZHRoICsgdGhpcy5fYmFzZVdpZHRoO1xuICAgIHRoaXMubW92ZWQgPSBmYWxzZTtcbiAgfSxcblxuICBvbk1vdXNlTW92ZTogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIGlmICh0aGlzLmNhbnZhcy5faXNDdXJyZW50bHlEcmF3aW5nKSB7XG4gICAgICB0aGlzLl9yZW5kZXIocG9pbnRlcik7XG4gICAgfVxuICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICB9LFxuXG4gIG9uTW91c2VVcDogZnVuY3Rpb24oKSB7fVxufSk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kcmF3VG9vbC9icnVzaGVzL2JydXNoZXMvbWFya2VyQnJ1c2guanNcbiAqKi8iLCJpbXBvcnQge2ZhYnJpY30gZnJvbSAnZmFicmljJztcblxuZmFicmljLkN1c3RvbUJydXNoID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLkJhc2VCcnVzaCwge1xuXG4gIGNvbG9yOiBcIiMwMDAwMDBcIixcbiAgb3BhY2l0eTogMSxcbiAgd2lkdGg6IDMwLFxuXG4gIF9iYXNlV2lkdGg6IDEwLFxuICBfbGFzdFBvaW50OiBudWxsLFxuICBfbGluZVdpZHRoOiAzLFxuICBfcG9pbnQ6IG51bGwsXG4gIF9zaXplOiAwLFxuICBzcHJheUJydXNoRGF0YVVybDogXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFRQUFBQUVDQVlBQUFDcDhaNStBQUFBRTBsRVFWUjQybU5nd0FGK0FmRVB2QUp3QUFCK3ZnUGxEc1FvR0FBQUFBQkpSVTVFcmtKZ2dnPT1cIixcbiAgbW92ZWQ6IGZhbHNlLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGNhbnZhcywgb3B0ID0ge30pIHtcblxuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMud2lkdGggPSBvcHQud2lkdGggfHwgY2FudmFzLmZyZWVEcmF3aW5nQnJ1c2gud2lkdGg7XG4gICAgdGhpcy5jb2xvciA9IG9wdC5jb2xvciB8fCBjYW52YXMuZnJlZURyYXdpbmdCcnVzaC5jb2xvcjtcbiAgICB0aGlzLm9wYWNpdHkgPSBvcHQub3BhY2l0eSB8fCBjYW52YXMuY29udGV4dFRvcC5nbG9iYWxBbHBoYTtcbiAgICB0aGlzLl9wb2ludCA9IG5ldyBmYWJyaWMuUG9pbnQoKTtcbiAgICB0aGlzLnNwcmF5QnJ1c2hEYXRhVXJsID0gb3B0LmltYWdlIHx8IHRoaXMuc3ByYXlCcnVzaERhdGFVcmw7XG5cbiAgICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmxpbmVKb2luID0gJ3JvdW5kJztcbiAgICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmxpbmVDYXAgPSAncm91bmQnO1xuXG4gICAgZmFicmljLkltYWdlLmZyb21VUkwodGhpcy5zcHJheUJydXNoRGF0YVVybCwgKGJydXNoKSA9PiB7XG4gICAgICB0aGlzLmJydXNoID0gYnJ1c2g7XG4gICAgICB0aGlzLmJydXNoLmZpbHRlcnMgPSBbXTtcbiAgICAgIHRoaXMuY2hhbmdlQ29sb3IodGhpcy5jb2xvcik7XG4gICAgfSwge2Nyb3NzT3JpZ2luOiBcImFub255bW91c1wifSk7XG4gIH0sXG5cbiAgY2hhbmdlQ29sb3I6IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLmJydXNoLmZpbHRlcnNbMF0gPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuVGludCh7Y29sb3I6IGNvbG9yfSk7XG4gICAgdGhpcy5icnVzaC5hcHBseUZpbHRlcnModGhpcy5jYW52YXMucmVuZGVyQWxsLmJpbmQodGhpcy5jYW52YXMpKTtcbiAgfSxcblxuICBjaGFuZ2VPcGFjaXR5OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLm9wYWNpdHkgPSB2YWx1ZTtcbiAgICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmdsb2JhbEFscGhhID0gdmFsdWU7XG4gIH0sXG5cblxuICBfcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3R4LCBsaW5lV2lkdGhEaWZmLCBpLCBsZW4sIHgsIHk7XG4gICAgdmFyIHZ0ID0gdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm07XG5cbiAgICBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuXG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgudHJhbnNmb3JtKHZ0WzBdLCB2dFsxXSwgdnRbMl0sIHZ0WzNdLCB2dFs0XSwgdnRbNV0pO1xuXG4gICAgdmFyIGRpc3QgPSB0aGlzLl9wb2ludC5kaXN0YW5jZUZyb20odGhpcy5fbGFzdFBvaW50KTtcbiAgICB2YXIgYW5nbGUgPSB0aGlzLl9wb2ludC5hbmdsZUJldHdlZW4odGhpcy5fbGFzdFBvaW50KTtcblxuICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMub3BhY2l0eTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzdDsgaSsrKSB7XG4gICAgICB4ID0gKHRoaXMuX2xhc3RQb2ludC54ICsgTWF0aC5zaW4oYW5nbGUpICogaSApIC0gdGhpcy5fc2l6ZSAvIDI7XG4gICAgICB5ID0gKHRoaXMuX2xhc3RQb2ludC55ICsgTWF0aC5jb3MoYW5nbGUpICogaSApLSB0aGlzLl9zaXplIC8gMjtcbiAgICAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZHJhd0ltYWdlKHRoaXMuYnJ1c2guX2VsZW1lbnQsIHgsIHksIHRoaXMuX3NpemUsIHRoaXMuX3NpemUpO1xuICAgIH1cblxuICAgIGN0eC5yZXN0b3JlKClcbiAgfSxcblxuICBvbk1vdXNlRG93bjogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHRoaXMuX3BvaW50ID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSk7XG4gICAgdGhpcy5fbGFzdFBvaW50ID0gdGhpcy5fcG9pbnQ7XG4gICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5saW5lV2lkdGggPSB0aGlzLl9saW5lV2lkdGg7XG4gICAgdGhpcy5fc2l6ZSA9IHRoaXMud2lkdGggKyB0aGlzLl9iYXNlV2lkdGg7XG4gICAgdGhpcy5tb3ZlZCA9IGZhbHNlO1xuICB9LFxuXG4gIG9uTW91c2VNb3ZlOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdGhpcy5fbGFzdFBvaW50ID0gdGhpcy5fcG9pbnQ7XG4gICAgdGhpcy5fcG9pbnQgPSBuZXcgZmFicmljLlBvaW50KHBvaW50ZXIueCwgcG9pbnRlci55KTtcbiAgICBpZiAodGhpcy5jYW52YXMuX2lzQ3VycmVudGx5RHJhd2luZykge1xuICAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgfVxuICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICB9LFxuXG4gIG9uTW91c2VVcDogZnVuY3Rpb24oKSB7fVxufSk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2RyYXdUb29sL2JydXNoZXMvYnJ1c2hlcy9jdXN0b21CcnVzaC5qc1xuICoqLyIsImltcG9ydCB7ZmFicmljfSBmcm9tICdmYWJyaWMnO1xuXG5sZXQgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZDtcbmxldCBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnM7XG5sZXQgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuZmlsdGVycy5SZW1vdmVDb2xvciA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgIHtcblxuICB0eXBlOiAnUmVtb3ZlQ29sb3InLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMuY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKG9wdGlvbnMuY29sb3IgfHwgJyNmZmZmZmYnKTtcbiAgICB0aGlzLmRpc3RhbmNlID0gb3B0aW9ucy5kaXN0YW5jZSA9PT0gdW5kZWZpbmVkID8gMSA6IE51bWJlcihvcHRpb25zLmRpc3RhbmNlKTtcblxuICB9LFxuXG4gIGFwcGx5VG86IGZ1bmN0aW9uKGNhbnZhc0VsKSB7XG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzRWwud2lkdGgsIGNhbnZhc0VsLmhlaWdodCksXG4gICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICBjb2xvciA9IHRoaXMuY29sb3IsXG4gICAgICB0aHJlc2hvbGQgPSA2MCxcbiAgICAgIGRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZSxcbiAgICAgIGxpbWl0ID0gMjU1IC0gdGhyZXNob2xkLFxuICAgICAgciwgZywgYjtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICByID0gZGF0YVtpXTtcbiAgICAgIGcgPSBkYXRhW2kgKyAxXTtcbiAgICAgIGIgPSBkYXRhW2kgKyAyXTtcblxuICAgICAgaWYoXG4gICAgICAgIE1hdGguYWJzKHIgLSBjb2xvci5fc291cmNlWzBdKSA8IGRpc3RhbmNlICYmXG4gICAgICAgIE1hdGguYWJzKGcgLSBjb2xvci5fc291cmNlWzFdKSA8IGRpc3RhbmNlICYmXG4gICAgICAgIE1hdGguYWJzKGIgLSBjb2xvci5fc291cmNlWzJdKSA8IGRpc3RhbmNlXG4gICAgICApe1xuICAgICAgICBkYXRhW2kgKyAzXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gIH0sXG5cbiAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JyksIHtcbiAgICAgIGNvbG9yOiB0aGlzLmNvbG9yXG4gICAgfSk7XG4gIH1cbn0pO1xuXG5mYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVDb2xvci5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHJldHVybiBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlQ29sb3Iob2JqZWN0KTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZHJhd1Rvb2wvdXRpbHMvcmVtb3ZlQ29sb3IuanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZShcImNvcmUtanMvc2hpbVwiKTtcblxucmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZVwiKTtcblxucmVxdWlyZShcImNvcmUtanMvZm4vcmVnZXhwL2VzY2FwZVwiKTtcblxuaWYgKGdsb2JhbC5fYmFiZWxQb2x5ZmlsbCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IG9uZSBpbnN0YW5jZSBvZiBiYWJlbC1wb2x5ZmlsbCBpcyBhbGxvd2VkXCIpO1xufVxuZ2xvYmFsLl9iYWJlbFBvbHlmaWxsID0gdHJ1ZTtcblxudmFyIERFRklORV9QUk9QRVJUWSA9IFwiZGVmaW5lUHJvcGVydHlcIjtcbmZ1bmN0aW9uIGRlZmluZShPLCBrZXksIHZhbHVlKSB7XG4gIE9ba2V5XSB8fCBPYmplY3RbREVGSU5FX1BST1BFUlRZXShPLCBrZXksIHtcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH0pO1xufVxuXG5kZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgXCJwYWRMZWZ0XCIsIFwiXCIucGFkU3RhcnQpO1xuZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIFwicGFkUmlnaHRcIiwgXCJcIi5wYWRFbmQpO1xuXG5cInBvcCxyZXZlcnNlLHNoaWZ0LGtleXMsdmFsdWVzLGVudHJpZXMsaW5kZXhPZixldmVyeSxzb21lLGZvckVhY2gsbWFwLGZpbHRlcixmaW5kLGZpbmRJbmRleCxpbmNsdWRlcyxqb2luLHNsaWNlLGNvbmNhdCxwdXNoLHNwbGljZSx1bnNoaWZ0LHNvcnQsbGFzdEluZGV4T2YscmVkdWNlLHJlZHVjZVJpZ2h0LGNvcHlXaXRoaW4sZmlsbFwiLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgW11ba2V5XSAmJiBkZWZpbmUoQXJyYXksIGtleSwgRnVuY3Rpb24uY2FsbC5iaW5kKFtdW2tleV0pKTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9iYWJlbC1wb2x5ZmlsbC9saWIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA2N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnNlYWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5iaW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnBhcnNlLWludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hY29zaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmFzaW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYXRhbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jYnJ0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY2x6MzInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jb3NoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguZXhwbTEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5mcm91bmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5oeXBvdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmltdWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cxMCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnNpZ24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5zaW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgudGFuaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnRydW5jJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnJhdycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYmlnJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5ibGluaycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYm9sZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZml4ZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udHNpemUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLml0YWxpY3MnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmxpbmsnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnNtYWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdHJpa2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN1YicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3VwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUubm93Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tanNvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1wcmltaXRpdmUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaXMtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5qb2luJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNvcnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkubWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zb21lJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UtcmlnaHQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkubGFzdC1pbmRleC1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3RvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LndlYWstbWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LndlYWstc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5kYXRhLXZpZXcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDE2LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQxNi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZmxvYXQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuYXBwbHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5kZWxldGUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuaGFzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuaXMtZXh0ZW5zaWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcuYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1sZWZ0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy50cmltLXJpZ2h0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5tYXRjaC1hbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmVudHJpZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1nZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1zZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1zZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWFwLnRvLWpzb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc2V0LnRvLWpzb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5lcnJvci5pcy1lcnJvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmlhZGRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaXN1YmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pbXVsaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnVtdWxoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVsZXRlLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLWtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS1rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW93bi1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lm1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFzYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JzZXJ2YWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi50aW1lcnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIuaW1tZWRpYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21vZHVsZXMvX2NvcmUnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9zaGltLmpzXG4gKiogbW9kdWxlIGlkID0gNjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIERFU0NSSVBUT1JTICAgID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBNRVRBICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVlcbiAgLCAkZmFpbHMgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBzaGFyZWQgICAgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgdWlkICAgICAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIHdrcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJylcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxuICAsIHdrc0RlZmluZSAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpXG4gICwga2V5T2YgICAgICAgICAgPSByZXF1aXJlKCcuL19rZXlvZicpXG4gICwgZW51bUtleXMgICAgICAgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKVxuICAsIGlzQXJyYXkgICAgICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIF9jcmVhdGUgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZ09QTkV4dCAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKVxuICAsICRHT1BEICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsICREUCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCAka2V5cyAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BEICAgICAgICAgICA9ICRHT1BELmZcbiAgLCBkUCAgICAgICAgICAgICA9ICREUC5mXG4gICwgZ09QTiAgICAgICAgICAgPSBnT1BORXh0LmZcbiAgLCAkU3ltYm9sICAgICAgICA9IGdsb2JhbC5TeW1ib2xcbiAgLCAkSlNPTiAgICAgICAgICA9IGdsb2JhbC5KU09OXG4gICwgX3N0cmluZ2lmeSAgICAgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnlcbiAgLCBQUk9UT1RZUEUgICAgICA9ICdwcm90b3R5cGUnXG4gICwgSElEREVOICAgICAgICAgPSB3a3MoJ19oaWRkZW4nKVxuICAsIFRPX1BSSU1JVElWRSAgID0gd2tzKCd0b1ByaW1pdGl2ZScpXG4gICwgaXNFbnVtICAgICAgICAgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZVxuICAsIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKVxuICAsIEFsbFN5bWJvbHMgICAgID0gc2hhcmVkKCdzeW1ib2xzJylcbiAgLCBPUFN5bWJvbHMgICAgICA9IHNoYXJlZCgnb3Atc3ltYm9scycpXG4gICwgT2JqZWN0UHJvdG8gICAgPSBPYmplY3RbUFJPVE9UWVBFXVxuICAsIFVTRV9OQVRJVkUgICAgID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJ1xuICAsIFFPYmplY3QgICAgICAgID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBkUCh0aGlzLCAnYScsIHt2YWx1ZTogN30pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24oaXQsIGtleSwgRCl7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZihwcm90b0Rlc2MpZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZihwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKWRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24odGFnKXtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCl7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90bykkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZihoYXMoQWxsU3ltYm9scywga2V5KSl7XG4gICAgaWYoIUQuZW51bWVyYWJsZSl7XG4gICAgICBpZighaGFzKGl0LCBISURERU4pKWRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0paXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7ZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSl9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKXtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpXG4gICAgLCBpICAgID0gMFxuICAgICwgbCA9IGtleXMubGVuZ3RoXG4gICAgLCBrZXk7XG4gIHdoaWxlKGwgPiBpKSRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApe1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSl7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKXJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuICBpdCAgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZihpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSlELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgdmFyIG5hbWVzICA9IGdPUE4odG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xuICAgIGlmKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSlyZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpe1xuICB2YXIgSVNfT1AgID0gaXQgPT09IE9iamVjdFByb3RvXG4gICAgLCBuYW1lcyAgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xuICAgIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSlyZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmKCFVU0VfTkFUSVZFKXtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpe1xuICAgIGlmKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKXRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24odmFsdWUpe1xuICAgICAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8pJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSl0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmKERFU0NSSVBUT1JTICYmIHNldHRlcilzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHtjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mICAgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiAgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJykuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSl7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uKG5hbWUpe1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH1cbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1N5bWJvbDogJFN5bWJvbH0pO1xuXG5mb3IodmFyIHN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaSA9IDA7IHN5bWJvbHMubGVuZ3RoID4gaTsgKXdrcyhzeW1ib2xzW2krK10pO1xuXG5mb3IodmFyIHN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzRGVmaW5lKHN5bWJvbHNbaSsrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24oa2V5KXtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKGtleSl7XG4gICAgaWYoaXNTeW1ib2woa2V5KSlyZXR1cm4ga2V5T2YoU3ltYm9sUmVnaXN0cnksIGtleSk7XG4gICAgdGhyb3cgVHlwZUVycm9yKGtleSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uKCl7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24oKXsgc2V0dGVyID0gZmFsc2U7IH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoe2E6IFN9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpe1xuICAgIGlmKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKXJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIHZhciBhcmdzID0gW2l0XVxuICAgICAgLCBpICAgID0gMVxuICAgICAgLCByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmKHR5cGVvZiByZXBsYWNlciA9PSAnZnVuY3Rpb24nKSRyZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgIGlmKCRyZXBsYWNlciB8fCAhaXNBcnJheShyZXBsYWNlcikpcmVwbGFjZXIgPSBmdW5jdGlvbihrZXksIHZhbHVlKXtcbiAgICAgIGlmKCRyZXBsYWNlcil2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYoIWlzU3ltYm9sKHZhbHVlKSlyZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qc1xuICoqIG1vZHVsZSBpZCA9IDY5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzXG4gKiogbW9kdWxlIGlkID0gNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX2hhcy5qc1xuICoqIG1vZHVsZSBpZCA9IDcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qc1xuICoqIG1vZHVsZSBpZCA9IDcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19mYWlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDczXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCByZWRlZmluZSAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIHx8IChnbG9iYWxbbmFtZV0gPSB7fSkgOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgZXhwUHJvdG8gID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSlcbiAgICAsIGtleSwgb3duLCBvdXQsIGV4cDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIGV4cCA9IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICBpZih0YXJnZXQpcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7XG4gICAgLy8gZXhwb3J0XG4gICAgaWYoZXhwb3J0c1trZXldICE9IG91dCloaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZihJU19QUk9UTyAmJiBleHBQcm90b1trZXldICE9IG91dClleHBQcm90b1trZXldID0gb3V0O1xuICB9XG59O1xuZ2xvYmFsLmNvcmUgPSBjb3JlO1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YCBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanNcbiAqKiBtb2R1bGUgaWQgPSA3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi40LjAnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanNcbiAqKiBtb2R1bGUgaWQgPSA3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGRQICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanNcbiAqKiBtb2R1bGUgaWQgPSA3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZFAgICAgICAgICAgICAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcyl0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZigndmFsdWUnIGluIEF0dHJpYnV0ZXMpT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanNcbiAqKiBtb2R1bGUgaWQgPSA3N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoIWlzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSA3OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDgwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnRcbiAgLy8gaW4gb2xkIElFIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnXG4gICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBTKXtcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZihTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanNcbiAqKiBtb2R1bGUgaWQgPSA4MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanNcbiAqKiBtb2R1bGUgaWQgPSA4M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgaGFzICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBTUkMgICAgICAgPSByZXF1aXJlKCcuL191aWQnKSgnc3JjJylcbiAgLCBUT19TVFJJTkcgPSAndG9TdHJpbmcnXG4gICwgJHRvU3RyaW5nID0gRnVuY3Rpb25bVE9fU1RSSU5HXVxuICAsIFRQTCAgICAgICA9ICgnJyArICR0b1N0cmluZykuc3BsaXQoVE9fU1RSSU5HKTtcblxucmVxdWlyZSgnLi9fY29yZScpLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihPLCBrZXksIHZhbCwgc2FmZSl7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nO1xuICBpZihpc0Z1bmN0aW9uKWhhcyh2YWwsICduYW1lJykgfHwgaGlkZSh2YWwsICduYW1lJywga2V5KTtcbiAgaWYoT1trZXldID09PSB2YWwpcmV0dXJuO1xuICBpZihpc0Z1bmN0aW9uKWhhcyh2YWwsIFNSQykgfHwgaGlkZSh2YWwsIFNSQywgT1trZXldID8gJycgKyBPW2tleV0gOiBUUEwuam9pbihTdHJpbmcoa2V5KSkpO1xuICBpZihPID09PSBnbG9iYWwpe1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBpZighc2FmZSl7XG4gICAgICBkZWxldGUgT1trZXldO1xuICAgICAgaGlkZShPLCBrZXksIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKE9ba2V5XSlPW2tleV0gPSB2YWw7XG4gICAgICBlbHNlIGhpZGUoTywga2V5LCB2YWwpO1xuICAgIH1cbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgdGhpc1tTUkNdIHx8ICR0b1N0cmluZy5jYWxsKHRoaXMpO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlkID0gMFxuICAsIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzXG4gKiogbW9kdWxlIGlkID0gODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCl7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XG4gIHN3aXRjaChsZW5ndGgpe1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fY3R4LmpzXG4gKiogbW9kdWxlIGlkID0gODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZih0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSA4N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIE1FVEEgICAgID0gcmVxdWlyZSgnLi9fdWlkJykoJ21ldGEnKVxuICAsIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBoYXMgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgc2V0RGVzYyAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgaWQgICAgICAgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZSRUVaRSA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24oaXQpe1xuICBzZXREZXNjKGl0LCBNRVRBLCB7dmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9fSk7XG59O1xudmFyIGZhc3RLZXkgPSBmdW5jdGlvbihpdCwgY3JlYXRlKXtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZighaXNPYmplY3QoaXQpKXJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmKCFoYXMoaXQsIE1FVEEpKXtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmKCFpc0V4dGVuc2libGUoaXQpKXJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZighY3JlYXRlKXJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG4gIGlmKCFoYXMoaXQsIE1FVEEpKXtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmKCFpc0V4dGVuc2libGUoaXQpKXJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIGhhc2ggd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQV0udztcbn07XG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKXNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiAgICAgIE1FVEEsXG4gIE5FRUQ6ICAgICBmYWxzZSxcbiAgZmFzdEtleTogIGZhc3RLZXksXG4gIGdldFdlYWs6ICBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fbWV0YS5qc1xuICoqIG1vZHVsZSBpZCA9IDg4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJ1xuICAsIHN0b3JlICA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qc1xuICoqIG1vZHVsZSBpZCA9IDg5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIHRhZywgc3RhdCl7XG4gIGlmKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpZGVmKGl0LCBUQUcsIHtjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWd9KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanNcbiAqKiBtb2R1bGUgaWQgPSA5MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHN0b3JlICAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJylcbiAgLCB1aWQgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCBTeW1ib2wgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sXG4gICwgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzXG4gKiogbW9kdWxlIGlkID0gOTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX3drcy1leHQuanNcbiAqKiBtb2R1bGUgaWQgPSA5MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgd2tzRXh0ICAgICAgICAgPSByZXF1aXJlKCcuL193a3MtZXh0JylcbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pO1xuICBpZihuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKWRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHt2YWx1ZTogd2tzRXh0LmYobmFtZSl9KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX2xpYnJhcnkuanNcbiAqKiBtb2R1bGUgaWQgPSA5NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdldEtleXMgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgZWwpe1xuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAsIGtleXMgICA9IGdldEtleXMoTylcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKGxlbmd0aCA+IGluZGV4KWlmKE9ba2V5ID0ga2V5c1tpbmRleCsrXV0gPT09IGVsKXJldHVybiBrZXk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX2tleW9mLmpzXG4gKiogbW9kdWxlIGlkID0gOTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gOTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBoYXMgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHRvSU9iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpXG4gICwgSUVfUFJPVE8gICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZXMpe1xuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBrZXk7XG4gIGZvcihrZXkgaW4gTylpZihrZXkgIT0gSUVfUFJPVE8paGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSl7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1xuICoqIG1vZHVsZSBpZCA9IDk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSA5OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9faW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDk5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX2NvZi5qc1xuICoqIG1vZHVsZSBpZCA9IDEwMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCB0b0luZGV4ICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCgkdGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG4gICAgICAsIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTyl7XG4gICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDEwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzXG4gKiogbW9kdWxlIGlkID0gMTAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsICA9IE1hdGguY2VpbFxuICAsIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1heCAgICAgICA9IE1hdGgubWF4XG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpe1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL190by1pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJylcbiAgLCB1aWQgICAgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLWtleS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSAoXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG4pLnNwbGl0KCcsJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qc1xuICoqIG1vZHVsZSBpZCA9IDEwN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUFMgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpXG4gICwgcElFICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgcmVzdWx0ICAgICA9IGdldEtleXMoaXQpXG4gICAgLCBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICBpZihnZXRTeW1ib2xzKXtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpXG4gICAgICAsIGlzRW51bSAgPSBwSUUuZlxuICAgICAgLCBpICAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUoc3ltYm9scy5sZW5ndGggPiBpKWlmKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fZW51bS1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMTA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BzLmpzXG4gKiogbW9kdWxlIGlkID0gMTA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzXG4gKiogbW9kdWxlIGlkID0gMTEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKXtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gMTExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZFBzICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJylcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKVxuICAsIElFX1BST1RPICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpXG4gICwgRW1wdHkgICAgICAgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9XG4gICwgUFJPVE9UWVBFICAgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbigpe1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKVxuICAgICwgaSAgICAgID0gZW51bUJ1Z0tleXMubGVuZ3RoXG4gICAgLCBsdCAgICAgPSAnPCdcbiAgICAsIGd0ICAgICA9ICc+J1xuICAgICwgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUoaS0tKWRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKXtcbiAgdmFyIHJlc3VsdDtcbiAgaWYoTyAhPT0gbnVsbCl7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZFAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzICAgPSBnZXRLZXlzKFByb3BlcnRpZXMpXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaSA9IDBcbiAgICAsIFA7XG4gIHdoaWxlKGxlbmd0aCA+IGkpZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcHMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBnT1BOICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCB0b1N0cmluZyAgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uKGl0KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanNcbiAqKiBtb2R1bGUgaWQgPSAxMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBwSUUgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIGdPUEQgICAgICAgICAgID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCl7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZihoYXMoTywgUCkpcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qc1xuICoqIG1vZHVsZSBpZCA9IDExN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtjcmVhdGU6IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHtkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuMyAvIDE1LjIuMy43IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0Jywge2RlZmluZVByb3BlcnRpZXM6IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxudmFyIHRvSU9iamVjdCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcicsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JT2JqZWN0KGl0KSwga2V5KTtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNvcmUgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBleGVjKXtcbiAgdmFyIGZuICA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXVxuICAgICwgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24oKXsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXNhcC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjkgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgdG9PYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCAkZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0UHJvdG90eXBlT2YnLCBmdW5jdGlvbigpe1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpe1xuICAgIHJldHVybiAkZ2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gMTIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCB0b09iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcbiAgLCBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKE8pe1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmKGhhcyhPLCBJRV9QUk9UTykpcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZih0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKXtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1ncG8uanNcbiAqKiBtb2R1bGUgaWQgPSAxMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCAka2V5cyAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgna2V5cycsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiBmdW5jdGlvbiBrZXlzKGl0KXtcbiAgICByZXR1cm4gJGtleXModG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMTI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eU5hbWVzJywgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpLmY7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qc1xuICoqIG1vZHVsZSBpZCA9IDEyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjUgT2JqZWN0LmZyZWV6ZShPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBtZXRhICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdmcmVlemUnLCBmdW5jdGlvbigkZnJlZXplKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZyZWV6ZShpdCl7XG4gICAgcmV0dXJuICRmcmVlemUgJiYgaXNPYmplY3QoaXQpID8gJGZyZWV6ZShtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi4xNyBPYmplY3Quc2VhbChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBtZXRhICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdzZWFsJywgZnVuY3Rpb24oJHNlYWwpe1xuICByZXR1cm4gZnVuY3Rpb24gc2VhbChpdCl7XG4gICAgcmV0dXJuICRzZWFsICYmIGlzT2JqZWN0KGl0KSA/ICRzZWFsKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNlYWwuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi4xNSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgbWV0YSAgICAgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgncHJldmVudEV4dGVuc2lvbnMnLCBmdW5jdGlvbigkcHJldmVudEV4dGVuc2lvbnMpe1xuICByZXR1cm4gZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnMoaXQpe1xuICAgIHJldHVybiAkcHJldmVudEV4dGVuc2lvbnMgJiYgaXNPYmplY3QoaXQpID8gJHByZXZlbnRFeHRlbnNpb25zKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjEyIE9iamVjdC5pc0Zyb3plbihPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNGcm96ZW4nLCBmdW5jdGlvbigkaXNGcm96ZW4pe1xuICByZXR1cm4gZnVuY3Rpb24gaXNGcm96ZW4oaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNGcm96ZW4gPyAkaXNGcm96ZW4oaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWZyb3plbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjEzIE9iamVjdC5pc1NlYWxlZChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNTZWFsZWQnLCBmdW5jdGlvbigkaXNTZWFsZWQpe1xuICByZXR1cm4gZnVuY3Rpb24gaXNTZWFsZWQoaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNTZWFsZWQgPyAkaXNTZWFsZWQoaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLXNlYWxlZC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjExIE9iamVjdC5pc0V4dGVuc2libGUoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzRXh0ZW5zaWJsZScsIGZ1bmN0aW9uKCRpc0V4dGVuc2libGUpe1xuICByZXR1cm4gZnVuY3Rpb24gaXNFeHRlbnNpYmxlKGl0KXtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUoaXQpIDogdHJ1ZSA6IGZhbHNlO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHthc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanNcbiAqKiBtb2R1bGUgaWQgPSAxMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsICRhc3NpZ24gID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgdmFyIEEgPSB7fVxuICAgICwgQiA9IHt9XG4gICAgLCBTID0gU3ltYm9sKClcbiAgICAsIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbihrKXsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCAgICAgPSB0b09iamVjdCh0YXJnZXQpXG4gICAgLCBhTGVuICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGluZGV4ID0gMVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZlxuICAgICwgaXNFbnVtICAgICA9IHBJRS5mO1xuICB3aGlsZShhTGVuID4gaW5kZXgpe1xuICAgIHZhciBTICAgICAgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSlcbiAgICAgICwga2V5cyAgID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBqICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShsZW5ndGggPiBqKWlmKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4zLjEwIE9iamVjdC5pcyh2YWx1ZTEsIHZhbHVlMilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtpczogcmVxdWlyZSgnLi9fc2FtZS12YWx1ZScpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLmpzXG4gKiogbW9kdWxlIGlkID0gMTM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjIuOSBTYW1lVmFsdWUoeCwgeSlcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmlzIHx8IGZ1bmN0aW9uIGlzKHgsIHkpe1xuICByZXR1cm4geCA9PT0geSA/IHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5IDogeCAhPSB4ICYmIHkgIT0geTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fc2FtZS12YWx1ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0fSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uKE8sIHByb3RvKXtcbiAgYW5PYmplY3QoTyk7XG4gIGlmKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24odGVzdCwgYnVnZ3ksIHNldCl7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaChlKXsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pe1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmKGJ1Z2d5KU8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19zZXQtcHJvdG8uanNcbiAqKiBtb2R1bGUgaWQgPSAxMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCB0ZXN0ICAgID0ge307XG50ZXN0W3JlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpXSA9ICd6JztcbmlmKHRlc3QgKyAnJyAhPSAnW29iamVjdCB6XScpe1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgcmV0dXJuICdbb2JqZWN0ICcgKyBjbGFzc29mKHRoaXMpICsgJ10nO1xuICB9LCB0cnVlKTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzXG4gKiogbW9kdWxlIGlkID0gMTQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJylcbiAgLy8gRVMzIHdyb25nIGhlcmVcbiAgLCBBUkcgPSBjb2YoZnVuY3Rpb24oKXsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjIuMy4yIC8gMTUuMy40LjUgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQodGhpc0FyZywgYXJncy4uLilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnRnVuY3Rpb24nLCB7YmluZDogcmVxdWlyZSgnLi9fYmluZCcpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZC5qc1xuICoqIG1vZHVsZSBpZCA9IDE0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFGdW5jdGlvbiAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBpc09iamVjdCAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBpbnZva2UgICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBhcnJheVNsaWNlID0gW10uc2xpY2VcbiAgLCBmYWN0b3JpZXMgID0ge307XG5cbnZhciBjb25zdHJ1Y3QgPSBmdW5jdGlvbihGLCBsZW4sIGFyZ3Mpe1xuICBpZighKGxlbiBpbiBmYWN0b3JpZXMpKXtcbiAgICBmb3IodmFyIG4gPSBbXSwgaSA9IDA7IGkgPCBsZW47IGkrKyluW2ldID0gJ2FbJyArIGkgKyAnXSc7XG4gICAgZmFjdG9yaWVzW2xlbl0gPSBGdW5jdGlvbignRixhJywgJ3JldHVybiBuZXcgRignICsgbi5qb2luKCcsJykgKyAnKScpO1xuICB9IHJldHVybiBmYWN0b3JpZXNbbGVuXShGLCBhcmdzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uYmluZCB8fCBmdW5jdGlvbiBiaW5kKHRoYXQgLyosIGFyZ3MuLi4gKi8pe1xuICB2YXIgZm4gICAgICAgPSBhRnVuY3Rpb24odGhpcylcbiAgICAsIHBhcnRBcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBib3VuZCA9IGZ1bmN0aW9uKC8qIGFyZ3MuLi4gKi8pe1xuICAgIHZhciBhcmdzID0gcGFydEFyZ3MuY29uY2F0KGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGJvdW5kID8gY29uc3RydWN0KGZuLCBhcmdzLmxlbmd0aCwgYXJncykgOiBpbnZva2UoZm4sIGFyZ3MsIHRoYXQpO1xuICB9O1xuICBpZihpc09iamVjdChmbi5wcm90b3R5cGUpKWJvdW5kLnByb3RvdHlwZSA9IGZuLnByb3RvdHlwZTtcbiAgcmV0dXJuIGJvdW5kO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19iaW5kLmpzXG4gKiogbW9kdWxlIGlkID0gMTQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIGFyZ3MsIHRoYXQpe1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG4gIHN3aXRjaChhcmdzLmxlbmd0aCl7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9faW52b2tlLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgaGFzICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgRlByb3RvICAgICA9IEZ1bmN0aW9uLnByb3RvdHlwZVxuICAsIG5hbWVSRSAgICAgPSAvXlxccypmdW5jdGlvbiAoW14gKF0qKS9cbiAgLCBOQU1FICAgICAgID0gJ25hbWUnO1xuXG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbigpe1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIDE5LjIuNC4yIG5hbWVcbk5BTUUgaW4gRlByb3RvIHx8IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgZFAoRlByb3RvLCBOQU1FLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpe1xuICAgIHRyeSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgICAgLCBuYW1lID0gKCcnICsgdGhhdCkubWF0Y2gobmFtZVJFKVsxXTtcbiAgICAgIGhhcyh0aGF0LCBOQU1FKSB8fCAhaXNFeHRlbnNpYmxlKHRoYXQpIHx8IGRQKHRoYXQsIE5BTUUsIGNyZWF0ZURlc2MoNSwgbmFtZSkpO1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBIQVNfSU5TVEFOQ0UgICA9IHJlcXVpcmUoJy4vX3drcycpKCdoYXNJbnN0YW5jZScpXG4gICwgRnVuY3Rpb25Qcm90byAgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4vLyAxOS4yLjMuNiBGdW5jdGlvbi5wcm90b3R5cGVbQEBoYXNJbnN0YW5jZV0oVilcbmlmKCEoSEFTX0lOU1RBTkNFIGluIEZ1bmN0aW9uUHJvdG8pKXJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYoRnVuY3Rpb25Qcm90bywgSEFTX0lOU1RBTkNFLCB7dmFsdWU6IGZ1bmN0aW9uKE8pe1xuICBpZih0eXBlb2YgdGhpcyAhPSAnZnVuY3Rpb24nIHx8ICFpc09iamVjdChPKSlyZXR1cm4gZmFsc2U7XG4gIGlmKCFpc09iamVjdCh0aGlzLnByb3RvdHlwZSkpcmV0dXJuIE8gaW5zdGFuY2VvZiB0aGlzO1xuICAvLyBmb3IgZW52aXJvbm1lbnQgdy9vIG5hdGl2ZSBgQEBoYXNJbnN0YW5jZWAgbG9naWMgZW5vdWdoIGBpbnN0YW5jZW9mYCwgYnV0IGFkZCB0aGlzOlxuICB3aGlsZShPID0gZ2V0UHJvdG90eXBlT2YoTykpaWYodGhpcy5wcm90b3R5cGUgPT09IE8pcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn19KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5oYXMtaW5zdGFuY2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX3BhcnNlLWludCcpO1xuLy8gMTguMi41IHBhcnNlSW50KHN0cmluZywgcmFkaXgpXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuRiAqIChwYXJzZUludCAhPSAkcGFyc2VJbnQpLCB7cGFyc2VJbnQ6ICRwYXJzZUludH0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWludC5qc1xuICoqIG1vZHVsZSBpZCA9IDE0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnBhcnNlSW50XG4gICwgJHRyaW0gICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltXG4gICwgd3MgICAgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXdzJylcbiAgLCBoZXggICAgICAgPSAvXltcXC0rXT8wW3hYXS87XG5cbm1vZHVsZS5leHBvcnRzID0gJHBhcnNlSW50KHdzICsgJzA4JykgIT09IDggfHwgJHBhcnNlSW50KHdzICsgJzB4MTYnKSAhPT0gMjIgPyBmdW5jdGlvbiBwYXJzZUludChzdHIsIHJhZGl4KXtcbiAgdmFyIHN0cmluZyA9ICR0cmltKFN0cmluZyhzdHIpLCAzKTtcbiAgcmV0dXJuICRwYXJzZUludChzdHJpbmcsIChyYWRpeCA+Pj4gMCkgfHwgKGhleC50ZXN0KHN0cmluZykgPyAxNiA6IDEwKSk7XG59IDogJHBhcnNlSW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWludC5qc1xuICoqIG1vZHVsZSBpZCA9IDE0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIHNwYWNlcyAgPSByZXF1aXJlKCcuL19zdHJpbmctd3MnKVxuICAsIHNwYWNlICAgPSAnWycgKyBzcGFjZXMgKyAnXSdcbiAgLCBub24gICAgID0gJ1xcdTIwMGJcXHUwMDg1J1xuICAsIGx0cmltICAgPSBSZWdFeHAoJ14nICsgc3BhY2UgKyBzcGFjZSArICcqJylcbiAgLCBydHJpbSAgID0gUmVnRXhwKHNwYWNlICsgc3BhY2UgKyAnKiQnKTtcblxudmFyIGV4cG9ydGVyID0gZnVuY3Rpb24oS0VZLCBleGVjLCBBTElBUyl7XG4gIHZhciBleHAgICA9IHt9O1xuICB2YXIgRk9SQ0UgPSBmYWlscyhmdW5jdGlvbigpe1xuICAgIHJldHVybiAhIXNwYWNlc1tLRVldKCkgfHwgbm9uW0tFWV0oKSAhPSBub247XG4gIH0pO1xuICB2YXIgZm4gPSBleHBbS0VZXSA9IEZPUkNFID8gZXhlYyh0cmltKSA6IHNwYWNlc1tLRVldO1xuICBpZihBTElBUylleHBbQUxJQVNdID0gZm47XG4gICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0UsICdTdHJpbmcnLCBleHApO1xufTtcblxuLy8gMSAtPiBTdHJpbmcjdHJpbUxlZnRcbi8vIDIgLT4gU3RyaW5nI3RyaW1SaWdodFxuLy8gMyAtPiBTdHJpbmcjdHJpbVxudmFyIHRyaW0gPSBleHBvcnRlci50cmltID0gZnVuY3Rpb24oc3RyaW5nLCBUWVBFKXtcbiAgc3RyaW5nID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSk7XG4gIGlmKFRZUEUgJiAxKXN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGx0cmltLCAnJyk7XG4gIGlmKFRZUEUgJiAyKXN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJ0cmltLCAnJyk7XG4gIHJldHVybiBzdHJpbmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydGVyO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy10cmltLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9ICdcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwMycgK1xuICAnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXdzLmpzXG4gKiogbW9kdWxlIGlkID0gMTUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fcGFyc2UtZmxvYXQnKTtcbi8vIDE4LjIuNCBwYXJzZUZsb2F0KHN0cmluZylcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5GICogKHBhcnNlRmxvYXQgIT0gJHBhcnNlRmxvYXQpLCB7cGFyc2VGbG9hdDogJHBhcnNlRmxvYXR9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucGFyc2VGbG9hdFxuICAsICR0cmltICAgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltO1xuXG5tb2R1bGUuZXhwb3J0cyA9IDEgLyAkcGFyc2VGbG9hdChyZXF1aXJlKCcuL19zdHJpbmctd3MnKSArICctMCcpICE9PSAtSW5maW5pdHkgPyBmdW5jdGlvbiBwYXJzZUZsb2F0KHN0cil7XG4gIHZhciBzdHJpbmcgPSAkdHJpbShTdHJpbmcoc3RyKSwgMylcbiAgICAsIHJlc3VsdCA9ICRwYXJzZUZsb2F0KHN0cmluZyk7XG4gIHJldHVybiByZXN1bHQgPT09IDAgJiYgc3RyaW5nLmNoYXJBdCgwKSA9PSAnLScgPyAtMCA6IHJlc3VsdDtcbn0gOiAkcGFyc2VGbG9hdDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19wYXJzZS1mbG9hdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoYXMgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgY29mICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jb2YnKVxuICAsIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpXG4gICwgdG9QcmltaXRpdmUgICAgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGZhaWxzICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGdPUE4gICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgZ09QRCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmZcbiAgLCBkUCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCAkdHJpbSAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbVxuICAsIE5VTUJFUiAgICAgICAgICAgID0gJ051bWJlcidcbiAgLCAkTnVtYmVyICAgICAgICAgICA9IGdsb2JhbFtOVU1CRVJdXG4gICwgQmFzZSAgICAgICAgICAgICAgPSAkTnVtYmVyXG4gICwgcHJvdG8gICAgICAgICAgICAgPSAkTnVtYmVyLnByb3RvdHlwZVxuICAvLyBPcGVyYSB+MTIgaGFzIGJyb2tlbiBPYmplY3QjdG9TdHJpbmdcbiAgLCBCUk9LRU5fQ09GICAgICAgICA9IGNvZihyZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJykocHJvdG8pKSA9PSBOVU1CRVJcbiAgLCBUUklNICAgICAgICAgICAgICA9ICd0cmltJyBpbiBTdHJpbmcucHJvdG90eXBlO1xuXG4vLyA3LjEuMyBUb051bWJlcihhcmd1bWVudClcbnZhciB0b051bWJlciA9IGZ1bmN0aW9uKGFyZ3VtZW50KXtcbiAgdmFyIGl0ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsIGZhbHNlKTtcbiAgaWYodHlwZW9mIGl0ID09ICdzdHJpbmcnICYmIGl0Lmxlbmd0aCA+IDIpe1xuICAgIGl0ID0gVFJJTSA/IGl0LnRyaW0oKSA6ICR0cmltKGl0LCAzKTtcbiAgICB2YXIgZmlyc3QgPSBpdC5jaGFyQ29kZUF0KDApXG4gICAgICAsIHRoaXJkLCByYWRpeCwgbWF4Q29kZTtcbiAgICBpZihmaXJzdCA9PT0gNDMgfHwgZmlyc3QgPT09IDQ1KXtcbiAgICAgIHRoaXJkID0gaXQuY2hhckNvZGVBdCgyKTtcbiAgICAgIGlmKHRoaXJkID09PSA4OCB8fCB0aGlyZCA9PT0gMTIwKXJldHVybiBOYU47IC8vIE51bWJlcignKzB4MScpIHNob3VsZCBiZSBOYU4sIG9sZCBWOCBmaXhcbiAgICB9IGVsc2UgaWYoZmlyc3QgPT09IDQ4KXtcbiAgICAgIHN3aXRjaChpdC5jaGFyQ29kZUF0KDEpKXtcbiAgICAgICAgY2FzZSA2NiA6IGNhc2UgOTggIDogcmFkaXggPSAyOyBtYXhDb2RlID0gNDk7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIC9eMGJbMDFdKyQvaVxuICAgICAgICBjYXNlIDc5IDogY2FzZSAxMTEgOiByYWRpeCA9IDg7IG1heENvZGUgPSA1NTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wb1swLTddKyQvaVxuICAgICAgICBkZWZhdWx0IDogcmV0dXJuICtpdDtcbiAgICAgIH1cbiAgICAgIGZvcih2YXIgZGlnaXRzID0gaXQuc2xpY2UoMiksIGkgPSAwLCBsID0gZGlnaXRzLmxlbmd0aCwgY29kZTsgaSA8IGw7IGkrKyl7XG4gICAgICAgIGNvZGUgPSBkaWdpdHMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgLy8gcGFyc2VJbnQgcGFyc2VzIGEgc3RyaW5nIHRvIGEgZmlyc3QgdW5hdmFpbGFibGUgc3ltYm9sXG4gICAgICAgIC8vIGJ1dCBUb051bWJlciBzaG91bGQgcmV0dXJuIE5hTiBpZiBhIHN0cmluZyBjb250YWlucyB1bmF2YWlsYWJsZSBzeW1ib2xzXG4gICAgICAgIGlmKGNvZGUgPCA0OCB8fCBjb2RlID4gbWF4Q29kZSlyZXR1cm4gTmFOO1xuICAgICAgfSByZXR1cm4gcGFyc2VJbnQoZGlnaXRzLCByYWRpeCk7XG4gICAgfVxuICB9IHJldHVybiAraXQ7XG59O1xuXG5pZighJE51bWJlcignIDBvMScpIHx8ICEkTnVtYmVyKCcwYjEnKSB8fCAkTnVtYmVyKCcrMHgxJykpe1xuICAkTnVtYmVyID0gZnVuY3Rpb24gTnVtYmVyKHZhbHVlKXtcbiAgICB2YXIgaXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMSA/IDAgOiB2YWx1ZVxuICAgICAgLCB0aGF0ID0gdGhpcztcbiAgICByZXR1cm4gdGhhdCBpbnN0YW5jZW9mICROdW1iZXJcbiAgICAgIC8vIGNoZWNrIG9uIDEuLmNvbnN0cnVjdG9yKGZvbykgY2FzZVxuICAgICAgJiYgKEJST0tFTl9DT0YgPyBmYWlscyhmdW5jdGlvbigpeyBwcm90by52YWx1ZU9mLmNhbGwodGhhdCk7IH0pIDogY29mKHRoYXQpICE9IE5VTUJFUilcbiAgICAgICAgPyBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSh0b051bWJlcihpdCkpLCB0aGF0LCAkTnVtYmVyKSA6IHRvTnVtYmVyKGl0KTtcbiAgfTtcbiAgZm9yKHZhciBrZXlzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUE4oQmFzZSkgOiAoXG4gICAgLy8gRVMzOlxuICAgICdNQVhfVkFMVUUsTUlOX1ZBTFVFLE5hTixORUdBVElWRV9JTkZJTklUWSxQT1NJVElWRV9JTkZJTklUWSwnICtcbiAgICAvLyBFUzYgKGluIGNhc2UsIGlmIG1vZHVsZXMgd2l0aCBFUzYgTnVtYmVyIHN0YXRpY3MgcmVxdWlyZWQgYmVmb3JlKTpcbiAgICAnRVBTSUxPTixpc0Zpbml0ZSxpc0ludGVnZXIsaXNOYU4saXNTYWZlSW50ZWdlcixNQVhfU0FGRV9JTlRFR0VSLCcgK1xuICAgICdNSU5fU0FGRV9JTlRFR0VSLHBhcnNlRmxvYXQscGFyc2VJbnQsaXNJbnRlZ2VyJ1xuICApLnNwbGl0KCcsJyksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajsgaisrKXtcbiAgICBpZihoYXMoQmFzZSwga2V5ID0ga2V5c1tqXSkgJiYgIWhhcygkTnVtYmVyLCBrZXkpKXtcbiAgICAgIGRQKCROdW1iZXIsIGtleSwgZ09QRChCYXNlLCBrZXkpKTtcbiAgICB9XG4gIH1cbiAgJE51bWJlci5wcm90b3R5cGUgPSBwcm90bztcbiAgcHJvdG8uY29uc3RydWN0b3IgPSAkTnVtYmVyO1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKGdsb2JhbCwgTlVNQkVSLCAkTnVtYmVyKTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIHRhcmdldCwgQyl7XG4gIHZhciBQLCBTID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICBpZihTICE9PSBDICYmIHR5cGVvZiBTID09ICdmdW5jdGlvbicgJiYgKFAgPSBTLnByb3RvdHlwZSkgIT09IEMucHJvdG90eXBlICYmIGlzT2JqZWN0KFApICYmIHNldFByb3RvdHlwZU9mKXtcbiAgICBzZXRQcm90b3R5cGVPZih0aGF0LCBQKTtcbiAgfSByZXR1cm4gdGhhdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9faW5oZXJpdC1pZi1yZXF1aXJlZC5qc1xuICoqIG1vZHVsZSBpZCA9IDE1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9JbnRlZ2VyICAgID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgYU51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9fYS1udW1iZXItdmFsdWUnKVxuICAsIHJlcGVhdCAgICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKVxuICAsICR0b0ZpeGVkICAgICA9IDEuLnRvRml4ZWRcbiAgLCBmbG9vciAgICAgICAgPSBNYXRoLmZsb29yXG4gICwgZGF0YSAgICAgICAgID0gWzAsIDAsIDAsIDAsIDAsIDBdXG4gICwgRVJST1IgICAgICAgID0gJ051bWJlci50b0ZpeGVkOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnXG4gICwgWkVSTyAgICAgICAgID0gJzAnO1xuXG52YXIgbXVsdGlwbHkgPSBmdW5jdGlvbihuLCBjKXtcbiAgdmFyIGkgID0gLTFcbiAgICAsIGMyID0gYztcbiAgd2hpbGUoKytpIDwgNil7XG4gICAgYzIgKz0gbiAqIGRhdGFbaV07XG4gICAgZGF0YVtpXSA9IGMyICUgMWU3O1xuICAgIGMyID0gZmxvb3IoYzIgLyAxZTcpO1xuICB9XG59O1xudmFyIGRpdmlkZSA9IGZ1bmN0aW9uKG4pe1xuICB2YXIgaSA9IDZcbiAgICAsIGMgPSAwO1xuICB3aGlsZSgtLWkgPj0gMCl7XG4gICAgYyArPSBkYXRhW2ldO1xuICAgIGRhdGFbaV0gPSBmbG9vcihjIC8gbik7XG4gICAgYyA9IChjICUgbikgKiAxZTc7XG4gIH1cbn07XG52YXIgbnVtVG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICB2YXIgaSA9IDZcbiAgICAsIHMgPSAnJztcbiAgd2hpbGUoLS1pID49IDApe1xuICAgIGlmKHMgIT09ICcnIHx8IGkgPT09IDAgfHwgZGF0YVtpXSAhPT0gMCl7XG4gICAgICB2YXIgdCA9IFN0cmluZyhkYXRhW2ldKTtcbiAgICAgIHMgPSBzID09PSAnJyA/IHQgOiBzICsgcmVwZWF0LmNhbGwoWkVSTywgNyAtIHQubGVuZ3RoKSArIHQ7XG4gICAgfVxuICB9IHJldHVybiBzO1xufTtcbnZhciBwb3cgPSBmdW5jdGlvbih4LCBuLCBhY2Mpe1xuICByZXR1cm4gbiA9PT0gMCA/IGFjYyA6IG4gJSAyID09PSAxID8gcG93KHgsIG4gLSAxLCBhY2MgKiB4KSA6IHBvdyh4ICogeCwgbiAvIDIsIGFjYyk7XG59O1xudmFyIGxvZyA9IGZ1bmN0aW9uKHgpe1xuICB2YXIgbiAgPSAwXG4gICAgLCB4MiA9IHg7XG4gIHdoaWxlKHgyID49IDQwOTYpe1xuICAgIG4gKz0gMTI7XG4gICAgeDIgLz0gNDA5NjtcbiAgfVxuICB3aGlsZSh4MiA+PSAyKXtcbiAgICBuICArPSAxO1xuICAgIHgyIC89IDI7XG4gIH0gcmV0dXJuIG47XG59O1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICghISR0b0ZpeGVkICYmIChcbiAgMC4wMDAwOC50b0ZpeGVkKDMpICE9PSAnMC4wMDAnIHx8XG4gIDAuOS50b0ZpeGVkKDApICE9PSAnMScgfHxcbiAgMS4yNTUudG9GaXhlZCgyKSAhPT0gJzEuMjUnIHx8XG4gIDEwMDAwMDAwMDAwMDAwMDAxMjguLnRvRml4ZWQoMCkgIT09ICcxMDAwMDAwMDAwMDAwMDAwMTI4J1xuKSB8fCAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICAkdG9GaXhlZC5jYWxsKHt9KTtcbn0pKSwgJ051bWJlcicsIHtcbiAgdG9GaXhlZDogZnVuY3Rpb24gdG9GaXhlZChmcmFjdGlvbkRpZ2l0cyl7XG4gICAgdmFyIHggPSBhTnVtYmVyVmFsdWUodGhpcywgRVJST1IpXG4gICAgICAsIGYgPSB0b0ludGVnZXIoZnJhY3Rpb25EaWdpdHMpXG4gICAgICAsIHMgPSAnJ1xuICAgICAgLCBtID0gWkVST1xuICAgICAgLCBlLCB6LCBqLCBrO1xuICAgIGlmKGYgPCAwIHx8IGYgPiAyMCl0aHJvdyBSYW5nZUVycm9yKEVSUk9SKTtcbiAgICBpZih4ICE9IHgpcmV0dXJuICdOYU4nO1xuICAgIGlmKHggPD0gLTFlMjEgfHwgeCA+PSAxZTIxKXJldHVybiBTdHJpbmcoeCk7XG4gICAgaWYoeCA8IDApe1xuICAgICAgcyA9ICctJztcbiAgICAgIHggPSAteDtcbiAgICB9XG4gICAgaWYoeCA+IDFlLTIxKXtcbiAgICAgIGUgPSBsb2coeCAqIHBvdygyLCA2OSwgMSkpIC0gNjk7XG4gICAgICB6ID0gZSA8IDAgPyB4ICogcG93KDIsIC1lLCAxKSA6IHggLyBwb3coMiwgZSwgMSk7XG4gICAgICB6ICo9IDB4MTAwMDAwMDAwMDAwMDA7XG4gICAgICBlID0gNTIgLSBlO1xuICAgICAgaWYoZSA+IDApe1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgaiA9IGY7XG4gICAgICAgIHdoaWxlKGogPj0gNyl7XG4gICAgICAgICAgbXVsdGlwbHkoMWU3LCAwKTtcbiAgICAgICAgICBqIC09IDc7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHkocG93KDEwLCBqLCAxKSwgMCk7XG4gICAgICAgIGogPSBlIC0gMTtcbiAgICAgICAgd2hpbGUoaiA+PSAyMyl7XG4gICAgICAgICAgZGl2aWRlKDEgPDwgMjMpO1xuICAgICAgICAgIGogLT0gMjM7XG4gICAgICAgIH1cbiAgICAgICAgZGl2aWRlKDEgPDwgaik7XG4gICAgICAgIG11bHRpcGx5KDEsIDEpO1xuICAgICAgICBkaXZpZGUoMik7XG4gICAgICAgIG0gPSBudW1Ub1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXVsdGlwbHkoMCwgeik7XG4gICAgICAgIG11bHRpcGx5KDEgPDwgLWUsIDApO1xuICAgICAgICBtID0gbnVtVG9TdHJpbmcoKSArIHJlcGVhdC5jYWxsKFpFUk8sIGYpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihmID4gMCl7XG4gICAgICBrID0gbS5sZW5ndGg7XG4gICAgICBtID0gcyArIChrIDw9IGYgPyAnMC4nICsgcmVwZWF0LmNhbGwoWkVSTywgZiAtIGspICsgbSA6IG0uc2xpY2UoMCwgayAtIGYpICsgJy4nICsgbS5zbGljZShrIC0gZikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gcyArIG07XG4gICAgfSByZXR1cm4gbTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkLmpzXG4gKiogbW9kdWxlIGlkID0gMTU1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBtc2cpe1xuICBpZih0eXBlb2YgaXQgIT0gJ251bWJlcicgJiYgY29mKGl0KSAhPSAnTnVtYmVyJyl0aHJvdyBUeXBlRXJyb3IobXNnKTtcbiAgcmV0dXJuICtpdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fYS1udW1iZXItdmFsdWUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBkZWZpbmVkICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVwZWF0KGNvdW50KXtcbiAgdmFyIHN0ciA9IFN0cmluZyhkZWZpbmVkKHRoaXMpKVxuICAgICwgcmVzID0gJydcbiAgICAsIG4gICA9IHRvSW50ZWdlcihjb3VudCk7XG4gIGlmKG4gPCAwIHx8IG4gPT0gSW5maW5pdHkpdGhyb3cgUmFuZ2VFcnJvcihcIkNvdW50IGNhbid0IGJlIG5lZ2F0aXZlXCIpO1xuICBmb3IoO24gPiAwOyAobiA+Pj49IDEpICYmIChzdHIgKz0gc3RyKSlpZihuICYgMSlyZXMgKz0gc3RyO1xuICByZXR1cm4gcmVzO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctcmVwZWF0LmpzXG4gKiogbW9kdWxlIGlkID0gMTU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZmFpbHMgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgYU51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9fYS1udW1iZXItdmFsdWUnKVxuICAsICR0b1ByZWNpc2lvbiA9IDEuLnRvUHJlY2lzaW9uO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICgkZmFpbHMoZnVuY3Rpb24oKXtcbiAgLy8gSUU3LVxuICByZXR1cm4gJHRvUHJlY2lzaW9uLmNhbGwoMSwgdW5kZWZpbmVkKSAhPT0gJzEnO1xufSkgfHwgISRmYWlscyhmdW5jdGlvbigpe1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICAkdG9QcmVjaXNpb24uY2FsbCh7fSk7XG59KSksICdOdW1iZXInLCB7XG4gIHRvUHJlY2lzaW9uOiBmdW5jdGlvbiB0b1ByZWNpc2lvbihwcmVjaXNpb24pe1xuICAgIHZhciB0aGF0ID0gYU51bWJlclZhbHVlKHRoaXMsICdOdW1iZXIjdG9QcmVjaXNpb246IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICAgIHJldHVybiBwcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/ICR0b1ByZWNpc2lvbi5jYWxsKHRoYXQpIDogJHRvUHJlY2lzaW9uLmNhbGwodGhhdCwgcHJlY2lzaW9uKTsgXG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjEuMi4xIE51bWJlci5FUFNJTE9OXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtFUFNJTE9OOiBNYXRoLnBvdygyLCAtNTIpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjEuMi4yIE51bWJlci5pc0Zpbml0ZShudW1iZXIpXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBfaXNGaW5pdGUgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5pc0Zpbml0ZTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzRmluaXRlOiBmdW5jdGlvbiBpc0Zpbml0ZShpdCl7XG4gICAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnbnVtYmVyJyAmJiBfaXNGaW5pdGUoaXQpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtZmluaXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge2lzSW50ZWdlcjogcmVxdWlyZSgnLi9faXMtaW50ZWdlcicpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjEuMi4zIE51bWJlci5pc0ludGVnZXIobnVtYmVyKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBmbG9vciAgICA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzSW50ZWdlcihpdCl7XG4gIHJldHVybiAhaXNPYmplY3QoaXQpICYmIGlzRmluaXRlKGl0KSAmJiBmbG9vcihpdCkgPT09IGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19pcy1pbnRlZ2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMTYyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4xLjIuNCBOdW1iZXIuaXNOYU4obnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzTmFOOiBmdW5jdGlvbiBpc05hTihudW1iZXIpe1xuICAgIHJldHVybiBudW1iZXIgIT0gbnVtYmVyO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuLmpzXG4gKiogbW9kdWxlIGlkID0gMTYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4xLjIuNSBOdW1iZXIuaXNTYWZlSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpc0ludGVnZXIgPSByZXF1aXJlKCcuL19pcy1pbnRlZ2VyJylcbiAgLCBhYnMgICAgICAgPSBNYXRoLmFicztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzU2FmZUludGVnZXI6IGZ1bmN0aW9uIGlzU2FmZUludGVnZXIobnVtYmVyKXtcbiAgICByZXR1cm4gaXNJbnRlZ2VyKG51bWJlcikgJiYgYWJzKG51bWJlcikgPD0gMHgxZmZmZmZmZmZmZmZmZjtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLXNhZmUtaW50ZWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDE2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMS4yLjYgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge01BWF9TQUZFX0lOVEVHRVI6IDB4MWZmZmZmZmZmZmZmZmZ9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDE2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMS4yLjEwIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtNSU5fU0FGRV9JTlRFR0VSOiAtMHgxZmZmZmZmZmZmZmZmZn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMTY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fcGFyc2UtZmxvYXQnKTtcbi8vIDIwLjEuMi4xMiBOdW1iZXIucGFyc2VGbG9hdChzdHJpbmcpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChOdW1iZXIucGFyc2VGbG9hdCAhPSAkcGFyc2VGbG9hdCksICdOdW1iZXInLCB7cGFyc2VGbG9hdDogJHBhcnNlRmxvYXR9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtZmxvYXQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX3BhcnNlLWludCcpO1xuLy8gMjAuMS4yLjEzIE51bWJlci5wYXJzZUludChzdHJpbmcsIHJhZGl4KVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTnVtYmVyLnBhcnNlSW50ICE9ICRwYXJzZUludCksICdOdW1iZXInLCB7cGFyc2VJbnQ6ICRwYXJzZUludH0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1pbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjIuMi4zIE1hdGguYWNvc2goeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBsb2cxcCAgID0gcmVxdWlyZSgnLi9fbWF0aC1sb2cxcCcpXG4gICwgc3FydCAgICA9IE1hdGguc3FydFxuICAsICRhY29zaCAgPSBNYXRoLmFjb3NoO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGFjb3NoXG4gIC8vIFY4IGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM1MDlcbiAgJiYgTWF0aC5mbG9vcigkYWNvc2goTnVtYmVyLk1BWF9WQUxVRSkpID09IDcxMFxuICAvLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYWNvc2goSW5maW5pdHkpIC0+IE5hTiBcbiAgJiYgJGFjb3NoKEluZmluaXR5KSA9PSBJbmZpbml0eVxuKSwgJ01hdGgnLCB7XG4gIGFjb3NoOiBmdW5jdGlvbiBhY29zaCh4KXtcbiAgICByZXR1cm4gKHggPSAreCkgPCAxID8gTmFOIDogeCA+IDk0OTA2MjY1LjYyNDI1MTU2XG4gICAgICA/IE1hdGgubG9nKHgpICsgTWF0aC5MTjJcbiAgICAgIDogbG9nMXAoeCAtIDEgKyBzcXJ0KHggLSAxKSAqIHNxcnQoeCArIDEpKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hY29zaC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjIwIE1hdGgubG9nMXAoeClcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5sb2cxcCB8fCBmdW5jdGlvbiBsb2cxcCh4KXtcbiAgcmV0dXJuICh4ID0gK3gpID4gLTFlLTggJiYgeCA8IDFlLTggPyB4IC0geCAqIHggLyAyIDogTWF0aC5sb2coMSArIHgpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19tYXRoLWxvZzFwLmpzXG4gKiogbW9kdWxlIGlkID0gMTcwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuNSBNYXRoLmFzaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGFzaW5oICA9IE1hdGguYXNpbmg7XG5cbmZ1bmN0aW9uIGFzaW5oKHgpe1xuICByZXR1cm4gIWlzRmluaXRlKHggPSAreCkgfHwgeCA9PSAwID8geCA6IHggPCAwID8gLWFzaW5oKC14KSA6IE1hdGgubG9nKHggKyBNYXRoLnNxcnQoeCAqIHggKyAxKSk7XG59XG5cbi8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hc2luaCgwKSAtPiAtMCBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXNpbmggJiYgMSAvICRhc2luaCgwKSA+IDApLCAnTWF0aCcsIHthc2luaDogYXNpbmh9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmFzaW5oLmpzXG4gKiogbW9kdWxlIGlkID0gMTcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuNyBNYXRoLmF0YW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGF0YW5oICA9IE1hdGguYXRhbmg7XG5cbi8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hdGFuaCgtMCkgLT4gMCBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXRhbmggJiYgMSAvICRhdGFuaCgtMCkgPCAwKSwgJ01hdGgnLCB7XG4gIGF0YW5oOiBmdW5jdGlvbiBhdGFuaCh4KXtcbiAgICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiBNYXRoLmxvZygoMSArIHgpIC8gKDEgLSB4KSkgLyAyO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmF0YW5oLmpzXG4gKiogbW9kdWxlIGlkID0gMTcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuOSBNYXRoLmNicnQoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBzaWduICAgID0gcmVxdWlyZSgnLi9fbWF0aC1zaWduJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2JydDogZnVuY3Rpb24gY2JydCh4KXtcbiAgICByZXR1cm4gc2lnbih4ID0gK3gpICogTWF0aC5wb3coTWF0aC5hYnMoeCksIDEgLyAzKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jYnJ0LmpzXG4gKiogbW9kdWxlIGlkID0gMTczXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbiBzaWduKHgpe1xuICByZXR1cm4gKHggPSAreCkgPT0gMCB8fCB4ICE9IHggPyB4IDogeCA8IDAgPyAtMSA6IDE7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX21hdGgtc2lnbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjExIE1hdGguY2x6MzIoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2x6MzI6IGZ1bmN0aW9uIGNsejMyKHgpe1xuICAgIHJldHVybiAoeCA+Pj49IDApID8gMzEgLSBNYXRoLmZsb29yKE1hdGgubG9nKHggKyAwLjUpICogTWF0aC5MT0cyRSkgOiAzMjtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jbHozMi5qc1xuICoqIG1vZHVsZSBpZCA9IDE3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjEyIE1hdGguY29zaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGV4cCAgICAgPSBNYXRoLmV4cDtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjb3NoOiBmdW5jdGlvbiBjb3NoKHgpe1xuICAgIHJldHVybiAoZXhwKHggPSAreCkgKyBleHAoLXgpKSAvIDI7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY29zaC5qc1xuICoqIG1vZHVsZSBpZCA9IDE3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZXhwbTEgID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICgkZXhwbTEgIT0gTWF0aC5leHBtMSksICdNYXRoJywge2V4cG0xOiAkZXhwbTF9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmV4cG0xLmpzXG4gKiogbW9kdWxlIGlkID0gMTc3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxudmFyICRleHBtMSA9IE1hdGguZXhwbTE7XG5tb2R1bGUuZXhwb3J0cyA9ICghJGV4cG0xXG4gIC8vIE9sZCBGRiBidWdcbiAgfHwgJGV4cG0xKDEwKSA+IDIyMDI1LjQ2NTc5NDgwNjcxOSB8fCAkZXhwbTEoMTApIDwgMjIwMjUuNDY1Nzk0ODA2NzE2NTE2OFxuICAvLyBUb3IgQnJvd3NlciBidWdcbiAgfHwgJGV4cG0xKC0yZS0xNykgIT0gLTJlLTE3XG4pID8gZnVuY3Rpb24gZXhwbTEoeCl7XG4gIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IHggPiAtMWUtNiAmJiB4IDwgMWUtNiA/IHggKyB4ICogeCAvIDIgOiBNYXRoLmV4cCh4KSAtIDE7XG59IDogJGV4cG0xO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX21hdGgtZXhwbTEuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjIuMi4xNiBNYXRoLmZyb3VuZCh4KVxudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgc2lnbiAgICAgID0gcmVxdWlyZSgnLi9fbWF0aC1zaWduJylcbiAgLCBwb3cgICAgICAgPSBNYXRoLnBvd1xuICAsIEVQU0lMT04gICA9IHBvdygyLCAtNTIpXG4gICwgRVBTSUxPTjMyID0gcG93KDIsIC0yMylcbiAgLCBNQVgzMiAgICAgPSBwb3coMiwgMTI3KSAqICgyIC0gRVBTSUxPTjMyKVxuICAsIE1JTjMyICAgICA9IHBvdygyLCAtMTI2KTtcblxudmFyIHJvdW5kVGllc1RvRXZlbiA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gbiArIDEgLyBFUFNJTE9OIC0gMSAvIEVQU0lMT047XG59O1xuXG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgZnJvdW5kOiBmdW5jdGlvbiBmcm91bmQoeCl7XG4gICAgdmFyICRhYnMgID0gTWF0aC5hYnMoeClcbiAgICAgICwgJHNpZ24gPSBzaWduKHgpXG4gICAgICAsIGEsIHJlc3VsdDtcbiAgICBpZigkYWJzIDwgTUlOMzIpcmV0dXJuICRzaWduICogcm91bmRUaWVzVG9FdmVuKCRhYnMgLyBNSU4zMiAvIEVQU0lMT04zMikgKiBNSU4zMiAqIEVQU0lMT04zMjtcbiAgICBhID0gKDEgKyBFUFNJTE9OMzIgLyBFUFNJTE9OKSAqICRhYnM7XG4gICAgcmVzdWx0ID0gYSAtIChhIC0gJGFicyk7XG4gICAgaWYocmVzdWx0ID4gTUFYMzIgfHwgcmVzdWx0ICE9IHJlc3VsdClyZXR1cm4gJHNpZ24gKiBJbmZpbml0eTtcbiAgICByZXR1cm4gJHNpZ24gKiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kLmpzXG4gKiogbW9kdWxlIGlkID0gMTc5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuMTcgTWF0aC5oeXBvdChbdmFsdWUxWywgdmFsdWUyWywg4oCmIF1dXSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhYnMgICAgID0gTWF0aC5hYnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaHlwb3Q6IGZ1bmN0aW9uIGh5cG90KHZhbHVlMSwgdmFsdWUyKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciBzdW0gID0gMFxuICAgICAgLCBpICAgID0gMFxuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBsYXJnID0gMFxuICAgICAgLCBhcmcsIGRpdjtcbiAgICB3aGlsZShpIDwgYUxlbil7XG4gICAgICBhcmcgPSBhYnMoYXJndW1lbnRzW2krK10pO1xuICAgICAgaWYobGFyZyA8IGFyZyl7XG4gICAgICAgIGRpdiAgPSBsYXJnIC8gYXJnO1xuICAgICAgICBzdW0gID0gc3VtICogZGl2ICogZGl2ICsgMTtcbiAgICAgICAgbGFyZyA9IGFyZztcbiAgICAgIH0gZWxzZSBpZihhcmcgPiAwKXtcbiAgICAgICAgZGl2ICA9IGFyZyAvIGxhcmc7XG4gICAgICAgIHN1bSArPSBkaXYgKiBkaXY7XG4gICAgICB9IGVsc2Ugc3VtICs9IGFyZztcbiAgICB9XG4gICAgcmV0dXJuIGxhcmcgPT09IEluZmluaXR5ID8gSW5maW5pdHkgOiBsYXJnICogTWF0aC5zcXJ0KHN1bSk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxODBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjIuMi4xOCBNYXRoLmltdWwoeCwgeSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkaW11bCAgID0gTWF0aC5pbXVsO1xuXG4vLyBzb21lIFdlYktpdCB2ZXJzaW9ucyBmYWlscyB3aXRoIGJpZyBudW1iZXJzLCBzb21lIGhhcyB3cm9uZyBhcml0eVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiAkaW11bCgweGZmZmZmZmZmLCA1KSAhPSAtNSB8fCAkaW11bC5sZW5ndGggIT0gMjtcbn0pLCAnTWF0aCcsIHtcbiAgaW11bDogZnVuY3Rpb24gaW11bCh4LCB5KXtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmXG4gICAgICAsIHhuID0gK3hcbiAgICAgICwgeW4gPSAreVxuICAgICAgLCB4bCA9IFVJTlQxNiAmIHhuXG4gICAgICAsIHlsID0gVUlOVDE2ICYgeW47XG4gICAgcmV0dXJuIDAgfCB4bCAqIHlsICsgKChVSU5UMTYgJiB4biA+Pj4gMTYpICogeWwgKyB4bCAqIChVSU5UMTYgJiB5biA+Pj4gMTYpIDw8IDE2ID4+PiAwKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5pbXVsLmpzXG4gKiogbW9kdWxlIGlkID0gMTgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuMjEgTWF0aC5sb2cxMCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cxMDogZnVuY3Rpb24gbG9nMTAoeCl7XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjEwO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwLmpzXG4gKiogbW9kdWxlIGlkID0gMTgyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuMjAgTWF0aC5sb2cxcCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge2xvZzFwOiByZXF1aXJlKCcuL19tYXRoLWxvZzFwJyl9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwLmpzXG4gKiogbW9kdWxlIGlkID0gMTgzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuMjIgTWF0aC5sb2cyKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGxvZzI6IGZ1bmN0aW9uIGxvZzIoeCl7XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjI7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMi5qc1xuICoqIG1vZHVsZSBpZCA9IDE4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge3NpZ246IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaWduLmpzXG4gKiogbW9kdWxlIGlkID0gMTg1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuMzAgTWF0aC5zaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZXhwbTEgICA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKVxuICAsIGV4cCAgICAgPSBNYXRoLmV4cDtcblxuLy8gVjggbmVhciBDaHJvbWl1bSAzOCBoYXMgYSBwcm9ibGVtIHdpdGggdmVyeSBzbWFsbCBudW1iZXJzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuICFNYXRoLnNpbmgoLTJlLTE3KSAhPSAtMmUtMTc7XG59KSwgJ01hdGgnLCB7XG4gIHNpbmg6IGZ1bmN0aW9uIHNpbmgoeCl7XG4gICAgcmV0dXJuIE1hdGguYWJzKHggPSAreCkgPCAxXG4gICAgICA/IChleHBtMSh4KSAtIGV4cG0xKC14KSkgLyAyXG4gICAgICA6IChleHAoeCAtIDEpIC0gZXhwKC14IC0gMSkpICogKE1hdGguRSAvIDIpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpbmguanNcbiAqKiBtb2R1bGUgaWQgPSAxODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjIuMi4zMyBNYXRoLnRhbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBleHBtMSAgID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpXG4gICwgZXhwICAgICA9IE1hdGguZXhwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHRhbmg6IGZ1bmN0aW9uIHRhbmgoeCl7XG4gICAgdmFyIGEgPSBleHBtMSh4ID0gK3gpXG4gICAgICAsIGIgPSBleHBtMSgteCk7XG4gICAgcmV0dXJuIGEgPT0gSW5maW5pdHkgPyAxIDogYiA9PSBJbmZpbml0eSA/IC0xIDogKGEgLSBiKSAvIChleHAoeCkgKyBleHAoLXgpKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50YW5oLmpzXG4gKiogbW9kdWxlIGlkID0gMTg3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuMzQgTWF0aC50cnVuYyh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB0cnVuYzogZnVuY3Rpb24gdHJ1bmMoaXQpe1xuICAgIHJldHVybiAoaXQgPiAwID8gTWF0aC5mbG9vciA6IE1hdGguY2VpbCkoaXQpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnRydW5jLmpzXG4gKiogbW9kdWxlIGlkID0gMTg4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvSW5kZXggICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIGZyb21DaGFyQ29kZSAgID0gU3RyaW5nLmZyb21DaGFyQ29kZVxuICAsICRmcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG5cbi8vIGxlbmd0aCBzaG91bGQgYmUgMSwgb2xkIEZGIHByb2JsZW1cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCEhJGZyb21Db2RlUG9pbnQgJiYgJGZyb21Db2RlUG9pbnQubGVuZ3RoICE9IDEpLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjIuMiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jb2RlUG9pbnRzKVxuICBmcm9tQ29kZVBvaW50OiBmdW5jdGlvbiBmcm9tQ29kZVBvaW50KHgpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHJlcyAgPSBbXVxuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBpICAgID0gMFxuICAgICAgLCBjb2RlO1xuICAgIHdoaWxlKGFMZW4gPiBpKXtcbiAgICAgIGNvZGUgPSArYXJndW1lbnRzW2krK107XG4gICAgICBpZih0b0luZGV4KGNvZGUsIDB4MTBmZmZmKSAhPT0gY29kZSl0aHJvdyBSYW5nZUVycm9yKGNvZGUgKyAnIGlzIG5vdCBhIHZhbGlkIGNvZGUgcG9pbnQnKTtcbiAgICAgIHJlcy5wdXNoKGNvZGUgPCAweDEwMDAwXG4gICAgICAgID8gZnJvbUNoYXJDb2RlKGNvZGUpXG4gICAgICAgIDogZnJvbUNoYXJDb2RlKCgoY29kZSAtPSAweDEwMDAwKSA+PiAxMCkgKyAweGQ4MDAsIGNvZGUgJSAweDQwMCArIDB4ZGMwMClcbiAgICAgICk7XG4gICAgfSByZXR1cm4gcmVzLmpvaW4oJycpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50LmpzXG4gKiogbW9kdWxlIGlkID0gMTg5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi40IFN0cmluZy5yYXcoY2FsbFNpdGUsIC4uLnN1YnN0aXR1dGlvbnMpXG4gIHJhdzogZnVuY3Rpb24gcmF3KGNhbGxTaXRlKXtcbiAgICB2YXIgdHBsICA9IHRvSU9iamVjdChjYWxsU2l0ZS5yYXcpXG4gICAgICAsIGxlbiAgPSB0b0xlbmd0aCh0cGwubGVuZ3RoKVxuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCByZXMgID0gW11cbiAgICAgICwgaSAgICA9IDA7XG4gICAgd2hpbGUobGVuID4gaSl7XG4gICAgICByZXMucHVzaChTdHJpbmcodHBsW2krK10pKTtcbiAgICAgIGlmKGkgPCBhTGVuKXJlcy5wdXNoKFN0cmluZyhhcmd1bWVudHNbaV0pKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yYXcuanNcbiAqKiBtb2R1bGUgaWQgPSAxOTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIxLjEuMy4yNSBTdHJpbmcucHJvdG90eXBlLnRyaW0oKVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbScsIGZ1bmN0aW9uKCR0cmltKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW0oKXtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMyk7XG4gIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbS5qc1xuICoqIG1vZHVsZSBpZCA9IDE5MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCAgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGluZGV4ID0gdGhpcy5faVxuICAgICwgcG9pbnQ7XG4gIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7dmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZX07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBkZWZpbmVkICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUT19TVFJJTkcpe1xuICByZXR1cm4gZnVuY3Rpb24odGhhdCwgcG9zKXtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxuICAgICAgLCBpID0gdG9JbnRlZ2VyKHBvcylcbiAgICAgICwgbCA9IHMubGVuZ3RoXG4gICAgICAsIGEsIGI7XG4gICAgaWYoaSA8IDAgfHwgaSA+PSBsKXJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1hdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGhpZGUgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIEl0ZXJhdG9ycyAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCAkaXRlckNyZWF0ZSAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIElURVJBVE9SICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBCVUdHWSAgICAgICAgICA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKSAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG4gICwgRkZfSVRFUkFUT1IgICAgPSAnQEBpdGVyYXRvcidcbiAgLCBLRVlTICAgICAgICAgICA9ICdrZXlzJ1xuICAsIFZBTFVFUyAgICAgICAgID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKXtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24oa2luZCl7XG4gICAgaWYoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaChraW5kKXtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHICAgICAgICA9IE5BTUUgKyAnIEl0ZXJhdG9yJ1xuICAgICwgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTXG4gICAgLCBWQUxVRVNfQlVHID0gZmFsc2VcbiAgICAsIHByb3RvICAgICAgPSBCYXNlLnByb3RvdHlwZVxuICAgICwgJG5hdGl2ZSAgICA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXVxuICAgICwgJGRlZmF1bHQgICA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpXG4gICAgLCAkZW50cmllcyAgID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZFxuICAgICwgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmVcbiAgICAsIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYoJGFueU5hdGl2ZSl7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UpKTtcbiAgICBpZihJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSl7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKWhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZihERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpe1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKXtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddICA9IHJldHVyblRoaXM7XG4gIGlmKERFRkFVTFQpe1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6ICBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6ICAgIElTX1NFVCAgICAgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZihGT1JDRUQpZm9yKGtleSBpbiBtZXRob2RzKXtcbiAgICAgIGlmKCEoa2V5IGluIHByb3RvKSlyZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gMTk0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qc1xuICoqIG1vZHVsZSBpZCA9IDE5NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZGVzY3JpcHRvciAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KXtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7bmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KX0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxOTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkYXQgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykoZmFsc2UpO1xuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4zIFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQocG9zKVxuICBjb2RlUG9pbnRBdDogZnVuY3Rpb24gY29kZVBvaW50QXQocG9zKXtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0LmpzXG4gKiogbW9kdWxlIGlkID0gMTk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMS4xLjMuNiBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKHNlYXJjaFN0cmluZyBbLCBlbmRQb3NpdGlvbl0pXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGNvbnRleHQgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0JylcbiAgLCBFTkRTX1dJVEggPSAnZW5kc1dpdGgnXG4gICwgJGVuZHNXaXRoID0gJydbRU5EU19XSVRIXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShFTkRTX1dJVEgpLCAnU3RyaW5nJywge1xuICBlbmRzV2l0aDogZnVuY3Rpb24gZW5kc1dpdGgoc2VhcmNoU3RyaW5nIC8qLCBlbmRQb3NpdGlvbiA9IEBsZW5ndGggKi8pe1xuICAgIHZhciB0aGF0ID0gY29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIEVORFNfV0lUSClcbiAgICAgICwgZW5kUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZFxuICAgICAgLCBsZW4gICAgPSB0b0xlbmd0aCh0aGF0Lmxlbmd0aClcbiAgICAgICwgZW5kICAgID0gZW5kUG9zaXRpb24gPT09IHVuZGVmaW5lZCA/IGxlbiA6IE1hdGgubWluKHRvTGVuZ3RoKGVuZFBvc2l0aW9uKSwgbGVuKVxuICAgICAgLCBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJGVuZHNXaXRoXG4gICAgICA/ICRlbmRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgZW5kKVxuICAgICAgOiB0aGF0LnNsaWNlKGVuZCAtIHNlYXJjaC5sZW5ndGgsIGVuZCkgPT09IHNlYXJjaDtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaGVscGVyIGZvciBTdHJpbmcje3N0YXJ0c1dpdGgsIGVuZHNXaXRoLCBpbmNsdWRlc31cbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpXG4gICwgZGVmaW5lZCAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGhhdCwgc2VhcmNoU3RyaW5nLCBOQU1FKXtcbiAgaWYoaXNSZWdFeHAoc2VhcmNoU3RyaW5nKSl0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZyMnICsgTkFNRSArIFwiIGRvZXNuJ3QgYWNjZXB0IHJlZ2V4IVwiKTtcbiAgcmV0dXJuIFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWNvbnRleHQuanNcbiAqKiBtb2R1bGUgaWQgPSAxOTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMi44IElzUmVnRXhwKGFyZ3VtZW50KVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBjb2YgICAgICA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgTUFUQ0ggICAgPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgaXNSZWdFeHA7XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIXSkgIT09IHVuZGVmaW5lZCA/ICEhaXNSZWdFeHAgOiBjb2YoaXQpID09ICdSZWdFeHAnKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtcmVnZXhwLmpzXG4gKiogbW9kdWxlIGlkID0gMjAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgTUFUQ0ggPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZKXtcbiAgdmFyIHJlID0gLy4vO1xuICB0cnkge1xuICAgICcvLi8nW0tFWV0ocmUpO1xuICB9IGNhdGNoKGUpe1xuICAgIHRyeSB7XG4gICAgICByZVtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAhJy8uLydbS0VZXShyZSk7XG4gICAgfSBjYXRjaChmKXsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiB0cnVlO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19mYWlscy1pcy1yZWdleHAuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIxLjEuMy43IFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiA9IDApXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNvbnRleHQgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKVxuICAsIElOQ0xVREVTID0gJ2luY2x1ZGVzJztcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShJTkNMVURFUyksICdTdHJpbmcnLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hTdHJpbmcgLyosIHBvc2l0aW9uID0gMCAqLyl7XG4gICAgcmV0dXJuICEhfmNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBJTkNMVURFUylcbiAgICAgIC5pbmRleE9mKHNlYXJjaFN0cmluZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQoY291bnQpXG4gIHJlcGVhdDogcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpXG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmVwZWF0LmpzXG4gKiogbW9kdWxlIGlkID0gMjAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMS4xLjMuMTggU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoKHNlYXJjaFN0cmluZyBbLCBwb3NpdGlvbiBdKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0xlbmd0aCAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgY29udGV4dCAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpXG4gICwgU1RBUlRTX1dJVEggPSAnc3RhcnRzV2l0aCdcbiAgLCAkc3RhcnRzV2l0aCA9ICcnW1NUQVJUU19XSVRIXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShTVEFSVFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIHN0YXJ0c1dpdGg6IGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIC8qLCBwb3NpdGlvbiA9IDAgKi8pe1xuICAgIHZhciB0aGF0ICAgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgU1RBUlRTX1dJVEgpXG4gICAgICAsIGluZGV4ICA9IHRvTGVuZ3RoKE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0aGF0Lmxlbmd0aCkpXG4gICAgICAsIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkc3RhcnRzV2l0aFxuICAgICAgPyAkc3RhcnRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgaW5kZXgpXG4gICAgICA6IHRoYXQuc2xpY2UoaW5kZXgsIGluZGV4ICsgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0YXJ0cy13aXRoLmpzXG4gKiogbW9kdWxlIGlkID0gMjA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4yIFN0cmluZy5wcm90b3R5cGUuYW5jaG9yKG5hbWUpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdhbmNob3InLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFuY2hvcihuYW1lKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYScsICduYW1lJywgbmFtZSk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5hbmNob3IuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCBxdW90ICAgID0gL1wiL2c7XG4vLyBCLjIuMy4yLjEgQ3JlYXRlSFRNTChzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSlcbnZhciBjcmVhdGVIVE1MID0gZnVuY3Rpb24oc3RyaW5nLCB0YWcsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgdmFyIFMgID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSlcbiAgICAsIHAxID0gJzwnICsgdGFnO1xuICBpZihhdHRyaWJ1dGUgIT09ICcnKXAxICs9ICcgJyArIGF0dHJpYnV0ZSArICc9XCInICsgU3RyaW5nKHZhbHVlKS5yZXBsYWNlKHF1b3QsICcmcXVvdDsnKSArICdcIic7XG4gIHJldHVybiBwMSArICc+JyArIFMgKyAnPC8nICsgdGFnICsgJz4nO1xufTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSwgZXhlYyl7XG4gIHZhciBPID0ge307XG4gIE9bTkFNRV0gPSBleGVjKGNyZWF0ZUhUTUwpO1xuICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgdmFyIHRlc3QgPSAnJ1tOQU1FXSgnXCInKTtcbiAgICByZXR1cm4gdGVzdCAhPT0gdGVzdC50b0xvd2VyQ2FzZSgpIHx8IHRlc3Quc3BsaXQoJ1wiJykubGVuZ3RoID4gMztcbiAgfSksICdTdHJpbmcnLCBPKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWh0bWwuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjMgU3RyaW5nLnByb3RvdHlwZS5iaWcoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYmlnJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBiaWcoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYmlnJywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJpZy5qc1xuICoqIG1vZHVsZSBpZCA9IDIwN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNCBTdHJpbmcucHJvdG90eXBlLmJsaW5rKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JsaW5rJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBibGluaygpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdibGluaycsICcnLCAnJyk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ibGluay5qc1xuICoqIG1vZHVsZSBpZCA9IDIwOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNSBTdHJpbmcucHJvdG90eXBlLmJvbGQoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYm9sZCcsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gYm9sZCgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdiJywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJvbGQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjYgU3RyaW5nLnByb3RvdHlwZS5maXhlZCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmaXhlZCcsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gZml4ZWQoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAndHQnLCAnJywgJycpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZml4ZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjcgU3RyaW5nLnByb3RvdHlwZS5mb250Y29sb3IoY29sb3IpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmb250Y29sb3InLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbnRjb2xvcihjb2xvcil7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2ZvbnQnLCAnY29sb3InLCBjb2xvcik7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250Y29sb3IuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjggU3RyaW5nLnByb3RvdHlwZS5mb250c2l6ZShzaXplKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZm9udHNpemUnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbnRzaXplKHNpemUpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdmb250JywgJ3NpemUnLCBzaXplKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRzaXplLmpzXG4gKiogbW9kdWxlIGlkID0gMjEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy45IFN0cmluZy5wcm90b3R5cGUuaXRhbGljcygpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdpdGFsaWNzJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBpdGFsaWNzKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2knLCAnJywgJycpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcy5qc1xuICoqIG1vZHVsZSBpZCA9IDIxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTAgU3RyaW5nLnByb3RvdHlwZS5saW5rKHVybClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2xpbmsnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGxpbmsodXJsKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYScsICdocmVmJywgdXJsKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmxpbmsuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjExIFN0cmluZy5wcm90b3R5cGUuc21hbGwoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc21hbGwnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNtYWxsKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3NtYWxsJywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnNtYWxsLmpzXG4gKiogbW9kdWxlIGlkID0gMjE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMiBTdHJpbmcucHJvdG90eXBlLnN0cmlrZSgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdHJpa2UnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN0cmlrZSgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdHJpa2UnLCAnJywgJycpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RyaWtlLmpzXG4gKiogbW9kdWxlIGlkID0gMjE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMyBTdHJpbmcucHJvdG90eXBlLnN1YigpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdWInLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN1Yigpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdWInLCAnJywgJycpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3ViLmpzXG4gKiogbW9kdWxlIGlkID0gMjE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xNCBTdHJpbmcucHJvdG90eXBlLnN1cCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdXAnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN1cCgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdXAnLCAnJywgJycpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3VwLmpzXG4gKiogbW9kdWxlIGlkID0gMjE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4zLjMuMSAvIDE1LjkuNC40IERhdGUubm93KClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnRGF0ZScsIHtub3c6IGZ1bmN0aW9uKCl7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUubm93LmpzXG4gKiogbW9kdWxlIGlkID0gMjE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIG5ldyBEYXRlKE5hTikudG9KU09OKCkgIT09IG51bGwgfHwgRGF0ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoe3RvSVNPU3RyaW5nOiBmdW5jdGlvbigpeyByZXR1cm4gMTsgfX0pICE9PSAxO1xufSksICdEYXRlJywge1xuICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTihrZXkpe1xuICAgIHZhciBPICA9IHRvT2JqZWN0KHRoaXMpXG4gICAgICAsIHB2ID0gdG9QcmltaXRpdmUoTyk7XG4gICAgcmV0dXJuIHR5cGVvZiBwdiA9PSAnbnVtYmVyJyAmJiAhaXNGaW5pdGUocHYpID8gbnVsbCA6IE8udG9JU09TdHJpbmcoKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1qc29uLmpzXG4gKiogbW9kdWxlIGlkID0gMjIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyAyMC4zLjQuMzYgLyAxNS45LjUuNDMgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGZhaWxzICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgZ2V0VGltZSA9IERhdGUucHJvdG90eXBlLmdldFRpbWU7XG5cbnZhciBseiA9IGZ1bmN0aW9uKG51bSl7XG4gIHJldHVybiBudW0gPiA5ID8gbnVtIDogJzAnICsgbnVtO1xufTtcblxuLy8gUGhhbnRvbUpTIC8gb2xkIFdlYktpdCBoYXMgYSBicm9rZW4gaW1wbGVtZW50YXRpb25zXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbigpe1xuICByZXR1cm4gbmV3IERhdGUoLTVlMTMgLSAxKS50b0lTT1N0cmluZygpICE9ICcwMzg1LTA3LTI1VDA3OjA2OjM5Ljk5OVonO1xufSkgfHwgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gIG5ldyBEYXRlKE5hTikudG9JU09TdHJpbmcoKTtcbn0pKSwgJ0RhdGUnLCB7XG4gIHRvSVNPU3RyaW5nOiBmdW5jdGlvbiB0b0lTT1N0cmluZygpe1xuICAgIGlmKCFpc0Zpbml0ZShnZXRUaW1lLmNhbGwodGhpcykpKXRocm93IFJhbmdlRXJyb3IoJ0ludmFsaWQgdGltZSB2YWx1ZScpO1xuICAgIHZhciBkID0gdGhpc1xuICAgICAgLCB5ID0gZC5nZXRVVENGdWxsWWVhcigpXG4gICAgICAsIG0gPSBkLmdldFVUQ01pbGxpc2Vjb25kcygpXG4gICAgICAsIHMgPSB5IDwgMCA/ICctJyA6IHkgPiA5OTk5ID8gJysnIDogJyc7XG4gICAgcmV0dXJuIHMgKyAoJzAwMDAwJyArIE1hdGguYWJzKHkpKS5zbGljZShzID8gLTYgOiAtNCkgK1xuICAgICAgJy0nICsgbHooZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgKyBseihkLmdldFVUQ0RhdGUoKSkgK1xuICAgICAgJ1QnICsgbHooZC5nZXRVVENIb3VycygpKSArICc6JyArIGx6KGQuZ2V0VVRDTWludXRlcygpKSArXG4gICAgICAnOicgKyBseihkLmdldFVUQ1NlY29uZHMoKSkgKyAnLicgKyAobSA+IDk5ID8gbSA6ICcwJyArIGx6KG0pKSArICdaJztcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1pc28tc3RyaW5nLmpzXG4gKiogbW9kdWxlIGlkID0gMjIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgRGF0ZVByb3RvICAgID0gRGF0ZS5wcm90b3R5cGVcbiAgLCBJTlZBTElEX0RBVEUgPSAnSW52YWxpZCBEYXRlJ1xuICAsIFRPX1NUUklORyAgICA9ICd0b1N0cmluZydcbiAgLCAkdG9TdHJpbmcgICAgPSBEYXRlUHJvdG9bVE9fU1RSSU5HXVxuICAsIGdldFRpbWUgICAgICA9IERhdGVQcm90by5nZXRUaW1lO1xuaWYobmV3IERhdGUoTmFOKSArICcnICE9IElOVkFMSURfREFURSl7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoRGF0ZVByb3RvLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgdmFyIHZhbHVlID0gZ2V0VGltZS5jYWxsKHRoaXMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyAkdG9TdHJpbmcuY2FsbCh0aGlzKSA6IElOVkFMSURfREFURTtcbiAgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBUT19QUklNSVRJVkUgPSByZXF1aXJlKCcuL193a3MnKSgndG9QcmltaXRpdmUnKVxuICAsIHByb3RvICAgICAgICA9IERhdGUucHJvdG90eXBlO1xuXG5pZighKFRPX1BSSU1JVElWRSBpbiBwcm90bykpcmVxdWlyZSgnLi9faGlkZScpKHByb3RvLCBUT19QUklNSVRJVkUsIHJlcXVpcmUoJy4vX2RhdGUtdG8tcHJpbWl0aXZlJykpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tcHJpbWl0aXZlLmpzXG4gKiogbW9kdWxlIGlkID0gMjIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBOVU1CRVIgICAgICA9ICdudW1iZXInO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhpbnQpe1xuICBpZihoaW50ICE9PSAnc3RyaW5nJyAmJiBoaW50ICE9PSBOVU1CRVIgJiYgaGludCAhPT0gJ2RlZmF1bHQnKXRocm93IFR5cGVFcnJvcignSW5jb3JyZWN0IGhpbnQnKTtcbiAgcmV0dXJuIHRvUHJpbWl0aXZlKGFuT2JqZWN0KHRoaXMpLCBoaW50ICE9IE5VTUJFUik7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX2RhdGUtdG8tcHJpbWl0aXZlLmpzXG4gKiogbW9kdWxlIGlkID0gMjI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMi4xLjIuMiAvIDE1LjQuMy4yIEFycmF5LmlzQXJyYXkoYXJnKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdBcnJheScsIHtpc0FycmF5OiByZXF1aXJlKCcuL19pcy1hcnJheScpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXMtYXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBjdHggICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBjYWxsICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpXG4gICwgaXNBcnJheUl0ZXIgICAgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJylcbiAgLCB0b0xlbmd0aCAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKVxuICAsIGdldEl0ZXJGbiAgICAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbihpdGVyKXsgQXJyYXkuZnJvbShpdGVyKTsgfSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjEgQXJyYXkuZnJvbShhcnJheUxpa2UsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICBmcm9tOiBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZS8qLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCovKXtcbiAgICB2YXIgTyAgICAgICA9IHRvT2JqZWN0KGFycmF5TGlrZSlcbiAgICAgICwgQyAgICAgICA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXlcbiAgICAgICwgYUxlbiAgICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgbWFwZm4gICA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkXG4gICAgICAsIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkXG4gICAgICAsIGluZGV4ICAgPSAwXG4gICAgICAsIGl0ZXJGbiAgPSBnZXRJdGVyRm4oTylcbiAgICAgICwgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmKG1hcHBpbmcpbWFwZm4gPSBjdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZihpdGVyRm4gIT0gdW5kZWZpbmVkICYmICEoQyA9PSBBcnJheSAmJiBpc0FycmF5SXRlcihpdGVyRm4pKSl7XG4gICAgICBmb3IoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEM7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKyl7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yKHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKXtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZyb20uanNcbiAqKiBtb2R1bGUgaWQgPSAyMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoKGUpe1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYocmV0ICE9PSB1bmRlZmluZWQpYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY2FsbC5qc1xuICoqIG1vZHVsZSBpZCA9IDIyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIElURVJBVE9SICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBjcmVhdGVEZXNjICAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBpbmRleCwgdmFsdWUpe1xuICBpZihpbmRleCBpbiBvYmplY3QpJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gMjI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCAhPSB1bmRlZmluZWQpcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIElURVJBVE9SICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24oKXsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24oKXsgdGhyb3cgMjsgfSk7XG59IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYywgc2tpcENsb3Npbmcpe1xuICBpZighc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORylyZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciAgPSBbN11cbiAgICAgICwgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbigpeyByZXR1cm4ge2RvbmU6IHNhZmUgPSB0cnVlfTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG4vLyBXZWJLaXQgQXJyYXkub2YgaXNuJ3QgZ2VuZXJpY1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIGZ1bmN0aW9uIEYoKXt9XG4gIHJldHVybiAhKEFycmF5Lm9mLmNhbGwoRikgaW5zdGFuY2VvZiBGKTtcbn0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4zIEFycmF5Lm9mKCAuLi5pdGVtcylcbiAgb2Y6IGZ1bmN0aW9uIG9mKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHZhciBpbmRleCAgPSAwXG4gICAgICAsIGFMZW4gICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgcmVzdWx0ID0gbmV3ICh0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5KShhTGVuKTtcbiAgICB3aGlsZShhTGVuID4gaW5kZXgpY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICByZXN1bHQubGVuZ3RoID0gYUxlbjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDIzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5qb2luKHNlcGFyYXRvcilcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGFycmF5Sm9pbiA9IFtdLmpvaW47XG5cbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBzdHJpbmdzXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChyZXF1aXJlKCcuL19pb2JqZWN0JykgIT0gT2JqZWN0IHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoYXJyYXlKb2luKSksICdBcnJheScsIHtcbiAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3Ipe1xuICAgIHJldHVybiBhcnJheUpvaW4uY2FsbCh0b0lPYmplY3QodGhpcyksIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkID8gJywnIDogc2VwYXJhdG9yKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuam9pbi5qc1xuICoqIG1vZHVsZSBpZCA9IDIzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtZXRob2QsIGFyZyl7XG4gIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyhmdW5jdGlvbigpe1xuICAgIGFyZyA/IG1ldGhvZC5jYWxsKG51bGwsIGZ1bmN0aW9uKCl7fSwgMSkgOiBtZXRob2QuY2FsbChudWxsKTtcbiAgfSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmljdC1tZXRob2QuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBodG1sICAgICAgID0gcmVxdWlyZSgnLi9faHRtbCcpXG4gICwgY29mICAgICAgICA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgdG9JbmRleCAgICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4JylcbiAgLCB0b0xlbmd0aCAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBhcnJheVNsaWNlID0gW10uc2xpY2U7XG5cbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBFUzMgc3RyaW5ncyBhbmQgRE9NIG9iamVjdHNcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICBpZihodG1sKWFycmF5U2xpY2UuY2FsbChodG1sKTtcbn0pLCAnQXJyYXknLCB7XG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShiZWdpbiwgZW5kKXtcbiAgICB2YXIgbGVuICAgPSB0b0xlbmd0aCh0aGlzLmxlbmd0aClcbiAgICAgICwga2xhc3MgPSBjb2YodGhpcyk7XG4gICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQ7XG4gICAgaWYoa2xhc3MgPT0gJ0FycmF5JylyZXR1cm4gYXJyYXlTbGljZS5jYWxsKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgIHZhciBzdGFydCAgPSB0b0luZGV4KGJlZ2luLCBsZW4pXG4gICAgICAsIHVwVG8gICA9IHRvSW5kZXgoZW5kLCBsZW4pXG4gICAgICAsIHNpemUgICA9IHRvTGVuZ3RoKHVwVG8gLSBzdGFydClcbiAgICAgICwgY2xvbmVkID0gQXJyYXkoc2l6ZSlcbiAgICAgICwgaSAgICAgID0gMDtcbiAgICBmb3IoOyBpIDwgc2l6ZTsgaSsrKWNsb25lZFtpXSA9IGtsYXNzID09ICdTdHJpbmcnXG4gICAgICA/IHRoaXMuY2hhckF0KHN0YXJ0ICsgaSlcbiAgICAgIDogdGhpc1tzdGFydCArIGldO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlLmpzXG4gKiogbW9kdWxlIGlkID0gMjM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCB0b09iamVjdCAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGZhaWxzICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCAkc29ydCAgICAgPSBbXS5zb3J0XG4gICwgdGVzdCAgICAgID0gWzEsIDIsIDNdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbigpe1xuICAvLyBJRTgtXG4gIHRlc3Quc29ydCh1bmRlZmluZWQpO1xufSkgfHwgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gIC8vIFY4IGJ1Z1xuICB0ZXN0LnNvcnQobnVsbCk7XG4gIC8vIE9sZCBXZWJLaXRcbn0pIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJHNvcnQpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMjUgQXJyYXkucHJvdG90eXBlLnNvcnQoY29tcGFyZWZuKVxuICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbil7XG4gICAgcmV0dXJuIGNvbXBhcmVmbiA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICRzb3J0LmNhbGwodG9PYmplY3QodGhpcykpXG4gICAgICA6ICRzb3J0LmNhbGwodG9PYmplY3QodGhpcyksIGFGdW5jdGlvbihjb21wYXJlZm4pKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29ydC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZm9yRWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKVxuICAsIFNUUklDVCAgID0gcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmZvckVhY2gsIHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFTVFJJQ1QsICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjEwIC8gMTUuNC40LjE4IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pe1xuICAgIHJldHVybiAkZm9yRWFjaCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMCAtPiBBcnJheSNmb3JFYWNoXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxudmFyIGN0eCAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgYXNjICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUWVBFLCAkY3JlYXRlKXtcbiAgdmFyIElTX01BUCAgICAgICAgPSBUWVBFID09IDFcbiAgICAsIElTX0ZJTFRFUiAgICAgPSBUWVBFID09IDJcbiAgICAsIElTX1NPTUUgICAgICAgPSBUWVBFID09IDNcbiAgICAsIElTX0VWRVJZICAgICAgPSBUWVBFID09IDRcbiAgICAsIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDZcbiAgICAsIE5PX0hPTEVTICAgICAgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWFxuICAgICwgY3JlYXRlICAgICAgICA9ICRjcmVhdGUgfHwgYXNjO1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQpe1xuICAgIHZhciBPICAgICAgPSB0b09iamVjdCgkdGhpcylcbiAgICAgICwgc2VsZiAgID0gSU9iamVjdChPKVxuICAgICAgLCBmICAgICAgPSBjdHgoY2FsbGJhY2tmbiwgdGhhdCwgMylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IDBcbiAgICAgICwgcmVzdWx0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZFxuICAgICAgLCB2YWwsIHJlcztcbiAgICBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpe1xuICAgICAgdmFsID0gc2VsZltpbmRleF07XG4gICAgICByZXMgPSBmKHZhbCwgaW5kZXgsIE8pO1xuICAgICAgaWYoVFlQRSl7XG4gICAgICAgIGlmKElTX01BUClyZXN1bHRbaW5kZXhdID0gcmVzOyAgICAgICAgICAgIC8vIG1hcFxuICAgICAgICBlbHNlIGlmKHJlcylzd2l0Y2goVFlQRSl7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHJlc3VsdC5wdXNoKHZhbCk7ICAgICAgICAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZihJU19FVkVSWSlyZXR1cm4gZmFsc2U7ICAgICAgICAgIC8vIGV2ZXJ5XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiByZXN1bHQ7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDkuNC4yLjMgQXJyYXlTcGVjaWVzQ3JlYXRlKG9yaWdpbmFsQXJyYXksIGxlbmd0aClcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3JpZ2luYWwsIGxlbmd0aCl7XG4gIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbCkpKGxlbmd0aCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMjM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGlzQXJyYXkgID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKVxuICAsIFNQRUNJRVMgID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbCl7XG4gIHZhciBDO1xuICBpZihpc0FycmF5KG9yaWdpbmFsKSl7XG4gICAgQyA9IG9yaWdpbmFsLmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKUMgPSB1bmRlZmluZWQ7XG4gICAgaWYoaXNPYmplY3QoQykpe1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZihDID09PSBudWxsKUMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IHJldHVybiBDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEM7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkbWFwICAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDEpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ubWFwLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTUgLyAxNS40LjQuMTkgQXJyYXkucHJvdG90eXBlLm1hcChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBtYXA6IGZ1bmN0aW9uIG1hcChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLyl7XG4gICAgcmV0dXJuICRtYXAodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkubWFwLmpzXG4gKiogbW9kdWxlIGlkID0gMjQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgyKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmZpbHRlciwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjcgLyAxNS40LjQuMjAgQXJyYXkucHJvdG90eXBlLmZpbHRlcihjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLyl7XG4gICAgcmV0dXJuICRmaWx0ZXIodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsdGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHNvbWUgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgzKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnNvbWUsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4yMyAvIDE1LjQuNC4xNyBBcnJheS5wcm90b3R5cGUuc29tZShjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcbiAgICByZXR1cm4gJHNvbWUodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29tZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRldmVyeSAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNCk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5ldmVyeSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjUgLyAxNS40LjQuMTYgQXJyYXkucHJvdG90eXBlLmV2ZXJ5KGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLyl7XG4gICAgcmV0dXJuICRldmVyeSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5ldmVyeS5qc1xuICoqIG1vZHVsZSBpZCA9IDI0NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRyZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheS1yZWR1Y2UnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnJlZHVjZSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE4IC8gMTUuNC40LjIxIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UoY2FsbGJhY2tmbiBbLCBpbml0aWFsVmFsdWVdKVxuICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKXtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNbMV0sIGZhbHNlKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLmpzXG4gKiogbW9kdWxlIGlkID0gMjQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgdG9PYmplY3QgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICAgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aGF0LCBjYWxsYmFja2ZuLCBhTGVuLCBtZW1vLCBpc1JpZ2h0KXtcbiAgYUZ1bmN0aW9uKGNhbGxiYWNrZm4pO1xuICB2YXIgTyAgICAgID0gdG9PYmplY3QodGhhdClcbiAgICAsIHNlbGYgICA9IElPYmplY3QoTylcbiAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICwgaW5kZXggID0gaXNSaWdodCA/IGxlbmd0aCAtIDEgOiAwXG4gICAgLCBpICAgICAgPSBpc1JpZ2h0ID8gLTEgOiAxO1xuICBpZihhTGVuIDwgMilmb3IoOzspe1xuICAgIGlmKGluZGV4IGluIHNlbGYpe1xuICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleCArPSBpO1xuICAgIGlmKGlzUmlnaHQgPyBpbmRleCA8IDAgOiBsZW5ndGggPD0gaW5kZXgpe1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgfVxuICB9XG4gIGZvcig7aXNSaWdodCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSlpZihpbmRleCBpbiBzZWxmKXtcbiAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICB9XG4gIHJldHVybiBtZW1vO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1yZWR1Y2UuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5yZWR1Y2VSaWdodCwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE5IC8gMTUuNC40LjIyIEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodChjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0pXG4gIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKXtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNbMV0sIHRydWUpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UtcmlnaHQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkaW5kZXhPZiAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSlcbiAgLCAkbmF0aXZlICAgICAgID0gW10uaW5kZXhPZlxuICAsIE5FR0FUSVZFX1pFUk8gPSAhISRuYXRpdmUgJiYgMSAvIFsxXS5pbmRleE9mKDEsIC0wKSA8IDA7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKE5FR0FUSVZFX1pFUk8gfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkbmF0aXZlKSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjExIC8gMTUuNC40LjE0IEFycmF5LnByb3RvdHlwZS5pbmRleE9mKHNlYXJjaEVsZW1lbnQgWywgZnJvbUluZGV4XSlcbiAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggPSAwICovKXtcbiAgICByZXR1cm4gTkVHQVRJVkVfWkVST1xuICAgICAgLy8gY29udmVydCAtMCB0byArMFxuICAgICAgPyAkbmF0aXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMFxuICAgICAgOiAkaW5kZXhPZih0aGlzLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pbmRleC1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDI0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvSU9iamVjdCAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b0ludGVnZXIgICAgID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgdG9MZW5ndGggICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgJG5hdGl2ZSAgICAgICA9IFtdLmxhc3RJbmRleE9mXG4gICwgTkVHQVRJVkVfWkVSTyA9ICEhJG5hdGl2ZSAmJiAxIC8gWzFdLmxhc3RJbmRleE9mKDEsIC0wKSA8IDA7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKE5FR0FUSVZFX1pFUk8gfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkbmF0aXZlKSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE0IC8gMTUuNC40LjE1IEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IFssIGZyb21JbmRleF0pXG4gIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggPSBAWyotMV0gKi8pe1xuICAgIC8vIGNvbnZlcnQgLTAgdG8gKzBcbiAgICBpZihORUdBVElWRV9aRVJPKXJldHVybiAkbmF0aXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMDtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KHRoaXMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSBsZW5ndGggLSAxO1xuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPiAxKWluZGV4ID0gTWF0aC5taW4oaW5kZXgsIHRvSW50ZWdlcihhcmd1bWVudHNbMV0pKTtcbiAgICBpZihpbmRleCA8IDApaW5kZXggPSBsZW5ndGggKyBpbmRleDtcbiAgICBmb3IoO2luZGV4ID49IDA7IGluZGV4LS0paWYoaW5kZXggaW4gTylpZihPW2luZGV4XSA9PT0gc2VhcmNoRWxlbWVudClyZXR1cm4gaW5kZXggfHwgMDtcbiAgICByZXR1cm4gLTE7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtjb3B5V2l0aGluOiByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdjb3B5V2l0aGluJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuY29weS13aXRoaW4uanNcbiAqKiBtb2R1bGUgaWQgPSAyNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b0luZGV4ICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4JylcbiAgLCB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtdLmNvcHlXaXRoaW4gfHwgZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQvKj0gMCovLCBzdGFydC8qPSAwLCBlbmQgPSBAbGVuZ3RoKi8pe1xuICB2YXIgTyAgICAgPSB0b09iamVjdCh0aGlzKVxuICAgICwgbGVuICAgPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAsIHRvICAgID0gdG9JbmRleCh0YXJnZXQsIGxlbilcbiAgICAsIGZyb20gID0gdG9JbmRleChzdGFydCwgbGVuKVxuICAgICwgZW5kICAgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZFxuICAgICwgY291bnQgPSBNYXRoLm1pbigoZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB0b0luZGV4KGVuZCwgbGVuKSkgLSBmcm9tLCBsZW4gLSB0bylcbiAgICAsIGluYyAgID0gMTtcbiAgaWYoZnJvbSA8IHRvICYmIHRvIDwgZnJvbSArIGNvdW50KXtcbiAgICBpbmMgID0gLTE7XG4gICAgZnJvbSArPSBjb3VudCAtIDE7XG4gICAgdG8gICArPSBjb3VudCAtIDE7XG4gIH1cbiAgd2hpbGUoY291bnQtLSA+IDApe1xuICAgIGlmKGZyb20gaW4gTylPW3RvXSA9IE9bZnJvbV07XG4gICAgZWxzZSBkZWxldGUgT1t0b107XG4gICAgdG8gICArPSBpbmM7XG4gICAgZnJvbSArPSBpbmM7XG4gIH0gcmV0dXJuIE87XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWNvcHktd2l0aGluLmpzXG4gKiogbW9kdWxlIGlkID0gMjUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgVU5TQ09QQUJMRVMgPSByZXF1aXJlKCcuL193a3MnKSgndW5zY29wYWJsZXMnKVxuICAsIEFycmF5UHJvdG8gID0gQXJyYXkucHJvdG90eXBlO1xuaWYoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKXJlcXVpcmUoJy4vX2hpZGUnKShBcnJheVByb3RvLCBVTlNDT1BBQkxFUywge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMjUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7ZmlsbDogcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdmaWxsJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsbC5qc1xuICoqIG1vZHVsZSBpZCA9IDI1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvSW5kZXggID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyosIHN0YXJ0ID0gMCwgZW5kID0gQGxlbmd0aCAqLyl7XG4gIHZhciBPICAgICAgPSB0b09iamVjdCh0aGlzKVxuICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgLCBhTGVuICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBpbmRleCAgPSB0b0luZGV4KGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpXG4gICAgLCBlbmQgICAgPSBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZFxuICAgICwgZW5kUG9zID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0luZGV4KGVuZCwgbGVuZ3RoKTtcbiAgd2hpbGUoZW5kUG9zID4gaW5kZXgpT1tpbmRleCsrXSA9IHZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZmlsbC5qc1xuICoqIG1vZHVsZSBpZCA9IDI1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjggQXJyYXkucHJvdG90eXBlLmZpbmQocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmaW5kICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNSlcbiAgLCBLRVkgICAgID0gJ2ZpbmQnXG4gICwgZm9yY2VkICA9IHRydWU7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYoS0VZIGluIFtdKUFycmF5KDEpW0tFWV0oZnVuY3Rpb24oKXsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZDogZnVuY3Rpb24gZmluZChjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoS0VZKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzXG4gKiogbW9kdWxlIGlkID0gMjU1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZmluZCAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDYpXG4gICwgS0VZICAgICA9ICdmaW5kSW5kZXgnXG4gICwgZm9yY2VkICA9IHRydWU7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYoS0VZIGluIFtdKUFycmF5KDEpW0tFWV0oZnVuY3Rpb24oKXsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgoY2FsbGJhY2tmbi8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKEtFWSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDI1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnQXJyYXknKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzLmpzXG4gKiogbW9kdWxlIGlkID0gMjU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGRQICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBTUEVDSUVTICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZKXtcbiAgdmFyIEMgPSBnbG9iYWxbS0VZXTtcbiAgaWYoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSlkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJylcbiAgLCBzdGVwICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJylcbiAgLCBJdGVyYXRvcnMgICAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCB0b0lPYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBraW5kICA9IHRoaXMuX2tcbiAgICAsIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZighTyB8fCBpbmRleCA+PSBPLmxlbmd0aCl7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZG9uZSwgdmFsdWUpe1xuICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1zdGVwLmpzXG4gKiogbW9kdWxlIGlkID0gMjYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2xvYmFsICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpXG4gICwgZFAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgZ09QTiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCBpc1JlZ0V4cCAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpXG4gICwgJGZsYWdzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mbGFncycpXG4gICwgJFJlZ0V4cCAgICAgICAgICAgPSBnbG9iYWwuUmVnRXhwXG4gICwgQmFzZSAgICAgICAgICAgICAgPSAkUmVnRXhwXG4gICwgcHJvdG8gICAgICAgICAgICAgPSAkUmVnRXhwLnByb3RvdHlwZVxuICAsIHJlMSAgICAgICAgICAgICAgID0gL2EvZ1xuICAsIHJlMiAgICAgICAgICAgICAgID0gL2EvZ1xuICAvLyBcIm5ld1wiIGNyZWF0ZXMgYSBuZXcgb2JqZWN0LCBvbGQgd2Via2l0IGJ1Z2d5IGhlcmVcbiAgLCBDT1JSRUNUX05FVyAgICAgICA9IG5ldyAkUmVnRXhwKHJlMSkgIT09IHJlMTtcblxuaWYocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAoIUNPUlJFQ1RfTkVXIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmUyW3JlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpXSA9IGZhbHNlO1xuICAvLyBSZWdFeHAgY29uc3RydWN0b3IgY2FuIGFsdGVyIGZsYWdzIGFuZCBJc1JlZ0V4cCB3b3JrcyBjb3JyZWN0IHdpdGggQEBtYXRjaFxuICByZXR1cm4gJFJlZ0V4cChyZTEpICE9IHJlMSB8fCAkUmVnRXhwKHJlMikgPT0gcmUyIHx8ICRSZWdFeHAocmUxLCAnaScpICE9ICcvYS9pJztcbn0pKSl7XG4gICRSZWdFeHAgPSBmdW5jdGlvbiBSZWdFeHAocCwgZil7XG4gICAgdmFyIHRpUkUgPSB0aGlzIGluc3RhbmNlb2YgJFJlZ0V4cFxuICAgICAgLCBwaVJFID0gaXNSZWdFeHAocClcbiAgICAgICwgZmlVICA9IGYgPT09IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gIXRpUkUgJiYgcGlSRSAmJiBwLmNvbnN0cnVjdG9yID09PSAkUmVnRXhwICYmIGZpVSA/IHBcbiAgICAgIDogaW5oZXJpdElmUmVxdWlyZWQoQ09SUkVDVF9ORVdcbiAgICAgICAgPyBuZXcgQmFzZShwaVJFICYmICFmaVUgPyBwLnNvdXJjZSA6IHAsIGYpXG4gICAgICAgIDogQmFzZSgocGlSRSA9IHAgaW5zdGFuY2VvZiAkUmVnRXhwKSA/IHAuc291cmNlIDogcCwgcGlSRSAmJiBmaVUgPyAkZmxhZ3MuY2FsbChwKSA6IGYpXG4gICAgICAsIHRpUkUgPyB0aGlzIDogcHJvdG8sICRSZWdFeHApO1xuICB9O1xuICB2YXIgcHJveHkgPSBmdW5jdGlvbihrZXkpe1xuICAgIGtleSBpbiAkUmVnRXhwIHx8IGRQKCRSZWdFeHAsIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gQmFzZVtrZXldOyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbihpdCl7IEJhc2Vba2V5XSA9IGl0OyB9XG4gICAgfSk7XG4gIH07XG4gIGZvcih2YXIga2V5cyA9IGdPUE4oQmFzZSksIGkgPSAwOyBrZXlzLmxlbmd0aCA+IGk7IClwcm94eShrZXlzW2krK10pO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICRSZWdFeHA7XG4gICRSZWdFeHAucHJvdG90eXBlID0gcHJvdG87XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCAnUmVnRXhwJywgJFJlZ0V4cCk7XG59XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ1JlZ0V4cCcpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3Rvci5qc1xuICoqIG1vZHVsZSBpZCA9IDI2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpe1xuICB2YXIgdGhhdCAgID0gYW5PYmplY3QodGhpcylcbiAgICAsIHJlc3VsdCA9ICcnO1xuICBpZih0aGF0Lmdsb2JhbCkgICAgIHJlc3VsdCArPSAnZyc7XG4gIGlmKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYodGhhdC5tdWx0aWxpbmUpICByZXN1bHQgKz0gJ20nO1xuICBpZih0aGF0LnVuaWNvZGUpICAgIHJlc3VsdCArPSAndSc7XG4gIGlmKHRoYXQuc3RpY2t5KSAgICAgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4vZXM2LnJlZ2V4cC5mbGFncycpO1xudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCAkZmxhZ3MgICAgICA9IHJlcXVpcmUoJy4vX2ZsYWdzJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBUT19TVFJJTkcgICA9ICd0b1N0cmluZydcbiAgLCAkdG9TdHJpbmcgICA9IC8uL1tUT19TVFJJTkddO1xuXG52YXIgZGVmaW5lID0gZnVuY3Rpb24oZm4pe1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKFJlZ0V4cC5wcm90b3R5cGUsIFRPX1NUUklORywgZm4sIHRydWUpO1xufTtcblxuLy8gMjEuMi41LjE0IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcoKVxuaWYocmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpeyByZXR1cm4gJHRvU3RyaW5nLmNhbGwoe3NvdXJjZTogJ2EnLCBmbGFnczogJ2InfSkgIT0gJy9hL2InOyB9KSl7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHZhciBSID0gYW5PYmplY3QodGhpcyk7XG4gICAgcmV0dXJuICcvJy5jb25jYXQoUi5zb3VyY2UsICcvJyxcbiAgICAgICdmbGFncycgaW4gUiA/IFIuZmxhZ3MgOiAhREVTQ1JJUFRPUlMgJiYgUiBpbnN0YW5jZW9mIFJlZ0V4cCA/ICRmbGFncy5jYWxsKFIpIDogdW5kZWZpbmVkKTtcbiAgfSk7XG4vLyBGRjQ0LSBSZWdFeHAjdG9TdHJpbmcgaGFzIGEgd3JvbmcgbmFtZVxufSBlbHNlIGlmKCR0b1N0cmluZy5uYW1lICE9IFRPX1NUUklORyl7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbiAgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDI2M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3MoKVxuaWYocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAvLi9nLmZsYWdzICE9ICdnJylyZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKFJlZ0V4cC5wcm90b3R5cGUsICdmbGFncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IHJlcXVpcmUoJy4vX2ZsYWdzJylcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncy5qc1xuICoqIG1vZHVsZSBpZCA9IDI2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQEBtYXRjaCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdtYXRjaCcsIDEsIGZ1bmN0aW9uKGRlZmluZWQsIE1BVENILCAkbWF0Y2gpe1xuICAvLyAyMS4xLjMuMTEgU3RyaW5nLnByb3RvdHlwZS5tYXRjaChyZWdleHApXG4gIHJldHVybiBbZnVuY3Rpb24gbWF0Y2gocmVnZXhwKXtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gID0gZGVmaW5lZCh0aGlzKVxuICAgICAgLCBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbTUFUQ0hdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW01BVENIXShTdHJpbmcoTykpO1xuICB9LCAkbWF0Y2hdO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLm1hdGNoLmpzXG4gKiogbW9kdWxlIGlkID0gMjY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgaGlkZSAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBmYWlscyAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBkZWZpbmVkICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIHdrcyAgICAgID0gcmVxdWlyZSgnLi9fd2tzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBsZW5ndGgsIGV4ZWMpe1xuICB2YXIgU1lNQk9MICAgPSB3a3MoS0VZKVxuICAgICwgZm5zICAgICAgPSBleGVjKGRlZmluZWQsIFNZTUJPTCwgJydbS0VZXSlcbiAgICAsIHN0cmZuICAgID0gZm5zWzBdXG4gICAgLCByeGZuICAgICA9IGZuc1sxXTtcbiAgaWYoZmFpbHMoZnVuY3Rpb24oKXtcbiAgICB2YXIgTyA9IHt9O1xuICAgIE9bU1lNQk9MXSA9IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9O1xuICAgIHJldHVybiAnJ1tLRVldKE8pICE9IDc7XG4gIH0pKXtcbiAgICByZWRlZmluZShTdHJpbmcucHJvdG90eXBlLCBLRVksIHN0cmZuKTtcbiAgICBoaWRlKFJlZ0V4cC5wcm90b3R5cGUsIFNZTUJPTCwgbGVuZ3RoID09IDJcbiAgICAgIC8vIDIxLjIuNS44IFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXShzdHJpbmcsIHJlcGxhY2VWYWx1ZSlcbiAgICAgIC8vIDIxLjIuNS4xMSBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdKHN0cmluZywgbGltaXQpXG4gICAgICA/IGZ1bmN0aW9uKHN0cmluZywgYXJnKXsgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMsIGFyZyk7IH1cbiAgICAgIC8vIDIxLjIuNS42IFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF0oc3RyaW5nKVxuICAgICAgLy8gMjEuMi41LjkgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF0oc3RyaW5nKVxuICAgICAgOiBmdW5jdGlvbihzdHJpbmcpeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcyk7IH1cbiAgICApO1xuICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX2ZpeC1yZS13a3MuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIEBAcmVwbGFjZSBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdyZXBsYWNlJywgMiwgZnVuY3Rpb24oZGVmaW5lZCwgUkVQTEFDRSwgJHJlcGxhY2Upe1xuICAvLyAyMS4xLjMuMTQgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpXG4gIHJldHVybiBbZnVuY3Rpb24gcmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKXtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gID0gZGVmaW5lZCh0aGlzKVxuICAgICAgLCBmbiA9IHNlYXJjaFZhbHVlID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlYXJjaFZhbHVlW1JFUExBQ0VdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGZuLmNhbGwoc2VhcmNoVmFsdWUsIE8sIHJlcGxhY2VWYWx1ZSlcbiAgICAgIDogJHJlcGxhY2UuY2FsbChTdHJpbmcoTyksIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICB9LCAkcmVwbGFjZV07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAucmVwbGFjZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI2N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQEBzZWFyY2ggbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnc2VhcmNoJywgMSwgZnVuY3Rpb24oZGVmaW5lZCwgU0VBUkNILCAkc2VhcmNoKXtcbiAgLy8gMjEuMS4zLjE1IFN0cmluZy5wcm90b3R5cGUuc2VhcmNoKHJlZ2V4cClcbiAgcmV0dXJuIFtmdW5jdGlvbiBzZWFyY2gocmVnZXhwKXtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gID0gZGVmaW5lZCh0aGlzKVxuICAgICAgLCBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbU0VBUkNIXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtTRUFSQ0hdKFN0cmluZyhPKSk7XG4gIH0sICRzZWFyY2hdO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaC5qc1xuICoqIG1vZHVsZSBpZCA9IDI2OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQEBzcGxpdCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzcGxpdCcsIDIsIGZ1bmN0aW9uKGRlZmluZWQsIFNQTElULCAkc3BsaXQpe1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBpc1JlZ0V4cCAgID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJylcbiAgICAsIF9zcGxpdCAgICAgPSAkc3BsaXRcbiAgICAsICRwdXNoICAgICAgPSBbXS5wdXNoXG4gICAgLCAkU1BMSVQgICAgID0gJ3NwbGl0J1xuICAgICwgTEVOR1RIICAgICA9ICdsZW5ndGgnXG4gICAgLCBMQVNUX0lOREVYID0gJ2xhc3RJbmRleCc7XG4gIGlmKFxuICAgICdhYmJjJ1skU1BMSVRdKC8oYikqLylbMV0gPT0gJ2MnIHx8XG4gICAgJ3Rlc3QnWyRTUExJVF0oLyg/OikvLCAtMSlbTEVOR1RIXSAhPSA0IHx8XG4gICAgJ2FiJ1skU1BMSVRdKC8oPzphYikqLylbTEVOR1RIXSAhPSAyIHx8XG4gICAgJy4nWyRTUExJVF0oLyguPykoLj8pLylbTEVOR1RIXSAhPSA0IHx8XG4gICAgJy4nWyRTUExJVF0oLygpKCkvKVtMRU5HVEhdID4gMSB8fFxuICAgICcnWyRTUExJVF0oLy4/LylbTEVOR1RIXVxuICApe1xuICAgIHZhciBOUENHID0gLygpPz8vLmV4ZWMoJycpWzFdID09PSB1bmRlZmluZWQ7IC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG4gICAgLy8gYmFzZWQgb24gZXM1LXNoaW0gaW1wbGVtZW50YXRpb24sIG5lZWQgdG8gcmV3b3JrIGl0XG4gICAgJHNwbGl0ID0gZnVuY3Rpb24oc2VwYXJhdG9yLCBsaW1pdCl7XG4gICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuICAgICAgaWYoc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDApcmV0dXJuIFtdO1xuICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgIGlmKCFpc1JlZ0V4cChzZXBhcmF0b3IpKXJldHVybiBfc3BsaXQuY2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgdmFyIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IudW5pY29kZSA/ICd1JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnN0aWNreSA/ICd5JyA6ICcnKTtcbiAgICAgIHZhciBsYXN0TGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBzcGxpdExpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IDQyOTQ5NjcyOTUgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICB2YXIgc2VwYXJhdG9yQ29weSA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgdmFyIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGgsIGk7XG4gICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgIGlmKCFOUENHKXNlcGFyYXRvcjIgPSBuZXcgUmVnRXhwKCdeJyArIHNlcGFyYXRvckNvcHkuc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XG4gICAgICB3aGlsZShtYXRjaCA9IHNlcGFyYXRvckNvcHkuZXhlYyhzdHJpbmcpKXtcbiAgICAgICAgLy8gYHNlcGFyYXRvckNvcHkubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdW0xFTkdUSF07XG4gICAgICAgIGlmKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpe1xuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvciBOUENHXG4gICAgICAgICAgaWYoIU5QQ0cgJiYgbWF0Y2hbTEVOR1RIXSA+IDEpbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgZm9yKGkgPSAxOyBpIDwgYXJndW1lbnRzW0xFTkdUSF0gLSAyOyBpKyspaWYoYXJndW1lbnRzW2ldID09PSB1bmRlZmluZWQpbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYobWF0Y2hbTEVOR1RIXSA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmdbTEVOR1RIXSkkcHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF1bTEVOR1RIXTtcbiAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgIGlmKG91dHB1dFtMRU5HVEhdID49IHNwbGl0TGltaXQpYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYoc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSA9PT0gbWF0Y2guaW5kZXgpc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICB9XG4gICAgICBpZihsYXN0TGFzdEluZGV4ID09PSBzdHJpbmdbTEVOR1RIXSl7XG4gICAgICAgIGlmKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvckNvcHkudGVzdCgnJykpb3V0cHV0LnB1c2goJycpO1xuICAgICAgfSBlbHNlIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICByZXR1cm4gb3V0cHV0W0xFTkdUSF0gPiBzcGxpdExpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIHNwbGl0TGltaXQpIDogb3V0cHV0O1xuICAgIH07XG4gIC8vIENoYWtyYSwgVjhcbiAgfSBlbHNlIGlmKCcwJ1skU1BMSVRdKHVuZGVmaW5lZCwgMClbTEVOR1RIXSl7XG4gICAgJHNwbGl0ID0gZnVuY3Rpb24oc2VwYXJhdG9yLCBsaW1pdCl7XG4gICAgICByZXR1cm4gc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDAgPyBbXSA6IF9zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG4gIH1cbiAgLy8gMjEuMS4zLjE3IFN0cmluZy5wcm90b3R5cGUuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdClcbiAgcmV0dXJuIFtmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KXtcbiAgICB2YXIgTyAgPSBkZWZpbmVkKHRoaXMpXG4gICAgICAsIGZuID0gc2VwYXJhdG9yID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlcGFyYXRvcltTUExJVF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHNlcGFyYXRvciwgTywgbGltaXQpIDogJHNwbGl0LmNhbGwoU3RyaW5nKE8pLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgfSwgJHNwbGl0XTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdC5qc1xuICoqIG1vZHVsZSBpZCA9IDI2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY3R4ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBjbGFzc29mICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCAkZXhwb3J0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGlzT2JqZWN0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5JbnN0YW5jZSAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGZvck9mICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICwgdGFzayAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldFxuICAsIG1pY3JvdGFzayAgICAgICAgICA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKClcbiAgLCBQUk9NSVNFICAgICAgICAgICAgPSAnUHJvbWlzZSdcbiAgLCBUeXBlRXJyb3IgICAgICAgICAgPSBnbG9iYWwuVHlwZUVycm9yXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCAkUHJvbWlzZSAgICAgICAgICAgPSBnbG9iYWxbUFJPTUlTRV1cbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIGlzTm9kZSAgICAgICAgICAgICA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnXG4gICwgZW1wdHkgICAgICAgICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIEludGVybmFsLCBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlICAgICA9ICRQcm9taXNlLnJlc29sdmUoMSlcbiAgICAgICwgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uKGV4ZWMpeyBleGVjKGVtcHR5LCBlbXB0eSk7IH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJykgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBzYW1lQ29uc3RydWN0b3IgPSBmdW5jdGlvbihhLCBiKXtcbiAgLy8gd2l0aCBsaWJyYXJ5IHdyYXBwZXIgc3BlY2lhbCBjYXNlXG4gIHJldHVybiBhID09PSBiIHx8IGEgPT09ICRQcm9taXNlICYmIGIgPT09IFdyYXBwZXI7XG59O1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHJldHVybiBzYW1lQ29uc3RydWN0b3IoJFByb21pc2UsIEMpXG4gICAgPyBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICA6IG5ldyBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uKCQkcmVzb2x2ZSwgJCRyZWplY3Qpe1xuICAgIGlmKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ICA9IGFGdW5jdGlvbihyZWplY3QpO1xufTtcbnZhciBwZXJmb3JtID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB7ZXJyb3I6IGV9O1xuICB9XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uKHByb21pc2UsIGlzUmVqZWN0KXtcbiAgaWYocHJvbWlzZS5fbilyZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92XG4gICAgICAsIG9rICAgID0gcHJvbWlzZS5fcyA9PSAxXG4gICAgICAsIGkgICAgID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24ocmVhY3Rpb24pe1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbFxuICAgICAgICAsIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlXG4gICAgICAgICwgcmVqZWN0ICA9IHJlYWN0aW9uLnJlamVjdFxuICAgICAgICAsIGRvbWFpbiAgPSByZWFjdGlvbi5kb21haW5cbiAgICAgICAgLCByZXN1bHQsIHRoZW47XG4gICAgICB0cnkge1xuICAgICAgICBpZihoYW5kbGVyKXtcbiAgICAgICAgICBpZighb2spe1xuICAgICAgICAgICAgaWYocHJvbWlzZS5faCA9PSAyKW9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGhhbmRsZXIgPT09IHRydWUpcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZihkb21haW4pZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmKGRvbWFpbilkb21haW4uZXhpdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2Upe1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSl7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSlydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZihpc1JlamVjdCAmJiAhcHJvbWlzZS5faClvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdlxuICAgICAgLCBhYnJ1cHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYoaXNVbmhhbmRsZWQocHJvbWlzZSkpe1xuICAgICAgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgICBpZihpc05vZGUpe1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbil7XG4gICAgICAgICAgaGFuZGxlcih7cHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZX0pO1xuICAgICAgICB9IGVsc2UgaWYoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcil7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmKGFicnVwdCl0aHJvdyBhYnJ1cHQuZXJyb3I7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICBpZihwcm9taXNlLl9oID09IDEpcmV0dXJuIGZhbHNlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9hIHx8IHByb21pc2UuX2NcbiAgICAsIGkgICAgID0gMFxuICAgICwgcmVhY3Rpb247XG4gIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpe1xuICAgIHJlYWN0aW9uID0gY2hhaW5baSsrXTtcbiAgICBpZihyZWFjdGlvbi5mYWlsIHx8ICFpc1VuaGFuZGxlZChyZWFjdGlvbi5wcm9taXNlKSlyZXR1cm4gZmFsc2U7XG4gIH0gcmV0dXJuIHRydWU7XG59O1xudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYoaXNOb2RlKXtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZihoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCl7XG4gICAgICBoYW5kbGVyKHtwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHByb21pc2UuX3Z9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmKHByb21pc2UuX2QpcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmKCFwcm9taXNlLl9hKXByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciBwcm9taXNlID0gdGhpc1xuICAgICwgdGhlbjtcbiAgaWYocHJvbWlzZS5fZClyZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZihwcm9taXNlID09PSB2YWx1ZSl0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZih0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpe1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB3cmFwcGVyID0ge193OiBwcm9taXNlLCBfZDogZmFsc2V9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2goZSl7XG4gICAgJHJlamVjdC5jYWxsKHtfdzogcHJvbWlzZSwgX2Q6IGZhbHNlfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmKCFVU0VfTkFUSVZFKXtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaChlcnIpe1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpKCRQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCl7XG4gICAgICB2YXIgcmVhY3Rpb24gICAgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rICAgICA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCAgID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fYSl0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fcylub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpe1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcHJvbWlzZSAgPSBuZXcgSW50ZXJuYWw7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ICA9IGN0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1Byb21pc2U6ICRQcm9taXNlfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpe1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZWplY3QgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCl7XG4gICAgLy8gaW5zdGFuY2VvZiBpbnN0ZWFkIG9mIGludGVybmFsIHNsb3QgY2hlY2sgYmVjYXVzZSB3ZSBzaG91bGQgZml4IGl0IHdpdGhvdXQgcmVwbGFjZW1lbnQgbmF0aXZlIFByb21pc2UgY29yZVxuICAgIGlmKHggaW5zdGFuY2VvZiAkUHJvbWlzZSAmJiBzYW1lQ29uc3RydWN0b3IoeC5jb25zdHJ1Y3RvciwgdGhpcykpcmV0dXJuIHg7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlc29sdmUgID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgICQkcmVzb2x2ZSh4KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IHRoaXNcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlc29sdmUgICAgPSBjYXBhYmlsaXR5LnJlc29sdmVcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdmFsdWVzICAgID0gW11cbiAgICAgICAgLCBpbmRleCAgICAgPSAwXG4gICAgICAgICwgcmVtYWluaW5nID0gMTtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIHZhciAkaW5kZXggICAgICAgID0gaW5kZXgrK1xuICAgICAgICAgICwgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIGlmKGFscmVhZHlDYWxsZWQpcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpe1xuICAgIHZhciBDICAgICAgICAgID0gdGhpc1xuICAgICAgLCBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucHJvbWlzZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKXtcbiAgaWYoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSB8fCAoZm9yYmlkZGVuRmllbGQgIT09IHVuZGVmaW5lZCAmJiBmb3JiaWRkZW5GaWVsZCBpbiBpdCkpe1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19hbi1pbnN0YW5jZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI3MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGN0eCAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBjYWxsICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpXG4gICwgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJylcbiAgLCBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9MZW5ndGggICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGdldEl0ZXJGbiAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKVxuICAsIEJSRUFLICAgICAgID0ge31cbiAgLCBSRVRVUk4gICAgICA9IHt9O1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCwgSVRFUkFUT1Ipe1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbigpeyByZXR1cm4gaXRlcmFibGU7IH0gOiBnZXRJdGVyRm4oaXRlcmFibGUpXG4gICAgLCBmICAgICAgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSlcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3IsIHJlc3VsdDtcbiAgaWYodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYoaXNBcnJheUl0ZXIoaXRlckZuKSlmb3IobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgIHJlc3VsdCA9IGVudHJpZXMgPyBmKGFuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKSA6IGYoaXRlcmFibGVbaW5kZXhdKTtcbiAgICBpZihyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKXJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgKXtcbiAgICByZXN1bHQgPSBjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKTtcbiAgICBpZihyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKXJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5leHBvcnRzLkJSRUFLICA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fZm9yLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gMjcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcbnZhciBhbk9iamVjdCAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIFNQRUNJRVMgICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE8sIEQpe1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yLCBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAyNzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjdHggICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGludm9rZSAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ludm9rZScpXG4gICwgaHRtbCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faHRtbCcpXG4gICwgY2VsICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpXG4gICwgZ2xvYmFsICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIHNldFRhc2sgICAgICAgICAgICA9IGdsb2JhbC5zZXRJbW1lZGlhdGVcbiAgLCBjbGVhclRhc2sgICAgICAgICAgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGVcbiAgLCBNZXNzYWdlQ2hhbm5lbCAgICAgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWxcbiAgLCBjb3VudGVyICAgICAgICAgICAgPSAwXG4gICwgcXVldWUgICAgICAgICAgICAgID0ge31cbiAgLCBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJ1xuICAsIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpZCA9ICt0aGlzO1xuICBpZihxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpe1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCl7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spe1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKXtcbiAgICB2YXIgYXJncyA9IFtdLCBpID0gMTtcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbigpe1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKXtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZihNZXNzYWdlQ2hhbm5lbCl7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbDtcbiAgICBwb3J0ICAgID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0Jykpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6ICAgc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL190YXNrLmpzXG4gKiogbW9kdWxlIGlkID0gMjc0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBtYWNyb3Rhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0XG4gICwgT2JzZXJ2ZXIgID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXJcbiAgLCBwcm9jZXNzICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIFByb21pc2UgICA9IGdsb2JhbC5Qcm9taXNlXG4gICwgaXNOb2RlICAgID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZihpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSlwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlKGhlYWQpe1xuICAgICAgZm4gICA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIGlmKGhlYWQpbm90aWZ5KCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYocGFyZW50KXBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYoaXNOb2RlKXtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyXG4gIH0gZWxzZSBpZihPYnNlcnZlcil7XG4gICAgdmFyIHRvZ2dsZSA9IHRydWVcbiAgICAgICwgbm9kZSAgID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZihQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSl7XG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oZm4pe1xuICAgIHZhciB0YXNrID0ge2ZuOiBmbiwgbmV4dDogdW5kZWZpbmVkfTtcbiAgICBpZihsYXN0KWxhc3QubmV4dCA9IHRhc2s7XG4gICAgaWYoIWhlYWQpe1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9IGxhc3QgPSB0YXNrO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19taWNyb3Rhc2suanNcbiAqKiBtb2R1bGUgaWQgPSAyNzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldCwgc3JjLCBzYWZlKXtcbiAgZm9yKHZhciBrZXkgaW4gc3JjKXJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgc2FmZSk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qc1xuICoqIG1vZHVsZSBpZCA9IDI3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIDIzLjEgTWFwIE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKCdNYXAnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gTWFwKCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSl7XG4gICAgdmFyIGVudHJ5ID0gc3Ryb25nLmdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnY7XG4gIH0sXG4gIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpe1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nLCB0cnVlKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXAuanNcbiAqKiBtb2R1bGUgaWQgPSAyNzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBjcmVhdGUgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBjdHggICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgYW5JbnN0YW5jZSAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgZGVmaW5lZCAgICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCBmb3JPZiAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgJGl0ZXJEZWZpbmUgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpXG4gICwgc3RlcCAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKVxuICAsIHNldFNwZWNpZXMgID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKVxuICAsIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsIGZhc3RLZXkgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLmZhc3RLZXlcbiAgLCBTSVpFICAgICAgICA9IERFU0NSSVBUT1JTID8gJ19zJyA6ICdzaXplJztcblxudmFyIGdldEVudHJ5ID0gZnVuY3Rpb24odGhhdCwga2V5KXtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KSwgZW50cnk7XG4gIGlmKGluZGV4ICE9PSAnRicpcmV0dXJuIHRoYXQuX2lbaW5kZXhdO1xuICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgZm9yKGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgaWYoZW50cnkuayA9PSBrZXkpcmV0dXJuIGVudHJ5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpe1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBpdGVyYWJsZSl7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5faSA9IGNyZWF0ZShudWxsKTsgLy8gaW5kZXhcbiAgICAgIHRoYXQuX2YgPSB1bmRlZmluZWQ7ICAgIC8vIGZpcnN0IGVudHJ5XG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAgICAvLyBsYXN0IGVudHJ5XG4gICAgICB0aGF0W1NJWkVdID0gMDsgICAgICAgICAvLyBzaXplXG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCl7XG4gICAgICAgIGZvcih2YXIgdGhhdCA9IHRoaXMsIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pe1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmKGVudHJ5LnApZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgdmFyIHRoYXQgID0gdGhpc1xuICAgICAgICAgICwgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZihlbnRyeSl7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uXG4gICAgICAgICAgICAsIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmKHByZXYpcHJldi5uID0gbmV4dDtcbiAgICAgICAgICBpZihuZXh0KW5leHQucCA9IHByZXY7XG4gICAgICAgICAgaWYodGhhdC5fZiA9PSBlbnRyeSl0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZih0aGF0Ll9sID09IGVudHJ5KXRoYXQuX2wgPSBwcmV2O1xuICAgICAgICAgIHRoYXRbU0laRV0tLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGlzLCBDLCAnZm9yRWFjaCcpO1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMylcbiAgICAgICAgICAsIGVudHJ5O1xuICAgICAgICB3aGlsZShlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXMuX2Ype1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUoZW50cnkgJiYgZW50cnkucillbnRyeSA9IGVudHJ5LnA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSl7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYoREVTQ1JJUFRPUlMpZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gZGVmaW5lZCh0aGlzW1NJWkVdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbih0aGF0LCBrZXksIHZhbHVlKXtcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpXG4gICAgICAsIHByZXYsIGluZGV4O1xuICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgIGlmKGVudHJ5KXtcbiAgICAgIGVudHJ5LnYgPSB2YWx1ZTtcbiAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX2wgPSBlbnRyeSA9IHtcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksIC8vIDwtIGluZGV4XG4gICAgICAgIGs6IGtleSwgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBrZXlcbiAgICAgICAgdjogdmFsdWUsICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICAgIHA6IHByZXYgPSB0aGF0Ll9sLCAgICAgICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxuICAgICAgICBuOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgLy8gPC0gbmV4dCBlbnRyeVxuICAgICAgICByOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gcmVtb3ZlZFxuICAgICAgfTtcbiAgICAgIGlmKCF0aGF0Ll9mKXRoYXQuX2YgPSBlbnRyeTtcbiAgICAgIGlmKHByZXYpcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7XG4gICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgIGlmKGluZGV4ICE9PSAnRicpdGhhdC5faVtpbmRleF0gPSBlbnRyeTtcbiAgICB9IHJldHVybiB0aGF0O1xuICB9LFxuICBnZXRFbnRyeTogZ2V0RW50cnksXG4gIHNldFN0cm9uZzogZnVuY3Rpb24oQywgTkFNRSwgSVNfTUFQKXtcbiAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cbiAgICAvLyAyMy4xLjMuNCwgMjMuMS4zLjgsIDIzLjEuMy4xMSwgMjMuMS4zLjEyLCAyMy4yLjMuNSwgMjMuMi4zLjgsIDIzLjIuMy4xMCwgMjMuMi4zLjExXG4gICAgJGl0ZXJEZWZpbmUoQywgTkFNRSwgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICAgICAgdGhpcy5fdCA9IGl0ZXJhdGVkOyAgLy8gdGFyZ2V0XG4gICAgICB0aGlzLl9rID0ga2luZDsgICAgICAvLyBraW5kXG4gICAgICB0aGlzLl9sID0gdW5kZWZpbmVkOyAvLyBwcmV2aW91c1xuICAgIH0sIGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdGhhdCAgPSB0aGlzXG4gICAgICAgICwga2luZCAgPSB0aGF0Ll9rXG4gICAgICAgICwgZW50cnkgPSB0aGF0Ll9sO1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcbiAgICAgIC8vIGdldCBuZXh0IGVudHJ5XG4gICAgICBpZighdGhhdC5fdCB8fCAhKHRoYXQuX2wgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoYXQuX3QuX2YpKXtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgdGhhdC5fdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHN0ZXAoMSk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGVudHJ5LmspO1xuICAgICAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBlbnRyeS52KTtcbiAgICAgIHJldHVybiBzdGVwKDAsIFtlbnRyeS5rLCBlbnRyeS52XSk7XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycgLCAhSVNfTUFQLCB0cnVlKTtcblxuICAgIC8vIGFkZCBbQEBzcGVjaWVzXSwgMjMuMS4yLjIsIDIzLjIuMi4yXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXN0cm9uZy5qc1xuICoqIG1vZHVsZSBpZCA9IDI3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCAkZXhwb3J0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgcmVkZWZpbmVBbGwgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIG1ldGEgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpXG4gICwgZm9yT2YgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIGFuSW5zdGFuY2UgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGlzT2JqZWN0ICAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBmYWlscyAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCAkaXRlckRldGVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JylcbiAgLCBzZXRUb1N0cmluZ1RhZyAgICA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSyl7XG4gIHZhciBCYXNlICA9IGdsb2JhbFtOQU1FXVxuICAgICwgQyAgICAgPSBCYXNlXG4gICAgLCBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCdcbiAgICAsIHByb3RvID0gQyAmJiBDLnByb3RvdHlwZVxuICAgICwgTyAgICAgPSB7fTtcbiAgdmFyIGZpeE1ldGhvZCA9IGZ1bmN0aW9uKEtFWSl7XG4gICAgdmFyIGZuID0gcHJvdG9bS0VZXTtcbiAgICByZWRlZmluZShwcm90bywgS0VZLFxuICAgICAgS0VZID09ICdkZWxldGUnID8gZnVuY3Rpb24oYSl7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnaGFzJyA/IGZ1bmN0aW9uIGhhcyhhKXtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gZmFsc2UgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdnZXQnID8gZnVuY3Rpb24gZ2V0KGEpe1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyB1bmRlZmluZWQgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdhZGQnID8gZnVuY3Rpb24gYWRkKGEpeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7IHJldHVybiB0aGlzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gc2V0KGEsIGIpeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSwgYik7IHJldHVybiB0aGlzOyB9XG4gICAgKTtcbiAgfTtcbiAgaWYodHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgcHJvdG8uZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgQygpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSl7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICBtZXRhLk5FRUQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBpbnN0YW5jZSAgICAgICAgICAgICA9IG5ldyBDXG4gICAgICAvLyBlYXJseSBpbXBsZW1lbnRhdGlvbnMgbm90IHN1cHBvcnRzIGNoYWluaW5nXG4gICAgICAsIEhBU05UX0NIQUlOSU5HICAgICAgID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZVxuICAgICAgLy8gVjggfiAgQ2hyb21pdW0gNDAtIHdlYWstY29sbGVjdGlvbnMgdGhyb3dzIG9uIHByaW1pdGl2ZXMsIGJ1dCBzaG91bGQgcmV0dXJuIGZhbHNlXG4gICAgICAsIFRIUk9XU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24oKXsgaW5zdGFuY2UuaGFzKDEpOyB9KVxuICAgICAgLy8gbW9zdCBlYXJseSBpbXBsZW1lbnRhdGlvbnMgZG9lc24ndCBzdXBwb3J0cyBpdGVyYWJsZXMsIG1vc3QgbW9kZXJuIC0gbm90IGNsb3NlIGl0IGNvcnJlY3RseVxuICAgICAgLCBBQ0NFUFRfSVRFUkFCTEVTICAgICA9ICRpdGVyRGV0ZWN0KGZ1bmN0aW9uKGl0ZXIpeyBuZXcgQyhpdGVyKTsgfSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxuICAgICAgLCBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gVjggfiBDaHJvbWl1bSA0Mi0gZmFpbHMgb25seSB3aXRoIDUrIGVsZW1lbnRzXG4gICAgICAgIHZhciAkaW5zdGFuY2UgPSBuZXcgQygpXG4gICAgICAgICAgLCBpbmRleCAgICAgPSA1O1xuICAgICAgICB3aGlsZShpbmRleC0tKSRpbnN0YW5jZVtBRERFUl0oaW5kZXgsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuICEkaW5zdGFuY2UuaGFzKC0wKTtcbiAgICAgIH0pO1xuICAgIGlmKCFBQ0NFUFRfSVRFUkFCTEVTKXsgXG4gICAgICBDID0gd3JhcHBlcihmdW5jdGlvbih0YXJnZXQsIGl0ZXJhYmxlKXtcbiAgICAgICAgYW5JbnN0YW5jZSh0YXJnZXQsIEMsIE5BTUUpO1xuICAgICAgICB2YXIgdGhhdCA9IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBCYXNlLCB0YXJnZXQsIEMpO1xuICAgICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICAgIH0pO1xuICAgICAgQy5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgIHByb3RvLmNvbnN0cnVjdG9yID0gQztcbiAgICB9XG4gICAgaWYoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTyl7XG4gICAgICBmaXhNZXRob2QoJ2RlbGV0ZScpO1xuICAgICAgZml4TWV0aG9kKCdoYXMnKTtcbiAgICAgIElTX01BUCAmJiBmaXhNZXRob2QoJ2dldCcpO1xuICAgIH1cbiAgICBpZihCVUdHWV9aRVJPIHx8IEhBU05UX0NIQUlOSU5HKWZpeE1ldGhvZChBRERFUik7XG4gICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcbiAgICBpZihJU19XRUFLICYmIHByb3RvLmNsZWFyKWRlbGV0ZSBwcm90by5jbGVhcjtcbiAgfVxuXG4gIHNldFRvU3RyaW5nVGFnKEMsIE5BTUUpO1xuXG4gIE9bTkFNRV0gPSBDO1xuICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChDICE9IEJhc2UpLCBPKTtcblxuICBpZighSVNfV0VBSyljb21tb24uc2V0U3Ryb25nKEMsIE5BTUUsIElTX01BUCk7XG5cbiAgcmV0dXJuIEM7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAyNzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xuXG4vLyAyMy4yIFNldCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKSgnU2V0JywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFNldCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKXtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih0aGlzLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc2V0LmpzXG4gKiogbW9kdWxlIGlkID0gMjgwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgZWFjaCAgICAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApXG4gICwgcmVkZWZpbmUgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIG1ldGEgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKVxuICAsIGFzc2lnbiAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKVxuICAsIHdlYWsgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24td2VhaycpXG4gICwgaXNPYmplY3QgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBnZXRXZWFrICAgICAgPSBtZXRhLmdldFdlYWtcbiAgLCBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlXG4gICwgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IHdlYWsudWZzdG9yZVxuICAsIHRtcCAgICAgICAgICA9IHt9XG4gICwgSW50ZXJuYWxNYXA7XG5cbnZhciB3cmFwcGVyID0gZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtNYXAoKXtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgfTtcbn07XG5cbnZhciBtZXRob2RzID0ge1xuICAvLyAyMy4zLjMuMyBXZWFrTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpe1xuICAgIGlmKGlzT2JqZWN0KGtleSkpe1xuICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICBpZihkYXRhID09PSB0cnVlKXJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHRoaXMpLmdldChrZXkpO1xuICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhW3RoaXMuX2ldIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSxcbiAgLy8gMjMuMy4zLjUgV2Vha01hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpe1xuICAgIHJldHVybiB3ZWFrLmRlZih0aGlzLCBrZXksIHZhbHVlKTtcbiAgfVxufTtcblxuLy8gMjMuMyBXZWFrTWFwIE9iamVjdHNcbnZhciAkV2Vha01hcCA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKCdXZWFrTWFwJywgd3JhcHBlciwgbWV0aG9kcywgd2VhaywgdHJ1ZSwgdHJ1ZSk7XG5cbi8vIElFMTEgV2Vha01hcCBmcm96ZW4ga2V5cyBmaXhcbmlmKG5ldyAkV2Vha01hcCgpLnNldCgoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHRtcCksIDcpLmdldCh0bXApICE9IDcpe1xuICBJbnRlcm5hbE1hcCA9IHdlYWsuZ2V0Q29uc3RydWN0b3Iod3JhcHBlcik7XG4gIGFzc2lnbihJbnRlcm5hbE1hcC5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICBtZXRhLk5FRUQgPSB0cnVlO1xuICBlYWNoKFsnZGVsZXRlJywgJ2hhcycsICdnZXQnLCAnc2V0J10sIGZ1bmN0aW9uKGtleSl7XG4gICAgdmFyIHByb3RvICA9ICRXZWFrTWFwLnByb3RvdHlwZVxuICAgICAgLCBtZXRob2QgPSBwcm90b1trZXldO1xuICAgIHJlZGVmaW5lKHByb3RvLCBrZXksIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgLy8gc3RvcmUgZnJvemVuIG9iamVjdHMgb24gaW50ZXJuYWwgd2Vha21hcCBzaGltXG4gICAgICBpZihpc09iamVjdChhKSAmJiAhaXNFeHRlbnNpYmxlKGEpKXtcbiAgICAgICAgaWYoIXRoaXMuX2YpdGhpcy5fZiA9IG5ldyBJbnRlcm5hbE1hcDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2Zba2V5XShhLCBiKTtcbiAgICAgICAgcmV0dXJuIGtleSA9PSAnc2V0JyA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICAvLyBzdG9yZSBhbGwgdGhlIHJlc3Qgb24gbmF0aXZlIHdlYWttYXBcbiAgICAgIH0gcmV0dXJuIG1ldGhvZC5jYWxsKHRoaXMsIGEsIGIpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLW1hcC5qc1xuICoqIG1vZHVsZSBpZCA9IDI4MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlZGVmaW5lQWxsICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBnZXRXZWFrICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5nZXRXZWFrXG4gICwgYW5PYmplY3QgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGlzT2JqZWN0ICAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBhbkluc3RhbmNlICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBmb3JPZiAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgY3JlYXRlQXJyYXlNZXRob2QgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJylcbiAgLCAkaGFzICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgYXJyYXlGaW5kICAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCg1KVxuICAsIGFycmF5RmluZEluZGV4ICAgID0gY3JlYXRlQXJyYXlNZXRob2QoNilcbiAgLCBpZCAgICAgICAgICAgICAgICA9IDA7XG5cbi8vIGZhbGxiYWNrIGZvciB1bmNhdWdodCBmcm96ZW4ga2V5c1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbih0aGF0KXtcbiAgcmV0dXJuIHRoYXQuX2wgfHwgKHRoYXQuX2wgPSBuZXcgVW5jYXVnaHRGcm96ZW5TdG9yZSk7XG59O1xudmFyIFVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbigpe1xuICB0aGlzLmEgPSBbXTtcbn07XG52YXIgZmluZFVuY2F1Z2h0RnJvemVuID0gZnVuY3Rpb24oc3RvcmUsIGtleSl7XG4gIHJldHVybiBhcnJheUZpbmQoc3RvcmUuYSwgZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICB9KTtcbn07XG5VbmNhdWdodEZyb3plblN0b3JlLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbihrZXkpe1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmKGVudHJ5KXJldHVybiBlbnRyeVsxXTtcbiAgfSxcbiAgaGFzOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmKGVudHJ5KWVudHJ5WzFdID0gdmFsdWU7XG4gICAgZWxzZSB0aGlzLmEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9LFxuICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICB2YXIgaW5kZXggPSBhcnJheUZpbmRJbmRleCh0aGlzLmEsIGZ1bmN0aW9uKGl0KXtcbiAgICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICAgIH0pO1xuICAgIGlmKH5pbmRleCl0aGlzLmEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gISF+aW5kZXg7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24od3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUil7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGl0ZXJhYmxlKXtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll9pID0gaWQrKzsgICAgICAvLyBjb2xsZWN0aW9uIGlkXG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAvLyBsZWFrIHN0b3JlIGZvciB1bmNhdWdodCBmcm96ZW4gb2JqZWN0c1xuICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMy4zLjIgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjQuMy4zIFdlYWtTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgICBpZighaXNPYmplY3Qoa2V5KSlyZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZihkYXRhID09PSB0cnVlKXJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHRoaXMpWydkZWxldGUnXShrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpICYmIGRlbGV0ZSBkYXRhW3RoaXMuX2ldO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjMuMy40IFdlYWtNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy40LjMuNCBXZWFrU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpe1xuICAgICAgICBpZighaXNPYmplY3Qoa2V5KSlyZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZihkYXRhID09PSB0cnVlKXJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHRoaXMpLmhhcyhrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uKHRoYXQsIGtleSwgdmFsdWUpe1xuICAgIHZhciBkYXRhID0gZ2V0V2Vhayhhbk9iamVjdChrZXkpLCB0cnVlKTtcbiAgICBpZihkYXRhID09PSB0cnVlKXVuY2F1Z2h0RnJvemVuU3RvcmUodGhhdCkuc2V0KGtleSwgdmFsdWUpO1xuICAgIGVsc2UgZGF0YVt0aGF0Ll9pXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGF0O1xuICB9LFxuICB1ZnN0b3JlOiB1bmNhdWdodEZyb3plblN0b3JlXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24td2Vhay5qc1xuICoqIG1vZHVsZSBpZCA9IDI4MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHdlYWsgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKTtcblxuLy8gMjMuNCBXZWFrU2V0IE9iamVjdHNcbnJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKSgnV2Vha1NldCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrU2V0KCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy40LjMuMSBXZWFrU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKXtcbiAgICByZXR1cm4gd2Vhay5kZWYodGhpcywgdmFsdWUsIHRydWUpO1xuICB9XG59LCB3ZWFrLCBmYWxzZSwgdHJ1ZSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1zZXQuanNcbiAqKiBtb2R1bGUgaWQgPSAyODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICR0eXBlZCAgICAgICA9IHJlcXVpcmUoJy4vX3R5cGVkJylcbiAgLCBidWZmZXIgICAgICAgPSByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKVxuICAsIGFuT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9JbmRleCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIHRvTGVuZ3RoICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgaXNPYmplY3QgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBBcnJheUJ1ZmZlciAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5BcnJheUJ1ZmZlclxuICAsIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKVxuICAsICRBcnJheUJ1ZmZlciA9IGJ1ZmZlci5BcnJheUJ1ZmZlclxuICAsICREYXRhVmlldyAgICA9IGJ1ZmZlci5EYXRhVmlld1xuICAsICRpc1ZpZXcgICAgICA9ICR0eXBlZC5BQlYgJiYgQXJyYXlCdWZmZXIuaXNWaWV3XG4gICwgJHNsaWNlICAgICAgID0gJEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZVxuICAsIFZJRVcgICAgICAgICA9ICR0eXBlZC5WSUVXXG4gICwgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoQXJyYXlCdWZmZXIgIT09ICRBcnJheUJ1ZmZlciksIHtBcnJheUJ1ZmZlcjogJEFycmF5QnVmZmVyfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISR0eXBlZC5DT05TVFIsIEFSUkFZX0JVRkZFUiwge1xuICAvLyAyNC4xLjMuMSBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJnKVxuICBpc1ZpZXc6IGZ1bmN0aW9uIGlzVmlldyhpdCl7XG4gICAgcmV0dXJuICRpc1ZpZXcgJiYgJGlzVmlldyhpdCkgfHwgaXNPYmplY3QoaXQpICYmIFZJRVcgaW4gaXQ7XG4gIH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuVSArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuICFuZXcgJEFycmF5QnVmZmVyKDIpLnNsaWNlKDEsIHVuZGVmaW5lZCkuYnl0ZUxlbmd0aDtcbn0pLCBBUlJBWV9CVUZGRVIsIHtcbiAgLy8gMjQuMS40LjMgQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKXtcbiAgICBpZigkc2xpY2UgIT09IHVuZGVmaW5lZCAmJiBlbmQgPT09IHVuZGVmaW5lZClyZXR1cm4gJHNsaWNlLmNhbGwoYW5PYmplY3QodGhpcyksIHN0YXJ0KTsgLy8gRkYgZml4XG4gICAgdmFyIGxlbiAgICA9IGFuT2JqZWN0KHRoaXMpLmJ5dGVMZW5ndGhcbiAgICAgICwgZmlyc3QgID0gdG9JbmRleChzdGFydCwgbGVuKVxuICAgICAgLCBmaW5hbCAgPSB0b0luZGV4KGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogZW5kLCBsZW4pXG4gICAgICAsIHJlc3VsdCA9IG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRBcnJheUJ1ZmZlcikpKHRvTGVuZ3RoKGZpbmFsIC0gZmlyc3QpKVxuICAgICAgLCB2aWV3UyAgPSBuZXcgJERhdGFWaWV3KHRoaXMpXG4gICAgICAsIHZpZXdUICA9IG5ldyAkRGF0YVZpZXcocmVzdWx0KVxuICAgICAgLCBpbmRleCAgPSAwO1xuICAgIHdoaWxlKGZpcnN0IDwgZmluYWwpe1xuICAgICAgdmlld1Quc2V0VWludDgoaW5kZXgrKywgdmlld1MuZ2V0VWludDgoZmlyc3QrKykpO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoQVJSQVlfQlVGRkVSKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5hcnJheS1idWZmZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyODRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgVFlQRUQgID0gdWlkKCd0eXBlZF9hcnJheScpXG4gICwgVklFVyAgID0gdWlkKCd2aWV3JylcbiAgLCBBQlYgICAgPSAhIShnbG9iYWwuQXJyYXlCdWZmZXIgJiYgZ2xvYmFsLkRhdGFWaWV3KVxuICAsIENPTlNUUiA9IEFCVlxuICAsIGkgPSAwLCBsID0gOSwgVHlwZWQ7XG5cbnZhciBUeXBlZEFycmF5Q29uc3RydWN0b3JzID0gKFxuICAnSW50OEFycmF5LFVpbnQ4QXJyYXksVWludDhDbGFtcGVkQXJyYXksSW50MTZBcnJheSxVaW50MTZBcnJheSxJbnQzMkFycmF5LFVpbnQzMkFycmF5LEZsb2F0MzJBcnJheSxGbG9hdDY0QXJyYXknXG4pLnNwbGl0KCcsJyk7XG5cbndoaWxlKGkgPCBsKXtcbiAgaWYoVHlwZWQgPSBnbG9iYWxbVHlwZWRBcnJheUNvbnN0cnVjdG9yc1tpKytdXSl7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFRZUEVELCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkLnByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gIH0gZWxzZSBDT05TVFIgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFCVjogICAgQUJWLFxuICBDT05TVFI6IENPTlNUUixcbiAgVFlQRUQ6ICBUWVBFRCxcbiAgVklFVzogICBWSUVXXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLmpzXG4gKiogbW9kdWxlIGlkID0gMjg1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIERFU0NSSVBUT1JTICAgID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgJHR5cGVkICAgICAgICAgPSByZXF1aXJlKCcuL190eXBlZCcpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCByZWRlZmluZUFsbCAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgZmFpbHMgICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgYW5JbnN0YW5jZSAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgdG9JbnRlZ2VyICAgICAgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCB0b0xlbmd0aCAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgZ09QTiAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCBkUCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBhcnJheUZpbGwgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIEFSUkFZX0JVRkZFUiAgID0gJ0FycmF5QnVmZmVyJ1xuICAsIERBVEFfVklFVyAgICAgID0gJ0RhdGFWaWV3J1xuICAsIFBST1RPVFlQRSAgICAgID0gJ3Byb3RvdHlwZSdcbiAgLCBXUk9OR19MRU5HVEggICA9ICdXcm9uZyBsZW5ndGghJ1xuICAsIFdST05HX0lOREVYICAgID0gJ1dyb25nIGluZGV4ISdcbiAgLCAkQXJyYXlCdWZmZXIgICA9IGdsb2JhbFtBUlJBWV9CVUZGRVJdXG4gICwgJERhdGFWaWV3ICAgICAgPSBnbG9iYWxbREFUQV9WSUVXXVxuICAsIE1hdGggICAgICAgICAgID0gZ2xvYmFsLk1hdGhcbiAgLCBSYW5nZUVycm9yICAgICA9IGdsb2JhbC5SYW5nZUVycm9yXG4gICwgSW5maW5pdHkgICAgICAgPSBnbG9iYWwuSW5maW5pdHlcbiAgLCBCYXNlQnVmZmVyICAgICA9ICRBcnJheUJ1ZmZlclxuICAsIGFicyAgICAgICAgICAgID0gTWF0aC5hYnNcbiAgLCBwb3cgICAgICAgICAgICA9IE1hdGgucG93XG4gICwgZmxvb3IgICAgICAgICAgPSBNYXRoLmZsb29yXG4gICwgbG9nICAgICAgICAgICAgPSBNYXRoLmxvZ1xuICAsIExOMiAgICAgICAgICAgID0gTWF0aC5MTjJcbiAgLCBCVUZGRVIgICAgICAgICA9ICdidWZmZXInXG4gICwgQllURV9MRU5HVEggICAgPSAnYnl0ZUxlbmd0aCdcbiAgLCBCWVRFX09GRlNFVCAgICA9ICdieXRlT2Zmc2V0J1xuICAsICRCVUZGRVIgICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX2InIDogQlVGRkVSXG4gICwgJExFTkdUSCAgICAgICAgPSBERVNDUklQVE9SUyA/ICdfbCcgOiBCWVRFX0xFTkdUSFxuICAsICRPRkZTRVQgICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX28nIDogQllURV9PRkZTRVQ7XG5cbi8vIElFRUU3NTQgY29udmVyc2lvbnMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pZWVlNzU0XG52YXIgcGFja0lFRUU3NTQgPSBmdW5jdGlvbih2YWx1ZSwgbUxlbiwgbkJ5dGVzKXtcbiAgdmFyIGJ1ZmZlciA9IEFycmF5KG5CeXRlcylcbiAgICAsIGVMZW4gICA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICAgICwgZU1heCAgID0gKDEgPDwgZUxlbikgLSAxXG4gICAgLCBlQmlhcyAgPSBlTWF4ID4+IDFcbiAgICAsIHJ0ICAgICA9IG1MZW4gPT09IDIzID8gcG93KDIsIC0yNCkgLSBwb3coMiwgLTc3KSA6IDBcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIHMgICAgICA9IHZhbHVlIDwgMCB8fCB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwID8gMSA6IDBcbiAgICAsIGUsIG0sIGM7XG4gIHZhbHVlID0gYWJzKHZhbHVlKVxuICBpZih2YWx1ZSAhPSB2YWx1ZSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpe1xuICAgIG0gPSB2YWx1ZSAhPSB2YWx1ZSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBmbG9vcihsb2codmFsdWUpIC8gTE4yKTtcbiAgICBpZih2YWx1ZSAqIChjID0gcG93KDIsIC1lKSkgPCAxKXtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYoZSArIGVCaWFzID49IDEpe1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIHBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZih2YWx1ZSAqIGMgPj0gMil7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuICAgIGlmKGUgKyBlQmlhcyA+PSBlTWF4KXtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmKGUgKyBlQmlhcyA+PSAxKXtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBwb3coMiwgZUJpYXMgLSAxKSAqIHBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuICBmb3IoOyBtTGVuID49IDg7IGJ1ZmZlcltpKytdID0gbSAmIDI1NSwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG4gIGUgPSBlIDw8IG1MZW4gfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvcig7IGVMZW4gPiAwOyBidWZmZXJbaSsrXSA9IGUgJiAyNTUsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuICBidWZmZXJbLS1pXSB8PSBzICogMTI4O1xuICByZXR1cm4gYnVmZmVyO1xufTtcbnZhciB1bnBhY2tJRUVFNzU0ID0gZnVuY3Rpb24oYnVmZmVyLCBtTGVuLCBuQnl0ZXMpe1xuICB2YXIgZUxlbiAgPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgICAsIGVNYXggID0gKDEgPDwgZUxlbikgLSAxXG4gICAgLCBlQmlhcyA9IGVNYXggPj4gMVxuICAgICwgbkJpdHMgPSBlTGVuIC0gN1xuICAgICwgaSAgICAgPSBuQnl0ZXMgLSAxXG4gICAgLCBzICAgICA9IGJ1ZmZlcltpLS1dXG4gICAgLCBlICAgICA9IHMgJiAxMjdcbiAgICAsIG07XG4gIHMgPj49IDc7XG4gIGZvcig7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG4gIG0gPSBlICYgKDEgPDwgLW5CaXRzKSAtIDE7XG4gIGUgPj49IC1uQml0cztcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltpXSwgaS0tLCBuQml0cyAtPSA4KTtcbiAgaWYoZSA9PT0gMCl7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmKGUgPT09IGVNYXgpe1xuICAgIHJldHVybiBtID8gTmFOIDogcyA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgcG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH0gcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBwb3coMiwgZSAtIG1MZW4pO1xufTtcblxudmFyIHVucGFja0kzMiA9IGZ1bmN0aW9uKGJ5dGVzKXtcbiAgcmV0dXJuIGJ5dGVzWzNdIDw8IDI0IHwgYnl0ZXNbMl0gPDwgMTYgfCBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG59O1xudmFyIHBhY2tJOCA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIFtpdCAmIDB4ZmZdO1xufTtcbnZhciBwYWNrSTE2ID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gW2l0ICYgMHhmZiwgaXQgPj4gOCAmIDB4ZmZdO1xufTtcbnZhciBwYWNrSTMyID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gW2l0ICYgMHhmZiwgaXQgPj4gOCAmIDB4ZmYsIGl0ID4+IDE2ICYgMHhmZiwgaXQgPj4gMjQgJiAweGZmXTtcbn07XG52YXIgcGFja0Y2NCA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KGl0LCA1MiwgOCk7XG59O1xudmFyIHBhY2tGMzIgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBwYWNrSUVFRTc1NChpdCwgMjMsIDQpO1xufTtcblxudmFyIGFkZEdldHRlciA9IGZ1bmN0aW9uKEMsIGtleSwgaW50ZXJuYWwpe1xuICBkUChDW1BST1RPVFlQRV0sIGtleSwge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXNbaW50ZXJuYWxdOyB9fSk7XG59O1xuXG52YXIgZ2V0ID0gZnVuY3Rpb24odmlldywgYnl0ZXMsIGluZGV4LCBpc0xpdHRsZUVuZGlhbil7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleFxuICAgICwgaW50SW5kZXggPSB0b0ludGVnZXIobnVtSW5kZXgpO1xuICBpZihudW1JbmRleCAhPSBpbnRJbmRleCB8fCBpbnRJbmRleCA8IDAgfHwgaW50SW5kZXggKyBieXRlcyA+IHZpZXdbJExFTkdUSF0pdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBzdG9yZSA9IHZpZXdbJEJVRkZFUl0uX2JcbiAgICAsIHN0YXJ0ID0gaW50SW5kZXggKyB2aWV3WyRPRkZTRVRdXG4gICAgLCBwYWNrICA9IHN0b3JlLnNsaWNlKHN0YXJ0LCBzdGFydCArIGJ5dGVzKTtcbiAgcmV0dXJuIGlzTGl0dGxlRW5kaWFuID8gcGFjayA6IHBhY2sucmV2ZXJzZSgpO1xufTtcbnZhciBzZXQgPSBmdW5jdGlvbih2aWV3LCBieXRlcywgaW5kZXgsIGNvbnZlcnNpb24sIHZhbHVlLCBpc0xpdHRsZUVuZGlhbil7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleFxuICAgICwgaW50SW5kZXggPSB0b0ludGVnZXIobnVtSW5kZXgpO1xuICBpZihudW1JbmRleCAhPSBpbnRJbmRleCB8fCBpbnRJbmRleCA8IDAgfHwgaW50SW5kZXggKyBieXRlcyA+IHZpZXdbJExFTkdUSF0pdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBzdG9yZSA9IHZpZXdbJEJVRkZFUl0uX2JcbiAgICAsIHN0YXJ0ID0gaW50SW5kZXggKyB2aWV3WyRPRkZTRVRdXG4gICAgLCBwYWNrICA9IGNvbnZlcnNpb24oK3ZhbHVlKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGJ5dGVzOyBpKyspc3RvcmVbc3RhcnQgKyBpXSA9IHBhY2tbaXNMaXR0bGVFbmRpYW4gPyBpIDogYnl0ZXMgLSBpIC0gMV07XG59O1xuXG52YXIgdmFsaWRhdGVBcnJheUJ1ZmZlckFyZ3VtZW50cyA9IGZ1bmN0aW9uKHRoYXQsIGxlbmd0aCl7XG4gIGFuSW5zdGFuY2UodGhhdCwgJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuICB2YXIgbnVtYmVyTGVuZ3RoID0gK2xlbmd0aFxuICAgICwgYnl0ZUxlbmd0aCAgID0gdG9MZW5ndGgobnVtYmVyTGVuZ3RoKTtcbiAgaWYobnVtYmVyTGVuZ3RoICE9IGJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICByZXR1cm4gYnl0ZUxlbmd0aDtcbn07XG5cbmlmKCEkdHlwZWQuQUJWKXtcbiAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKXtcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHZhbGlkYXRlQXJyYXlCdWZmZXJBcmd1bWVudHModGhpcywgbGVuZ3RoKTtcbiAgICB0aGlzLl9iICAgICAgID0gYXJyYXlGaWxsLmNhbGwoQXJyYXkoYnl0ZUxlbmd0aCksIDApO1xuICAgIHRoaXNbJExFTkdUSF0gPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gICREYXRhVmlldyA9IGZ1bmN0aW9uIERhdGFWaWV3KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCl7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkRGF0YVZpZXcsIERBVEFfVklFVyk7XG4gICAgYW5JbnN0YW5jZShidWZmZXIsICRBcnJheUJ1ZmZlciwgREFUQV9WSUVXKTtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYnVmZmVyWyRMRU5HVEhdXG4gICAgICAsIG9mZnNldCAgICAgICA9IHRvSW50ZWdlcihieXRlT2Zmc2V0KTtcbiAgICBpZihvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGJ1ZmZlckxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQhJyk7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPT09IHVuZGVmaW5lZCA/IGJ1ZmZlckxlbmd0aCAtIG9mZnNldCA6IHRvTGVuZ3RoKGJ5dGVMZW5ndGgpO1xuICAgIGlmKG9mZnNldCArIGJ5dGVMZW5ndGggPiBidWZmZXJMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHRoaXNbJEJVRkZFUl0gPSBidWZmZXI7XG4gICAgdGhpc1skT0ZGU0VUXSA9IG9mZnNldDtcbiAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICBpZihERVNDUklQVE9SUyl7XG4gICAgYWRkR2V0dGVyKCRBcnJheUJ1ZmZlciwgQllURV9MRU5HVEgsICdfbCcpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJVRkZFUiwgJ19iJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQllURV9MRU5HVEgsICdfbCcpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfT0ZGU0VULCAnX28nKTtcbiAgfVxuXG4gIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgZ2V0SW50ODogZnVuY3Rpb24gZ2V0SW50OChieXRlT2Zmc2V0KXtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF0gPDwgMjQgPj4gMjQ7XG4gICAgfSxcbiAgICBnZXRVaW50ODogZnVuY3Rpb24gZ2V0VWludDgoYnl0ZU9mZnNldCl7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MTY6IGZ1bmN0aW9uIGdldEludDE2KGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiAoYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdKSA8PCAxNiA+PiAxNjtcbiAgICB9LFxuICAgIGdldFVpbnQxNjogZnVuY3Rpb24gZ2V0VWludDE2KGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG4gICAgfSxcbiAgICBnZXRJbnQzMjogZnVuY3Rpb24gZ2V0SW50MzIoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpO1xuICAgIH0sXG4gICAgZ2V0VWludDMyOiBmdW5jdGlvbiBnZXRVaW50MzIoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpID4+PiAwO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQzMjogZnVuY3Rpb24gZ2V0RmxvYXQzMihieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSksIDIzLCA0KTtcbiAgICB9LFxuICAgIGdldEZsb2F0NjQ6IGZ1bmN0aW9uIGdldEZsb2F0NjQoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCA1MiwgOCk7XG4gICAgfSxcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKXtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSTgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSl7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRJbnQxNjogZnVuY3Rpb24gc2V0SW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0kxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRVaW50MTY6IGZ1bmN0aW9uIHNldFVpbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSTE2LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEludDMyOiBmdW5jdGlvbiBzZXRJbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldFVpbnQzMjogZnVuY3Rpb24gc2V0VWludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0RmxvYXQzMjogZnVuY3Rpb24gc2V0RmxvYXQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrRjMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0NjQ6IGZ1bmN0aW9uIHNldEZsb2F0NjQoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgcGFja0Y2NCwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIGlmKCFmYWlscyhmdW5jdGlvbigpe1xuICAgIG5ldyAkQXJyYXlCdWZmZXI7ICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgJEFycmF5QnVmZmVyKC41KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgfSkpe1xuICAgICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCl7XG4gICAgICByZXR1cm4gbmV3IEJhc2VCdWZmZXIodmFsaWRhdGVBcnJheUJ1ZmZlckFyZ3VtZW50cyh0aGlzLCBsZW5ndGgpKTtcbiAgICB9O1xuICAgIHZhciBBcnJheUJ1ZmZlclByb3RvID0gJEFycmF5QnVmZmVyW1BST1RPVFlQRV0gPSBCYXNlQnVmZmVyW1BST1RPVFlQRV07XG4gICAgZm9yKHZhciBrZXlzID0gZ09QTihCYXNlQnVmZmVyKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOyApe1xuICAgICAgaWYoISgoa2V5ID0ga2V5c1tqKytdKSBpbiAkQXJyYXlCdWZmZXIpKWhpZGUoJEFycmF5QnVmZmVyLCBrZXksIEJhc2VCdWZmZXJba2V5XSk7XG4gICAgfTtcbiAgICBpZighTElCUkFSWSlBcnJheUJ1ZmZlclByb3RvLmNvbnN0cnVjdG9yID0gJEFycmF5QnVmZmVyO1xuICB9XG4gIC8vIGlPUyBTYWZhcmkgNy54IGJ1Z1xuICB2YXIgdmlldyA9IG5ldyAkRGF0YVZpZXcobmV3ICRBcnJheUJ1ZmZlcigyKSlcbiAgICAsICRzZXRJbnQ4ID0gJERhdGFWaWV3W1BST1RPVFlQRV0uc2V0SW50ODtcbiAgdmlldy5zZXRJbnQ4KDAsIDIxNDc0ODM2NDgpO1xuICB2aWV3LnNldEludDgoMSwgMjE0NzQ4MzY0OSk7XG4gIGlmKHZpZXcuZ2V0SW50OCgwKSB8fCAhdmlldy5nZXRJbnQ4KDEpKXJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSl7XG4gICAgICAkc2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSl7XG4gICAgICAkc2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9XG4gIH0sIHRydWUpO1xufVxuc2V0VG9TdHJpbmdUYWcoJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuc2V0VG9TdHJpbmdUYWcoJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuaGlkZSgkRGF0YVZpZXdbUFJPVE9UWVBFXSwgJHR5cGVkLlZJRVcsIHRydWUpO1xuZXhwb3J0c1tBUlJBWV9CVUZGRVJdID0gJEFycmF5QnVmZmVyO1xuZXhwb3J0c1tEQVRBX1ZJRVddID0gJERhdGFWaWV3O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLWJ1ZmZlci5qc1xuICoqIG1vZHVsZSBpZCA9IDI4NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3R5cGVkJykuQUJWLCB7XG4gIERhdGFWaWV3OiByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKS5EYXRhVmlld1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZGF0YS12aWV3LmpzXG4gKiogbW9kdWxlIGlkID0gMjg3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQ4JywgMSwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheS5qc1xuICoqIG1vZHVsZSBpZCA9IDI4OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuaWYocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSl7XG4gIHZhciBMSUJSQVJZICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICAgLCBnbG9iYWwgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgICAsIGZhaWxzICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICAgLCAkZXhwb3J0ICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgICAsICR0eXBlZCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190eXBlZCcpXG4gICAgLCAkYnVmZmVyICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJylcbiAgICAsIGN0eCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAgICwgYW5JbnN0YW5jZSAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgICAsIHByb3BlcnR5RGVzYyAgICAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgICAsIGhpZGUgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgICAsIHJlZGVmaW5lQWxsICAgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAgICwgdG9JbnRlZ2VyICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAgICwgdG9MZW5ndGggICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICAgLCB0b0luZGV4ICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAgICwgdG9QcmltaXRpdmUgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICAgLCBoYXMgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgICAsIHNhbWUgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19zYW1lLXZhbHVlJylcbiAgICAsIGNsYXNzb2YgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgICAsIGlzT2JqZWN0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAgICwgdG9PYmplY3QgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICAgLCBpc0FycmF5SXRlciAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICAgLCBjcmVhdGUgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICAgLCBnZXRQcm90b3R5cGVPZiAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICAgLCBnT1BOICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICAgLCBnZXRJdGVyRm4gICAgICAgICAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKVxuICAgICwgdWlkICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICAgLCB3a3MgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJylcbiAgICAsIGNyZWF0ZUFycmF5TWV0aG9kICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJylcbiAgICAsIGNyZWF0ZUFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpXG4gICAgLCBzcGVjaWVzQ29uc3RydWN0b3IgID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICAgLCBBcnJheUl0ZXJhdG9ycyAgICAgID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKVxuICAgICwgSXRlcmF0b3JzICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICAgLCAkaXRlckRldGVjdCAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKVxuICAgICwgc2V0U3BlY2llcyAgICAgICAgICA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJylcbiAgICAsIGFycmF5RmlsbCAgICAgICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJylcbiAgICAsIGFycmF5Q29weVdpdGhpbiAgICAgPSByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpXG4gICAgLCAkRFAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgICAsICRHT1BEICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICAgLCBkUCAgICAgICAgICAgICAgICAgID0gJERQLmZcbiAgICAsIGdPUEQgICAgICAgICAgICAgICAgPSAkR09QRC5mXG4gICAgLCBSYW5nZUVycm9yICAgICAgICAgID0gZ2xvYmFsLlJhbmdlRXJyb3JcbiAgICAsIFR5cGVFcnJvciAgICAgICAgICAgPSBnbG9iYWwuVHlwZUVycm9yXG4gICAgLCBVaW50OEFycmF5ICAgICAgICAgID0gZ2xvYmFsLlVpbnQ4QXJyYXlcbiAgICAsIEFSUkFZX0JVRkZFUiAgICAgICAgPSAnQXJyYXlCdWZmZXInXG4gICAgLCBTSEFSRURfQlVGRkVSICAgICAgID0gJ1NoYXJlZCcgKyBBUlJBWV9CVUZGRVJcbiAgICAsIEJZVEVTX1BFUl9FTEVNRU5UICAgPSAnQllURVNfUEVSX0VMRU1FTlQnXG4gICAgLCBQUk9UT1RZUEUgICAgICAgICAgID0gJ3Byb3RvdHlwZSdcbiAgICAsIEFycmF5UHJvdG8gICAgICAgICAgPSBBcnJheVtQUk9UT1RZUEVdXG4gICAgLCAkQXJyYXlCdWZmZXIgICAgICAgID0gJGJ1ZmZlci5BcnJheUJ1ZmZlclxuICAgICwgJERhdGFWaWV3ICAgICAgICAgICA9ICRidWZmZXIuRGF0YVZpZXdcbiAgICAsIGFycmF5Rm9yRWFjaCAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCgwKVxuICAgICwgYXJyYXlGaWx0ZXIgICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDIpXG4gICAgLCBhcnJheVNvbWUgICAgICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoMylcbiAgICAsIGFycmF5RXZlcnkgICAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCg0KVxuICAgICwgYXJyYXlGaW5kICAgICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpXG4gICAgLCBhcnJheUZpbmRJbmRleCAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoNilcbiAgICAsIGFycmF5SW5jbHVkZXMgICAgICAgPSBjcmVhdGVBcnJheUluY2x1ZGVzKHRydWUpXG4gICAgLCBhcnJheUluZGV4T2YgICAgICAgID0gY3JlYXRlQXJyYXlJbmNsdWRlcyhmYWxzZSlcbiAgICAsIGFycmF5VmFsdWVzICAgICAgICAgPSBBcnJheUl0ZXJhdG9ycy52YWx1ZXNcbiAgICAsIGFycmF5S2V5cyAgICAgICAgICAgPSBBcnJheUl0ZXJhdG9ycy5rZXlzXG4gICAgLCBhcnJheUVudHJpZXMgICAgICAgID0gQXJyYXlJdGVyYXRvcnMuZW50cmllc1xuICAgICwgYXJyYXlMYXN0SW5kZXhPZiAgICA9IEFycmF5UHJvdG8ubGFzdEluZGV4T2ZcbiAgICAsIGFycmF5UmVkdWNlICAgICAgICAgPSBBcnJheVByb3RvLnJlZHVjZVxuICAgICwgYXJyYXlSZWR1Y2VSaWdodCAgICA9IEFycmF5UHJvdG8ucmVkdWNlUmlnaHRcbiAgICAsIGFycmF5Sm9pbiAgICAgICAgICAgPSBBcnJheVByb3RvLmpvaW5cbiAgICAsIGFycmF5U29ydCAgICAgICAgICAgPSBBcnJheVByb3RvLnNvcnRcbiAgICAsIGFycmF5U2xpY2UgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlXG4gICAgLCBhcnJheVRvU3RyaW5nICAgICAgID0gQXJyYXlQcm90by50b1N0cmluZ1xuICAgICwgYXJyYXlUb0xvY2FsZVN0cmluZyA9IEFycmF5UHJvdG8udG9Mb2NhbGVTdHJpbmdcbiAgICAsIElURVJBVE9SICAgICAgICAgICAgPSB3a3MoJ2l0ZXJhdG9yJylcbiAgICAsIFRBRyAgICAgICAgICAgICAgICAgPSB3a3MoJ3RvU3RyaW5nVGFnJylcbiAgICAsIFRZUEVEX0NPTlNUUlVDVE9SICAgPSB1aWQoJ3R5cGVkX2NvbnN0cnVjdG9yJylcbiAgICAsIERFRl9DT05TVFJVQ1RPUiAgICAgPSB1aWQoJ2RlZl9jb25zdHJ1Y3RvcicpXG4gICAgLCBBTExfQ09OU1RSVUNUT1JTICAgID0gJHR5cGVkLkNPTlNUUlxuICAgICwgVFlQRURfQVJSQVkgICAgICAgICA9ICR0eXBlZC5UWVBFRFxuICAgICwgVklFVyAgICAgICAgICAgICAgICA9ICR0eXBlZC5WSUVXXG4gICAgLCBXUk9OR19MRU5HVEggICAgICAgID0gJ1dyb25nIGxlbmd0aCEnO1xuXG4gIHZhciAkbWFwID0gY3JlYXRlQXJyYXlNZXRob2QoMSwgZnVuY3Rpb24oTywgbGVuZ3RoKXtcbiAgICByZXR1cm4gYWxsb2NhdGUoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSksIGxlbmd0aCk7XG4gIH0pO1xuXG4gIHZhciBMSVRUTEVfRU5ESUFOID0gZmFpbHMoZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQxNkFycmF5KFsxXSkuYnVmZmVyKVswXSA9PT0gMTtcbiAgfSk7XG5cbiAgdmFyIEZPUkNFRF9TRVQgPSAhIVVpbnQ4QXJyYXkgJiYgISFVaW50OEFycmF5W1BST1RPVFlQRV0uc2V0ICYmIGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgbmV3IFVpbnQ4QXJyYXkoMSkuc2V0KHt9KTtcbiAgfSk7XG5cbiAgdmFyIHN0cmljdFRvTGVuZ3RoID0gZnVuY3Rpb24oaXQsIFNBTUUpe1xuICAgIGlmKGl0ID09PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgdmFyIG51bWJlciA9ICtpdFxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChpdCk7XG4gICAgaWYoU0FNRSAmJiAhc2FtZShudW1iZXIsIGxlbmd0aCkpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHJldHVybiBsZW5ndGg7XG4gIH07XG5cbiAgdmFyIHRvT2Zmc2V0ID0gZnVuY3Rpb24oaXQsIEJZVEVTKXtcbiAgICB2YXIgb2Zmc2V0ID0gdG9JbnRlZ2VyKGl0KTtcbiAgICBpZihvZmZzZXQgPCAwIHx8IG9mZnNldCAlIEJZVEVTKXRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCEnKTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uKGl0KXtcbiAgICBpZihpc09iamVjdChpdCkgJiYgVFlQRURfQVJSQVkgaW4gaXQpcmV0dXJuIGl0O1xuICAgIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgdHlwZWQgYXJyYXkhJyk7XG4gIH07XG5cbiAgdmFyIGFsbG9jYXRlID0gZnVuY3Rpb24oQywgbGVuZ3RoKXtcbiAgICBpZighKGlzT2JqZWN0KEMpICYmIFRZUEVEX0NPTlNUUlVDVE9SIGluIEMpKXtcbiAgICAgIHRocm93IFR5cGVFcnJvcignSXQgaXMgbm90IGEgdHlwZWQgYXJyYXkgY29uc3RydWN0b3IhJyk7XG4gICAgfSByZXR1cm4gbmV3IEMobGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgc3BlY2llc0Zyb21MaXN0ID0gZnVuY3Rpb24oTywgbGlzdCl7XG4gICAgcmV0dXJuIGZyb21MaXN0KHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pLCBsaXN0KTtcbiAgfTtcblxuICB2YXIgZnJvbUxpc3QgPSBmdW5jdGlvbihDLCBsaXN0KXtcbiAgICB2YXIgaW5kZXggID0gMFxuICAgICAgLCBsZW5ndGggPSBsaXN0Lmxlbmd0aFxuICAgICAgLCByZXN1bHQgPSBhbGxvY2F0ZShDLCBsZW5ndGgpO1xuICAgIHdoaWxlKGxlbmd0aCA+IGluZGV4KXJlc3VsdFtpbmRleF0gPSBsaXN0W2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIGFkZEdldHRlciA9IGZ1bmN0aW9uKGl0LCBrZXksIGludGVybmFsKXtcbiAgICBkUChpdCwga2V5LCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5fZFtpbnRlcm5hbF07IH19KTtcbiAgfTtcblxuICB2YXIgJGZyb20gPSBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiwgbWFwZm4sIHRoaXNBcmcgKi8pe1xuICAgIHZhciBPICAgICAgID0gdG9PYmplY3Qoc291cmNlKVxuICAgICAgLCBhTGVuICAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBtYXBmbiAgID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcbiAgICAgICwgaXRlckZuICA9IGdldEl0ZXJGbihPKVxuICAgICAgLCBpLCBsZW5ndGgsIHZhbHVlcywgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZihpdGVyRm4gIT0gdW5kZWZpbmVkICYmICFpc0FycmF5SXRlcihpdGVyRm4pKXtcbiAgICAgIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCB2YWx1ZXMgPSBbXSwgaSA9IDA7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaSsrKXtcbiAgICAgICAgdmFsdWVzLnB1c2goc3RlcC52YWx1ZSk7XG4gICAgICB9IE8gPSB2YWx1ZXM7XG4gICAgfVxuICAgIGlmKG1hcHBpbmcgJiYgYUxlbiA+IDIpbWFwZm4gPSBjdHgobWFwZm4sIGFyZ3VtZW50c1syXSwgMik7XG4gICAgZm9yKGkgPSAwLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCksIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7IGxlbmd0aCA+IGk7IGkrKyl7XG4gICAgICByZXN1bHRbaV0gPSBtYXBwaW5nID8gbWFwZm4oT1tpXSwgaSkgOiBPW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciAkb2YgPSBmdW5jdGlvbiBvZigvKi4uLml0ZW1zKi8pe1xuICAgIHZhciBpbmRleCAgPSAwXG4gICAgICAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTtcbiAgICB3aGlsZShsZW5ndGggPiBpbmRleClyZXN1bHRbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gaU9TIFNhZmFyaSA2LnggZmFpbHMgaGVyZVxuICB2YXIgVE9fTE9DQUxFX0JVRyA9ICEhVWludDhBcnJheSAmJiBmYWlscyhmdW5jdGlvbigpeyBhcnJheVRvTG9jYWxlU3RyaW5nLmNhbGwobmV3IFVpbnQ4QXJyYXkoMSkpOyB9KTtcblxuICB2YXIgJHRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9Mb2NhbGVTdHJpbmcoKXtcbiAgICByZXR1cm4gYXJyYXlUb0xvY2FsZVN0cmluZy5hcHBseShUT19MT0NBTEVfQlVHID8gYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpKSA6IHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHZhciBwcm90byA9IHtcbiAgICBjb3B5V2l0aGluOiBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldCwgc3RhcnQgLyosIGVuZCAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlDb3B5V2l0aGluLmNhbGwodmFsaWRhdGUodGhpcyksIHRhcmdldCwgc3RhcnQsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiBhcnJheUV2ZXJ5KHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmaWxsOiBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qLCBzdGFydCwgZW5kICovKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5RmlsbC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheUZpbHRlcih2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbixcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpKTtcbiAgICB9LFxuICAgIGZpbmQ6IGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiBhcnJheUZpbmQodmFsaWRhdGUodGhpcyksIHByZWRpY2F0ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgocHJlZGljYXRlIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiBhcnJheUZpbmRJbmRleCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgYXJyYXlGb3JFYWNoKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlJbmRleE9mKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ICovKXtcbiAgICAgIHJldHVybiBhcnJheUluY2x1ZGVzKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcil7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUpvaW4uYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ICovKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5TGFzdEluZGV4T2YuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIG1hcChtYXBmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICByZXR1cm4gJG1hcCh2YWxpZGF0ZSh0aGlzKSwgbWFwZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyosIGluaXRpYWxWYWx1ZSAqLyl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZS5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuIC8qLCBpbml0aWFsVmFsdWUgKi8peyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2VSaWdodC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKXtcbiAgICAgIHZhciB0aGF0ICAgPSB0aGlzXG4gICAgICAgICwgbGVuZ3RoID0gdmFsaWRhdGUodGhhdCkubGVuZ3RoXG4gICAgICAgICwgbWlkZGxlID0gTWF0aC5mbG9vcihsZW5ndGggLyAyKVxuICAgICAgICAsIGluZGV4ICA9IDBcbiAgICAgICAgLCB2YWx1ZTtcbiAgICAgIHdoaWxlKGluZGV4IDwgbWlkZGxlKXtcbiAgICAgICAgdmFsdWUgICAgICAgICA9IHRoYXRbaW5kZXhdO1xuICAgICAgICB0aGF0W2luZGV4KytdID0gdGhhdFstLWxlbmd0aF07XG4gICAgICAgIHRoYXRbbGVuZ3RoXSAgPSB2YWx1ZTtcbiAgICAgIH0gcmV0dXJuIHRoYXQ7XG4gICAgfSxcbiAgICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5U29tZSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pe1xuICAgICAgcmV0dXJuIGFycmF5U29ydC5jYWxsKHZhbGlkYXRlKHRoaXMpLCBjb21wYXJlZm4pO1xuICAgIH0sXG4gICAgc3ViYXJyYXk6IGZ1bmN0aW9uIHN1YmFycmF5KGJlZ2luLCBlbmQpe1xuICAgICAgdmFyIE8gICAgICA9IHZhbGlkYXRlKHRoaXMpXG4gICAgICAgICwgbGVuZ3RoID0gTy5sZW5ndGhcbiAgICAgICAgLCAkYmVnaW4gPSB0b0luZGV4KGJlZ2luLCBsZW5ndGgpO1xuICAgICAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSkpKFxuICAgICAgICBPLmJ1ZmZlcixcbiAgICAgICAgTy5ieXRlT2Zmc2V0ICsgJGJlZ2luICogTy5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgdG9MZW5ndGgoKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9JbmRleChlbmQsIGxlbmd0aCkpIC0gJGJlZ2luKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyICRzbGljZSA9IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpe1xuICAgIHJldHVybiBzcGVjaWVzRnJvbUxpc3QodGhpcywgYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpLCBzdGFydCwgZW5kKSk7XG4gIH07XG5cbiAgdmFyICRzZXQgPSBmdW5jdGlvbiBzZXQoYXJyYXlMaWtlIC8qLCBvZmZzZXQgKi8pe1xuICAgIHZhbGlkYXRlKHRoaXMpO1xuICAgIHZhciBvZmZzZXQgPSB0b09mZnNldChhcmd1bWVudHNbMV0sIDEpXG4gICAgICAsIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgICAsIHNyYyAgICA9IHRvT2JqZWN0KGFycmF5TGlrZSlcbiAgICAgICwgbGVuICAgID0gdG9MZW5ndGgoc3JjLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gMDtcbiAgICBpZihsZW4gKyBvZmZzZXQgPiBsZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHdoaWxlKGluZGV4IDwgbGVuKXRoaXNbb2Zmc2V0ICsgaW5kZXhdID0gc3JjW2luZGV4KytdO1xuICB9O1xuXG4gIHZhciAkaXRlcmF0b3JzID0ge1xuICAgIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoKXtcbiAgICAgIHJldHVybiBhcnJheUVudHJpZXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfSxcbiAgICBrZXlzOiBmdW5jdGlvbiBrZXlzKCl7XG4gICAgICByZXR1cm4gYXJyYXlLZXlzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH0sXG4gICAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoKXtcbiAgICAgIHJldHVybiBhcnJheVZhbHVlcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzVEFJbmRleCA9IGZ1bmN0aW9uKHRhcmdldCwga2V5KXtcbiAgICByZXR1cm4gaXNPYmplY3QodGFyZ2V0KVxuICAgICAgJiYgdGFyZ2V0W1RZUEVEX0FSUkFZXVxuICAgICAgJiYgdHlwZW9mIGtleSAhPSAnc3ltYm9sJ1xuICAgICAgJiYga2V5IGluIHRhcmdldFxuICAgICAgJiYgU3RyaW5nKCtrZXkpID09IFN0cmluZyhrZXkpO1xuICB9O1xuICB2YXIgJGdldERlc2MgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpe1xuICAgIHJldHVybiBpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgICAgPyBwcm9wZXJ0eURlc2MoMiwgdGFyZ2V0W2tleV0pXG4gICAgICA6IGdPUEQodGFyZ2V0LCBrZXkpO1xuICB9O1xuICB2YXIgJHNldERlc2MgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzYyl7XG4gICAgaWYoaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSlcbiAgICAgICYmIGlzT2JqZWN0KGRlc2MpXG4gICAgICAmJiBoYXMoZGVzYywgJ3ZhbHVlJylcbiAgICAgICYmICFoYXMoZGVzYywgJ2dldCcpXG4gICAgICAmJiAhaGFzKGRlc2MsICdzZXQnKVxuICAgICAgLy8gVE9ETzogYWRkIHZhbGlkYXRpb24gZGVzY3JpcHRvciB3L28gY2FsbGluZyBhY2Nlc3NvcnNcbiAgICAgICYmICFkZXNjLmNvbmZpZ3VyYWJsZVxuICAgICAgJiYgKCFoYXMoZGVzYywgJ3dyaXRhYmxlJykgfHwgZGVzYy53cml0YWJsZSlcbiAgICAgICYmICghaGFzKGRlc2MsICdlbnVtZXJhYmxlJykgfHwgZGVzYy5lbnVtZXJhYmxlKVxuICAgICl7XG4gICAgICB0YXJnZXRba2V5XSA9IGRlc2MudmFsdWU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0gZWxzZSByZXR1cm4gZFAodGFyZ2V0LCBrZXksIGRlc2MpO1xuICB9O1xuXG4gIGlmKCFBTExfQ09OU1RSVUNUT1JTKXtcbiAgICAkR09QRC5mID0gJGdldERlc2M7XG4gICAgJERQLmYgICA9ICRzZXREZXNjO1xuICB9XG5cbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhQUxMX0NPTlNUUlVDVE9SUywgJ09iamVjdCcsIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXREZXNjLFxuICAgIGRlZmluZVByb3BlcnR5OiAgICAgICAgICAgJHNldERlc2NcbiAgfSk7XG5cbiAgaWYoZmFpbHMoZnVuY3Rpb24oKXsgYXJyYXlUb1N0cmluZy5jYWxsKHt9KTsgfSkpe1xuICAgIGFycmF5VG9TdHJpbmcgPSBhcnJheVRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICAgIHJldHVybiBhcnJheUpvaW4uY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICB2YXIgJFR5cGVkQXJyYXlQcm90b3R5cGUkID0gcmVkZWZpbmVBbGwoe30sIHByb3RvKTtcbiAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAkaXRlcmF0b3JzKTtcbiAgaGlkZSgkVHlwZWRBcnJheVByb3RvdHlwZSQsIElURVJBVE9SLCAkaXRlcmF0b3JzLnZhbHVlcyk7XG4gIHJlZGVmaW5lQWxsKCRUeXBlZEFycmF5UHJvdG90eXBlJCwge1xuICAgIHNsaWNlOiAgICAgICAgICAkc2xpY2UsXG4gICAgc2V0OiAgICAgICAgICAgICRzZXQsXG4gICAgY29uc3RydWN0b3I6ICAgIGZ1bmN0aW9uKCl7IC8qIG5vb3AgKi8gfSxcbiAgICB0b1N0cmluZzogICAgICAgYXJyYXlUb1N0cmluZyxcbiAgICB0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nXG4gIH0pO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnVmZmVyJywgJ2InKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J5dGVPZmZzZXQnLCAnbycpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnl0ZUxlbmd0aCcsICdsJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdsZW5ndGgnLCAnZScpO1xuICBkUCgkVHlwZWRBcnJheVByb3RvdHlwZSQsIFRBRywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXNbVFlQRURfQVJSQVldOyB9XG4gIH0pO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBCWVRFUywgd3JhcHBlciwgQ0xBTVBFRCl7XG4gICAgQ0xBTVBFRCA9ICEhQ0xBTVBFRDtcbiAgICB2YXIgTkFNRSAgICAgICA9IEtFWSArIChDTEFNUEVEID8gJ0NsYW1wZWQnIDogJycpICsgJ0FycmF5J1xuICAgICAgLCBJU05UX1VJTlQ4ID0gTkFNRSAhPSAnVWludDhBcnJheSdcbiAgICAgICwgR0VUVEVSICAgICA9ICdnZXQnICsgS0VZXG4gICAgICAsIFNFVFRFUiAgICAgPSAnc2V0JyArIEtFWVxuICAgICAgLCBUeXBlZEFycmF5ID0gZ2xvYmFsW05BTUVdXG4gICAgICAsIEJhc2UgICAgICAgPSBUeXBlZEFycmF5IHx8IHt9XG4gICAgICAsIFRBQyAgICAgICAgPSBUeXBlZEFycmF5ICYmIGdldFByb3RvdHlwZU9mKFR5cGVkQXJyYXkpXG4gICAgICAsIEZPUkNFRCAgICAgPSAhVHlwZWRBcnJheSB8fCAhJHR5cGVkLkFCVlxuICAgICAgLCBPICAgICAgICAgID0ge31cbiAgICAgICwgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXkgJiYgVHlwZWRBcnJheVtQUk9UT1RZUEVdO1xuICAgIHZhciBnZXR0ZXIgPSBmdW5jdGlvbih0aGF0LCBpbmRleCl7XG4gICAgICB2YXIgZGF0YSA9IHRoYXQuX2Q7XG4gICAgICByZXR1cm4gZGF0YS52W0dFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEubywgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24odGhhdCwgaW5kZXgsIHZhbHVlKXtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIGlmKENMQU1QRUQpdmFsdWUgPSAodmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKSkgPCAwID8gMCA6IHZhbHVlID4gMHhmZiA/IDB4ZmYgOiB2YWx1ZSAmIDB4ZmY7XG4gICAgICBkYXRhLnZbU0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCB2YWx1ZSwgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgYWRkRWxlbWVudCA9IGZ1bmN0aW9uKHRoYXQsIGluZGV4KXtcbiAgICAgIGRQKHRoYXQsIGluZGV4LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgICByZXR1cm4gZ2V0dGVyKHRoaXMsIGluZGV4KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgICAgcmV0dXJuIHNldHRlcih0aGlzLCBpbmRleCwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmKEZPUkNFRCl7XG4gICAgICBUeXBlZEFycmF5ID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKXtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5LCBOQU1FLCAnX2QnKTtcbiAgICAgICAgdmFyIGluZGV4ICA9IDBcbiAgICAgICAgICAsIG9mZnNldCA9IDBcbiAgICAgICAgICAsIGJ1ZmZlciwgYnl0ZUxlbmd0aCwgbGVuZ3RoLCBrbGFzcztcbiAgICAgICAgaWYoIWlzT2JqZWN0KGRhdGEpKXtcbiAgICAgICAgICBsZW5ndGggICAgID0gc3RyaWN0VG9MZW5ndGgoZGF0YSwgdHJ1ZSlcbiAgICAgICAgICBieXRlTGVuZ3RoID0gbGVuZ3RoICogQllURVM7XG4gICAgICAgICAgYnVmZmVyICAgICA9IG5ldyAkQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZihkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKXtcbiAgICAgICAgICBidWZmZXIgPSBkYXRhO1xuICAgICAgICAgIG9mZnNldCA9IHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKTtcbiAgICAgICAgICB2YXIgJGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBpZigkbGVuZ3RoID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgaWYoJGxlbiAlIEJZVEVTKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSAkbGVuIC0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYoYnl0ZUxlbmd0aCA8IDApdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gdG9MZW5ndGgoJGxlbmd0aCkgKiBCWVRFUztcbiAgICAgICAgICAgIGlmKGJ5dGVMZW5ndGggKyBvZmZzZXQgPiAkbGVuKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoID0gYnl0ZUxlbmd0aCAvIEJZVEVTO1xuICAgICAgICB9IGVsc2UgaWYoVFlQRURfQVJSQVkgaW4gZGF0YSl7XG4gICAgICAgICAgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGhpZGUodGhhdCwgJ19kJywge1xuICAgICAgICAgIGI6IGJ1ZmZlcixcbiAgICAgICAgICBvOiBvZmZzZXQsXG4gICAgICAgICAgbDogYnl0ZUxlbmd0aCxcbiAgICAgICAgICBlOiBsZW5ndGgsXG4gICAgICAgICAgdjogbmV3ICREYXRhVmlldyhidWZmZXIpXG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZShpbmRleCA8IGxlbmd0aClhZGRFbGVtZW50KHRoYXQsIGluZGV4KyspO1xuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheVtQUk9UT1RZUEVdID0gY3JlYXRlKCRUeXBlZEFycmF5UHJvdG90eXBlJCk7XG4gICAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIFR5cGVkQXJyYXkpO1xuICAgIH0gZWxzZSBpZighJGl0ZXJEZXRlY3QoZnVuY3Rpb24oaXRlcil7XG4gICAgICAvLyBWOCB3b3JrcyB3aXRoIGl0ZXJhdG9ycywgYnV0IGZhaWxzIGluIG1hbnkgb3RoZXIgY2FzZXNcbiAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00NTUyXG4gICAgICBuZXcgVHlwZWRBcnJheShudWxsKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIG5ldyBUeXBlZEFycmF5KGl0ZXIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH0sIHRydWUpKXtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGRhdGEsICRvZmZzZXQsICRsZW5ndGgpe1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUpO1xuICAgICAgICB2YXIga2xhc3M7XG4gICAgICAgIC8vIGB3c2AgbW9kdWxlIGJ1ZywgdGVtcG9yYXJpbHkgcmVtb3ZlIHZhbGlkYXRpb24gbGVuZ3RoIGZvciBVaW50OEFycmF5XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL3B1bGwvNjQ1XG4gICAgICAgIGlmKCFpc09iamVjdChkYXRhKSlyZXR1cm4gbmV3IEJhc2Uoc3RyaWN0VG9MZW5ndGgoZGF0YSwgSVNOVF9VSU5UOCkpO1xuICAgICAgICBpZihkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKXtcbiAgICAgICAgICByZXR1cm4gJGxlbmd0aCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IG5ldyBCYXNlKGRhdGEsIHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKSwgJGxlbmd0aClcbiAgICAgICAgICAgIDogJG9mZnNldCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpKVxuICAgICAgICAgICAgICA6IG5ldyBCYXNlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmKFRZUEVEX0FSUkFZIGluIGRhdGEpcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICByZXR1cm4gJGZyb20uY2FsbChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgIH0pO1xuICAgICAgYXJyYXlGb3JFYWNoKFRBQyAhPT0gRnVuY3Rpb24ucHJvdG90eXBlID8gZ09QTihCYXNlKS5jb25jYXQoZ09QTihUQUMpKSA6IGdPUE4oQmFzZSksIGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIGlmKCEoa2V5IGluIFR5cGVkQXJyYXkpKWhpZGUoVHlwZWRBcnJheSwga2V5LCBCYXNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBUeXBlZEFycmF5UHJvdG90eXBlO1xuICAgICAgaWYoIUxJQlJBUlkpVHlwZWRBcnJheVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFR5cGVkQXJyYXk7XG4gICAgfVxuICAgIHZhciAkbmF0aXZlSXRlcmF0b3IgICA9IFR5cGVkQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdXG4gICAgICAsIENPUlJFQ1RfSVRFUl9OQU1FID0gISEkbmF0aXZlSXRlcmF0b3IgJiYgKCRuYXRpdmVJdGVyYXRvci5uYW1lID09ICd2YWx1ZXMnIHx8ICRuYXRpdmVJdGVyYXRvci5uYW1lID09IHVuZGVmaW5lZClcbiAgICAgICwgJGl0ZXJhdG9yICAgICAgICAgPSAkaXRlcmF0b3JzLnZhbHVlcztcbiAgICBoaWRlKFR5cGVkQXJyYXksIFRZUEVEX0NPTlNUUlVDVE9SLCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRZUEVEX0FSUkFZLCBOQU1FKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgREVGX0NPTlNUUlVDVE9SLCBUeXBlZEFycmF5KTtcblxuICAgIGlmKENMQU1QRUQgPyBuZXcgVHlwZWRBcnJheSgxKVtUQUddICE9IE5BTUUgOiAhKFRBRyBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSl7XG4gICAgICBkUChUeXBlZEFycmF5UHJvdG90eXBlLCBUQUcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gTkFNRTsgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgT1tOQU1FXSA9IFR5cGVkQXJyYXk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChUeXBlZEFycmF5ICE9IEJhc2UpLCBPKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5TLCBOQU1FLCB7XG4gICAgICBCWVRFU19QRVJfRUxFTUVOVDogQllURVMsXG4gICAgICBmcm9tOiAkZnJvbSxcbiAgICAgIG9mOiAkb2ZcbiAgICB9KTtcblxuICAgIGlmKCEoQllURVNfUEVSX0VMRU1FTlQgaW4gVHlwZWRBcnJheVByb3RvdHlwZSkpaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBCWVRFU19QRVJfRUxFTUVOVCwgQllURVMpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAsIE5BTUUsIHByb3RvKTtcblxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFRF9TRVQsIE5BTUUsIHtzZXQ6ICRzZXR9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIUNPUlJFQ1RfSVRFUl9OQU1FLCBOQU1FLCAkaXRlcmF0b3JzKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKFR5cGVkQXJyYXlQcm90b3R5cGUudG9TdHJpbmcgIT0gYXJyYXlUb1N0cmluZyksIE5BTUUsIHt0b1N0cmluZzogYXJyYXlUb1N0cmluZ30pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbigpe1xuICAgICAgbmV3IFR5cGVkQXJyYXkoMSkuc2xpY2UoKTtcbiAgICB9KSwgTkFNRSwge3NsaWNlOiAkc2xpY2V9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gWzEsIDJdLnRvTG9jYWxlU3RyaW5nKCkgIT0gbmV3IFR5cGVkQXJyYXkoWzEsIDJdKS50b0xvY2FsZVN0cmluZygpXG4gICAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nLmNhbGwoWzEsIDJdKTtcbiAgICB9KSksIE5BTUUsIHt0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nfSk7XG5cbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBDT1JSRUNUX0lURVJfTkFNRSA/ICRuYXRpdmVJdGVyYXRvciA6ICRpdGVyYXRvcjtcbiAgICBpZighTElCUkFSWSAmJiAhQ09SUkVDVF9JVEVSX05BTUUpaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBJVEVSQVRPUiwgJGl0ZXJhdG9yKTtcbiAgfTtcbn0gZWxzZSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAyODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQ4JywgMSwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gMjkwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50OCcsIDEsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhDbGFtcGVkQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSwgdHJ1ZSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtY2xhbXBlZC1hcnJheS5qc1xuICoqIG1vZHVsZSBpZCA9IDI5MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50MTYnLCAyLCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAyOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQxNicsIDIsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gVWludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gMjkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQzMicsIDQsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gSW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheS5qc1xuICoqIG1vZHVsZSBpZCA9IDI5NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDMyJywgNCwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAyOTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0Zsb2F0MzInLCA0LCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDMyLWFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gMjk2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdGbG9hdDY0JywgOCwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBGbG9hdDY0QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQ2NC1hcnJheS5qc1xuICoqIG1vZHVsZSBpZCA9IDI5N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjYuMS4xIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QpXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBhbk9iamVjdCAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHJBcHBseSAgICA9IChyZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0IHx8IHt9KS5hcHBseVxuICAsIGZBcHBseSAgICA9IEZ1bmN0aW9uLmFwcGx5O1xuLy8gTVMgRWRnZSBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJBcHBseShmdW5jdGlvbigpe30pO1xufSksICdSZWZsZWN0Jywge1xuICBhcHBseTogZnVuY3Rpb24gYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3Qpe1xuICAgIHZhciBUID0gYUZ1bmN0aW9uKHRhcmdldClcbiAgICAgICwgTCA9IGFuT2JqZWN0KGFyZ3VtZW50c0xpc3QpO1xuICAgIHJldHVybiByQXBwbHkgPyByQXBwbHkoVCwgdGhpc0FyZ3VtZW50LCBMKSA6IGZBcHBseS5jYWxsKFQsIHRoaXNBcmd1bWVudCwgTCk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuYXBwbHkuanNcbiAqKiBtb2R1bGUgaWQgPSAyOThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDI2LjEuMiBSZWZsZWN0LmNvbnN0cnVjdCh0YXJnZXQsIGFyZ3VtZW50c0xpc3QgWywgbmV3VGFyZ2V0XSlcbnZhciAkZXhwb3J0ICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjcmVhdGUgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgYUZ1bmN0aW9uICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIGFuT2JqZWN0ICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGlzT2JqZWN0ICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGZhaWxzICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgYmluZCAgICAgICA9IHJlcXVpcmUoJy4vX2JpbmQnKVxuICAsIHJDb25zdHJ1Y3QgPSAocmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdCB8fCB7fSkuY29uc3RydWN0O1xuXG4vLyBNUyBFZGdlIHN1cHBvcnRzIG9ubHkgMiBhcmd1bWVudHMgYW5kIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcbi8vIEZGIE5pZ2h0bHkgc2V0cyB0aGlyZCBhcmd1bWVudCBhcyBgbmV3LnRhcmdldGAsIGJ1dCBkb2VzIG5vdCBjcmVhdGUgYHRoaXNgIGZyb20gaXRcbnZhciBORVdfVEFSR0VUX0JVRyA9IGZhaWxzKGZ1bmN0aW9uKCl7XG4gIGZ1bmN0aW9uIEYoKXt9XG4gIHJldHVybiAhKHJDb25zdHJ1Y3QoZnVuY3Rpb24oKXt9LCBbXSwgRikgaW5zdGFuY2VvZiBGKTtcbn0pO1xudmFyIEFSR1NfQlVHID0gIWZhaWxzKGZ1bmN0aW9uKCl7XG4gIHJDb25zdHJ1Y3QoZnVuY3Rpb24oKXt9KTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChORVdfVEFSR0VUX0JVRyB8fCBBUkdTX0JVRyksICdSZWZsZWN0Jywge1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIGNvbnN0cnVjdChUYXJnZXQsIGFyZ3MgLyosIG5ld1RhcmdldCovKXtcbiAgICBhRnVuY3Rpb24oVGFyZ2V0KTtcbiAgICBhbk9iamVjdChhcmdzKTtcbiAgICB2YXIgbmV3VGFyZ2V0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBUYXJnZXQgOiBhRnVuY3Rpb24oYXJndW1lbnRzWzJdKTtcbiAgICBpZihBUkdTX0JVRyAmJiAhTkVXX1RBUkdFVF9CVUcpcmV0dXJuIHJDb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzLCBuZXdUYXJnZXQpO1xuICAgIGlmKFRhcmdldCA9PSBuZXdUYXJnZXQpe1xuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBvcHRpbWl6YXRpb24gZm9yIDAtNCBhcmd1bWVudHNcbiAgICAgIHN3aXRjaChhcmdzLmxlbmd0aCl7XG4gICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBUYXJnZXQ7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSk7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIGNhc2UgNDogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICB9XG4gICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIGxvdCBvZiBhcmd1bWVudHMgY2FzZVxuICAgICAgdmFyICRhcmdzID0gW251bGxdO1xuICAgICAgJGFyZ3MucHVzaC5hcHBseSgkYXJncywgYXJncyk7XG4gICAgICByZXR1cm4gbmV3IChiaW5kLmFwcGx5KFRhcmdldCwgJGFyZ3MpKTtcbiAgICB9XG4gICAgLy8gd2l0aCBhbHRlcmVkIG5ld1RhcmdldCwgbm90IHN1cHBvcnQgYnVpbHQtaW4gY29uc3RydWN0b3JzXG4gICAgdmFyIHByb3RvICAgID0gbmV3VGFyZ2V0LnByb3RvdHlwZVxuICAgICAgLCBpbnN0YW5jZSA9IGNyZWF0ZShpc09iamVjdChwcm90bykgPyBwcm90byA6IE9iamVjdC5wcm90b3R5cGUpXG4gICAgICAsIHJlc3VsdCAgID0gRnVuY3Rpb24uYXBwbHkuY2FsbChUYXJnZXQsIGluc3RhbmNlLCBhcmdzKTtcbiAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IGluc3RhbmNlO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmNvbnN0cnVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDI5OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjYuMS4zIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcylcbnZhciBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4vLyBNUyBFZGdlIGhhcyBicm9rZW4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSAtIHRocm93aW5nIGluc3RlYWQgb2YgcmV0dXJuaW5nIGZhbHNlXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShkUC5mKHt9LCAxLCB7dmFsdWU6IDF9KSwgMSwge3ZhbHVlOiAyfSk7XG59KSwgJ1JlZmxlY3QnLCB7XG4gIGRlZmluZVByb3BlcnR5OiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKXtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHByb3BlcnR5S2V5ID0gdG9QcmltaXRpdmUocHJvcGVydHlLZXksIHRydWUpO1xuICAgIGFuT2JqZWN0KGF0dHJpYnV0ZXMpO1xuICAgIHRyeSB7XG4gICAgICBkUC5mKHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gMzAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyNi4xLjQgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBnT1BEICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZlxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpe1xuICAgIHZhciBkZXNjID0gZ09QRChhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gICAgcmV0dXJuIGRlc2MgJiYgIWRlc2MuY29uZmlndXJhYmxlID8gZmFsc2UgOiBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5kZWxldGUtcHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSAzMDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIDI2LjEuNSBSZWZsZWN0LmVudW1lcmF0ZSh0YXJnZXQpXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgRW51bWVyYXRlID0gZnVuY3Rpb24oaXRlcmF0ZWQpe1xuICB0aGlzLl90ID0gYW5PYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB2YXIga2V5cyA9IHRoaXMuX2sgPSBbXSAgICAgICAvLyBrZXlzXG4gICAgLCBrZXk7XG4gIGZvcihrZXkgaW4gaXRlcmF0ZWQpa2V5cy5wdXNoKGtleSk7XG59O1xucmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKShFbnVtZXJhdGUsICdPYmplY3QnLCBmdW5jdGlvbigpe1xuICB2YXIgdGhhdCA9IHRoaXNcbiAgICAsIGtleXMgPSB0aGF0Ll9rXG4gICAgLCBrZXk7XG4gIGRvIHtcbiAgICBpZih0aGF0Ll9pID49IGtleXMubGVuZ3RoKXJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG4gIH0gd2hpbGUoISgoa2V5ID0ga2V5c1t0aGF0Ll9pKytdKSBpbiB0aGF0Ll90KSk7XG4gIHJldHVybiB7dmFsdWU6IGtleSwgZG9uZTogZmFsc2V9O1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZW51bWVyYXRlOiBmdW5jdGlvbiBlbnVtZXJhdGUodGFyZ2V0KXtcbiAgICByZXR1cm4gbmV3IEVudW1lcmF0ZSh0YXJnZXQpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmVudW1lcmF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDMwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjYuMS42IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkgWywgcmVjZWl2ZXJdKVxudmFyIGdPUEQgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuZnVuY3Rpb24gZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkvKiwgcmVjZWl2ZXIqLyl7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogYXJndW1lbnRzWzJdXG4gICAgLCBkZXNjLCBwcm90bztcbiAgaWYoYW5PYmplY3QodGFyZ2V0KSA9PT0gcmVjZWl2ZXIpcmV0dXJuIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIGlmKGRlc2MgPSBnT1BELmYodGFyZ2V0LCBwcm9wZXJ0eUtleSkpcmV0dXJuIGhhcyhkZXNjLCAndmFsdWUnKVxuICAgID8gZGVzYy52YWx1ZVxuICAgIDogZGVzYy5nZXQgIT09IHVuZGVmaW5lZFxuICAgICAgPyBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIGlmKGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpcmV0dXJuIGdldChwcm90bywgcHJvcGVydHlLZXksIHJlY2VpdmVyKTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge2dldDogZ2V0fSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQuanNcbiAqKiBtb2R1bGUgaWQgPSAzMDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDI2LjEuNyBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyIGdPUEQgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpe1xuICAgIHJldHVybiBnT1BELmYoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDMwNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjYuMS44IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KVxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBnZXRQcm90byA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKHRhcmdldCl7XG4gICAgcmV0dXJuIGdldFByb3RvKGFuT2JqZWN0KHRhcmdldCkpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1wcm90b3R5cGUtb2YuanNcbiAqKiBtb2R1bGUgaWQgPSAzMDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDI2LjEuOSBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBoYXM6IGZ1bmN0aW9uIGhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KXtcbiAgICByZXR1cm4gcHJvcGVydHlLZXkgaW4gdGFyZ2V0O1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lmhhcy5qc1xuICoqIG1vZHVsZSBpZCA9IDMwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjYuMS4xMCBSZWZsZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpXG52YXIgJGV4cG9ydCAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYW5PYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgJGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgaXNFeHRlbnNpYmxlOiBmdW5jdGlvbiBpc0V4dGVuc2libGUodGFyZ2V0KXtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHJldHVybiAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZSh0YXJnZXQpIDogdHJ1ZTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5pcy1leHRlbnNpYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMzA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyNi4xLjExIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7b3duS2V5czogcmVxdWlyZSgnLi9fb3duLWtleXMnKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Qub3duLWtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSAzMDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBnT1BOICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJylcbiAgLCBnT1BTICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgUmVmbGVjdCAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBSZWZsZWN0ICYmIFJlZmxlY3Qub3duS2V5cyB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KXtcbiAgdmFyIGtleXMgICAgICAgPSBnT1BOLmYoYW5PYmplY3QoaXQpKVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgcmV0dXJuIGdldFN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19vd24ta2V5cy5qc1xuICoqIG1vZHVsZSBpZCA9IDMwOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjYuMS4xMiBSZWZsZWN0LnByZXZlbnRFeHRlbnNpb25zKHRhcmdldClcbnZhciAkZXhwb3J0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgJHByZXZlbnRFeHRlbnNpb25zID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIHByZXZlbnRFeHRlbnNpb25zOiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpe1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmKCRwcmV2ZW50RXh0ZW5zaW9ucykkcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDMxMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjYuMS4xMyBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWIFssIHJlY2VpdmVyXSlcbnZhciBkUCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgZ09QRCAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGlzT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWLyosIHJlY2VpdmVyKi8pe1xuICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgNCA/IHRhcmdldCA6IGFyZ3VtZW50c1szXVxuICAgICwgb3duRGVzYyAgPSBnT1BELmYoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpXG4gICAgLCBleGlzdGluZ0Rlc2NyaXB0b3IsIHByb3RvO1xuICBpZighb3duRGVzYyl7XG4gICAgaWYoaXNPYmplY3QocHJvdG8gPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSl7XG4gICAgICByZXR1cm4gc2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgViwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgICBvd25EZXNjID0gY3JlYXRlRGVzYygwKTtcbiAgfVxuICBpZihoYXMob3duRGVzYywgJ3ZhbHVlJykpe1xuICAgIGlmKG93bkRlc2Mud3JpdGFibGUgPT09IGZhbHNlIHx8ICFpc09iamVjdChyZWNlaXZlcikpcmV0dXJuIGZhbHNlO1xuICAgIGV4aXN0aW5nRGVzY3JpcHRvciA9IGdPUEQuZihyZWNlaXZlciwgcHJvcGVydHlLZXkpIHx8IGNyZWF0ZURlc2MoMCk7XG4gICAgZXhpc3RpbmdEZXNjcmlwdG9yLnZhbHVlID0gVjtcbiAgICBkUC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSwgZXhpc3RpbmdEZXNjcmlwdG9yKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gb3duRGVzYy5zZXQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogKG93bkRlc2Muc2V0LmNhbGwocmVjZWl2ZXIsIFYpLCB0cnVlKTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge3NldDogc2V0fSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5zZXQuanNcbiAqKiBtb2R1bGUgaWQgPSAzMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDI2LjEuMTQgUmVmbGVjdC5zZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKVxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBzZXRQcm90byA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpO1xuXG5pZihzZXRQcm90bykkZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIHNldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKXtcbiAgICBzZXRQcm90by5jaGVjayh0YXJnZXQsIHByb3RvKTtcbiAgICB0cnkge1xuICAgICAgc2V0UHJvdG8uc2V0KHRhcmdldCwgcHJvdG8pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDMxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkaW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWwgLyosIGZyb21JbmRleCA9IDAgKi8pe1xuICAgIHJldHVybiAkaW5jbHVkZXModGhpcywgZWwsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdpbmNsdWRlcycpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMzEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGF0ICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgYXQ6IGZ1bmN0aW9uIGF0KHBvcyl7XG4gICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcuYXQuanNcbiAqKiBtb2R1bGUgaWQgPSAzMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhZCAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1wYWQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIHBhZFN0YXJ0OiBmdW5jdGlvbiBwYWRTdGFydChtYXhMZW5ndGggLyosIGZpbGxTdHJpbmcgPSAnICcgKi8pe1xuICAgIHJldHVybiAkcGFkKHRoaXMsIG1heExlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRydWUpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLXN0YXJ0LmpzXG4gKiogbW9kdWxlIGlkID0gMzE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCByZXBlYXQgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKVxuICAsIGRlZmluZWQgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIG1heExlbmd0aCwgZmlsbFN0cmluZywgbGVmdCl7XG4gIHZhciBTICAgICAgICAgICAgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSlcbiAgICAsIHN0cmluZ0xlbmd0aCA9IFMubGVuZ3RoXG4gICAgLCBmaWxsU3RyICAgICAgPSBmaWxsU3RyaW5nID09PSB1bmRlZmluZWQgPyAnICcgOiBTdHJpbmcoZmlsbFN0cmluZylcbiAgICAsIGludE1heExlbmd0aCA9IHRvTGVuZ3RoKG1heExlbmd0aCk7XG4gIGlmKGludE1heExlbmd0aCA8PSBzdHJpbmdMZW5ndGggfHwgZmlsbFN0ciA9PSAnJylyZXR1cm4gUztcbiAgdmFyIGZpbGxMZW4gPSBpbnRNYXhMZW5ndGggLSBzdHJpbmdMZW5ndGhcbiAgICAsIHN0cmluZ0ZpbGxlciA9IHJlcGVhdC5jYWxsKGZpbGxTdHIsIE1hdGguY2VpbChmaWxsTGVuIC8gZmlsbFN0ci5sZW5ndGgpKTtcbiAgaWYoc3RyaW5nRmlsbGVyLmxlbmd0aCA+IGZpbGxMZW4pc3RyaW5nRmlsbGVyID0gc3RyaW5nRmlsbGVyLnNsaWNlKDAsIGZpbGxMZW4pO1xuICByZXR1cm4gbGVmdCA/IHN0cmluZ0ZpbGxlciArIFMgOiBTICsgc3RyaW5nRmlsbGVyO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1wYWQuanNcbiAqKiBtb2R1bGUgaWQgPSAzMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhZCAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1wYWQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIHBhZEVuZDogZnVuY3Rpb24gcGFkRW5kKG1heExlbmd0aCAvKiwgZmlsbFN0cmluZyA9ICcgJyAqLyl7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgZmFsc2UpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZC5qc1xuICoqIG1vZHVsZSBpZCA9IDMxN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbUxlZnQnLCBmdW5jdGlvbigkdHJpbSl7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltTGVmdCgpe1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAxKTtcbiAgfTtcbn0sICd0cmltU3RhcnQnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1sZWZ0LmpzXG4gKiogbW9kdWxlIGlkID0gMzE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2VibWFya2JhZ2UvZWNtYXNjcmlwdC1zdHJpbmctbGVmdC1yaWdodC10cmltXG5yZXF1aXJlKCcuL19zdHJpbmctdHJpbScpKCd0cmltUmlnaHQnLCBmdW5jdGlvbigkdHJpbSl7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltUmlnaHQoKXtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMik7XG4gIH07XG59LCAndHJpbUVuZCcpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLXJpZ2h0LmpzXG4gKiogbW9kdWxlIGlkID0gMzE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL1N0cmluZy5wcm90b3R5cGUubWF0Y2hBbGwvXG52YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGRlZmluZWQgICAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgdG9MZW5ndGggICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGlzUmVnRXhwICAgID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJylcbiAgLCBnZXRGbGFncyAgICA9IHJlcXVpcmUoJy4vX2ZsYWdzJylcbiAgLCBSZWdFeHBQcm90byA9IFJlZ0V4cC5wcm90b3R5cGU7XG5cbnZhciAkUmVnRXhwU3RyaW5nSXRlcmF0b3IgPSBmdW5jdGlvbihyZWdleHAsIHN0cmluZyl7XG4gIHRoaXMuX3IgPSByZWdleHA7XG4gIHRoaXMuX3MgPSBzdHJpbmc7XG59O1xuXG5yZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpKCRSZWdFeHBTdHJpbmdJdGVyYXRvciwgJ1JlZ0V4cCBTdHJpbmcnLCBmdW5jdGlvbiBuZXh0KCl7XG4gIHZhciBtYXRjaCA9IHRoaXMuX3IuZXhlYyh0aGlzLl9zKTtcbiAgcmV0dXJuIHt2YWx1ZTogbWF0Y2gsIGRvbmU6IG1hdGNoID09PSBudWxsfTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgbWF0Y2hBbGw6IGZ1bmN0aW9uIG1hdGNoQWxsKHJlZ2V4cCl7XG4gICAgZGVmaW5lZCh0aGlzKTtcbiAgICBpZighaXNSZWdFeHAocmVnZXhwKSl0aHJvdyBUeXBlRXJyb3IocmVnZXhwICsgJyBpcyBub3QgYSByZWdleHAhJyk7XG4gICAgdmFyIFMgICAgID0gU3RyaW5nKHRoaXMpXG4gICAgICAsIGZsYWdzID0gJ2ZsYWdzJyBpbiBSZWdFeHBQcm90byA/IFN0cmluZyhyZWdleHAuZmxhZ3MpIDogZ2V0RmxhZ3MuY2FsbChyZWdleHApXG4gICAgICAsIHJ4ICAgID0gbmV3IFJlZ0V4cChyZWdleHAuc291cmNlLCB+ZmxhZ3MuaW5kZXhPZignZycpID8gZmxhZ3MgOiAnZycgKyBmbGFncyk7XG4gICAgcngubGFzdEluZGV4ID0gdG9MZW5ndGgocmVnZXhwLmxhc3RJbmRleCk7XG4gICAgcmV0dXJuIG5ldyAkUmVnRXhwU3RyaW5nSXRlcmF0b3IocngsIFMpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcubWF0Y2gtYWxsLmpzXG4gKiogbW9kdWxlIGlkID0gMzIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAzMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMzIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xudmFyICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBvd25LZXlzICAgICAgICA9IHJlcXVpcmUoJy4vX293bi1rZXlzJylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGdPUEQgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iamVjdCl7XG4gICAgdmFyIE8gICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICAgLCBnZXREZXNjID0gZ09QRC5mXG4gICAgICAsIGtleXMgICAgPSBvd25LZXlzKE8pXG4gICAgICAsIHJlc3VsdCAgPSB7fVxuICAgICAgLCBpICAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUoa2V5cy5sZW5ndGggPiBpKWNyZWF0ZVByb3BlcnR5KHJlc3VsdCwga2V5ID0ga2V5c1tpKytdLCBnZXREZXNjKE8sIGtleSkpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzXG4gKiogbW9kdWxlIGlkID0gMzIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtdmFsdWVzLWVudHJpZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkdmFsdWVzID0gcmVxdWlyZSgnLi9fb2JqZWN0LXRvLWFycmF5JykoZmFsc2UpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoaXQpe1xuICAgIHJldHVybiAkdmFsdWVzKGl0KTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LnZhbHVlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDMyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdldEtleXMgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBpc0VudW0gICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNFbnRyaWVzKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKGl0KXtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KGl0KVxuICAgICAgLCBrZXlzICAgPSBnZXRLZXlzKE8pXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAsIGkgICAgICA9IDBcbiAgICAgICwgcmVzdWx0ID0gW11cbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGxlbmd0aCA+IGkpaWYoaXNFbnVtLmNhbGwoTywga2V5ID0ga2V5c1tpKytdKSl7XG4gICAgICByZXN1bHQucHVzaChpc0VudHJpZXMgPyBba2V5LCBPW2tleV1dIDogT1trZXldKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC10by1hcnJheS5qc1xuICoqIG1vZHVsZSBpZCA9IDMyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LXZhbHVlcy1lbnRyaWVzXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRlbnRyaWVzID0gcmVxdWlyZSgnLi9fb2JqZWN0LXRvLWFycmF5JykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKGl0KXtcbiAgICByZXR1cm4gJGVudHJpZXMoaXQpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcy5qc1xuICoqIG1vZHVsZSBpZCA9IDMyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gICAgICAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcblxuLy8gQi4yLjIuMiBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX18oUCwgZ2V0dGVyKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fZGVmaW5lR2V0dGVyX186IGZ1bmN0aW9uIF9fZGVmaW5lR2V0dGVyX18oUCwgZ2V0dGVyKXtcbiAgICAkZGVmaW5lUHJvcGVydHkuZih0b09iamVjdCh0aGlzKSwgUCwge2dldDogYUZ1bmN0aW9uKGdldHRlciksIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0pO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLWdldHRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDMyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gRm9yY2VkIHJlcGxhY2VtZW50IHByb3RvdHlwZSBhY2Nlc3NvcnMgbWV0aG9kc1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyl8fCAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICB2YXIgSyA9IE1hdGgucmFuZG9tKCk7XG4gIC8vIEluIEZGIHRocm93cyBvbmx5IGRlZmluZSBtZXRob2RzXG4gIF9fZGVmaW5lU2V0dGVyX18uY2FsbChudWxsLCBLLCBmdW5jdGlvbigpeyAvKiBlbXB0eSAqL30pO1xuICBkZWxldGUgcmVxdWlyZSgnLi9fZ2xvYmFsJylbS107XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZm9yY2VkLXBhbS5qc1xuICoqIG1vZHVsZSBpZCA9IDMyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gICAgICAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcblxuLy8gQi4yLjIuMyBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lU2V0dGVyX18oUCwgc2V0dGVyKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fZGVmaW5lU2V0dGVyX186IGZ1bmN0aW9uIF9fZGVmaW5lU2V0dGVyX18oUCwgc2V0dGVyKXtcbiAgICAkZGVmaW5lUHJvcGVydHkuZih0b09iamVjdCh0aGlzKSwgUCwge3NldDogYUZ1bmN0aW9uKHNldHRlciksIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0pO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLXNldHRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDMyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGdldFByb3RvdHlwZU9mICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxuLy8gQi4yLjIuNCBPYmplY3QucHJvdG90eXBlLl9fbG9va3VwR2V0dGVyX18oUClcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2xvb2t1cEdldHRlcl9fOiBmdW5jdGlvbiBfX2xvb2t1cEdldHRlcl9fKFApe1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcylcbiAgICAgICwgSyA9IHRvUHJpbWl0aXZlKFAsIHRydWUpXG4gICAgICAsIEQ7XG4gICAgZG8ge1xuICAgICAgaWYoRCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBLKSlyZXR1cm4gRC5nZXQ7XG4gICAgfSB3aGlsZShPID0gZ2V0UHJvdG90eXBlT2YoTykpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLWdldHRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDMzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGdldFByb3RvdHlwZU9mICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxuLy8gQi4yLjIuNSBPYmplY3QucHJvdG90eXBlLl9fbG9va3VwU2V0dGVyX18oUClcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2xvb2t1cFNldHRlcl9fOiBmdW5jdGlvbiBfX2xvb2t1cFNldHRlcl9fKFApe1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcylcbiAgICAgICwgSyA9IHRvUHJpbWl0aXZlKFAsIHRydWUpXG4gICAgICAsIEQ7XG4gICAgZG8ge1xuICAgICAgaWYoRCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBLKSlyZXR1cm4gRC5zZXQ7XG4gICAgfSB3aGlsZShPID0gZ2V0UHJvdG90eXBlT2YoTykpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLXNldHRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDMzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnTWFwJywge3RvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ01hcCcpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWFwLnRvLWpzb24uanNcbiAqKiBtb2R1bGUgaWQgPSAzMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgZnJvbSAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSl7XG4gIHJldHVybiBmdW5jdGlvbiB0b0pTT04oKXtcbiAgICBpZihjbGFzc29mKHRoaXMpICE9IE5BTUUpdGhyb3cgVHlwZUVycm9yKE5BTUUgKyBcIiN0b0pTT04gaXNuJ3QgZ2VuZXJpY1wiKTtcbiAgICByZXR1cm4gZnJvbSh0aGlzKTtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi10by1qc29uLmpzXG4gKiogbW9kdWxlIGlkID0gMzMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyLCBJVEVSQVRPUil7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yT2YoaXRlciwgZmFsc2UsIHJlc3VsdC5wdXNoLCByZXN1bHQsIElURVJBVE9SKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1mcm9tLWl0ZXJhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMzM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdTZXQnLCB7dG9KU09OOiByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXRvLWpzb24nKSgnU2V0Jyl9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDMzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9wcm9wb3NhbC1nbG9iYWxcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnU3lzdGVtJywge2dsb2JhbDogcmVxdWlyZSgnLi9fZ2xvYmFsJyl9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zeXN0ZW0uZ2xvYmFsLmpzXG4gKiogbW9kdWxlIGlkID0gMzM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL3Byb3Bvc2FsLWlzLWVycm9yXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY29mICAgICA9IHJlcXVpcmUoJy4vX2NvZicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0Vycm9yJywge1xuICBpc0Vycm9yOiBmdW5jdGlvbiBpc0Vycm9yKGl0KXtcbiAgICByZXR1cm4gY29mKGl0KSA9PT0gJ0Vycm9yJztcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuZXJyb3IuaXMtZXJyb3IuanNcbiAqKiBtb2R1bGUgaWQgPSAzMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGlhZGRoOiBmdW5jdGlvbiBpYWRkaCh4MCwgeDEsIHkwLCB5MSl7XG4gICAgdmFyICR4MCA9IHgwID4+PiAwXG4gICAgICAsICR4MSA9IHgxID4+PiAwXG4gICAgICAsICR5MCA9IHkwID4+PiAwO1xuICAgIHJldHVybiAkeDEgKyAoeTEgPj4+IDApICsgKCgkeDAgJiAkeTAgfCAoJHgwIHwgJHkwKSAmIH4oJHgwICsgJHkwID4+PiAwKSkgPj4+IDMxKSB8IDA7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaWFkZGguanNcbiAqKiBtb2R1bGUgaWQgPSAzMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGlzdWJoOiBmdW5jdGlvbiBpc3ViaCh4MCwgeDEsIHkwLCB5MSl7XG4gICAgdmFyICR4MCA9IHgwID4+PiAwXG4gICAgICAsICR4MSA9IHgxID4+PiAwXG4gICAgICAsICR5MCA9IHkwID4+PiAwO1xuICAgIHJldHVybiAkeDEgLSAoeTEgPj4+IDApIC0gKCh+JHgwICYgJHkwIHwgfigkeDAgXiAkeTApICYgJHgwIC0gJHkwID4+PiAwKSA+Pj4gMzEpIHwgMDtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pc3ViaC5qc1xuICoqIG1vZHVsZSBpZCA9IDMzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaW11bGg6IGZ1bmN0aW9uIGltdWxoKHUsIHYpe1xuICAgIHZhciBVSU5UMTYgPSAweGZmZmZcbiAgICAgICwgJHUgPSArdVxuICAgICAgLCAkdiA9ICt2XG4gICAgICAsIHUwID0gJHUgJiBVSU5UMTZcbiAgICAgICwgdjAgPSAkdiAmIFVJTlQxNlxuICAgICAgLCB1MSA9ICR1ID4+IDE2XG4gICAgICAsIHYxID0gJHYgPj4gMTZcbiAgICAgICwgdCAgPSAodTEgKiB2MCA+Pj4gMCkgKyAodTAgKiB2MCA+Pj4gMTYpO1xuICAgIHJldHVybiB1MSAqIHYxICsgKHQgPj4gMTYpICsgKCh1MCAqIHYxID4+PiAwKSArICh0ICYgVUlOVDE2KSA+PiAxNik7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaW11bGguanNcbiAqKiBtb2R1bGUgaWQgPSAzNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHVtdWxoOiBmdW5jdGlvbiB1bXVsaCh1LCB2KXtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmXG4gICAgICAsICR1ID0gK3VcbiAgICAgICwgJHYgPSArdlxuICAgICAgLCB1MCA9ICR1ICYgVUlOVDE2XG4gICAgICAsIHYwID0gJHYgJiBVSU5UMTZcbiAgICAgICwgdTEgPSAkdSA+Pj4gMTZcbiAgICAgICwgdjEgPSAkdiA+Pj4gMTZcbiAgICAgICwgdCAgPSAodTEgKiB2MCA+Pj4gMCkgKyAodTAgKiB2MCA+Pj4gMTYpO1xuICAgIHJldHVybiB1MSAqIHYxICsgKHQgPj4+IDE2KSArICgodTAgKiB2MSA+Pj4gMCkgKyAodCAmIFVJTlQxNikgPj4+IDE2KTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC51bXVsaC5qc1xuICoqIG1vZHVsZSBpZCA9IDM0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleVxuICAsIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5zZXQ7XG5cbm1ldGFkYXRhLmV4cCh7ZGVmaW5lTWV0YWRhdGE6IGZ1bmN0aW9uIGRlZmluZU1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHRhcmdldEtleSl7XG4gIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIGFuT2JqZWN0KHRhcmdldCksIHRvTWV0YUtleSh0YXJnZXRLZXkpKTtcbn19KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlZmluZS1tZXRhZGF0YS5qc1xuICoqIG1vZHVsZSBpZCA9IDM0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIE1hcCAgICAgPSByZXF1aXJlKCcuL2VzNi5tYXAnKVxuICAsICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHNoYXJlZCAgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnbWV0YWRhdGEnKVxuICAsIHN0b3JlICAgPSBzaGFyZWQuc3RvcmUgfHwgKHNoYXJlZC5zdG9yZSA9IG5ldyAocmVxdWlyZSgnLi9lczYud2Vhay1tYXAnKSkpO1xuXG52YXIgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCA9IGZ1bmN0aW9uKHRhcmdldCwgdGFyZ2V0S2V5LCBjcmVhdGUpe1xuICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBzdG9yZS5nZXQodGFyZ2V0KTtcbiAgaWYoIXRhcmdldE1ldGFkYXRhKXtcbiAgICBpZighY3JlYXRlKXJldHVybiB1bmRlZmluZWQ7XG4gICAgc3RvcmUuc2V0KHRhcmdldCwgdGFyZ2V0TWV0YWRhdGEgPSBuZXcgTWFwKTtcbiAgfVxuICB2YXIga2V5TWV0YWRhdGEgPSB0YXJnZXRNZXRhZGF0YS5nZXQodGFyZ2V0S2V5KTtcbiAgaWYoIWtleU1ldGFkYXRhKXtcbiAgICBpZighY3JlYXRlKXJldHVybiB1bmRlZmluZWQ7XG4gICAgdGFyZ2V0TWV0YWRhdGEuc2V0KHRhcmdldEtleSwga2V5TWV0YWRhdGEgPSBuZXcgTWFwKTtcbiAgfSByZXR1cm4ga2V5TWV0YWRhdGE7XG59O1xudmFyIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBmdW5jdGlvbihNZXRhZGF0YUtleSwgTywgUCl7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgZmFsc2UpO1xuICByZXR1cm4gbWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogbWV0YWRhdGFNYXAuaGFzKE1ldGFkYXRhS2V5KTtcbn07XG52YXIgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IGZ1bmN0aW9uKE1ldGFkYXRhS2V5LCBPLCBQKXtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCBmYWxzZSk7XG4gIHJldHVybiBtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogbWV0YWRhdGFNYXAuZ2V0KE1ldGFkYXRhS2V5KTtcbn07XG52YXIgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9IGZ1bmN0aW9uKE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlLCBPLCBQKXtcbiAgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCB0cnVlKS5zZXQoTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUpO1xufTtcbnZhciBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IGZ1bmN0aW9uKHRhcmdldCwgdGFyZ2V0S2V5KXtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCh0YXJnZXQsIHRhcmdldEtleSwgZmFsc2UpXG4gICAgLCBrZXlzICAgICAgICA9IFtdO1xuICBpZihtZXRhZGF0YU1hcCltZXRhZGF0YU1hcC5mb3JFYWNoKGZ1bmN0aW9uKF8sIGtleSl7IGtleXMucHVzaChrZXkpOyB9KTtcbiAgcmV0dXJuIGtleXM7XG59O1xudmFyIHRvTWV0YUtleSA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiBTdHJpbmcoaXQpO1xufTtcbnZhciBleHAgPSBmdW5jdGlvbihPKXtcbiAgJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0JywgTyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3RvcmU6IHN0b3JlLFxuICBtYXA6IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAsXG4gIGhhczogb3JkaW5hcnlIYXNPd25NZXRhZGF0YSxcbiAgZ2V0OiBvcmRpbmFyeUdldE93bk1ldGFkYXRhLFxuICBzZXQ6IG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEsXG4gIGtleXM6IG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzLFxuICBrZXk6IHRvTWV0YUtleSxcbiAgZXhwOiBleHBcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fbWV0YWRhdGEuanNcbiAqKiBtb2R1bGUgaWQgPSAzNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXlcbiAgLCBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwID0gbWV0YWRhdGEubWFwXG4gICwgc3RvcmUgICAgICAgICAgICAgICAgICA9IG1ldGFkYXRhLnN0b3JlO1xuXG5tZXRhZGF0YS5leHAoe2RlbGV0ZU1ldGFkYXRhOiBmdW5jdGlvbiBkZWxldGVNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICB2YXIgdGFyZ2V0S2V5ICAgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pXG4gICAgLCBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoYW5PYmplY3QodGFyZ2V0KSwgdGFyZ2V0S2V5LCBmYWxzZSk7XG4gIGlmKG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgfHwgIW1ldGFkYXRhTWFwWydkZWxldGUnXShtZXRhZGF0YUtleSkpcmV0dXJuIGZhbHNlO1xuICBpZihtZXRhZGF0YU1hcC5zaXplKXJldHVybiB0cnVlO1xuICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBzdG9yZS5nZXQodGFyZ2V0KTtcbiAgdGFyZ2V0TWV0YWRhdGFbJ2RlbGV0ZSddKHRhcmdldEtleSk7XG4gIHJldHVybiAhIXRhcmdldE1ldGFkYXRhLnNpemUgfHwgc3RvcmVbJ2RlbGV0ZSddKHRhcmdldCk7XG59fSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5kZWxldGUtbWV0YWRhdGEuanNcbiAqKiBtb2R1bGUgaWQgPSAzNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGdldFByb3RvdHlwZU9mICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzXG4gICwgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmdldFxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeUdldE1ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE8sIFApe1xuICB2YXIgaGFzT3duID0gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIGlmKGhhc093bilyZXR1cm4gb3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIHZhciBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IG9yZGluYXJ5R2V0TWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCkgOiB1bmRlZmluZWQ7XG59O1xuXG5tZXRhZGF0YS5leHAoe2dldE1ldGFkYXRhOiBmdW5jdGlvbiBnZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlHZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59fSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEuanNcbiAqKiBtb2R1bGUgaWQgPSAzNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBTZXQgICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vZXM2LnNldCcpXG4gICwgZnJvbSAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1mcm9tLWl0ZXJhYmxlJylcbiAgLCBtZXRhZGF0YSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IG1ldGFkYXRhLmtleXNcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleTtcblxudmFyIG9yZGluYXJ5TWV0YWRhdGFLZXlzID0gZnVuY3Rpb24oTywgUCl7XG4gIHZhciBvS2V5cyAgPSBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKVxuICAgICwgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIGlmKHBhcmVudCA9PT0gbnVsbClyZXR1cm4gb0tleXM7XG4gIHZhciBwS2V5cyAgPSBvcmRpbmFyeU1ldGFkYXRhS2V5cyhwYXJlbnQsIFApO1xuICByZXR1cm4gcEtleXMubGVuZ3RoID8gb0tleXMubGVuZ3RoID8gZnJvbShuZXcgU2V0KG9LZXlzLmNvbmNhdChwS2V5cykpKSA6IHBLZXlzIDogb0tleXM7XG59O1xuXG5tZXRhZGF0YS5leHAoe2dldE1ldGFkYXRhS2V5czogZnVuY3Rpb24gZ2V0TWV0YWRhdGFLZXlzKHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5TWV0YWRhdGFLZXlzKGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1sxXSkpO1xufX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLWtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSAzNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBtZXRhZGF0YS5nZXRcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoe2dldE93bk1ldGFkYXRhOiBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlHZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KVxuICAgICwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59fSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLmpzXG4gKiogbW9kdWxlIGlkID0gMzQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5c1xuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoe2dldE93bk1ldGFkYXRhS2V5czogZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGFLZXlzKHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1sxXSkpO1xufX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMzQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRQcm90b3R5cGVPZiAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhc1xuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeUhhc01ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE8sIFApe1xuICB2YXIgaGFzT3duID0gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIGlmKGhhc093bilyZXR1cm4gdHJ1ZTtcbiAgdmFyIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICByZXR1cm4gcGFyZW50ICE9PSBudWxsID8gb3JkaW5hcnlIYXNNZXRhZGF0YShNZXRhZGF0YUtleSwgcGFyZW50LCBQKSA6IGZhbHNlO1xufTtcblxubWV0YWRhdGEuZXhwKHtoYXNNZXRhZGF0YTogZnVuY3Rpb24gaGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5SGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW1ldGFkYXRhLmpzXG4gKiogbW9kdWxlIGlkID0gMzQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleTtcblxubWV0YWRhdGEuZXhwKHtoYXNPd25NZXRhZGF0YTogZnVuY3Rpb24gaGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldClcbiAgICAsIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW93bi1tZXRhZGF0YS5qc1xuICoqIG1vZHVsZSBpZCA9IDM1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXlcbiAgLCBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gbWV0YWRhdGEuc2V0O1xuXG5tZXRhZGF0YS5leHAoe21ldGFkYXRhOiBmdW5jdGlvbiBtZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSl7XG4gIHJldHVybiBmdW5jdGlvbiBkZWNvcmF0b3IodGFyZ2V0LCB0YXJnZXRLZXkpe1xuICAgIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEoXG4gICAgICBtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSxcbiAgICAgICh0YXJnZXRLZXkgIT09IHVuZGVmaW5lZCA/IGFuT2JqZWN0IDogYUZ1bmN0aW9uKSh0YXJnZXQpLFxuICAgICAgdG9NZXRhS2V5KHRhcmdldEtleSlcbiAgICApO1xuICB9O1xufX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEuanNcbiAqKiBtb2R1bGUgaWQgPSAzNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yd2FsZHJvbi90YzM5LW5vdGVzL2Jsb2IvbWFzdGVyL2VzNi8yMDE0LTA5L3NlcHQtMjUubWQjNTEwLWdsb2JhbGFzYXAtZm9yLWVucXVldWluZy1hLW1pY3JvdGFza1xudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKVxuICAsIHByb2Nlc3MgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnByb2Nlc3NcbiAgLCBpc05vZGUgICAgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbiRleHBvcnQoJGV4cG9ydC5HLCB7XG4gIGFzYXA6IGZ1bmN0aW9uIGFzYXAoZm4pe1xuICAgIHZhciBkb21haW4gPSBpc05vZGUgJiYgcHJvY2Vzcy5kb21haW47XG4gICAgbWljcm90YXNrKGRvbWFpbiA/IGRvbWFpbi5iaW5kKGZuKSA6IGZuKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuYXNhcC5qc1xuICoqIG1vZHVsZSBpZCA9IDM1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZVxudmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBnbG9iYWwgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBtaWNyb3Rhc2sgICA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKClcbiAgLCBPQlNFUlZBQkxFICA9IHJlcXVpcmUoJy4vX3drcycpKCdvYnNlcnZhYmxlJylcbiAgLCBhRnVuY3Rpb24gICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBhbkluc3RhbmNlICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgaGlkZSAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBmb3JPZiAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgUkVUVVJOICAgICAgPSBmb3JPZi5SRVRVUk47XG5cbnZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihmbil7XG4gIHJldHVybiBmbiA9PSBudWxsID8gdW5kZWZpbmVkIDogYUZ1bmN0aW9uKGZuKTtcbn07XG5cbnZhciBjbGVhbnVwU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24oc3Vic2NyaXB0aW9uKXtcbiAgdmFyIGNsZWFudXAgPSBzdWJzY3JpcHRpb24uX2M7XG4gIGlmKGNsZWFudXApe1xuICAgIHN1YnNjcmlwdGlvbi5fYyA9IHVuZGVmaW5lZDtcbiAgICBjbGVhbnVwKCk7XG4gIH1cbn07XG5cbnZhciBzdWJzY3JpcHRpb25DbG9zZWQgPSBmdW5jdGlvbihzdWJzY3JpcHRpb24pe1xuICByZXR1cm4gc3Vic2NyaXB0aW9uLl9vID09PSB1bmRlZmluZWQ7XG59O1xuXG52YXIgY2xvc2VTdWJzY3JpcHRpb24gPSBmdW5jdGlvbihzdWJzY3JpcHRpb24pe1xuICBpZighc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpe1xuICAgIHN1YnNjcmlwdGlvbi5fbyA9IHVuZGVmaW5lZDtcbiAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gIH1cbn07XG5cbnZhciBTdWJzY3JpcHRpb24gPSBmdW5jdGlvbihvYnNlcnZlciwgc3Vic2NyaWJlcil7XG4gIGFuT2JqZWN0KG9ic2VydmVyKTtcbiAgdGhpcy5fYyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fbyA9IG9ic2VydmVyO1xuICBvYnNlcnZlciA9IG5ldyBTdWJzY3JpcHRpb25PYnNlcnZlcih0aGlzKTtcbiAgdHJ5IHtcbiAgICB2YXIgY2xlYW51cCAgICAgID0gc3Vic2NyaWJlcihvYnNlcnZlcilcbiAgICAgICwgc3Vic2NyaXB0aW9uID0gY2xlYW51cDtcbiAgICBpZihjbGVhbnVwICE9IG51bGwpe1xuICAgICAgaWYodHlwZW9mIGNsZWFudXAudW5zdWJzY3JpYmUgPT09ICdmdW5jdGlvbicpY2xlYW51cCA9IGZ1bmN0aW9uKCl7IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpOyB9O1xuICAgICAgZWxzZSBhRnVuY3Rpb24oY2xlYW51cCk7XG4gICAgICB0aGlzLl9jID0gY2xlYW51cDtcbiAgICB9XG4gIH0gY2F0Y2goZSl7XG4gICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgcmV0dXJuO1xuICB9IGlmKHN1YnNjcmlwdGlvbkNsb3NlZCh0aGlzKSljbGVhbnVwU3Vic2NyaXB0aW9uKHRoaXMpO1xufTtcblxuU3Vic2NyaXB0aW9uLnByb3RvdHlwZSA9IHJlZGVmaW5lQWxsKHt9LCB7XG4gIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpeyBjbG9zZVN1YnNjcmlwdGlvbih0aGlzKTsgfVxufSk7XG5cbnZhciBTdWJzY3JpcHRpb25PYnNlcnZlciA9IGZ1bmN0aW9uKHN1YnNjcmlwdGlvbil7XG4gIHRoaXMuX3MgPSBzdWJzY3JpcHRpb247XG59O1xuXG5TdWJzY3JpcHRpb25PYnNlcnZlci5wcm90b3R5cGUgPSByZWRlZmluZUFsbCh7fSwge1xuICBuZXh0OiBmdW5jdGlvbiBuZXh0KHZhbHVlKXtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZighc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpe1xuICAgICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIubmV4dCk7XG4gICAgICAgIGlmKG0pcmV0dXJuIG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjbG9zZVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGVycm9yOiBmdW5jdGlvbiBlcnJvcih2YWx1ZSl7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYoc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpdGhyb3cgdmFsdWU7XG4gICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgIHN1YnNjcmlwdGlvbi5fbyA9IHVuZGVmaW5lZDtcbiAgICB0cnkge1xuICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIuZXJyb3IpO1xuICAgICAgaWYoIW0pdGhyb3cgdmFsdWU7XG4gICAgICB2YWx1ZSA9IG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICB0cnkge1xuICAgICAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHZhbHVlKXtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZighc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpe1xuICAgICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgICAgc3Vic2NyaXB0aW9uLl9vID0gdW5kZWZpbmVkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIuY29tcGxldGUpO1xuICAgICAgICB2YWx1ZSA9IG0gPyBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKSA6IHVuZGVmaW5lZDtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufSk7XG5cbnZhciAkT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIE9ic2VydmFibGUoc3Vic2NyaWJlcil7XG4gIGFuSW5zdGFuY2UodGhpcywgJE9ic2VydmFibGUsICdPYnNlcnZhYmxlJywgJ19mJykuX2YgPSBhRnVuY3Rpb24oc3Vic2NyaWJlcik7XG59O1xuXG5yZWRlZmluZUFsbCgkT2JzZXJ2YWJsZS5wcm90b3R5cGUsIHtcbiAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpe1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uKG9ic2VydmVyLCB0aGlzLl9mKTtcbiAgfSxcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChmbil7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgKGNvcmUuUHJvbWlzZSB8fCBnbG9iYWwuUHJvbWlzZSkoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgIGFGdW5jdGlvbihmbik7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhhdC5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0IDogZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4odmFsdWUpO1xuICAgICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiByZWplY3QsXG4gICAgICAgIGNvbXBsZXRlOiByZXNvbHZlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbnJlZGVmaW5lQWxsKCRPYnNlcnZhYmxlLCB7XG4gIGZyb206IGZ1bmN0aW9uIGZyb20oeCl7XG4gICAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiAkT2JzZXJ2YWJsZTtcbiAgICB2YXIgbWV0aG9kID0gZ2V0TWV0aG9kKGFuT2JqZWN0KHgpW09CU0VSVkFCTEVdKTtcbiAgICBpZihtZXRob2Qpe1xuICAgICAgdmFyIG9ic2VydmFibGUgPSBhbk9iamVjdChtZXRob2QuY2FsbCh4KSk7XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZS5jb25zdHJ1Y3RvciA9PT0gQyA/IG9ic2VydmFibGUgOiBuZXcgQyhmdW5jdGlvbihvYnNlcnZlcil7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uKG9ic2VydmVyKXtcbiAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIWRvbmUpe1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZihmb3JPZih4LCBmYWxzZSwgZnVuY3Rpb24oaXQpe1xuICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0KTtcbiAgICAgICAgICAgICAgaWYoZG9uZSlyZXR1cm4gUkVUVVJOO1xuICAgICAgICAgICAgfSkgPT09IFJFVFVSTilyZXR1cm47XG4gICAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIGlmKGRvbmUpdGhyb3cgZTtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKXsgZG9uZSA9IHRydWU7IH07XG4gICAgfSk7XG4gIH0sXG4gIG9mOiBmdW5jdGlvbiBvZigpe1xuICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoLCBpdGVtcyA9IEFycmF5KGwpOyBpIDwgbDspaXRlbXNbaV0gPSBhcmd1bWVudHNbaSsrXTtcbiAgICByZXR1cm4gbmV3ICh0eXBlb2YgdGhpcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiAkT2JzZXJ2YWJsZSkoZnVuY3Rpb24ob2JzZXJ2ZXIpe1xuICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbigpe1xuICAgICAgICBpZighZG9uZSl7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoaXRlbXNbaV0pO1xuICAgICAgICAgICAgaWYoZG9uZSlyZXR1cm47XG4gICAgICAgICAgfSBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpeyBkb25lID0gdHJ1ZTsgfTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbmhpZGUoJE9ic2VydmFibGUucHJvdG90eXBlLCBPQlNFUlZBQkxFLCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5HLCB7T2JzZXJ2YWJsZTogJE9ic2VydmFibGV9KTtcblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnT2JzZXJ2YWJsZScpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9ic2VydmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSAzNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGllOS0gc2V0VGltZW91dCAmIHNldEludGVydmFsIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmaXhcbnZhciBnbG9iYWwgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCAkZXhwb3J0ICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpbnZva2UgICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBwYXJ0aWFsICAgID0gcmVxdWlyZSgnLi9fcGFydGlhbCcpXG4gICwgbmF2aWdhdG9yICA9IGdsb2JhbC5uYXZpZ2F0b3JcbiAgLCBNU0lFICAgICAgID0gISFuYXZpZ2F0b3IgJiYgL01TSUUgLlxcLi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gPC0gZGlydHkgaWU5LSBjaGVja1xudmFyIHdyYXAgPSBmdW5jdGlvbihzZXQpe1xuICByZXR1cm4gTVNJRSA/IGZ1bmN0aW9uKGZuLCB0aW1lIC8qLCAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gc2V0KGludm9rZShcbiAgICAgIHBhcnRpYWwsXG4gICAgICBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksXG4gICAgICB0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pXG4gICAgKSwgdGltZSk7XG4gIH0gOiBzZXQ7XG59O1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkIgKyAkZXhwb3J0LkYgKiBNU0lFLCB7XG4gIHNldFRpbWVvdXQ6ICB3cmFwKGdsb2JhbC5zZXRUaW1lb3V0KSxcbiAgc2V0SW50ZXJ2YWw6IHdyYXAoZ2xvYmFsLnNldEludGVydmFsKVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy93ZWIudGltZXJzLmpzXG4gKiogbW9kdWxlIGlkID0gMzU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgcGF0aCAgICAgID0gcmVxdWlyZSgnLi9fcGF0aCcpXG4gICwgaW52b2tlICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKC8qIC4uLnBhcmdzICovKXtcbiAgdmFyIGZuICAgICA9IGFGdW5jdGlvbih0aGlzKVxuICAgICwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgcGFyZ3MgID0gQXJyYXkobGVuZ3RoKVxuICAgICwgaSAgICAgID0gMFxuICAgICwgXyAgICAgID0gcGF0aC5fXG4gICAgLCBob2xkZXIgPSBmYWxzZTtcbiAgd2hpbGUobGVuZ3RoID4gaSlpZigocGFyZ3NbaV0gPSBhcmd1bWVudHNbaSsrXSkgPT09IF8paG9sZGVyID0gdHJ1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBqID0gMCwgayA9IDAsIGFyZ3M7XG4gICAgaWYoIWhvbGRlciAmJiAhYUxlbilyZXR1cm4gaW52b2tlKGZuLCBwYXJncywgdGhhdCk7XG4gICAgYXJncyA9IHBhcmdzLnNsaWNlKCk7XG4gICAgaWYoaG9sZGVyKWZvcig7bGVuZ3RoID4gajsgaisrKWlmKGFyZ3Nbal0gPT09IF8pYXJnc1tqXSA9IGFyZ3VtZW50c1trKytdO1xuICAgIHdoaWxlKGFMZW4gPiBrKWFyZ3MucHVzaChhcmd1bWVudHNbaysrXSk7XG4gICAgcmV0dXJuIGludm9rZShmbiwgYXJncywgdGhhdCk7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvX3BhcnRpYWwuanNcbiAqKiBtb2R1bGUgaWQgPSAzNTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fcGF0aC5qc1xuICoqIG1vZHVsZSBpZCA9IDM1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICR0YXNrICAgPSByZXF1aXJlKCcuL190YXNrJyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiwge1xuICBzZXRJbW1lZGlhdGU6ICAgJHRhc2suc2V0LFxuICBjbGVhckltbWVkaWF0ZTogJHRhc2suY2xlYXJcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDM1N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRpdGVyYXRvcnMgICAgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpXG4gICwgcmVkZWZpbmUgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBnbG9iYWwgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgSXRlcmF0b3JzICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgd2tzICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpXG4gICwgSVRFUkFUT1IgICAgICA9IHdrcygnaXRlcmF0b3InKVxuICAsIFRPX1NUUklOR19UQUcgPSB3a3MoJ3RvU3RyaW5nVGFnJylcbiAgLCBBcnJheVZhbHVlcyAgID0gSXRlcmF0b3JzLkFycmF5O1xuXG5mb3IodmFyIGNvbGxlY3Rpb25zID0gWydOb2RlTGlzdCcsICdET01Ub2tlbkxpc3QnLCAnTWVkaWFMaXN0JywgJ1N0eWxlU2hlZXRMaXN0JywgJ0NTU1J1bGVMaXN0J10sIGkgPSAwOyBpIDwgNTsgaSsrKXtcbiAgdmFyIE5BTUUgICAgICAgPSBjb2xsZWN0aW9uc1tpXVxuICAgICwgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXVxuICAgICwgcHJvdG8gICAgICA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGVcbiAgICAsIGtleTtcbiAgaWYocHJvdG8pe1xuICAgIGlmKCFwcm90b1tJVEVSQVRPUl0paGlkZShwcm90bywgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgICBpZighcHJvdG9bVE9fU1RSSU5HX1RBR10paGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7XG4gICAgZm9yKGtleSBpbiAkaXRlcmF0b3JzKWlmKCFwcm90b1trZXldKXJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7XG4gIH1cbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSAzNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKChvdXRlckZuIHx8IEdlbmVyYXRvcikucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGB2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0QXJndW1lbnRgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLiBTb21lIG1heSBjb25zaWRlciB0aGUgbmFtZSBvZiB0aGlzIG1ldGhvZCB0b29cbiAgLy8gY3V0ZXN5LCBidXQgdGhleSBhcmUgY3VybXVkZ2VvbnMuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gbmV3IEF3YWl0QXJndW1lbnQoYXJnKTtcbiAgfTtcblxuICBmdW5jdGlvbiBBd2FpdEFyZ3VtZW50KGFyZykge1xuICAgIHRoaXMuYXJnID0gYXJnO1xuICB9XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBd2FpdEFyZ3VtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5hcmcpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy5kb21haW4pIHtcbiAgICAgIGludm9rZSA9IHByb2Nlc3MuZG9tYWluLmJpbmQoaW52b2tlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIiB8fFxuICAgICAgICAgICAgICAobWV0aG9kID09PSBcInRocm93XCIgJiYgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgLy8gQSByZXR1cm4gb3IgdGhyb3cgKHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyB0aHJvd1xuICAgICAgICAgICAgLy8gbWV0aG9kKSBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgICAgdmFyIHJldHVybk1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdO1xuICAgICAgICAgICAgaWYgKHJldHVybk1ldGhvZCkge1xuICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gocmV0dXJuTWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgYXJnKTtcbiAgICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmV0dXJuIG1ldGhvZCB0aHJldyBhbiBleGNlcHRpb24sIGxldCB0aGF0XG4gICAgICAgICAgICAgICAgLy8gZXhjZXB0aW9uIHByZXZhaWwgb3ZlciB0aGUgb3JpZ2luYWwgcmV0dXJuIG9yIHRocm93LlxuICAgICAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICAgICAgLy8gQ29udGludWUgd2l0aCB0aGUgb3V0ZXIgcmV0dXJuLCBub3cgdGhhdCB0aGUgZGVsZWdhdGVcbiAgICAgICAgICAgICAgLy8gaXRlcmF0b3IgaGFzIGJlZW4gdGVybWluYXRlZC5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKFxuICAgICAgICAgICAgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSxcbiAgICAgICAgICAgIGRlbGVnYXRlLml0ZXJhdG9yLFxuICAgICAgICAgICAgYXJnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gTGlrZSByZXR1cm5pbmcgZ2VuZXJhdG9yLnRocm93KHVuY2F1Z2h0KSwgYnV0IHdpdGhvdXQgdGhlXG4gICAgICAgICAgICAvLyBvdmVyaGVhZCBvZiBhbiBleHRyYSBmdW5jdGlvbiBjYWxsLlxuICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERlbGVnYXRlIGdlbmVyYXRvciByYW4gYW5kIGhhbmRsZWQgaXRzIG93biBleGNlcHRpb25zIHNvXG4gICAgICAgICAgLy8gcmVnYXJkbGVzcyBvZiB3aGF0IHRoZSBtZXRob2Qgd2FzLCB3ZSBjb250aW51ZSBhcyBpZiBpdCBpc1xuICAgICAgICAgIC8vIFwibmV4dFwiIHdpdGggYW4gdW5kZWZpbmVkIGFyZy5cbiAgICAgICAgICBtZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG4gICAgICAgICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgICBtZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBhcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmRlbGVnYXRlICYmIG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG4gICAgICAgIHJldHVybiAhIWNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gQW1vbmcgdGhlIHZhcmlvdXMgdHJpY2tzIGZvciBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbFxuICAvLyBvYmplY3QsIHRoaXMgc2VlbXMgdG8gYmUgdGhlIG1vc3QgcmVsaWFibGUgdGVjaG5pcXVlIHRoYXQgZG9lcyBub3RcbiAgLy8gdXNlIGluZGlyZWN0IGV2YWwgKHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzXG4pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1xuICoqIG1vZHVsZSBpZCA9IDM1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9jb3JlLnJlZ2V4cC5lc2NhcGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLlJlZ0V4cC5lc2NhcGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvZm4vcmVnZXhwL2VzY2FwZS5qc1xuICoqIG1vZHVsZSBpZCA9IDM2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL2JlbmphbWluZ3IvUmV4RXhwLmVzY2FwZVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRyZSAgICAgPSByZXF1aXJlKCcuL19yZXBsYWNlcicpKC9bXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZ0V4cCcsIHtlc2NhcGU6IGZ1bmN0aW9uIGVzY2FwZShpdCl7IHJldHVybiAkcmUoaXQpOyB9fSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY29yZS1qcy9tb2R1bGVzL2NvcmUucmVnZXhwLmVzY2FwZS5qc1xuICoqIG1vZHVsZSBpZCA9IDM2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihyZWdFeHAsIHJlcGxhY2Upe1xuICB2YXIgcmVwbGFjZXIgPSByZXBsYWNlID09PSBPYmplY3QocmVwbGFjZSkgPyBmdW5jdGlvbihwYXJ0KXtcbiAgICByZXR1cm4gcmVwbGFjZVtwYXJ0XTtcbiAgfSA6IHJlcGxhY2U7XG4gIHJldHVybiBmdW5jdGlvbihpdCl7XG4gICAgcmV0dXJuIFN0cmluZyhpdCkucmVwbGFjZShyZWdFeHAsIHJlcGxhY2VyKTtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtanMvbW9kdWxlcy9fcmVwbGFjZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAzNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=