(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["DrawTool"] = factory();
	else
		root["DrawTool"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _DrawTool = __webpack_require__(1);
	
	var _DrawTool2 = _interopRequireDefault(_DrawTool);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = _DrawTool2.default;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(2);
	
	var _fontLoader = __webpack_require__(51);
	
	var _fontLoader2 = _interopRequireDefault(_fontLoader);
	
	var _errors = __webpack_require__(52);
	
	var _errors2 = _interopRequireDefault(_errors);
	
	var _escapeJSON = __webpack_require__(53);
	
	var _escapeJSON2 = _interopRequireDefault(_escapeJSON);
	
	__webpack_require__(54);
	
	var _Sides = __webpack_require__(55);
	
	var _Sides2 = _interopRequireDefault(_Sides);
	
	var _DrawHistory = __webpack_require__(62);
	
	var _DrawHistory2 = _interopRequireDefault(_DrawHistory);
	
	__webpack_require__(63);
	
	__webpack_require__(64);
	
	__webpack_require__(65);
	
	__webpack_require__(66);
	
	__webpack_require__(67);
	
	__webpack_require__(68);
	
	__webpack_require__(69);
	
	__webpack_require__(70);
	
	__webpack_require__(71);
	
	__webpack_require__(72);
	
	__webpack_require__(73);
	
	__webpack_require__(74);
	
	__webpack_require__(75);
	
	var _dafaultParams = __webpack_require__(50);
	
	var _dafaultParams2 = _interopRequireDefault(_dafaultParams);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	if (!global._babelPolyfill) {
	  __webpack_require__(76);
	}
	
	/**
	 * @namespace DrawTool
	 */
	var DrawTool = {
	
	  /**
	   * @property editable
	   * @default false
	   * @memberOf DrawTool
	   * @type {boolean}
	   */
	  editable: false,
	
	  /**
	   * @property Container
	   * @default container: {target: document.body, size: {width: document.body.clientWidth, height: document.body.clientHeight}}
	   * @memberOf DrawTool
	   * @type {{target: HTMLElement, size: {width: Number, height: Number}}}
	   */
	  container: {
	    target: document.body,
	    size: {
	      width: 0,
	      height: 0
	    }
	  },
	
	  /**
	   * @property Grid Step
	   * @default 10
	   * @memberOf DrawTool
	   * @type {Number}
	   */
	  gridStep: 10,
	
	  /**
	   * @property Grid
	   * @default {}
	   * @memberOf DrawTool
	   * @type {Object}
	   */
	  grid: {
	    color: 'rgba(150, 150, 150, 0.1)',
	    strokeWidth: 1
	  },
	
	  border: {
	    color: 'rgba(100,200,200,1)',
	    strokeWidth: 1,
	    backgroundColor: 'rgba(150, 150, 150, 0.1)',
	    strokeDashArray: [0, 0]
	  },
	
	  /**
	   * @property Callbacks
	   * @default {}
	   * @memberOf DrawTool
	   * @type {Object}
	   * @private
	   */
	  _callbacks: {},
	
	  /**
	   * @property Sides
	   * @default null
	   * @memberOf DrawTool
	   * @type {Object}
	   */
	  sides: null,
	
	  _evented: true,
	
	  __data: {},
	
	  /**
	   * @method
	   * @memberOf DrawTool
	   * @param target {HTMLElement} target container
	   * @param size {Object} Size of canvas
	   * @param size.width {Number} Width of canvas
	   * @param size.height {Number} height of canvas
	   */
	  initialize: function initialize(target, size) {
	
	    if (!(target instanceof HTMLElement)) {
	      throw new Error(JSON.stringify({ error: _errors2.default.HTMLElementUndefined }));
	      return false;
	    }
	
	    var _target = window.hasOwnProperty('jQuery') && target instanceof jQuery ? target[0] : target;
	
	    var _size = size || {};
	
	    this.container = {
	      target: _target,
	      size: _size
	    };
	
	    this.container.target.textContent = '';
	    this.container.target.style.position = 'relative';
	
	    this.sides = new _Sides2.default();
	
	    this.history = new _DrawHistory2.default();
	  },
	
	
	  /**
	   * Set sides editable
	   * @memberOf DrawTool
	   * @method
	   * @param val {Boolean} default: true
	   */
	  setEditable: function setEditable() {
	    var _this = this;
	
	    var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	
	    this.editable = val;
	
	    this.sides._collection.forEach(function (side) {
	      if (side.FabricBorder) {
	        side.FabricBorder.set('selectable', _this.editable);
	        side.FabricCanvas.deactivateAll().renderAll();
	      }
	    });
	  },
	
	
	  /**
	   * Add event handler
	   * @param {String} event event name
	   * @param {Function} handler Handler function
	   */
	  on: function on(event, handler) {
	    this._callbacks[event] = this._callbacks[event] || [];
	    this._callbacks[event].push(handler);
	  },
	
	
	  /**
	   * Remove event handler
	   * @param {String} event event name
	   * @param {Function} handler Handler function
	   */
	  off: function off(event, handler) {
	    this._callbacks[event].delete(handler);
	  },
	
	
	  /**
	   * Trigger event
	   * @param {String} event event name
	   * @param {Object} data
	   */
	  trigger: function trigger(event, data) {
	
	    if (!this._evented) {
	      return false;
	    }
	
	    if (event === 'history:update') {
	      this.history.pushState(data.side.id);
	      this.sides.getSide(data.side.id).layers.update();
	    }
	
	    if (typeof this._callbacks[event] !== 'undefined') {
	
	      this._callbacks[event].forEach(function (cb) {
	        return cb(JSON.stringify(data));
	      });
	    }
	  },
	
	
	  /**
	   * Export product data
	   * @return {String}
	   */
	  exportJSON: function exportJSON() {
	    var data = this.sides._collection.map(function (side) {
	      return side.toObject();
	    });
	    return JSON.stringify(data);
	  },
	
	
	  /**
	   * Import product data
	   * @param {String} json
	   * @param {Number} initialZoom
	   * @param {Number} proportions
	   */
	  importJSON: function importJSON(json, initialZoom) {
	    var _this2 = this;
	
	    var proportions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _dafaultParams2.default.proportions;
	
	
	    if (this.sides._collection.length) {
	      this.sides._collection.forEach(function (side) {
	        side.items.finalizeBrush();
	        _this2.__data[side.id] = side.toJSON();
	      });
	      this.sides.empty();
	      this.history.history = {};
	    }
	
	    var data = JSON.parse((0, _escapeJSON2.default)(json));
	
	    var promises = data.map(function (side) {
	      var _side = _this2.sides.addSide(side.id);
	      return _side.setImage(side.imageUrl + '?_', side.size.cm, proportions, side.border.cm);
	    });
	
	    return new Promise(function (resolve, reject) {
	
	      Promise.all(promises).then(function (values) {
	        values.map(function (d, index) {
	
	          var _side = _this2.sides.getSide(d.side.id);
	
	          _side.defaultWorkspaceSize = data[index].border.pixel;
	
	          _side.setBorder(data[index].border.cm);
	
	          if (initialZoom) {
	            _side.zoomToVal(initialZoom);
	          }
	
	          if (_this2.__data[_side.id]) {
	            _side.fromJSON(_this2.__data[_side.id]);
	          }
	
	          _side.FabricCanvas.renderAll.bind(_side.FabricCanvas);
	        });
	
	        resolve();
	      });
	    });
	  },
	
	
	  /**
	   * set customise controls
	   * @param {Object} customiseList
	   */
	  setCustomiseControls: function setCustomiseControls(customiseList) {
	    var isVML = function isVML() {
	      return typeof G_vmlCanvasManager !== 'undefined';
	    };
	
	    for (var key in customiseList) {
	      var iconImage = document.createElement('IMG');
	      iconImage.src = customiseList[key].src;
	    }
	
	    fabric.util.object.extend(fabric.Object.prototype, {
	      _drawControl: function _drawControl(control, ctx, methodName, left, top) {
	        if (!this.isControlVisible(control)) {
	          return;
	        }
	        var size = this.cornerSize,
	            stroke = !this.transparentCorners && this.cornerStrokeColor;
	        if (control in customiseList) {
	          var _iconImage = document.createElement('img'),
	              width = size,
	              height = size;
	
	          isVML() || this.transparentCorners || ctx.clearRect(left, top, size, size);
	
	          if ('size' in customiseList[control]) {
	            width = customiseList[control].size.width;
	            height = customiseList[control].size.height;
	          }
	
	          if ('offset' in customiseList[control]) {
	            left += customiseList[control].offset.x + (this.cornerSize - customiseList[control].size.width) / 2;
	            top += customiseList[control].offset.y + (this.cornerSize - customiseList[control].size.height) / 2;
	          }
	
	          _iconImage.src = customiseList[control].src;
	          ctx.drawImage(_iconImage, left, top, width, height);
	        } else {
	          switch (this.cornerStyle) {
	            case 'circle':
	              ctx.beginPath();
	              ctx.arc(left + size / 2, top + size / 2, size / 2, 0, 2 * Math.PI, false);
	              ctx[methodName]();
	              if (stroke) {
	                ctx.stroke();
	              }
	              break;
	            default:
	              isVML() || this.transparentCorners || ctx.clearRect(left, top, size, size);
	              ctx[methodName + 'Rect'](left, top, size, size);
	              if (stroke) {
	                ctx.strokeRect(left, top, size, size);
	              }
	          }
	        }
	      },
	      _setCornerCoords: function _setCornerCoords() {
	        var coords = this.oCoords,
	            newTheta = fabric.util.degreesToRadians(45 - this.angle),
	            cornerHypotenuse = this.cornerSize * 0.707106,
	            cosHalfOffset = cornerHypotenuse * Math.cos(newTheta),
	            sinHalfOffset = cornerHypotenuse * Math.sin(newTheta),
	            x,
	            y;
	
	        for (var point in coords) {
	          var offset = {
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	          };
	
	          if (point in customiseList && typeof customiseList[point].offset != 'undefined') {
	            offset.x = customiseList[point].offset.x;
	            offset.y = customiseList[point].offset.y;
	          }
	
	          if (point in customiseList && typeof customiseList[point].size != 'undefined') {
	            offset.width = this.cornerSize - customiseList[point].size.width;
	            offset.height = this.cornerSize - customiseList[point].size.height;
	          }
	
	          x = coords[point].x + offset.x + offset.width / 2;
	          y = coords[point].y + offset.y + offset.height / 2;
	          coords[point].corner = {
	            tl: {
	              x: x - sinHalfOffset,
	              y: y - cosHalfOffset
	            },
	            tr: {
	              x: x + cosHalfOffset - offset.width,
	              y: y - sinHalfOffset
	            },
	            bl: {
	              x: x - cosHalfOffset,
	              y: y + sinHalfOffset - offset.height
	            },
	            br: {
	              x: x + sinHalfOffset - offset.width,
	              y: y + cosHalfOffset - offset.height
	            }
	          };
	        }
	      }
	    });
	  },
	
	
	  fontLoader: _fontLoader2.default,
	
	  fonts: {}
	
	};
	
	exports.default = DrawTool;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _fabric = __webpack_require__(3);
	
	var _dafaultParams = __webpack_require__(50);
	
	var _dafaultParams2 = _interopRequireDefault(_dafaultParams);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_fabric.fabric.Object.prototype.cornerSize = _dafaultParams2.default.cornerSize;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {/* build: `node build.js modules=ALL exclude=json,gestures minifier=uglifyjs` */
	 /*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */
	
	var fabric = fabric || { version: "1.7.3" };
	if (true) {
	  exports.fabric = fabric;
	}
	
	if (typeof document !== 'undefined' && typeof window !== 'undefined') {
	  fabric.document = document;
	  fabric.window = window;
	  // ensure globality even if entire library were function wrapped (as in Meteor.js packaging system)
	  window.fabric = fabric;
	}
	else {
	  // assume we're running under node.js when document/window are not present
	  fabric.document = __webpack_require__(9)
	    .jsdom(
	      decodeURIComponent("%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E")
	    );
	
	  if (fabric.document.createWindow) {
	    fabric.window = fabric.document.createWindow();
	  } else {
	    fabric.window = fabric.document.parentWindow;
	  }
	}
	
	/**
	 * True when in environment that supports touch events
	 * @type boolean
	 */
	fabric.isTouchSupported = "ontouchstart" in fabric.document.documentElement;
	
	/**
	 * True when in environment that's probably Node.js
	 * @type boolean
	 */
	fabric.isLikelyNode = typeof Buffer !== 'undefined' &&
	                      typeof window === 'undefined';
	
	/* _FROM_SVG_START_ */
	/**
	 * Attributes parsed from all SVG elements
	 * @type array
	 */
	fabric.SHARED_ATTRIBUTES = [
	  "display",
	  "transform",
	  "fill", "fill-opacity", "fill-rule",
	  "opacity",
	  "stroke", "stroke-dasharray", "stroke-linecap",
	  "stroke-linejoin", "stroke-miterlimit",
	  "stroke-opacity", "stroke-width",
	  "id"
	];
	/* _FROM_SVG_END_ */
	
	/**
	 * Pixel per Inch as a default value set to 96. Can be changed for more realistic conversion.
	 */
	fabric.DPI = 96;
	fabric.reNum = '(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:e[-+]?\\d+)?)';
	fabric.fontPaths = { };
	
	/**
	 * Cache Object for widths of chars in text rendering.
	 */
	fabric.charWidthsCache = { };
	
	/**
	 * Device Pixel Ratio
	 * @see https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html
	 */
	fabric.devicePixelRatio = fabric.window.devicePixelRatio ||
	                          fabric.window.webkitDevicePixelRatio ||
	                          fabric.window.mozDevicePixelRatio ||
	                          1;
	
	
	(function() {
	
	  /**
	   * @private
	   * @param {String} eventName
	   * @param {Function} handler
	   */
	  function _removeEventListener(eventName, handler) {
	    if (!this.__eventListeners[eventName]) {
	      return;
	    }
	    var eventListener = this.__eventListeners[eventName];
	    if (handler) {
	      eventListener[eventListener.indexOf(handler)] = false;
	    }
	    else {
	      fabric.util.array.fill(eventListener, false);
	    }
	  }
	
	  /**
	   * Observes specified event
	   * @deprecated `observe` deprecated since 0.8.34 (use `on` instead)
	   * @memberOf fabric.Observable
	   * @alias on
	   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
	   * @param {Function} handler Function that receives a notification when an event of the specified type occurs
	   * @return {Self} thisArg
	   * @chainable
	   */
	  function observe(eventName, handler) {
	    if (!this.__eventListeners) {
	      this.__eventListeners = { };
	    }
	    // one object with key/value pairs was passed
	    if (arguments.length === 1) {
	      for (var prop in eventName) {
	        this.on(prop, eventName[prop]);
	      }
	    }
	    else {
	      if (!this.__eventListeners[eventName]) {
	        this.__eventListeners[eventName] = [];
	      }
	      this.__eventListeners[eventName].push(handler);
	    }
	    return this;
	  }
	
	  /**
	   * Stops event observing for a particular event handler. Calling this method
	   * without arguments removes all handlers for all events
	   * @deprecated `stopObserving` deprecated since 0.8.34 (use `off` instead)
	   * @memberOf fabric.Observable
	   * @alias off
	   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
	   * @param {Function} handler Function to be deleted from EventListeners
	   * @return {Self} thisArg
	   * @chainable
	   */
	  function stopObserving(eventName, handler) {
	    if (!this.__eventListeners) {
	      return;
	    }
	
	    // remove all key/value pairs (event name -> event handler)
	    if (arguments.length === 0) {
	      for (eventName in this.__eventListeners) {
	        _removeEventListener.call(this, eventName);
	      }
	    }
	    // one object with key/value pairs was passed
	    else if (arguments.length === 1 && typeof arguments[0] === 'object') {
	      for (var prop in eventName) {
	        _removeEventListener.call(this, prop, eventName[prop]);
	      }
	    }
	    else {
	      _removeEventListener.call(this, eventName, handler);
	    }
	    return this;
	  }
	
	  /**
	   * Fires event with an optional options object
	   * @deprecated `fire` deprecated since 1.0.7 (use `trigger` instead)
	   * @memberOf fabric.Observable
	   * @alias trigger
	   * @param {String} eventName Event name to fire
	   * @param {Object} [options] Options object
	   * @return {Self} thisArg
	   * @chainable
	   */
	  function fire(eventName, options) {
	    if (!this.__eventListeners) {
	      return;
	    }
	
	    var listenersForEvent = this.__eventListeners[eventName];
	    if (!listenersForEvent) {
	      return;
	    }
	
	    for (var i = 0, len = listenersForEvent.length; i < len; i++) {
	      listenersForEvent[i] && listenersForEvent[i].call(this, options || { });
	    }
	    this.__eventListeners[eventName] = listenersForEvent.filter(function(value) {
	      return value !== false;
	    });
	    return this;
	  }
	
	  /**
	   * @namespace fabric.Observable
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#events}
	   * @see {@link http://fabricjs.com/events|Events demo}
	   */
	  fabric.Observable = {
	    observe: observe,
	    stopObserving: stopObserving,
	    fire: fire,
	
	    on: observe,
	    off: stopObserving,
	    trigger: fire
	  };
	})();
	
	
	/**
	 * @namespace fabric.Collection
	 */
	fabric.Collection = {
	
	  _objects: [],
	
	  /**
	   * Adds objects to collection, Canvas or Group, then renders canvas
	   * (if `renderOnAddRemove` is not `false`).
	   * in case of Group no changes to bounding box are made.
	   * Objects should be instances of (or inherit from) fabric.Object
	   * @param {...fabric.Object} object Zero or more fabric instances
	   * @return {Self} thisArg
	   * @chainable
	   */
	  add: function () {
	    this._objects.push.apply(this._objects, arguments);
	    if (this._onObjectAdded) {
	      for (var i = 0, length = arguments.length; i < length; i++) {
	        this._onObjectAdded(arguments[i]);
	      }
	    }
	    this.renderOnAddRemove && this.renderAll();
	    return this;
	  },
	
	  /**
	   * Inserts an object into collection at specified index, then renders canvas (if `renderOnAddRemove` is not `false`)
	   * An object should be an instance of (or inherit from) fabric.Object
	   * @param {Object} object Object to insert
	   * @param {Number} index Index to insert object at
	   * @param {Boolean} nonSplicing When `true`, no splicing (shifting) of objects occurs
	   * @return {Self} thisArg
	   * @chainable
	   */
	  insertAt: function (object, index, nonSplicing) {
	    var objects = this.getObjects();
	    if (nonSplicing) {
	      objects[index] = object;
	    }
	    else {
	      objects.splice(index, 0, object);
	    }
	    this._onObjectAdded && this._onObjectAdded(object);
	    this.renderOnAddRemove && this.renderAll();
	    return this;
	  },
	
	  /**
	   * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)
	   * @param {...fabric.Object} object Zero or more fabric instances
	   * @return {Self} thisArg
	   * @chainable
	   */
	  remove: function() {
	    var objects = this.getObjects(),
	        index, somethingRemoved = false;
	
	    for (var i = 0, length = arguments.length; i < length; i++) {
	      index = objects.indexOf(arguments[i]);
	
	      // only call onObjectRemoved if an object was actually removed
	      if (index !== -1) {
	        somethingRemoved = true;
	        objects.splice(index, 1);
	        this._onObjectRemoved && this._onObjectRemoved(arguments[i]);
	      }
	    }
	
	    this.renderOnAddRemove && somethingRemoved && this.renderAll();
	    return this;
	  },
	
	  /**
	   * Executes given function for each object in this group
	   * @param {Function} callback
	   *                   Callback invoked with current object as first argument,
	   *                   index - as second and an array of all objects - as third.
	   *                   Callback is invoked in a context of Global Object (e.g. `window`)
	   *                   when no `context` argument is given
	   *
	   * @param {Object} context Context (aka thisObject)
	   * @return {Self} thisArg
	   * @chainable
	   */
	  forEachObject: function(callback, context) {
	    var objects = this.getObjects();
	    for (var i = 0, len = objects.length; i < len; i++) {
	      callback.call(context, objects[i], i, objects);
	    }
	    return this;
	  },
	
	  /**
	   * Returns an array of children objects of this instance
	   * Type parameter introduced in 1.3.10
	   * @param {String} [type] When specified, only objects of this type are returned
	   * @return {Array}
	   */
	  getObjects: function(type) {
	    if (typeof type === 'undefined') {
	      return this._objects;
	    }
	    return this._objects.filter(function(o) {
	      return o.type === type;
	    });
	  },
	
	  /**
	   * Returns object at specified index
	   * @param {Number} index
	   * @return {Self} thisArg
	   */
	  item: function (index) {
	    return this.getObjects()[index];
	  },
	
	  /**
	   * Returns true if collection contains no objects
	   * @return {Boolean} true if collection is empty
	   */
	  isEmpty: function () {
	    return this.getObjects().length === 0;
	  },
	
	  /**
	   * Returns a size of a collection (i.e: length of an array containing its objects)
	   * @return {Number} Collection size
	   */
	  size: function() {
	    return this.getObjects().length;
	  },
	
	  /**
	   * Returns true if collection contains an object
	   * @param {Object} object Object to check against
	   * @return {Boolean} `true` if collection contains an object
	   */
	  contains: function(object) {
	    return this.getObjects().indexOf(object) > -1;
	  },
	
	  /**
	   * Returns number representation of a collection complexity
	   * @return {Number} complexity
	   */
	  complexity: function () {
	    return this.getObjects().reduce(function (memo, current) {
	      memo += current.complexity ? current.complexity() : 0;
	      return memo;
	    }, 0);
	  }
	};
	
	
	/**
	 * @namespace fabric.CommonMethods
	 */
	fabric.CommonMethods = {
	
	  /**
	   * Sets object's properties from options
	   * @param {Object} [options] Options object
	   */
	  _setOptions: function(options) {
	    for (var prop in options) {
	      this.set(prop, options[prop]);
	    }
	  },
	
	  /**
	   * @private
	   * @param {Object} [filler] Options object
	   * @param {String} [property] property to set the Gradient to
	   */
	  _initGradient: function(filler, property) {
	    if (filler && filler.colorStops && !(filler instanceof fabric.Gradient)) {
	      this.set(property, new fabric.Gradient(filler));
	    }
	  },
	
	  /**
	   * @private
	   * @param {Object} [filler] Options object
	   * @param {String} [property] property to set the Pattern to
	   * @param {Function} [callback] callback to invoke after pattern load
	   */
	  _initPattern: function(filler, property, callback) {
	    if (filler && filler.source && !(filler instanceof fabric.Pattern)) {
	      this.set(property, new fabric.Pattern(filler, callback));
	    }
	    else {
	      callback && callback();
	    }
	  },
	
	  /**
	   * @private
	   * @param {Object} [options] Options object
	   */
	  _initClipping: function(options) {
	    if (!options.clipTo || typeof options.clipTo !== 'string') {
	      return;
	    }
	
	    var functionBody = fabric.util.getFunctionBody(options.clipTo);
	    if (typeof functionBody !== 'undefined') {
	      this.clipTo = new Function('ctx', functionBody);
	    }
	  },
	
	  /**
	   * @private
	   */
	  _setObject: function(obj) {
	    for (var prop in obj) {
	      this._set(prop, obj[prop]);
	    }
	  },
	
	  /**
	   * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.
	   * @param {String|Object} key Property name or object (if object, iterate over the object properties)
	   * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  set: function(key, value) {
	    if (typeof key === 'object') {
	      this._setObject(key);
	    }
	    else {
	      if (typeof value === 'function' && key !== 'clipTo') {
	        this._set(key, value(this.get(key)));
	      }
	      else {
	        this._set(key, value);
	      }
	    }
	    return this;
	  },
	
	  _set: function(key, value) {
	    this[key] = value;
	  },
	
	  /**
	   * Toggles specified property from `true` to `false` or from `false` to `true`
	   * @param {String} property Property to toggle
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  toggle: function(property) {
	    var value = this.get(property);
	    if (typeof value === 'boolean') {
	      this.set(property, !value);
	    }
	    return this;
	  },
	
	  /**
	   * Basic getter
	   * @param {String} property Property name
	   * @return {*} value of a property
	   */
	  get: function(property) {
	    return this[property];
	  }
	};
	
	
	(function(global) {
	
	  var sqrt = Math.sqrt,
	      atan2 = Math.atan2,
	      pow = Math.pow,
	      abs = Math.abs,
	      PiBy180 = Math.PI / 180;
	
	  /**
	   * @namespace fabric.util
	   */
	  fabric.util = {
	
	    /**
	     * Removes value from an array.
	     * Presence of value (and its position in an array) is determined via `Array.prototype.indexOf`
	     * @static
	     * @memberOf fabric.util
	     * @param {Array} array
	     * @param {*} value
	     * @return {Array} original array
	     */
	    removeFromArray: function(array, value) {
	      var idx = array.indexOf(value);
	      if (idx !== -1) {
	        array.splice(idx, 1);
	      }
	      return array;
	    },
	
	    /**
	     * Returns random number between 2 specified ones.
	     * @static
	     * @memberOf fabric.util
	     * @param {Number} min lower limit
	     * @param {Number} max upper limit
	     * @return {Number} random value (between min and max)
	     */
	    getRandomInt: function(min, max) {
	      return Math.floor(Math.random() * (max - min + 1)) + min;
	    },
	
	    /**
	     * Transforms degrees to radians.
	     * @static
	     * @memberOf fabric.util
	     * @param {Number} degrees value in degrees
	     * @return {Number} value in radians
	     */
	    degreesToRadians: function(degrees) {
	      return degrees * PiBy180;
	    },
	
	    /**
	     * Transforms radians to degrees.
	     * @static
	     * @memberOf fabric.util
	     * @param {Number} radians value in radians
	     * @return {Number} value in degrees
	     */
	    radiansToDegrees: function(radians) {
	      return radians / PiBy180;
	    },
	
	    /**
	     * Rotates `point` around `origin` with `radians`
	     * @static
	     * @memberOf fabric.util
	     * @param {fabric.Point} point The point to rotate
	     * @param {fabric.Point} origin The origin of the rotation
	     * @param {Number} radians The radians of the angle for the rotation
	     * @return {fabric.Point} The new rotated point
	     */
	    rotatePoint: function(point, origin, radians) {
	      point.subtractEquals(origin);
	      var v = fabric.util.rotateVector(point, radians);
	      return new fabric.Point(v.x, v.y).addEquals(origin);
	    },
	
	    /**
	     * Rotates `vector` with `radians`
	     * @static
	     * @memberOf fabric.util
	     * @param {Object} vector The vector to rotate (x and y)
	     * @param {Number} radians The radians of the angle for the rotation
	     * @return {Object} The new rotated point
	     */
	    rotateVector: function(vector, radians) {
	      var sin = Math.sin(radians),
	          cos = Math.cos(radians),
	          rx = vector.x * cos - vector.y * sin,
	          ry = vector.x * sin + vector.y * cos;
	      return {
	        x: rx,
	        y: ry
	      };
	    },
	
	    /**
	     * Apply transform t to point p
	     * @static
	     * @memberOf fabric.util
	     * @param  {fabric.Point} p The point to transform
	     * @param  {Array} t The transform
	     * @param  {Boolean} [ignoreOffset] Indicates that the offset should not be applied
	     * @return {fabric.Point} The transformed point
	     */
	    transformPoint: function(p, t, ignoreOffset) {
	      if (ignoreOffset) {
	        return new fabric.Point(
	          t[0] * p.x + t[2] * p.y,
	          t[1] * p.x + t[3] * p.y
	        );
	      }
	      return new fabric.Point(
	        t[0] * p.x + t[2] * p.y + t[4],
	        t[1] * p.x + t[3] * p.y + t[5]
	      );
	    },
	
	    /**
	     * Returns coordinates of points's bounding rectangle (left, top, width, height)
	     * @param {Array} points 4 points array
	     * @return {Object} Object with left, top, width, height properties
	     */
	    makeBoundingBoxFromPoints: function(points) {
	      var xPoints = [points[0].x, points[1].x, points[2].x, points[3].x],
	          minX = fabric.util.array.min(xPoints),
	          maxX = fabric.util.array.max(xPoints),
	          width = Math.abs(minX - maxX),
	          yPoints = [points[0].y, points[1].y, points[2].y, points[3].y],
	          minY = fabric.util.array.min(yPoints),
	          maxY = fabric.util.array.max(yPoints),
	          height = Math.abs(minY - maxY);
	
	      return {
	        left: minX,
	        top: minY,
	        width: width,
	        height: height
	      };
	    },
	
	    /**
	     * Invert transformation t
	     * @static
	     * @memberOf fabric.util
	     * @param {Array} t The transform
	     * @return {Array} The inverted transform
	     */
	    invertTransform: function(t) {
	      var a = 1 / (t[0] * t[3] - t[1] * t[2]),
	          r = [a * t[3], -a * t[1], -a * t[2], a * t[0]],
	          o = fabric.util.transformPoint({ x: t[4], y: t[5] }, r, true);
	      r[4] = -o.x;
	      r[5] = -o.y;
	      return r;
	    },
	
	    /**
	     * A wrapper around Number#toFixed, which contrary to native method returns number, not string.
	     * @static
	     * @memberOf fabric.util
	     * @param {Number|String} number number to operate on
	     * @param {Number} fractionDigits number of fraction digits to "leave"
	     * @return {Number}
	     */
	    toFixed: function(number, fractionDigits) {
	      return parseFloat(Number(number).toFixed(fractionDigits));
	    },
	
	    /**
	     * Converts from attribute value to pixel value if applicable.
	     * Returns converted pixels or original value not converted.
	     * @param {Number|String} value number to operate on
	     * @param {Number} fontSize
	     * @return {Number|String}
	     */
	    parseUnit: function(value, fontSize) {
	      var unit = /\D{0,2}$/.exec(value),
	          number = parseFloat(value);
	      if (!fontSize) {
	        fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;
	      }
	      switch (unit[0]) {
	        case 'mm':
	          return number * fabric.DPI / 25.4;
	
	        case 'cm':
	          return number * fabric.DPI / 2.54;
	
	        case 'in':
	          return number * fabric.DPI;
	
	        case 'pt':
	          return number * fabric.DPI / 72; // or * 4 / 3
	
	        case 'pc':
	          return number * fabric.DPI / 72 * 12; // or * 16
	
	        case 'em':
	          return number * fontSize;
	
	        default:
	          return number;
	      }
	    },
	
	    /**
	     * Function which always returns `false`.
	     * @static
	     * @memberOf fabric.util
	     * @return {Boolean}
	     */
	    falseFunction: function() {
	      return false;
	    },
	
	    /**
	     * Returns klass "Class" object of given namespace
	     * @memberOf fabric.util
	     * @param {String} type Type of object (eg. 'circle')
	     * @param {String} namespace Namespace to get klass "Class" object from
	     * @return {Object} klass "Class"
	     */
	    getKlass: function(type, namespace) {
	      // capitalize first letter only
	      type = fabric.util.string.camelize(type.charAt(0).toUpperCase() + type.slice(1));
	      return fabric.util.resolveNamespace(namespace)[type];
	    },
	
	    /**
	     * Returns object of given namespace
	     * @memberOf fabric.util
	     * @param {String} namespace Namespace string e.g. 'fabric.Image.filter' or 'fabric'
	     * @return {Object} Object for given namespace (default fabric)
	     */
	    resolveNamespace: function(namespace) {
	      if (!namespace) {
	        return fabric;
	      }
	
	      var parts = namespace.split('.'),
	          len = parts.length, i,
	          obj = global || fabric.window;
	
	      for (i = 0; i < len; ++i) {
	        obj = obj[parts[i]];
	      }
	
	      return obj;
	    },
	
	    /**
	     * Loads image element from given url and passes it to a callback
	     * @memberOf fabric.util
	     * @param {String} url URL representing an image
	     * @param {Function} callback Callback; invoked with loaded image
	     * @param {*} [context] Context to invoke callback in
	     * @param {Object} [crossOrigin] crossOrigin value to set image element to
	     */
	    loadImage: function(url, callback, context, crossOrigin) {
	      if (!url) {
	        callback && callback.call(context, url);
	        return;
	      }
	
	      var img = fabric.util.createImage();
	
	      /** @ignore */
	      img.onload = function () {
	        callback && callback.call(context, img);
	        img = img.onload = img.onerror = null;
	      };
	
	      /** @ignore */
	      img.onerror = function() {
	        fabric.log('Error loading ' + img.src);
	        callback && callback.call(context, null, true);
	        img = img.onload = img.onerror = null;
	      };
	
	      // data-urls appear to be buggy with crossOrigin
	      // https://github.com/kangax/fabric.js/commit/d0abb90f1cd5c5ef9d2a94d3fb21a22330da3e0a#commitcomment-4513767
	      // see https://code.google.com/p/chromium/issues/detail?id=315152
	      //     https://bugzilla.mozilla.org/show_bug.cgi?id=935069
	      if (url.indexOf('data') !== 0 && crossOrigin) {
	        img.crossOrigin = crossOrigin;
	      }
	
	      img.src = url;
	    },
	
	    /**
	     * Creates corresponding fabric instances from their object representations
	     * @static
	     * @memberOf fabric.util
	     * @param {Array} objects Objects to enliven
	     * @param {Function} callback Callback to invoke when all objects are created
	     * @param {String} namespace Namespace to get klass "Class" object from
	     * @param {Function} reviver Method for further parsing of object elements,
	     * called after each fabric object created.
	     */
	    enlivenObjects: function(objects, callback, namespace, reviver) {
	      objects = objects || [];
	
	      function onLoaded() {
	        if (++numLoadedObjects === numTotalObjects) {
	          callback && callback(enlivenedObjects);
	        }
	      }
	
	      var enlivenedObjects = [],
	          numLoadedObjects = 0,
	          numTotalObjects = objects.length,
	          forceAsync = true;
	
	      if (!numTotalObjects) {
	        callback && callback(enlivenedObjects);
	        return;
	      }
	
	      objects.forEach(function (o, index) {
	        // if sparse array
	        if (!o || !o.type) {
	          onLoaded();
	          return;
	        }
	        var klass = fabric.util.getKlass(o.type, namespace);
	        klass.fromObject(o, function (obj, error) {
	          error || (enlivenedObjects[index] = obj);
	          reviver && reviver(o, obj, error);
	          onLoaded();
	        }, forceAsync);
	      });
	    },
	
	    /**
	     * Create and wait for loading of patterns
	     * @static
	     * @memberOf fabric.util
	     * @param {Array} objects Objects to enliven
	     * @param {Function} callback Callback to invoke when all objects are created
	     * @param {String} namespace Namespace to get klass "Class" object from
	     * @param {Function} reviver Method for further parsing of object elements,
	     * called after each fabric object created.
	     */
	    enlivenPatterns: function(patterns, callback) {
	      patterns = patterns || [];
	
	      function onLoaded() {
	        if (++numLoadedPatterns === numPatterns) {
	          callback && callback(enlivenedPatterns);
	        }
	      }
	
	      var enlivenedPatterns = [],
	          numLoadedPatterns = 0,
	          numPatterns = patterns.length;
	
	      if (!numPatterns) {
	        callback && callback(enlivenedPatterns);
	        return;
	      }
	
	      patterns.forEach(function (p, index) {
	        if (p && p.source) {
	          new fabric.Pattern(p, function(pattern) {
	            enlivenedPatterns[index] = pattern;
	            onLoaded();
	          });
	        }
	        else {
	          enlivenedPatterns[index] = p;
	          onLoaded();
	        }
	      });
	    },
	
	    /**
	     * Groups SVG elements (usually those retrieved from SVG document)
	     * @static
	     * @memberOf fabric.util
	     * @param {Array} elements SVG elements to group
	     * @param {Object} [options] Options object
	     * @param {String} path Value to set sourcePath to
	     * @return {fabric.Object|fabric.PathGroup}
	     */
	    groupSVGElements: function(elements, options, path) {
	      var object;
	
	      object = new fabric.PathGroup(elements, options);
	
	      if (typeof path !== 'undefined') {
	        object.setSourcePath(path);
	      }
	      return object;
	    },
	
	    /**
	     * Populates an object with properties of another object
	     * @static
	     * @memberOf fabric.util
	     * @param {Object} source Source object
	     * @param {Object} destination Destination object
	     * @return {Array} properties Propertie names to include
	     */
	    populateWithProperties: function(source, destination, properties) {
	      if (properties && Object.prototype.toString.call(properties) === '[object Array]') {
	        for (var i = 0, len = properties.length; i < len; i++) {
	          if (properties[i] in source) {
	            destination[properties[i]] = source[properties[i]];
	          }
	        }
	      }
	    },
	
	    /**
	     * Draws a dashed line between two points
	     *
	     * This method is used to draw dashed line around selection area.
	     * See <a href="http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas">dotted stroke in canvas</a>
	     *
	     * @param {CanvasRenderingContext2D} ctx context
	     * @param {Number} x  start x coordinate
	     * @param {Number} y start y coordinate
	     * @param {Number} x2 end x coordinate
	     * @param {Number} y2 end y coordinate
	     * @param {Array} da dash array pattern
	     */
	    drawDashedLine: function(ctx, x, y, x2, y2, da) {
	      var dx = x2 - x,
	          dy = y2 - y,
	          len = sqrt(dx * dx + dy * dy),
	          rot = atan2(dy, dx),
	          dc = da.length,
	          di = 0,
	          draw = true;
	
	      ctx.save();
	      ctx.translate(x, y);
	      ctx.moveTo(0, 0);
	      ctx.rotate(rot);
	
	      x = 0;
	      while (len > x) {
	        x += da[di++ % dc];
	        if (x > len) {
	          x = len;
	        }
	        ctx[draw ? 'lineTo' : 'moveTo'](x, 0);
	        draw = !draw;
	      }
	
	      ctx.restore();
	    },
	
	    /**
	     * Creates canvas element and initializes it via excanvas if necessary
	     * @static
	     * @memberOf fabric.util
	     * @param {CanvasElement} [canvasEl] optional canvas element to initialize;
	     * when not given, element is created implicitly
	     * @return {CanvasElement} initialized canvas element
	     */
	    createCanvasElement: function(canvasEl) {
	      canvasEl || (canvasEl = fabric.document.createElement('canvas'));
	      /* eslint-disable camelcase */
	      if (!canvasEl.getContext && typeof G_vmlCanvasManager !== 'undefined') {
	        G_vmlCanvasManager.initElement(canvasEl);
	      }
	      /* eslint-enable camelcase */
	      return canvasEl;
	    },
	
	    /**
	     * Creates image element (works on client and node)
	     * @static
	     * @memberOf fabric.util
	     * @return {HTMLImageElement} HTML image element
	     */
	    createImage: function() {
	      return fabric.isLikelyNode
	        ? new (__webpack_require__(10).Image)()
	        : fabric.document.createElement('img');
	    },
	
	    /**
	     * Creates accessors (getXXX, setXXX) for a "class", based on "stateProperties" array
	     * @static
	     * @memberOf fabric.util
	     * @param {Object} klass "Class" to create accessors for
	     */
	    createAccessors: function(klass) {
	      var proto = klass.prototype, i, propName,
	          capitalizedPropName, setterName, getterName;
	
	      for (i = proto.stateProperties.length; i--; ) {
	
	        propName = proto.stateProperties[i];
	        capitalizedPropName = propName.charAt(0).toUpperCase() + propName.slice(1);
	        setterName = 'set' + capitalizedPropName;
	        getterName = 'get' + capitalizedPropName;
	
	        // using `new Function` for better introspection
	        if (!proto[getterName]) {
	          proto[getterName] = (function(property) {
	            return new Function('return this.get("' + property + '")');
	          })(propName);
	        }
	        if (!proto[setterName]) {
	          proto[setterName] = (function(property) {
	            return new Function('value', 'return this.set("' + property + '", value)');
	          })(propName);
	        }
	      }
	    },
	
	    /**
	     * @static
	     * @memberOf fabric.util
	     * @param {fabric.Object} receiver Object implementing `clipTo` method
	     * @param {CanvasRenderingContext2D} ctx Context to clip
	     */
	    clipContext: function(receiver, ctx) {
	      ctx.save();
	      ctx.beginPath();
	      receiver.clipTo(ctx);
	      ctx.clip();
	    },
	
	    /**
	     * Multiply matrix A by matrix B to nest transformations
	     * @static
	     * @memberOf fabric.util
	     * @param  {Array} a First transformMatrix
	     * @param  {Array} b Second transformMatrix
	     * @param  {Boolean} is2x2 flag to multiply matrices as 2x2 matrices
	     * @return {Array} The product of the two transform matrices
	     */
	    multiplyTransformMatrices: function(a, b, is2x2) {
	      // Matrix multiply a * b
	      return [
	        a[0] * b[0] + a[2] * b[1],
	        a[1] * b[0] + a[3] * b[1],
	        a[0] * b[2] + a[2] * b[3],
	        a[1] * b[2] + a[3] * b[3],
	        is2x2 ? 0 : a[0] * b[4] + a[2] * b[5] + a[4],
	        is2x2 ? 0 : a[1] * b[4] + a[3] * b[5] + a[5]
	      ];
	    },
	
	    /**
	     * Decomposes standard 2x2 matrix into transform componentes
	     * @static
	     * @memberOf fabric.util
	     * @param  {Array} a transformMatrix
	     * @return {Object} Components of transform
	     */
	    qrDecompose: function(a) {
	      var angle = atan2(a[1], a[0]),
	          denom = pow(a[0], 2) + pow(a[1], 2),
	          scaleX = sqrt(denom),
	          scaleY = (a[0] * a[3] - a[2] * a [1]) / scaleX,
	          skewX = atan2(a[0] * a[2] + a[1] * a [3], denom);
	      return {
	        angle: angle  / PiBy180,
	        scaleX: scaleX,
	        scaleY: scaleY,
	        skewX: skewX / PiBy180,
	        skewY: 0,
	        translateX: a[4],
	        translateY: a[5]
	      };
	    },
	
	    customTransformMatrix: function(scaleX, scaleY, skewX) {
	      var skewMatrixX = [1, 0, abs(Math.tan(skewX * PiBy180)), 1],
	          scaleMatrix = [abs(scaleX), 0, 0, abs(scaleY)];
	      return fabric.util.multiplyTransformMatrices(scaleMatrix, skewMatrixX, true);
	    },
	
	    resetObjectTransform: function (target) {
	      target.scaleX = 1;
	      target.scaleY = 1;
	      target.skewX = 0;
	      target.skewY = 0;
	      target.flipX = false;
	      target.flipY = false;
	      target.setAngle(0);
	    },
	
	    /**
	     * Returns string representation of function body
	     * @param {Function} fn Function to get body of
	     * @return {String} Function body
	     */
	    getFunctionBody: function(fn) {
	      return (String(fn).match(/function[^{]*\{([\s\S]*)\}/) || {})[1];
	    },
	
	    /**
	     * Returns true if context has transparent pixel
	     * at specified location (taking tolerance into account)
	     * @param {CanvasRenderingContext2D} ctx context
	     * @param {Number} x x coordinate
	     * @param {Number} y y coordinate
	     * @param {Number} tolerance Tolerance
	     */
	    isTransparent: function(ctx, x, y, tolerance) {
	
	      // If tolerance is > 0 adjust start coords to take into account.
	      // If moves off Canvas fix to 0
	      if (tolerance > 0) {
	        if (x > tolerance) {
	          x -= tolerance;
	        }
	        else {
	          x = 0;
	        }
	        if (y > tolerance) {
	          y -= tolerance;
	        }
	        else {
	          y = 0;
	        }
	      }
	
	      var _isTransparent = true, i, temp,
	          imageData = ctx.getImageData(x, y, (tolerance * 2) || 1, (tolerance * 2) || 1),
	          l = imageData.data.length;
	
	      // Split image data - for tolerance > 1, pixelDataSize = 4;
	      for (i = 3; i < l; i += 4) {
	        temp = imageData.data[i];
	        _isTransparent = temp <= 0;
	        if (_isTransparent === false) {
	          break; // Stop if colour found
	        }
	      }
	
	      imageData = null;
	
	      return _isTransparent;
	    },
	
	    /**
	     * Parse preserveAspectRatio attribute from element
	     * @param {string} attribute to be parsed
	     * @return {Object} an object containing align and meetOrSlice attribute
	     */
	    parsePreserveAspectRatioAttribute: function(attribute) {
	      var meetOrSlice = 'meet', alignX = 'Mid', alignY = 'Mid',
	          aspectRatioAttrs = attribute.split(' '), align;
	
	      if (aspectRatioAttrs && aspectRatioAttrs.length) {
	        meetOrSlice = aspectRatioAttrs.pop();
	        if (meetOrSlice !== 'meet' && meetOrSlice !== 'slice') {
	          align = meetOrSlice;
	          meetOrSlice = 'meet';
	        }
	        else if (aspectRatioAttrs.length) {
	          align = aspectRatioAttrs.pop();
	        }
	      }
	      //divide align in alignX and alignY
	      alignX = align !== 'none' ? align.slice(1, 4) : 'none';
	      alignY = align !== 'none' ? align.slice(5, 8) : 'none';
	      return {
	        meetOrSlice: meetOrSlice,
	        alignX: alignX,
	        alignY: alignY
	      };
	    },
	
	    /**
	     * Clear char widths cache for a font family.
	     * @memberOf fabric.util
	     * @param {String} [fontFamily] font family to clear
	     */
	    clearFabricFontCache: function(fontFamily) {
	      if (!fontFamily) {
	        fabric.charWidthsCache = { };
	      }
	      else if (fabric.charWidthsCache[fontFamily]) {
	        delete fabric.charWidthsCache[fontFamily];
	      }
	    }
	  };
	
	})( true ? exports : this);
	
	
	(function() {
	
	  var arcToSegmentsCache = { },
	      segmentToBezierCache = { },
	      boundsOfCurveCache = { },
	      _join = Array.prototype.join;
	
	  /* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp
	   * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here
	   * http://mozilla.org/MPL/2.0/
	   */
	  function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {
	    var argsString = _join.call(arguments);
	    if (arcToSegmentsCache[argsString]) {
	      return arcToSegmentsCache[argsString];
	    }
	
	    var PI = Math.PI, th = rotateX * PI / 180,
	        sinTh = Math.sin(th),
	        cosTh = Math.cos(th),
	        fromX = 0, fromY = 0;
	
	    rx = Math.abs(rx);
	    ry = Math.abs(ry);
	
	    var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5,
	        py = -cosTh * toY * 0.5 + sinTh * toX * 0.5,
	        rx2 = rx * rx, ry2 = ry * ry, py2 = py * py, px2 = px * px,
	        pl = rx2 * ry2 - rx2 * py2 - ry2 * px2,
	        root = 0;
	
	    if (pl < 0) {
	      var s = Math.sqrt(1 - pl / (rx2 * ry2));
	      rx *= s;
	      ry *= s;
	    }
	    else {
	      root = (large === sweep ? -1.0 : 1.0) *
	              Math.sqrt( pl / (rx2 * py2 + ry2 * px2));
	    }
	
	    var cx = root * rx * py / ry,
	        cy = -root * ry * px / rx,
	        cx1 = cosTh * cx - sinTh * cy + toX * 0.5,
	        cy1 = sinTh * cx + cosTh * cy + toY * 0.5,
	        mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry),
	        dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);
	
	    if (sweep === 0 && dtheta > 0) {
	      dtheta -= 2 * PI;
	    }
	    else if (sweep === 1 && dtheta < 0) {
	      dtheta += 2 * PI;
	    }
	
	    // Convert into cubic bezier segments <= 90deg
	    var segments = Math.ceil(Math.abs(dtheta / PI * 2)),
	        result = [], mDelta = dtheta / segments,
	        mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2),
	        th3 = mTheta + mDelta;
	
	    for (var i = 0; i < segments; i++) {
	      result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);
	      fromX = result[i][4];
	      fromY = result[i][5];
	      mTheta = th3;
	      th3 += mDelta;
	    }
	    arcToSegmentsCache[argsString] = result;
	    return result;
	  }
	
	  function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {
	    var argsString2 = _join.call(arguments);
	    if (segmentToBezierCache[argsString2]) {
	      return segmentToBezierCache[argsString2];
	    }
	
	    var costh2 = Math.cos(th2),
	        sinth2 = Math.sin(th2),
	        costh3 = Math.cos(th3),
	        sinth3 = Math.sin(th3),
	        toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1,
	        toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1,
	        cp1X = fromX + mT * ( -cosTh * rx * sinth2 - sinTh * ry * costh2),
	        cp1Y = fromY + mT * ( -sinTh * rx * sinth2 + cosTh * ry * costh2),
	        cp2X = toX + mT * ( cosTh * rx * sinth3 + sinTh * ry * costh3),
	        cp2Y = toY + mT * ( sinTh * rx * sinth3 - cosTh * ry * costh3);
	
	    segmentToBezierCache[argsString2] = [
	      cp1X, cp1Y,
	      cp2X, cp2Y,
	      toX, toY
	    ];
	    return segmentToBezierCache[argsString2];
	  }
	
	  /*
	   * Private
	   */
	  function calcVectorAngle(ux, uy, vx, vy) {
	    var ta = Math.atan2(uy, ux),
	        tb = Math.atan2(vy, vx);
	    if (tb >= ta) {
	      return tb - ta;
	    }
	    else {
	      return 2 * Math.PI - (ta - tb);
	    }
	  }
	
	  /**
	   * Draws arc
	   * @param {CanvasRenderingContext2D} ctx
	   * @param {Number} fx
	   * @param {Number} fy
	   * @param {Array} coords
	   */
	  fabric.util.drawArc = function(ctx, fx, fy, coords) {
	    var rx = coords[0],
	        ry = coords[1],
	        rot = coords[2],
	        large = coords[3],
	        sweep = coords[4],
	        tx = coords[5],
	        ty = coords[6],
	        segs = [[], [], [], []],
	        segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);
	
	    for (var i = 0, len = segsNorm.length; i < len; i++) {
	      segs[i][0] = segsNorm[i][0] + fx;
	      segs[i][1] = segsNorm[i][1] + fy;
	      segs[i][2] = segsNorm[i][2] + fx;
	      segs[i][3] = segsNorm[i][3] + fy;
	      segs[i][4] = segsNorm[i][4] + fx;
	      segs[i][5] = segsNorm[i][5] + fy;
	      ctx.bezierCurveTo.apply(ctx, segs[i]);
	    }
	  };
	
	  /**
	   * Calculate bounding box of a elliptic-arc
	   * @param {Number} fx start point of arc
	   * @param {Number} fy
	   * @param {Number} rx horizontal radius
	   * @param {Number} ry vertical radius
	   * @param {Number} rot angle of horizontal axe
	   * @param {Number} large 1 or 0, whatever the arc is the big or the small on the 2 points
	   * @param {Number} sweep 1 or 0, 1 clockwise or counterclockwise direction
	   * @param {Number} tx end point of arc
	   * @param {Number} ty
	   */
	  fabric.util.getBoundsOfArc = function(fx, fy, rx, ry, rot, large, sweep, tx, ty) {
	
	    var fromX = 0, fromY = 0, bound, bounds = [],
	        segs = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);
	
	    for (var i = 0, len = segs.length; i < len; i++) {
	      bound = getBoundsOfCurve(fromX, fromY, segs[i][0], segs[i][1], segs[i][2], segs[i][3], segs[i][4], segs[i][5]);
	      bounds.push({ x: bound[0].x + fx, y: bound[0].y + fy });
	      bounds.push({ x: bound[1].x + fx, y: bound[1].y + fy });
	      fromX = segs[i][4];
	      fromY = segs[i][5];
	    }
	    return bounds;
	  };
	
	  /**
	   * Calculate bounding box of a beziercurve
	   * @param {Number} x0 starting point
	   * @param {Number} y0
	   * @param {Number} x1 first control point
	   * @param {Number} y1
	   * @param {Number} x2 secondo control point
	   * @param {Number} y2
	   * @param {Number} x3 end of beizer
	   * @param {Number} y3
	   */
	  // taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.
	  function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {
	    var argsString = _join.call(arguments);
	    if (boundsOfCurveCache[argsString]) {
	      return boundsOfCurveCache[argsString];
	    }
	
	    var sqrt = Math.sqrt,
	        min = Math.min, max = Math.max,
	        abs = Math.abs, tvalues = [],
	        bounds = [[], []],
	        a, b, c, t, t1, t2, b2ac, sqrtb2ac;
	
	    b = 6 * x0 - 12 * x1 + 6 * x2;
	    a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
	    c = 3 * x1 - 3 * x0;
	
	    for (var i = 0; i < 2; ++i) {
	      if (i > 0) {
	        b = 6 * y0 - 12 * y1 + 6 * y2;
	        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
	        c = 3 * y1 - 3 * y0;
	      }
	
	      if (abs(a) < 1e-12) {
	        if (abs(b) < 1e-12) {
	          continue;
	        }
	        t = -c / b;
	        if (0 < t && t < 1) {
	          tvalues.push(t);
	        }
	        continue;
	      }
	      b2ac = b * b - 4 * c * a;
	      if (b2ac < 0) {
	        continue;
	      }
	      sqrtb2ac = sqrt(b2ac);
	      t1 = (-b + sqrtb2ac) / (2 * a);
	      if (0 < t1 && t1 < 1) {
	        tvalues.push(t1);
	      }
	      t2 = (-b - sqrtb2ac) / (2 * a);
	      if (0 < t2 && t2 < 1) {
	        tvalues.push(t2);
	      }
	    }
	
	    var x, y, j = tvalues.length, jlen = j, mt;
	    while (j--) {
	      t = tvalues[j];
	      mt = 1 - t;
	      x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);
	      bounds[0][j] = x;
	
	      y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);
	      bounds[1][j] = y;
	    }
	
	    bounds[0][jlen] = x0;
	    bounds[1][jlen] = y0;
	    bounds[0][jlen + 1] = x3;
	    bounds[1][jlen + 1] = y3;
	    var result = [
	      {
	        x: min.apply(null, bounds[0]),
	        y: min.apply(null, bounds[1])
	      },
	      {
	        x: max.apply(null, bounds[0]),
	        y: max.apply(null, bounds[1])
	      }
	    ];
	    boundsOfCurveCache[argsString] = result;
	    return result;
	  }
	
	  fabric.util.getBoundsOfCurve = getBoundsOfCurve;
	
	})();
	
	
	(function() {
	
	  var slice = Array.prototype.slice;
	
	  /* _ES5_COMPAT_START_ */
	
	  if (!Array.prototype.indexOf) {
	    /**
	     * Finds index of an element in an array
	     * @param {*} searchElement
	     * @return {Number}
	     */
	    Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
	      if (this === void 0 || this === null) {
	        throw new TypeError();
	      }
	      var t = Object(this), len = t.length >>> 0;
	      if (len === 0) {
	        return -1;
	      }
	      var n = 0;
	      if (arguments.length > 0) {
	        n = Number(arguments[1]);
	        if (n !== n) { // shortcut for verifying if it's NaN
	          n = 0;
	        }
	        else if (n !== 0 && n !== Number.POSITIVE_INFINITY && n !== Number.NEGATIVE_INFINITY) {
	          n = (n > 0 || -1) * Math.floor(Math.abs(n));
	        }
	      }
	      if (n >= len) {
	        return -1;
	      }
	      var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
	      for (; k < len; k++) {
	        if (k in t && t[k] === searchElement) {
	          return k;
	        }
	      }
	      return -1;
	    };
	  }
	
	  if (!Array.prototype.forEach) {
	    /**
	     * Iterates an array, invoking callback for each element
	     * @param {Function} fn Callback to invoke for each element
	     * @param {Object} [context] Context to invoke callback in
	     * @return {Array}
	     */
	    Array.prototype.forEach = function(fn, context) {
	      for (var i = 0, len = this.length >>> 0; i < len; i++) {
	        if (i in this) {
	          fn.call(context, this[i], i, this);
	        }
	      }
	    };
	  }
	
	  if (!Array.prototype.map) {
	    /**
	     * Returns a result of iterating over an array, invoking callback for each element
	     * @param {Function} fn Callback to invoke for each element
	     * @param {Object} [context] Context to invoke callback in
	     * @return {Array}
	     */
	    Array.prototype.map = function(fn, context) {
	      var result = [];
	      for (var i = 0, len = this.length >>> 0; i < len; i++) {
	        if (i in this) {
	          result[i] = fn.call(context, this[i], i, this);
	        }
	      }
	      return result;
	    };
	  }
	
	  if (!Array.prototype.every) {
	    /**
	     * Returns true if a callback returns truthy value for all elements in an array
	     * @param {Function} fn Callback to invoke for each element
	     * @param {Object} [context] Context to invoke callback in
	     * @return {Boolean}
	     */
	    Array.prototype.every = function(fn, context) {
	      for (var i = 0, len = this.length >>> 0; i < len; i++) {
	        if (i in this && !fn.call(context, this[i], i, this)) {
	          return false;
	        }
	      }
	      return true;
	    };
	  }
	
	  if (!Array.prototype.some) {
	    /**
	     * Returns true if a callback returns truthy value for at least one element in an array
	     * @param {Function} fn Callback to invoke for each element
	     * @param {Object} [context] Context to invoke callback in
	     * @return {Boolean}
	     */
	    Array.prototype.some = function(fn, context) {
	      for (var i = 0, len = this.length >>> 0; i < len; i++) {
	        if (i in this && fn.call(context, this[i], i, this)) {
	          return true;
	        }
	      }
	      return false;
	    };
	  }
	
	  if (!Array.prototype.filter) {
	    /**
	     * Returns the result of iterating over elements in an array
	     * @param {Function} fn Callback to invoke for each element
	     * @param {Object} [context] Context to invoke callback in
	     * @return {Array}
	     */
	    Array.prototype.filter = function(fn, context) {
	      var result = [], val;
	      for (var i = 0, len = this.length >>> 0; i < len; i++) {
	        if (i in this) {
	          val = this[i]; // in case fn mutates this
	          if (fn.call(context, val, i, this)) {
	            result.push(val);
	          }
	        }
	      }
	      return result;
	    };
	  }
	
	  if (!Array.prototype.reduce) {
	    /**
	     * Returns "folded" (reduced) result of iterating over elements in an array
	     * @param {Function} fn Callback to invoke for each element
	     * @return {*}
	     */
	    Array.prototype.reduce = function(fn /*, initial*/) {
	      var len = this.length >>> 0,
	          i = 0,
	          rv;
	
	      if (arguments.length > 1) {
	        rv = arguments[1];
	      }
	      else {
	        do {
	          if (i in this) {
	            rv = this[i++];
	            break;
	          }
	          // if array contains no values, no initial value to return
	          if (++i >= len) {
	            throw new TypeError();
	          }
	        }
	        while (true);
	      }
	      for (; i < len; i++) {
	        if (i in this) {
	          rv = fn.call(null, rv, this[i], i, this);
	        }
	      }
	      return rv;
	    };
	  }
	
	  /* _ES5_COMPAT_END_ */
	
	  /**
	   * Invokes method on all items in a given array
	   * @memberOf fabric.util.array
	   * @param {Array} array Array to iterate over
	   * @param {String} method Name of a method to invoke
	   * @return {Array}
	   */
	  function invoke(array, method) {
	    var args = slice.call(arguments, 2), result = [];
	    for (var i = 0, len = array.length; i < len; i++) {
	      result[i] = args.length ? array[i][method].apply(array[i], args) : array[i][method].call(array[i]);
	    }
	    return result;
	  }
	
	  /**
	   * Finds maximum value in array (not necessarily "first" one)
	   * @memberOf fabric.util.array
	   * @param {Array} array Array to iterate over
	   * @param {String} byProperty
	   * @return {*}
	   */
	  function max(array, byProperty) {
	    return find(array, byProperty, function(value1, value2) {
	      return value1 >= value2;
	    });
	  }
	
	  /**
	   * Finds minimum value in array (not necessarily "first" one)
	   * @memberOf fabric.util.array
	   * @param {Array} array Array to iterate over
	   * @param {String} byProperty
	   * @return {*}
	   */
	  function min(array, byProperty) {
	    return find(array, byProperty, function(value1, value2) {
	      return value1 < value2;
	    });
	  }
	
	  /**
	   * @private
	   */
	  function fill(array, value) {
	    var k = array.length;
	    while (k--) {
	      array[k] = value;
	    }
	    return array;
	  }
	
	  /**
	   * @private
	   */
	  function find(array, byProperty, condition) {
	    if (!array || array.length === 0) {
	      return;
	    }
	
	    var i = array.length - 1,
	        result = byProperty ? array[i][byProperty] : array[i];
	    if (byProperty) {
	      while (i--) {
	        if (condition(array[i][byProperty], result)) {
	          result = array[i][byProperty];
	        }
	      }
	    }
	    else {
	      while (i--) {
	        if (condition(array[i], result)) {
	          result = array[i];
	        }
	      }
	    }
	    return result;
	  }
	
	  /**
	   * @namespace fabric.util.array
	   */
	  fabric.util.array = {
	    fill: fill,
	    invoke: invoke,
	    min: min,
	    max: max
	  };
	
	})();
	
	
	(function() {
	  /**
	   * Copies all enumerable properties of one js object to another
	   * Does not clone or extend fabric.Object subclasses.
	   * @memberOf fabric.util.object
	   * @param {Object} destination Where to copy to
	   * @param {Object} source Where to copy from
	   * @return {Object}
	   */
	
	  function extend(destination, source, deep) {
	    // JScript DontEnum bug is not taken care of
	    // the deep clone is for internal use, is not meant to avoid
	    // javascript traps or cloning html element or self referenced objects.
	    if (deep) {
	      if (!fabric.isLikelyNode && source instanceof Element) {
	        // avoid cloning deep images, canvases,
	        destination = source;
	      }
	      else if (source instanceof Array) {
	        destination = [];
	        for (var i = 0, len = source.length; i < len; i++) {
	          destination[i] = extend({ }, source[i], deep);
	        }
	      }
	      else if (source && typeof source === 'object') {
	        for (var property in source) {
	          if (source.hasOwnProperty(property)) {
	            destination[property] = extend({ }, source[property], deep);
	          }
	        }
	      }
	      else {
	        // this sounds odd for an extend but is ok for recursive use
	        destination = source;
	      }
	    }
	    else {
	      for (var property in source) {
	        destination[property] = source[property];
	      }
	    }
	    return destination;
	  }
	
	  /**
	   * Creates an empty object and copies all enumerable properties of another object to it
	   * @memberOf fabric.util.object
	   * @param {Object} object Object to clone
	   * @return {Object}
	   */
	  function clone(object, deep) {
	    return extend({ }, object, deep);
	  }
	
	  /** @namespace fabric.util.object */
	  fabric.util.object = {
	    extend: extend,
	    clone: clone
	  };
	
	})();
	
	
	(function() {
	
	  /* _ES5_COMPAT_START_ */
	  if (!String.prototype.trim) {
	    /**
	     * Trims a string (removing whitespace from the beginning and the end)
	     * @function external:String#trim
	     * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String/Trim">String#trim on MDN</a>
	     */
	    String.prototype.trim = function () {
	      // this trim is not fully ES3 or ES5 compliant, but it should cover most cases for now
	      return this.replace(/^[\s\xA0]+/, '').replace(/[\s\xA0]+$/, '');
	    };
	  }
	  /* _ES5_COMPAT_END_ */
	
	  /**
	   * Camelizes a string
	   * @memberOf fabric.util.string
	   * @param {String} string String to camelize
	   * @return {String} Camelized version of a string
	   */
	  function camelize(string) {
	    return string.replace(/-+(.)?/g, function(match, character) {
	      return character ? character.toUpperCase() : '';
	    });
	  }
	
	  /**
	   * Capitalizes a string
	   * @memberOf fabric.util.string
	   * @param {String} string String to capitalize
	   * @param {Boolean} [firstLetterOnly] If true only first letter is capitalized
	   * and other letters stay untouched, if false first letter is capitalized
	   * and other letters are converted to lowercase.
	   * @return {String} Capitalized version of a string
	   */
	  function capitalize(string, firstLetterOnly) {
	    return string.charAt(0).toUpperCase() +
	      (firstLetterOnly ? string.slice(1) : string.slice(1).toLowerCase());
	  }
	
	  /**
	   * Escapes XML in a string
	   * @memberOf fabric.util.string
	   * @param {String} string String to escape
	   * @return {String} Escaped version of a string
	   */
	  function escapeXml(string) {
	    return string.replace(/&/g, '&amp;')
	       .replace(/"/g, '&quot;')
	       .replace(/'/g, '&apos;')
	       .replace(/</g, '&lt;')
	       .replace(/>/g, '&gt;');
	  }
	
	  /**
	   * String utilities
	   * @namespace fabric.util.string
	   */
	  fabric.util.string = {
	    camelize: camelize,
	    capitalize: capitalize,
	    escapeXml: escapeXml
	  };
	})();
	
	
	/* _ES5_COMPAT_START_ */
	(function() {
	
	  var slice = Array.prototype.slice,
	      apply = Function.prototype.apply,
	      Dummy = function() { };
	
	  if (!Function.prototype.bind) {
	    /**
	     * Cross-browser approximation of ES5 Function.prototype.bind (not fully spec conforming)
	     * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind">Function#bind on MDN</a>
	     * @param {Object} thisArg Object to bind function to
	     * @param {Any[]} Values to pass to a bound function
	     * @return {Function}
	     */
	    Function.prototype.bind = function(thisArg) {
	      var _this = this, args = slice.call(arguments, 1), bound;
	      if (args.length) {
	        bound = function() {
	          return apply.call(_this, this instanceof Dummy ? this : thisArg, args.concat(slice.call(arguments)));
	        };
	      }
	      else {
	        /** @ignore */
	        bound = function() {
	          return apply.call(_this, this instanceof Dummy ? this : thisArg, arguments);
	        };
	      }
	      Dummy.prototype = this.prototype;
	      bound.prototype = new Dummy();
	
	      return bound;
	    };
	  }
	
	})();
	/* _ES5_COMPAT_END_ */
	
	
	(function() {
	
	  var slice = Array.prototype.slice, emptyFunction = function() { },
	
	      IS_DONTENUM_BUGGY = (function() {
	        for (var p in { toString: 1 }) {
	          if (p === 'toString') {
	            return false;
	          }
	        }
	        return true;
	      })(),
	
	      /** @ignore */
	      addMethods = function(klass, source, parent) {
	        for (var property in source) {
	
	          if (property in klass.prototype &&
	              typeof klass.prototype[property] === 'function' &&
	              (source[property] + '').indexOf('callSuper') > -1) {
	
	            klass.prototype[property] = (function(property) {
	              return function() {
	
	                var superclass = this.constructor.superclass;
	                this.constructor.superclass = parent;
	                var returnValue = source[property].apply(this, arguments);
	                this.constructor.superclass = superclass;
	
	                if (property !== 'initialize') {
	                  return returnValue;
	                }
	              };
	            })(property);
	          }
	          else {
	            klass.prototype[property] = source[property];
	          }
	
	          if (IS_DONTENUM_BUGGY) {
	            if (source.toString !== Object.prototype.toString) {
	              klass.prototype.toString = source.toString;
	            }
	            if (source.valueOf !== Object.prototype.valueOf) {
	              klass.prototype.valueOf = source.valueOf;
	            }
	          }
	        }
	      };
	
	  function Subclass() { }
	
	  function callSuper(methodName) {
	    var fn = this.constructor.superclass.prototype[methodName];
	    return (arguments.length > 1)
	      ? fn.apply(this, slice.call(arguments, 1))
	      : fn.call(this);
	  }
	
	  /**
	   * Helper for creation of "classes".
	   * @memberOf fabric.util
	   * @param {Function} [parent] optional "Class" to inherit from
	   * @param {Object} [properties] Properties shared by all instances of this class
	   *                  (be careful modifying objects defined here as this would affect all instances)
	   */
	  function createClass() {
	    var parent = null,
	        properties = slice.call(arguments, 0);
	
	    if (typeof properties[0] === 'function') {
	      parent = properties.shift();
	    }
	    function klass() {
	      this.initialize.apply(this, arguments);
	    }
	
	    klass.superclass = parent;
	    klass.subclasses = [];
	
	    if (parent) {
	      Subclass.prototype = parent.prototype;
	      klass.prototype = new Subclass();
	      parent.subclasses.push(klass);
	    }
	    for (var i = 0, length = properties.length; i < length; i++) {
	      addMethods(klass, properties[i], parent);
	    }
	    if (!klass.prototype.initialize) {
	      klass.prototype.initialize = emptyFunction;
	    }
	    klass.prototype.constructor = klass;
	    klass.prototype.callSuper = callSuper;
	    return klass;
	  }
	
	  fabric.util.createClass = createClass;
	})();
	
	
	(function () {
	
	  var unknown = 'unknown';
	
	  /* EVENT HANDLING */
	
	  function areHostMethods(object) {
	    var methodNames = Array.prototype.slice.call(arguments, 1),
	        t, i, len = methodNames.length;
	    for (i = 0; i < len; i++) {
	      t = typeof object[methodNames[i]];
	      if (!(/^(?:function|object|unknown)$/).test(t)) {
	        return false;
	      }
	    }
	    return true;
	  }
	
	  /** @ignore */
	  var getElement,
	      setElement,
	      getUniqueId = (function () {
	        var uid = 0;
	        return function (element) {
	          return element.__uniqueID || (element.__uniqueID = 'uniqueID__' + uid++);
	        };
	      })();
	
	  (function () {
	    var elements = { };
	    /** @ignore */
	    getElement = function (uid) {
	      return elements[uid];
	    };
	    /** @ignore */
	    setElement = function (uid, element) {
	      elements[uid] = element;
	    };
	  })();
	
	  function createListener(uid, handler) {
	    return {
	      handler: handler,
	      wrappedHandler: createWrappedHandler(uid, handler)
	    };
	  }
	
	  function createWrappedHandler(uid, handler) {
	    return function (e) {
	      handler.call(getElement(uid), e || fabric.window.event);
	    };
	  }
	
	  function createDispatcher(uid, eventName) {
	    return function (e) {
	      if (handlers[uid] && handlers[uid][eventName]) {
	        var handlersForEvent = handlers[uid][eventName];
	        for (var i = 0, len = handlersForEvent.length; i < len; i++) {
	          handlersForEvent[i].call(this, e || fabric.window.event);
	        }
	      }
	    };
	  }
	
	  var shouldUseAddListenerRemoveListener = (
	        areHostMethods(fabric.document.documentElement, 'addEventListener', 'removeEventListener') &&
	        areHostMethods(fabric.window, 'addEventListener', 'removeEventListener')),
	
	      shouldUseAttachEventDetachEvent = (
	        areHostMethods(fabric.document.documentElement, 'attachEvent', 'detachEvent') &&
	        areHostMethods(fabric.window, 'attachEvent', 'detachEvent')),
	
	      // IE branch
	      listeners = { },
	
	      // DOM L0 branch
	      handlers = { },
	
	      addListener, removeListener;
	
	  if (shouldUseAddListenerRemoveListener) {
	    /** @ignore */
	    addListener = function (element, eventName, handler) {
	      element.addEventListener(eventName, handler, false);
	    };
	    /** @ignore */
	    removeListener = function (element, eventName, handler) {
	      element.removeEventListener(eventName, handler, false);
	    };
	  }
	
	  else if (shouldUseAttachEventDetachEvent) {
	    /** @ignore */
	    addListener = function (element, eventName, handler) {
	      var uid = getUniqueId(element);
	      setElement(uid, element);
	      if (!listeners[uid]) {
	        listeners[uid] = { };
	      }
	      if (!listeners[uid][eventName]) {
	        listeners[uid][eventName] = [];
	
	      }
	      var listener = createListener(uid, handler);
	      listeners[uid][eventName].push(listener);
	      element.attachEvent('on' + eventName, listener.wrappedHandler);
	    };
	    /** @ignore */
	    removeListener = function (element, eventName, handler) {
	      var uid = getUniqueId(element), listener;
	      if (listeners[uid] && listeners[uid][eventName]) {
	        for (var i = 0, len = listeners[uid][eventName].length; i < len; i++) {
	          listener = listeners[uid][eventName][i];
	          if (listener && listener.handler === handler) {
	            element.detachEvent('on' + eventName, listener.wrappedHandler);
	            listeners[uid][eventName][i] = null;
	          }
	        }
	      }
	    };
	  }
	  else {
	    /** @ignore */
	    addListener = function (element, eventName, handler) {
	      var uid = getUniqueId(element);
	      if (!handlers[uid]) {
	        handlers[uid] = { };
	      }
	      if (!handlers[uid][eventName]) {
	        handlers[uid][eventName] = [];
	        var existingHandler = element['on' + eventName];
	        if (existingHandler) {
	          handlers[uid][eventName].push(existingHandler);
	        }
	        element['on' + eventName] = createDispatcher(uid, eventName);
	      }
	      handlers[uid][eventName].push(handler);
	    };
	    /** @ignore */
	    removeListener = function (element, eventName, handler) {
	      var uid = getUniqueId(element);
	      if (handlers[uid] && handlers[uid][eventName]) {
	        var handlersForEvent = handlers[uid][eventName];
	        for (var i = 0, len = handlersForEvent.length; i < len; i++) {
	          if (handlersForEvent[i] === handler) {
	            handlersForEvent.splice(i, 1);
	          }
	        }
	      }
	    };
	  }
	
	  /**
	   * Adds an event listener to an element
	   * @function
	   * @memberOf fabric.util
	   * @param {HTMLElement} element
	   * @param {String} eventName
	   * @param {Function} handler
	   */
	  fabric.util.addListener = addListener;
	
	  /**
	   * Removes an event listener from an element
	   * @function
	   * @memberOf fabric.util
	   * @param {HTMLElement} element
	   * @param {String} eventName
	   * @param {Function} handler
	   */
	  fabric.util.removeListener = removeListener;
	
	  /**
	   * Cross-browser wrapper for getting event's coordinates
	   * @memberOf fabric.util
	   * @param {Event} event Event object
	   */
	  function getPointer(event) {
	    event || (event = fabric.window.event);
	
	    var element = event.target ||
	                  (typeof event.srcElement !== unknown ? event.srcElement : null),
	
	        scroll = fabric.util.getScrollLeftTop(element);
	
	    return {
	      x: pointerX(event) + scroll.left,
	      y: pointerY(event) + scroll.top
	    };
	  }
	
	  var pointerX = function(event) {
	    // looks like in IE (<9) clientX at certain point (apparently when mouseup fires on VML element)
	    // is represented as COM object, with all the consequences, like "unknown" type and error on [[Get]]
	    // need to investigate later
	        return (typeof event.clientX !== unknown ? event.clientX : 0);
	      },
	
	      pointerY = function(event) {
	        return (typeof event.clientY !== unknown ? event.clientY : 0);
	      };
	
	  function _getPointer(event, pageProp, clientProp) {
	    var touchProp = event.type === 'touchend' ? 'changedTouches' : 'touches';
	
	    return (event[touchProp] && event[touchProp][0]
	      ? (event[touchProp][0][pageProp] - (event[touchProp][0][pageProp] - event[touchProp][0][clientProp]))
	        || event[clientProp]
	      : event[clientProp]);
	  }
	
	  if (fabric.isTouchSupported) {
	    pointerX = function(event) {
	      return _getPointer(event, 'pageX', 'clientX');
	    };
	    pointerY = function(event) {
	      return _getPointer(event, 'pageY', 'clientY');
	    };
	  }
	
	  fabric.util.getPointer = getPointer;
	
	  fabric.util.object.extend(fabric.util, fabric.Observable);
	
	})();
	
	
	(function () {
	
	  /**
	   * Cross-browser wrapper for setting element's style
	   * @memberOf fabric.util
	   * @param {HTMLElement} element
	   * @param {Object} styles
	   * @return {HTMLElement} Element that was passed as a first argument
	   */
	  function setStyle(element, styles) {
	    var elementStyle = element.style;
	    if (!elementStyle) {
	      return element;
	    }
	    if (typeof styles === 'string') {
	      element.style.cssText += ';' + styles;
	      return styles.indexOf('opacity') > -1
	        ? setOpacity(element, styles.match(/opacity:\s*(\d?\.?\d*)/)[1])
	        : element;
	    }
	    for (var property in styles) {
	      if (property === 'opacity') {
	        setOpacity(element, styles[property]);
	      }
	      else {
	        var normalizedProperty = (property === 'float' || property === 'cssFloat')
	          ? (typeof elementStyle.styleFloat === 'undefined' ? 'cssFloat' : 'styleFloat')
	          : property;
	        elementStyle[normalizedProperty] = styles[property];
	      }
	    }
	    return element;
	  }
	
	  var parseEl = fabric.document.createElement('div'),
	      supportsOpacity = typeof parseEl.style.opacity === 'string',
	      supportsFilters = typeof parseEl.style.filter === 'string',
	      reOpacity = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/,
	
	      /** @ignore */
	      setOpacity = function (element) { return element; };
	
	  if (supportsOpacity) {
	    /** @ignore */
	    setOpacity = function(element, value) {
	      element.style.opacity = value;
	      return element;
	    };
	  }
	  else if (supportsFilters) {
	    /** @ignore */
	    setOpacity = function(element, value) {
	      var es = element.style;
	      if (element.currentStyle && !element.currentStyle.hasLayout) {
	        es.zoom = 1;
	      }
	      if (reOpacity.test(es.filter)) {
	        value = value >= 0.9999 ? '' : ('alpha(opacity=' + (value * 100) + ')');
	        es.filter = es.filter.replace(reOpacity, value);
	      }
	      else {
	        es.filter += ' alpha(opacity=' + (value * 100) + ')';
	      }
	      return element;
	    };
	  }
	
	  fabric.util.setStyle = setStyle;
	
	})();
	
	
	(function() {
	
	  var _slice = Array.prototype.slice;
	
	  /**
	   * Takes id and returns an element with that id (if one exists in a document)
	   * @memberOf fabric.util
	   * @param {String|HTMLElement} id
	   * @return {HTMLElement|null}
	   */
	  function getById(id) {
	    return typeof id === 'string' ? fabric.document.getElementById(id) : id;
	  }
	
	  var sliceCanConvertNodelists,
	      /**
	       * Converts an array-like object (e.g. arguments or NodeList) to an array
	       * @memberOf fabric.util
	       * @param {Object} arrayLike
	       * @return {Array}
	       */
	      toArray = function(arrayLike) {
	        return _slice.call(arrayLike, 0);
	      };
	
	  try {
	    sliceCanConvertNodelists = toArray(fabric.document.childNodes) instanceof Array;
	  }
	  catch (err) { }
	
	  if (!sliceCanConvertNodelists) {
	    toArray = function(arrayLike) {
	      var arr = new Array(arrayLike.length), i = arrayLike.length;
	      while (i--) {
	        arr[i] = arrayLike[i];
	      }
	      return arr;
	    };
	  }
	
	  /**
	   * Creates specified element with specified attributes
	   * @memberOf fabric.util
	   * @param {String} tagName Type of an element to create
	   * @param {Object} [attributes] Attributes to set on an element
	   * @return {HTMLElement} Newly created element
	   */
	  function makeElement(tagName, attributes) {
	    var el = fabric.document.createElement(tagName);
	    for (var prop in attributes) {
	      if (prop === 'class') {
	        el.className = attributes[prop];
	      }
	      else if (prop === 'for') {
	        el.htmlFor = attributes[prop];
	      }
	      else {
	        el.setAttribute(prop, attributes[prop]);
	      }
	    }
	    return el;
	  }
	
	  /**
	   * Adds class to an element
	   * @memberOf fabric.util
	   * @param {HTMLElement} element Element to add class to
	   * @param {String} className Class to add to an element
	   */
	  function addClass(element, className) {
	    if (element && (' ' + element.className + ' ').indexOf(' ' + className + ' ') === -1) {
	      element.className += (element.className ? ' ' : '') + className;
	    }
	  }
	
	  /**
	   * Wraps element with another element
	   * @memberOf fabric.util
	   * @param {HTMLElement} element Element to wrap
	   * @param {HTMLElement|String} wrapper Element to wrap with
	   * @param {Object} [attributes] Attributes to set on a wrapper
	   * @return {HTMLElement} wrapper
	   */
	  function wrapElement(element, wrapper, attributes) {
	    if (typeof wrapper === 'string') {
	      wrapper = makeElement(wrapper, attributes);
	    }
	    if (element.parentNode) {
	      element.parentNode.replaceChild(wrapper, element);
	    }
	    wrapper.appendChild(element);
	    return wrapper;
	  }
	
	  /**
	   * Returns element scroll offsets
	   * @memberOf fabric.util
	   * @param {HTMLElement} element Element to operate on
	   * @return {Object} Object with left/top values
	   */
	  function getScrollLeftTop(element) {
	
	    var left = 0,
	        top = 0,
	        docElement = fabric.document.documentElement,
	        body = fabric.document.body || {
	          scrollLeft: 0, scrollTop: 0
	        };
	
	    // While loop checks (and then sets element to) .parentNode OR .host
	    //  to account for ShadowDOM. We still want to traverse up out of ShadowDOM,
	    //  but the .parentNode of a root ShadowDOM node will always be null, instead
	    //  it should be accessed through .host. See http://stackoverflow.com/a/24765528/4383938
	    while (element && (element.parentNode || element.host)) {
	
	      // Set element to element parent, or 'host' in case of ShadowDOM
	      element = element.parentNode || element.host;
	
	      if (element === fabric.document) {
	        left = body.scrollLeft || docElement.scrollLeft || 0;
	        top = body.scrollTop ||  docElement.scrollTop || 0;
	      }
	      else {
	        left += element.scrollLeft || 0;
	        top += element.scrollTop || 0;
	      }
	
	      if (element.nodeType === 1 &&
	          fabric.util.getElementStyle(element, 'position') === 'fixed') {
	        break;
	      }
	    }
	
	    return { left: left, top: top };
	  }
	
	  /**
	   * Returns offset for a given element
	   * @function
	   * @memberOf fabric.util
	   * @param {HTMLElement} element Element to get offset for
	   * @return {Object} Object with "left" and "top" properties
	   */
	  function getElementOffset(element) {
	    var docElem,
	        doc = element && element.ownerDocument,
	        box = { left: 0, top: 0 },
	        offset = { left: 0, top: 0 },
	        scrollLeftTop,
	        offsetAttributes = {
	          borderLeftWidth: 'left',
	          borderTopWidth:  'top',
	          paddingLeft:     'left',
	          paddingTop:      'top'
	        };
	
	    if (!doc) {
	      return offset;
	    }
	
	    for (var attr in offsetAttributes) {
	      offset[offsetAttributes[attr]] += parseInt(getElementStyle(element, attr), 10) || 0;
	    }
	
	    docElem = doc.documentElement;
	    if ( typeof element.getBoundingClientRect !== 'undefined' ) {
	      box = element.getBoundingClientRect();
	    }
	
	    scrollLeftTop = getScrollLeftTop(element);
	
	    return {
	      left: box.left + scrollLeftTop.left - (docElem.clientLeft || 0) + offset.left,
	      top: box.top + scrollLeftTop.top - (docElem.clientTop || 0)  + offset.top
	    };
	  }
	
	  /**
	   * Returns style attribute value of a given element
	   * @memberOf fabric.util
	   * @param {HTMLElement} element Element to get style attribute for
	   * @param {String} attr Style attribute to get for element
	   * @return {String} Style attribute value of the given element.
	   */
	  var getElementStyle;
	  if (fabric.document.defaultView && fabric.document.defaultView.getComputedStyle) {
	    getElementStyle = function(element, attr) {
	      var style = fabric.document.defaultView.getComputedStyle(element, null);
	      return style ? style[attr] : undefined;
	    };
	  }
	  else {
	    getElementStyle = function(element, attr) {
	      var value = element.style[attr];
	      if (!value && element.currentStyle) {
	        value = element.currentStyle[attr];
	      }
	      return value;
	    };
	  }
	
	  (function () {
	    var style = fabric.document.documentElement.style,
	        selectProp = 'userSelect' in style
	          ? 'userSelect'
	          : 'MozUserSelect' in style
	            ? 'MozUserSelect'
	            : 'WebkitUserSelect' in style
	              ? 'WebkitUserSelect'
	              : 'KhtmlUserSelect' in style
	                ? 'KhtmlUserSelect'
	                : '';
	
	    /**
	     * Makes element unselectable
	     * @memberOf fabric.util
	     * @param {HTMLElement} element Element to make unselectable
	     * @return {HTMLElement} Element that was passed in
	     */
	    function makeElementUnselectable(element) {
	      if (typeof element.onselectstart !== 'undefined') {
	        element.onselectstart = fabric.util.falseFunction;
	      }
	      if (selectProp) {
	        element.style[selectProp] = 'none';
	      }
	      else if (typeof element.unselectable === 'string') {
	        element.unselectable = 'on';
	      }
	      return element;
	    }
	
	    /**
	     * Makes element selectable
	     * @memberOf fabric.util
	     * @param {HTMLElement} element Element to make selectable
	     * @return {HTMLElement} Element that was passed in
	     */
	    function makeElementSelectable(element) {
	      if (typeof element.onselectstart !== 'undefined') {
	        element.onselectstart = null;
	      }
	      if (selectProp) {
	        element.style[selectProp] = '';
	      }
	      else if (typeof element.unselectable === 'string') {
	        element.unselectable = '';
	      }
	      return element;
	    }
	
	    fabric.util.makeElementUnselectable = makeElementUnselectable;
	    fabric.util.makeElementSelectable = makeElementSelectable;
	  })();
	
	  (function() {
	
	    /**
	     * Inserts a script element with a given url into a document; invokes callback, when that script is finished loading
	     * @memberOf fabric.util
	     * @param {String} url URL of a script to load
	     * @param {Function} callback Callback to execute when script is finished loading
	     */
	    function getScript(url, callback) {
	      var headEl = fabric.document.getElementsByTagName('head')[0],
	          scriptEl = fabric.document.createElement('script'),
	          loading = true;
	
	      /** @ignore */
	      scriptEl.onload = /** @ignore */ scriptEl.onreadystatechange = function(e) {
	        if (loading) {
	          if (typeof this.readyState === 'string' &&
	              this.readyState !== 'loaded' &&
	              this.readyState !== 'complete') {
	            return;
	          }
	          loading = false;
	          callback(e || fabric.window.event);
	          scriptEl = scriptEl.onload = scriptEl.onreadystatechange = null;
	        }
	      };
	      scriptEl.src = url;
	      headEl.appendChild(scriptEl);
	      // causes issue in Opera
	      // headEl.removeChild(scriptEl);
	    }
	
	    fabric.util.getScript = getScript;
	  })();
	
	  fabric.util.getById = getById;
	  fabric.util.toArray = toArray;
	  fabric.util.makeElement = makeElement;
	  fabric.util.addClass = addClass;
	  fabric.util.wrapElement = wrapElement;
	  fabric.util.getScrollLeftTop = getScrollLeftTop;
	  fabric.util.getElementOffset = getElementOffset;
	  fabric.util.getElementStyle = getElementStyle;
	
	})();
	
	
	(function() {
	
	  function addParamToUrl(url, param) {
	    return url + (/\?/.test(url) ? '&' : '?') + param;
	  }
	
	  var makeXHR = (function() {
	    var factories = [
	      function() { return new ActiveXObject('Microsoft.XMLHTTP'); },
	      function() { return new ActiveXObject('Msxml2.XMLHTTP'); },
	      function() { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); },
	      function() { return new XMLHttpRequest(); }
	    ];
	    for (var i = factories.length; i--; ) {
	      try {
	        var req = factories[i]();
	        if (req) {
	          return factories[i];
	        }
	      }
	      catch (err) { }
	    }
	  })();
	
	  function emptyFn() { }
	
	  /**
	   * Cross-browser abstraction for sending XMLHttpRequest
	   * @memberOf fabric.util
	   * @param {String} url URL to send XMLHttpRequest to
	   * @param {Object} [options] Options object
	   * @param {String} [options.method="GET"]
	   * @param {String} [options.parameters] parameters to append to url in GET or in body
	   * @param {String} [options.body] body to send with POST or PUT request
	   * @param {Function} options.onComplete Callback to invoke when request is completed
	   * @return {XMLHttpRequest} request
	   */
	  function request(url, options) {
	
	    options || (options = { });
	
	    var method = options.method ? options.method.toUpperCase() : 'GET',
	        onComplete = options.onComplete || function() { },
	        xhr = makeXHR(),
	        body = options.body || options.parameters;
	
	    /** @ignore */
	    xhr.onreadystatechange = function() {
	      if (xhr.readyState === 4) {
	        onComplete(xhr);
	        xhr.onreadystatechange = emptyFn;
	      }
	    };
	
	    if (method === 'GET') {
	      body = null;
	      if (typeof options.parameters === 'string') {
	        url = addParamToUrl(url, options.parameters);
	      }
	    }
	
	    xhr.open(method, url, true);
	
	    if (method === 'POST' || method === 'PUT') {
	      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
	    }
	
	    xhr.send(body);
	    return xhr;
	  }
	
	  fabric.util.request = request;
	})();
	
	
	/**
	 * Wrapper around `console.log` (when available)
	 * @param {*} [values] Values to log
	 */
	fabric.log = function() { };
	
	/**
	 * Wrapper around `console.warn` (when available)
	 * @param {*} [values] Values to log as a warning
	 */
	fabric.warn = function() { };
	
	/* eslint-disable */
	if (typeof console !== 'undefined') {
	
	  ['log', 'warn'].forEach(function(methodName) {
	
	    if (typeof console[methodName] !== 'undefined' &&
	        typeof console[methodName].apply === 'function') {
	
	      fabric[methodName] = function() {
	        return console[methodName].apply(console, arguments);
	      };
	    }
	  });
	}
	/* eslint-enable */
	
	
	(function() {
	
	  /**
	   * Changes value from one to another within certain period of time, invoking callbacks as value is being changed.
	   * @memberOf fabric.util
	   * @param {Object} [options] Animation options
	   * @param {Function} [options.onChange] Callback; invoked on every value change
	   * @param {Function} [options.onComplete] Callback; invoked when value change is completed
	   * @param {Number} [options.startValue=0] Starting value
	   * @param {Number} [options.endValue=100] Ending value
	   * @param {Number} [options.byValue=100] Value to modify the property by
	   * @param {Function} [options.easing] Easing function
	   * @param {Number} [options.duration=500] Duration of change (in ms)
	   */
	  function animate(options) {
	
	    requestAnimFrame(function(timestamp) {
	      options || (options = { });
	
	      var start = timestamp || +new Date(),
	          duration = options.duration || 500,
	          finish = start + duration, time,
	          onChange = options.onChange || function() { },
	          abort = options.abort || function() { return false; },
	          easing = options.easing || function(t, b, c, d) {return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;},
	          startValue = 'startValue' in options ? options.startValue : 0,
	          endValue = 'endValue' in options ? options.endValue : 100,
	          byValue = options.byValue || endValue - startValue;
	
	      options.onStart && options.onStart();
	
	      (function tick(ticktime) {
	        time = ticktime || +new Date();
	        var currentTime = time > finish ? duration : (time - start);
	        if (abort()) {
	          options.onComplete && options.onComplete();
	          return;
	        }
	        onChange(easing(currentTime, startValue, byValue, duration));
	        if (time > finish) {
	          options.onComplete && options.onComplete();
	          return;
	        }
	        requestAnimFrame(tick);
	      })(start);
	    });
	
	  }
	
	  var _requestAnimFrame = fabric.window.requestAnimationFrame       ||
	                          fabric.window.webkitRequestAnimationFrame ||
	                          fabric.window.mozRequestAnimationFrame    ||
	                          fabric.window.oRequestAnimationFrame      ||
	                          fabric.window.msRequestAnimationFrame     ||
	                          function(callback) {
	                            fabric.window.setTimeout(callback, 1000 / 60);
	                          };
	
	  /**
	   * requestAnimationFrame polyfill based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/
	   * In order to get a precise start time, `requestAnimFrame` should be called as an entry into the method
	   * @memberOf fabric.util
	   * @param {Function} callback Callback to invoke
	   * @param {DOMElement} element optional Element to associate with animation
	   */
	  function requestAnimFrame() {
	    return _requestAnimFrame.apply(fabric.window, arguments);
	  }
	
	  fabric.util.animate = animate;
	  fabric.util.requestAnimFrame = requestAnimFrame;
	
	})();
	
	
	(function() {
	  // Calculate an in-between color. Returns a "rgba()" string.
	  // Credit: Edwin Martin <edwin@bitstorm.org>
	  //         http://www.bitstorm.org/jquery/color-animation/jquery.animate-colors.js
	  function calculateColor(begin, end, pos) {
	    var color = 'rgba('
	        + parseInt((begin[0] + pos * (end[0] - begin[0])), 10) + ','
	        + parseInt((begin[1] + pos * (end[1] - begin[1])), 10) + ','
	        + parseInt((begin[2] + pos * (end[2] - begin[2])), 10);
	
	    color += ',' + (begin && end ? parseFloat(begin[3] + pos * (end[3] - begin[3])) : 1);
	    color += ')';
	    return color;
	  }
	
	  /**
	   * Changes the color from one to another within certain period of time, invoking callbacks as value is being changed.
	   * @memberOf fabric.util
	   * @param {String} fromColor The starting color in hex or rgb(a) format.
	   * @param {String} toColor The starting color in hex or rgb(a) format.
	   * @param {Number} [duration] Duration of change (in ms).
	   * @param {Object} [options] Animation options
	   * @param {Function} [options.onChange] Callback; invoked on every value change
	   * @param {Function} [options.onComplete] Callback; invoked when value change is completed
	   * @param {Function} [options.colorEasing] Easing function. Note that this function only take two arguments (currentTime, duration). Thus the regular animation easing functions cannot be used.
	   */
	  function animateColor(fromColor, toColor, duration, options) {
	    var startColor = new fabric.Color(fromColor).getSource(),
	        endColor = new fabric.Color(toColor).getSource();
	
	    options = options || {};
	
	    fabric.util.animate(fabric.util.object.extend(options, {
	      duration: duration || 500,
	      startValue: startColor,
	      endValue: endColor,
	      byValue: endColor,
	      easing: function (currentTime, startValue, byValue, duration) {
	        var posValue = options.colorEasing
	              ? options.colorEasing(currentTime, duration)
	              : 1 - Math.cos(currentTime / duration * (Math.PI / 2));
	        return calculateColor(startValue, byValue, posValue);
	      }
	    }));
	  }
	
	  fabric.util.animateColor = animateColor;
	
	})();
	
	
	(function() {
	
	  function normalize(a, c, p, s) {
	    if (a < Math.abs(c)) {
	      a = c;
	      s = p / 4;
	    }
	    else {
	      //handle the 0/0 case:
	      if (c === 0 && a === 0) {
	        s = p / (2 * Math.PI) * Math.asin(1);
	      }
	      else {
	        s = p / (2 * Math.PI) * Math.asin(c / a);
	      }
	    }
	    return { a: a, c: c, p: p, s: s };
	  }
	
	  function elastic(opts, t, d) {
	    return opts.a *
	      Math.pow(2, 10 * (t -= 1)) *
	      Math.sin( (t * d - opts.s) * (2 * Math.PI) / opts.p );
	  }
	
	  /**
	   * Cubic easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutCubic(t, b, c, d) {
	    return c * ((t = t / d - 1) * t * t + 1) + b;
	  }
	
	  /**
	   * Cubic easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutCubic(t, b, c, d) {
	    t /= d / 2;
	    if (t < 1) {
	      return c / 2 * t * t * t + b;
	    }
	    return c / 2 * ((t -= 2) * t * t + 2) + b;
	  }
	
	  /**
	   * Quartic easing in
	   * @memberOf fabric.util.ease
	   */
	  function easeInQuart(t, b, c, d) {
	    return c * (t /= d) * t * t * t + b;
	  }
	
	  /**
	   * Quartic easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutQuart(t, b, c, d) {
	    return -c * ((t = t / d - 1) * t * t * t - 1) + b;
	  }
	
	  /**
	   * Quartic easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutQuart(t, b, c, d) {
	    t /= d / 2;
	    if (t < 1) {
	      return c / 2 * t * t * t * t + b;
	    }
	    return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
	  }
	
	  /**
	   * Quintic easing in
	   * @memberOf fabric.util.ease
	   */
	  function easeInQuint(t, b, c, d) {
	    return c * (t /= d) * t * t * t * t + b;
	  }
	
	  /**
	   * Quintic easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutQuint(t, b, c, d) {
	    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
	  }
	
	  /**
	   * Quintic easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutQuint(t, b, c, d) {
	    t /= d / 2;
	    if (t < 1) {
	      return c / 2 * t * t * t * t * t + b;
	    }
	    return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
	  }
	
	  /**
	   * Sinusoidal easing in
	   * @memberOf fabric.util.ease
	   */
	  function easeInSine(t, b, c, d) {
	    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
	  }
	
	  /**
	   * Sinusoidal easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutSine(t, b, c, d) {
	    return c * Math.sin(t / d * (Math.PI / 2)) + b;
	  }
	
	  /**
	   * Sinusoidal easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutSine(t, b, c, d) {
	    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
	  }
	
	  /**
	   * Exponential easing in
	   * @memberOf fabric.util.ease
	   */
	  function easeInExpo(t, b, c, d) {
	    return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
	  }
	
	  /**
	   * Exponential easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutExpo(t, b, c, d) {
	    return (t === d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
	  }
	
	  /**
	   * Exponential easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutExpo(t, b, c, d) {
	    if (t === 0) {
	      return b;
	    }
	    if (t === d) {
	      return b + c;
	    }
	    t /= d / 2;
	    if (t < 1) {
	      return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
	    }
	    return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
	  }
	
	  /**
	   * Circular easing in
	   * @memberOf fabric.util.ease
	   */
	  function easeInCirc(t, b, c, d) {
	    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
	  }
	
	  /**
	   * Circular easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutCirc(t, b, c, d) {
	    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
	  }
	
	  /**
	   * Circular easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutCirc(t, b, c, d) {
	    t /= d / 2;
	    if (t < 1) {
	      return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
	    }
	    return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
	  }
	
	  /**
	   * Elastic easing in
	   * @memberOf fabric.util.ease
	   */
	  function easeInElastic(t, b, c, d) {
	    var s = 1.70158, p = 0, a = c;
	    if (t === 0) {
	      return b;
	    }
	    t /= d;
	    if (t === 1) {
	      return b + c;
	    }
	    if (!p) {
	      p = d * 0.3;
	    }
	    var opts = normalize(a, c, p, s);
	    return -elastic(opts, t, d) + b;
	  }
	
	  /**
	   * Elastic easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutElastic(t, b, c, d) {
	    var s = 1.70158, p = 0, a = c;
	    if (t === 0) {
	      return b;
	    }
	    t /= d;
	    if (t === 1) {
	      return b + c;
	    }
	    if (!p) {
	      p = d * 0.3;
	    }
	    var opts = normalize(a, c, p, s);
	    return opts.a * Math.pow(2, -10 * t) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) + opts.c + b;
	  }
	
	  /**
	   * Elastic easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutElastic(t, b, c, d) {
	    var s = 1.70158, p = 0, a = c;
	    if (t === 0) {
	      return b;
	    }
	    t /= d / 2;
	    if (t === 2) {
	      return b + c;
	    }
	    if (!p) {
	      p = d * (0.3 * 1.5);
	    }
	    var opts = normalize(a, c, p, s);
	    if (t < 1) {
	      return -0.5 * elastic(opts, t, d) + b;
	    }
	    return opts.a * Math.pow(2, -10 * (t -= 1)) *
	      Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) * 0.5 + opts.c + b;
	  }
	
	  /**
	   * Backwards easing in
	   * @memberOf fabric.util.ease
	   */
	  function easeInBack(t, b, c, d, s) {
	    if (s === undefined) {
	      s = 1.70158;
	    }
	    return c * (t /= d) * t * ((s + 1) * t - s) + b;
	  }
	
	  /**
	   * Backwards easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutBack(t, b, c, d, s) {
	    if (s === undefined) {
	      s = 1.70158;
	    }
	    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
	  }
	
	  /**
	   * Backwards easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutBack(t, b, c, d, s) {
	    if (s === undefined) {
	      s = 1.70158;
	    }
	    t /= d / 2;
	    if (t < 1) {
	      return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
	    }
	    return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
	  }
	
	  /**
	   * Bouncing easing in
	   * @memberOf fabric.util.ease
	   */
	  function easeInBounce(t, b, c, d) {
	    return c - easeOutBounce (d - t, 0, c, d) + b;
	  }
	
	  /**
	   * Bouncing easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutBounce(t, b, c, d) {
	    if ((t /= d) < (1 / 2.75)) {
	      return c * (7.5625 * t * t) + b;
	    }
	    else if (t < (2 / 2.75)) {
	      return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
	    }
	    else if (t < (2.5 / 2.75)) {
	      return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
	    }
	    else {
	      return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
	    }
	  }
	
	  /**
	   * Bouncing easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutBounce(t, b, c, d) {
	    if (t < d / 2) {
	      return easeInBounce (t * 2, 0, c, d) * 0.5 + b;
	    }
	    return easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
	  }
	
	  /**
	   * Easing functions
	   * See <a href="http://gizma.com/easing/">Easing Equations by Robert Penner</a>
	   * @namespace fabric.util.ease
	   */
	  fabric.util.ease = {
	
	    /**
	     * Quadratic easing in
	     * @memberOf fabric.util.ease
	     */
	    easeInQuad: function(t, b, c, d) {
	      return c * (t /= d) * t + b;
	    },
	
	    /**
	     * Quadratic easing out
	     * @memberOf fabric.util.ease
	     */
	    easeOutQuad: function(t, b, c, d) {
	      return -c * (t /= d) * (t - 2) + b;
	    },
	
	    /**
	     * Quadratic easing in and out
	     * @memberOf fabric.util.ease
	     */
	    easeInOutQuad: function(t, b, c, d) {
	      t /= (d / 2);
	      if (t < 1) {
	        return c / 2 * t * t + b;
	      }
	      return -c / 2 * ((--t) * (t - 2) - 1) + b;
	    },
	
	    /**
	     * Cubic easing in
	     * @memberOf fabric.util.ease
	     */
	    easeInCubic: function(t, b, c, d) {
	      return c * (t /= d) * t * t + b;
	    },
	
	    easeOutCubic: easeOutCubic,
	    easeInOutCubic: easeInOutCubic,
	    easeInQuart: easeInQuart,
	    easeOutQuart: easeOutQuart,
	    easeInOutQuart: easeInOutQuart,
	    easeInQuint: easeInQuint,
	    easeOutQuint: easeOutQuint,
	    easeInOutQuint: easeInOutQuint,
	    easeInSine: easeInSine,
	    easeOutSine: easeOutSine,
	    easeInOutSine: easeInOutSine,
	    easeInExpo: easeInExpo,
	    easeOutExpo: easeOutExpo,
	    easeInOutExpo: easeInOutExpo,
	    easeInCirc: easeInCirc,
	    easeOutCirc: easeOutCirc,
	    easeInOutCirc: easeInOutCirc,
	    easeInElastic: easeInElastic,
	    easeOutElastic: easeOutElastic,
	    easeInOutElastic: easeInOutElastic,
	    easeInBack: easeInBack,
	    easeOutBack: easeOutBack,
	    easeInOutBack: easeInOutBack,
	    easeInBounce: easeInBounce,
	    easeOutBounce: easeOutBounce,
	    easeInOutBounce: easeInOutBounce
	  };
	
	})();
	
	
	(function(global) {
	
	  'use strict';
	
	  /**
	   * @name fabric
	   * @namespace
	   */
	
	  var fabric = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      clone = fabric.util.object.clone,
	      toFixed = fabric.util.toFixed,
	      parseUnit = fabric.util.parseUnit,
	      multiplyTransformMatrices = fabric.util.multiplyTransformMatrices,
	
	      reAllowedSVGTagNames = /^(path|circle|polygon|polyline|ellipse|rect|line|image|text)$/i,
	      reViewBoxTagNames = /^(symbol|image|marker|pattern|view|svg)$/i,
	      reNotAllowedAncestors = /^(?:pattern|defs|symbol|metadata|clipPath|mask)$/i,
	      reAllowedParents = /^(symbol|g|a|svg)$/i,
	
	      attributesMap = {
	        cx:                   'left',
	        x:                    'left',
	        r:                    'radius',
	        cy:                   'top',
	        y:                    'top',
	        display:              'visible',
	        visibility:           'visible',
	        transform:            'transformMatrix',
	        'fill-opacity':       'fillOpacity',
	        'fill-rule':          'fillRule',
	        'font-family':        'fontFamily',
	        'font-size':          'fontSize',
	        'font-style':         'fontStyle',
	        'font-weight':        'fontWeight',
	        'stroke-dasharray':   'strokeDashArray',
	        'stroke-linecap':     'strokeLineCap',
	        'stroke-linejoin':    'strokeLineJoin',
	        'stroke-miterlimit':  'strokeMiterLimit',
	        'stroke-opacity':     'strokeOpacity',
	        'stroke-width':       'strokeWidth',
	        'text-decoration':    'textDecoration',
	        'text-anchor':        'originX'
	      },
	
	      colorAttributes = {
	        stroke: 'strokeOpacity',
	        fill:   'fillOpacity'
	      };
	
	  fabric.cssRules = { };
	  fabric.gradientDefs = { };
	
	  function normalizeAttr(attr) {
	    // transform attribute names
	    if (attr in attributesMap) {
	      return attributesMap[attr];
	    }
	    return attr;
	  }
	
	  function normalizeValue(attr, value, parentAttributes, fontSize) {
	    var isArray = Object.prototype.toString.call(value) === '[object Array]',
	        parsed;
	
	    if ((attr === 'fill' || attr === 'stroke') && value === 'none') {
	      value = '';
	    }
	    else if (attr === 'strokeDashArray') {
	      if (value === 'none') {
	        value = null;
	      }
	      else {
	        value = value.replace(/,/g, ' ').split(/\s+/).map(function(n) {
	          return parseFloat(n);
	        });
	      }
	    }
	    else if (attr === 'transformMatrix') {
	      if (parentAttributes && parentAttributes.transformMatrix) {
	        value = multiplyTransformMatrices(
	          parentAttributes.transformMatrix, fabric.parseTransformAttribute(value));
	      }
	      else {
	        value = fabric.parseTransformAttribute(value);
	      }
	    }
	    else if (attr === 'visible') {
	      value = (value === 'none' || value === 'hidden') ? false : true;
	      // display=none on parent element always takes precedence over child element
	      if (parentAttributes && parentAttributes.visible === false) {
	        value = false;
	      }
	    }
	    else if (attr === 'originX' /* text-anchor */) {
	      value = value === 'start' ? 'left' : value === 'end' ? 'right' : 'center';
	    }
	    else {
	      parsed = isArray ? value.map(parseUnit) : parseUnit(value, fontSize);
	    }
	
	    return (!isArray && isNaN(parsed) ? value : parsed);
	  }
	
	  /**
	   * @private
	   * @param {Object} attributes Array of attributes to parse
	   */
	  function _setStrokeFillOpacity(attributes) {
	    for (var attr in colorAttributes) {
	
	      if (typeof attributes[colorAttributes[attr]] === 'undefined' || attributes[attr] === '') {
	        continue;
	      }
	
	      if (typeof attributes[attr] === 'undefined') {
	        if (!fabric.Object.prototype[attr]) {
	          continue;
	        }
	        attributes[attr] = fabric.Object.prototype[attr];
	      }
	
	      if (attributes[attr].indexOf('url(') === 0) {
	        continue;
	      }
	
	      var color = new fabric.Color(attributes[attr]);
	      attributes[attr] = color.setAlpha(toFixed(color.getAlpha() * attributes[colorAttributes[attr]], 2)).toRgba();
	    }
	    return attributes;
	  }
	
	  /**
	   * @private
	   */
	  function _getMultipleNodes(doc, nodeNames) {
	    var nodeName, nodeArray = [], nodeList;
	    for (var i = 0; i < nodeNames.length; i++) {
	      nodeName = nodeNames[i];
	      nodeList = doc.getElementsByTagName(nodeName);
	      nodeArray = nodeArray.concat(Array.prototype.slice.call(nodeList));
	    }
	    return nodeArray;
	  }
	
	  /**
	   * Parses "transform" attribute, returning an array of values
	   * @static
	   * @function
	   * @memberOf fabric
	   * @param {String} attributeValue String containing attribute value
	   * @return {Array} Array of 6 elements representing transformation matrix
	   */
	  fabric.parseTransformAttribute = (function() {
	    function rotateMatrix(matrix, args) {
	      var cos = Math.cos(args[0]), sin = Math.sin(args[0]),
	          x = 0, y = 0;
	      if (args.length === 3) {
	        x = args[1];
	        y = args[2];
	      }
	
	      matrix[0] = cos;
	      matrix[1] = sin;
	      matrix[2] = -sin;
	      matrix[3] = cos;
	      matrix[4] = x - (cos * x - sin * y);
	      matrix[5] = y - (sin * x + cos * y);
	    }
	
	    function scaleMatrix(matrix, args) {
	      var multiplierX = args[0],
	          multiplierY = (args.length === 2) ? args[1] : args[0];
	
	      matrix[0] = multiplierX;
	      matrix[3] = multiplierY;
	    }
	
	    function skewMatrix(matrix, args, pos) {
	      matrix[pos] = Math.tan(fabric.util.degreesToRadians(args[0]));
	    }
	
	    function translateMatrix(matrix, args) {
	      matrix[4] = args[0];
	      if (args.length === 2) {
	        matrix[5] = args[1];
	      }
	    }
	
	    // identity matrix
	    var iMatrix = [
	          1, // a
	          0, // b
	          0, // c
	          1, // d
	          0, // e
	          0  // f
	        ],
	
	        // == begin transform regexp
	        number = fabric.reNum,
	
	        commaWsp = '(?:\\s+,?\\s*|,\\s*)',
	
	        skewX = '(?:(skewX)\\s*\\(\\s*(' + number + ')\\s*\\))',
	
	        skewY = '(?:(skewY)\\s*\\(\\s*(' + number + ')\\s*\\))',
	
	        rotate = '(?:(rotate)\\s*\\(\\s*(' + number + ')(?:' +
	                    commaWsp + '(' + number + ')' +
	                    commaWsp + '(' + number + '))?\\s*\\))',
	
	        scale = '(?:(scale)\\s*\\(\\s*(' + number + ')(?:' +
	                    commaWsp + '(' + number + '))?\\s*\\))',
	
	        translate = '(?:(translate)\\s*\\(\\s*(' + number + ')(?:' +
	                    commaWsp + '(' + number + '))?\\s*\\))',
	
	        matrix = '(?:(matrix)\\s*\\(\\s*' +
	                  '(' + number + ')' + commaWsp +
	                  '(' + number + ')' + commaWsp +
	                  '(' + number + ')' + commaWsp +
	                  '(' + number + ')' + commaWsp +
	                  '(' + number + ')' + commaWsp +
	                  '(' + number + ')' +
	                  '\\s*\\))',
	
	        transform = '(?:' +
	                    matrix + '|' +
	                    translate + '|' +
	                    scale + '|' +
	                    rotate + '|' +
	                    skewX + '|' +
	                    skewY +
	                    ')',
	
	        transforms = '(?:' + transform + '(?:' + commaWsp + '*' + transform + ')*' + ')',
	
	        transformList = '^\\s*(?:' + transforms + '?)\\s*$',
	
	        // http://www.w3.org/TR/SVG/coords.html#TransformAttribute
	        reTransformList = new RegExp(transformList),
	        // == end transform regexp
	
	        reTransform = new RegExp(transform, 'g');
	
	    return function(attributeValue) {
	
	      // start with identity matrix
	      var matrix = iMatrix.concat(),
	          matrices = [];
	
	      // return if no argument was given or
	      // an argument does not match transform attribute regexp
	      if (!attributeValue || (attributeValue && !reTransformList.test(attributeValue))) {
	        return matrix;
	      }
	
	      attributeValue.replace(reTransform, function(match) {
	
	        var m = new RegExp(transform).exec(match).filter(function (match) {
	              // match !== '' && match != null
	              return (!!match);
	            }),
	            operation = m[1],
	            args = m.slice(2).map(parseFloat);
	
	        switch (operation) {
	          case 'translate':
	            translateMatrix(matrix, args);
	            break;
	          case 'rotate':
	            args[0] = fabric.util.degreesToRadians(args[0]);
	            rotateMatrix(matrix, args);
	            break;
	          case 'scale':
	            scaleMatrix(matrix, args);
	            break;
	          case 'skewX':
	            skewMatrix(matrix, args, 2);
	            break;
	          case 'skewY':
	            skewMatrix(matrix, args, 1);
	            break;
	          case 'matrix':
	            matrix = args;
	            break;
	        }
	
	        // snapshot current matrix into matrices array
	        matrices.push(matrix.concat());
	        // reset
	        matrix = iMatrix.concat();
	      });
	
	      var combinedMatrix = matrices[0];
	      while (matrices.length > 1) {
	        matrices.shift();
	        combinedMatrix = fabric.util.multiplyTransformMatrices(combinedMatrix, matrices[0]);
	      }
	      return combinedMatrix;
	    };
	  })();
	
	  /**
	   * @private
	   */
	  function parseStyleString(style, oStyle) {
	    var attr, value;
	    style.replace(/;\s*$/, '').split(';').forEach(function (chunk) {
	      var pair = chunk.split(':');
	
	      attr = normalizeAttr(pair[0].trim().toLowerCase());
	      value = normalizeValue(attr, pair[1].trim());
	
	      oStyle[attr] = value;
	    });
	  }
	
	  /**
	   * @private
	   */
	  function parseStyleObject(style, oStyle) {
	    var attr, value;
	    for (var prop in style) {
	      if (typeof style[prop] === 'undefined') {
	        continue;
	      }
	
	      attr = normalizeAttr(prop.toLowerCase());
	      value = normalizeValue(attr, style[prop]);
	
	      oStyle[attr] = value;
	    }
	  }
	
	  /**
	   * @private
	   */
	  function getGlobalStylesForElement(element, svgUid) {
	    var styles = { };
	    for (var rule in fabric.cssRules[svgUid]) {
	      if (elementMatchesRule(element, rule.split(' '))) {
	        for (var property in fabric.cssRules[svgUid][rule]) {
	          styles[property] = fabric.cssRules[svgUid][rule][property];
	        }
	      }
	    }
	    return styles;
	  }
	
	  /**
	   * @private
	   */
	  function elementMatchesRule(element, selectors) {
	    var firstMatching, parentMatching = true;
	    //start from rightmost selector.
	    firstMatching = selectorMatches(element, selectors.pop());
	    if (firstMatching && selectors.length) {
	      parentMatching = doesSomeParentMatch(element, selectors);
	    }
	    return firstMatching && parentMatching && (selectors.length === 0);
	  }
	
	  function doesSomeParentMatch(element, selectors) {
	    var selector, parentMatching = true;
	    while (element.parentNode && element.parentNode.nodeType === 1 && selectors.length) {
	      if (parentMatching) {
	        selector = selectors.pop();
	      }
	      element = element.parentNode;
	      parentMatching = selectorMatches(element, selector);
	    }
	    return selectors.length === 0;
	  }
	
	  /**
	   * @private
	   */
	  function selectorMatches(element, selector) {
	    var nodeName = element.nodeName,
	        classNames = element.getAttribute('class'),
	        id = element.getAttribute('id'), matcher;
	    // i check if a selector matches slicing away part from it.
	    // if i get empty string i should match
	    matcher = new RegExp('^' + nodeName, 'i');
	    selector = selector.replace(matcher, '');
	    if (id && selector.length) {
	      matcher = new RegExp('#' + id + '(?![a-zA-Z\\-]+)', 'i');
	      selector = selector.replace(matcher, '');
	    }
	    if (classNames && selector.length) {
	      classNames = classNames.split(' ');
	      for (var i = classNames.length; i--;) {
	        matcher = new RegExp('\\.' + classNames[i] + '(?![a-zA-Z\\-]+)', 'i');
	        selector = selector.replace(matcher, '');
	      }
	    }
	    return selector.length === 0;
	  }
	
	  /**
	   * @private
	   * to support IE8 missing getElementById on SVGdocument
	   */
	  function elementById(doc, id) {
	    var el;
	    doc.getElementById && (el = doc.getElementById(id));
	    if (el) {
	      return el;
	    }
	    var node, i, nodelist = doc.getElementsByTagName('*');
	    for (i = 0; i < nodelist.length; i++) {
	      node = nodelist[i];
	      if (id === node.getAttribute('id')) {
	        return node;
	      }
	    }
	  }
	
	  /**
	   * @private
	   */
	  function parseUseDirectives(doc) {
	    var nodelist = _getMultipleNodes(doc, ['use', 'svg:use']), i = 0;
	
	    while (nodelist.length && i < nodelist.length) {
	      var el = nodelist[i],
	          xlink = el.getAttribute('xlink:href').substr(1),
	          x = el.getAttribute('x') || 0,
	          y = el.getAttribute('y') || 0,
	          el2 = elementById(doc, xlink).cloneNode(true),
	          currentTrans = (el2.getAttribute('transform') || '') + ' translate(' + x + ', ' + y + ')',
	          parentNode, oldLength = nodelist.length, attr, j, attrs, l;
	
	      applyViewboxTransform(el2);
	      if (/^svg$/i.test(el2.nodeName)) {
	        var el3 = el2.ownerDocument.createElement('g');
	        for (j = 0, attrs = el2.attributes, l = attrs.length; j < l; j++) {
	          attr = attrs.item(j);
	          el3.setAttribute(attr.nodeName, attr.nodeValue);
	        }
	        // el2.firstChild != null
	        while (el2.firstChild) {
	          el3.appendChild(el2.firstChild);
	        }
	        el2 = el3;
	      }
	
	      for (j = 0, attrs = el.attributes, l = attrs.length; j < l; j++) {
	        attr = attrs.item(j);
	        if (attr.nodeName === 'x' || attr.nodeName === 'y' || attr.nodeName === 'xlink:href') {
	          continue;
	        }
	
	        if (attr.nodeName === 'transform') {
	          currentTrans = attr.nodeValue + ' ' + currentTrans;
	        }
	        else {
	          el2.setAttribute(attr.nodeName, attr.nodeValue);
	        }
	      }
	
	      el2.setAttribute('transform', currentTrans);
	      el2.setAttribute('instantiated_by_use', '1');
	      el2.removeAttribute('id');
	      parentNode = el.parentNode;
	      parentNode.replaceChild(el2, el);
	      // some browsers do not shorten nodelist after replaceChild (IE8)
	      if (nodelist.length === oldLength) {
	        i++;
	      }
	    }
	  }
	
	  // http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute
	  // matches, e.g.: +14.56e-12, etc.
	  var reViewBoxAttrValue = new RegExp(
	    '^' +
	    '\\s*(' + fabric.reNum + '+)\\s*,?' +
	    '\\s*(' + fabric.reNum + '+)\\s*,?' +
	    '\\s*(' + fabric.reNum + '+)\\s*,?' +
	    '\\s*(' + fabric.reNum + '+)\\s*' +
	    '$'
	  );
	
	  /**
	   * Add a <g> element that envelop all child elements and makes the viewbox transformMatrix descend on all elements
	   */
	  function applyViewboxTransform(element) {
	
	    var viewBoxAttr = element.getAttribute('viewBox'),
	        scaleX = 1,
	        scaleY = 1,
	        minX = 0,
	        minY = 0,
	        viewBoxWidth, viewBoxHeight, matrix, el,
	        widthAttr = element.getAttribute('width'),
	        heightAttr = element.getAttribute('height'),
	        x = element.getAttribute('x') || 0,
	        y = element.getAttribute('y') || 0,
	        preserveAspectRatio = element.getAttribute('preserveAspectRatio') || '',
	        missingViewBox = (!viewBoxAttr || !reViewBoxTagNames.test(element.nodeName)
	                           || !(viewBoxAttr = viewBoxAttr.match(reViewBoxAttrValue))),
	        missingDimAttr = (!widthAttr || !heightAttr || widthAttr === '100%' || heightAttr === '100%'),
	        toBeParsed = missingViewBox && missingDimAttr,
	        parsedDim = { }, translateMatrix = '';
	
	    parsedDim.width = 0;
	    parsedDim.height = 0;
	    parsedDim.toBeParsed = toBeParsed;
	
	    if (toBeParsed) {
	      return parsedDim;
	    }
	
	    if (missingViewBox) {
	      parsedDim.width = parseUnit(widthAttr);
	      parsedDim.height = parseUnit(heightAttr);
	      return parsedDim;
	    }
	
	    minX = -parseFloat(viewBoxAttr[1]);
	    minY = -parseFloat(viewBoxAttr[2]);
	    viewBoxWidth = parseFloat(viewBoxAttr[3]);
	    viewBoxHeight = parseFloat(viewBoxAttr[4]);
	
	    if (!missingDimAttr) {
	      parsedDim.width = parseUnit(widthAttr);
	      parsedDim.height = parseUnit(heightAttr);
	      scaleX = parsedDim.width / viewBoxWidth;
	      scaleY = parsedDim.height / viewBoxHeight;
	    }
	    else {
	      parsedDim.width = viewBoxWidth;
	      parsedDim.height = viewBoxHeight;
	    }
	
	    // default is to preserve aspect ratio
	    preserveAspectRatio = fabric.util.parsePreserveAspectRatioAttribute(preserveAspectRatio);
	    if (preserveAspectRatio.alignX !== 'none') {
	      //translate all container for the effect of Mid, Min, Max
	      scaleY = scaleX = (scaleX > scaleY ? scaleY : scaleX);
	    }
	
	    if (scaleX === 1 && scaleY === 1 && minX === 0 && minY === 0 && x === 0 && y === 0) {
	      return parsedDim;
	    }
	
	    if (x || y) {
	      translateMatrix = ' translate(' + parseUnit(x) + ' ' + parseUnit(y) + ') ';
	    }
	
	    matrix = translateMatrix + ' matrix(' + scaleX +
	                  ' 0' +
	                  ' 0 ' +
	                  scaleY + ' ' +
	                  (minX * scaleX) + ' ' +
	                  (minY * scaleY) + ') ';
	
	    if (element.nodeName === 'svg') {
	      el = element.ownerDocument.createElement('g');
	      // element.firstChild != null
	      while (element.firstChild) {
	        el.appendChild(element.firstChild);
	      }
	      element.appendChild(el);
	    }
	    else {
	      el = element;
	      matrix = el.getAttribute('transform') + matrix;
	    }
	
	    el.setAttribute('transform', matrix);
	    return parsedDim;
	  }
	
	  function hasAncestorWithNodeName(element, nodeName) {
	    while (element && (element = element.parentNode)) {
	      if (element.nodeName && nodeName.test(element.nodeName.replace('svg:', ''))
	        && !element.getAttribute('instantiated_by_use')) {
	        return true;
	      }
	    }
	    return false;
	  }
	
	  /**
	   * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback
	   * @static
	   * @function
	   * @memberOf fabric
	   * @param {SVGDocument} doc SVG document to parse
	   * @param {Function} callback Callback to call when parsing is finished;
	   * It's being passed an array of elements (parsed from a document).
	   * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
	   */
	  fabric.parseSVGDocument = function(doc, callback, reviver) {
	    if (!doc) {
	      return;
	    }
	
	    parseUseDirectives(doc);
	
	    var svgUid =  fabric.Object.__uid++,
	        options = applyViewboxTransform(doc),
	        descendants = fabric.util.toArray(doc.getElementsByTagName('*'));
	
	    options.svgUid = svgUid;
	
	    if (descendants.length === 0 && fabric.isLikelyNode) {
	      // we're likely in node, where "o3-xml" library fails to gEBTN("*")
	      // https://github.com/ajaxorg/node-o3-xml/issues/21
	      descendants = doc.selectNodes('//*[name(.)!="svg"]');
	      var arr = [];
	      for (var i = 0, len = descendants.length; i < len; i++) {
	        arr[i] = descendants[i];
	      }
	      descendants = arr;
	    }
	
	    var elements = descendants.filter(function(el) {
	      applyViewboxTransform(el);
	      return reAllowedSVGTagNames.test(el.nodeName.replace('svg:', '')) &&
	            !hasAncestorWithNodeName(el, reNotAllowedAncestors); // http://www.w3.org/TR/SVG/struct.html#DefsElement
	    });
	
	    if (!elements || (elements && !elements.length)) {
	      callback && callback([], {});
	      return;
	    }
	
	    fabric.gradientDefs[svgUid] = fabric.getGradientDefs(doc);
	    fabric.cssRules[svgUid] = fabric.getCSSRules(doc);
	    // Precedence of rules:   style > class > attribute
	    fabric.parseElements(elements, function(instances) {
	      if (callback) {
	        callback(instances, options);
	      }
	    }, clone(options), reviver);
	  };
	
	  var reFontDeclaration = new RegExp(
	    '(normal|italic)?\\s*(normal|small-caps)?\\s*' +
	    '(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(' +
	      fabric.reNum +
	    '(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|' + fabric.reNum + '))?\\s+(.*)');
	
	  extend(fabric, {
	    /**
	     * Parses a short font declaration, building adding its properties to a style object
	     * @static
	     * @function
	     * @memberOf fabric
	     * @param {String} value font declaration
	     * @param {Object} oStyle definition
	     */
	    parseFontDeclaration: function(value, oStyle) {
	      var match = value.match(reFontDeclaration);
	
	      if (!match) {
	        return;
	      }
	      var fontStyle = match[1],
	          // font variant is not used
	          // fontVariant = match[2],
	          fontWeight = match[3],
	          fontSize = match[4],
	          lineHeight = match[5],
	          fontFamily = match[6];
	
	      if (fontStyle) {
	        oStyle.fontStyle = fontStyle;
	      }
	      if (fontWeight) {
	        oStyle.fontWeight = isNaN(parseFloat(fontWeight)) ? fontWeight : parseFloat(fontWeight);
	      }
	      if (fontSize) {
	        oStyle.fontSize = parseUnit(fontSize);
	      }
	      if (fontFamily) {
	        oStyle.fontFamily = fontFamily;
	      }
	      if (lineHeight) {
	        oStyle.lineHeight = lineHeight === 'normal' ? 1 : lineHeight;
	      }
	    },
	
	    /**
	     * Parses an SVG document, returning all of the gradient declarations found in it
	     * @static
	     * @function
	     * @memberOf fabric
	     * @param {SVGDocument} doc SVG document to parse
	     * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element
	     */
	    getGradientDefs: function(doc) {
	      var tagArray = [
	            'linearGradient',
	            'radialGradient',
	            'svg:linearGradient',
	            'svg:radialGradient'],
	          elList = _getMultipleNodes(doc, tagArray),
	          el, j = 0, id, xlink,
	          gradientDefs = { }, idsToXlinkMap = { };
	
	      j = elList.length;
	
	      while (j--) {
	        el = elList[j];
	        xlink = el.getAttribute('xlink:href');
	        id = el.getAttribute('id');
	        if (xlink) {
	          idsToXlinkMap[id] = xlink.substr(1);
	        }
	        gradientDefs[id] = el;
	      }
	
	      for (id in idsToXlinkMap) {
	        var el2 = gradientDefs[idsToXlinkMap[id]].cloneNode(true);
	        el = gradientDefs[id];
	        while (el2.firstChild) {
	          el.appendChild(el2.firstChild);
	        }
	      }
	      return gradientDefs;
	    },
	
	    /**
	     * Returns an object of attributes' name/value, given element and an array of attribute names;
	     * Parses parent "g" nodes recursively upwards.
	     * @static
	     * @memberOf fabric
	     * @param {DOMElement} element Element to parse
	     * @param {Array} attributes Array of attributes to parse
	     * @return {Object} object containing parsed attributes' names/values
	     */
	    parseAttributes: function(element, attributes, svgUid) {
	
	      if (!element) {
	        return;
	      }
	
	      var value,
	          parentAttributes = { },
	          fontSize;
	
	      if (typeof svgUid === 'undefined') {
	        svgUid = element.getAttribute('svgUid');
	      }
	      // if there's a parent container (`g` or `a` or `symbol` node), parse its attributes recursively upwards
	      if (element.parentNode && reAllowedParents.test(element.parentNode.nodeName)) {
	        parentAttributes = fabric.parseAttributes(element.parentNode, attributes, svgUid);
	      }
	      fontSize = (parentAttributes && parentAttributes.fontSize ) ||
	                 element.getAttribute('font-size') || fabric.Text.DEFAULT_SVG_FONT_SIZE;
	
	      var ownAttributes = attributes.reduce(function(memo, attr) {
	        value = element.getAttribute(attr);
	        if (value) {
	          attr = normalizeAttr(attr);
	          value = normalizeValue(attr, value, parentAttributes, fontSize);
	
	          memo[attr] = value;
	        }
	        return memo;
	      }, { });
	
	      // add values parsed from style, which take precedence over attributes
	      // (see: http://www.w3.org/TR/SVG/styling.html#UsingPresentationAttributes)
	      ownAttributes = extend(ownAttributes,
	        extend(getGlobalStylesForElement(element, svgUid), fabric.parseStyleAttribute(element)));
	      if (ownAttributes.font) {
	        fabric.parseFontDeclaration(ownAttributes.font, ownAttributes);
	      }
	      return _setStrokeFillOpacity(extend(parentAttributes, ownAttributes));
	    },
	
	    /**
	     * Transforms an array of svg elements to corresponding fabric.* instances
	     * @static
	     * @memberOf fabric
	     * @param {Array} elements Array of elements to parse
	     * @param {Function} callback Being passed an array of fabric instances (transformed from SVG elements)
	     * @param {Object} [options] Options object
	     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
	     */
	    parseElements: function(elements, callback, options, reviver) {
	      new fabric.ElementsParser(elements, callback, options, reviver).parse();
	    },
	
	    /**
	     * Parses "style" attribute, retuning an object with values
	     * @static
	     * @memberOf fabric
	     * @param {SVGElement} element Element to parse
	     * @return {Object} Objects with values parsed from style attribute of an element
	     */
	    parseStyleAttribute: function(element) {
	      var oStyle = { },
	          style = element.getAttribute('style');
	
	      if (!style) {
	        return oStyle;
	      }
	
	      if (typeof style === 'string') {
	        parseStyleString(style, oStyle);
	      }
	      else {
	        parseStyleObject(style, oStyle);
	      }
	
	      return oStyle;
	    },
	
	    /**
	     * Parses "points" attribute, returning an array of values
	     * @static
	     * @memberOf fabric
	     * @param {String} points points attribute string
	     * @return {Array} array of points
	     */
	    parsePointsAttribute: function(points) {
	
	      // points attribute is required and must not be empty
	      if (!points) {
	        return null;
	      }
	
	      // replace commas with whitespace and remove bookending whitespace
	      points = points.replace(/,/g, ' ').trim();
	
	      points = points.split(/\s+/);
	      var parsedPoints = [], i, len;
	
	      i = 0;
	      len = points.length;
	      for (; i < len; i += 2) {
	        parsedPoints.push({
	          x: parseFloat(points[i]),
	          y: parseFloat(points[i + 1])
	        });
	      }
	
	      // odd number of points is an error
	      // if (parsedPoints.length % 2 !== 0) {
	      //   return null;
	      // }
	
	      return parsedPoints;
	    },
	
	    /**
	     * Returns CSS rules for a given SVG document
	     * @static
	     * @function
	     * @memberOf fabric
	     * @param {SVGDocument} doc SVG document to parse
	     * @return {Object} CSS rules of this document
	     */
	    getCSSRules: function(doc) {
	      var styles = doc.getElementsByTagName('style'),
	          allRules = { }, rules;
	
	      // very crude parsing of style contents
	      for (var i = 0, len = styles.length; i < len; i++) {
	        // IE9 doesn't support textContent, but provides text instead.
	        var styleContents = styles[i].textContent || styles[i].text;
	
	        // remove comments
	        styleContents = styleContents.replace(/\/\*[\s\S]*?\*\//g, '');
	        if (styleContents.trim() === '') {
	          continue;
	        }
	        rules = styleContents.match(/[^{]*\{[\s\S]*?\}/g);
	        rules = rules.map(function(rule) { return rule.trim(); });
	        rules.forEach(function(rule) {
	
	          var match = rule.match(/([\s\S]*?)\s*\{([^}]*)\}/),
	              ruleObj = { }, declaration = match[2].trim(),
	              propertyValuePairs = declaration.replace(/;$/, '').split(/\s*;\s*/);
	
	          for (var i = 0, len = propertyValuePairs.length; i < len; i++) {
	            var pair = propertyValuePairs[i].split(/\s*:\s*/),
	                property = normalizeAttr(pair[0]),
	                value = normalizeValue(property, pair[1], pair[0]);
	            ruleObj[property] = value;
	          }
	          rule = match[1];
	          rule.split(',').forEach(function(_rule) {
	            _rule = _rule.replace(/^svg/i, '').trim();
	            if (_rule === '') {
	              return;
	            }
	            if (allRules[_rule]) {
	              fabric.util.object.extend(allRules[_rule], ruleObj);
	            }
	            else {
	              allRules[_rule] = fabric.util.object.clone(ruleObj);
	            }
	          });
	        });
	      }
	      return allRules;
	    },
	
	    /**
	     * Takes url corresponding to an SVG document, and parses it into a set of fabric objects.
	     * Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)
	     * @memberOf fabric
	     * @param {String} url
	     * @param {Function} callback
	     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
	     */
	    loadSVGFromURL: function(url, callback, reviver) {
	
	      url = url.replace(/^\n\s*/, '').trim();
	      new fabric.util.request(url, {
	        method: 'get',
	        onComplete: onComplete
	      });
	
	      function onComplete(r) {
	
	        var xml = r.responseXML;
	        if (xml && !xml.documentElement && fabric.window.ActiveXObject && r.responseText) {
	          xml = new ActiveXObject('Microsoft.XMLDOM');
	          xml.async = 'false';
	          //IE chokes on DOCTYPE
	          xml.loadXML(r.responseText.replace(/<!DOCTYPE[\s\S]*?(\[[\s\S]*\])*?>/i, ''));
	        }
	        if (!xml || !xml.documentElement) {
	          callback && callback(null);
	        }
	
	        fabric.parseSVGDocument(xml.documentElement, function (results, options) {
	          callback && callback(results, options);
	        }, reviver);
	      }
	    },
	
	    /**
	     * Takes string corresponding to an SVG document, and parses it into a set of fabric objects
	     * @memberOf fabric
	     * @param {String} string
	     * @param {Function} callback
	     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
	     */
	    loadSVGFromString: function(string, callback, reviver) {
	      string = string.trim();
	      var doc;
	      if (typeof DOMParser !== 'undefined') {
	        var parser = new DOMParser();
	        if (parser && parser.parseFromString) {
	          doc = parser.parseFromString(string, 'text/xml');
	        }
	      }
	      else if (fabric.window.ActiveXObject) {
	        doc = new ActiveXObject('Microsoft.XMLDOM');
	        doc.async = 'false';
	        // IE chokes on DOCTYPE
	        doc.loadXML(string.replace(/<!DOCTYPE[\s\S]*?(\[[\s\S]*\])*?>/i, ''));
	      }
	
	      fabric.parseSVGDocument(doc.documentElement, function (results, options) {
	        callback(results, options);
	      }, reviver);
	    }
	  });
	
	})( true ? exports : this);
	
	
	fabric.ElementsParser = function(elements, callback, options, reviver) {
	  this.elements = elements;
	  this.callback = callback;
	  this.options = options;
	  this.reviver = reviver;
	  this.svgUid = (options && options.svgUid) || 0;
	};
	
	fabric.ElementsParser.prototype.parse = function() {
	  this.instances = new Array(this.elements.length);
	  this.numElements = this.elements.length;
	
	  this.createObjects();
	};
	
	fabric.ElementsParser.prototype.createObjects = function() {
	  for (var i = 0, len = this.elements.length; i < len; i++) {
	    this.elements[i].setAttribute('svgUid', this.svgUid);
	    (function(_obj, i) {
	      setTimeout(function() {
	        _obj.createObject(_obj.elements[i], i);
	      }, 0);
	    })(this, i);
	  }
	};
	
	fabric.ElementsParser.prototype.createObject = function(el, index) {
	  var klass = fabric[fabric.util.string.capitalize(el.tagName.replace('svg:', ''))];
	  if (klass && klass.fromElement) {
	    try {
	      this._createObject(klass, el, index);
	    }
	    catch (err) {
	      fabric.log(err);
	    }
	  }
	  else {
	    this.checkIfDone();
	  }
	};
	
	fabric.ElementsParser.prototype._createObject = function(klass, el, index) {
	  if (klass.async) {
	    klass.fromElement(el, this.createCallback(index, el), this.options);
	  }
	  else {
	    var obj = klass.fromElement(el, this.options);
	    this.resolveGradient(obj, 'fill');
	    this.resolveGradient(obj, 'stroke');
	    this.reviver && this.reviver(el, obj);
	    this.instances[index] = obj;
	    this.checkIfDone();
	  }
	};
	
	fabric.ElementsParser.prototype.createCallback = function(index, el) {
	  var _this = this;
	  return function(obj) {
	    _this.resolveGradient(obj, 'fill');
	    _this.resolveGradient(obj, 'stroke');
	    _this.reviver && _this.reviver(el, obj);
	    _this.instances[index] = obj;
	    _this.checkIfDone();
	  };
	};
	
	fabric.ElementsParser.prototype.resolveGradient = function(obj, property) {
	
	  var instanceFillValue = obj.get(property);
	  if (!(/^url\(/).test(instanceFillValue)) {
	    return;
	  }
	  var gradientId = instanceFillValue.slice(5, instanceFillValue.length - 1);
	  if (fabric.gradientDefs[this.svgUid][gradientId]) {
	    obj.set(property,
	      fabric.Gradient.fromElement(fabric.gradientDefs[this.svgUid][gradientId], obj));
	  }
	};
	
	fabric.ElementsParser.prototype.checkIfDone = function() {
	  if (--this.numElements === 0) {
	    this.instances = this.instances.filter(function(el) {
	      // eslint-disable-next-line no-eq-null, eqeqeq
	      return el != null;
	    });
	    this.callback(this.instances);
	  }
	};
	
	
	(function(global) {
	
	  'use strict';
	
	  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */
	
	  var fabric = global.fabric || (global.fabric = { });
	
	  if (fabric.Point) {
	    fabric.warn('fabric.Point is already defined');
	    return;
	  }
	
	  fabric.Point = Point;
	
	  /**
	   * Point class
	   * @class fabric.Point
	   * @memberOf fabric
	   * @constructor
	   * @param {Number} x
	   * @param {Number} y
	   * @return {fabric.Point} thisArg
	   */
	  function Point(x, y) {
	    this.x = x;
	    this.y = y;
	  }
	
	  Point.prototype = /** @lends fabric.Point.prototype */ {
	
	    type: 'point',
	
	    constructor: Point,
	
	    /**
	     * Adds another point to this one and returns another one
	     * @param {fabric.Point} that
	     * @return {fabric.Point} new Point instance with added values
	     */
	    add: function (that) {
	      return new Point(this.x + that.x, this.y + that.y);
	    },
	
	    /**
	     * Adds another point to this one
	     * @param {fabric.Point} that
	     * @return {fabric.Point} thisArg
	     * @chainable
	     */
	    addEquals: function (that) {
	      this.x += that.x;
	      this.y += that.y;
	      return this;
	    },
	
	    /**
	     * Adds value to this point and returns a new one
	     * @param {Number} scalar
	     * @return {fabric.Point} new Point with added value
	     */
	    scalarAdd: function (scalar) {
	      return new Point(this.x + scalar, this.y + scalar);
	    },
	
	    /**
	     * Adds value to this point
	     * @param {Number} scalar
	     * @return {fabric.Point} thisArg
	     * @chainable
	     */
	    scalarAddEquals: function (scalar) {
	      this.x += scalar;
	      this.y += scalar;
	      return this;
	    },
	
	    /**
	     * Subtracts another point from this point and returns a new one
	     * @param {fabric.Point} that
	     * @return {fabric.Point} new Point object with subtracted values
	     */
	    subtract: function (that) {
	      return new Point(this.x - that.x, this.y - that.y);
	    },
	
	    /**
	     * Subtracts another point from this point
	     * @param {fabric.Point} that
	     * @return {fabric.Point} thisArg
	     * @chainable
	     */
	    subtractEquals: function (that) {
	      this.x -= that.x;
	      this.y -= that.y;
	      return this;
	    },
	
	    /**
	     * Subtracts value from this point and returns a new one
	     * @param {Number} scalar
	     * @return {fabric.Point}
	     */
	    scalarSubtract: function (scalar) {
	      return new Point(this.x - scalar, this.y - scalar);
	    },
	
	    /**
	     * Subtracts value from this point
	     * @param {Number} scalar
	     * @return {fabric.Point} thisArg
	     * @chainable
	     */
	    scalarSubtractEquals: function (scalar) {
	      this.x -= scalar;
	      this.y -= scalar;
	      return this;
	    },
	
	    /**
	     * Miltiplies this point by a value and returns a new one
	     * TODO: rename in scalarMultiply in 2.0
	     * @param {Number} scalar
	     * @return {fabric.Point}
	     */
	    multiply: function (scalar) {
	      return new Point(this.x * scalar, this.y * scalar);
	    },
	
	    /**
	     * Miltiplies this point by a value
	     * TODO: rename in scalarMultiplyEquals in 2.0
	     * @param {Number} scalar
	     * @return {fabric.Point} thisArg
	     * @chainable
	     */
	    multiplyEquals: function (scalar) {
	      this.x *= scalar;
	      this.y *= scalar;
	      return this;
	    },
	
	    /**
	     * Divides this point by a value and returns a new one
	     * TODO: rename in scalarDivide in 2.0
	     * @param {Number} scalar
	     * @return {fabric.Point}
	     */
	    divide: function (scalar) {
	      return new Point(this.x / scalar, this.y / scalar);
	    },
	
	    /**
	     * Divides this point by a value
	     * TODO: rename in scalarDivideEquals in 2.0
	     * @param {Number} scalar
	     * @return {fabric.Point} thisArg
	     * @chainable
	     */
	    divideEquals: function (scalar) {
	      this.x /= scalar;
	      this.y /= scalar;
	      return this;
	    },
	
	    /**
	     * Returns true if this point is equal to another one
	     * @param {fabric.Point} that
	     * @return {Boolean}
	     */
	    eq: function (that) {
	      return (this.x === that.x && this.y === that.y);
	    },
	
	    /**
	     * Returns true if this point is less than another one
	     * @param {fabric.Point} that
	     * @return {Boolean}
	     */
	    lt: function (that) {
	      return (this.x < that.x && this.y < that.y);
	    },
	
	    /**
	     * Returns true if this point is less than or equal to another one
	     * @param {fabric.Point} that
	     * @return {Boolean}
	     */
	    lte: function (that) {
	      return (this.x <= that.x && this.y <= that.y);
	    },
	
	    /**
	
	     * Returns true if this point is greater another one
	     * @param {fabric.Point} that
	     * @return {Boolean}
	     */
	    gt: function (that) {
	      return (this.x > that.x && this.y > that.y);
	    },
	
	    /**
	     * Returns true if this point is greater than or equal to another one
	     * @param {fabric.Point} that
	     * @return {Boolean}
	     */
	    gte: function (that) {
	      return (this.x >= that.x && this.y >= that.y);
	    },
	
	    /**
	     * Returns new point which is the result of linear interpolation with this one and another one
	     * @param {fabric.Point} that
	     * @param {Number} t , position of interpolation, between 0 and 1 default 0.5
	     * @return {fabric.Point}
	     */
	    lerp: function (that, t) {
	      if (typeof t === 'undefined') {
	        t = 0.5;
	      }
	      t = Math.max(Math.min(1, t), 0);
	      return new Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);
	    },
	
	    /**
	     * Returns distance from this point and another one
	     * @param {fabric.Point} that
	     * @return {Number}
	     */
	    distanceFrom: function (that) {
	      var dx = this.x - that.x,
	          dy = this.y - that.y;
	      return Math.sqrt(dx * dx + dy * dy);
	    },
	
	    /**
	     * Returns the point between this point and another one
	     * @param {fabric.Point} that
	     * @return {fabric.Point}
	     */
	    midPointFrom: function (that) {
	      return this.lerp(that);
	    },
	
	    /**
	     * Returns a new point which is the min of this and another one
	     * @param {fabric.Point} that
	     * @return {fabric.Point}
	     */
	    min: function (that) {
	      return new Point(Math.min(this.x, that.x), Math.min(this.y, that.y));
	    },
	
	    /**
	     * Returns a new point which is the max of this and another one
	     * @param {fabric.Point} that
	     * @return {fabric.Point}
	     */
	    max: function (that) {
	      return new Point(Math.max(this.x, that.x), Math.max(this.y, that.y));
	    },
	
	    /**
	     * Returns string representation of this point
	     * @return {String}
	     */
	    toString: function () {
	      return this.x + ',' + this.y;
	    },
	
	    /**
	     * Sets x/y of this point
	     * @param {Number} x
	     * @param {Number} y
	     * @chainable
	     */
	    setXY: function (x, y) {
	      this.x = x;
	      this.y = y;
	      return this;
	    },
	
	    /**
	     * Sets x of this point
	     * @param {Number} x
	     * @chainable
	     */
	    setX: function (x) {
	      this.x = x;
	      return this;
	    },
	
	    /**
	     * Sets y of this point
	     * @param {Number} y
	     * @chainable
	     */
	    setY: function (y) {
	      this.y = y;
	      return this;
	    },
	
	    /**
	     * Sets x/y of this point from another point
	     * @param {fabric.Point} that
	     * @chainable
	     */
	    setFromPoint: function (that) {
	      this.x = that.x;
	      this.y = that.y;
	      return this;
	    },
	
	    /**
	     * Swaps x/y of this point and another point
	     * @param {fabric.Point} that
	     */
	    swap: function (that) {
	      var x = this.x,
	          y = this.y;
	      this.x = that.x;
	      this.y = that.y;
	      that.x = x;
	      that.y = y;
	    },
	
	    /**
	     * return a cloned instance of the point
	     * @return {fabric.Point}
	     */
	    clone: function () {
	      return new Point(this.x, this.y);
	    }
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */
	  var fabric = global.fabric || (global.fabric = { });
	
	  if (fabric.Intersection) {
	    fabric.warn('fabric.Intersection is already defined');
	    return;
	  }
	
	  /**
	   * Intersection class
	   * @class fabric.Intersection
	   * @memberOf fabric
	   * @constructor
	   */
	  function Intersection(status) {
	    this.status = status;
	    this.points = [];
	  }
	
	  fabric.Intersection = Intersection;
	
	  fabric.Intersection.prototype = /** @lends fabric.Intersection.prototype */ {
	
	    constructor: Intersection,
	
	    /**
	     * Appends a point to intersection
	     * @param {fabric.Point} point
	     * @return {fabric.Intersection} thisArg
	     * @chainable
	     */
	    appendPoint: function (point) {
	      this.points.push(point);
	      return this;
	    },
	
	    /**
	     * Appends points to intersection
	     * @param {Array} points
	     * @return {fabric.Intersection} thisArg
	     * @chainable
	     */
	    appendPoints: function (points) {
	      this.points = this.points.concat(points);
	      return this;
	    }
	  };
	
	  /**
	   * Checks if one line intersects another
	   * TODO: rename in intersectSegmentSegment
	   * @static
	   * @param {fabric.Point} a1
	   * @param {fabric.Point} a2
	   * @param {fabric.Point} b1
	   * @param {fabric.Point} b2
	   * @return {fabric.Intersection}
	   */
	  fabric.Intersection.intersectLineLine = function (a1, a2, b1, b2) {
	    var result,
	        uaT = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),
	        ubT = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),
	        uB = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
	    if (uB !== 0) {
	      var ua = uaT / uB,
	          ub = ubT / uB;
	      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
	        result = new Intersection('Intersection');
	        result.appendPoint(new fabric.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));
	      }
	      else {
	        result = new Intersection();
	      }
	    }
	    else {
	      if (uaT === 0 || ubT === 0) {
	        result = new Intersection('Coincident');
	      }
	      else {
	        result = new Intersection('Parallel');
	      }
	    }
	    return result;
	  };
	
	  /**
	   * Checks if line intersects polygon
	   * TODO: rename in intersectSegmentPolygon
	   * fix detection of coincident
	   * @static
	   * @param {fabric.Point} a1
	   * @param {fabric.Point} a2
	   * @param {Array} points
	   * @return {fabric.Intersection}
	   */
	  fabric.Intersection.intersectLinePolygon = function(a1, a2, points) {
	    var result = new Intersection(),
	        length = points.length,
	        b1, b2, inter;
	
	    for (var i = 0; i < length; i++) {
	      b1 = points[i];
	      b2 = points[(i + 1) % length];
	      inter = Intersection.intersectLineLine(a1, a2, b1, b2);
	
	      result.appendPoints(inter.points);
	    }
	    if (result.points.length > 0) {
	      result.status = 'Intersection';
	    }
	    return result;
	  };
	
	  /**
	   * Checks if polygon intersects another polygon
	   * @static
	   * @param {Array} points1
	   * @param {Array} points2
	   * @return {fabric.Intersection}
	   */
	  fabric.Intersection.intersectPolygonPolygon = function (points1, points2) {
	    var result = new Intersection(),
	        length = points1.length;
	
	    for (var i = 0; i < length; i++) {
	      var a1 = points1[i],
	          a2 = points1[(i + 1) % length],
	          inter = Intersection.intersectLinePolygon(a1, a2, points2);
	
	      result.appendPoints(inter.points);
	    }
	    if (result.points.length > 0) {
	      result.status = 'Intersection';
	    }
	    return result;
	  };
	
	  /**
	   * Checks if polygon intersects rectangle
	   * @static
	   * @param {Array} points
	   * @param {fabric.Point} r1
	   * @param {fabric.Point} r2
	   * @return {fabric.Intersection}
	   */
	  fabric.Intersection.intersectPolygonRectangle = function (points, r1, r2) {
	    var min = r1.min(r2),
	        max = r1.max(r2),
	        topRight = new fabric.Point(max.x, min.y),
	        bottomLeft = new fabric.Point(min.x, max.y),
	        inter1 = Intersection.intersectLinePolygon(min, topRight, points),
	        inter2 = Intersection.intersectLinePolygon(topRight, max, points),
	        inter3 = Intersection.intersectLinePolygon(max, bottomLeft, points),
	        inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points),
	        result = new Intersection();
	
	    result.appendPoints(inter1.points);
	    result.appendPoints(inter2.points);
	    result.appendPoints(inter3.points);
	    result.appendPoints(inter4.points);
	
	    if (result.points.length > 0) {
	      result.status = 'Intersection';
	    }
	    return result;
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { });
	
	  if (fabric.Color) {
	    fabric.warn('fabric.Color is already defined.');
	    return;
	  }
	
	  /**
	   * Color class
	   * The purpose of {@link fabric.Color} is to abstract and encapsulate common color operations;
	   * {@link fabric.Color} is a constructor and creates instances of {@link fabric.Color} objects.
	   *
	   * @class fabric.Color
	   * @param {String} color optional in hex or rgb(a) or hsl format or from known color list
	   * @return {fabric.Color} thisArg
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#colors}
	   */
	  function Color(color) {
	    if (!color) {
	      this.setSource([0, 0, 0, 1]);
	    }
	    else {
	      this._tryParsingColor(color);
	    }
	  }
	
	  fabric.Color = Color;
	
	  fabric.Color.prototype = /** @lends fabric.Color.prototype */ {
	
	    /**
	     * @private
	     * @param {String|Array} color Color value to parse
	     */
	    _tryParsingColor: function(color) {
	      var source;
	
	      if (color in Color.colorNameMap) {
	        color = Color.colorNameMap[color];
	      }
	
	      if (color === 'transparent') {
	        source = [255, 255, 255, 0];
	      }
	
	      if (!source) {
	        source = Color.sourceFromHex(color);
	      }
	      if (!source) {
	        source = Color.sourceFromRgb(color);
	      }
	      if (!source) {
	        source = Color.sourceFromHsl(color);
	      }
	      if (!source) {
	        //if color is not recognize let's make black as canvas does
	        source = [0, 0, 0, 1];
	      }
	      if (source) {
	        this.setSource(source);
	      }
	    },
	
	    /**
	     * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
	     * @private
	     * @param {Number} r Red color value
	     * @param {Number} g Green color value
	     * @param {Number} b Blue color value
	     * @return {Array} Hsl color
	     */
	    _rgbToHsl: function(r, g, b) {
	      r /= 255; g /= 255; b /= 255;
	
	      var h, s, l,
	          max = fabric.util.array.max([r, g, b]),
	          min = fabric.util.array.min([r, g, b]);
	
	      l = (max + min) / 2;
	
	      if (max === min) {
	        h = s = 0; // achromatic
	      }
	      else {
	        var d = max - min;
	        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
	        switch (max) {
	          case r:
	            h = (g - b) / d + (g < b ? 6 : 0);
	            break;
	          case g:
	            h = (b - r) / d + 2;
	            break;
	          case b:
	            h = (r - g) / d + 4;
	            break;
	        }
	        h /= 6;
	      }
	
	      return [
	        Math.round(h * 360),
	        Math.round(s * 100),
	        Math.round(l * 100)
	      ];
	    },
	
	    /**
	     * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])
	     * @return {Array}
	     */
	    getSource: function() {
	      return this._source;
	    },
	
	    /**
	     * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])
	     * @param {Array} source
	     */
	    setSource: function(source) {
	      this._source = source;
	    },
	
	    /**
	     * Returns color represenation in RGB format
	     * @return {String} ex: rgb(0-255,0-255,0-255)
	     */
	    toRgb: function() {
	      var source = this.getSource();
	      return 'rgb(' + source[0] + ',' + source[1] + ',' + source[2] + ')';
	    },
	
	    /**
	     * Returns color represenation in RGBA format
	     * @return {String} ex: rgba(0-255,0-255,0-255,0-1)
	     */
	    toRgba: function() {
	      var source = this.getSource();
	      return 'rgba(' + source[0] + ',' + source[1] + ',' + source[2] + ',' + source[3] + ')';
	    },
	
	    /**
	     * Returns color represenation in HSL format
	     * @return {String} ex: hsl(0-360,0%-100%,0%-100%)
	     */
	    toHsl: function() {
	      var source = this.getSource(),
	          hsl = this._rgbToHsl(source[0], source[1], source[2]);
	
	      return 'hsl(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%)';
	    },
	
	    /**
	     * Returns color represenation in HSLA format
	     * @return {String} ex: hsla(0-360,0%-100%,0%-100%,0-1)
	     */
	    toHsla: function() {
	      var source = this.getSource(),
	          hsl = this._rgbToHsl(source[0], source[1], source[2]);
	
	      return 'hsla(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%,' + source[3] + ')';
	    },
	
	    /**
	     * Returns color represenation in HEX format
	     * @return {String} ex: FF5555
	     */
	    toHex: function() {
	      var source = this.getSource(), r, g, b;
	
	      r = source[0].toString(16);
	      r = (r.length === 1) ? ('0' + r) : r;
	
	      g = source[1].toString(16);
	      g = (g.length === 1) ? ('0' + g) : g;
	
	      b = source[2].toString(16);
	      b = (b.length === 1) ? ('0' + b) : b;
	
	      return r.toUpperCase() + g.toUpperCase() + b.toUpperCase();
	    },
	
	    /**
	     * Gets value of alpha channel for this color
	     * @return {Number} 0-1
	     */
	    getAlpha: function() {
	      return this.getSource()[3];
	    },
	
	    /**
	     * Sets value of alpha channel for this color
	     * @param {Number} alpha Alpha value 0-1
	     * @return {fabric.Color} thisArg
	     */
	    setAlpha: function(alpha) {
	      var source = this.getSource();
	      source[3] = alpha;
	      this.setSource(source);
	      return this;
	    },
	
	    /**
	     * Transforms color to its grayscale representation
	     * @return {fabric.Color} thisArg
	     */
	    toGrayscale: function() {
	      var source = this.getSource(),
	          average = parseInt((source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), 10),
	          currentAlpha = source[3];
	      this.setSource([average, average, average, currentAlpha]);
	      return this;
	    },
	
	    /**
	     * Transforms color to its black and white representation
	     * @param {Number} threshold
	     * @return {fabric.Color} thisArg
	     */
	    toBlackWhite: function(threshold) {
	      var source = this.getSource(),
	          average = (source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0),
	          currentAlpha = source[3];
	
	      threshold = threshold || 127;
	
	      average = (Number(average) < Number(threshold)) ? 0 : 255;
	      this.setSource([average, average, average, currentAlpha]);
	      return this;
	    },
	
	    /**
	     * Overlays color with another color
	     * @param {String|fabric.Color} otherColor
	     * @return {fabric.Color} thisArg
	     */
	    overlayWith: function(otherColor) {
	      if (!(otherColor instanceof Color)) {
	        otherColor = new Color(otherColor);
	      }
	
	      var result = [],
	          alpha = this.getAlpha(),
	          otherAlpha = 0.5,
	          source = this.getSource(),
	          otherSource = otherColor.getSource();
	
	      for (var i = 0; i < 3; i++) {
	        result.push(Math.round((source[i] * (1 - otherAlpha)) + (otherSource[i] * otherAlpha)));
	      }
	
	      result[3] = alpha;
	      this.setSource(result);
	      return this;
	    }
	  };
	
	  /**
	   * Regex matching color in RGB or RGBA formats (ex: rgb(0, 0, 0), rgba(255, 100, 10, 0.5), rgba( 255 , 100 , 10 , 0.5 ), rgb(1,1,1), rgba(100%, 60%, 10%, 0.5))
	   * @static
	   * @field
	   * @memberOf fabric.Color
	   */
	   // eslint-disable-next-line max-len
	  fabric.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/;
	
	  /**
	   * Regex matching color in HSL or HSLA formats (ex: hsl(200, 80%, 10%), hsla(300, 50%, 80%, 0.5), hsla( 300 , 50% , 80% , 0.5 ))
	   * @static
	   * @field
	   * @memberOf fabric.Color
	   */
	  fabric.Color.reHSLa = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/;
	
	  /**
	   * Regex matching color in HEX format (ex: #FF5544CC, #FF5555, 010155, aff)
	   * @static
	   * @field
	   * @memberOf fabric.Color
	   */
	  fabric.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;
	
	  /**
	   * Map of the 17 basic color names with HEX code
	   * @static
	   * @field
	   * @memberOf fabric.Color
	   * @see: http://www.w3.org/TR/CSS2/syndata.html#color-units
	   */
	  fabric.Color.colorNameMap = {
	    aqua:    '#00FFFF',
	    black:   '#000000',
	    blue:    '#0000FF',
	    fuchsia: '#FF00FF',
	    gray:    '#808080',
	    grey:    '#808080',
	    green:   '#008000',
	    lime:    '#00FF00',
	    maroon:  '#800000',
	    navy:    '#000080',
	    olive:   '#808000',
	    orange:  '#FFA500',
	    purple:  '#800080',
	    red:     '#FF0000',
	    silver:  '#C0C0C0',
	    teal:    '#008080',
	    white:   '#FFFFFF',
	    yellow:  '#FFFF00'
	  };
	
	  /**
	   * @private
	   * @param {Number} p
	   * @param {Number} q
	   * @param {Number} t
	   * @return {Number}
	   */
	  function hue2rgb(p, q, t) {
	    if (t < 0) {
	      t += 1;
	    }
	    if (t > 1) {
	      t -= 1;
	    }
	    if (t < 1 / 6) {
	      return p + (q - p) * 6 * t;
	    }
	    if (t < 1 / 2) {
	      return q;
	    }
	    if (t < 2 / 3) {
	      return p + (q - p) * (2 / 3 - t) * 6;
	    }
	    return p;
	  }
	
	  /**
	   * Returns new color object, when given a color in RGB format
	   * @memberOf fabric.Color
	   * @param {String} color Color value ex: rgb(0-255,0-255,0-255)
	   * @return {fabric.Color}
	   */
	  fabric.Color.fromRgb = function(color) {
	    return Color.fromSource(Color.sourceFromRgb(color));
	  };
	
	  /**
	   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in RGB or RGBA format
	   * @memberOf fabric.Color
	   * @param {String} color Color value ex: rgb(0-255,0-255,0-255), rgb(0%-100%,0%-100%,0%-100%)
	   * @return {Array} source
	   */
	  fabric.Color.sourceFromRgb = function(color) {
	    var match = color.match(Color.reRGBa);
	    if (match) {
	      var r = parseInt(match[1], 10) / (/%$/.test(match[1]) ? 100 : 1) * (/%$/.test(match[1]) ? 255 : 1),
	          g = parseInt(match[2], 10) / (/%$/.test(match[2]) ? 100 : 1) * (/%$/.test(match[2]) ? 255 : 1),
	          b = parseInt(match[3], 10) / (/%$/.test(match[3]) ? 100 : 1) * (/%$/.test(match[3]) ? 255 : 1);
	
	      return [
	        parseInt(r, 10),
	        parseInt(g, 10),
	        parseInt(b, 10),
	        match[4] ? parseFloat(match[4]) : 1
	      ];
	    }
	  };
	
	  /**
	   * Returns new color object, when given a color in RGBA format
	   * @static
	   * @function
	   * @memberOf fabric.Color
	   * @param {String} color
	   * @return {fabric.Color}
	   */
	  fabric.Color.fromRgba = Color.fromRgb;
	
	  /**
	   * Returns new color object, when given a color in HSL format
	   * @param {String} color Color value ex: hsl(0-260,0%-100%,0%-100%)
	   * @memberOf fabric.Color
	   * @return {fabric.Color}
	   */
	  fabric.Color.fromHsl = function(color) {
	    return Color.fromSource(Color.sourceFromHsl(color));
	  };
	
	  /**
	   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HSL or HSLA format.
	   * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
	   * @memberOf fabric.Color
	   * @param {String} color Color value ex: hsl(0-360,0%-100%,0%-100%) or hsla(0-360,0%-100%,0%-100%, 0-1)
	   * @return {Array} source
	   * @see http://http://www.w3.org/TR/css3-color/#hsl-color
	   */
	  fabric.Color.sourceFromHsl = function(color) {
	    var match = color.match(Color.reHSLa);
	    if (!match) {
	      return;
	    }
	
	    var h = (((parseFloat(match[1]) % 360) + 360) % 360) / 360,
	        s = parseFloat(match[2]) / (/%$/.test(match[2]) ? 100 : 1),
	        l = parseFloat(match[3]) / (/%$/.test(match[3]) ? 100 : 1),
	        r, g, b;
	
	    if (s === 0) {
	      r = g = b = l;
	    }
	    else {
	      var q = l <= 0.5 ? l * (s + 1) : l + s - l * s,
	          p = l * 2 - q;
	
	      r = hue2rgb(p, q, h + 1 / 3);
	      g = hue2rgb(p, q, h);
	      b = hue2rgb(p, q, h - 1 / 3);
	    }
	
	    return [
	      Math.round(r * 255),
	      Math.round(g * 255),
	      Math.round(b * 255),
	      match[4] ? parseFloat(match[4]) : 1
	    ];
	  };
	
	  /**
	   * Returns new color object, when given a color in HSLA format
	   * @static
	   * @function
	   * @memberOf fabric.Color
	   * @param {String} color
	   * @return {fabric.Color}
	   */
	  fabric.Color.fromHsla = Color.fromHsl;
	
	  /**
	   * Returns new color object, when given a color in HEX format
	   * @static
	   * @memberOf fabric.Color
	   * @param {String} color Color value ex: FF5555
	   * @return {fabric.Color}
	   */
	  fabric.Color.fromHex = function(color) {
	    return Color.fromSource(Color.sourceFromHex(color));
	  };
	
	  /**
	   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HEX format
	   * @static
	   * @memberOf fabric.Color
	   * @param {String} color ex: FF5555 or FF5544CC (RGBa)
	   * @return {Array} source
	   */
	  fabric.Color.sourceFromHex = function(color) {
	    if (color.match(Color.reHex)) {
	      var value = color.slice(color.indexOf('#') + 1),
	          isShortNotation = (value.length === 3 || value.length === 4),
	          isRGBa = (value.length === 8 || value.length === 4),
	          r = isShortNotation ? (value.charAt(0) + value.charAt(0)) : value.substring(0, 2),
	          g = isShortNotation ? (value.charAt(1) + value.charAt(1)) : value.substring(2, 4),
	          b = isShortNotation ? (value.charAt(2) + value.charAt(2)) : value.substring(4, 6),
	          a = isRGBa ? (isShortNotation ? (value.charAt(3) + value.charAt(3)) : value.substring(6, 8)) : 'FF';
	
	      return [
	        parseInt(r, 16),
	        parseInt(g, 16),
	        parseInt(b, 16),
	        parseFloat((parseInt(a, 16) / 255).toFixed(2))
	      ];
	    }
	  };
	
	  /**
	   * Returns new color object, when given color in array representation (ex: [200, 100, 100, 0.5])
	   * @static
	   * @memberOf fabric.Color
	   * @param {Array} source
	   * @return {fabric.Color}
	   */
	  fabric.Color.fromSource = function(source) {
	    var oColor = new Color();
	    oColor.setSource(source);
	    return oColor;
	  };
	
	})( true ? exports : this);
	
	
	(function() {
	
	  /* _FROM_SVG_START_ */
	  function getColorStop(el) {
	    var style = el.getAttribute('style'),
	        offset = el.getAttribute('offset') || 0,
	        color, colorAlpha, opacity;
	
	    // convert percents to absolute values
	    offset = parseFloat(offset) / (/%$/.test(offset) ? 100 : 1);
	    offset = offset < 0 ? 0 : offset > 1 ? 1 : offset;
	    if (style) {
	      var keyValuePairs = style.split(/\s*;\s*/);
	
	      if (keyValuePairs[keyValuePairs.length - 1] === '') {
	        keyValuePairs.pop();
	      }
	
	      for (var i = keyValuePairs.length; i--; ) {
	
	        var split = keyValuePairs[i].split(/\s*:\s*/),
	            key = split[0].trim(),
	            value = split[1].trim();
	
	        if (key === 'stop-color') {
	          color = value;
	        }
	        else if (key === 'stop-opacity') {
	          opacity = value;
	        }
	      }
	    }
	
	    if (!color) {
	      color = el.getAttribute('stop-color') || 'rgb(0,0,0)';
	    }
	    if (!opacity) {
	      opacity = el.getAttribute('stop-opacity');
	    }
	
	    color = new fabric.Color(color);
	    colorAlpha = color.getAlpha();
	    opacity = isNaN(parseFloat(opacity)) ? 1 : parseFloat(opacity);
	    opacity *= colorAlpha;
	
	    return {
	      offset: offset,
	      color: color.toRgb(),
	      opacity: opacity
	    };
	  }
	
	  function getLinearCoords(el) {
	    return {
	      x1: el.getAttribute('x1') || 0,
	      y1: el.getAttribute('y1') || 0,
	      x2: el.getAttribute('x2') || '100%',
	      y2: el.getAttribute('y2') || 0
	    };
	  }
	
	  function getRadialCoords(el) {
	    return {
	      x1: el.getAttribute('fx') || el.getAttribute('cx') || '50%',
	      y1: el.getAttribute('fy') || el.getAttribute('cy') || '50%',
	      r1: 0,
	      x2: el.getAttribute('cx') || '50%',
	      y2: el.getAttribute('cy') || '50%',
	      r2: el.getAttribute('r') || '50%'
	    };
	  }
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Gradient class
	   * @class fabric.Gradient
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#gradients}
	   * @see {@link fabric.Gradient#initialize} for constructor definition
	   */
	  fabric.Gradient = fabric.util.createClass(/** @lends fabric.Gradient.prototype */ {
	
	    /**
	     * Horizontal offset for aligning gradients coming from SVG when outside pathgroups
	     * @type Number
	     * @default 0
	     */
	    offsetX: 0,
	
	    /**
	     * Vertical offset for aligning gradients coming from SVG when outside pathgroups
	     * @type Number
	     * @default 0
	     */
	    offsetY: 0,
	
	    /**
	     * Constructor
	     * @param {Object} [options] Options object with type, coords, gradientUnits and colorStops
	     * @return {fabric.Gradient} thisArg
	     */
	    initialize: function(options) {
	      options || (options = { });
	
	      var coords = { };
	
	      this.id = fabric.Object.__uid++;
	      this.type = options.type || 'linear';
	
	      coords = {
	        x1: options.coords.x1 || 0,
	        y1: options.coords.y1 || 0,
	        x2: options.coords.x2 || 0,
	        y2: options.coords.y2 || 0
	      };
	
	      if (this.type === 'radial') {
	        coords.r1 = options.coords.r1 || 0;
	        coords.r2 = options.coords.r2 || 0;
	      }
	      this.coords = coords;
	      this.colorStops = options.colorStops.slice();
	      if (options.gradientTransform) {
	        this.gradientTransform = options.gradientTransform;
	      }
	      this.offsetX = options.offsetX || this.offsetX;
	      this.offsetY = options.offsetY || this.offsetY;
	    },
	
	    /**
	     * Adds another colorStop
	     * @param {Object} colorStop Object with offset and color
	     * @return {fabric.Gradient} thisArg
	     */
	    addColorStop: function(colorStops) {
	      for (var position in colorStops) {
	        var color = new fabric.Color(colorStops[position]);
	        this.colorStops.push({
	          offset: position,
	          color: color.toRgb(),
	          opacity: color.getAlpha()
	        });
	      }
	      return this;
	    },
	
	    /**
	     * Returns object representation of a gradient
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object}
	     */
	    toObject: function(propertiesToInclude) {
	      var object = {
	        type: this.type,
	        coords: this.coords,
	        colorStops: this.colorStops,
	        offsetX: this.offsetX,
	        offsetY: this.offsetY,
	        gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform
	      };
	      fabric.util.populateWithProperties(this, object, propertiesToInclude);
	
	      return object;
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns SVG representation of an gradient
	     * @param {Object} object Object to create a gradient for
	     * @return {String} SVG representation of an gradient (linear/radial)
	     */
	    toSVG: function(object) {
	      var coords = fabric.util.object.clone(this.coords),
	          markup, commonAttributes;
	
	      // colorStops must be sorted ascending
	      this.colorStops.sort(function(a, b) {
	        return a.offset - b.offset;
	      });
	
	      if (!(object.group && object.group.type === 'path-group')) {
	        for (var prop in coords) {
	          if (prop === 'x1' || prop === 'x2' || prop === 'r2') {
	            coords[prop] += this.offsetX - object.width / 2;
	          }
	          else if (prop === 'y1' || prop === 'y2') {
	            coords[prop] += this.offsetY - object.height / 2;
	          }
	        }
	      }
	
	      commonAttributes = 'id="SVGID_' + this.id +
	                     '" gradientUnits="userSpaceOnUse"';
	      if (this.gradientTransform) {
	        commonAttributes += ' gradientTransform="matrix(' + this.gradientTransform.join(' ') + ')" ';
	      }
	      if (this.type === 'linear') {
	        markup = [
	          '<linearGradient ',
	          commonAttributes,
	          ' x1="', coords.x1,
	          '" y1="', coords.y1,
	          '" x2="', coords.x2,
	          '" y2="', coords.y2,
	          '">\n'
	        ];
	      }
	      else if (this.type === 'radial') {
	        markup = [
	          '<radialGradient ',
	          commonAttributes,
	          ' cx="', coords.x2,
	          '" cy="', coords.y2,
	          '" r="', coords.r2,
	          '" fx="', coords.x1,
	          '" fy="', coords.y1,
	          '">\n'
	        ];
	      }
	
	      for (var i = 0; i < this.colorStops.length; i++) {
	        markup.push(
	          '<stop ',
	            'offset="', (this.colorStops[i].offset * 100) + '%',
	            '" style="stop-color:', this.colorStops[i].color,
	            (this.colorStops[i].opacity !== null ? ';stop-opacity: ' + this.colorStops[i].opacity : ';'),
	          '"/>\n'
	        );
	      }
	
	      markup.push((this.type === 'linear' ? '</linearGradient>\n' : '</radialGradient>\n'));
	
	      return markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns an instance of CanvasGradient
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Object} object
	     * @return {CanvasGradient}
	     */
	    toLive: function(ctx, object) {
	      var gradient, prop, coords = fabric.util.object.clone(this.coords);
	
	      if (!this.type) {
	        return;
	      }
	
	      if (object.group && object.group.type === 'path-group') {
	        for (prop in coords) {
	          if (prop === 'x1' || prop === 'x2') {
	            coords[prop] += -this.offsetX + object.width / 2;
	          }
	          else if (prop === 'y1' || prop === 'y2') {
	            coords[prop] += -this.offsetY + object.height / 2;
	          }
	        }
	      }
	
	      if (this.type === 'linear') {
	        gradient = ctx.createLinearGradient(
	          coords.x1, coords.y1, coords.x2, coords.y2);
	      }
	      else if (this.type === 'radial') {
	        gradient = ctx.createRadialGradient(
	          coords.x1, coords.y1, coords.r1, coords.x2, coords.y2, coords.r2);
	      }
	
	      for (var i = 0, len = this.colorStops.length; i < len; i++) {
	        var color = this.colorStops[i].color,
	            opacity = this.colorStops[i].opacity,
	            offset = this.colorStops[i].offset;
	
	        if (typeof opacity !== 'undefined') {
	          color = new fabric.Color(color).setAlpha(opacity).toRgba();
	        }
	        gradient.addColorStop(parseFloat(offset), color);
	      }
	
	      return gradient;
	    }
	  });
	
	  fabric.util.object.extend(fabric.Gradient, {
	
	    /* _FROM_SVG_START_ */
	    /**
	     * Returns {@link fabric.Gradient} instance from an SVG element
	     * @static
	     * @memberOf fabric.Gradient
	     * @param {SVGGradientElement} el SVG gradient element
	     * @param {fabric.Object} instance
	     * @return {fabric.Gradient} Gradient instance
	     * @see http://www.w3.org/TR/SVG/pservers.html#LinearGradientElement
	     * @see http://www.w3.org/TR/SVG/pservers.html#RadialGradientElement
	     */
	    fromElement: function(el, instance) {
	
	      /**
	       *  @example:
	       *
	       *  <linearGradient id="linearGrad1">
	       *    <stop offset="0%" stop-color="white"/>
	       *    <stop offset="100%" stop-color="black"/>
	       *  </linearGradient>
	       *
	       *  OR
	       *
	       *  <linearGradient id="linearGrad2">
	       *    <stop offset="0" style="stop-color:rgb(255,255,255)"/>
	       *    <stop offset="1" style="stop-color:rgb(0,0,0)"/>
	       *  </linearGradient>
	       *
	       *  OR
	       *
	       *  <radialGradient id="radialGrad1">
	       *    <stop offset="0%" stop-color="white" stop-opacity="1" />
	       *    <stop offset="50%" stop-color="black" stop-opacity="0.5" />
	       *    <stop offset="100%" stop-color="white" stop-opacity="1" />
	       *  </radialGradient>
	       *
	       *  OR
	       *
	       *  <radialGradient id="radialGrad2">
	       *    <stop offset="0" stop-color="rgb(255,255,255)" />
	       *    <stop offset="0.5" stop-color="rgb(0,0,0)" />
	       *    <stop offset="1" stop-color="rgb(255,255,255)" />
	       *  </radialGradient>
	       *
	       */
	
	      var colorStopEls = el.getElementsByTagName('stop'),
	          type,
	          gradientUnits = el.getAttribute('gradientUnits') || 'objectBoundingBox',
	          gradientTransform = el.getAttribute('gradientTransform'),
	          colorStops = [],
	          coords, ellipseMatrix;
	
	      if (el.nodeName === 'linearGradient' || el.nodeName === 'LINEARGRADIENT') {
	        type = 'linear';
	      }
	      else {
	        type = 'radial';
	      }
	
	      if (type === 'linear') {
	        coords = getLinearCoords(el);
	      }
	      else if (type === 'radial') {
	        coords = getRadialCoords(el);
	      }
	
	      for (var i = colorStopEls.length; i--; ) {
	        colorStops.push(getColorStop(colorStopEls[i]));
	      }
	
	      ellipseMatrix = _convertPercentUnitsToValues(instance, coords, gradientUnits);
	
	      var gradient = new fabric.Gradient({
	        type: type,
	        coords: coords,
	        colorStops: colorStops,
	        offsetX: -instance.left,
	        offsetY: -instance.top
	      });
	
	      if (gradientTransform || ellipseMatrix !== '') {
	        gradient.gradientTransform = fabric.parseTransformAttribute((gradientTransform || '') + ellipseMatrix);
	      }
	      return gradient;
	    },
	    /* _FROM_SVG_END_ */
	
	    /**
	     * Returns {@link fabric.Gradient} instance from its object representation
	     * @static
	     * @memberOf fabric.Gradient
	     * @param {Object} obj
	     * @param {Object} [options] Options object
	     */
	    forObject: function(obj, options) {
	      options || (options = { });
	      _convertPercentUnitsToValues(obj, options.coords, 'userSpaceOnUse');
	      return new fabric.Gradient(options);
	    }
	  });
	
	  /**
	   * @private
	   */
	  function _convertPercentUnitsToValues(object, options, gradientUnits) {
	    var propValue, addFactor = 0, multFactor = 1, ellipseMatrix = '';
	    for (var prop in options) {
	      if (options[prop] === 'Infinity') {
	        options[prop] = 1;
	      }
	      else if (options[prop] === '-Infinity') {
	        options[prop] = 0;
	      }
	      propValue = parseFloat(options[prop], 10);
	      if (typeof options[prop] === 'string' && /^\d+%$/.test(options[prop])) {
	        multFactor = 0.01;
	      }
	      else {
	        multFactor = 1;
	      }
	      if (prop === 'x1' || prop === 'x2' || prop === 'r2') {
	        multFactor *= gradientUnits === 'objectBoundingBox' ? object.width : 1;
	        addFactor = gradientUnits === 'objectBoundingBox' ? object.left || 0 : 0;
	      }
	      else if (prop === 'y1' || prop === 'y2') {
	        multFactor *= gradientUnits === 'objectBoundingBox' ? object.height : 1;
	        addFactor = gradientUnits === 'objectBoundingBox' ? object.top || 0 : 0;
	      }
	      options[prop] = propValue * multFactor + addFactor;
	    }
	    if (object.type === 'ellipse' &&
	        options.r2 !== null &&
	        gradientUnits === 'objectBoundingBox' &&
	        object.rx !== object.ry) {
	
	      var scaleFactor = object.ry / object.rx;
	      ellipseMatrix = ' scale(1, ' + scaleFactor + ')';
	      if (options.y1) {
	        options.y1 /= scaleFactor;
	      }
	      if (options.y2) {
	        options.y2 /= scaleFactor;
	      }
	    }
	    return ellipseMatrix;
	  }
	})();
	
	
	(function() {
	
	  'use strict';
	
	  var toFixed = fabric.util.toFixed;
	
	  /**
	   * Pattern class
	   * @class fabric.Pattern
	   * @see {@link http://fabricjs.com/patterns|Pattern demo}
	   * @see {@link http://fabricjs.com/dynamic-patterns|DynamicPattern demo}
	   * @see {@link fabric.Pattern#initialize} for constructor definition
	   */
	
	
	  fabric.Pattern = fabric.util.createClass(/** @lends fabric.Pattern.prototype */ {
	
	    /**
	     * Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)
	     * @type String
	     * @default
	     */
	    repeat: 'repeat',
	
	    /**
	     * Pattern horizontal offset from object's left/top corner
	     * @type Number
	     * @default
	     */
	    offsetX: 0,
	
	    /**
	     * Pattern vertical offset from object's left/top corner
	     * @type Number
	     * @default
	     */
	    offsetY: 0,
	
	    /**
	     * Constructor
	     * @param {Object} [options] Options object
	     * @param {Function} [callback] function to invoke after callback init.
	     * @return {fabric.Pattern} thisArg
	     */
	    initialize: function(options, callback) {
	      options || (options = { });
	
	      this.id = fabric.Object.__uid++;
	      this.setOptions(options);
	      if (!options.source || (options.source && typeof options.source !== 'string')) {
	        callback && callback(this);
	        return;
	      }
	      // function string
	      if (typeof fabric.util.getFunctionBody(options.source) !== 'undefined') {
	        this.source = new Function(fabric.util.getFunctionBody(options.source));
	        callback && callback(this);
	      }
	      else {
	        // img src string
	        var _this = this;
	        this.source = fabric.util.createImage();
	        fabric.util.loadImage(options.source, function(img) {
	          _this.source = img;
	          callback && callback(_this);
	        });
	      }
	    },
	
	    /**
	     * Returns object representation of a pattern
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} Object representation of a pattern instance
	     */
	    toObject: function(propertiesToInclude) {
	      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
	          source, object;
	
	      // callback
	      if (typeof this.source === 'function') {
	        source = String(this.source);
	      }
	      // <img> element
	      else if (typeof this.source.src === 'string') {
	        source = this.source.src;
	      }
	      // <canvas> element
	      else if (typeof this.source === 'object' && this.source.toDataURL) {
	        source = this.source.toDataURL();
	      }
	
	      object = {
	        type: 'pattern',
	        source: source,
	        repeat: this.repeat,
	        offsetX: toFixed(this.offsetX, NUM_FRACTION_DIGITS),
	        offsetY: toFixed(this.offsetY, NUM_FRACTION_DIGITS),
	      };
	      fabric.util.populateWithProperties(this, object, propertiesToInclude);
	
	      return object;
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns SVG representation of a pattern
	     * @param {fabric.Object} object
	     * @return {String} SVG representation of a pattern
	     */
	    toSVG: function(object) {
	      var patternSource = typeof this.source === 'function' ? this.source() : this.source,
	          patternWidth = patternSource.width / object.width,
	          patternHeight = patternSource.height / object.height,
	          patternOffsetX = this.offsetX / object.width,
	          patternOffsetY = this.offsetY / object.height,
	          patternImgSrc = '';
	      if (this.repeat === 'repeat-x' || this.repeat === 'no-repeat') {
	        patternHeight = 1;
	      }
	      if (this.repeat === 'repeat-y' || this.repeat === 'no-repeat') {
	        patternWidth = 1;
	      }
	      if (patternSource.src) {
	        patternImgSrc = patternSource.src;
	      }
	      else if (patternSource.toDataURL) {
	        patternImgSrc = patternSource.toDataURL();
	      }
	
	      return '<pattern id="SVGID_' + this.id +
	                    '" x="' + patternOffsetX +
	                    '" y="' + patternOffsetY +
	                    '" width="' + patternWidth +
	                    '" height="' + patternHeight + '">\n' +
	               '<image x="0" y="0"' +
	                      ' width="' + patternSource.width +
	                      '" height="' + patternSource.height +
	                      '" xlink:href="' + patternImgSrc +
	               '"></image>\n' +
	             '</pattern>\n';
	    },
	    /* _TO_SVG_END_ */
	
	    setOptions: function(options) {
	      for (var prop in options) {
	        this[prop] = options[prop];
	      }
	    },
	
	    /**
	     * Returns an instance of CanvasPattern
	     * @param {CanvasRenderingContext2D} ctx Context to create pattern
	     * @return {CanvasPattern}
	     */
	    toLive: function(ctx) {
	      var source = typeof this.source === 'function' ? this.source() : this.source;
	
	      // if the image failed to load, return, and allow rest to continue loading
	      if (!source) {
	        return '';
	      }
	
	      // if an image
	      if (typeof source.src !== 'undefined') {
	        if (!source.complete) {
	          return '';
	        }
	        if (source.naturalWidth === 0 || source.naturalHeight === 0) {
	          return '';
	        }
	      }
	      return ctx.createPattern(source, this.repeat);
	    }
	  });
	})();
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      toFixed = fabric.util.toFixed;
	
	  if (fabric.Shadow) {
	    fabric.warn('fabric.Shadow is already defined.');
	    return;
	  }
	
	  /**
	   * Shadow class
	   * @class fabric.Shadow
	   * @see {@link http://fabricjs.com/shadows|Shadow demo}
	   * @see {@link fabric.Shadow#initialize} for constructor definition
	   */
	  fabric.Shadow = fabric.util.createClass(/** @lends fabric.Shadow.prototype */ {
	
	    /**
	     * Shadow color
	     * @type String
	     * @default
	     */
	    color: 'rgb(0,0,0)',
	
	    /**
	     * Shadow blur
	     * @type Number
	     */
	    blur: 0,
	
	    /**
	     * Shadow horizontal offset
	     * @type Number
	     * @default
	     */
	    offsetX: 0,
	
	    /**
	     * Shadow vertical offset
	     * @type Number
	     * @default
	     */
	    offsetY: 0,
	
	    /**
	     * Whether the shadow should affect stroke operations
	     * @type Boolean
	     * @default
	     */
	    affectStroke: false,
	
	    /**
	     * Indicates whether toObject should include default values
	     * @type Boolean
	     * @default
	     */
	    includeDefaultValues: true,
	
	    /**
	     * Constructor
	     * @param {Object|String} [options] Options object with any of color, blur, offsetX, offsetX properties or string (e.g. "rgba(0,0,0,0.2) 2px 2px 10px, "2px 2px 10px rgba(0,0,0,0.2)")
	     * @return {fabric.Shadow} thisArg
	     */
	    initialize: function(options) {
	
	      if (typeof options === 'string') {
	        options = this._parseShadow(options);
	      }
	
	      for (var prop in options) {
	        this[prop] = options[prop];
	      }
	
	      this.id = fabric.Object.__uid++;
	    },
	
	    /**
	     * @private
	     * @param {String} shadow Shadow value to parse
	     * @return {Object} Shadow object with color, offsetX, offsetY and blur
	     */
	    _parseShadow: function(shadow) {
	      var shadowStr = shadow.trim(),
	          offsetsAndBlur = fabric.Shadow.reOffsetsAndBlur.exec(shadowStr) || [],
	          color = shadowStr.replace(fabric.Shadow.reOffsetsAndBlur, '') || 'rgb(0,0,0)';
	
	      return {
	        color: color.trim(),
	        offsetX: parseInt(offsetsAndBlur[1], 10) || 0,
	        offsetY: parseInt(offsetsAndBlur[2], 10) || 0,
	        blur: parseInt(offsetsAndBlur[3], 10) || 0
	      };
	    },
	
	    /**
	     * Returns a string representation of an instance
	     * @see http://www.w3.org/TR/css-text-decor-3/#text-shadow
	     * @return {String} Returns CSS3 text-shadow declaration
	     */
	    toString: function() {
	      return [this.offsetX, this.offsetY, this.blur, this.color].join('px ');
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns SVG representation of a shadow
	     * @param {fabric.Object} object
	     * @return {String} SVG representation of a shadow
	     */
	    toSVG: function(object) {
	      var fBoxX = 40, fBoxY = 40, NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
	          offset = fabric.util.rotateVector(
	            { x: this.offsetX, y: this.offsetY },
	            fabric.util.degreesToRadians(-object.angle)),
	          BLUR_BOX = 20;
	
	      if (object.width && object.height) {
	        //http://www.w3.org/TR/SVG/filters.html#FilterEffectsRegion
	        // we add some extra space to filter box to contain the blur ( 20 )
	        fBoxX = toFixed((Math.abs(offset.x) + this.blur) / object.width, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;
	        fBoxY = toFixed((Math.abs(offset.y) + this.blur) / object.height, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;
	      }
	      if (object.flipX) {
	        offset.x *= -1;
	      }
	      if (object.flipY) {
	        offset.y *= -1;
	      }
	      return (
	        '<filter id="SVGID_' + this.id + '" y="-' + fBoxY + '%" height="' + (100 + 2 * fBoxY) + '%" ' +
	          'x="-' + fBoxX + '%" width="' + (100 + 2 * fBoxX) + '%" ' + '>\n' +
	          '\t<feGaussianBlur in="SourceAlpha" stdDeviation="' +
	            toFixed(this.blur ? this.blur / 2 : 0, NUM_FRACTION_DIGITS) + '"></feGaussianBlur>\n' +
	          '\t<feOffset dx="' + toFixed(offset.x, NUM_FRACTION_DIGITS) +
	          '" dy="' + toFixed(offset.y, NUM_FRACTION_DIGITS) + '" result="oBlur" ></feOffset>\n' +
	          '\t<feFlood flood-color="' + this.color + '"/>\n' +
	          '\t<feComposite in2="oBlur" operator="in" />\n' +
	          '\t<feMerge>\n' +
	            '\t\t<feMergeNode></feMergeNode>\n' +
	            '\t\t<feMergeNode in="SourceGraphic"></feMergeNode>\n' +
	          '\t</feMerge>\n' +
	        '</filter>\n');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns object representation of a shadow
	     * @return {Object} Object representation of a shadow instance
	     */
	    toObject: function() {
	      if (this.includeDefaultValues) {
	        return {
	          color: this.color,
	          blur: this.blur,
	          offsetX: this.offsetX,
	          offsetY: this.offsetY,
	          affectStroke: this.affectStroke
	        };
	      }
	      var obj = { }, proto = fabric.Shadow.prototype;
	
	      ['color', 'blur', 'offsetX', 'offsetY', 'affectStroke'].forEach(function(prop) {
	        if (this[prop] !== proto[prop]) {
	          obj[prop] = this[prop];
	        }
	      }, this);
	
	      return obj;
	    }
	  });
	
	  /**
	   * Regex matching shadow offsetX, offsetY and blur (ex: "2px 2px 10px rgba(0,0,0,0.2)", "rgb(0,255,0) 2px 2px")
	   * @static
	   * @field
	   * @memberOf fabric.Shadow
	   */
	  // eslint-disable-next-line max-len
	  fabric.Shadow.reOffsetsAndBlur = /(?:\s|^)(-?\d+(?:px)?(?:\s?|$))?(-?\d+(?:px)?(?:\s?|$))?(\d+(?:px)?)?(?:\s?|$)(?:$|\s)/;
	
	})( true ? exports : this);
	
	
	(function () {
	
	  'use strict';
	
	  if (fabric.StaticCanvas) {
	    fabric.warn('fabric.StaticCanvas is already defined.');
	    return;
	  }
	
	  // aliases for faster resolution
	  var extend = fabric.util.object.extend,
	      getElementOffset = fabric.util.getElementOffset,
	      removeFromArray = fabric.util.removeFromArray,
	      toFixed = fabric.util.toFixed,
	
	      CANVAS_INIT_ERROR = new Error('Could not initialize `canvas` element');
	
	  /**
	   * Static canvas class
	   * @class fabric.StaticCanvas
	   * @mixes fabric.Collection
	   * @mixes fabric.Observable
	   * @see {@link http://fabricjs.com/static_canvas|StaticCanvas demo}
	   * @see {@link fabric.StaticCanvas#initialize} for constructor definition
	   * @fires before:render
	   * @fires after:render
	   * @fires canvas:cleared
	   * @fires object:added
	   * @fires object:removed
	   */
	  fabric.StaticCanvas = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.StaticCanvas.prototype */ {
	
	    /**
	     * Constructor
	     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
	     * @param {Object} [options] Options object
	     * @return {Object} thisArg
	     */
	    initialize: function(el, options) {
	      options || (options = { });
	
	      this._initStatic(el, options);
	    },
	
	    /**
	     * Background color of canvas instance.
	     * Should be set via {@link fabric.StaticCanvas#setBackgroundColor}.
	     * @type {(String|fabric.Pattern)}
	     * @default
	     */
	    backgroundColor: '',
	
	    /**
	     * Background image of canvas instance.
	     * Should be set via {@link fabric.StaticCanvas#setBackgroundImage}.
	     * <b>Backwards incompatibility note:</b> The "backgroundImageOpacity"
	     * and "backgroundImageStretch" properties are deprecated since 1.3.9.
	     * Use {@link fabric.Image#opacity}, {@link fabric.Image#width} and {@link fabric.Image#height}.
	     * @type fabric.Image
	     * @default
	     */
	    backgroundImage: null,
	
	    /**
	     * Overlay color of canvas instance.
	     * Should be set via {@link fabric.StaticCanvas#setOverlayColor}
	     * @since 1.3.9
	     * @type {(String|fabric.Pattern)}
	     * @default
	     */
	    overlayColor: '',
	
	    /**
	     * Overlay image of canvas instance.
	     * Should be set via {@link fabric.StaticCanvas#setOverlayImage}.
	     * <b>Backwards incompatibility note:</b> The "overlayImageLeft"
	     * and "overlayImageTop" properties are deprecated since 1.3.9.
	     * Use {@link fabric.Image#left} and {@link fabric.Image#top}.
	     * @type fabric.Image
	     * @default
	     */
	    overlayImage: null,
	
	    /**
	     * Indicates whether toObject/toDatalessObject should include default values
	     * @type Boolean
	     * @default
	     */
	    includeDefaultValues: true,
	
	    /**
	     * Indicates whether objects' state should be saved
	     * @type Boolean
	     * @default
	     */
	    stateful: false,
	
	    /**
	     * Indicates whether {@link fabric.Collection.add}, {@link fabric.Collection.insertAt} and {@link fabric.Collection.remove} should also re-render canvas.
	     * Disabling this option could give a great performance boost when adding/removing a lot of objects to/from canvas at once
	     * (followed by a manual rendering after addition/deletion)
	     * @type Boolean
	     * @default
	     */
	    renderOnAddRemove: true,
	
	    /**
	     * Function that determines clipping of entire canvas area
	     * Being passed context as first argument. See clipping canvas area in {@link https://github.com/kangax/fabric.js/wiki/FAQ}
	     * @type Function
	     * @default
	     */
	    clipTo: null,
	
	    /**
	     * Indicates whether object controls (borders/controls) are rendered above overlay image
	     * @type Boolean
	     * @default
	     */
	    controlsAboveOverlay: false,
	
	    /**
	     * Indicates whether the browser can be scrolled when using a touchscreen and dragging on the canvas
	     * @type Boolean
	     * @default
	     */
	    allowTouchScrolling: false,
	
	    /**
	     * Indicates whether this canvas will use image smoothing, this is on by default in browsers
	     * @type Boolean
	     * @default
	     */
	    imageSmoothingEnabled: true,
	
	    /**
	     * The transformation (in the format of Canvas transform) which focuses the viewport
	     * @type Array
	     * @default
	     */
	    viewportTransform: [1, 0, 0, 1, 0, 0],
	
	    /**
	     * if set to false background image is not affected by viewport transform
	     * @since 1.6.3
	     * @type Boolean
	     * @default
	     */
	    backgroundVpt: true,
	
	    /**
	     * if set to false overlya image is not affected by viewport transform
	     * @since 1.6.3
	     * @type Boolean
	     * @default
	     */
	    overlayVpt: true,
	
	    /**
	     * Callback; invoked right before object is about to be scaled/rotated
	     */
	    onBeforeScaleRotate: function () {
	      /* NOOP */
	    },
	
	    /**
	     * When true, canvas is scaled by devicePixelRatio for better rendering on retina screens
	     */
	    enableRetinaScaling: true,
	
	    /**
	     * @private
	     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
	     * @param {Object} [options] Options object
	     */
	    _initStatic: function(el, options) {
	      var cb = fabric.StaticCanvas.prototype.renderAll.bind(this);
	      this._objects = [];
	      this._createLowerCanvas(el);
	      this._initOptions(options);
	      this._setImageSmoothing();
	      // only initialize retina scaling once
	      if (!this.interactive) {
	        this._initRetinaScaling();
	      }
	
	      if (options.overlayImage) {
	        this.setOverlayImage(options.overlayImage, cb);
	      }
	      if (options.backgroundImage) {
	        this.setBackgroundImage(options.backgroundImage, cb);
	      }
	      if (options.backgroundColor) {
	        this.setBackgroundColor(options.backgroundColor, cb);
	      }
	      if (options.overlayColor) {
	        this.setOverlayColor(options.overlayColor, cb);
	      }
	      this.calcOffset();
	    },
	
	    /**
	     * @private
	     */
	    _isRetinaScaling: function() {
	      return (fabric.devicePixelRatio !== 1 && this.enableRetinaScaling);
	    },
	
	    /**
	     * @private
	     * @return {Number} retinaScaling if applied, otherwise 1;
	     */
	    getRetinaScaling: function() {
	      return this._isRetinaScaling() ? fabric.devicePixelRatio : 1;
	    },
	
	    /**
	     * @private
	     */
	    _initRetinaScaling: function() {
	      if (!this._isRetinaScaling()) {
	        return;
	      }
	      this.lowerCanvasEl.setAttribute('width', this.width * fabric.devicePixelRatio);
	      this.lowerCanvasEl.setAttribute('height', this.height * fabric.devicePixelRatio);
	
	      this.contextContainer.scale(fabric.devicePixelRatio, fabric.devicePixelRatio);
	    },
	
	    /**
	     * Calculates canvas element offset relative to the document
	     * This method is also attached as "resize" event handler of window
	     * @return {fabric.Canvas} instance
	     * @chainable
	     */
	    calcOffset: function () {
	      this._offset = getElementOffset(this.lowerCanvasEl);
	      return this;
	    },
	
	    /**
	     * Sets {@link fabric.StaticCanvas#overlayImage|overlay image} for this canvas
	     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set overlay to
	     * @param {Function} callback callback to invoke when image is loaded and set as an overlay
	     * @param {Object} [options] Optional options to set for the {@link fabric.Image|overlay image}.
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     * @see {@link http://jsfiddle.net/fabricjs/MnzHT/|jsFiddle demo}
	     * @example <caption>Normal overlayImage with left/top = 0</caption>
	     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
	     *   // Needed to position overlayImage at 0/0
	     *   originX: 'left',
	     *   originY: 'top'
	     * });
	     * @example <caption>overlayImage with different properties</caption>
	     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
	     *   opacity: 0.5,
	     *   angle: 45,
	     *   left: 400,
	     *   top: 400,
	     *   originX: 'left',
	     *   originY: 'top'
	     * });
	     * @example <caption>Stretched overlayImage #1 - width/height correspond to canvas width/height</caption>
	     * fabric.Image.fromURL('http://fabricjs.com/assets/jail_cell_bars.png', function(img) {
	     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
	     *    canvas.setOverlayImage(img, canvas.renderAll.bind(canvas));
	     * });
	     * @example <caption>Stretched overlayImage #2 - width/height correspond to canvas width/height</caption>
	     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
	     *   width: canvas.width,
	     *   height: canvas.height,
	     *   // Needed to position overlayImage at 0/0
	     *   originX: 'left',
	     *   originY: 'top'
	     * });
	     * @example <caption>overlayImage loaded from cross-origin</caption>
	     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
	     *   opacity: 0.5,
	     *   angle: 45,
	     *   left: 400,
	     *   top: 400,
	     *   originX: 'left',
	     *   originY: 'top',
	     *   crossOrigin: 'anonymous'
	     * });
	     */
	    setOverlayImage: function (image, callback, options) {
	      return this.__setBgOverlayImage('overlayImage', image, callback, options);
	    },
	
	    /**
	     * Sets {@link fabric.StaticCanvas#backgroundImage|background image} for this canvas
	     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set background to
	     * @param {Function} callback Callback to invoke when image is loaded and set as background
	     * @param {Object} [options] Optional options to set for the {@link fabric.Image|background image}.
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     * @see {@link http://jsfiddle.net/fabricjs/YH9yD/|jsFiddle demo}
	     * @example <caption>Normal backgroundImage with left/top = 0</caption>
	     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
	     *   // Needed to position backgroundImage at 0/0
	     *   originX: 'left',
	     *   originY: 'top'
	     * });
	     * @example <caption>backgroundImage with different properties</caption>
	     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
	     *   opacity: 0.5,
	     *   angle: 45,
	     *   left: 400,
	     *   top: 400,
	     *   originX: 'left',
	     *   originY: 'top'
	     * });
	     * @example <caption>Stretched backgroundImage #1 - width/height correspond to canvas width/height</caption>
	     * fabric.Image.fromURL('http://fabricjs.com/assets/honey_im_subtle.png', function(img) {
	     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
	     *    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
	     * });
	     * @example <caption>Stretched backgroundImage #2 - width/height correspond to canvas width/height</caption>
	     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
	     *   width: canvas.width,
	     *   height: canvas.height,
	     *   // Needed to position backgroundImage at 0/0
	     *   originX: 'left',
	     *   originY: 'top'
	     * });
	     * @example <caption>backgroundImage loaded from cross-origin</caption>
	     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
	     *   opacity: 0.5,
	     *   angle: 45,
	     *   left: 400,
	     *   top: 400,
	     *   originX: 'left',
	     *   originY: 'top',
	     *   crossOrigin: 'anonymous'
	     * });
	     */
	    setBackgroundImage: function (image, callback, options) {
	      return this.__setBgOverlayImage('backgroundImage', image, callback, options);
	    },
	
	    /**
	     * Sets {@link fabric.StaticCanvas#overlayColor|background color} for this canvas
	     * @param {(String|fabric.Pattern)} overlayColor Color or pattern to set background color to
	     * @param {Function} callback Callback to invoke when background color is set
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     * @see {@link http://jsfiddle.net/fabricjs/pB55h/|jsFiddle demo}
	     * @example <caption>Normal overlayColor - color value</caption>
	     * canvas.setOverlayColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
	     * @example <caption>fabric.Pattern used as overlayColor</caption>
	     * canvas.setOverlayColor({
	     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
	     * }, canvas.renderAll.bind(canvas));
	     * @example <caption>fabric.Pattern used as overlayColor with repeat and offset</caption>
	     * canvas.setOverlayColor({
	     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
	     *   repeat: 'repeat',
	     *   offsetX: 200,
	     *   offsetY: 100
	     * }, canvas.renderAll.bind(canvas));
	     */
	    setOverlayColor: function(overlayColor, callback) {
	      return this.__setBgOverlayColor('overlayColor', overlayColor, callback);
	    },
	
	    /**
	     * Sets {@link fabric.StaticCanvas#backgroundColor|background color} for this canvas
	     * @param {(String|fabric.Pattern)} backgroundColor Color or pattern to set background color to
	     * @param {Function} callback Callback to invoke when background color is set
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     * @see {@link http://jsfiddle.net/fabricjs/hXzvk/|jsFiddle demo}
	     * @example <caption>Normal backgroundColor - color value</caption>
	     * canvas.setBackgroundColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
	     * @example <caption>fabric.Pattern used as backgroundColor</caption>
	     * canvas.setBackgroundColor({
	     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
	     * }, canvas.renderAll.bind(canvas));
	     * @example <caption>fabric.Pattern used as backgroundColor with repeat and offset</caption>
	     * canvas.setBackgroundColor({
	     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
	     *   repeat: 'repeat',
	     *   offsetX: 200,
	     *   offsetY: 100
	     * }, canvas.renderAll.bind(canvas));
	     */
	    setBackgroundColor: function(backgroundColor, callback) {
	      return this.__setBgOverlayColor('backgroundColor', backgroundColor, callback);
	    },
	
	    /**
	     * @private
	     * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-imagesmoothingenabled|WhatWG Canvas Standard}
	     */
	    _setImageSmoothing: function() {
	      var ctx = this.getContext();
	
	      ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled || ctx.webkitImageSmoothingEnabled
	        || ctx.mozImageSmoothingEnabled || ctx.msImageSmoothingEnabled || ctx.oImageSmoothingEnabled;
	      ctx.imageSmoothingEnabled = this.imageSmoothingEnabled;
	    },
	
	    /**
	     * @private
	     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundImage|backgroundImage}
	     * or {@link fabric.StaticCanvas#overlayImage|overlayImage})
	     * @param {(fabric.Image|String|null)} image fabric.Image instance, URL of an image or null to set background or overlay to
	     * @param {Function} callback Callback to invoke when image is loaded and set as background or overlay
	     * @param {Object} [options] Optional options to set for the {@link fabric.Image|image}.
	     */
	    __setBgOverlayImage: function(property, image, callback, options) {
	      if (typeof image === 'string') {
	        fabric.util.loadImage(image, function(img) {
	          img && (this[property] = new fabric.Image(img, options));
	          callback && callback(img);
	        }, this, options && options.crossOrigin);
	      }
	      else {
	        options && image.setOptions(options);
	        this[property] = image;
	        callback && callback(image);
	      }
	
	      return this;
	    },
	
	    /**
	     * @private
	     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundColor|backgroundColor}
	     * or {@link fabric.StaticCanvas#overlayColor|overlayColor})
	     * @param {(Object|String|null)} color Object with pattern information, color value or null
	     * @param {Function} [callback] Callback is invoked when color is set
	     */
	    __setBgOverlayColor: function(property, color, callback) {
	      this[property] = color;
	      this._initGradient(color, property);
	      this._initPattern(color, property, callback);
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _createCanvasElement: function(canvasEl) {
	      var element = fabric.util.createCanvasElement(canvasEl);
	      if (!element.style) {
	        element.style = { };
	      }
	      if (!element) {
	        throw CANVAS_INIT_ERROR;
	      }
	      if (typeof element.getContext === 'undefined') {
	        throw CANVAS_INIT_ERROR;
	      }
	      return element;
	    },
	
	    /**
	     * @private
	     * @param {Object} [options] Options object
	     */
	    _initOptions: function (options) {
	      this._setOptions(options);
	
	      this.width = this.width || parseInt(this.lowerCanvasEl.width, 10) || 0;
	      this.height = this.height || parseInt(this.lowerCanvasEl.height, 10) || 0;
	
	      if (!this.lowerCanvasEl.style) {
	        return;
	      }
	
	      this.lowerCanvasEl.width = this.width;
	      this.lowerCanvasEl.height = this.height;
	
	      this.lowerCanvasEl.style.width = this.width + 'px';
	      this.lowerCanvasEl.style.height = this.height + 'px';
	
	      this.viewportTransform = this.viewportTransform.slice();
	    },
	
	    /**
	     * Creates a bottom canvas
	     * @private
	     * @param {HTMLElement} [canvasEl]
	     */
	    _createLowerCanvas: function (canvasEl) {
	      this.lowerCanvasEl = fabric.util.getById(canvasEl) || this._createCanvasElement(canvasEl);
	
	      fabric.util.addClass(this.lowerCanvasEl, 'lower-canvas');
	
	      if (this.interactive) {
	        this._applyCanvasStyle(this.lowerCanvasEl);
	      }
	
	      this.contextContainer = this.lowerCanvasEl.getContext('2d');
	    },
	
	    /**
	     * Returns canvas width (in px)
	     * @return {Number}
	     */
	    getWidth: function () {
	      return this.width;
	    },
	
	    /**
	     * Returns canvas height (in px)
	     * @return {Number}
	     */
	    getHeight: function () {
	      return this.height;
	    },
	
	    /**
	     * Sets width of this canvas instance
	     * @param {Number|String} value                         Value to set width to
	     * @param {Object}        [options]                     Options object
	     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
	     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    setWidth: function (value, options) {
	      return this.setDimensions({ width: value }, options);
	    },
	
	    /**
	     * Sets height of this canvas instance
	     * @param {Number|String} value                         Value to set height to
	     * @param {Object}        [options]                     Options object
	     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
	     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    setHeight: function (value, options) {
	      return this.setDimensions({ height: value }, options);
	    },
	
	    /**
	     * Sets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)
	     * @param {Object}        dimensions                    Object with width/height properties
	     * @param {Number|String} [dimensions.width]            Width of canvas element
	     * @param {Number|String} [dimensions.height]           Height of canvas element
	     * @param {Object}        [options]                     Options object
	     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
	     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    setDimensions: function (dimensions, options) {
	      var cssValue;
	
	      options = options || {};
	
	      for (var prop in dimensions) {
	        cssValue = dimensions[prop];
	
	        if (!options.cssOnly) {
	          this._setBackstoreDimension(prop, dimensions[prop]);
	          cssValue += 'px';
	        }
	
	        if (!options.backstoreOnly) {
	          this._setCssDimension(prop, cssValue);
	        }
	      }
	      this._initRetinaScaling();
	      this._setImageSmoothing();
	      this.calcOffset();
	
	      if (!options.cssOnly) {
	        this.renderAll();
	      }
	
	      return this;
	    },
	
	    /**
	     * Helper for setting width/height
	     * @private
	     * @param {String} prop property (width|height)
	     * @param {Number} value value to set property to
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    _setBackstoreDimension: function (prop, value) {
	      this.lowerCanvasEl[prop] = value;
	
	      if (this.upperCanvasEl) {
	        this.upperCanvasEl[prop] = value;
	      }
	
	      if (this.cacheCanvasEl) {
	        this.cacheCanvasEl[prop] = value;
	      }
	
	      this[prop] = value;
	
	      return this;
	    },
	
	    /**
	     * Helper for setting css width/height
	     * @private
	     * @param {String} prop property (width|height)
	     * @param {String} value value to set property to
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    _setCssDimension: function (prop, value) {
	      this.lowerCanvasEl.style[prop] = value;
	
	      if (this.upperCanvasEl) {
	        this.upperCanvasEl.style[prop] = value;
	      }
	
	      if (this.wrapperEl) {
	        this.wrapperEl.style[prop] = value;
	      }
	
	      return this;
	    },
	
	    /**
	     * Returns canvas zoom level
	     * @return {Number}
	     */
	    getZoom: function () {
	      return this.viewportTransform[0];
	    },
	
	    /**
	     * Sets viewport transform of this canvas instance
	     * @param {Array} vpt the transform in the form of context.transform
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    setViewportTransform: function (vpt) {
	      var activeGroup = this._activeGroup, object, ingoreVpt = false, skipAbsolute = true;
	      this.viewportTransform = vpt;
	      for (var i = 0, len = this._objects.length; i < len; i++) {
	        object = this._objects[i];
	        object.group || object.setCoords(ingoreVpt, skipAbsolute);
	      }
	      if (activeGroup) {
	        activeGroup.setCoords(ingoreVpt, skipAbsolute);
	      }
	      this.renderAll();
	      return this;
	    },
	
	    /**
	     * Sets zoom level of this canvas instance, zoom centered around point
	     * @param {fabric.Point} point to zoom with respect to
	     * @param {Number} value to set zoom to, less than 1 zooms out
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    zoomToPoint: function (point, value) {
	      // TODO: just change the scale, preserve other transformations
	      var before = point, vpt = this.viewportTransform.slice(0);
	      point = fabric.util.transformPoint(point, fabric.util.invertTransform(this.viewportTransform));
	      vpt[0] = value;
	      vpt[3] = value;
	      var after = fabric.util.transformPoint(point, vpt);
	      vpt[4] += before.x - after.x;
	      vpt[5] += before.y - after.y;
	      return this.setViewportTransform(vpt);
	    },
	
	    /**
	     * Sets zoom level of this canvas instance
	     * @param {Number} value to set zoom to, less than 1 zooms out
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    setZoom: function (value) {
	      this.zoomToPoint(new fabric.Point(0, 0), value);
	      return this;
	    },
	
	    /**
	     * Pan viewport so as to place point at top left corner of canvas
	     * @param {fabric.Point} point to move to
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    absolutePan: function (point) {
	      var vpt = this.viewportTransform.slice(0);
	      vpt[4] = -point.x;
	      vpt[5] = -point.y;
	      return this.setViewportTransform(vpt);
	    },
	
	    /**
	     * Pans viewpoint relatively
	     * @param {fabric.Point} point (position vector) to move by
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    relativePan: function (point) {
	      return this.absolutePan(new fabric.Point(
	        -point.x - this.viewportTransform[4],
	        -point.y - this.viewportTransform[5]
	      ));
	    },
	
	    /**
	     * Returns &lt;canvas> element corresponding to this instance
	     * @return {HTMLCanvasElement}
	     */
	    getElement: function () {
	      return this.lowerCanvasEl;
	    },
	
	    /**
	     * @private
	     * @param {fabric.Object} obj Object that was added
	     */
	    _onObjectAdded: function(obj) {
	      this.stateful && obj.setupState();
	      obj._set('canvas', this);
	      obj.setCoords();
	      this.fire('object:added', { target: obj });
	      obj.fire('added');
	    },
	
	    /**
	     * @private
	     * @param {fabric.Object} obj Object that was removed
	     */
	    _onObjectRemoved: function(obj) {
	      this.fire('object:removed', { target: obj });
	      obj.fire('removed');
	      delete obj.canvas;
	    },
	
	    /**
	     * Clears specified context of canvas element
	     * @param {CanvasRenderingContext2D} ctx Context to clear
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    clearContext: function(ctx) {
	      ctx.clearRect(0, 0, this.width, this.height);
	      return this;
	    },
	
	    /**
	     * Returns context of canvas where objects are drawn
	     * @return {CanvasRenderingContext2D}
	     */
	    getContext: function () {
	      return this.contextContainer;
	    },
	
	    /**
	     * Clears all contexts (background, main, top) of an instance
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    clear: function () {
	      this._objects.length = 0;
	      this.backgroundImage = null;
	      this.overlayImage = null;
	      this.backgroundColor = '';
	      this.overlayColor = '';
	      if (this._hasITextHandlers) {
	        this.off('selection:cleared', this._canvasITextSelectionClearedHanlder);
	        this.off('object:selected', this._canvasITextSelectionClearedHanlder);
	        this.off('mouse:up', this._mouseUpITextHandler);
	        this._iTextInstances = null;
	        this._hasITextHandlers = false;
	      }
	      this.clearContext(this.contextContainer);
	      this.fire('canvas:cleared');
	      this.renderAll();
	      return this;
	    },
	
	    /**
	     * Renders both the canvas.
	     * @return {fabric.Canvas} instance
	     * @chainable
	     */
	    renderAll: function () {
	      var canvasToDrawOn = this.contextContainer;
	      this.renderCanvas(canvasToDrawOn, this._objects);
	      return this;
	    },
	
	    /**
	     * Renders background, objects, overlay and controls.
	     * @param {CanvasRenderingContext2D} ctx
	     * @param {Array} objects to render
	     * @return {fabric.Canvas} instance
	     * @chainable
	     */
	    renderCanvas: function(ctx, objects) {
	      this.clearContext(ctx);
	      this.fire('before:render');
	      if (this.clipTo) {
	        fabric.util.clipContext(this, ctx);
	      }
	      this._renderBackground(ctx);
	
	      ctx.save();
	      //apply viewport transform once for all rendering process
	      ctx.transform.apply(ctx, this.viewportTransform);
	      this._renderObjects(ctx, objects);
	      ctx.restore();
	      if (!this.controlsAboveOverlay && this.interactive) {
	        this.drawControls(ctx);
	      }
	      if (this.clipTo) {
	        ctx.restore();
	      }
	      this._renderOverlay(ctx);
	      if (this.controlsAboveOverlay && this.interactive) {
	        this.drawControls(ctx);
	      }
	      this.fire('after:render');
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Array} objects to render
	     */
	    _renderObjects: function(ctx, objects) {
	      for (var i = 0, length = objects.length; i < length; ++i) {
	        objects[i] && objects[i].render(ctx);
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {string} property 'background' or 'overlay'
	     */
	    _renderBackgroundOrOverlay: function(ctx, property) {
	      var object = this[property + 'Color'];
	      if (object) {
	        ctx.fillStyle = object.toLive
	          ? object.toLive(ctx, this)
	          : object;
	
	        ctx.fillRect(
	          object.offsetX || 0,
	          object.offsetY || 0,
	          this.width,
	          this.height);
	      }
	      object = this[property + 'Image'];
	      if (object) {
	        if (this[property + 'Vpt']) {
	          ctx.save();
	          ctx.transform.apply(ctx, this.viewportTransform);
	        }
	        object.render(ctx);
	        this[property + 'Vpt'] && ctx.restore();
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderBackground: function(ctx) {
	      this._renderBackgroundOrOverlay(ctx, 'background');
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderOverlay: function(ctx) {
	      this._renderBackgroundOrOverlay(ctx, 'overlay');
	    },
	
	    /**
	     * Returns coordinates of a center of canvas.
	     * Returned value is an object with top and left properties
	     * @return {Object} object with "top" and "left" number values
	     */
	    getCenter: function () {
	      return {
	        top: this.getHeight() / 2,
	        left: this.getWidth() / 2
	      };
	    },
	
	    /**
	     * Centers object horizontally in the canvas
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @param {fabric.Object} object Object to center horizontally
	     * @return {fabric.Canvas} thisArg
	     */
	    centerObjectH: function (object) {
	      return this._centerObject(object, new fabric.Point(this.getCenter().left, object.getCenterPoint().y));
	    },
	
	    /**
	     * Centers object vertically in the canvas
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @param {fabric.Object} object Object to center vertically
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    centerObjectV: function (object) {
	      return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, this.getCenter().top));
	    },
	
	    /**
	     * Centers object vertically and horizontally in the canvas
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @param {fabric.Object} object Object to center vertically and horizontally
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    centerObject: function(object) {
	      var center = this.getCenter();
	
	      return this._centerObject(object, new fabric.Point(center.left, center.top));
	    },
	
	    /**
	     * Centers object vertically and horizontally in the viewport
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @param {fabric.Object} object Object to center vertically and horizontally
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    viewportCenterObject: function(object) {
	      var vpCenter = this.getVpCenter();
	
	      return this._centerObject(object, vpCenter);
	    },
	
	    /**
	     * Centers object horizontally in the viewport, object.top is unchanged
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @param {fabric.Object} object Object to center vertically and horizontally
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    viewportCenterObjectH: function(object) {
	      var vpCenter = this.getVpCenter();
	      this._centerObject(object, new fabric.Point(vpCenter.x, object.getCenterPoint().y));
	      return this;
	    },
	
	    /**
	     * Centers object Vertically in the viewport, object.top is unchanged
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @param {fabric.Object} object Object to center vertically and horizontally
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    viewportCenterObjectV: function(object) {
	      var vpCenter = this.getVpCenter();
	
	      return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, vpCenter.y));
	    },
	
	    /**
	     * Calculate the point in canvas that correspond to the center of actual viewport.
	     * @return {fabric.Point} vpCenter, viewport center
	     * @chainable
	     */
	    getVpCenter: function() {
	      var center = this.getCenter(),
	          iVpt = fabric.util.invertTransform(this.viewportTransform);
	      return fabric.util.transformPoint({ x: center.left, y: center.top }, iVpt);
	    },
	
	    /**
	     * @private
	     * @param {fabric.Object} object Object to center
	     * @param {fabric.Point} center Center point
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    _centerObject: function(object, center) {
	      object.setPositionByOrigin(center, 'center', 'center');
	      this.renderAll();
	      return this;
	    },
	
	    /**
	     * Returs dataless JSON representation of canvas
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {String} json string
	     */
	    toDatalessJSON: function (propertiesToInclude) {
	      return this.toDatalessObject(propertiesToInclude);
	    },
	
	    /**
	     * Returns object representation of canvas
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function (propertiesToInclude) {
	      return this._toObjectMethod('toObject', propertiesToInclude);
	    },
	
	    /**
	     * Returns dataless object representation of canvas
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toDatalessObject: function (propertiesToInclude) {
	      return this._toObjectMethod('toDatalessObject', propertiesToInclude);
	    },
	
	    /**
	     * @private
	     */
	    _toObjectMethod: function (methodName, propertiesToInclude) {
	
	      var data = {
	        objects: this._toObjects(methodName, propertiesToInclude)
	      };
	
	      extend(data, this.__serializeBgOverlay(methodName, propertiesToInclude));
	
	      fabric.util.populateWithProperties(this, data, propertiesToInclude);
	
	      return data;
	    },
	
	    /**
	     * @private
	     */
	    _toObjects: function(methodName, propertiesToInclude) {
	      return this.getObjects().filter(function(object) {
	        return !object.excludeFromExport;
	      }).map(function(instance) {
	        return this._toObject(instance, methodName, propertiesToInclude);
	      }, this);
	    },
	
	    /**
	     * @private
	     */
	    _toObject: function(instance, methodName, propertiesToInclude) {
	      var originalValue;
	
	      if (!this.includeDefaultValues) {
	        originalValue = instance.includeDefaultValues;
	        instance.includeDefaultValues = false;
	      }
	
	      var object = instance[methodName](propertiesToInclude);
	      if (!this.includeDefaultValues) {
	        instance.includeDefaultValues = originalValue;
	      }
	      return object;
	    },
	
	    /**
	     * @private
	     */
	    __serializeBgOverlay: function(methodName, propertiesToInclude) {
	      var data = { };
	
	      if (this.backgroundColor) {
	        data.background = this.backgroundColor.toObject
	          ? this.backgroundColor.toObject(propertiesToInclude)
	          : this.backgroundColor;
	      }
	
	      if (this.overlayColor) {
	        data.overlay = this.overlayColor.toObject
	          ? this.overlayColor.toObject(propertiesToInclude)
	          : this.overlayColor;
	      }
	      if (this.backgroundImage) {
	        data.backgroundImage = this._toObject(this.backgroundImage, methodName, propertiesToInclude);
	      }
	      if (this.overlayImage) {
	        data.overlayImage = this._toObject(this.overlayImage, methodName, propertiesToInclude);
	      }
	
	      return data;
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * When true, getSvgTransform() will apply the StaticCanvas.viewportTransform to the SVG transformation. When true,
	     * a zoomed canvas will then produce zoomed SVG output.
	     * @type Boolean
	     * @default
	     */
	    svgViewportTransformation: true,
	
	    /**
	     * Returns SVG representation of canvas
	     * @function
	     * @param {Object} [options] Options object for SVG output
	     * @param {Boolean} [options.suppressPreamble=false] If true xml tag is not included
	     * @param {Object} [options.viewBox] SVG viewbox object
	     * @param {Number} [options.viewBox.x] x-cooridnate of viewbox
	     * @param {Number} [options.viewBox.y] y-coordinate of viewbox
	     * @param {Number} [options.viewBox.width] Width of viewbox
	     * @param {Number} [options.viewBox.height] Height of viewbox
	     * @param {String} [options.encoding=UTF-8] Encoding of SVG output
	     * @param {String} [options.width] desired width of svg with or without units
	     * @param {String} [options.height] desired height of svg with or without units
	     * @param {Function} [reviver] Method for further parsing of svg elements, called after each fabric object converted into svg representation.
	     * @return {String} SVG string
	     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}
	     * @see {@link http://jsfiddle.net/fabricjs/jQ3ZZ/|jsFiddle demo}
	     * @example <caption>Normal SVG output</caption>
	     * var svg = canvas.toSVG();
	     * @example <caption>SVG output without preamble (without &lt;?xml ../>)</caption>
	     * var svg = canvas.toSVG({suppressPreamble: true});
	     * @example <caption>SVG output with viewBox attribute</caption>
	     * var svg = canvas.toSVG({
	     *   viewBox: {
	     *     x: 100,
	     *     y: 100,
	     *     width: 200,
	     *     height: 300
	     *   }
	     * });
	     * @example <caption>SVG output with different encoding (default: UTF-8)</caption>
	     * var svg = canvas.toSVG({encoding: 'ISO-8859-1'});
	     * @example <caption>Modify SVG output with reviver function</caption>
	     * var svg = canvas.toSVG(null, function(svg) {
	     *   return svg.replace('stroke-dasharray: ; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; ', '');
	     * });
	     */
	    toSVG: function(options, reviver) {
	      options || (options = { });
	
	      var markup = [];
	
	      this._setSVGPreamble(markup, options);
	      this._setSVGHeader(markup, options);
	
	      this._setSVGBgOverlayColor(markup, 'backgroundColor');
	      this._setSVGBgOverlayImage(markup, 'backgroundImage', reviver);
	
	      this._setSVGObjects(markup, reviver);
	
	      this._setSVGBgOverlayColor(markup, 'overlayColor');
	      this._setSVGBgOverlayImage(markup, 'overlayImage', reviver);
	
	      markup.push('</svg>');
	
	      return markup.join('');
	    },
	
	    /**
	     * @private
	     */
	    _setSVGPreamble: function(markup, options) {
	      if (options.suppressPreamble) {
	        return;
	      }
	      markup.push(
	        '<?xml version="1.0" encoding="', (options.encoding || 'UTF-8'), '" standalone="no" ?>\n',
	          '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ',
	            '"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n'
	      );
	    },
	
	    /**
	     * @private
	     */
	    _setSVGHeader: function(markup, options) {
	      var width = options.width || this.width,
	          height = options.height || this.height,
	          vpt, viewBox = 'viewBox="0 0 ' + this.width + ' ' + this.height + '" ',
	          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
	
	      if (options.viewBox) {
	        viewBox = 'viewBox="' +
	                options.viewBox.x + ' ' +
	                options.viewBox.y + ' ' +
	                options.viewBox.width + ' ' +
	                options.viewBox.height + '" ';
	      }
	      else {
	        if (this.svgViewportTransformation) {
	          vpt = this.viewportTransform;
	          viewBox = 'viewBox="' +
	                  toFixed(-vpt[4] / vpt[0], NUM_FRACTION_DIGITS) + ' ' +
	                  toFixed(-vpt[5] / vpt[3], NUM_FRACTION_DIGITS) + ' ' +
	                  toFixed(this.width / vpt[0], NUM_FRACTION_DIGITS) + ' ' +
	                  toFixed(this.height / vpt[3], NUM_FRACTION_DIGITS) + '" ';
	        }
	      }
	
	      markup.push(
	        '<svg ',
	          'xmlns="http://www.w3.org/2000/svg" ',
	          'xmlns:xlink="http://www.w3.org/1999/xlink" ',
	          'version="1.1" ',
	          'width="', width, '" ',
	          'height="', height, '" ',
	          viewBox,
	          'xml:space="preserve">\n',
	        '<desc>Created with Fabric.js ', fabric.version, '</desc>\n',
	        '<defs>\n',
	          this.createSVGFontFacesMarkup(),
	          this.createSVGRefElementsMarkup(),
	        '</defs>\n'
	      );
	    },
	
	    /**
	     * Creates markup containing SVG referenced elements like patterns, gradients etc.
	     * @return {String}
	     */
	    createSVGRefElementsMarkup: function() {
	      var _this = this,
	          markup = ['backgroundColor', 'overlayColor'].map(function(prop) {
	            var fill = _this[prop];
	            if (fill && fill.toLive) {
	              return fill.toSVG(_this, false);
	            }
	          });
	      return markup.join('');
	    },
	
	    /**
	     * Creates markup containing SVG font faces,
	     * font URLs for font faces must be collected by developers
	     * and are not extracted from the DOM by fabricjs
	     * @param {Array} objects Array of fabric objects
	     * @return {String}
	     */
	    createSVGFontFacesMarkup: function() {
	      var markup = '', fontList = { }, obj, fontFamily,
	          style, row, rowIndex, _char, charIndex,
	          fontPaths = fabric.fontPaths, objects = this.getObjects();
	
	      for (var i = 0, len = objects.length; i < len; i++) {
	        obj = objects[i];
	        fontFamily = obj.fontFamily;
	        if (obj.type.indexOf('text') === -1 || fontList[fontFamily] || !fontPaths[fontFamily]) {
	          continue;
	        }
	        fontList[fontFamily] = true;
	        if (!obj.styles) {
	          continue;
	        }
	        style = obj.styles;
	        for (rowIndex in style) {
	          row = style[rowIndex];
	          for (charIndex in row) {
	            _char = row[charIndex];
	            fontFamily = _char.fontFamily;
	            if (!fontList[fontFamily] && fontPaths[fontFamily]) {
	              fontList[fontFamily] = true;
	            }
	          }
	        }
	      }
	
	      for (var j in fontList) {
	        markup += [
	          '\t\t@font-face {\n',
	          '\t\t\tfont-family: \'', j, '\';\n',
	          '\t\t\tsrc: url(\'', fontPaths[j], '\');\n',
	          '\t\t}\n'
	        ].join('');
	      }
	
	      if (markup) {
	        markup = [
	          '\t<style type="text/css">',
	          '<![CDATA[\n',
	          markup,
	          ']]>',
	          '</style>\n'
	        ].join('');
	      }
	
	      return markup;
	    },
	
	    /**
	     * @private
	     */
	    _setSVGObjects: function(markup, reviver) {
	      var instance;
	      for (var i = 0, objects = this.getObjects(), len = objects.length; i < len; i++) {
	        instance = objects[i];
	        if (instance.excludeFromExport) {
	          continue;
	        }
	        this._setSVGObject(markup, instance, reviver);
	      }
	    },
	
	    /**
	     * push single object svg representation in the markup
	     * @private
	     */
	    _setSVGObject: function(markup, instance, reviver) {
	      markup.push(instance.toSVG(reviver));
	    },
	
	    /**
	     * @private
	     */
	    _setSVGBgOverlayImage: function(markup, property, reviver) {
	      if (this[property] && this[property].toSVG) {
	        markup.push(this[property].toSVG(reviver));
	      }
	    },
	
	    /**
	     * @private
	     */
	    _setSVGBgOverlayColor: function(markup, property) {
	      var filler = this[property];
	      if (!filler) {
	        return;
	      }
	      if (filler.toLive) {
	        var repeat = filler.repeat;
	        markup.push(
	          '<rect transform="translate(', this.width / 2, ',', this.height / 2, ')"',
	            ' x="', filler.offsetX - this.width / 2, '" y="', filler.offsetY - this.height / 2, '" ',
	            'width="',
	              (repeat === 'repeat-y' || repeat === 'no-repeat'
	                ? filler.source.width
	                : this.width),
	            '" height="',
	              (repeat === 'repeat-x' || repeat === 'no-repeat'
	                ? filler.source.height
	                : this.height),
	            '" fill="url(#SVGID_' + filler.id + ')"',
	          '></rect>\n'
	        );
	      }
	      else {
	        markup.push(
	          '<rect x="0" y="0" ',
	            'width="', this.width,
	            '" height="', this.height,
	            '" fill="', this[property], '"',
	          '></rect>\n'
	        );
	      }
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Moves an object or the objects of a multiple selection
	     * to the bottom of the stack of drawn objects
	     * @param {fabric.Object} object Object to send to back
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    sendToBack: function (object) {
	      if (!object) {
	        return this;
	      }
	      var activeGroup = this._activeGroup,
	          i, obj, objs;
	      if (object === activeGroup) {
	        objs = activeGroup._objects;
	        for (i = objs.length; i--;) {
	          obj = objs[i];
	          removeFromArray(this._objects, obj);
	          this._objects.unshift(obj);
	        }
	      }
	      else {
	        removeFromArray(this._objects, object);
	        this._objects.unshift(object);
	      }
	      return this.renderAll && this.renderAll();
	    },
	
	    /**
	     * Moves an object or the objects of a multiple selection
	     * to the top of the stack of drawn objects
	     * @param {fabric.Object} object Object to send
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    bringToFront: function (object) {
	      if (!object) {
	        return this;
	      }
	      var activeGroup = this._activeGroup,
	          i, obj, objs;
	      if (object === activeGroup) {
	        objs = activeGroup._objects;
	        for (i = 0; i < objs.length; i++) {
	          obj = objs[i];
	          removeFromArray(this._objects, obj);
	          this._objects.push(obj);
	        }
	      }
	      else {
	        removeFromArray(this._objects, object);
	        this._objects.push(object);
	      }
	      return this.renderAll && this.renderAll();
	    },
	
	    /**
	     * Moves an object or a selection down in stack of drawn objects
	     * @param {fabric.Object} object Object to send
	     * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    sendBackwards: function (object, intersecting) {
	      if (!object) {
	        return this;
	      }
	      var activeGroup = this._activeGroup,
	          i, obj, idx, newIdx, objs;
	
	      if (object === activeGroup) {
	        objs = activeGroup._objects;
	        for (i = 0; i < objs.length; i++) {
	          obj = objs[i];
	          idx = this._objects.indexOf(obj);
	          if (idx !== 0) {
	            newIdx = idx - 1;
	            removeFromArray(this._objects, obj);
	            this._objects.splice(newIdx, 0, obj);
	          }
	        }
	      }
	      else {
	        idx = this._objects.indexOf(object);
	        if (idx !== 0) {
	          // if object is not on the bottom of stack
	          newIdx = this._findNewLowerIndex(object, idx, intersecting);
	          removeFromArray(this._objects, object);
	          this._objects.splice(newIdx, 0, object);
	        }
	      }
	      this.renderAll && this.renderAll();
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _findNewLowerIndex: function(object, idx, intersecting) {
	      var newIdx;
	
	      if (intersecting) {
	        newIdx = idx;
	
	        // traverse down the stack looking for the nearest intersecting object
	        for (var i = idx - 1; i >= 0; --i) {
	
	          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||
	                               object.isContainedWithinObject(this._objects[i]) ||
	                               this._objects[i].isContainedWithinObject(object);
	
	          if (isIntersecting) {
	            newIdx = i;
	            break;
	          }
	        }
	      }
	      else {
	        newIdx = idx - 1;
	      }
	
	      return newIdx;
	    },
	
	    /**
	     * Moves an object or a selection up in stack of drawn objects
	     * @param {fabric.Object} object Object to send
	     * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    bringForward: function (object, intersecting) {
	      if (!object) {
	        return this;
	      }
	      var activeGroup = this._activeGroup,
	          i, obj, idx, newIdx, objs;
	
	      if (object === activeGroup) {
	        objs = activeGroup._objects;
	        for (i = objs.length; i--;) {
	          obj = objs[i];
	          idx = this._objects.indexOf(obj);
	          if (idx !== this._objects.length - 1) {
	            newIdx = idx + 1;
	            removeFromArray(this._objects, obj);
	            this._objects.splice(newIdx, 0, obj);
	          }
	        }
	      }
	      else {
	        idx = this._objects.indexOf(object);
	        if (idx !== this._objects.length - 1) {
	          // if object is not on top of stack (last item in an array)
	          newIdx = this._findNewUpperIndex(object, idx, intersecting);
	          removeFromArray(this._objects, object);
	          this._objects.splice(newIdx, 0, object);
	        }
	      }
	      this.renderAll && this.renderAll();
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _findNewUpperIndex: function(object, idx, intersecting) {
	      var newIdx;
	
	      if (intersecting) {
	        newIdx = idx;
	
	        // traverse up the stack looking for the nearest intersecting object
	        for (var i = idx + 1; i < this._objects.length; ++i) {
	
	          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||
	                               object.isContainedWithinObject(this._objects[i]) ||
	                               this._objects[i].isContainedWithinObject(object);
	
	          if (isIntersecting) {
	            newIdx = i;
	            break;
	          }
	        }
	      }
	      else {
	        newIdx = idx + 1;
	      }
	
	      return newIdx;
	    },
	
	    /**
	     * Moves an object to specified level in stack of drawn objects
	     * @param {fabric.Object} object Object to send
	     * @param {Number} index Position to move to
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    moveTo: function (object, index) {
	      removeFromArray(this._objects, object);
	      this._objects.splice(index, 0, object);
	      return this.renderAll && this.renderAll();
	    },
	
	    /**
	     * Clears a canvas element and removes all event listeners
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    dispose: function () {
	      this.clear();
	      return this;
	    },
	
	    /**
	     * Returns a string representation of an instance
	     * @return {String} string representation of an instance
	     */
	    toString: function () {
	      return '#<fabric.Canvas (' + this.complexity() + '): ' +
	               '{ objects: ' + this.getObjects().length + ' }>';
	    }
	  });
	
	  extend(fabric.StaticCanvas.prototype, fabric.Observable);
	  extend(fabric.StaticCanvas.prototype, fabric.Collection);
	  extend(fabric.StaticCanvas.prototype, fabric.DataURLExporter);
	
	  extend(fabric.StaticCanvas, /** @lends fabric.StaticCanvas */ {
	
	    /**
	     * @static
	     * @type String
	     * @default
	     */
	    EMPTY_JSON: '{"objects": [], "background": "white"}',
	
	    /**
	     * Provides a way to check support of some of the canvas methods
	     * (either those of HTMLCanvasElement itself, or rendering context)
	     *
	     * @param {String} methodName Method to check support for;
	     *                            Could be one of "getImageData", "toDataURL", "toDataURLWithQuality" or "setLineDash"
	     * @return {Boolean | null} `true` if method is supported (or at least exists),
	     *                          `null` if canvas element or context can not be initialized
	     */
	    supports: function (methodName) {
	      var el = fabric.util.createCanvasElement();
	
	      if (!el || !el.getContext) {
	        return null;
	      }
	
	      var ctx = el.getContext('2d');
	      if (!ctx) {
	        return null;
	      }
	
	      switch (methodName) {
	
	        case 'getImageData':
	          return typeof ctx.getImageData !== 'undefined';
	
	        case 'setLineDash':
	          return typeof ctx.setLineDash !== 'undefined';
	
	        case 'toDataURL':
	          return typeof el.toDataURL !== 'undefined';
	
	        case 'toDataURLWithQuality':
	          try {
	            el.toDataURL('image/jpeg', 0);
	            return true;
	          }
	          catch (e) { }
	          return false;
	
	        default:
	          return null;
	      }
	    }
	  });
	
	  /**
	   * Returns JSON representation of canvas
	   * @function
	   * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	   * @return {String} JSON string
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}
	   * @see {@link http://jsfiddle.net/fabricjs/pec86/|jsFiddle demo}
	   * @example <caption>JSON without additional properties</caption>
	   * var json = canvas.toJSON();
	   * @example <caption>JSON with additional properties included</caption>
	   * var json = canvas.toJSON(['lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY', 'lockUniScaling']);
	   * @example <caption>JSON without default values</caption>
	   * canvas.includeDefaultValues = false;
	   * var json = canvas.toJSON();
	   */
	  fabric.StaticCanvas.prototype.toJSON = fabric.StaticCanvas.prototype.toObject;
	
	})();
	
	
	/**
	 * BaseBrush class
	 * @class fabric.BaseBrush
	 * @see {@link http://fabricjs.com/freedrawing|Freedrawing demo}
	 */
	fabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype */ {
	
	  /**
	   * Color of a brush
	   * @type String
	   * @default
	   */
	  color: 'rgb(0, 0, 0)',
	
	  /**
	   * Width of a brush
	   * @type Number
	   * @default
	   */
	  width: 1,
	
	  /**
	   * Shadow object representing shadow of this shape.
	   * <b>Backwards incompatibility note:</b> This property replaces "shadowColor" (String), "shadowOffsetX" (Number),
	   * "shadowOffsetY" (Number) and "shadowBlur" (Number) since v1.2.12
	   * @type fabric.Shadow
	   * @default
	   */
	  shadow: null,
	
	  /**
	   * Line endings style of a brush (one of "butt", "round", "square")
	   * @type String
	   * @default
	   */
	  strokeLineCap: 'round',
	
	  /**
	   * Corner style of a brush (one of "bevil", "round", "miter")
	   * @type String
	   * @default
	   */
	  strokeLineJoin: 'round',
	
	  /**
	   * Stroke Dash Array.
	   * @type Array
	   * @default
	   */
	  strokeDashArray: null,
	
	  /**
	   * Sets shadow of an object
	   * @param {Object|String} [options] Options object or string (e.g. "2px 2px 10px rgba(0,0,0,0.2)")
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  setShadow: function(options) {
	    this.shadow = new fabric.Shadow(options);
	    return this;
	  },
	
	  /**
	   * Sets brush styles
	   * @private
	   */
	  _setBrushStyles: function() {
	    var ctx = this.canvas.contextTop;
	
	    ctx.strokeStyle = this.color;
	    ctx.lineWidth = this.width;
	    ctx.lineCap = this.strokeLineCap;
	    ctx.lineJoin = this.strokeLineJoin;
	    if (this.strokeDashArray && fabric.StaticCanvas.supports('setLineDash')) {
	      ctx.setLineDash(this.strokeDashArray);
	    }
	  },
	
	  /**
	   * Sets brush shadow styles
	   * @private
	   */
	  _setShadow: function() {
	    if (!this.shadow) {
	      return;
	    }
	
	    var ctx = this.canvas.contextTop,
	        zoom = this.canvas.getZoom();
	
	    ctx.shadowColor = this.shadow.color;
	    ctx.shadowBlur = this.shadow.blur * zoom;
	    ctx.shadowOffsetX = this.shadow.offsetX * zoom;
	    ctx.shadowOffsetY = this.shadow.offsetY * zoom;
	  },
	
	  /**
	   * Removes brush shadow styles
	   * @private
	   */
	  _resetShadow: function() {
	    var ctx = this.canvas.contextTop;
	
	    ctx.shadowColor = '';
	    ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
	  }
	});
	
	
	(function() {
	
	  /**
	   * PencilBrush class
	   * @class fabric.PencilBrush
	   * @extends fabric.BaseBrush
	   */
	  fabric.PencilBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.PencilBrush.prototype */ {
	
	    /**
	     * Constructor
	     * @param {fabric.Canvas} canvas
	     * @return {fabric.PencilBrush} Instance of a pencil brush
	     */
	    initialize: function(canvas) {
	      this.canvas = canvas;
	      this._points = [];
	    },
	
	    /**
	     * Inovoked on mouse down
	     * @param {Object} pointer
	     */
	    onMouseDown: function(pointer) {
	      this._prepareForDrawing(pointer);
	      // capture coordinates immediately
	      // this allows to draw dots (when movement never occurs)
	      this._captureDrawingPath(pointer);
	      this._render();
	    },
	
	    /**
	     * Inovoked on mouse move
	     * @param {Object} pointer
	     */
	    onMouseMove: function(pointer) {
	      this._captureDrawingPath(pointer);
	      // redraw curve
	      // clear top canvas
	      this.canvas.clearContext(this.canvas.contextTop);
	      this._render();
	    },
	
	    /**
	     * Invoked on mouse up
	     */
	    onMouseUp: function() {
	      this._finalizeAndAddPath();
	    },
	
	    /**
	     * @private
	     * @param {Object} pointer Actual mouse position related to the canvas.
	     */
	    _prepareForDrawing: function(pointer) {
	
	      var p = new fabric.Point(pointer.x, pointer.y);
	
	      this._reset();
	      this._addPoint(p);
	
	      this.canvas.contextTop.moveTo(p.x, p.y);
	    },
	
	    /**
	     * @private
	     * @param {fabric.Point} point Point to be added to points array
	     */
	    _addPoint: function(point) {
	      this._points.push(point);
	    },
	
	    /**
	     * Clear points array and set contextTop canvas style.
	     * @private
	     */
	    _reset: function() {
	      this._points.length = 0;
	
	      this._setBrushStyles();
	      this._setShadow();
	    },
	
	    /**
	     * @private
	     * @param {Object} pointer Actual mouse position related to the canvas.
	     */
	    _captureDrawingPath: function(pointer) {
	      var pointerPoint = new fabric.Point(pointer.x, pointer.y);
	      this._addPoint(pointerPoint);
	    },
	
	    /**
	     * Draw a smooth path on the topCanvas using quadraticCurveTo
	     * @private
	     */
	    _render: function() {
	      var ctx  = this.canvas.contextTop,
	          v = this.canvas.viewportTransform,
	          p1 = this._points[0],
	          p2 = this._points[1];
	
	      ctx.save();
	      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
	      ctx.beginPath();
	
	      //if we only have 2 points in the path and they are the same
	      //it means that the user only clicked the canvas without moving the mouse
	      //then we should be drawing a dot. A path isn't drawn between two identical dots
	      //that's why we set them apart a bit
	      if (this._points.length === 2 && p1.x === p2.x && p1.y === p2.y) {
	        p1.x -= 0.5;
	        p2.x += 0.5;
	      }
	      ctx.moveTo(p1.x, p1.y);
	
	      for (var i = 1, len = this._points.length; i < len; i++) {
	        // we pick the point between pi + 1 & pi + 2 as the
	        // end point and p1 as our control point.
	        var midPoint = p1.midPointFrom(p2);
	        ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);
	
	        p1 = this._points[i];
	        p2 = this._points[i + 1];
	      }
	      // Draw last line as a straight line while
	      // we wait for the next point to be able to calculate
	      // the bezier control point
	      ctx.lineTo(p1.x, p1.y);
	      ctx.stroke();
	      ctx.restore();
	    },
	
	    /**
	     * Converts points to SVG path
	     * @param {Array} points Array of points
	     * @return {String} SVG path
	     */
	    convertPointsToSVGPath: function(points) {
	      var path = [],
	          p1 = new fabric.Point(points[0].x, points[0].y),
	          p2 = new fabric.Point(points[1].x, points[1].y);
	
	      path.push('M ', points[0].x, ' ', points[0].y, ' ');
	      for (var i = 1, len = points.length; i < len; i++) {
	        var midPoint = p1.midPointFrom(p2);
	        // p1 is our bezier control point
	        // midpoint is our endpoint
	        // start point is p(i-1) value.
	        path.push('Q ', p1.x, ' ', p1.y, ' ', midPoint.x, ' ', midPoint.y, ' ');
	        p1 = new fabric.Point(points[i].x, points[i].y);
	        if ((i + 1) < points.length) {
	          p2 = new fabric.Point(points[i + 1].x, points[i + 1].y);
	        }
	      }
	      path.push('L ', p1.x, ' ', p1.y, ' ');
	      return path;
	    },
	
	    /**
	     * Creates fabric.Path object to add on canvas
	     * @param {String} pathData Path data
	     * @return {fabric.Path} Path to add on canvas
	     */
	    createPath: function(pathData) {
	      var path = new fabric.Path(pathData, {
	        fill: null,
	        stroke: this.color,
	        strokeWidth: this.width,
	        strokeLineCap: this.strokeLineCap,
	        strokeLineJoin: this.strokeLineJoin,
	        strokeDashArray: this.strokeDashArray,
	        originX: 'center',
	        originY: 'center'
	      });
	
	      if (this.shadow) {
	        this.shadow.affectStroke = true;
	        path.setShadow(this.shadow);
	      }
	
	      return path;
	    },
	
	    /**
	     * On mouseup after drawing the path on contextTop canvas
	     * we use the points captured to create an new fabric path object
	     * and add it to the fabric canvas.
	     */
	    _finalizeAndAddPath: function() {
	      var ctx = this.canvas.contextTop;
	      ctx.closePath();
	
	      var pathData = this.convertPointsToSVGPath(this._points).join('');
	      if (pathData === 'M 0 0 Q 0 0 0 0 L 0 0') {
	        // do not create 0 width/height paths, as they are
	        // rendered inconsistently across browsers
	        // Firefox 4, for example, renders a dot,
	        // whereas Chrome 10 renders nothing
	        this.canvas.renderAll();
	        return;
	      }
	
	      var path = this.createPath(pathData);
	
	      this.canvas.add(path);
	      path.setCoords();
	
	      this.canvas.clearContext(this.canvas.contextTop);
	      this._resetShadow();
	      this.canvas.renderAll();
	
	      // fire event 'path' created
	      this.canvas.fire('path:created', { path: path });
	    }
	  });
	})();
	
	
	/**
	 * CircleBrush class
	 * @class fabric.CircleBrush
	 */
	fabric.CircleBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.CircleBrush.prototype */ {
	
	  /**
	   * Width of a brush
	   * @type Number
	   * @default
	   */
	  width: 10,
	
	  /**
	   * Constructor
	   * @param {fabric.Canvas} canvas
	   * @return {fabric.CircleBrush} Instance of a circle brush
	   */
	  initialize: function(canvas) {
	    this.canvas = canvas;
	    this.points = [];
	  },
	
	  /**
	   * Invoked inside on mouse down and mouse move
	   * @param {Object} pointer
	   */
	  drawDot: function(pointer) {
	    var point = this.addPoint(pointer),
	        ctx = this.canvas.contextTop,
	        v = this.canvas.viewportTransform;
	    ctx.save();
	    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
	
	    ctx.fillStyle = point.fill;
	    ctx.beginPath();
	    ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);
	    ctx.closePath();
	    ctx.fill();
	
	    ctx.restore();
	  },
	
	  /**
	   * Invoked on mouse down
	   */
	  onMouseDown: function(pointer) {
	    this.points.length = 0;
	    this.canvas.clearContext(this.canvas.contextTop);
	    this._setShadow();
	    this.drawDot(pointer);
	  },
	
	  /**
	   * Invoked on mouse move
	   * @param {Object} pointer
	   */
	  onMouseMove: function(pointer) {
	    this.drawDot(pointer);
	  },
	
	  /**
	   * Invoked on mouse up
	   */
	  onMouseUp: function() {
	    var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;
	    this.canvas.renderOnAddRemove = false;
	
	    var circles = [];
	
	    for (var i = 0, len = this.points.length; i < len; i++) {
	      var point = this.points[i],
	          circle = new fabric.Circle({
	            radius: point.radius,
	            left: point.x,
	            top: point.y,
	            originX: 'center',
	            originY: 'center',
	            fill: point.fill
	          });
	
	      this.shadow && circle.setShadow(this.shadow);
	
	      circles.push(circle);
	    }
	    var group = new fabric.Group(circles, { originX: 'center', originY: 'center' });
	    group.canvas = this.canvas;
	
	    this.canvas.add(group);
	    this.canvas.fire('path:created', { path: group });
	
	    this.canvas.clearContext(this.canvas.contextTop);
	    this._resetShadow();
	    this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
	    this.canvas.renderAll();
	  },
	
	  /**
	   * @param {Object} pointer
	   * @return {fabric.Point} Just added pointer point
	   */
	  addPoint: function(pointer) {
	    var pointerPoint = new fabric.Point(pointer.x, pointer.y),
	
	        circleRadius = fabric.util.getRandomInt(
	                        Math.max(0, this.width - 20), this.width + 20) / 2,
	
	        circleColor = new fabric.Color(this.color)
	                        .setAlpha(fabric.util.getRandomInt(0, 100) / 100)
	                        .toRgba();
	
	    pointerPoint.radius = circleRadius;
	    pointerPoint.fill = circleColor;
	
	    this.points.push(pointerPoint);
	
	    return pointerPoint;
	  }
	});
	
	
	/**
	 * SprayBrush class
	 * @class fabric.SprayBrush
	 */
	fabric.SprayBrush = fabric.util.createClass( fabric.BaseBrush, /** @lends fabric.SprayBrush.prototype */ {
	
	  /**
	   * Width of a spray
	   * @type Number
	   * @default
	   */
	  width:              10,
	
	  /**
	   * Density of a spray (number of dots per chunk)
	   * @type Number
	   * @default
	   */
	  density:            20,
	
	  /**
	   * Width of spray dots
	   * @type Number
	   * @default
	   */
	  dotWidth:           1,
	
	  /**
	   * Width variance of spray dots
	   * @type Number
	   * @default
	   */
	  dotWidthVariance:   1,
	
	  /**
	   * Whether opacity of a dot should be random
	   * @type Boolean
	   * @default
	   */
	  randomOpacity:        false,
	
	  /**
	   * Whether overlapping dots (rectangles) should be removed (for performance reasons)
	   * @type Boolean
	   * @default
	   */
	  optimizeOverlapping:  true,
	
	  /**
	   * Constructor
	   * @param {fabric.Canvas} canvas
	   * @return {fabric.SprayBrush} Instance of a spray brush
	   */
	  initialize: function(canvas) {
	    this.canvas = canvas;
	    this.sprayChunks = [];
	  },
	
	  /**
	   * Invoked on mouse down
	   * @param {Object} pointer
	   */
	  onMouseDown: function(pointer) {
	    this.sprayChunks.length = 0;
	    this.canvas.clearContext(this.canvas.contextTop);
	    this._setShadow();
	
	    this.addSprayChunk(pointer);
	    this.render();
	  },
	
	  /**
	   * Invoked on mouse move
	   * @param {Object} pointer
	   */
	  onMouseMove: function(pointer) {
	    this.addSprayChunk(pointer);
	    this.render();
	  },
	
	  /**
	   * Invoked on mouse up
	   */
	  onMouseUp: function() {
	    var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;
	    this.canvas.renderOnAddRemove = false;
	
	    var rects = [];
	
	    for (var i = 0, ilen = this.sprayChunks.length; i < ilen; i++) {
	      var sprayChunk = this.sprayChunks[i];
	
	      for (var j = 0, jlen = sprayChunk.length; j < jlen; j++) {
	
	        var rect = new fabric.Rect({
	          width: sprayChunk[j].width,
	          height: sprayChunk[j].width,
	          left: sprayChunk[j].x + 1,
	          top: sprayChunk[j].y + 1,
	          originX: 'center',
	          originY: 'center',
	          fill: this.color
	        });
	
	        this.shadow && rect.setShadow(this.shadow);
	        rects.push(rect);
	      }
	    }
	
	    if (this.optimizeOverlapping) {
	      rects = this._getOptimizedRects(rects);
	    }
	
	    var group = new fabric.Group(rects, { originX: 'center', originY: 'center' });
	    group.canvas = this.canvas;
	
	    this.canvas.add(group);
	    this.canvas.fire('path:created', { path: group });
	
	    this.canvas.clearContext(this.canvas.contextTop);
	    this._resetShadow();
	    this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
	    this.canvas.renderAll();
	  },
	
	  /**
	   * @private
	   * @param {Array} rects
	   */
	  _getOptimizedRects: function(rects) {
	
	    // avoid creating duplicate rects at the same coordinates
	    var uniqueRects = { }, key;
	
	    for (var i = 0, len = rects.length; i < len; i++) {
	      key = rects[i].left + '' + rects[i].top;
	      if (!uniqueRects[key]) {
	        uniqueRects[key] = rects[i];
	      }
	    }
	    var uniqueRectsArray = [];
	    for (key in uniqueRects) {
	      uniqueRectsArray.push(uniqueRects[key]);
	    }
	
	    return uniqueRectsArray;
	  },
	
	  /**
	   * Renders brush
	   */
	  render: function() {
	    var ctx = this.canvas.contextTop;
	    ctx.fillStyle = this.color;
	
	    var v = this.canvas.viewportTransform;
	    ctx.save();
	    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
	
	    for (var i = 0, len = this.sprayChunkPoints.length; i < len; i++) {
	      var point = this.sprayChunkPoints[i];
	      if (typeof point.opacity !== 'undefined') {
	        ctx.globalAlpha = point.opacity;
	      }
	      ctx.fillRect(point.x, point.y, point.width, point.width);
	    }
	    ctx.restore();
	  },
	
	  /**
	   * @param {Object} pointer
	   */
	  addSprayChunk: function(pointer) {
	    this.sprayChunkPoints = [];
	
	    var x, y, width, radius = this.width / 2;
	
	    for (var i = 0; i < this.density; i++) {
	
	      x = fabric.util.getRandomInt(pointer.x - radius, pointer.x + radius);
	      y = fabric.util.getRandomInt(pointer.y - radius, pointer.y + radius);
	
	      if (this.dotWidthVariance) {
	        width = fabric.util.getRandomInt(
	          // bottom clamp width to 1
	          Math.max(1, this.dotWidth - this.dotWidthVariance),
	          this.dotWidth + this.dotWidthVariance);
	      }
	      else {
	        width = this.dotWidth;
	      }
	
	      var point = new fabric.Point(x, y);
	      point.width = width;
	
	      if (this.randomOpacity) {
	        point.opacity = fabric.util.getRandomInt(0, 100) / 100;
	      }
	
	      this.sprayChunkPoints.push(point);
	    }
	
	    this.sprayChunks.push(this.sprayChunkPoints);
	  }
	});
	
	
	/**
	 * PatternBrush class
	 * @class fabric.PatternBrush
	 * @extends fabric.BaseBrush
	 */
	fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fabric.PatternBrush.prototype */ {
	
	  getPatternSrc: function() {
	
	    var dotWidth = 20,
	        dotDistance = 5,
	        patternCanvas = fabric.document.createElement('canvas'),
	        patternCtx = patternCanvas.getContext('2d');
	
	    patternCanvas.width = patternCanvas.height = dotWidth + dotDistance;
	
	    patternCtx.fillStyle = this.color;
	    patternCtx.beginPath();
	    patternCtx.arc(dotWidth / 2, dotWidth / 2, dotWidth / 2, 0, Math.PI * 2, false);
	    patternCtx.closePath();
	    patternCtx.fill();
	
	    return patternCanvas;
	  },
	
	  getPatternSrcFunction: function() {
	    return String(this.getPatternSrc).replace('this.color', '"' + this.color + '"');
	  },
	
	  /**
	   * Creates "pattern" instance property
	   */
	  getPattern: function() {
	    return this.canvas.contextTop.createPattern(this.source || this.getPatternSrc(), 'repeat');
	  },
	
	  /**
	   * Sets brush styles
	   */
	  _setBrushStyles: function() {
	    this.callSuper('_setBrushStyles');
	    this.canvas.contextTop.strokeStyle = this.getPattern();
	  },
	
	  /**
	   * Creates path
	   */
	  createPath: function(pathData) {
	    var path = this.callSuper('createPath', pathData),
	        topLeft = path._getLeftTopCoords().scalarAdd(path.strokeWidth / 2);
	
	    path.stroke = new fabric.Pattern({
	      source: this.source || this.getPatternSrcFunction(),
	      offsetX: -topLeft.x,
	      offsetY: -topLeft.y
	    });
	    return path;
	  }
	});
	
	
	(function() {
	
	  var getPointer = fabric.util.getPointer,
	      degreesToRadians = fabric.util.degreesToRadians,
	      radiansToDegrees = fabric.util.radiansToDegrees,
	      atan2 = Math.atan2,
	      abs = Math.abs,
	      supportLineDash = fabric.StaticCanvas.supports('setLineDash'),
	
	      STROKE_OFFSET = 0.5;
	
	  /**
	   * Canvas class
	   * @class fabric.Canvas
	   * @extends fabric.StaticCanvas
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#canvas}
	   * @see {@link fabric.Canvas#initialize} for constructor definition
	   *
	   * @fires object:added
	   * @fires object:modified
	   * @fires object:rotating
	   * @fires object:scaling
	   * @fires object:moving
	   * @fires object:selected
	   *
	   * @fires before:selection:cleared
	   * @fires selection:cleared
	   * @fires selection:created
	   *
	   * @fires path:created
	   * @fires mouse:down
	   * @fires mouse:move
	   * @fires mouse:up
	   * @fires mouse:over
	   * @fires mouse:out
	   *
	   */
	  fabric.Canvas = fabric.util.createClass(fabric.StaticCanvas, /** @lends fabric.Canvas.prototype */ {
	
	    /**
	     * Constructor
	     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
	     * @param {Object} [options] Options object
	     * @return {Object} thisArg
	     */
	    initialize: function(el, options) {
	      options || (options = { });
	
	      this._initStatic(el, options);
	      this._initInteractive();
	      this._createCacheCanvas();
	    },
	
	    /**
	     * When true, objects can be transformed by one side (unproportionally)
	     * @type Boolean
	     * @default
	     */
	    uniScaleTransform:      false,
	
	    /**
	     * Indicates which key enable unproportional scaling
	     * values: 'altKey', 'shiftKey', 'ctrlKey'.
	     * If `null` or 'none' or any other string that is not a modifier key
	     * feature is disabled feature disabled.
	     * @since 1.6.2
	     * @type String
	     * @default
	     */
	    uniScaleKey:           'shiftKey',
	
	    /**
	     * When true, objects use center point as the origin of scale transformation.
	     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
	     * @since 1.3.4
	     * @type Boolean
	     * @default
	     */
	    centeredScaling:        false,
	
	    /**
	     * When true, objects use center point as the origin of rotate transformation.
	     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
	     * @since 1.3.4
	     * @type Boolean
	     * @default
	     */
	    centeredRotation:       false,
	
	    /**
	     * Indicates which key enable centered Transfrom
	     * values: 'altKey', 'shiftKey', 'ctrlKey'.
	     * If `null` or 'none' or any other string that is not a modifier key
	     * feature is disabled feature disabled.
	     * @since 1.6.2
	     * @type String
	     * @default
	     */
	    centeredKey:           'altKey',
	
	    /**
	     * Indicates which key enable alternate action on corner
	     * values: 'altKey', 'shiftKey', 'ctrlKey'.
	     * If `null` or 'none' or any other string that is not a modifier key
	     * feature is disabled feature disabled.
	     * @since 1.6.2
	     * @type String
	     * @default
	     */
	    altActionKey:           'shiftKey',
	
	    /**
	     * Indicates that canvas is interactive. This property should not be changed.
	     * @type Boolean
	     * @default
	     */
	    interactive:            true,
	
	    /**
	     * Indicates whether group selection should be enabled
	     * @type Boolean
	     * @default
	     */
	    selection:              true,
	
	    /**
	     * Indicates which key enable multiple click selection
	     * values: 'altKey', 'shiftKey', 'ctrlKey'.
	     * If `null` or 'none' or any other string that is not a modifier key
	     * feature is disabled feature disabled.
	     * @since 1.6.2
	     * @type String
	     * @default
	     */
	    selectionKey:           'shiftKey',
	
	    /**
	     * Indicates which key enable alternative selection
	     * in case of target overlapping with active object
	     * values: 'altKey', 'shiftKey', 'ctrlKey'.
	     * If `null` or 'none' or any other string that is not a modifier key
	     * feature is disabled feature disabled.
	     * @since 1.6.5
	     * @type null|String
	     * @default
	     */
	    altSelectionKey:           null,
	
	    /**
	     * Color of selection
	     * @type String
	     * @default
	     */
	    selectionColor:         'rgba(100, 100, 255, 0.3)', // blue
	
	    /**
	     * Default dash array pattern
	     * If not empty the selection border is dashed
	     * @type Array
	     */
	    selectionDashArray:     [],
	
	    /**
	     * Color of the border of selection (usually slightly darker than color of selection itself)
	     * @type String
	     * @default
	     */
	    selectionBorderColor:   'rgba(255, 255, 255, 0.3)',
	
	    /**
	     * Width of a line used in object/group selection
	     * @type Number
	     * @default
	     */
	    selectionLineWidth:     1,
	
	    /**
	     * Default cursor value used when hovering over an object on canvas
	     * @type String
	     * @default
	     */
	    hoverCursor:            'move',
	
	    /**
	     * Default cursor value used when moving an object on canvas
	     * @type String
	     * @default
	     */
	    moveCursor:             'move',
	
	    /**
	     * Default cursor value used for the entire canvas
	     * @type String
	     * @default
	     */
	    defaultCursor:          'default',
	
	    /**
	     * Cursor value used during free drawing
	     * @type String
	     * @default
	     */
	    freeDrawingCursor:      'crosshair',
	
	    /**
	     * Cursor value used for rotation point
	     * @type String
	     * @default
	     */
	    rotationCursor:         'crosshair',
	
	    /**
	     * Default element class that's given to wrapper (div) element of canvas
	     * @type String
	     * @default
	     */
	    containerClass:         'canvas-container',
	
	    /**
	     * When true, object detection happens on per-pixel basis rather than on per-bounding-box
	     * @type Boolean
	     * @default
	     */
	    perPixelTargetFind:     false,
	
	    /**
	     * Number of pixels around target pixel to tolerate (consider active) during object detection
	     * @type Number
	     * @default
	     */
	    targetFindTolerance:    0,
	
	    /**
	     * When true, target detection is skipped when hovering over canvas. This can be used to improve performance.
	     * @type Boolean
	     * @default
	     */
	    skipTargetFind:         false,
	
	    /**
	     * When true, mouse events on canvas (mousedown/mousemove/mouseup) result in free drawing.
	     * After mousedown, mousemove creates a shape,
	     * and then mouseup finalizes it and adds an instance of `fabric.Path` onto canvas.
	     * @tutorial {@link http://fabricjs.com/fabric-intro-part-4#free_drawing}
	     * @type Boolean
	     * @default
	     */
	    isDrawingMode:          false,
	
	    /**
	     * Indicates whether objects should remain in current stack position when selected.
	     * When false objects are brought to top and rendered as part of the selection group
	     * @type Boolean
	     * @default
	     */
	    preserveObjectStacking: false,
	
	    /**
	     * Indicates the angle that an object will lock to while rotating.
	     * @type Number
	     * @since 1.6.7
	     * @default
	     */
	    snapAngle: 0,
	
	    /**
	     * Indicates the distance from the snapAngle the rotation will lock to the snapAngle.
	     * When `null`, the snapThreshold will default to the snapAngle.
	     * @type null|Number
	     * @since 1.6.7
	     * @default
	     */
	    snapThreshold: null,
	
	    /**
	     * Indicates if the right click on canvas can output the context menu or not
	     * @type Boolean
	     * @since 1.6.5
	     * @default
	     */
	    stopContextMenu: false,
	
	    /**
	     * Indicates if the canvas can fire right click events
	     * @type Boolean
	     * @since 1.6.5
	     * @default
	     */
	    fireRightClick: false,
	
	    /**
	     * @private
	     */
	    _initInteractive: function() {
	      this._currentTransform = null;
	      this._groupSelector = null;
	      this._initWrapperElement();
	      this._createUpperCanvas();
	      this._initEventListeners();
	
	      this._initRetinaScaling();
	
	      this.freeDrawingBrush = fabric.PencilBrush && new fabric.PencilBrush(this);
	
	      this.calcOffset();
	    },
	
	    /**
	     * Divides objects in two groups, one to render immediately
	     * and one to render as activeGroup.
	     * @return {Array} objects to render immediately and pushes the other in the activeGroup.
	     */
	    _chooseObjectsToRender: function() {
	      var activeGroup = this.getActiveGroup(),
	          activeObject = this.getActiveObject(),
	          object, objsToRender = [], activeGroupObjects = [];
	
	      if ((activeGroup || activeObject) && !this.preserveObjectStacking) {
	        for (var i = 0, length = this._objects.length; i < length; i++) {
	          object = this._objects[i];
	          if ((!activeGroup || !activeGroup.contains(object)) && object !== activeObject) {
	            objsToRender.push(object);
	          }
	          else {
	            activeGroupObjects.push(object);
	          }
	        }
	        if (activeGroup) {
	          activeGroup._set('_objects', activeGroupObjects);
	          objsToRender.push(activeGroup);
	        }
	        activeObject && objsToRender.push(activeObject);
	      }
	      else {
	        objsToRender = this._objects;
	      }
	      return objsToRender;
	    },
	
	    /**
	     * Renders both the top canvas and the secondary container canvas.
	     * @return {fabric.Canvas} instance
	     * @chainable
	     */
	    renderAll: function () {
	      if (this.contextTopDirty && !this._groupSelector && !this.isDrawingMode) {
	        this.clearContext(this.contextTop);
	        this.contextTopDirty = false;
	      }
	      var canvasToDrawOn = this.contextContainer;
	      this.renderCanvas(canvasToDrawOn, this._chooseObjectsToRender());
	      return this;
	    },
	
	    /**
	     * Method to render only the top canvas.
	     * Also used to render the group selection box.
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    renderTop: function () {
	      var ctx = this.contextTop;
	      this.clearContext(ctx);
	
	      // we render the top context - last object
	      if (this.selection && this._groupSelector) {
	        this._drawSelection(ctx);
	      }
	
	      this.fire('after:render');
	      this.contextTopDirty = true;
	      return this;
	    },
	
	    /**
	     * Resets the current transform to its original values and chooses the type of resizing based on the event
	     * @private
	     */
	    _resetCurrentTransform: function() {
	      var t = this._currentTransform;
	
	      t.target.set({
	        scaleX: t.original.scaleX,
	        scaleY: t.original.scaleY,
	        skewX: t.original.skewX,
	        skewY: t.original.skewY,
	        left: t.original.left,
	        top: t.original.top
	      });
	
	      if (this._shouldCenterTransform(t.target)) {
	        if (t.action === 'rotate') {
	          this._setOriginToCenter(t.target);
	        }
	        else {
	          if (t.originX !== 'center') {
	            if (t.originX === 'right') {
	              t.mouseXSign = -1;
	            }
	            else {
	              t.mouseXSign = 1;
	            }
	          }
	          if (t.originY !== 'center') {
	            if (t.originY === 'bottom') {
	              t.mouseYSign = -1;
	            }
	            else {
	              t.mouseYSign = 1;
	            }
	          }
	
	          t.originX = 'center';
	          t.originY = 'center';
	        }
	      }
	      else {
	        t.originX = t.original.originX;
	        t.originY = t.original.originY;
	      }
	    },
	
	    /**
	     * Checks if point is contained within an area of given object
	     * @param {Event} e Event object
	     * @param {fabric.Object} target Object to test against
	     * @param {Object} [point] x,y object of point coordinates we want to check.
	     * @return {Boolean} true if point is contained within an area of given object
	     */
	    containsPoint: function (e, target, point) {
	      var ignoreZoom = true,
	          pointer = point || this.getPointer(e, ignoreZoom),
	          xy;
	
	      if (target.group && target.group === this.getActiveGroup()) {
	        xy = this._normalizePointer(target.group, pointer);
	      }
	      else {
	        xy = { x: pointer.x, y: pointer.y };
	      }
	      // http://www.geog.ubc.ca/courses/klink/gis.notes/ncgia/u32.html
	      // http://idav.ucdavis.edu/~okreylos/TAship/Spring2000/PointInPolygon.html
	      return (target.containsPoint(xy) || target._findTargetCorner(pointer));
	    },
	
	    /**
	     * @private
	     */
	    _normalizePointer: function (object, pointer) {
	      var m = object.calcTransformMatrix(),
	          invertedM = fabric.util.invertTransform(m),
	          vptPointer = this.restorePointerVpt(pointer);
	      return fabric.util.transformPoint(vptPointer, invertedM);
	    },
	
	    /**
	     * Returns true if object is transparent at a certain location
	     * @param {fabric.Object} target Object to check
	     * @param {Number} x Left coordinate
	     * @param {Number} y Top coordinate
	     * @return {Boolean}
	     */
	    isTargetTransparent: function (target, x, y) {
	      var hasBorders = target.hasBorders,
	          transparentCorners = target.transparentCorners,
	          ctx = this.contextCache,
	          originalColor = target.selectionBackgroundColor;
	
	      target.hasBorders = target.transparentCorners = false;
	      target.selectionBackgroundColor = '';
	
	      ctx.save();
	      ctx.transform.apply(ctx, this.viewportTransform);
	      target.render(ctx);
	      ctx.restore();
	
	      target.active && target._renderControls(ctx);
	
	      target.hasBorders = hasBorders;
	      target.transparentCorners = transparentCorners;
	      target.selectionBackgroundColor = originalColor;
	
	      var isTransparent = fabric.util.isTransparent(
	        ctx, x, y, this.targetFindTolerance);
	
	      this.clearContext(ctx);
	
	      return isTransparent;
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object
	     * @param {fabric.Object} target
	     */
	    _shouldClearSelection: function (e, target) {
	      var activeGroup = this.getActiveGroup(),
	          activeObject = this.getActiveObject();
	
	      return (
	        !target
	        ||
	        (target &&
	          activeGroup &&
	          !activeGroup.contains(target) &&
	          activeGroup !== target &&
	          !e[this.selectionKey])
	        ||
	        (target && !target.evented)
	        ||
	        (target &&
	          !target.selectable &&
	          activeObject &&
	          activeObject !== target)
	      );
	    },
	
	    /**
	     * @private
	     * @param {fabric.Object} target
	     */
	    _shouldCenterTransform: function (target) {
	      if (!target) {
	        return;
	      }
	
	      var t = this._currentTransform,
	          centerTransform;
	
	      if (t.action === 'scale' || t.action === 'scaleX' || t.action === 'scaleY') {
	        centerTransform = this.centeredScaling || target.centeredScaling;
	      }
	      else if (t.action === 'rotate') {
	        centerTransform = this.centeredRotation || target.centeredRotation;
	      }
	
	      return centerTransform ? !t.altKey : t.altKey;
	    },
	
	    /**
	     * @private
	     */
	    _getOriginFromCorner: function(target, corner) {
	      var origin = {
	        x: target.originX,
	        y: target.originY
	      };
	
	      if (corner === 'ml' || corner === 'tl' || corner === 'bl') {
	        origin.x = 'right';
	      }
	      else if (corner === 'mr' || corner === 'tr' || corner === 'br') {
	        origin.x = 'left';
	      }
	
	      if (corner === 'tl' || corner === 'mt' || corner === 'tr') {
	        origin.y = 'bottom';
	      }
	      else if (corner === 'bl' || corner === 'mb' || corner === 'br') {
	        origin.y = 'top';
	      }
	
	      return origin;
	    },
	
	    /**
	     * @private
	     */
	    _getActionFromCorner: function(target, corner, e) {
	      if (!corner) {
	        return 'drag';
	      }
	
	      switch (corner) {
	        case 'mtr':
	          return 'rotate';
	        case 'ml':
	        case 'mr':
	          return e[this.altActionKey] ? 'skewY' : 'scaleX';
	        case 'mt':
	        case 'mb':
	          return e[this.altActionKey] ? 'skewX' : 'scaleY';
	        default:
	          return 'scale';
	      }
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object
	     * @param {fabric.Object} target
	     */
	    _setupCurrentTransform: function (e, target) {
	      if (!target) {
	        return;
	      }
	
	      var pointer = this.getPointer(e),
	          corner = target._findTargetCorner(this.getPointer(e, true)),
	          action = this._getActionFromCorner(target, corner, e),
	          origin = this._getOriginFromCorner(target, corner);
	
	      this._currentTransform = {
	        target: target,
	        action: action,
	        corner: corner,
	        scaleX: target.scaleX,
	        scaleY: target.scaleY,
	        skewX: target.skewX,
	        skewY: target.skewY,
	        offsetX: pointer.x - target.left,
	        offsetY: pointer.y - target.top,
	        originX: origin.x,
	        originY: origin.y,
	        ex: pointer.x,
	        ey: pointer.y,
	        lastX: pointer.x,
	        lastY: pointer.y,
	        left: target.left,
	        top: target.top,
	        theta: degreesToRadians(target.angle),
	        width: target.width * target.scaleX,
	        mouseXSign: 1,
	        mouseYSign: 1,
	        shiftKey: e.shiftKey,
	        altKey: e[this.centeredKey]
	      };
	
	      this._currentTransform.original = {
	        left: target.left,
	        top: target.top,
	        scaleX: target.scaleX,
	        scaleY: target.scaleY,
	        skewX: target.skewX,
	        skewY: target.skewY,
	        originX: origin.x,
	        originY: origin.y
	      };
	
	      this._resetCurrentTransform();
	    },
	
	    /**
	     * Translates object by "setting" its left/top
	     * @private
	     * @param {Number} x pointer's x coordinate
	     * @param {Number} y pointer's y coordinate
	     * @return {Boolean} true if the translation occurred
	     */
	    _translateObject: function (x, y) {
	      var transform = this._currentTransform,
	          target = transform.target,
	          newLeft = x - transform.offsetX,
	          newTop = y - transform.offsetY,
	          moveX = !target.get('lockMovementX') && target.left !== newLeft,
	          moveY = !target.get('lockMovementY') && target.top !== newTop;
	
	      moveX && target.set('left', newLeft);
	      moveY && target.set('top', newTop);
	      return moveX || moveY;
	    },
	
	    /**
	     * Check if we are increasing a positive skew or lower it,
	     * checking mouse direction and pressed corner.
	     * @private
	     */
	    _changeSkewTransformOrigin: function(mouseMove, t, by) {
	      var property = 'originX', origins = { 0: 'center' },
	          skew = t.target.skewX, originA = 'left', originB = 'right',
	          corner = t.corner === 'mt' || t.corner === 'ml' ? 1 : -1,
	          flipSign = 1;
	
	      mouseMove = mouseMove > 0 ? 1 : -1;
	      if (by === 'y') {
	        skew = t.target.skewY;
	        originA = 'top';
	        originB = 'bottom';
	        property = 'originY';
	      }
	      origins[-1] = originA;
	      origins[1] = originB;
	
	      t.target.flipX && (flipSign *= -1);
	      t.target.flipY && (flipSign *= -1);
	
	      if (skew === 0) {
	        t.skewSign = -corner * mouseMove * flipSign;
	        t[property] = origins[-mouseMove];
	      }
	      else {
	        skew = skew > 0 ? 1 : -1;
	        t.skewSign = skew;
	        t[property] = origins[skew * corner * flipSign];
	      }
	    },
	
	    /**
	     * Skew object by mouse events
	     * @private
	     * @param {Number} x pointer's x coordinate
	     * @param {Number} y pointer's y coordinate
	     * @param {String} by Either 'x' or 'y'
	     * @return {Boolean} true if the skewing occurred
	     */
	    _skewObject: function (x, y, by) {
	      var t = this._currentTransform,
	          target = t.target, skewed = false,
	          lockSkewingX = target.get('lockSkewingX'),
	          lockSkewingY = target.get('lockSkewingY');
	
	      if ((lockSkewingX && by === 'x') || (lockSkewingY && by === 'y')) {
	        return false;
	      }
	
	      // Get the constraint point
	      var center = target.getCenterPoint(),
	          actualMouseByCenter = target.toLocalPoint(new fabric.Point(x, y), 'center', 'center')[by],
	          lastMouseByCenter = target.toLocalPoint(new fabric.Point(t.lastX, t.lastY), 'center', 'center')[by],
	          actualMouseByOrigin, constraintPosition, dim = target._getTransformedDimensions();
	
	      this._changeSkewTransformOrigin(actualMouseByCenter - lastMouseByCenter, t, by);
	      actualMouseByOrigin = target.toLocalPoint(new fabric.Point(x, y), t.originX, t.originY)[by];
	      constraintPosition = target.translateToOriginPoint(center, t.originX, t.originY);
	      // Actually skew the object
	      skewed = this._setObjectSkew(actualMouseByOrigin, t, by, dim);
	      t.lastX = x;
	      t.lastY = y;
	      // Make sure the constraints apply
	      target.setPositionByOrigin(constraintPosition, t.originX, t.originY);
	      return skewed;
	    },
	
	    /**
	     * Set object skew
	     * @private
	     * @return {Boolean} true if the skewing occurred
	     */
	    _setObjectSkew: function(localMouse, transform, by, _dim) {
	      var target = transform.target, newValue, skewed = false,
	          skewSign = transform.skewSign, newDim, dimNoSkew,
	          otherBy, _otherBy, _by, newDimMouse, skewX, skewY;
	
	      if (by === 'x') {
	        otherBy = 'y';
	        _otherBy = 'Y';
	        _by = 'X';
	        skewX = 0;
	        skewY = target.skewY;
	      }
	      else {
	        otherBy = 'x';
	        _otherBy = 'X';
	        _by = 'Y';
	        skewX = target.skewX;
	        skewY = 0;
	      }
	
	      dimNoSkew = target._getTransformedDimensions(skewX, skewY);
	      newDimMouse = 2 * Math.abs(localMouse) - dimNoSkew[by];
	      if (newDimMouse <= 2) {
	        newValue = 0;
	      }
	      else {
	        newValue = skewSign * Math.atan((newDimMouse / target['scale' + _by]) /
	                                        (dimNoSkew[otherBy] / target['scale' + _otherBy]));
	        newValue = fabric.util.radiansToDegrees(newValue);
	      }
	      skewed = target['skew' + _by] !== newValue;
	      target.set('skew' + _by, newValue);
	      if (target['skew' + _otherBy] !== 0) {
	        newDim = target._getTransformedDimensions();
	        newValue = (_dim[otherBy] / newDim[otherBy]) * target['scale' + _otherBy];
	        target.set('scale' + _otherBy, newValue);
	      }
	      return skewed;
	    },
	
	    /**
	     * Scales object by invoking its scaleX/scaleY methods
	     * @private
	     * @param {Number} x pointer's x coordinate
	     * @param {Number} y pointer's y coordinate
	     * @param {String} by Either 'x' or 'y' - specifies dimension constraint by which to scale an object.
	     *                    When not provided, an object is scaled by both dimensions equally
	     * @return {Boolean} true if the scaling occurred
	     */
	    _scaleObject: function (x, y, by) {
	      var t = this._currentTransform,
	          target = t.target,
	          lockScalingX = target.get('lockScalingX'),
	          lockScalingY = target.get('lockScalingY'),
	          lockScalingFlip = target.get('lockScalingFlip');
	
	      if (lockScalingX && lockScalingY) {
	        return false;
	      }
	
	      // Get the constraint point
	      var constraintPosition = target.translateToOriginPoint(target.getCenterPoint(), t.originX, t.originY),
	          localMouse = target.toLocalPoint(new fabric.Point(x, y), t.originX, t.originY),
	          dim = target._getTransformedDimensions(), scaled = false;
	
	      this._setLocalMouse(localMouse, t);
	
	      // Actually scale the object
	      scaled = this._setObjectScale(localMouse, t, lockScalingX, lockScalingY, by, lockScalingFlip, dim);
	
	      // Make sure the constraints apply
	      target.setPositionByOrigin(constraintPosition, t.originX, t.originY);
	      return scaled;
	    },
	
	    /**
	     * @private
	     * @return {Boolean} true if the scaling occurred
	     */
	    _setObjectScale: function(localMouse, transform, lockScalingX, lockScalingY, by, lockScalingFlip, _dim) {
	      var target = transform.target, forbidScalingX = false, forbidScalingY = false, scaled = false,
	          changeX, changeY, scaleX, scaleY;
	
	      scaleX = localMouse.x * target.scaleX / _dim.x;
	      scaleY = localMouse.y * target.scaleY / _dim.y;
	      changeX = target.scaleX !== scaleX;
	      changeY = target.scaleY !== scaleY;
	
	      if (lockScalingFlip && scaleX <= 0 && scaleX < target.scaleX) {
	        forbidScalingX = true;
	      }
	
	      if (lockScalingFlip && scaleY <= 0 && scaleY < target.scaleY) {
	        forbidScalingY = true;
	      }
	
	      if (by === 'equally' && !lockScalingX && !lockScalingY) {
	        forbidScalingX || forbidScalingY || (scaled = this._scaleObjectEqually(localMouse, target, transform, _dim));
	      }
	      else if (!by) {
	        forbidScalingX || lockScalingX || (target.set('scaleX', scaleX) && (scaled = scaled || changeX));
	        forbidScalingY || lockScalingY || (target.set('scaleY', scaleY) && (scaled = scaled || changeY));
	      }
	      else if (by === 'x' && !target.get('lockUniScaling')) {
	        forbidScalingX || lockScalingX || (target.set('scaleX', scaleX) && (scaled = scaled || changeX));
	      }
	      else if (by === 'y' && !target.get('lockUniScaling')) {
	        forbidScalingY || lockScalingY || (target.set('scaleY', scaleY) && (scaled = scaled || changeY));
	      }
	      transform.newScaleX = scaleX;
	      transform.newScaleY = scaleY;
	      forbidScalingX || forbidScalingY || this._flipObject(transform, by);
	      return scaled;
	    },
	
	    /**
	     * @private
	     * @return {Boolean} true if the scaling occurred
	     */
	    _scaleObjectEqually: function(localMouse, target, transform, _dim) {
	
	      var dist = localMouse.y + localMouse.x,
	          lastDist = _dim.y * transform.original.scaleY / target.scaleY +
	                     _dim.x * transform.original.scaleX / target.scaleX,
	          scaled;
	
	      // We use transform.scaleX/Y instead of target.scaleX/Y
	      // because the object may have a min scale and we'll loose the proportions
	      transform.newScaleX = transform.original.scaleX * dist / lastDist;
	      transform.newScaleY = transform.original.scaleY * dist / lastDist;
	      scaled = transform.newScaleX !== target.scaleX || transform.newScaleY !== target.scaleY;
	      target.set('scaleX', transform.newScaleX);
	      target.set('scaleY', transform.newScaleY);
	      return scaled;
	    },
	
	    /**
	     * @private
	     */
	    _flipObject: function(transform, by) {
	      if (transform.newScaleX < 0 && by !== 'y') {
	        if (transform.originX === 'left') {
	          transform.originX = 'right';
	        }
	        else if (transform.originX === 'right') {
	          transform.originX = 'left';
	        }
	      }
	
	      if (transform.newScaleY < 0 && by !== 'x') {
	        if (transform.originY === 'top') {
	          transform.originY = 'bottom';
	        }
	        else if (transform.originY === 'bottom') {
	          transform.originY = 'top';
	        }
	      }
	    },
	
	    /**
	     * @private
	     */
	    _setLocalMouse: function(localMouse, t) {
	      var target = t.target;
	
	      if (t.originX === 'right') {
	        localMouse.x *= -1;
	      }
	      else if (t.originX === 'center') {
	        localMouse.x *= t.mouseXSign * 2;
	        if (localMouse.x < 0) {
	          t.mouseXSign = -t.mouseXSign;
	        }
	      }
	
	      if (t.originY === 'bottom') {
	        localMouse.y *= -1;
	      }
	      else if (t.originY === 'center') {
	        localMouse.y *= t.mouseYSign * 2;
	        if (localMouse.y < 0) {
	          t.mouseYSign = -t.mouseYSign;
	        }
	      }
	
	      // adjust the mouse coordinates when dealing with padding
	      if (abs(localMouse.x) > target.padding) {
	        if (localMouse.x < 0) {
	          localMouse.x += target.padding;
	        }
	        else {
	          localMouse.x -= target.padding;
	        }
	      }
	      else { // mouse is within the padding, set to 0
	        localMouse.x = 0;
	      }
	
	      if (abs(localMouse.y) > target.padding) {
	        if (localMouse.y < 0) {
	          localMouse.y += target.padding;
	        }
	        else {
	          localMouse.y -= target.padding;
	        }
	      }
	      else {
	        localMouse.y = 0;
	      }
	    },
	
	    /**
	     * Rotates object by invoking its rotate method
	     * @private
	     * @param {Number} x pointer's x coordinate
	     * @param {Number} y pointer's y coordinate
	     * @return {Boolean} true if the rotation occurred
	     */
	    _rotateObject: function (x, y) {
	
	      var t = this._currentTransform;
	
	      if (t.target.get('lockRotation')) {
	        return false;
	      }
	
	      var lastAngle = atan2(t.ey - t.top, t.ex - t.left),
	          curAngle = atan2(y - t.top, x - t.left),
	          angle = radiansToDegrees(curAngle - lastAngle + t.theta),
	          hasRoated = true;
	
	      // normalize angle to positive value
	      if (angle < 0) {
	        angle = 360 + angle;
	      }
	
	      angle %= 360;
	
	      if (t.target.snapAngle > 0) {
	        var snapAngle  = t.target.snapAngle,
	            snapThreshold  = t.target.snapThreshold || snapAngle,
	            rightAngleLocked = Math.ceil(angle / snapAngle) * snapAngle,
	            leftAngleLocked = Math.floor(angle / snapAngle) * snapAngle;
	
	        if (Math.abs(angle - leftAngleLocked) < snapThreshold) {
	          angle = leftAngleLocked;
	        }
	        else if (Math.abs(angle - rightAngleLocked) < snapThreshold) {
	          angle = rightAngleLocked;
	        }
	
	        if (t.target.angle === angle) {
	          hasRoated = false;
	        }
	      }
	
	      t.target.angle = angle;
	      return hasRoated;
	    },
	
	    /**
	     * Set the cursor type of the canvas element
	     * @param {String} value Cursor type of the canvas element.
	     * @see http://www.w3.org/TR/css3-ui/#cursor
	     */
	    setCursor: function (value) {
	      this.upperCanvasEl.style.cursor = value;
	    },
	
	    /**
	     * @param {fabric.Object} target to reset transform
	     * @private
	     */
	    _resetObjectTransform: function (target) {
	      target.scaleX = 1;
	      target.scaleY = 1;
	      target.skewX = 0;
	      target.skewY = 0;
	      target.setAngle(0);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx to draw the selection on
	     */
	    _drawSelection: function (ctx) {
	      var groupSelector = this._groupSelector,
	          left = groupSelector.left,
	          top = groupSelector.top,
	          aleft = abs(left),
	          atop = abs(top);
	
	      if (this.selectionColor) {
	        ctx.fillStyle = this.selectionColor;
	
	        ctx.fillRect(
	          groupSelector.ex - ((left > 0) ? 0 : -left),
	          groupSelector.ey - ((top > 0) ? 0 : -top),
	          aleft,
	          atop
	        );
	      }
	
	      if (!this.selectionLineWidth || !this.selectionBorderColor) {
	        return;
	      }
	      ctx.lineWidth = this.selectionLineWidth;
	      ctx.strokeStyle = this.selectionBorderColor;
	
	      // selection border
	      if (this.selectionDashArray.length > 1 && !supportLineDash) {
	
	        var px = groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0 : aleft),
	            py = groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0 : atop);
	
	        ctx.beginPath();
	
	        fabric.util.drawDashedLine(ctx, px, py, px + aleft, py, this.selectionDashArray);
	        fabric.util.drawDashedLine(ctx, px, py + atop - 1, px + aleft, py + atop - 1, this.selectionDashArray);
	        fabric.util.drawDashedLine(ctx, px, py, px, py + atop, this.selectionDashArray);
	        fabric.util.drawDashedLine(ctx, px + aleft - 1, py, px + aleft - 1, py + atop, this.selectionDashArray);
	
	        ctx.closePath();
	        ctx.stroke();
	      }
	      else {
	        fabric.Object.prototype._setLineDash.call(this, ctx, this.selectionDashArray);
	        ctx.strokeRect(
	          groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0 : aleft),
	          groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0 : atop),
	          aleft,
	          atop
	        );
	      }
	    },
	
	    /**
	     * Method that determines what object we are clicking on
	     * @param {Event} e mouse event
	     * @param {Boolean} skipGroup when true, activeGroup is skipped and only objects are traversed through
	     */
	    findTarget: function (e, skipGroup) {
	      if (this.skipTargetFind) {
	        return;
	      }
	
	      var ignoreZoom = true,
	          pointer = this.getPointer(e, ignoreZoom),
	          activeGroup = this.getActiveGroup(),
	          activeObject = this.getActiveObject(),
	          activeTarget;
	      // first check current group (if one exists)
	      // active group does not check sub targets like normal groups.
	      // if active group just exits.
	      if (activeGroup && !skipGroup && this._checkTarget(pointer, activeGroup)) {
	        this._fireOverOutEvents(activeGroup, e);
	        return activeGroup;
	      }
	      // if we hit the corner of an activeObject, let's return that.
	      if (activeObject && activeObject._findTargetCorner(pointer)) {
	        this._fireOverOutEvents(activeObject, e);
	        return activeObject;
	      }
	      if (activeObject && this._checkTarget(pointer, activeObject)) {
	        if (!this.preserveObjectStacking) {
	          this._fireOverOutEvents(activeObject, e);
	          return activeObject;
	        }
	        else {
	          activeTarget = activeObject;
	        }
	      }
	
	      this.targets = [];
	      var target = this._searchPossibleTargets(this._objects, pointer);
	      if (e[this.altSelectionKey] && target && activeTarget && target !== activeTarget) {
	        target = activeTarget;
	      }
	      this._fireOverOutEvents(target, e);
	      return target;
	    },
	
	    /**
	     * @private
	     */
	    _fireOverOutEvents: function(target, e) {
	      if (target) {
	        if (this._hoveredTarget !== target) {
	          if (this._hoveredTarget) {
	            this.fire('mouse:out', { target: this._hoveredTarget, e: e });
	            this._hoveredTarget.fire('mouseout');
	          }
	          this.fire('mouse:over', { target: target, e: e });
	          target.fire('mouseover');
	          this._hoveredTarget = target;
	        }
	      }
	      else if (this._hoveredTarget) {
	        this.fire('mouse:out', { target: this._hoveredTarget, e: e });
	        this._hoveredTarget.fire('mouseout');
	        this._hoveredTarget = null;
	      }
	    },
	
	    /**
	     * @private
	     */
	    _checkTarget: function(pointer, obj) {
	      if (obj &&
	          obj.visible &&
	          obj.evented &&
	          this.containsPoint(null, obj, pointer)){
	        if ((this.perPixelTargetFind || obj.perPixelTargetFind) && !obj.isEditing) {
	          var isTransparent = this.isTargetTransparent(obj, pointer.x, pointer.y);
	          if (!isTransparent) {
	            return true;
	          }
	        }
	        else {
	          return true;
	        }
	      }
	    },
	
	    /**
	     * @private
	     */
	    _searchPossibleTargets: function(objects, pointer) {
	
	      // Cache all targets where their bounding box contains point.
	      var target, i = objects.length, normalizedPointer, subTarget;
	      // Do not check for currently grouped objects, since we check the parent group itself.
	      // untill we call this function specifically to search inside the activeGroup
	      while (i--) {
	        if (this._checkTarget(pointer, objects[i])) {
	          target = objects[i];
	          if (target.type === 'group' && target.subTargetCheck) {
	            normalizedPointer = this._normalizePointer(target, pointer);
	            subTarget = this._searchPossibleTargets(target._objects, normalizedPointer);
	            subTarget && this.targets.push(subTarget);
	          }
	          break;
	        }
	      }
	      return target;
	    },
	
	    /**
	     * Returns pointer coordinates without the effect of the viewport
	     * @param {Object} pointer with "x" and "y" number values
	     * @return {Object} object with "x" and "y" number values
	     */
	    restorePointerVpt: function(pointer) {
	      return fabric.util.transformPoint(
	        pointer,
	        fabric.util.invertTransform(this.viewportTransform)
	      );
	    },
	
	    /**
	     * Returns pointer coordinates relative to canvas.
	     * @param {Event} e
	     * @param {Boolean} ignoreZoom
	     * @return {Object} object with "x" and "y" number values
	     */
	    getPointer: function (e, ignoreZoom, upperCanvasEl) {
	      if (!upperCanvasEl) {
	        upperCanvasEl = this.upperCanvasEl;
	      }
	      var pointer = getPointer(e),
	          bounds = upperCanvasEl.getBoundingClientRect(),
	          boundsWidth = bounds.width || 0,
	          boundsHeight = bounds.height || 0,
	          cssScale;
	
	      if (!boundsWidth || !boundsHeight ) {
	        if ('top' in bounds && 'bottom' in bounds) {
	          boundsHeight = Math.abs( bounds.top - bounds.bottom );
	        }
	        if ('right' in bounds && 'left' in bounds) {
	          boundsWidth = Math.abs( bounds.right - bounds.left );
	        }
	      }
	
	      this.calcOffset();
	
	      pointer.x = pointer.x - this._offset.left;
	      pointer.y = pointer.y - this._offset.top;
	      if (!ignoreZoom) {
	        pointer = this.restorePointerVpt(pointer);
	      }
	
	      if (boundsWidth === 0 || boundsHeight === 0) {
	        // If bounds are not available (i.e. not visible), do not apply scale.
	        cssScale = { width: 1, height: 1 };
	      }
	      else {
	        cssScale = {
	          width: upperCanvasEl.width / boundsWidth,
	          height: upperCanvasEl.height / boundsHeight
	        };
	      }
	
	      return {
	        x: pointer.x * cssScale.width,
	        y: pointer.y * cssScale.height
	      };
	    },
	
	    /**
	     * @private
	     * @throws {CANVAS_INIT_ERROR} If canvas can not be initialized
	     */
	    _createUpperCanvas: function () {
	      var lowerCanvasClass = this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/, '');
	
	      this.upperCanvasEl = this._createCanvasElement();
	      fabric.util.addClass(this.upperCanvasEl, 'upper-canvas ' + lowerCanvasClass);
	
	      this.wrapperEl.appendChild(this.upperCanvasEl);
	
	      this._copyCanvasStyle(this.lowerCanvasEl, this.upperCanvasEl);
	      this._applyCanvasStyle(this.upperCanvasEl);
	      this.contextTop = this.upperCanvasEl.getContext('2d');
	    },
	
	    /**
	     * @private
	     */
	    _createCacheCanvas: function () {
	      this.cacheCanvasEl = this._createCanvasElement();
	      this.cacheCanvasEl.setAttribute('width', this.width);
	      this.cacheCanvasEl.setAttribute('height', this.height);
	      this.contextCache = this.cacheCanvasEl.getContext('2d');
	    },
	
	    /**
	     * @private
	     */
	    _initWrapperElement: function () {
	      this.wrapperEl = fabric.util.wrapElement(this.lowerCanvasEl, 'div', {
	        'class': this.containerClass
	      });
	      fabric.util.setStyle(this.wrapperEl, {
	        width: this.getWidth() + 'px',
	        height: this.getHeight() + 'px',
	        position: 'relative'
	      });
	      fabric.util.makeElementUnselectable(this.wrapperEl);
	    },
	
	    /**
	     * @private
	     * @param {HTMLElement} element canvas element to apply styles on
	     */
	    _applyCanvasStyle: function (element) {
	      var width = this.getWidth() || element.width,
	          height = this.getHeight() || element.height;
	
	      fabric.util.setStyle(element, {
	        position: 'absolute',
	        width: width + 'px',
	        height: height + 'px',
	        left: 0,
	        top: 0
	      });
	      element.width = width;
	      element.height = height;
	      fabric.util.makeElementUnselectable(element);
	    },
	
	    /**
	     * Copys the the entire inline style from one element (fromEl) to another (toEl)
	     * @private
	     * @param {Element} fromEl Element style is copied from
	     * @param {Element} toEl Element copied style is applied to
	     */
	    _copyCanvasStyle: function (fromEl, toEl) {
	      toEl.style.cssText = fromEl.style.cssText;
	    },
	
	    /**
	     * Returns context of canvas where object selection is drawn
	     * @return {CanvasRenderingContext2D}
	     */
	    getSelectionContext: function() {
	      return this.contextTop;
	    },
	
	    /**
	     * Returns &lt;canvas> element on which object selection is drawn
	     * @return {HTMLCanvasElement}
	     */
	    getSelectionElement: function () {
	      return this.upperCanvasEl;
	    },
	
	    /**
	     * @private
	     * @param {Object} object
	     */
	    _setActiveObject: function(object) {
	      if (this._activeObject) {
	        this._activeObject.set('active', false);
	      }
	      this._activeObject = object;
	      object.set('active', true);
	    },
	
	    /**
	     * Sets given object as the only active object on canvas
	     * @param {fabric.Object} object Object to set as an active one
	     * @param {Event} [e] Event (passed along when firing "object:selected")
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    setActiveObject: function (object, e) {
	      this._setActiveObject(object);
	      this.renderAll();
	      this.fire('object:selected', { target: object, e: e });
	      object.fire('selected', { e: e });
	      return this;
	    },
	
	    /**
	     * Returns currently active object
	     * @return {fabric.Object} active object
	     */
	    getActiveObject: function () {
	      return this._activeObject;
	    },
	
	    /**
	     * @private
	     * @param {fabric.Object} obj Object that was removed
	     */
	    _onObjectRemoved: function(obj) {
	      // removing active object should fire "selection:cleared" events
	      if (this.getActiveObject() === obj) {
	        this.fire('before:selection:cleared', { target: obj });
	        this._discardActiveObject();
	        this.fire('selection:cleared', { target: obj });
	        obj.fire('deselected');
	      }
	      this.callSuper('_onObjectRemoved', obj);
	    },
	
	    /**
	     * @private
	     */
	    _discardActiveObject: function() {
	      if (this._activeObject) {
	        this._activeObject.set('active', false);
	      }
	      this._activeObject = null;
	    },
	
	    /**
	     * Discards currently active object and fire events
	     * @param {event} e
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    discardActiveObject: function (e) {
	      var activeObject = this._activeObject;
	      this.fire('before:selection:cleared', { target: activeObject, e: e });
	      this._discardActiveObject();
	      this.fire('selection:cleared', { e: e });
	      activeObject && activeObject.fire('deselected', { e: e });
	      return this;
	    },
	
	    /**
	     * @private
	     * @param {fabric.Group} group
	     */
	    _setActiveGroup: function(group) {
	      this._activeGroup = group;
	      if (group) {
	        group.set('active', true);
	      }
	    },
	
	    /**
	     * Sets active group to a specified one
	     * @param {fabric.Group} group Group to set as a current one
	     * @param {Event} e Event object
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    setActiveGroup: function (group, e) {
	      this._setActiveGroup(group);
	      if (group) {
	        this.fire('object:selected', { target: group, e: e });
	        group.fire('selected', { e: e });
	      }
	      return this;
	    },
	
	    /**
	     * Returns currently active group
	     * @return {fabric.Group} Current group
	     */
	    getActiveGroup: function () {
	      return this._activeGroup;
	    },
	
	    /**
	     * @private
	     */
	    _discardActiveGroup: function() {
	      var g = this.getActiveGroup();
	      if (g) {
	        g.destroy();
	      }
	      this.setActiveGroup(null);
	    },
	
	    /**
	     * Discards currently active group and fire events
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    discardActiveGroup: function (e) {
	      var g = this.getActiveGroup();
	      this.fire('before:selection:cleared', { e: e, target: g });
	      this._discardActiveGroup();
	      this.fire('selection:cleared', { e: e });
	      return this;
	    },
	
	    /**
	     * Deactivates all objects on canvas, removing any active group or object
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    deactivateAll: function () {
	      var allObjects = this.getObjects(),
	          i = 0,
	          len = allObjects.length,
	          obj;
	      for ( ; i < len; i++) {
	        obj = allObjects[i];
	        obj && obj.set('active', false);
	      }
	      this._discardActiveGroup();
	      this._discardActiveObject();
	      return this;
	    },
	
	    /**
	     * Deactivates all objects and dispatches appropriate events
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    deactivateAllWithDispatch: function (e) {
	      var activeGroup = this.getActiveGroup(),
	          activeObject = this.getActiveObject();
	      if (activeObject || activeGroup) {
	        this.fire('before:selection:cleared', { target: activeObject || activeGroup, e: e });
	      }
	      this.deactivateAll();
	      if (activeObject || activeGroup) {
	        this.fire('selection:cleared', { e: e, target: activeObject });
	        activeObject && activeObject.fire('deselected');
	      }
	      return this;
	    },
	
	    /**
	     * Clears a canvas element and removes all event listeners
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    dispose: function () {
	      this.callSuper('dispose');
	      var wrapper = this.wrapperEl;
	      this.removeListeners();
	      wrapper.removeChild(this.upperCanvasEl);
	      wrapper.removeChild(this.lowerCanvasEl);
	      delete this.upperCanvasEl;
	      if (wrapper.parentNode) {
	        wrapper.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl);
	      }
	      delete this.wrapperEl;
	      return this;
	    },
	
	    /**
	     * Clears all contexts (background, main, top) of an instance
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    clear: function () {
	      this.discardActiveGroup();
	      this.discardActiveObject();
	      this.clearContext(this.contextTop);
	      return this.callSuper('clear');
	    },
	
	    /**
	     * Draws objects' controls (borders/controls)
	     * @param {CanvasRenderingContext2D} ctx Context to render controls on
	     */
	    drawControls: function(ctx) {
	      var activeGroup = this.getActiveGroup();
	
	      if (activeGroup) {
	        activeGroup._renderControls(ctx);
	      }
	      else {
	        this._drawObjectsControls(ctx);
	      }
	    },
	
	    /**
	     * @private
	     */
	    _drawObjectsControls: function(ctx) {
	      for (var i = 0, len = this._objects.length; i < len; ++i) {
	        if (!this._objects[i] || !this._objects[i].active) {
	          continue;
	        }
	        this._objects[i]._renderControls(ctx);
	      }
	    },
	
	    /**
	     * @private
	     */
	    _toObject: function(instance, methodName, propertiesToInclude) {
	      //If the object is part of the current selection group, it should
	      //be transformed appropriately
	      //i.e. it should be serialised as it would appear if the selection group
	      //were to be destroyed.
	      var originalProperties = this._realizeGroupTransformOnObject(instance),
	          object = this.callSuper('_toObject', instance, methodName, propertiesToInclude);
	      //Undo the damage we did by changing all of its properties
	      this._unwindGroupTransformOnObject(instance, originalProperties);
	      return object;
	    },
	
	    /**
	     * Realises an object's group transformation on it
	     * @private
	     * @param {fabric.Object} [instance] the object to transform (gets mutated)
	     * @returns the original values of instance which were changed
	     */
	    _realizeGroupTransformOnObject: function(instance) {
	      var layoutProps = ['angle', 'flipX', 'flipY', 'height', 'left', 'scaleX', 'scaleY', 'top', 'width'];
	      if (instance.group && instance.group === this.getActiveGroup()) {
	        //Copy all the positionally relevant properties across now
	        var originalValues = {};
	        layoutProps.forEach(function(prop) {
	          originalValues[prop] = instance[prop];
	        });
	        this.getActiveGroup().realizeTransform(instance);
	        return originalValues;
	      }
	      else {
	        return null;
	      }
	    },
	
	    /**
	     * Restores the changed properties of instance
	     * @private
	     * @param {fabric.Object} [instance] the object to un-transform (gets mutated)
	     * @param {Object} [originalValues] the original values of instance, as returned by _realizeGroupTransformOnObject
	     */
	    _unwindGroupTransformOnObject: function(instance, originalValues) {
	      if (originalValues) {
	        instance.set(originalValues);
	      }
	    },
	
	    /**
	     * @private
	     */
	    _setSVGObject: function(markup, instance, reviver) {
	      var originalProperties;
	      //If the object is in a selection group, simulate what would happen to that
	      //object when the group is deselected
	      originalProperties = this._realizeGroupTransformOnObject(instance);
	      this.callSuper('_setSVGObject', markup, instance, reviver);
	      this._unwindGroupTransformOnObject(instance, originalProperties);
	    },
	  });
	
	  // copying static properties manually to work around Opera's bug,
	  // where "prototype" property is enumerable and overrides existing prototype
	  for (var prop in fabric.StaticCanvas) {
	    if (prop !== 'prototype') {
	      fabric.Canvas[prop] = fabric.StaticCanvas[prop];
	    }
	  }
	
	  if (fabric.isTouchSupported) {
	    /** @ignore */
	    fabric.Canvas.prototype._setCursorFromEvent = function() { };
	  }
	
	  /**
	   * @ignore
	   * @class fabric.Element
	   * @alias fabric.Canvas
	   * @deprecated Use {@link fabric.Canvas} instead.
	   * @constructor
	   */
	  fabric.Element = fabric.Canvas;
	})();
	
	
	(function() {
	
	  var cursorOffset = {
	        mt: 0, // n
	        tr: 1, // ne
	        mr: 2, // e
	        br: 3, // se
	        mb: 4, // s
	        bl: 5, // sw
	        ml: 6, // w
	        tl: 7 // nw
	      },
	      addListener = fabric.util.addListener,
	      removeListener = fabric.util.removeListener;
	
	  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {
	
	    /**
	     * Map of cursor style values for each of the object controls
	     * @private
	     */
	    cursorMap: [
	      'n-resize',
	      'ne-resize',
	      'e-resize',
	      'se-resize',
	      's-resize',
	      'sw-resize',
	      'w-resize',
	      'nw-resize'
	    ],
	
	    /**
	     * Adds mouse listeners to canvas
	     * @private
	     */
	    _initEventListeners: function () {
	
	      this._bindEvents();
	
	      addListener(fabric.window, 'resize', this._onResize);
	
	      // mouse events
	      addListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);
	      addListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);
	      addListener(this.upperCanvasEl, 'mouseout', this._onMouseOut);
	      addListener(this.upperCanvasEl, 'mouseenter', this._onMouseEnter);
	      addListener(this.upperCanvasEl, 'wheel', this._onMouseWheel);
	      addListener(this.upperCanvasEl, 'contextmenu', this._onContextMenu);
	
	      // touch events
	      addListener(this.upperCanvasEl, 'touchstart', this._onMouseDown);
	      addListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);
	
	      if (typeof eventjs !== 'undefined' && 'add' in eventjs) {
	        eventjs.add(this.upperCanvasEl, 'gesture', this._onGesture);
	        eventjs.add(this.upperCanvasEl, 'drag', this._onDrag);
	        eventjs.add(this.upperCanvasEl, 'orientation', this._onOrientationChange);
	        eventjs.add(this.upperCanvasEl, 'shake', this._onShake);
	        eventjs.add(this.upperCanvasEl, 'longpress', this._onLongPress);
	      }
	    },
	
	    /**
	     * @private
	     */
	    _bindEvents: function() {
	      this._onMouseDown = this._onMouseDown.bind(this);
	      this._onMouseMove = this._onMouseMove.bind(this);
	      this._onMouseUp = this._onMouseUp.bind(this);
	      this._onResize = this._onResize.bind(this);
	      this._onGesture = this._onGesture.bind(this);
	      this._onDrag = this._onDrag.bind(this);
	      this._onShake = this._onShake.bind(this);
	      this._onLongPress = this._onLongPress.bind(this);
	      this._onOrientationChange = this._onOrientationChange.bind(this);
	      this._onMouseWheel = this._onMouseWheel.bind(this);
	      this._onMouseOut = this._onMouseOut.bind(this);
	      this._onMouseEnter = this._onMouseEnter.bind(this);
	      this._onContextMenu = this._onContextMenu.bind(this);
	    },
	
	    /**
	     * Removes all event listeners
	     */
	    removeListeners: function() {
	      removeListener(fabric.window, 'resize', this._onResize);
	
	      removeListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);
	      removeListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);
	      removeListener(this.upperCanvasEl, 'mouseout', this._onMouseOut);
	      removeListener(this.upperCanvasEl, 'mouseenter', this._onMouseEnter);
	      removeListener(this.upperCanvasEl, 'wheel', this._onMouseWheel);
	      removeListener(this.upperCanvasEl, 'contextmenu', this._onContextMenu);
	
	      removeListener(this.upperCanvasEl, 'touchstart', this._onMouseDown);
	      removeListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);
	
	      if (typeof eventjs !== 'undefined' && 'remove' in eventjs) {
	        eventjs.remove(this.upperCanvasEl, 'gesture', this._onGesture);
	        eventjs.remove(this.upperCanvasEl, 'drag', this._onDrag);
	        eventjs.remove(this.upperCanvasEl, 'orientation', this._onOrientationChange);
	        eventjs.remove(this.upperCanvasEl, 'shake', this._onShake);
	        eventjs.remove(this.upperCanvasEl, 'longpress', this._onLongPress);
	      }
	    },
	
	    /**
	     * @private
	     * @param {Event} [e] Event object fired on Event.js gesture
	     * @param {Event} [self] Inner Event object
	     */
	    _onGesture: function(e, self) {
	      this.__onTransformGesture && this.__onTransformGesture(e, self);
	    },
	
	    /**
	     * @private
	     * @param {Event} [e] Event object fired on Event.js drag
	     * @param {Event} [self] Inner Event object
	     */
	    _onDrag: function(e, self) {
	      this.__onDrag && this.__onDrag(e, self);
	    },
	
	    /**
	     * @private
	     * @param {Event} [e] Event object fired on wheel event
	     */
	    _onMouseWheel: function(e) {
	      this.__onMouseWheel(e);
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object fired on mousedown
	     */
	    _onMouseOut: function(e) {
	      var target = this._hoveredTarget;
	      this.fire('mouse:out', { target: target, e: e });
	      this._hoveredTarget = null;
	      target && target.fire('mouseout', { e: e });
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object fired on mouseenter
	     */
	    _onMouseEnter: function(e) {
	      if (!this.findTarget(e)) {
	        this.fire('mouse:over', { target: null, e: e });
	        this._hoveredTarget = null;
	      }
	    },
	
	    /**
	     * @private
	     * @param {Event} [e] Event object fired on Event.js orientation change
	     * @param {Event} [self] Inner Event object
	     */
	    _onOrientationChange: function(e, self) {
	      this.__onOrientationChange && this.__onOrientationChange(e, self);
	    },
	
	    /**
	     * @private
	     * @param {Event} [e] Event object fired on Event.js shake
	     * @param {Event} [self] Inner Event object
	     */
	    _onShake: function(e, self) {
	      this.__onShake && this.__onShake(e, self);
	    },
	
	    /**
	     * @private
	     * @param {Event} [e] Event object fired on Event.js shake
	     * @param {Event} [self] Inner Event object
	     */
	    _onLongPress: function(e, self) {
	      this.__onLongPress && this.__onLongPress(e, self);
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object fired on mousedown
	     */
	    _onContextMenu: function (e) {
	      if (this.stopContextMenu) {
	        e.stopPropagation();
	        e.preventDefault();
	      }
	      return false;
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object fired on mousedown
	     */
	    _onMouseDown: function (e) {
	      this.__onMouseDown(e);
	
	      addListener(fabric.document, 'touchend', this._onMouseUp);
	      addListener(fabric.document, 'touchmove', this._onMouseMove);
	
	      removeListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);
	      removeListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);
	
	      if (e.type === 'touchstart') {
	        // Unbind mousedown to prevent double triggers from touch devices
	        removeListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);
	      }
	      else {
	        addListener(fabric.document, 'mouseup', this._onMouseUp);
	        addListener(fabric.document, 'mousemove', this._onMouseMove);
	      }
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object fired on mouseup
	     */
	    _onMouseUp: function (e) {
	      this.__onMouseUp(e);
	
	      removeListener(fabric.document, 'mouseup', this._onMouseUp);
	      removeListener(fabric.document, 'touchend', this._onMouseUp);
	
	      removeListener(fabric.document, 'mousemove', this._onMouseMove);
	      removeListener(fabric.document, 'touchmove', this._onMouseMove);
	
	      addListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);
	      addListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);
	
	      if (e.type === 'touchend') {
	        // Wait 400ms before rebinding mousedown to prevent double triggers
	        // from touch devices
	        var _this = this;
	        setTimeout(function() {
	          addListener(_this.upperCanvasEl, 'mousedown', _this._onMouseDown);
	        }, 400);
	      }
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object fired on mousemove
	     */
	    _onMouseMove: function (e) {
	      !this.allowTouchScrolling && e.preventDefault && e.preventDefault();
	      this.__onMouseMove(e);
	    },
	
	    /**
	     * @private
	     */
	    _onResize: function () {
	      this.calcOffset();
	    },
	
	    /**
	     * Decides whether the canvas should be redrawn in mouseup and mousedown events.
	     * @private
	     * @param {Object} target
	     * @param {Object} pointer
	     */
	    _shouldRender: function(target, pointer) {
	      var activeObject = this.getActiveGroup() || this.getActiveObject();
	
	      if (activeObject && activeObject.isEditing && target === activeObject) {
	        // if we mouse up/down over a editing textbox a cursor change,
	        // there is no need to re render
	        return false;
	      }
	      return !!(
	        (target && (
	          target.isMoving ||
	          target !== activeObject))
	        ||
	        (!target && !!activeObject)
	        ||
	        (!target && !activeObject && !this._groupSelector)
	        ||
	        (pointer &&
	          this._previousPointer &&
	          this.selection && (
	          pointer.x !== this._previousPointer.x ||
	          pointer.y !== this._previousPointer.y))
	      );
	    },
	
	    /**
	     * Method that defines the actions when mouse is released on canvas.
	     * The method resets the currentTransform parameters, store the image corner
	     * position in the image object and render the canvas on top.
	     * @private
	     * @param {Event} e Event object fired on mouseup
	     */
	    __onMouseUp: function (e) {
	      var target, searchTarget = true, transform = this._currentTransform,
	          groupSelector = this._groupSelector,
	          isClick = (!groupSelector || (groupSelector.left === 0 && groupSelector.top === 0));
	
	      if (this.isDrawingMode && this._isCurrentlyDrawing) {
	        this._onMouseUpInDrawingMode(e);
	        return;
	      }
	
	      if (transform) {
	        this._finalizeCurrentTransform();
	        searchTarget = !transform.actionPerformed;
	      }
	
	      target = searchTarget ? this.findTarget(e, true) : transform.target;
	
	      var shouldRender = this._shouldRender(target, this.getPointer(e));
	
	      if (target || !isClick) {
	        this._maybeGroupObjects(e);
	      }
	      else {
	        // those are done by default on mouse up
	        // by _maybeGroupObjects, we are skipping it in case of no target find
	        this._groupSelector = null;
	        this._currentTransform = null;
	      }
	
	      if (target) {
	        target.isMoving = false;
	      }
	
	      this._handleCursorAndEvent(e, target, 'up');
	      target && (target.__corner = 0);
	      shouldRender && this.renderAll();
	    },
	
	    /**
	     * set cursor for mouse up and handle mouseUp event
	     * @param {Event} e event from mouse
	     * @param {fabric.Object} target receiving event
	     * @param {String} eventType event to fire (up, down or move)
	     */
	    _handleCursorAndEvent: function(e, target, eventType) {
	      this._setCursorFromEvent(e, target);
	      this._handleEvent(e, eventType, target ? target : null);
	    },
	
	    /**
	     * Handle event firing for target and subtargets
	     * @param {Event} e event from mouse
	     * @param {String} eventType event to fire (up, down or move)
	     * @param {fabric.Object} targetObj receiving event
	     */
	    _handleEvent: function(e, eventType, targetObj) {
	      var target = typeof targetObj === 'undefined' ? this.findTarget(e) : targetObj,
	          targets = this.targets || [],
	          options = { e: e, target: target, subTargets: targets };
	      this.fire('mouse:' + eventType, options);
	      target && target.fire('mouse' + eventType, options);
	      for (var i = 0; i < targets.length; i++) {
	        targets[i].fire('mouse' + eventType, options);
	      }
	    },
	
	    /**
	     * @private
	     */
	    _finalizeCurrentTransform: function() {
	
	      var transform = this._currentTransform,
	          target = transform.target;
	
	      if (target._scaling) {
	        target._scaling = false;
	      }
	
	      target.setCoords();
	      this._restoreOriginXY(target);
	
	      if (transform.actionPerformed || (this.stateful && target.hasStateChanged())) {
	        this.fire('object:modified', { target: target });
	        target.fire('modified');
	      }
	    },
	
	    /**
	     * @private
	     * @param {Object} target Object to restore
	     */
	    _restoreOriginXY: function(target) {
	      if (this._previousOriginX && this._previousOriginY) {
	
	        var originPoint = target.translateToOriginPoint(
	          target.getCenterPoint(),
	          this._previousOriginX,
	          this._previousOriginY);
	
	        target.originX = this._previousOriginX;
	        target.originY = this._previousOriginY;
	
	        target.left = originPoint.x;
	        target.top = originPoint.y;
	
	        this._previousOriginX = null;
	        this._previousOriginY = null;
	      }
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object fired on mousedown
	     */
	    _onMouseDownInDrawingMode: function(e) {
	      this._isCurrentlyDrawing = true;
	      this.discardActiveObject(e).renderAll();
	      if (this.clipTo) {
	        fabric.util.clipContext(this, this.contextTop);
	      }
	      var pointer = this.getPointer(e);
	      this.freeDrawingBrush.onMouseDown(pointer);
	      this._handleEvent(e, 'down');
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object fired on mousemove
	     */
	    _onMouseMoveInDrawingMode: function(e) {
	      if (this._isCurrentlyDrawing) {
	        var pointer = this.getPointer(e);
	        this.freeDrawingBrush.onMouseMove(pointer);
	      }
	      this.setCursor(this.freeDrawingCursor);
	      this._handleEvent(e, 'move');
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object fired on mouseup
	     */
	    _onMouseUpInDrawingMode: function(e) {
	      this._isCurrentlyDrawing = false;
	      if (this.clipTo) {
	        this.contextTop.restore();
	      }
	      this.freeDrawingBrush.onMouseUp();
	      this._handleEvent(e, 'up');
	    },
	
	    /**
	     * Method that defines the actions when mouse is clicked on canvas.
	     * The method inits the currentTransform parameters and renders all the
	     * canvas so the current image can be placed on the top canvas and the rest
	     * in on the container one.
	     * @private
	     * @param {Event} e Event object fired on mousedown
	     */
	    __onMouseDown: function (e) {
	
	      var target = this.findTarget(e);
	
	      // if right click just fire events
	      var isRightClick  = 'which' in e ? e.which === 3 : e.button === 2;
	      if (isRightClick) {
	        if (this.fireRightClick) {
	          this._handleEvent(e, 'down', target ? target : null);
	        }
	        return;
	      }
	
	      if (this.isDrawingMode) {
	        this._onMouseDownInDrawingMode(e);
	        return;
	      }
	
	      // ignore if some object is being transformed at this moment
	      if (this._currentTransform) {
	        return;
	      }
	
	      // save pointer for check in __onMouseUp event
	      var pointer = this.getPointer(e, true);
	      this._previousPointer = pointer;
	
	      var shouldRender = this._shouldRender(target, pointer),
	          shouldGroup = this._shouldGroup(e, target);
	
	      if (this._shouldClearSelection(e, target)) {
	        this._clearSelection(e, target, pointer);
	      }
	      else if (shouldGroup) {
	        this._handleGrouping(e, target);
	        target = this.getActiveGroup();
	      }
	
	      if (target) {
	        if (target.selectable && (target.__corner || !shouldGroup)) {
	          this._beforeTransform(e, target);
	          this._setupCurrentTransform(e, target);
	        }
	
	        if (target !== this.getActiveGroup() && target !== this.getActiveObject()) {
	          this.deactivateAll();
	          target.selectable && this.setActiveObject(target, e);
	        }
	      }
	      this._handleEvent(e, 'down', target ? target : null);
	      // we must renderAll so that we update the visuals
	      shouldRender && this.renderAll();
	    },
	
	    /**
	     * @private
	     */
	    _beforeTransform: function(e, target) {
	      this.stateful && target.saveState();
	
	      // determine if it's a drag or rotate case
	      if (target._findTargetCorner(this.getPointer(e))) {
	        this.onBeforeScaleRotate(target);
	      }
	
	    },
	
	    /**
	     * @private
	     */
	    _clearSelection: function(e, target, pointer) {
	      this.deactivateAllWithDispatch(e);
	
	      if (target && target.selectable) {
	        this.setActiveObject(target, e);
	      }
	      else if (this.selection) {
	        this._groupSelector = {
	          ex: pointer.x,
	          ey: pointer.y,
	          top: 0,
	          left: 0
	        };
	      }
	    },
	
	    /**
	     * @private
	     * @param {Object} target Object for that origin is set to center
	     */
	    _setOriginToCenter: function(target) {
	      this._previousOriginX = this._currentTransform.target.originX;
	      this._previousOriginY = this._currentTransform.target.originY;
	
	      var center = target.getCenterPoint();
	
	      target.originX = 'center';
	      target.originY = 'center';
	
	      target.left = center.x;
	      target.top = center.y;
	
	      this._currentTransform.left = target.left;
	      this._currentTransform.top = target.top;
	    },
	
	    /**
	     * @private
	     * @param {Object} target Object for that center is set to origin
	     */
	    _setCenterToOrigin: function(target) {
	      var originPoint = target.translateToOriginPoint(
	        target.getCenterPoint(),
	        this._previousOriginX,
	        this._previousOriginY);
	
	      target.originX = this._previousOriginX;
	      target.originY = this._previousOriginY;
	
	      target.left = originPoint.x;
	      target.top = originPoint.y;
	
	      this._previousOriginX = null;
	      this._previousOriginY = null;
	    },
	
	    /**
	     * Method that defines the actions when mouse is hovering the canvas.
	     * The currentTransform parameter will definde whether the user is rotating/scaling/translating
	     * an image or neither of them (only hovering). A group selection is also possible and would cancel
	     * all any other type of action.
	     * In case of an image transformation only the top canvas will be rendered.
	     * @private
	     * @param {Event} e Event object fired on mousemove
	     */
	    __onMouseMove: function (e) {
	
	      var target, pointer;
	
	      if (this.isDrawingMode) {
	        this._onMouseMoveInDrawingMode(e);
	        return;
	      }
	      if (typeof e.touches !== 'undefined' && e.touches.length > 1) {
	        return;
	      }
	
	      var groupSelector = this._groupSelector;
	
	      // We initially clicked in an empty area, so we draw a box for multiple selection
	      if (groupSelector) {
	        pointer = this.getPointer(e, true);
	
	        groupSelector.left = pointer.x - groupSelector.ex;
	        groupSelector.top = pointer.y - groupSelector.ey;
	
	        this.renderTop();
	      }
	      else if (!this._currentTransform) {
	        target = this.findTarget(e);
	        this._setCursorFromEvent(e, target);
	      }
	      else {
	        this._transformObject(e);
	      }
	      this._handleEvent(e, 'move', target ? target : null);
	    },
	
	    /**
	     * Method that defines actions when an Event Mouse Wheel
	     * @param {Event} e Event object fired on mouseup
	     */
	    __onMouseWheel: function(e) {
	      this._handleEvent(e, 'wheel');
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event fired on mousemove
	     */
	    _transformObject: function(e) {
	      var pointer = this.getPointer(e),
	          transform = this._currentTransform;
	
	      transform.reset = false;
	      transform.target.isMoving = true;
	      transform.shiftKey = e.shiftKey;
	      transform.altKey = e[this.centeredKey];
	
	      this._beforeScaleTransform(e, transform);
	      this._performTransformAction(e, transform, pointer);
	
	      transform.actionPerformed && this.renderAll();
	    },
	
	    /**
	     * @private
	     */
	    _performTransformAction: function(e, transform, pointer) {
	      var x = pointer.x,
	          y = pointer.y,
	          target = transform.target,
	          action = transform.action,
	          actionPerformed = false;
	
	      if (action === 'rotate') {
	        (actionPerformed = this._rotateObject(x, y)) && this._fire('rotating', target, e);
	      }
	      else if (action === 'scale') {
	        (actionPerformed = this._onScale(e, transform, x, y)) && this._fire('scaling', target, e);
	      }
	      else if (action === 'scaleX') {
	        (actionPerformed = this._scaleObject(x, y, 'x')) && this._fire('scaling', target, e);
	      }
	      else if (action === 'scaleY') {
	        (actionPerformed = this._scaleObject(x, y, 'y')) && this._fire('scaling', target, e);
	      }
	      else if (action === 'skewX') {
	        (actionPerformed = this._skewObject(x, y, 'x')) && this._fire('skewing', target, e);
	      }
	      else if (action === 'skewY') {
	        (actionPerformed = this._skewObject(x, y, 'y')) && this._fire('skewing', target, e);
	      }
	      else {
	        actionPerformed = this._translateObject(x, y);
	        if (actionPerformed) {
	          this._fire('moving', target, e);
	          this.setCursor(target.moveCursor || this.moveCursor);
	        }
	      }
	      transform.actionPerformed = transform.actionPerformed || actionPerformed;
	    },
	
	    /**
	     * @private
	     */
	    _fire: function(eventName, target, e) {
	      this.fire('object:' + eventName, { target: target, e: e });
	      target.fire(eventName, { e: e });
	    },
	
	    /**
	     * @private
	     */
	    _beforeScaleTransform: function(e, transform) {
	      if (transform.action === 'scale' || transform.action === 'scaleX' || transform.action === 'scaleY') {
	        var centerTransform = this._shouldCenterTransform(transform.target);
	
	        // Switch from a normal resize to center-based
	        if ((centerTransform && (transform.originX !== 'center' || transform.originY !== 'center')) ||
	           // Switch from center-based resize to normal one
	           (!centerTransform && transform.originX === 'center' && transform.originY === 'center')
	        ) {
	          this._resetCurrentTransform();
	          transform.reset = true;
	        }
	      }
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object
	     * @param {Object} transform current tranform
	     * @param {Number} x mouse position x from origin
	     * @param {Number} y mouse poistion y from origin
	     * @return {Boolean} true if the scaling occurred
	     */
	    _onScale: function(e, transform, x, y) {
	      if ((e[this.uniScaleKey] || this.uniScaleTransform) && !transform.target.get('lockUniScaling')) {
	        transform.currentAction = 'scale';
	        return this._scaleObject(x, y);
	      }
	      else {
	        // Switch from a normal resize to proportional
	        if (!transform.reset && transform.currentAction === 'scale') {
	          this._resetCurrentTransform();
	        }
	
	        transform.currentAction = 'scaleEqually';
	        return this._scaleObject(x, y, 'equally');
	      }
	    },
	
	    /**
	     * Sets the cursor depending on where the canvas is being hovered.
	     * Note: very buggy in Opera
	     * @param {Event} e Event object
	     * @param {Object} target Object that the mouse is hovering, if so.
	     */
	    _setCursorFromEvent: function (e, target) {
	      if (!target) {
	        this.setCursor(this.defaultCursor);
	        return false;
	      }
	
	      var hoverCursor = target.hoverCursor || this.hoverCursor;
	      if (!target.selectable) {
	        //let's skip _findTargetCorner if object is not selectable
	        this.setCursor(hoverCursor);
	      }
	      else {
	        var activeGroup = this.getActiveGroup(),
	            // only show proper corner when group selection is not active
	            corner = target._findTargetCorner
	                      && (!activeGroup || !activeGroup.contains(target))
	                      && target._findTargetCorner(this.getPointer(e, true));
	
	        if (!corner) {
	          this.setCursor(hoverCursor);
	        }
	        else {
	          this._setCornerCursor(corner, target, e);
	        }
	      }
	      //actually unclear why it should return something
	      //is never evaluated
	      return true;
	    },
	
	    /**
	     * @private
	     */
	    _setCornerCursor: function(corner, target, e) {
	      if (corner in cursorOffset) {
	        this.setCursor(this._getRotatedCornerCursor(corner, target, e));
	      }
	      else if (corner === 'mtr' && target.hasRotatingPoint) {
	        this.setCursor(this.rotationCursor);
	      }
	      else {
	        this.setCursor(this.defaultCursor);
	        return false;
	      }
	    },
	
	    /**
	     * @private
	     */
	    _getRotatedCornerCursor: function(corner, target, e) {
	      var n = Math.round((target.getAngle() % 360) / 45);
	
	      if (n < 0) {
	        n += 8; // full circle ahead
	      }
	      n += cursorOffset[corner];
	      if (e[this.altActionKey] && cursorOffset[corner] % 2 === 0) {
	        //if we are holding shift and we are on a mx corner...
	        n += 2;
	      }
	      // normalize n to be from 0 to 7
	      n %= 8;
	
	      return this.cursorMap[n];
	    }
	  });
	})();
	
	
	(function() {
	
	  var min = Math.min,
	      max = Math.max;
	
	  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {
	
	    /**
	     * @private
	     * @param {Event} e Event object
	     * @param {fabric.Object} target
	     * @return {Boolean}
	     */
	    _shouldGroup: function(e, target) {
	      var activeObject = this.getActiveObject();
	      return e[this.selectionKey] && target && target.selectable &&
	            (this.getActiveGroup() || (activeObject && activeObject !== target))
	            && this.selection;
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object
	     * @param {fabric.Object} target
	     */
	    _handleGrouping: function (e, target) {
	      var activeGroup = this.getActiveGroup();
	
	      if (target === activeGroup) {
	        // if it's a group, find target again, using activeGroup objects
	        target = this.findTarget(e, true);
	        // if even object is not found, bail out
	        if (!target) {
	          return;
	        }
	      }
	      if (activeGroup) {
	        this._updateActiveGroup(target, e);
	      }
	      else {
	        this._createActiveGroup(target, e);
	      }
	
	      if (this._activeGroup) {
	        this._activeGroup.saveCoords();
	      }
	    },
	
	    /**
	     * @private
	     */
	    _updateActiveGroup: function(target, e) {
	      var activeGroup = this.getActiveGroup();
	
	      if (activeGroup.contains(target)) {
	
	        activeGroup.removeWithUpdate(target);
	        target.set('active', false);
	
	        if (activeGroup.size() === 1) {
	          // remove group alltogether if after removal it only contains 1 object
	          this.discardActiveGroup(e);
	          // activate last remaining object
	          this.setActiveObject(activeGroup.item(0));
	          return;
	        }
	      }
	      else {
	        activeGroup.addWithUpdate(target);
	      }
	      this.fire('selection:created', { target: activeGroup, e: e });
	      activeGroup.set('active', true);
	    },
	
	    /**
	     * @private
	     */
	    _createActiveGroup: function(target, e) {
	
	      if (this._activeObject && target !== this._activeObject) {
	
	        var group = this._createGroup(target);
	        group.addWithUpdate();
	
	        this.setActiveGroup(group);
	        this._activeObject = null;
	
	        this.fire('selection:created', { target: group, e: e });
	      }
	
	      target.set('active', true);
	    },
	
	    /**
	     * @private
	     * @param {Object} target
	     */
	    _createGroup: function(target) {
	
	      var objects = this.getObjects(),
	          isActiveLower = objects.indexOf(this._activeObject) < objects.indexOf(target),
	          groupObjects = isActiveLower
	            ? [this._activeObject, target]
	            : [target, this._activeObject];
	      this._activeObject.isEditing && this._activeObject.exitEditing();
	      return new fabric.Group(groupObjects, {
	        canvas: this
	      });
	    },
	
	    /**
	     * @private
	     * @param {Event} e mouse event
	     */
	    _groupSelectedObjects: function (e) {
	
	      var group = this._collectObjects();
	
	      // do not create group for 1 element only
	      if (group.length === 1) {
	        this.setActiveObject(group[0], e);
	      }
	      else if (group.length > 1) {
	        group = new fabric.Group(group.reverse(), {
	          canvas: this
	        });
	        group.addWithUpdate();
	        this.setActiveGroup(group, e);
	        group.saveCoords();
	        this.fire('selection:created', { target: group });
	        this.renderAll();
	      }
	    },
	
	    /**
	     * @private
	     */
	    _collectObjects: function() {
	      var group = [],
	          currentObject,
	          x1 = this._groupSelector.ex,
	          y1 = this._groupSelector.ey,
	          x2 = x1 + this._groupSelector.left,
	          y2 = y1 + this._groupSelector.top,
	          selectionX1Y1 = new fabric.Point(min(x1, x2), min(y1, y2)),
	          selectionX2Y2 = new fabric.Point(max(x1, x2), max(y1, y2)),
	          isClick = x1 === x2 && y1 === y2;
	
	      for (var i = this._objects.length; i--; ) {
	        currentObject = this._objects[i];
	
	        if (!currentObject || !currentObject.selectable || !currentObject.visible) {
	          continue;
	        }
	
	        if (currentObject.intersectsWithRect(selectionX1Y1, selectionX2Y2) ||
	            currentObject.isContainedWithinRect(selectionX1Y1, selectionX2Y2) ||
	            currentObject.containsPoint(selectionX1Y1) ||
	            currentObject.containsPoint(selectionX2Y2)
	        ) {
	          currentObject.set('active', true);
	          group.push(currentObject);
	
	          // only add one object if it's a click
	          if (isClick) {
	            break;
	          }
	        }
	      }
	
	      return group;
	    },
	
	    /**
	     * @private
	     */
	    _maybeGroupObjects: function(e) {
	      if (this.selection && this._groupSelector) {
	        this._groupSelectedObjects(e);
	      }
	
	      var activeGroup = this.getActiveGroup();
	      if (activeGroup) {
	        activeGroup.setObjectsCoords().setCoords();
	        activeGroup.isMoving = false;
	        this.setCursor(this.defaultCursor);
	      }
	
	      // clear selection and current transformation
	      this._groupSelector = null;
	      this._currentTransform = null;
	    }
	  });
	
	})();
	
	
	(function () {
	
	  var supportQuality = fabric.StaticCanvas.supports('toDataURLWithQuality');
	
	  fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {
	
	    /**
	     * Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately
	     * @param {Object} [options] Options object
	     * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
	     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
	     * @param {Number} [options.multiplier=1] Multiplier to scale by
	     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
	     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
	     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
	     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
	     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
	     * @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}
	     * @example <caption>Generate jpeg dataURL with lower quality</caption>
	     * var dataURL = canvas.toDataURL({
	     *   format: 'jpeg',
	     *   quality: 0.8
	     * });
	     * @example <caption>Generate cropped png dataURL (clipping of canvas)</caption>
	     * var dataURL = canvas.toDataURL({
	     *   format: 'png',
	     *   left: 100,
	     *   top: 100,
	     *   width: 200,
	     *   height: 200
	     * });
	     * @example <caption>Generate double scaled png dataURL</caption>
	     * var dataURL = canvas.toDataURL({
	     *   format: 'png',
	     *   multiplier: 2
	     * });
	     */
	    toDataURL: function (options) {
	      options || (options = { });
	
	      var format = options.format || 'png',
	          quality = options.quality || 1,
	          multiplier = options.multiplier || 1,
	          cropping = {
	            left: options.left || 0,
	            top: options.top || 0,
	            width: options.width || 0,
	            height: options.height || 0,
	          };
	      return this.__toDataURLWithMultiplier(format, quality, cropping, multiplier);
	    },
	
	    /**
	     * @private
	     */
	    __toDataURLWithMultiplier: function(format, quality, cropping, multiplier) {
	
	      var origWidth = this.getWidth(),
	          origHeight = this.getHeight(),
	          scaledWidth = (cropping.width || this.getWidth()) * multiplier,
	          scaledHeight = (cropping.height || this.getHeight()) * multiplier,
	          zoom = this.getZoom(),
	          newZoom = zoom * multiplier,
	          vp = this.viewportTransform,
	          translateX = (vp[4] - cropping.left) * multiplier,
	          translateY = (vp[5] - cropping.top) * multiplier,
	          newVp = [newZoom, 0, 0, newZoom, translateX, translateY],
	          originalInteractive = this.interactive;
	
	      this.viewportTransform = newVp;
	      // setting interactive to false avoid exporting controls
	      this.interactive && (this.interactive = false);
	      if (origWidth !== scaledWidth || origHeight !== scaledHeight) {
	        // this.setDimensions is going to renderAll also;
	        this.setDimensions({ width: scaledWidth, height: scaledHeight });
	      }
	      else {
	        this.renderAll();
	      }
	      var data = this.__toDataURL(format, quality, cropping);
	      originalInteractive && (this.interactive = originalInteractive);
	      this.viewportTransform = vp;
	      //setDimensions with no option object is taking care of:
	      //this.width, this.height, this.renderAll()
	      this.setDimensions({ width: origWidth, height: origHeight });
	      return data;
	    },
	
	    /**
	     * @private
	     */
	    __toDataURL: function(format, quality) {
	
	      var canvasEl = this.contextContainer.canvas;
	      // to avoid common confusion https://github.com/kangax/fabric.js/issues/806
	      if (format === 'jpg') {
	        format = 'jpeg';
	      }
	
	      var data = supportQuality
	                ? canvasEl.toDataURL('image/' + format, quality)
	                : canvasEl.toDataURL('image/' + format);
	
	      return data;
	    },
	
	    /**
	     * Exports canvas element to a dataurl image (allowing to change image size via multiplier).
	     * @deprecated since 1.0.13
	     * @param {String} format (png|jpeg)
	     * @param {Number} multiplier
	     * @param {Number} quality (0..1)
	     * @return {String}
	     */
	    toDataURLWithMultiplier: function (format, multiplier, quality) {
	      return this.toDataURL({
	        format: format,
	        multiplier: multiplier,
	        quality: quality
	      });
	    },
	  });
	
	})();
	
	
	fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {
	
	  /**
	   * Populates canvas with data from the specified dataless JSON.
	   * JSON format must conform to the one of {@link fabric.Canvas#toDatalessJSON}
	   * @deprecated since 1.2.2
	   * @param {String|Object} json JSON string or object
	   * @param {Function} callback Callback, invoked when json is parsed
	   *                            and corresponding objects (e.g: {@link fabric.Image})
	   *                            are initialized
	   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.
	   * @return {fabric.Canvas} instance
	   * @chainable
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}
	   */
	  loadFromDatalessJSON: function (json, callback, reviver) {
	    return this.loadFromJSON(json, callback, reviver);
	  },
	
	  /**
	   * Populates canvas with data from the specified JSON.
	   * JSON format must conform to the one of {@link fabric.Canvas#toJSON}
	   * @param {String|Object} json JSON string or object
	   * @param {Function} callback Callback, invoked when json is parsed
	   *                            and corresponding objects (e.g: {@link fabric.Image})
	   *                            are initialized
	   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.
	   * @return {fabric.Canvas} instance
	   * @chainable
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}
	   * @see {@link http://jsfiddle.net/fabricjs/fmgXt/|jsFiddle demo}
	   * @example <caption>loadFromJSON</caption>
	   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));
	   * @example <caption>loadFromJSON with reviver</caption>
	   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas), function(o, object) {
	   *   // `o` = json object
	   *   // `object` = fabric.Object instance
	   *   // ... do some stuff ...
	   * });
	   */
	  loadFromJSON: function (json, callback, reviver) {
	    if (!json) {
	      return;
	    }
	
	    // serialize if it wasn't already
	    var serialized = (typeof json === 'string')
	      ? JSON.parse(json)
	      : fabric.util.object.clone(json);
	
	    this.clear();
	
	    var _this = this;
	    this._enlivenObjects(serialized.objects, function () {
	      _this._setBgOverlay(serialized, function () {
	        // remove parts i cannot set as options
	        delete serialized.objects;
	        delete serialized.backgroundImage;
	        delete serialized.overlayImage;
	        delete serialized.background;
	        delete serialized.overlay;
	        // this._initOptions does too many things to just
	        // call it. Normally loading an Object from JSON
	        // create the Object instance. Here the Canvas is
	        // already an instance and we are just loading things over it
	        _this._setOptions(serialized);
	        callback && callback();
	      });
	    }, reviver);
	    return this;
	  },
	
	  /**
	   * @private
	   * @param {Object} serialized Object with background and overlay information
	   * @param {Function} callback Invoked after all background and overlay images/patterns loaded
	   */
	  _setBgOverlay: function(serialized, callback) {
	    var _this = this,
	        loaded = {
	          backgroundColor: false,
	          overlayColor: false,
	          backgroundImage: false,
	          overlayImage: false
	        };
	
	    if (!serialized.backgroundImage && !serialized.overlayImage && !serialized.background && !serialized.overlay) {
	      callback && callback();
	      return;
	    }
	
	    var cbIfLoaded = function () {
	      if (loaded.backgroundImage && loaded.overlayImage && loaded.backgroundColor && loaded.overlayColor) {
	        _this.renderAll();
	        callback && callback();
	      }
	    };
	
	    this.__setBgOverlay('backgroundImage', serialized.backgroundImage, loaded, cbIfLoaded);
	    this.__setBgOverlay('overlayImage', serialized.overlayImage, loaded, cbIfLoaded);
	    this.__setBgOverlay('backgroundColor', serialized.background, loaded, cbIfLoaded);
	    this.__setBgOverlay('overlayColor', serialized.overlay, loaded, cbIfLoaded);
	  },
	
	  /**
	   * @private
	   * @param {String} property Property to set (backgroundImage, overlayImage, backgroundColor, overlayColor)
	   * @param {(Object|String)} value Value to set
	   * @param {Object} loaded Set loaded property to true if property is set
	   * @param {Object} callback Callback function to invoke after property is set
	   */
	  __setBgOverlay: function(property, value, loaded, callback) {
	    var _this = this;
	
	    if (!value) {
	      loaded[property] = true;
	      callback && callback();
	      return;
	    }
	
	    if (property === 'backgroundImage' || property === 'overlayImage') {
	      fabric.util.enlivenObjects([value], function(enlivedObject){
	        _this[property] = enlivedObject[0];
	        loaded[property] = true;
	        callback && callback();
	      });
	    }
	    else {
	      this['set' + fabric.util.string.capitalize(property, true)](value, function() {
	        loaded[property] = true;
	        callback && callback();
	      });
	    }
	  },
	
	  /**
	   * @private
	   * @param {Array} objects
	   * @param {Function} callback
	   * @param {Function} [reviver]
	   */
	  _enlivenObjects: function (objects, callback, reviver) {
	    var _this = this;
	
	    if (!objects || objects.length === 0) {
	      callback && callback();
	      return;
	    }
	
	    var renderOnAddRemove = this.renderOnAddRemove;
	    this.renderOnAddRemove = false;
	
	    fabric.util.enlivenObjects(objects, function(enlivenedObjects) {
	      enlivenedObjects.forEach(function(obj, index) {
	        // we splice the array just in case some custom classes restored from JSON
	        // will add more object to canvas at canvas init.
	        _this.insertAt(obj, index);
	      });
	
	      _this.renderOnAddRemove = renderOnAddRemove;
	      callback && callback();
	    }, null, reviver);
	  },
	
	  /**
	   * @private
	   * @param {String} format
	   * @param {Function} callback
	   */
	  _toDataURL: function (format, callback) {
	    this.clone(function (clone) {
	      callback(clone.toDataURL(format));
	    });
	  },
	
	  /**
	   * @private
	   * @param {String} format
	   * @param {Number} multiplier
	   * @param {Function} callback
	   */
	  _toDataURLWithMultiplier: function (format, multiplier, callback) {
	    this.clone(function (clone) {
	      callback(clone.toDataURLWithMultiplier(format, multiplier));
	    });
	  },
	
	  /**
	   * Clones canvas instance
	   * @param {Object} [callback] Receives cloned instance as a first argument
	   * @param {Array} [properties] Array of properties to include in the cloned canvas and children
	   */
	  clone: function (callback, properties) {
	    var data = JSON.stringify(this.toJSON(properties));
	    this.cloneWithoutData(function(clone) {
	      clone.loadFromJSON(data, function() {
	        callback && callback(clone);
	      });
	    });
	  },
	
	  /**
	   * Clones canvas instance without cloning existing data.
	   * This essentially copies canvas dimensions, clipping properties, etc.
	   * but leaves data empty (so that you can populate it with your own)
	   * @param {Object} [callback] Receives cloned instance as a first argument
	   */
	  cloneWithoutData: function(callback) {
	    var el = fabric.document.createElement('canvas');
	
	    el.width = this.getWidth();
	    el.height = this.getHeight();
	
	    var clone = new fabric.Canvas(el);
	    clone.clipTo = this.clipTo;
	    if (this.backgroundImage) {
	      clone.setBackgroundImage(this.backgroundImage.src, function() {
	        clone.renderAll();
	        callback && callback(clone);
	      });
	      clone.backgroundImageOpacity = this.backgroundImageOpacity;
	      clone.backgroundImageStretch = this.backgroundImageStretch;
	    }
	    else {
	      callback && callback(clone);
	    }
	  }
	});
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      clone = fabric.util.object.clone,
	      toFixed = fabric.util.toFixed,
	      capitalize = fabric.util.string.capitalize,
	      degreesToRadians = fabric.util.degreesToRadians,
	      supportsLineDash = fabric.StaticCanvas.supports('setLineDash'),
	      objectCaching = !fabric.isLikelyNode;
	
	  if (fabric.Object) {
	    return;
	  }
	
	  /**
	   * Root object class from which all 2d shape classes inherit from
	   * @class fabric.Object
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#objects}
	   * @see {@link fabric.Object#initialize} for constructor definition
	   *
	   * @fires added
	   * @fires removed
	   *
	   * @fires selected
	   * @fires deselected
	   * @fires modified
	   * @fires rotating
	   * @fires scaling
	   * @fires moving
	   * @fires skewing
	   *
	   * @fires mousedown
	   * @fires mouseup
	   * @fires mouseover
	   * @fires mouseout
	   * @fires mousewheel
	   */
	  fabric.Object = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.Object.prototype */ {
	
	    /**
	     * Retrieves object's {@link fabric.Object#clipTo|clipping function}
	     * @method getClipTo
	     * @memberOf fabric.Object.prototype
	     * @return {Function}
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#clipTo|clipping function}
	     * @method setClipTo
	     * @memberOf fabric.Object.prototype
	     * @param {Function} clipTo Clipping function
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#transformMatrix|transformMatrix}
	     * @method getTransformMatrix
	     * @memberOf fabric.Object.prototype
	     * @return {Array} transformMatrix
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#transformMatrix|transformMatrix}
	     * @method setTransformMatrix
	     * @memberOf fabric.Object.prototype
	     * @param {Array} transformMatrix
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#visible|visible} state
	     * @method getVisible
	     * @memberOf fabric.Object.prototype
	     * @return {Boolean} True if visible
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#visible|visible} state
	     * @method setVisible
	     * @memberOf fabric.Object.prototype
	     * @param {Boolean} value visible value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#shadow|shadow}
	     * @method getShadow
	     * @memberOf fabric.Object.prototype
	     * @return {Object} Shadow instance
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#stroke|stroke}
	     * @method getStroke
	     * @memberOf fabric.Object.prototype
	     * @return {String} stroke value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#stroke|stroke}
	     * @method setStroke
	     * @memberOf fabric.Object.prototype
	     * @param {String} value stroke value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#strokeWidth|strokeWidth}
	     * @method getStrokeWidth
	     * @memberOf fabric.Object.prototype
	     * @return {Number} strokeWidth value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#strokeWidth|strokeWidth}
	     * @method setStrokeWidth
	     * @memberOf fabric.Object.prototype
	     * @param {Number} value strokeWidth value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#originX|originX}
	     * @method getOriginX
	     * @memberOf fabric.Object.prototype
	     * @return {String} originX value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#originX|originX}
	     * @method setOriginX
	     * @memberOf fabric.Object.prototype
	     * @param {String} value originX value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#originY|originY}
	     * @method getOriginY
	     * @memberOf fabric.Object.prototype
	     * @return {String} originY value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#originY|originY}
	     * @method setOriginY
	     * @memberOf fabric.Object.prototype
	     * @param {String} value originY value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#fill|fill}
	     * @method getFill
	     * @memberOf fabric.Object.prototype
	     * @return {String} Fill value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#fill|fill}
	     * @method setFill
	     * @memberOf fabric.Object.prototype
	     * @param {String} value Fill value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#opacity|opacity}
	     * @method getOpacity
	     * @memberOf fabric.Object.prototype
	     * @return {Number} Opacity value (0-1)
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#opacity|opacity}
	     * @method setOpacity
	     * @memberOf fabric.Object.prototype
	     * @param {Number} value Opacity value (0-1)
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#angle|angle} (in degrees)
	     * @method getAngle
	     * @memberOf fabric.Object.prototype
	     * @return {Number}
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#top|top position}
	     * @method getTop
	     * @memberOf fabric.Object.prototype
	     * @return {Number} Top value (in pixels)
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#top|top position}
	     * @method setTop
	     * @memberOf fabric.Object.prototype
	     * @param {Number} value Top value (in pixels)
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#left|left position}
	     * @method getLeft
	     * @memberOf fabric.Object.prototype
	     * @return {Number} Left value (in pixels)
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#left|left position}
	     * @method setLeft
	     * @memberOf fabric.Object.prototype
	     * @param {Number} value Left value (in pixels)
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#scaleX|scaleX} value
	     * @method getScaleX
	     * @memberOf fabric.Object.prototype
	     * @return {Number} scaleX value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#scaleX|scaleX} value
	     * @method setScaleX
	     * @memberOf fabric.Object.prototype
	     * @param {Number} value scaleX value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#scaleY|scaleY} value
	     * @method getScaleY
	     * @memberOf fabric.Object.prototype
	     * @return {Number} scaleY value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#scaleY|scaleY} value
	     * @method setScaleY
	     * @memberOf fabric.Object.prototype
	     * @param {Number} value scaleY value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#flipX|flipX} value
	     * @method getFlipX
	     * @memberOf fabric.Object.prototype
	     * @return {Boolean} flipX value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#flipX|flipX} value
	     * @method setFlipX
	     * @memberOf fabric.Object.prototype
	     * @param {Boolean} value flipX value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#flipY|flipY} value
	     * @method getFlipY
	     * @memberOf fabric.Object.prototype
	     * @return {Boolean} flipY value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#flipY|flipY} value
	     * @method setFlipY
	     * @memberOf fabric.Object.prototype
	     * @param {Boolean} value flipY value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Type of an object (rect, circle, path, etc.).
	     * Note that this property is meant to be read-only and not meant to be modified.
	     * If you modify, certain parts of Fabric (such as JSON loading) won't work correctly.
	     * @type String
	     * @default
	     */
	    type:                     'object',
	
	    /**
	     * Horizontal origin of transformation of an object (one of "left", "right", "center")
	     * See http://jsfiddle.net/1ow02gea/40/ on how originX/originY affect objects in groups
	     * @type String
	     * @default
	     */
	    originX:                  'left',
	
	    /**
	     * Vertical origin of transformation of an object (one of "top", "bottom", "center")
	     * See http://jsfiddle.net/1ow02gea/40/ on how originX/originY affect objects in groups
	     * @type String
	     * @default
	     */
	    originY:                  'top',
	
	    /**
	     * Top position of an object. Note that by default it's relative to object top. You can change this by setting originY={top/center/bottom}
	     * @type Number
	     * @default
	     */
	    top:                      0,
	
	    /**
	     * Left position of an object. Note that by default it's relative to object left. You can change this by setting originX={left/center/right}
	     * @type Number
	     * @default
	     */
	    left:                     0,
	
	    /**
	     * Object width
	     * @type Number
	     * @default
	     */
	    width:                    0,
	
	    /**
	     * Object height
	     * @type Number
	     * @default
	     */
	    height:                   0,
	
	    /**
	     * Object scale factor (horizontal)
	     * @type Number
	     * @default
	     */
	    scaleX:                   1,
	
	    /**
	     * Object scale factor (vertical)
	     * @type Number
	     * @default
	     */
	    scaleY:                   1,
	
	    /**
	     * When true, an object is rendered as flipped horizontally
	     * @type Boolean
	     * @default
	     */
	    flipX:                    false,
	
	    /**
	     * When true, an object is rendered as flipped vertically
	     * @type Boolean
	     * @default
	     */
	    flipY:                    false,
	
	    /**
	     * Opacity of an object
	     * @type Number
	     * @default
	     */
	    opacity:                  1,
	
	    /**
	     * Angle of rotation of an object (in degrees)
	     * @type Number
	     * @default
	     */
	    angle:                    0,
	
	    /**
	     * Angle of skew on x axes of an object (in degrees)
	     * @type Number
	     * @default
	     */
	    skewX:                    0,
	
	    /**
	     * Angle of skew on y axes of an object (in degrees)
	     * @type Number
	     * @default
	     */
	    skewY:                    0,
	
	    /**
	     * Size of object's controlling corners (in pixels)
	     * @type Number
	     * @default
	     */
	    cornerSize:               13,
	
	    /**
	     * When true, object's controlling corners are rendered as transparent inside (i.e. stroke instead of fill)
	     * @type Boolean
	     * @default
	     */
	    transparentCorners:       true,
	
	    /**
	     * Default cursor value used when hovering over this object on canvas
	     * @type String
	     * @default
	     */
	    hoverCursor:              null,
	
	    /**
	     * Default cursor value used when moving this object on canvas
	     * @type String
	     * @default
	     */
	    moveCursor:               null,
	
	    /**
	     * Padding between object and its controlling borders (in pixels)
	     * @type Number
	     * @default
	     */
	    padding:                  0,
	
	    /**
	     * Color of controlling borders of an object (when it's active)
	     * @type String
	     * @default
	     */
	    borderColor:              'rgba(102,153,255,0.75)',
	
	    /**
	     * Array specifying dash pattern of an object's borders (hasBorder must be true)
	     * @since 1.6.2
	     * @type Array
	     */
	    borderDashArray:          null,
	
	    /**
	     * Color of controlling corners of an object (when it's active)
	     * @type String
	     * @default
	     */
	    cornerColor:              'rgba(102,153,255,0.5)',
	
	    /**
	     * Color of controlling corners of an object (when it's active and transparentCorners false)
	     * @since 1.6.2
	     * @type String
	     * @default
	     */
	    cornerStrokeColor:        null,
	
	    /**
	     * Specify style of control, 'rect' or 'circle'
	     * @since 1.6.2
	     * @type String
	     */
	    cornerStyle:          'rect',
	
	    /**
	     * Array specifying dash pattern of an object's control (hasBorder must be true)
	     * @since 1.6.2
	     * @type Array
	     */
	    cornerDashArray:          null,
	
	    /**
	     * When true, this object will use center point as the origin of transformation
	     * when being scaled via the controls.
	     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
	     * @since 1.3.4
	     * @type Boolean
	     * @default
	     */
	    centeredScaling:          false,
	
	    /**
	     * When true, this object will use center point as the origin of transformation
	     * when being rotated via the controls.
	     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
	     * @since 1.3.4
	     * @type Boolean
	     * @default
	     */
	    centeredRotation:         true,
	
	    /**
	     * Color of object's fill
	     * @type String
	     * @default
	     */
	    fill:                     'rgb(0,0,0)',
	
	    /**
	     * Fill rule used to fill an object
	     * accepted values are nonzero, evenodd
	     * <b>Backwards incompatibility note:</b> This property was used for setting globalCompositeOperation until v1.4.12 (use `fabric.Object#globalCompositeOperation` instead)
	     * @type String
	     * @default
	     */
	    fillRule:                 'nonzero',
	
	    /**
	     * Composite rule used for canvas globalCompositeOperation
	     * @type String
	     * @default
	     */
	    globalCompositeOperation: 'source-over',
	
	    /**
	     * Background color of an object.
	     * @type String
	     * @default
	     */
	    backgroundColor:          '',
	
	    /**
	     * Selection Background color of an object. colored layer behind the object when it is active.
	     * does not mix good with globalCompositeOperation methods.
	     * @type String
	     * @default
	     */
	    selectionBackgroundColor:          '',
	
	    /**
	     * When defined, an object is rendered via stroke and this property specifies its color
	     * @type String
	     * @default
	     */
	    stroke:                   null,
	
	    /**
	     * Width of a stroke used to render this object
	     * @type Number
	     * @default
	     */
	    strokeWidth:              1,
	
	    /**
	     * Array specifying dash pattern of an object's stroke (stroke must be defined)
	     * @type Array
	     */
	    strokeDashArray:          null,
	
	    /**
	     * Line endings style of an object's stroke (one of "butt", "round", "square")
	     * @type String
	     * @default
	     */
	    strokeLineCap:            'butt',
	
	    /**
	     * Corner style of an object's stroke (one of "bevil", "round", "miter")
	     * @type String
	     * @default
	     */
	    strokeLineJoin:           'miter',
	
	    /**
	     * Maximum miter length (used for strokeLineJoin = "miter") of an object's stroke
	     * @type Number
	     * @default
	     */
	    strokeMiterLimit:         10,
	
	    /**
	     * Shadow object representing shadow of this shape
	     * @type fabric.Shadow
	     * @default
	     */
	    shadow:                   null,
	
	    /**
	     * Opacity of object's controlling borders when object is active and moving
	     * @type Number
	     * @default
	     */
	    borderOpacityWhenMoving:  0.4,
	
	    /**
	     * Scale factor of object's controlling borders
	     * @type Number
	     * @default
	     */
	    borderScaleFactor:        1,
	
	    /**
	     * Transform matrix (similar to SVG's transform matrix)
	     * @type Array
	     */
	    transformMatrix:          null,
	
	    /**
	     * Minimum allowed scale value of an object
	     * @type Number
	     * @default
	     */
	    minScaleLimit:            0.01,
	
	    /**
	     * When set to `false`, an object can not be selected for modification (using either point-click-based or group-based selection).
	     * But events still fire on it.
	     * @type Boolean
	     * @default
	     */
	    selectable:               true,
	
	    /**
	     * When set to `false`, an object can not be a target of events. All events propagate through it. Introduced in v1.3.4
	     * @type Boolean
	     * @default
	     */
	    evented:                  true,
	
	    /**
	     * When set to `false`, an object is not rendered on canvas
	     * @type Boolean
	     * @default
	     */
	    visible:                  true,
	
	    /**
	     * When set to `false`, object's controls are not displayed and can not be used to manipulate object
	     * @type Boolean
	     * @default
	     */
	    hasControls:              true,
	
	    /**
	     * When set to `false`, object's controlling borders are not rendered
	     * @type Boolean
	     * @default
	     */
	    hasBorders:               true,
	
	    /**
	     * When set to `false`, object's controlling rotating point will not be visible or selectable
	     * @type Boolean
	     * @default
	     */
	    hasRotatingPoint:         true,
	
	    /**
	     * Offset for object's controlling rotating point (when enabled via `hasRotatingPoint`)
	     * @type Number
	     * @default
	     */
	    rotatingPointOffset:      40,
	
	    /**
	     * When set to `true`, objects are "found" on canvas on per-pixel basis rather than according to bounding box
	     * @type Boolean
	     * @default
	     */
	    perPixelTargetFind:       false,
	
	    /**
	     * When `false`, default object's values are not included in its serialization
	     * @type Boolean
	     * @default
	     */
	    includeDefaultValues:     true,
	
	    /**
	     * Function that determines clipping of an object (context is passed as a first argument)
	     * Note that context origin is at the object's center point (not left/top corner)
	     * @type Function
	     */
	    clipTo:                   null,
	
	    /**
	     * When `true`, object horizontal movement is locked
	     * @type Boolean
	     * @default
	     */
	    lockMovementX:            false,
	
	    /**
	     * When `true`, object vertical movement is locked
	     * @type Boolean
	     * @default
	     */
	    lockMovementY:            false,
	
	    /**
	     * When `true`, object rotation is locked
	     * @type Boolean
	     * @default
	     */
	    lockRotation:             false,
	
	    /**
	     * When `true`, object horizontal scaling is locked
	     * @type Boolean
	     * @default
	     */
	    lockScalingX:             false,
	
	    /**
	     * When `true`, object vertical scaling is locked
	     * @type Boolean
	     * @default
	     */
	    lockScalingY:             false,
	
	    /**
	     * When `true`, object non-uniform scaling is locked
	     * @type Boolean
	     * @default
	     */
	    lockUniScaling:           false,
	
	    /**
	     * When `true`, object horizontal skewing is locked
	     * @type Boolean
	     * @default
	     */
	    lockSkewingX:             false,
	
	    /**
	     * When `true`, object vertical skewing is locked
	     * @type Boolean
	     * @default
	     */
	    lockSkewingY:             false,
	
	    /**
	     * When `true`, object cannot be flipped by scaling into negative values
	     * @type Boolean
	     * @default
	     */
	    lockScalingFlip:          false,
	
	    /**
	     * When `true`, object is not exported in SVG or OBJECT/JSON
	     * since 1.6.3
	     * @type Boolean
	     * @default
	     */
	    excludeFromExport:        false,
	
	    /**
	     * When `true`, object is cached on an additional canvas.
	     * default to true
	     * since 1.7.0
	     * @type Boolean
	     * @default true
	     */
	    objectCaching:            objectCaching,
	
	    /**
	     * When `true`, object properties are checked for cache invalidation. In some particular
	     * situation you may want this to be disabled ( spray brush, very big pathgroups, groups)
	     * or if your application does not allow you to modify properties for groups child you want
	     * to disable it for groups.
	     * default to false
	     * since 1.7.0
	     * @type Boolean
	     * @default false
	     */
	    statefullCache:            false,
	
	    /**
	     * When `true`, cache does not get updated during scaling. The picture will get blocky if scaled
	     * too much and will be redrawn with correct details at the end of scaling.
	     * this setting is performance and application dependant.
	     * default to true
	     * since 1.7.0
	     * @type Boolean
	     * @default true
	     */
	    noScaleCache:              true,
	
	    /**
	     * When set to `true`, object's cache will be rerendered next render call.
	     * since 1.7.0
	     * @type Boolean
	     * @default false
	     */
	    dirty:                false,
	
	    /**
	     * List of properties to consider when checking if state
	     * of an object is changed (fabric.Object#hasStateChanged)
	     * as well as for history (undo/redo) purposes
	     * @type Array
	     */
	    stateProperties: (
	      'top left width height scaleX scaleY flipX flipY originX originY transformMatrix ' +
	      'stroke strokeWidth strokeDashArray strokeLineCap strokeLineJoin strokeMiterLimit ' +
	      'angle opacity fill fillRule globalCompositeOperation shadow clipTo visible backgroundColor ' +
	      'skewX skewY'
	    ).split(' '),
	
	    /**
	     * List of properties to consider when checking if cache needs refresh
	     * @type Array
	     */
	    cacheProperties: (
	      'fill stroke strokeWidth strokeDashArray width height stroke strokeWidth strokeDashArray' +
	      ' strokeLineCap strokeLineJoin strokeMiterLimit fillRule backgroundColor'
	    ).split(' '),
	
	    /**
	     * Constructor
	     * @param {Object} [options] Options object
	     */
	    initialize: function(options) {
	      options = options || { };
	      if (options) {
	        this.setOptions(options);
	      }
	      if (this.objectCaching) {
	        this._createCacheCanvas();
	        this.setupState({ propertySet: 'cacheProperties' });
	      }
	    },
	
	    /**
	     * Create a the canvas used to keep the cached copy of the object
	     * @private
	     */
	    _createCacheCanvas: function() {
	      this._cacheCanvas = fabric.document.createElement('canvas');
	      this._cacheContext = this._cacheCanvas.getContext('2d');
	      this._updateCacheCanvas();
	    },
	
	    /**
	     * Return the dimension and the zoom level needed to create a cache canvas
	     * big enough to host the object to be cached.
	     * @private
	     * @return {Object}.width width of canvas
	     * @return {Object}.height height of canvas
	     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
	     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
	     */
	    _getCacheCanvasDimensions: function() {
	      var zoom = this.canvas && this.canvas.getZoom() || 1,
	          objectScale = this.getObjectScaling(),
	          dim = this._getNonTransformedDimensions(),
	          retina = this.canvas && this.canvas._isRetinaScaling() ? fabric.devicePixelRatio : 1,
	          zoomX = objectScale.scaleX * zoom * retina,
	          zoomY = objectScale.scaleY * zoom * retina,
	          width = dim.x * zoomX,
	          height = dim.y * zoomY;
	      return {
	        width: Math.ceil(width) + 2,
	        height: Math.ceil(height) + 2,
	        zoomX: zoomX,
	        zoomY: zoomY
	      };
	    },
	
	    /**
	     * Update width and height of the canvas for cache
	     * returns true or false if canvas needed resize.
	     * @private
	     * @return {Boolean} true if the canvas has been resized
	     */
	    _updateCacheCanvas: function() {
	      if (this.noScaleCache && this.canvas && this.canvas._currentTransform) {
	        var action = this.canvas._currentTransform.action;
	        if (action.slice(0, 5) === 'scale') {
	          return false;
	        }
	      }
	      var dims = this._getCacheCanvasDimensions(),
	          width = dims.width, height = dims.height,
	          zoomX = dims.zoomX, zoomY = dims.zoomY;
	
	      if (width !== this.cacheWidth || height !== this.cacheHeight) {
	        this._cacheCanvas.width = width;
	        this._cacheCanvas.height = height;
	        this._cacheContext.translate(width / 2, height / 2);
	        this._cacheContext.scale(zoomX, zoomY);
	        this.cacheWidth = width;
	        this.cacheHeight = height;
	        this.zoomX = zoomX;
	        this.zoomY = zoomY;
	        return true;
	      }
	      return false;
	    },
	
	    /**
	     * Sets object's properties from options
	     * @param {Object} [options] Options object
	     */
	    setOptions: function(options) {
	      this._setOptions(options);
	      this._initGradient(options.fill, 'fill');
	      this._initGradient(options.stroke, 'stroke');
	      this._initClipping(options);
	      this._initPattern(options.fill, 'fill');
	      this._initPattern(options.stroke, 'stroke');
	    },
	
	    /**
	     * Transforms context when rendering an object
	     * @param {CanvasRenderingContext2D} ctx Context
	     * @param {Boolean} fromLeft When true, context is transformed to object's top/left corner. This is used when rendering text on Node
	     */
	    transform: function(ctx, fromLeft) {
	      if (this.group && !this.group._transformDone && this.group === this.canvas._activeGroup) {
	        this.group.transform(ctx);
	      }
	      var center = fromLeft ? this._getLeftTopCoords() : this.getCenterPoint();
	      ctx.translate(center.x, center.y);
	      ctx.rotate(degreesToRadians(this.angle));
	      ctx.scale(
	        this.scaleX * (this.flipX ? -1 : 1),
	        this.scaleY * (this.flipY ? -1 : 1)
	      );
	      ctx.transform(1, 0, Math.tan(degreesToRadians(this.skewX)), 1, 0, 0);
	      ctx.transform(1, Math.tan(degreesToRadians(this.skewY)), 0, 1, 0, 0);
	    },
	
	    /**
	     * Returns an object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
	
	          object = {
	            type:                     this.type,
	            originX:                  this.originX,
	            originY:                  this.originY,
	            left:                     toFixed(this.left, NUM_FRACTION_DIGITS),
	            top:                      toFixed(this.top, NUM_FRACTION_DIGITS),
	            width:                    toFixed(this.width, NUM_FRACTION_DIGITS),
	            height:                   toFixed(this.height, NUM_FRACTION_DIGITS),
	            fill:                     (this.fill && this.fill.toObject) ? this.fill.toObject() : this.fill,
	            stroke:                   (this.stroke && this.stroke.toObject) ? this.stroke.toObject() : this.stroke,
	            strokeWidth:              toFixed(this.strokeWidth, NUM_FRACTION_DIGITS),
	            strokeDashArray:          this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,
	            strokeLineCap:            this.strokeLineCap,
	            strokeLineJoin:           this.strokeLineJoin,
	            strokeMiterLimit:         toFixed(this.strokeMiterLimit, NUM_FRACTION_DIGITS),
	            scaleX:                   toFixed(this.scaleX, NUM_FRACTION_DIGITS),
	            scaleY:                   toFixed(this.scaleY, NUM_FRACTION_DIGITS),
	            angle:                    toFixed(this.getAngle(), NUM_FRACTION_DIGITS),
	            flipX:                    this.flipX,
	            flipY:                    this.flipY,
	            opacity:                  toFixed(this.opacity, NUM_FRACTION_DIGITS),
	            shadow:                   (this.shadow && this.shadow.toObject) ? this.shadow.toObject() : this.shadow,
	            visible:                  this.visible,
	            clipTo:                   this.clipTo && String(this.clipTo),
	            backgroundColor:          this.backgroundColor,
	            fillRule:                 this.fillRule,
	            globalCompositeOperation: this.globalCompositeOperation,
	            transformMatrix:          this.transformMatrix ? this.transformMatrix.concat() : null,
	            skewX:                    toFixed(this.skewX, NUM_FRACTION_DIGITS),
	            skewY:                    toFixed(this.skewY, NUM_FRACTION_DIGITS)
	          };
	
	      fabric.util.populateWithProperties(this, object, propertiesToInclude);
	
	      if (!this.includeDefaultValues) {
	        object = this._removeDefaultValues(object);
	      }
	
	      return object;
	    },
	
	    /**
	     * Returns (dataless) object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} Object representation of an instance
	     */
	    toDatalessObject: function(propertiesToInclude) {
	      // will be overwritten by subclasses
	      return this.toObject(propertiesToInclude);
	    },
	
	    /**
	     * @private
	     * @param {Object} object
	     */
	    _removeDefaultValues: function(object) {
	      var prototype = fabric.util.getKlass(object.type).prototype,
	          stateProperties = prototype.stateProperties;
	      stateProperties.forEach(function(prop) {
	        if (object[prop] === prototype[prop]) {
	          delete object[prop];
	        }
	        var isArray = Object.prototype.toString.call(object[prop]) === '[object Array]' &&
	                      Object.prototype.toString.call(prototype[prop]) === '[object Array]';
	
	        // basically a check for [] === []
	        if (isArray && object[prop].length === 0 && prototype[prop].length === 0) {
	          delete object[prop];
	        }
	      });
	
	      return object;
	    },
	
	    /**
	     * Returns a string representation of an instance
	     * @return {String}
	     */
	    toString: function() {
	      return '#<fabric.' + capitalize(this.type) + '>';
	    },
	
	    /**
	     * Return the object scale factor counting also the group scaling
	     * @return {Object} object with scaleX and scaleY properties
	     */
	    getObjectScaling: function() {
	      var scaleX = this.scaleX, scaleY = this.scaleY;
	      if (this.group) {
	        var scaling = this.group.getObjectScaling();
	        scaleX *= scaling.scaleX;
	        scaleY *= scaling.scaleY;
	      }
	      return { scaleX: scaleX, scaleY: scaleY };
	    },
	
	    /**
	     * @private
	     * @param {String} key
	     * @param {*} value
	     * @return {fabric.Object} thisArg
	     */
	    _set: function(key, value) {
	      var shouldConstrainValue = (key === 'scaleX' || key === 'scaleY');
	
	      if (shouldConstrainValue) {
	        value = this._constrainScale(value);
	      }
	      if (key === 'scaleX' && value < 0) {
	        this.flipX = !this.flipX;
	        value *= -1;
	      }
	      else if (key === 'scaleY' && value < 0) {
	        this.flipY = !this.flipY;
	        value *= -1;
	      }
	      else if (key === 'shadow' && value && !(value instanceof fabric.Shadow)) {
	        value = new fabric.Shadow(value);
	      }
	      else if (key === 'dirty' && this.group) {
	        this.group.set('dirty', value);
	      }
	
	      this[key] = value;
	
	      if (this.cacheProperties.indexOf(key) > -1) {
	        if (this.group) {
	          this.group.set('dirty', true);
	        }
	        this.dirty = true;
	      }
	
	      if (key === 'width' || key === 'height') {
	        this.minScaleLimit = Math.min(0.1, 1 / Math.max(this.width, this.height));
	      }
	
	      return this;
	    },
	
	    /**
	     * This callback function is called by the parent group of an object every
	     * time a non-delegated property changes on the group. It is passed the key
	     * and value as parameters. Not adding in this function's signature to avoid
	     * Travis build error about unused variables.
	     */
	    setOnGroup: function() {
	      // implemented by sub-classes, as needed.
	    },
	
	    /**
	     * Sets sourcePath of an object
	     * @param {String} value Value to set sourcePath to
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    setSourcePath: function(value) {
	      this.sourcePath = value;
	      return this;
	    },
	
	    /**
	     * Retrieves viewportTransform from Object's canvas if possible
	     * @method getViewportTransform
	     * @memberOf fabric.Object.prototype
	     * @return {Boolean} flipY value // TODO
	     */
	    getViewportTransform: function() {
	      if (this.canvas && this.canvas.viewportTransform) {
	        return this.canvas.viewportTransform;
	      }
	      return [1, 0, 0, 1, 0, 0];
	    },
	
	    /**
	     * Renders an object on a specified context
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} [noTransform] When true, context is not transformed
	     */
	    render: function(ctx, noTransform) {
	      // do not render if width/height are zeros or object is not visible
	      if ((this.width === 0 && this.height === 0) || !this.visible) {
	        return;
	      }
	      ctx.save();
	      //setup fill rule for current object
	      this._setupCompositeOperation(ctx);
	      this.drawSelectionBackground(ctx);
	      if (!noTransform) {
	        this.transform(ctx);
	      }
	      this._setOpacity(ctx);
	      this._setShadow(ctx);
	      if (this.transformMatrix) {
	        ctx.transform.apply(ctx, this.transformMatrix);
	      }
	      this.clipTo && fabric.util.clipContext(this, ctx);
	      if (this.objectCaching && !this.group) {
	        if (this.isCacheDirty(noTransform)) {
	          this.statefullCache && this.saveState({ propertySet: 'cacheProperties' });
	          this.drawObject(this._cacheContext, noTransform);
	          this.dirty = false;
	        }
	        this.drawCacheOnCanvas(ctx);
	      }
	      else {
	        this.drawObject(ctx, noTransform);
	        if (noTransform && this.objectCaching && this.statefullCache) {
	          this.saveState({ propertySet: 'cacheProperties' });
	        }
	      }
	      this.clipTo && ctx.restore();
	      ctx.restore();
	    },
	
	    /**
	     * Execute the drawing operation for an object on a specified context
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} [noTransform] When true, context is not transformed
	     */
	    drawObject: function(ctx, noTransform) {
	      this._renderBackground(ctx);
	      this._setStrokeStyles(ctx);
	      this._setFillStyles(ctx);
	      this._render(ctx, noTransform);
	    },
	
	    /**
	     * Paint the cached copy of the object on the target context.
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    drawCacheOnCanvas: function(ctx) {
	      ctx.scale(1 / this.zoomX, 1 / this.zoomY);
	      ctx.drawImage(this._cacheCanvas, -this.cacheWidth / 2, -this.cacheHeight / 2);
	    },
	
	    /**
	     * Check if cache is dirty
	     * @param {Boolean} skipCanvas skip canvas checks because this object is painted
	     * on parent canvas.
	     */
	    isCacheDirty: function(skipCanvas) {
	      if (!skipCanvas && this._updateCacheCanvas()) {
	        // in this case the context is already cleared.
	        return true;
	      }
	      else {
	        if (this.dirty || (this.statefullCache && this.hasStateChanged('cacheProperties'))) {
	          if (!skipCanvas) {
	            var dim = this._getNonTransformedDimensions();
	            this._cacheContext.clearRect(-dim.x / 2, -dim.y / 2, dim.x, dim.y);
	          }
	          return true;
	        }
	      }
	      return false;
	    },
	
	    /**
	     * Draws a background for the object big as its untrasformed dimensions
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderBackground: function(ctx) {
	      if (!this.backgroundColor) {
	        return;
	      }
	      var dim = this._getNonTransformedDimensions();
	      ctx.fillStyle = this.backgroundColor;
	
	      ctx.fillRect(
	        -dim.x / 2,
	        -dim.y / 2,
	        dim.x,
	        dim.y
	      );
	      // if there is background color no other shadows
	      // should be casted
	      this._removeShadow(ctx);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _setOpacity: function(ctx) {
	      ctx.globalAlpha *= this.opacity;
	    },
	
	    _setStrokeStyles: function(ctx) {
	      if (this.stroke) {
	        ctx.lineWidth = this.strokeWidth;
	        ctx.lineCap = this.strokeLineCap;
	        ctx.lineJoin = this.strokeLineJoin;
	        ctx.miterLimit = this.strokeMiterLimit;
	        ctx.strokeStyle = this.stroke.toLive
	          ? this.stroke.toLive(ctx, this)
	          : this.stroke;
	      }
	    },
	
	    _setFillStyles: function(ctx) {
	      if (this.fill) {
	        ctx.fillStyle = this.fill.toLive
	          ? this.fill.toLive(ctx, this)
	          : this.fill;
	      }
	    },
	
	    /**
	     * @private
	     * Sets line dash
	     * @param {CanvasRenderingContext2D} ctx Context to set the dash line on
	     * @param {Array} dashArray array representing dashes
	     * @param {Function} alternative function to call if browaser does not support lineDash
	     */
	    _setLineDash: function(ctx, dashArray, alternative) {
	      if (!dashArray) {
	        return;
	      }
	      // Spec requires the concatenation of two copies the dash list when the number of elements is odd
	      if (1 & dashArray.length) {
	        dashArray.push.apply(dashArray, dashArray);
	      }
	      if (supportsLineDash) {
	        ctx.setLineDash(dashArray);
	      }
	      else {
	        alternative && alternative(ctx);
	      }
	    },
	
	    /**
	     * Renders controls and borders for the object
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} [noTransform] When true, context is not transformed
	     */
	    _renderControls: function(ctx, noTransform) {
	      if (!this.active || noTransform
	          || (this.group && this.group !== this.canvas.getActiveGroup())) {
	        return;
	      }
	
	      var vpt = this.getViewportTransform(),
	          matrix = this.calcTransformMatrix(),
	          options;
	      matrix = fabric.util.multiplyTransformMatrices(vpt, matrix);
	      options = fabric.util.qrDecompose(matrix);
	
	      ctx.save();
	      ctx.translate(options.translateX, options.translateY);
	      ctx.lineWidth = 1 * this.borderScaleFactor;
	      if (!this.group) {
	        ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
	      }
	      if (this.group && this.group === this.canvas.getActiveGroup()) {
	        ctx.rotate(degreesToRadians(options.angle));
	        this.drawBordersInGroup(ctx, options);
	      }
	      else {
	        ctx.rotate(degreesToRadians(this.angle));
	        this.drawBorders(ctx);
	      }
	      this.drawControls(ctx);
	      ctx.restore();
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _setShadow: function(ctx) {
	      if (!this.shadow) {
	        return;
	      }
	
	      var multX = (this.canvas && this.canvas.viewportTransform[0]) || 1,
	          multY = (this.canvas && this.canvas.viewportTransform[3]) || 1,
	          scaling = this.getObjectScaling();
	      if (this.canvas && this.canvas._isRetinaScaling()) {
	        multX *= fabric.devicePixelRatio;
	        multY *= fabric.devicePixelRatio;
	      }
	      ctx.shadowColor = this.shadow.color;
	      ctx.shadowBlur = this.shadow.blur * (multX + multY) * (scaling.scaleX + scaling.scaleY) / 4;
	      ctx.shadowOffsetX = this.shadow.offsetX * multX * scaling.scaleX;
	      ctx.shadowOffsetY = this.shadow.offsetY * multY * scaling.scaleY;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _removeShadow: function(ctx) {
	      if (!this.shadow) {
	        return;
	      }
	
	      ctx.shadowColor = '';
	      ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Object} filler fabric.Pattern or fabric.Gradient
	     */
	    _applyPatternGradientTransform: function(ctx, filler) {
	      if (!filler.toLive) {
	        return;
	      }
	      var transform = filler.gradientTransform || filler.patternTransform;
	      if (transform) {
	        ctx.transform.apply(ctx, transform);
	      }
	      var offsetX = -this.width / 2 + filler.offsetX || 0,
	          offsetY = -this.height / 2 + filler.offsetY || 0;
	      ctx.translate(offsetX, offsetY);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderFill: function(ctx) {
	      if (!this.fill) {
	        return;
	      }
	
	      ctx.save();
	      this._applyPatternGradientTransform(ctx, this.fill);
	      if (this.fillRule === 'evenodd') {
	        ctx.fill('evenodd');
	      }
	      else {
	        ctx.fill();
	      }
	      ctx.restore();
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderStroke: function(ctx) {
	      if (!this.stroke || this.strokeWidth === 0) {
	        return;
	      }
	
	      if (this.shadow && !this.shadow.affectStroke) {
	        this._removeShadow(ctx);
	      }
	
	      ctx.save();
	      this._setLineDash(ctx, this.strokeDashArray, this._renderDashedStroke);
	      this._applyPatternGradientTransform(ctx, this.stroke);
	      ctx.stroke();
	      ctx.restore();
	    },
	
	    /**
	     * Clones an instance, some objects are async, so using callback method will work for every object.
	     * Using the direct return does not work for images and groups.
	     * @param {Function} callback Callback is invoked with a clone as a first argument
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {fabric.Object} clone of an instance
	     */
	    clone: function(callback, propertiesToInclude) {
	      if (this.constructor.fromObject) {
	        return this.constructor.fromObject(this.toObject(propertiesToInclude), callback);
	      }
	      return new fabric.Object(this.toObject(propertiesToInclude));
	    },
	
	    /**
	     * Creates an instance of fabric.Image out of an object
	     * @param {Function} callback callback, invoked with an instance as a first argument
	     * @param {Object} [options] for clone as image, passed to toDataURL
	     * @param {Boolean} [options.enableRetinaScaling] enable retina scaling for the cloned image
	     * @return {fabric.Object} thisArg
	     */
	    cloneAsImage: function(callback, options) {
	      var dataUrl = this.toDataURL(options);
	      fabric.util.loadImage(dataUrl, function(img) {
	        if (callback) {
	          callback(new fabric.Image(img));
	        }
	      });
	      return this;
	    },
	
	    /**
	     * Converts an object into a data-url-like string
	     * @param {Object} options Options object
	     * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
	     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
	     * @param {Number} [options.multiplier=1] Multiplier to scale by
	     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
	     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
	     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
	     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
	     * @param {Boolean} [options.enableRetina] Enable retina scaling for clone image. Introduce in 1.6.4
	     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
	     */
	    toDataURL: function(options) {
	      options || (options = { });
	
	      var el = fabric.util.createCanvasElement(),
	          boundingRect = this.getBoundingRect();
	
	      el.width = boundingRect.width;
	      el.height = boundingRect.height;
	      fabric.util.wrapElement(el, 'div');
	      var canvas = new fabric.StaticCanvas(el, { enableRetinaScaling: options.enableRetinaScaling });
	      // to avoid common confusion https://github.com/kangax/fabric.js/issues/806
	      if (options.format === 'jpg') {
	        options.format = 'jpeg';
	      }
	
	      if (options.format === 'jpeg') {
	        canvas.backgroundColor = '#fff';
	      }
	
	      var origParams = {
	        active: this.get('active'),
	        left: this.getLeft(),
	        top: this.getTop()
	      };
	
	      this.set('active', false);
	      this.setPositionByOrigin(new fabric.Point(canvas.getWidth() / 2, canvas.getHeight() / 2), 'center', 'center');
	
	      var originalCanvas = this.canvas;
	      canvas.add(this);
	      var data = canvas.toDataURL(options);
	
	      this.set(origParams).setCoords();
	      this.canvas = originalCanvas;
	
	      canvas.dispose();
	      canvas = null;
	
	      return data;
	    },
	
	    /**
	     * Returns true if specified type is identical to the type of an instance
	     * @param {String} type Type to check against
	     * @return {Boolean}
	     */
	    isType: function(type) {
	      return this.type === type;
	    },
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity of this instance
	     */
	    complexity: function() {
	      return 0;
	    },
	
	    /**
	     * Returns a JSON representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} JSON
	     */
	    toJSON: function(propertiesToInclude) {
	      // delegate, not alias
	      return this.toObject(propertiesToInclude);
	    },
	
	    /**
	     * Sets gradient (fill or stroke) of an object
	     * <b>Backwards incompatibility note:</b> This method was named "setGradientFill" until v1.1.0
	     * @param {String} property Property name 'stroke' or 'fill'
	     * @param {Object} [options] Options object
	     * @param {String} [options.type] Type of gradient 'radial' or 'linear'
	     * @param {Number} [options.x1=0] x-coordinate of start point
	     * @param {Number} [options.y1=0] y-coordinate of start point
	     * @param {Number} [options.x2=0] x-coordinate of end point
	     * @param {Number} [options.y2=0] y-coordinate of end point
	     * @param {Number} [options.r1=0] Radius of start point (only for radial gradients)
	     * @param {Number} [options.r2=0] Radius of end point (only for radial gradients)
	     * @param {Object} [options.colorStops] Color stops object eg. {0: 'ff0000', 1: '000000'}
	     * @param {Object} [options.gradientTransform] transforMatrix for gradient
	     * @return {fabric.Object} thisArg
	     * @chainable
	     * @see {@link http://jsfiddle.net/fabricjs/58y8b/|jsFiddle demo}
	     * @example <caption>Set linear gradient</caption>
	     * object.setGradient('fill', {
	     *   type: 'linear',
	     *   x1: -object.width / 2,
	     *   y1: 0,
	     *   x2: object.width / 2,
	     *   y2: 0,
	     *   colorStops: {
	     *     0: 'red',
	     *     0.5: '#005555',
	     *     1: 'rgba(0,0,255,0.5)'
	     *   }
	     * });
	     * canvas.renderAll();
	     * @example <caption>Set radial gradient</caption>
	     * object.setGradient('fill', {
	     *   type: 'radial',
	     *   x1: 0,
	     *   y1: 0,
	     *   x2: 0,
	     *   y2: 0,
	     *   r1: object.width / 2,
	     *   r2: 10,
	     *   colorStops: {
	     *     0: 'red',
	     *     0.5: '#005555',
	     *     1: 'rgba(0,0,255,0.5)'
	     *   }
	     * });
	     * canvas.renderAll();
	     */
	    setGradient: function(property, options) {
	      options || (options = { });
	
	      var gradient = { colorStops: [] };
	
	      gradient.type = options.type || (options.r1 || options.r2 ? 'radial' : 'linear');
	      gradient.coords = {
	        x1: options.x1,
	        y1: options.y1,
	        x2: options.x2,
	        y2: options.y2
	      };
	
	      if (options.r1 || options.r2) {
	        gradient.coords.r1 = options.r1;
	        gradient.coords.r2 = options.r2;
	      }
	
	      gradient.gradientTransform = options.gradientTransform;
	      fabric.Gradient.prototype.addColorStop.call(gradient, options.colorStops);
	
	      return this.set(property, fabric.Gradient.forObject(this, gradient));
	    },
	
	    /**
	     * Sets pattern fill of an object
	     * @param {Object} options Options object
	     * @param {(String|HTMLImageElement)} options.source Pattern source
	     * @param {String} [options.repeat=repeat] Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)
	     * @param {Number} [options.offsetX=0] Pattern horizontal offset from object's left/top corner
	     * @param {Number} [options.offsetY=0] Pattern vertical offset from object's left/top corner
	     * @return {fabric.Object} thisArg
	     * @chainable
	     * @see {@link http://jsfiddle.net/fabricjs/QT3pa/|jsFiddle demo}
	     * @example <caption>Set pattern</caption>
	     * fabric.util.loadImage('http://fabricjs.com/assets/escheresque_ste.png', function(img) {
	     *   object.setPatternFill({
	     *     source: img,
	     *     repeat: 'repeat'
	     *   });
	     *   canvas.renderAll();
	     * });
	     */
	    setPatternFill: function(options) {
	      return this.set('fill', new fabric.Pattern(options));
	    },
	
	    /**
	     * Sets {@link fabric.Object#shadow|shadow} of an object
	     * @param {Object|String} [options] Options object or string (e.g. "2px 2px 10px rgba(0,0,0,0.2)")
	     * @param {String} [options.color=rgb(0,0,0)] Shadow color
	     * @param {Number} [options.blur=0] Shadow blur
	     * @param {Number} [options.offsetX=0] Shadow horizontal offset
	     * @param {Number} [options.offsetY=0] Shadow vertical offset
	     * @return {fabric.Object} thisArg
	     * @chainable
	     * @see {@link http://jsfiddle.net/fabricjs/7gvJG/|jsFiddle demo}
	     * @example <caption>Set shadow with string notation</caption>
	     * object.setShadow('2px 2px 10px rgba(0,0,0,0.2)');
	     * canvas.renderAll();
	     * @example <caption>Set shadow with object notation</caption>
	     * object.setShadow({
	     *   color: 'red',
	     *   blur: 10,
	     *   offsetX: 20,
	     *   offsetY: 20
	     * });
	     * canvas.renderAll();
	     */
	    setShadow: function(options) {
	      return this.set('shadow', options ? new fabric.Shadow(options) : null);
	    },
	
	    /**
	     * Sets "color" of an instance (alias of `set('fill', &hellip;)`)
	     * @param {String} color Color value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    setColor: function(color) {
	      this.set('fill', color);
	      return this;
	    },
	
	    /**
	     * Sets "angle" of an instance
	     * @param {Number} angle Angle value (in degrees)
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    setAngle: function(angle) {
	      var shouldCenterOrigin = (this.originX !== 'center' || this.originY !== 'center') && this.centeredRotation;
	
	      if (shouldCenterOrigin) {
	        this._setOriginToCenter();
	      }
	
	      this.set('angle', angle);
	
	      if (shouldCenterOrigin) {
	        this._resetOrigin();
	      }
	
	      return this;
	    },
	
	    /**
	     * Centers object horizontally on canvas to which it was added last.
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    centerH: function () {
	      this.canvas && this.canvas.centerObjectH(this);
	      return this;
	    },
	
	    /**
	     * Centers object horizontally on current viewport of canvas to which it was added last.
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    viewportCenterH: function () {
	      this.canvas && this.canvas.viewportCenterObjectH(this);
	      return this;
	    },
	
	    /**
	     * Centers object vertically on canvas to which it was added last.
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    centerV: function () {
	      this.canvas && this.canvas.centerObjectV(this);
	      return this;
	    },
	
	    /**
	     * Centers object vertically on current viewport of canvas to which it was added last.
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    viewportCenterV: function () {
	      this.canvas && this.canvas.viewportCenterObjectV(this);
	      return this;
	    },
	
	    /**
	     * Centers object vertically and horizontally on canvas to which is was added last
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    center: function () {
	      this.canvas && this.canvas.centerObject(this);
	      return this;
	    },
	
	    /**
	     * Centers object on current viewport of canvas to which it was added last.
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    viewportCenter: function () {
	      this.canvas && this.canvas.viewportCenterObject(this);
	      return this;
	    },
	
	    /**
	     * Removes object from canvas to which it was added last
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    remove: function() {
	      this.canvas && this.canvas.remove(this);
	      return this;
	    },
	
	    /**
	     * Returns coordinates of a pointer relative to an object
	     * @param {Event} e Event to operate upon
	     * @param {Object} [pointer] Pointer to operate upon (instead of event)
	     * @return {Object} Coordinates of a pointer (x, y)
	     */
	    getLocalPointer: function(e, pointer) {
	      pointer = pointer || this.canvas.getPointer(e);
	      var pClicked = new fabric.Point(pointer.x, pointer.y),
	          objectLeftTop = this._getLeftTopCoords();
	      if (this.angle) {
	        pClicked = fabric.util.rotatePoint(
	          pClicked, objectLeftTop, degreesToRadians(-this.angle));
	      }
	      return {
	        x: pClicked.x - objectLeftTop.x,
	        y: pClicked.y - objectLeftTop.y
	      };
	    },
	
	    /**
	     * Sets canvas globalCompositeOperation for specific object
	     * custom composition operation for the particular object can be specifed using globalCompositeOperation property
	     * @param {CanvasRenderingContext2D} ctx Rendering canvas context
	     */
	    _setupCompositeOperation: function (ctx) {
	      if (this.globalCompositeOperation) {
	        ctx.globalCompositeOperation = this.globalCompositeOperation;
	      }
	    }
	  });
	
	  fabric.util.createAccessors(fabric.Object);
	
	  /**
	   * Alias for {@link fabric.Object.prototype.setAngle}
	   * @alias rotate -> setAngle
	   * @memberOf fabric.Object
	   */
	  fabric.Object.prototype.rotate = fabric.Object.prototype.setAngle;
	
	  extend(fabric.Object.prototype, fabric.Observable);
	
	  /**
	   * Defines the number of fraction digits to use when serializing object values.
	   * You can use it to increase/decrease precision of such values like left, top, scaleX, scaleY, etc.
	   * @static
	   * @memberOf fabric.Object
	   * @constant
	   * @type Number
	   */
	  fabric.Object.NUM_FRACTION_DIGITS = 2;
	
	  fabric.Object._fromObject = function(className, object, callback, forceAsync, extraParam) {
	    var klass = fabric[className];
	    object = clone(object, true);
	    if (forceAsync) {
	      fabric.util.enlivenPatterns([object.fill, object.stroke], function(patterns) {
	        object.fill = patterns[0];
	        object.stroke = patterns[1];
	        var instance = extraParam ? new klass(object[extraParam], object) : new klass(object);
	        callback && callback(instance);
	      });
	    }
	    else {
	      var instance = extraParam ? new klass(object[extraParam], object) : new klass(object);
	      callback && callback(instance);
	      return instance;
	    }
	  };
	
	  /**
	   * Unique id used internally when creating SVG elements
	   * @static
	   * @memberOf fabric.Object
	   * @type Number
	   */
	  fabric.Object.__uid = 0;
	
	})( true ? exports : this);
	
	
	(function() {
	
	  var degreesToRadians = fabric.util.degreesToRadians,
	      originXOffset = {
	        left: -0.5,
	        center: 0,
	        right: 0.5
	      },
	      originYOffset = {
	        top: -0.5,
	        center: 0,
	        bottom: 0.5
	      };
	
	  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
	
	    /**
	     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)
	     * @param {fabric.Point} point The point which corresponds to the originX and originY params
	     * @param {String} fromOriginX Horizontal origin: 'left', 'center' or 'right'
	     * @param {String} fromOriginY Vertical origin: 'top', 'center' or 'bottom'
	     * @param {String} toOriginX Horizontal origin: 'left', 'center' or 'right'
	     * @param {String} toOriginY Vertical origin: 'top', 'center' or 'bottom'
	     * @return {fabric.Point}
	     */
	    translateToGivenOrigin: function(point, fromOriginX, fromOriginY, toOriginX, toOriginY) {
	      var x = point.x,
	          y = point.y,
	          offsetX, offsetY, dim;
	
	      if (typeof fromOriginX === 'string') {
	        fromOriginX = originXOffset[fromOriginX];
	      }
	      else {
	        fromOriginX -= 0.5;
	      }
	
	      if (typeof toOriginX === 'string') {
	        toOriginX = originXOffset[toOriginX];
	      }
	      else {
	        toOriginX -= 0.5;
	      }
	
	      offsetX = toOriginX - fromOriginX;
	
	      if (typeof fromOriginY === 'string') {
	        fromOriginY = originYOffset[fromOriginY];
	      }
	      else {
	        fromOriginY -= 0.5;
	      }
	
	      if (typeof toOriginY === 'string') {
	        toOriginY = originYOffset[toOriginY];
	      }
	      else {
	        toOriginY -= 0.5;
	      }
	
	      offsetY = toOriginY - fromOriginY;
	
	      if (offsetX || offsetY) {
	        dim = this._getTransformedDimensions();
	        x = point.x + offsetX * dim.x;
	        y = point.y + offsetY * dim.y;
	      }
	
	      return new fabric.Point(x, y);
	    },
	
	    /**
	     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)
	     * @param {fabric.Point} point The point which corresponds to the originX and originY params
	     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
	     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
	     * @return {fabric.Point}
	     */
	    translateToCenterPoint: function(point, originX, originY) {
	      var p = this.translateToGivenOrigin(point, originX, originY, 'center', 'center');
	      if (this.angle) {
	        return fabric.util.rotatePoint(p, point, degreesToRadians(this.angle));
	      }
	      return p;
	    },
	
	    /**
	     * Translates the coordinates from center to origin coordinates (based on the object's dimensions)
	     * @param {fabric.Point} center The point which corresponds to center of the object
	     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
	     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
	     * @return {fabric.Point}
	     */
	    translateToOriginPoint: function(center, originX, originY) {
	      var p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
	      if (this.angle) {
	        return fabric.util.rotatePoint(p, center, degreesToRadians(this.angle));
	      }
	      return p;
	    },
	
	    /**
	     * Returns the real center coordinates of the object
	     * @return {fabric.Point}
	     */
	    getCenterPoint: function() {
	      var leftTop = new fabric.Point(this.left, this.top);
	      return this.translateToCenterPoint(leftTop, this.originX, this.originY);
	    },
	
	    /**
	     * Returns the coordinates of the object based on center coordinates
	     * @param {fabric.Point} point The point which corresponds to the originX and originY params
	     * @return {fabric.Point}
	     */
	    // getOriginPoint: function(center) {
	    //   return this.translateToOriginPoint(center, this.originX, this.originY);
	    // },
	
	    /**
	     * Returns the coordinates of the object as if it has a different origin
	     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
	     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
	     * @return {fabric.Point}
	     */
	    getPointByOrigin: function(originX, originY) {
	      var center = this.getCenterPoint();
	      return this.translateToOriginPoint(center, originX, originY);
	    },
	
	    /**
	     * Returns the point in local coordinates
	     * @param {fabric.Point} point The point relative to the global coordinate system
	     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
	     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
	     * @return {fabric.Point}
	     */
	    toLocalPoint: function(point, originX, originY) {
	      var center = this.getCenterPoint(),
	          p, p2;
	
	      if (typeof originX !== 'undefined' && typeof originY !== 'undefined' ) {
	        p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
	      }
	      else {
	        p = new fabric.Point(this.left, this.top);
	      }
	
	      p2 = new fabric.Point(point.x, point.y);
	      if (this.angle) {
	        p2 = fabric.util.rotatePoint(p2, center, -degreesToRadians(this.angle));
	      }
	      return p2.subtractEquals(p);
	    },
	
	    /**
	     * Returns the point in global coordinates
	     * @param {fabric.Point} The point relative to the local coordinate system
	     * @return {fabric.Point}
	     */
	    // toGlobalPoint: function(point) {
	    //   return fabric.util.rotatePoint(point, this.getCenterPoint(), degreesToRadians(this.angle)).addEquals(new fabric.Point(this.left, this.top));
	    // },
	
	    /**
	     * Sets the position of the object taking into consideration the object's origin
	     * @param {fabric.Point} pos The new position of the object
	     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
	     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
	     * @return {void}
	     */
	    setPositionByOrigin: function(pos, originX, originY) {
	      var center = this.translateToCenterPoint(pos, originX, originY),
	          position = this.translateToOriginPoint(center, this.originX, this.originY);
	
	      this.set('left', position.x);
	      this.set('top', position.y);
	    },
	
	    /**
	     * @param {String} to One of 'left', 'center', 'right'
	     */
	    adjustPosition: function(to) {
	      var angle = degreesToRadians(this.angle),
	          hypotFull = this.getWidth(),
	          xFull = Math.cos(angle) * hypotFull,
	          yFull = Math.sin(angle) * hypotFull,
	          offsetFrom, offsetTo;
	
	      //TODO: this function does not consider mixed situation like top, center.
	      if (typeof this.originX === 'string') {
	        offsetFrom = originXOffset[this.originX];
	      }
	      else {
	        offsetFrom = this.originX - 0.5;
	      }
	      if (typeof to === 'string') {
	        offsetTo = originXOffset[to];
	      }
	      else {
	        offsetTo = to - 0.5;
	      }
	      this.left += xFull * (offsetTo - offsetFrom);
	      this.top += yFull * (offsetTo - offsetFrom);
	      this.setCoords();
	      this.originX = to;
	    },
	
	    /**
	     * Sets the origin/position of the object to it's center point
	     * @private
	     * @return {void}
	     */
	    _setOriginToCenter: function() {
	      this._originalOriginX = this.originX;
	      this._originalOriginY = this.originY;
	
	      var center = this.getCenterPoint();
	
	      this.originX = 'center';
	      this.originY = 'center';
	
	      this.left = center.x;
	      this.top = center.y;
	    },
	
	    /**
	     * Resets the origin/position of the object to it's original origin
	     * @private
	     * @return {void}
	     */
	    _resetOrigin: function() {
	      var originPoint = this.translateToOriginPoint(
	        this.getCenterPoint(),
	        this._originalOriginX,
	        this._originalOriginY);
	
	      this.originX = this._originalOriginX;
	      this.originY = this._originalOriginY;
	
	      this.left = originPoint.x;
	      this.top = originPoint.y;
	
	      this._originalOriginX = null;
	      this._originalOriginY = null;
	    },
	
	    /**
	     * @private
	     */
	    _getLeftTopCoords: function() {
	      return this.translateToOriginPoint(this.getCenterPoint(), 'left', 'top');
	    }
	  });
	
	})();
	
	
	(function() {
	
	  function getCoords(oCoords) {
	    return [
	      new fabric.Point(oCoords.tl.x, oCoords.tl.y),
	      new fabric.Point(oCoords.tr.x, oCoords.tr.y),
	      new fabric.Point(oCoords.br.x, oCoords.br.y),
	      new fabric.Point(oCoords.bl.x, oCoords.bl.y)
	    ];
	  }
	
	  var degreesToRadians = fabric.util.degreesToRadians,
	      multiplyMatrices = fabric.util.multiplyTransformMatrices;
	
	  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
	
	    /**
	     * Object containing coordinates of object's controls
	     * @type Object
	     * @default
	     */
	    oCoords: null,
	
	    /**
	     * Checks if object intersects with an area formed by 2 points
	     * @param {Object} pointTL top-left point of area
	     * @param {Object} pointBR bottom-right point of area
	     * @return {Boolean} true if object intersects with an area formed by 2 points
	     */
	    intersectsWithRect: function(pointTL, pointBR) {
	      var oCoords = getCoords(this.oCoords),
	          intersection = fabric.Intersection.intersectPolygonRectangle(
	            oCoords,
	            pointTL,
	            pointBR
	          );
	      return intersection.status === 'Intersection';
	    },
	
	    /**
	     * Checks if object intersects with another object
	     * @param {Object} other Object to test
	     * @return {Boolean} true if object intersects with another object
	     */
	    intersectsWithObject: function(other) {
	      var intersection = fabric.Intersection.intersectPolygonPolygon(
	            getCoords(this.oCoords),
	            getCoords(other.oCoords)
	          );
	
	      return intersection.status === 'Intersection'
	        || other.isContainedWithinObject(this)
	        || this.isContainedWithinObject(other);
	    },
	
	    /**
	     * Checks if object is fully contained within area of another object
	     * @param {Object} other Object to test
	     * @return {Boolean} true if object is fully contained within area of another object
	     */
	    isContainedWithinObject: function(other) {
	      var points = getCoords(this.oCoords),
	          i = 0;
	      for (; i < 4; i++) {
	        if (!other.containsPoint(points[i])) {
	          return false;
	        }
	      }
	      return true;
	    },
	
	    /**
	     * Checks if object is fully contained within area formed by 2 points
	     * @param {Object} pointTL top-left point of area
	     * @param {Object} pointBR bottom-right point of area
	     * @return {Boolean} true if object is fully contained within area formed by 2 points
	     */
	    isContainedWithinRect: function(pointTL, pointBR) {
	      var boundingRect = this.getBoundingRect();
	
	      return (
	        boundingRect.left >= pointTL.x &&
	        boundingRect.left + boundingRect.width <= pointBR.x &&
	        boundingRect.top >= pointTL.y &&
	        boundingRect.top + boundingRect.height <= pointBR.y
	      );
	    },
	
	    /**
	     * Checks if point is inside the object
	     * @param {fabric.Point} point Point to check against
	     * @return {Boolean} true if point is inside the object
	     */
	    containsPoint: function(point) {
	      if (!this.oCoords) {
	        this.setCoords();
	      }
	      var lines = this._getImageLines(this.oCoords),
	          xPoints = this._findCrossPoints(point, lines);
	
	      // if xPoints is odd then point is inside the object
	      return (xPoints !== 0 && xPoints % 2 === 1);
	    },
	
	    /**
	     * Method that returns an object with the object edges in it, given the coordinates of the corners
	     * @private
	     * @param {Object} oCoords Coordinates of the object corners
	     */
	    _getImageLines: function(oCoords) {
	      return {
	        topline: {
	          o: oCoords.tl,
	          d: oCoords.tr
	        },
	        rightline: {
	          o: oCoords.tr,
	          d: oCoords.br
	        },
	        bottomline: {
	          o: oCoords.br,
	          d: oCoords.bl
	        },
	        leftline: {
	          o: oCoords.bl,
	          d: oCoords.tl
	        }
	      };
	    },
	
	    /**
	     * Helper method to determine how many cross points are between the 4 object edges
	     * and the horizontal line determined by a point on canvas
	     * @private
	     * @param {fabric.Point} point Point to check
	     * @param {Object} oCoords Coordinates of the object being evaluated
	     */
	     // remove yi, not used but left code here just in case.
	    _findCrossPoints: function(point, oCoords) {
	      var b1, b2, a1, a2, xi, // yi,
	          xcount = 0,
	          iLine;
	
	      for (var lineKey in oCoords) {
	        iLine = oCoords[lineKey];
	        // optimisation 1: line below point. no cross
	        if ((iLine.o.y < point.y) && (iLine.d.y < point.y)) {
	          continue;
	        }
	        // optimisation 2: line above point. no cross
	        if ((iLine.o.y >= point.y) && (iLine.d.y >= point.y)) {
	          continue;
	        }
	        // optimisation 3: vertical line case
	        if ((iLine.o.x === iLine.d.x) && (iLine.o.x >= point.x)) {
	          xi = iLine.o.x;
	          // yi = point.y;
	        }
	        // calculate the intersection point
	        else {
	          b1 = 0;
	          b2 = (iLine.d.y - iLine.o.y) / (iLine.d.x - iLine.o.x);
	          a1 = point.y - b1 * point.x;
	          a2 = iLine.o.y - b2 * iLine.o.x;
	
	          xi = -(a1 - a2) / (b1 - b2);
	          // yi = a1 + b1 * xi;
	        }
	        // dont count xi < point.x cases
	        if (xi >= point.x) {
	          xcount += 1;
	        }
	        // optimisation 4: specific for square images
	        if (xcount === 2) {
	          break;
	        }
	      }
	      return xcount;
	    },
	
	    /**
	     * Returns width of an object's bounding rectangle
	     * @deprecated since 1.0.4
	     * @return {Number} width value
	     */
	    getBoundingRectWidth: function() {
	      return this.getBoundingRect().width;
	    },
	
	    /**
	     * Returns height of an object's bounding rectangle
	     * @deprecated since 1.0.4
	     * @return {Number} height value
	     */
	    getBoundingRectHeight: function() {
	      return this.getBoundingRect().height;
	    },
	
	    /**
	     * Returns coordinates of object's bounding rectangle (left, top, width, height)
	     * the box is intented as aligned to axis of canvas.
	     * @param {Boolean} ignoreVpt bounding box will not be affected by viewportTransform
	     * @return {Object} Object with left, top, width, height properties
	     */
	    getBoundingRect: function(ignoreVpt) {
	      var coords = this.calcCoords(ignoreVpt);
	      return fabric.util.makeBoundingBoxFromPoints([
	        coords.tl,
	        coords.tr,
	        coords.br,
	        coords.bl
	      ]);
	    },
	
	    /**
	     * Returns width of an object bounding box counting transformations
	     * @return {Number} width value
	     */
	    getWidth: function() {
	      return this._getTransformedDimensions().x;
	    },
	
	    /**
	     * Returns height of an object bounding box counting transformations
	     * to be renamed in 2.0
	     * @return {Number} height value
	     */
	    getHeight: function() {
	      return this._getTransformedDimensions().y;
	    },
	
	    /**
	     * Makes sure the scale is valid and modifies it if necessary
	     * @private
	     * @param {Number} value
	     * @return {Number}
	     */
	    _constrainScale: function(value) {
	      if (Math.abs(value) < this.minScaleLimit) {
	        if (value < 0) {
	          return -this.minScaleLimit;
	        }
	        else {
	          return this.minScaleLimit;
	        }
	      }
	      return value;
	    },
	
	    /**
	     * Scales an object (equally by x and y)
	     * @param {Number} value Scale factor
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    scale: function(value) {
	      value = this._constrainScale(value);
	
	      if (value < 0) {
	        this.flipX = !this.flipX;
	        this.flipY = !this.flipY;
	        value *= -1;
	      }
	
	      this.scaleX = value;
	      this.scaleY = value;
	      return this.setCoords();
	    },
	
	    /**
	     * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)
	     * @param {Number} value New width value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    scaleToWidth: function(value) {
	      // adjust to bounding rect factor so that rotated shapes would fit as well
	      var boundingRectFactor = this.getBoundingRect().width / this.getWidth();
	      return this.scale(value / this.width / boundingRectFactor);
	    },
	
	    /**
	     * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)
	     * @param {Number} value New height value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    scaleToHeight: function(value) {
	      // adjust to bounding rect factor so that rotated shapes would fit as well
	      var boundingRectFactor = this.getBoundingRect().height / this.getHeight();
	      return this.scale(value / this.height / boundingRectFactor);
	    },
	
	    /**
	     * Calculate and returns the .coords of an object.
	     * @return {Object} Object with tl, tr, br, bl ....
	     * @chainable
	     */
	    calcCoords: function(ignoreVpt) {
	      var theta = degreesToRadians(this.angle),
	          vpt = this.getViewportTransform(),
	          dim = ignoreVpt ? this._getTransformedDimensions() : this._calculateCurrentDimensions(),
	          currentWidth = dim.x, currentHeight = dim.y,
	          sinTh = Math.sin(theta),
	          cosTh = Math.cos(theta),
	          _angle = currentWidth > 0 ? Math.atan(currentHeight / currentWidth) : 0,
	          _hypotenuse = (currentWidth / Math.cos(_angle)) / 2,
	          offsetX = Math.cos(_angle + theta) * _hypotenuse,
	          offsetY = Math.sin(_angle + theta) * _hypotenuse,
	          center = this.getCenterPoint(),
	          // offset added for rotate and scale actions
	          coords = ignoreVpt ? center : fabric.util.transformPoint(center, vpt),
	          tl  = new fabric.Point(coords.x - offsetX, coords.y - offsetY),
	          tr  = new fabric.Point(tl.x + (currentWidth * cosTh), tl.y + (currentWidth * sinTh)),
	          bl  = new fabric.Point(tl.x - (currentHeight * sinTh), tl.y + (currentHeight * cosTh)),
	          br  = new fabric.Point(coords.x + offsetX, coords.y + offsetY);
	      if (!ignoreVpt) {
	        var ml  = new fabric.Point((tl.x + bl.x) / 2, (tl.y + bl.y) / 2),
	            mt  = new fabric.Point((tr.x + tl.x) / 2, (tr.y + tl.y) / 2),
	            mr  = new fabric.Point((br.x + tr.x) / 2, (br.y + tr.y) / 2),
	            mb  = new fabric.Point((br.x + bl.x) / 2, (br.y + bl.y) / 2),
	            mtr = new fabric.Point(mt.x + sinTh * this.rotatingPointOffset, mt.y - cosTh * this.rotatingPointOffset);
	      }
	
	      // debugging
	
	      /* setTimeout(function() {
	         canvas.contextTop.fillStyle = 'green';
	         canvas.contextTop.fillRect(mb.x, mb.y, 3, 3);
	         canvas.contextTop.fillRect(bl.x, bl.y, 3, 3);
	         canvas.contextTop.fillRect(br.x, br.y, 3, 3);
	         canvas.contextTop.fillRect(tl.x, tl.y, 3, 3);
	         canvas.contextTop.fillRect(tr.x, tr.y, 3, 3);
	         canvas.contextTop.fillRect(ml.x, ml.y, 3, 3);
	         canvas.contextTop.fillRect(mr.x, mr.y, 3, 3);
	         canvas.contextTop.fillRect(mt.x, mt.y, 3, 3);
	         canvas.contextTop.fillRect(mtr.x, mtr.y, 3, 3);
	       }, 50); */
	
	      var coords = {
	        // corners
	        tl: tl, tr: tr, br: br, bl: bl,
	      };
	      if (!ignoreVpt) {
	        // middle
	        coords.ml = ml;
	        coords.mt = mt;
	        coords.mr = mr;
	        coords.mb = mb;
	        // rotating point
	        coords.mtr = mtr;
	      }
	      return coords;
	    },
	
	    /**
	     * Sets corner position coordinates based on current angle, width and height
	     * See https://github.com/kangax/fabric.js/wiki/When-to-call-setCoords
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    setCoords: function(ignoreZoom, skipAbsolute) {
	      this.oCoords = this.calcCoords(ignoreZoom);
	      if (!skipAbsolute && !ignoreZoom) {
	        this.absoluteCoords = this.calcCoords(true);
	      }
	      // set coordinates of the draggable boxes in the corners used to scale/rotate the image
	      ignoreZoom || this._setCornerCoords && this._setCornerCoords();
	
	      return this;
	    },
	
	    /*
	     * calculate rotation matrix of an object
	     * @return {Array} rotation matrix for the object
	     */
	    _calcRotateMatrix: function() {
	      if (this.angle) {
	        var theta = degreesToRadians(this.angle), cos = Math.cos(theta), sin = Math.sin(theta);
	        return [cos, sin, -sin, cos, 0, 0];
	      }
	      return [1, 0, 0, 1, 0, 0];
	    },
	
	    /*
	     * calculate trasform Matrix that represent current transformation from
	     * object properties.
	     * @return {Array} matrix Transform Matrix for the object
	     */
	    calcTransformMatrix: function() {
	      var center = this.getCenterPoint(),
	          translateMatrix = [1, 0, 0, 1, center.x, center.y],
	          rotateMatrix = this._calcRotateMatrix(),
	          dimensionMatrix = this._calcDimensionsTransformMatrix(this.skewX, this.skewY, true),
	          matrix = this.group ? this.group.calcTransformMatrix() : [1, 0, 0, 1, 0, 0];
	      matrix = multiplyMatrices(matrix, translateMatrix);
	      matrix = multiplyMatrices(matrix, rotateMatrix);
	      matrix = multiplyMatrices(matrix, dimensionMatrix);
	      return matrix;
	    },
	
	    _calcDimensionsTransformMatrix: function(skewX, skewY, flipping) {
	      var skewMatrixX = [1, 0, Math.tan(degreesToRadians(skewX)), 1],
	          skewMatrixY = [1, Math.tan(degreesToRadians(skewY)), 0, 1],
	          scaleX = this.scaleX * (flipping && this.flipX ? -1 : 1),
	          scaleY = this.scaleY * (flipping && this.flipY ? -1 : 1),
	          scaleMatrix = [scaleX, 0, 0, scaleY],
	          m = multiplyMatrices(scaleMatrix, skewMatrixX, true);
	      return multiplyMatrices(m, skewMatrixY, true);
	    }
	  });
	})();
	
	
	fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
	
	  /**
	   * Moves an object to the bottom of the stack of drawn objects
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  sendToBack: function() {
	    if (this.group) {
	      fabric.StaticCanvas.prototype.sendToBack.call(this.group, this);
	    }
	    else {
	      this.canvas.sendToBack(this);
	    }
	    return this;
	  },
	
	  /**
	   * Moves an object to the top of the stack of drawn objects
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  bringToFront: function() {
	    if (this.group) {
	      fabric.StaticCanvas.prototype.bringToFront.call(this.group, this);
	    }
	    else {
	      this.canvas.bringToFront(this);
	    }
	    return this;
	  },
	
	  /**
	   * Moves an object down in stack of drawn objects
	   * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  sendBackwards: function(intersecting) {
	    if (this.group) {
	      fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, intersecting);
	    }
	    else {
	      this.canvas.sendBackwards(this, intersecting);
	    }
	    return this;
	  },
	
	  /**
	   * Moves an object up in stack of drawn objects
	   * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  bringForward: function(intersecting) {
	    if (this.group) {
	      fabric.StaticCanvas.prototype.bringForward.call(this.group, this, intersecting);
	    }
	    else {
	      this.canvas.bringForward(this, intersecting);
	    }
	    return this;
	  },
	
	  /**
	   * Moves an object to specified level in stack of drawn objects
	   * @param {Number} index New position of object
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  moveTo: function(index) {
	    if (this.group) {
	      fabric.StaticCanvas.prototype.moveTo.call(this.group, this, index);
	    }
	    else {
	      this.canvas.moveTo(this, index);
	    }
	    return this;
	  }
	});
	
	
	/* _TO_SVG_START_ */
	(function() {
	
	  function getSvgColorString(prop, value) {
	    if (!value) {
	      return prop + ': none; ';
	    }
	    else if (value.toLive) {
	      return prop + ': url(#SVGID_' + value.id + '); ';
	    }
	    else {
	      var color = new fabric.Color(value),
	          str = prop + ': ' + color.toRgb() + '; ',
	          opacity = color.getAlpha();
	      if (opacity !== 1) {
	        //change the color in rgb + opacity
	        str += prop + '-opacity: ' + opacity.toString() + '; ';
	      }
	      return str;
	    }
	  }
	
	  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
	    /**
	     * Returns styles-string for svg-export
	     * @param {Boolean} skipShadow a boolean to skip shadow filter output
	     * @return {String}
	     */
	    getSvgStyles: function(skipShadow) {
	
	      var fillRule = this.fillRule,
	          strokeWidth = this.strokeWidth ? this.strokeWidth : '0',
	          strokeDashArray = this.strokeDashArray ? this.strokeDashArray.join(' ') : 'none',
	          strokeLineCap = this.strokeLineCap ? this.strokeLineCap : 'butt',
	          strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : 'miter',
	          strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : '4',
	          opacity = typeof this.opacity !== 'undefined' ? this.opacity : '1',
	          visibility = this.visible ? '' : ' visibility: hidden;',
	          filter = skipShadow ? '' : this.getSvgFilter(),
	          fill = getSvgColorString('fill', this.fill),
	          stroke = getSvgColorString('stroke', this.stroke);
	
	      return [
	        stroke,
	        'stroke-width: ', strokeWidth, '; ',
	        'stroke-dasharray: ', strokeDashArray, '; ',
	        'stroke-linecap: ', strokeLineCap, '; ',
	        'stroke-linejoin: ', strokeLineJoin, '; ',
	        'stroke-miterlimit: ', strokeMiterLimit, '; ',
	        fill,
	        'fill-rule: ', fillRule, '; ',
	        'opacity: ', opacity, ';',
	        filter,
	        visibility
	      ].join('');
	    },
	
	    /**
	     * Returns filter for svg shadow
	     * @return {String}
	     */
	    getSvgFilter: function() {
	      return this.shadow ? 'filter: url(#SVGID_' + this.shadow.id + ');' : '';
	    },
	
	    /**
	     * Returns id attribute for svg output
	     * @return {String}
	     */
	    getSvgId: function() {
	      return this.id ? 'id="' + this.id + '" ' : '';
	    },
	
	    /**
	     * Returns transform-string for svg-export
	     * @return {String}
	     */
	    getSvgTransform: function() {
	      if (this.group && this.group.type === 'path-group') {
	        return '';
	      }
	      var toFixed = fabric.util.toFixed,
	          angle = this.getAngle(),
	          skewX = (this.getSkewX() % 360),
	          skewY = (this.getSkewY() % 360),
	          center = this.getCenterPoint(),
	
	          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
	
	          translatePart = this.type === 'path-group' ? '' : 'translate(' +
	                            toFixed(center.x, NUM_FRACTION_DIGITS) +
	                            ' ' +
	                            toFixed(center.y, NUM_FRACTION_DIGITS) +
	                          ')',
	
	          anglePart = angle !== 0
	            ? (' rotate(' + toFixed(angle, NUM_FRACTION_DIGITS) + ')')
	            : '',
	
	          scalePart = (this.scaleX === 1 && this.scaleY === 1)
	            ? '' :
	            (' scale(' +
	              toFixed(this.scaleX, NUM_FRACTION_DIGITS) +
	              ' ' +
	              toFixed(this.scaleY, NUM_FRACTION_DIGITS) +
	            ')'),
	
	          skewXPart = skewX !== 0 ? ' skewX(' + toFixed(skewX, NUM_FRACTION_DIGITS) + ')' : '',
	
	          skewYPart = skewY !== 0 ? ' skewY(' + toFixed(skewY, NUM_FRACTION_DIGITS) + ')' : '',
	
	          addTranslateX = this.type === 'path-group' ? this.width : 0,
	
	          flipXPart = this.flipX ? ' matrix(-1 0 0 1 ' + addTranslateX + ' 0) ' : '',
	
	          addTranslateY = this.type === 'path-group' ? this.height : 0,
	
	          flipYPart = this.flipY ? ' matrix(1 0 0 -1 0 ' + addTranslateY + ')' : '';
	
	      return [
	        translatePart, anglePart, scalePart, flipXPart, flipYPart, skewXPart, skewYPart
	      ].join('');
	    },
	
	    /**
	     * Returns transform-string for svg-export from the transform matrix of single elements
	     * @return {String}
	     */
	    getSvgTransformMatrix: function() {
	      return this.transformMatrix ? ' matrix(' + this.transformMatrix.join(' ') + ') ' : '';
	    },
	
	    /**
	     * @private
	     */
	    _createBaseSVGMarkup: function() {
	      var markup = [];
	
	      if (this.fill && this.fill.toLive) {
	        markup.push(this.fill.toSVG(this, false));
	      }
	      if (this.stroke && this.stroke.toLive) {
	        markup.push(this.stroke.toSVG(this, false));
	      }
	      if (this.shadow) {
	        markup.push(this.shadow.toSVG(this));
	      }
	      return markup;
	    }
	  });
	})();
	/* _TO_SVG_END_ */
	
	
	(function() {
	
	  var extend = fabric.util.object.extend,
	      originalSet = 'stateProperties';
	
	  /*
	    Depends on `stateProperties`
	  */
	  function saveProps(origin, destination, props) {
	    var tmpObj = { }, deep = true;
	    props.forEach(function(prop) {
	      tmpObj[prop] = origin[prop];
	    });
	    extend(origin[destination], tmpObj, deep);
	  }
	
	  function _isEqual(origValue, currentValue, firstPass) {
	    if (!fabric.isLikelyNode && origValue instanceof Element) {
	      // avoid checking deep html elements
	      return origValue === currentValue;
	    }
	    else if (origValue instanceof Array) {
	      if (origValue.length !== currentValue.length) {
	        return false;
	      }
	      for (var i = 0, len = origValue.length; i < len; i++) {
	        if (origValue[i] !== currentValue[i]) {
	          return false;
	        }
	      }
	      return true;
	    }
	    else if (origValue && typeof origValue === 'object') {
	      if (!firstPass && Object.keys(origValue).length !== Object.keys(currentValue).length) {
	        return false;
	      }
	      for (var key in origValue) {
	        if (!_isEqual(origValue[key], currentValue[key])) {
	          return false;
	        }
	      }
	      return true;
	    }
	    else {
	      return origValue === currentValue;
	    }
	  }
	
	
	  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
	
	    /**
	     * Returns true if object state (one of its state properties) was changed
	     * @param {String} [propertySet] optional name for the set of property we want to save
	     * @return {Boolean} true if instance' state has changed since `{@link fabric.Object#saveState}` was called
	     */
	    hasStateChanged: function(propertySet) {
	      propertySet = propertySet || originalSet;
	      propertySet = '_' + propertySet;
	      return !_isEqual(this[propertySet], this, true);
	    },
	
	    /**
	     * Saves state of an object
	     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
	     * @return {fabric.Object} thisArg
	     */
	    saveState: function(options) {
	      var propertySet = options && options.propertySet || originalSet,
	          destination = '_' + propertySet;
	      if (!this[destination]) {
	        return this.setupState(options);
	      }
	      saveProps(this, destination, this[propertySet]);
	      if (options && options.stateProperties) {
	        saveProps(this, destination, options.stateProperties);
	      }
	      return this;
	    },
	
	    /**
	     * Setups state of an object
	     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
	     * @return {fabric.Object} thisArg
	     */
	    setupState: function(options) {
	      options = options || { };
	      var propertySet = options.propertySet || originalSet;
	      options.propertySet = propertySet;
	      this['_' + propertySet] = { };
	      this.saveState(options);
	      return this;
	    }
	  });
	})();
	
	
	(function() {
	
	  var degreesToRadians = fabric.util.degreesToRadians,
	      /* eslint-disable camelcase */
	      isVML = function() { return typeof G_vmlCanvasManager !== 'undefined'; };
	      /* eslint-enable camelcase */
	  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
	
	    /**
	     * The object interactivity controls.
	     * @private
	     */
	    _controlsVisibility: null,
	
	    /**
	     * Determines which corner has been clicked
	     * @private
	     * @param {Object} pointer The pointer indicating the mouse position
	     * @return {String|Boolean} corner code (tl, tr, bl, br, etc.), or false if nothing is found
	     */
	    _findTargetCorner: function(pointer) {
	      if (!this.hasControls || !this.active) {
	        return false;
	      }
	
	      var ex = pointer.x,
	          ey = pointer.y,
	          xPoints,
	          lines;
	      this.__corner = 0;
	      for (var i in this.oCoords) {
	
	        if (!this.isControlVisible(i)) {
	          continue;
	        }
	
	        if (i === 'mtr' && !this.hasRotatingPoint) {
	          continue;
	        }
	
	        if (this.get('lockUniScaling') &&
	           (i === 'mt' || i === 'mr' || i === 'mb' || i === 'ml')) {
	          continue;
	        }
	
	        lines = this._getImageLines(this.oCoords[i].corner);
	
	        // debugging
	
	        // canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);
	        // canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);
	
	        // canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);
	        // canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);
	
	        // canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);
	        // canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);
	
	        // canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);
	        // canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);
	
	    
	        xPoints = this._findCrossPoints({ x: ex, y: ey }, lines);
	        if (xPoints !== 0 && xPoints % 2 === 1) {
	          this.__corner = i;
	          return i;
	        }
	      }
	      return false;
	    },
	
	    /**
	     * Sets the coordinates of the draggable boxes in the corners of
	     * the image used to scale/rotate it.
	     * @private
	     */
	    _setCornerCoords: function() {
	      var coords = this.oCoords,
	          newTheta = degreesToRadians(45 - this.angle),
	          /* Math.sqrt(2 * Math.pow(this.cornerSize, 2)) / 2, */
	          /* 0.707106 stands for sqrt(2)/2 */
	          cornerHypotenuse = this.cornerSize * 0.707106,
	          cosHalfOffset = cornerHypotenuse * Math.cos(newTheta),
	          sinHalfOffset = cornerHypotenuse * Math.sin(newTheta),
	          x, y;
	
	      for (var point in coords) {
	        x = coords[point].x;
	        y = coords[point].y;
	        coords[point].corner = {
	          tl: {
	            x: x - sinHalfOffset,
	            y: y - cosHalfOffset
	          },
	          tr: {
	            x: x + cosHalfOffset,
	            y: y - sinHalfOffset
	          },
	          bl: {
	            x: x - cosHalfOffset,
	            y: y + sinHalfOffset
	          },
	          br: {
	            x: x + sinHalfOffset,
	            y: y + cosHalfOffset
	          }
	        };
	      }
	    },
	
	    /*
	     * Calculate object dimensions from its properties
	     * @private
	     */
	    _getNonTransformedDimensions: function() {
	      var strokeWidth = this.strokeWidth,
	          w = this.width + strokeWidth,
	          h = this.height + strokeWidth;
	      return { x: w, y: h };
	    },
	
	    /*
	     * @private
	     */
	    _getTransformedDimensions: function(skewX, skewY) {
	      if (typeof skewX === 'undefined') {
	        skewX = this.skewX;
	      }
	      if (typeof skewY === 'undefined') {
	        skewY = this.skewY;
	      }
	      var dimensions = this._getNonTransformedDimensions(),
	          dimX = dimensions.x / 2, dimY = dimensions.y / 2,
	          points = [
	            {
	              x: -dimX,
	              y: -dimY
	            },
	            {
	              x: dimX,
	              y: -dimY
	            },
	            {
	              x: -dimX,
	              y: dimY
	            },
	            {
	              x: dimX,
	              y: dimY
	            }],
	          i, transformMatrix = this._calcDimensionsTransformMatrix(skewX, skewY, false),
	          bbox;
	      for (i = 0; i < points.length; i++) {
	        points[i] = fabric.util.transformPoint(points[i], transformMatrix);
	      }
	      bbox = fabric.util.makeBoundingBoxFromPoints(points);
	      return { x: bbox.width, y: bbox.height };
	    },
	
	    /*
	     * private
	     */
	    _calculateCurrentDimensions: function()  {
	      var vpt = this.getViewportTransform(),
	          dim = this._getTransformedDimensions(),
	          p = fabric.util.transformPoint(dim, vpt, true);
	
	      return p.scalarAdd(2 * this.padding);
	    },
	
	    /**
	     * Draws a colored layer behind the object, inside its selection borders.
	     * Requires public options: padding, selectionBackgroundColor
	     * this function is called when the context is transformed
	     * @param {CanvasRenderingContext2D} ctx Context to draw on
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    drawSelectionBackground: function(ctx) {
	      if (!this.selectionBackgroundColor || this.group || !this.active) {
	        return this;
	      }
	      ctx.save();
	      var center = this.getCenterPoint(), wh = this._calculateCurrentDimensions(),
	          vpt = this.canvas.viewportTransform;
	      ctx.translate(center.x, center.y);
	      ctx.scale(1 / vpt[0], 1 / vpt[3]);
	      ctx.rotate(degreesToRadians(this.angle));
	      ctx.fillStyle = this.selectionBackgroundColor;
	      ctx.fillRect(-wh.x / 2, -wh.y / 2, wh.x, wh.y);
	      ctx.restore();
	      return this;
	    },
	
	    /**
	     * Draws borders of an object's bounding box.
	     * Requires public properties: width, height
	     * Requires public options: padding, borderColor
	     * @param {CanvasRenderingContext2D} ctx Context to draw on
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    drawBorders: function(ctx) {
	      if (!this.hasBorders) {
	        return this;
	      }
	
	      var wh = this._calculateCurrentDimensions(),
	          strokeWidth = 1 / this.borderScaleFactor,
	          width = wh.x + strokeWidth,
	          height = wh.y + strokeWidth;
	
	      ctx.save();
	      ctx.strokeStyle = this.borderColor;
	      this._setLineDash(ctx, this.borderDashArray, null);
	
	      ctx.strokeRect(
	        -width / 2,
	        -height / 2,
	        width,
	        height
	      );
	
	      if (this.hasRotatingPoint && this.isControlVisible('mtr') && !this.get('lockRotation') && this.hasControls) {
	
	        var rotateHeight = -height / 2;
	
	        ctx.beginPath();
	        ctx.moveTo(0, rotateHeight);
	        ctx.lineTo(0, rotateHeight - this.rotatingPointOffset);
	        ctx.closePath();
	        ctx.stroke();
	      }
	
	      ctx.restore();
	      return this;
	    },
	
	    /**
	     * Draws borders of an object's bounding box when it is inside a group.
	     * Requires public properties: width, height
	     * Requires public options: padding, borderColor
	     * @param {CanvasRenderingContext2D} ctx Context to draw on
	     * @param {object} options object representing current object parameters
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    drawBordersInGroup: function(ctx, options) {
	      if (!this.hasBorders) {
	        return this;
	      }
	
	      var p = this._getNonTransformedDimensions(),
	          matrix = fabric.util.customTransformMatrix(options.scaleX, options.scaleY, options.skewX),
	          wh = fabric.util.transformPoint(p, matrix),
	          strokeWidth = 1 / this.borderScaleFactor,
	          width = wh.x + strokeWidth,
	          height = wh.y + strokeWidth;
	
	      ctx.save();
	      this._setLineDash(ctx, this.borderDashArray, null);
	      ctx.strokeStyle = this.borderColor;
	
	      ctx.strokeRect(
	        -width / 2,
	        -height / 2,
	        width,
	        height
	      );
	
	      ctx.restore();
	      return this;
	    },
	
	    /**
	     * Draws corners of an object's bounding box.
	     * Requires public properties: width, height
	     * Requires public options: cornerSize, padding
	     * @param {CanvasRenderingContext2D} ctx Context to draw on
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    drawControls: function(ctx) {
	      if (!this.hasControls) {
	        return this;
	      }
	
	      var wh = this._calculateCurrentDimensions(),
	          width = wh.x,
	          height = wh.y,
	          scaleOffset = this.cornerSize,
	          left = -(width + scaleOffset) / 2,
	          top = -(height + scaleOffset) / 2,
	          methodName = this.transparentCorners ? 'stroke' : 'fill';
	
	      ctx.save();
	      ctx.strokeStyle = ctx.fillStyle = this.cornerColor;
	      if (!this.transparentCorners) {
	        ctx.strokeStyle = this.cornerStrokeColor;
	      }
	      this._setLineDash(ctx, this.cornerDashArray, null);
	
	      // top-left
	      this._drawControl('tl', ctx, methodName,
	        left,
	        top);
	
	      // top-right
	      this._drawControl('tr', ctx, methodName,
	        left + width,
	        top);
	
	      // bottom-left
	      this._drawControl('bl', ctx, methodName,
	        left,
	        top + height);
	
	      // bottom-right
	      this._drawControl('br', ctx, methodName,
	        left + width,
	        top + height);
	
	      if (!this.get('lockUniScaling')) {
	
	        // middle-top
	        this._drawControl('mt', ctx, methodName,
	          left + width / 2,
	          top);
	
	        // middle-bottom
	        this._drawControl('mb', ctx, methodName,
	          left + width / 2,
	          top + height);
	
	        // middle-right
	        this._drawControl('mr', ctx, methodName,
	          left + width,
	          top + height / 2);
	
	        // middle-left
	        this._drawControl('ml', ctx, methodName,
	          left,
	          top + height / 2);
	      }
	
	      // middle-top-rotate
	      if (this.hasRotatingPoint) {
	        this._drawControl('mtr', ctx, methodName,
	          left + width / 2,
	          top - this.rotatingPointOffset);
	      }
	
	      ctx.restore();
	
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _drawControl: function(control, ctx, methodName, left, top) {
	      if (!this.isControlVisible(control)) {
	        return;
	      }
	      var size = this.cornerSize, stroke = !this.transparentCorners && this.cornerStrokeColor;
	      switch (this.cornerStyle) {
	        case 'circle':
	          ctx.beginPath();
	          ctx.arc(left + size / 2, top + size / 2, size / 2, 0, 2 * Math.PI, false);
	          ctx[methodName]();
	          if (stroke) {
	            ctx.stroke();
	          }
	          break;
	        default:
	          isVML() || this.transparentCorners || ctx.clearRect(left, top, size, size);
	          ctx[methodName + 'Rect'](left, top, size, size);
	          if (stroke) {
	            ctx.strokeRect(left, top, size, size);
	          }
	      }
	    },
	
	    /**
	     * Returns true if the specified control is visible, false otherwise.
	     * @param {String} controlName The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
	     * @returns {Boolean} true if the specified control is visible, false otherwise
	     */
	    isControlVisible: function(controlName) {
	      return this._getControlsVisibility()[controlName];
	    },
	
	    /**
	     * Sets the visibility of the specified control.
	     * @param {String} controlName The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
	     * @param {Boolean} visible true to set the specified control visible, false otherwise
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    setControlVisible: function(controlName, visible) {
	      this._getControlsVisibility()[controlName] = visible;
	      return this;
	    },
	
	    /**
	     * Sets the visibility state of object controls.
	     * @param {Object} [options] Options object
	     * @param {Boolean} [options.bl] true to enable the bottom-left control, false to disable it
	     * @param {Boolean} [options.br] true to enable the bottom-right control, false to disable it
	     * @param {Boolean} [options.mb] true to enable the middle-bottom control, false to disable it
	     * @param {Boolean} [options.ml] true to enable the middle-left control, false to disable it
	     * @param {Boolean} [options.mr] true to enable the middle-right control, false to disable it
	     * @param {Boolean} [options.mt] true to enable the middle-top control, false to disable it
	     * @param {Boolean} [options.tl] true to enable the top-left control, false to disable it
	     * @param {Boolean} [options.tr] true to enable the top-right control, false to disable it
	     * @param {Boolean} [options.mtr] true to enable the middle-top-rotate control, false to disable it
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    setControlsVisibility: function(options) {
	      options || (options = { });
	
	      for (var p in options) {
	        this.setControlVisible(p, options[p]);
	      }
	      return this;
	    },
	
	    /**
	     * Returns the instance of the control visibility set for this object.
	     * @private
	     * @returns {Object}
	     */
	    _getControlsVisibility: function() {
	      if (!this._controlsVisibility) {
	        this._controlsVisibility = {
	          tl: true,
	          tr: true,
	          br: true,
	          bl: true,
	          ml: true,
	          mt: true,
	          mr: true,
	          mb: true,
	          mtr: true
	        };
	      }
	      return this._controlsVisibility;
	    }
	  });
	})();
	
	
	fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {
	
	  /**
	   * Animation duration (in ms) for fx* methods
	   * @type Number
	   * @default
	   */
	  FX_DURATION: 500,
	
	  /**
	   * Centers object horizontally with animation.
	   * @param {fabric.Object} object Object to center
	   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
	   * @param {Function} [callbacks.onComplete] Invoked on completion
	   * @param {Function} [callbacks.onChange] Invoked on every step of animation
	   * @return {fabric.Canvas} thisArg
	   * @chainable
	   */
	  fxCenterObjectH: function (object, callbacks) {
	    callbacks = callbacks || { };
	
	    var empty = function() { },
	        onComplete = callbacks.onComplete || empty,
	        onChange = callbacks.onChange || empty,
	        _this = this;
	
	    fabric.util.animate({
	      startValue: object.get('left'),
	      endValue: this.getCenter().left,
	      duration: this.FX_DURATION,
	      onChange: function(value) {
	        object.set('left', value);
	        _this.renderAll();
	        onChange();
	      },
	      onComplete: function() {
	        object.setCoords();
	        onComplete();
	      }
	    });
	
	    return this;
	  },
	
	  /**
	   * Centers object vertically with animation.
	   * @param {fabric.Object} object Object to center
	   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
	   * @param {Function} [callbacks.onComplete] Invoked on completion
	   * @param {Function} [callbacks.onChange] Invoked on every step of animation
	   * @return {fabric.Canvas} thisArg
	   * @chainable
	   */
	  fxCenterObjectV: function (object, callbacks) {
	    callbacks = callbacks || { };
	
	    var empty = function() { },
	        onComplete = callbacks.onComplete || empty,
	        onChange = callbacks.onChange || empty,
	        _this = this;
	
	    fabric.util.animate({
	      startValue: object.get('top'),
	      endValue: this.getCenter().top,
	      duration: this.FX_DURATION,
	      onChange: function(value) {
	        object.set('top', value);
	        _this.renderAll();
	        onChange();
	      },
	      onComplete: function() {
	        object.setCoords();
	        onComplete();
	      }
	    });
	
	    return this;
	  },
	
	  /**
	   * Same as `fabric.Canvas#remove` but animated
	   * @param {fabric.Object} object Object to remove
	   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
	   * @param {Function} [callbacks.onComplete] Invoked on completion
	   * @param {Function} [callbacks.onChange] Invoked on every step of animation
	   * @return {fabric.Canvas} thisArg
	   * @chainable
	   */
	  fxRemove: function (object, callbacks) {
	    callbacks = callbacks || { };
	
	    var empty = function() { },
	        onComplete = callbacks.onComplete || empty,
	        onChange = callbacks.onChange || empty,
	        _this = this;
	
	    fabric.util.animate({
	      startValue: object.get('opacity'),
	      endValue: 0,
	      duration: this.FX_DURATION,
	      onStart: function() {
	        object.set('active', false);
	      },
	      onChange: function(value) {
	        object.set('opacity', value);
	        _this.renderAll();
	        onChange();
	      },
	      onComplete: function () {
	        _this.remove(object);
	        onComplete();
	      }
	    });
	
	    return this;
	  }
	});
	
	fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
	  /**
	   * Animates object's properties
	   * @param {String|Object} property Property to animate (if string) or properties to animate (if object)
	   * @param {Number|Object} value Value to animate property to (if string was given first) or options object
	   * @return {fabric.Object} thisArg
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#animation}
	   * @chainable
	   *
	   * As object — multiple properties
	   *
	   * object.animate({ left: ..., top: ... });
	   * object.animate({ left: ..., top: ... }, { duration: ... });
	   *
	   * As string — one property
	   *
	   * object.animate('left', ...);
	   * object.animate('left', { duration: ... });
	   *
	   */
	  animate: function() {
	    if (arguments[0] && typeof arguments[0] === 'object') {
	      var propsToAnimate = [], prop, skipCallbacks;
	      for (prop in arguments[0]) {
	        propsToAnimate.push(prop);
	      }
	      for (var i = 0, len = propsToAnimate.length; i < len; i++) {
	        prop = propsToAnimate[i];
	        skipCallbacks = i !== len - 1;
	        this._animate(prop, arguments[0][prop], arguments[1], skipCallbacks);
	      }
	    }
	    else {
	      this._animate.apply(this, arguments);
	    }
	    return this;
	  },
	
	  /**
	   * @private
	   * @param {String} property Property to animate
	   * @param {String} to Value to animate to
	   * @param {Object} [options] Options object
	   * @param {Boolean} [skipCallbacks] When true, callbacks like onchange and oncomplete are not invoked
	   */
	  _animate: function(property, to, options, skipCallbacks) {
	    var _this = this, propPair;
	
	    to = to.toString();
	
	    if (!options) {
	      options = { };
	    }
	    else {
	      options = fabric.util.object.clone(options);
	    }
	
	    if (~property.indexOf('.')) {
	      propPair = property.split('.');
	    }
	
	    var currentValue = propPair
	      ? this.get(propPair[0])[propPair[1]]
	      : this.get(property);
	
	    if (!('from' in options)) {
	      options.from = currentValue;
	    }
	
	    if (~to.indexOf('=')) {
	      to = currentValue + parseFloat(to.replace('=', ''));
	    }
	    else {
	      to = parseFloat(to);
	    }
	
	    fabric.util.animate({
	      startValue: options.from,
	      endValue: to,
	      byValue: options.by,
	      easing: options.easing,
	      duration: options.duration,
	      abort: options.abort && function() {
	        return options.abort.call(_this);
	      },
	      onChange: function(value) {
	        if (propPair) {
	          _this[propPair[0]][propPair[1]] = value;
	        }
	        else {
	          _this.set(property, value);
	        }
	        if (skipCallbacks) {
	          return;
	        }
	        options.onChange && options.onChange();
	      },
	      onComplete: function() {
	        if (skipCallbacks) {
	          return;
	        }
	
	        _this.setCoords();
	        options.onComplete && options.onComplete();
	      }
	    });
	  }
	});
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      clone = fabric.util.object.clone,
	      coordProps = { x1: 1, x2: 1, y1: 1, y2: 1 },
	      supportsLineDash = fabric.StaticCanvas.supports('setLineDash');
	
	  if (fabric.Line) {
	    fabric.warn('fabric.Line is already defined');
	    return;
	  }
	
	  var cacheProperties = fabric.Object.prototype.cacheProperties.concat();
	  cacheProperties.push(
	    'x1',
	    'x2',
	    'y1',
	    'y2'
	  );
	
	  /**
	   * Line class
	   * @class fabric.Line
	   * @extends fabric.Object
	   * @see {@link fabric.Line#initialize} for constructor definition
	   */
	  fabric.Line = fabric.util.createClass(fabric.Object, /** @lends fabric.Line.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'line',
	
	    /**
	     * x value or first line edge
	     * @type Number
	     * @default
	     */
	    x1: 0,
	
	    /**
	     * y value or first line edge
	     * @type Number
	     * @default
	     */
	    y1: 0,
	
	    /**
	     * x value or second line edge
	     * @type Number
	     * @default
	     */
	    x2: 0,
	
	    /**
	     * y value or second line edge
	     * @type Number
	     * @default
	     */
	    y2: 0,
	
	    cacheProperties: cacheProperties,
	
	    /**
	     * Constructor
	     * @param {Array} [points] Array of points
	     * @param {Object} [options] Options object
	     * @return {fabric.Line} thisArg
	     */
	    initialize: function(points, options) {
	      if (!points) {
	        points = [0, 0, 0, 0];
	      }
	
	      this.callSuper('initialize', options);
	
	      this.set('x1', points[0]);
	      this.set('y1', points[1]);
	      this.set('x2', points[2]);
	      this.set('y2', points[3]);
	
	      this._setWidthHeight(options);
	    },
	
	    /**
	     * @private
	     * @param {Object} [options] Options
	     */
	    _setWidthHeight: function(options) {
	      options || (options = { });
	
	      this.width = Math.abs(this.x2 - this.x1);
	      this.height = Math.abs(this.y2 - this.y1);
	
	      this.left = 'left' in options
	        ? options.left
	        : this._getLeftToOriginX();
	
	      this.top = 'top' in options
	        ? options.top
	        : this._getTopToOriginY();
	    },
	
	    /**
	     * @private
	     * @param {String} key
	     * @param {*} value
	     */
	    _set: function(key, value) {
	      this.callSuper('_set', key, value);
	      if (typeof coordProps[key] !== 'undefined') {
	        this._setWidthHeight();
	      }
	      return this;
	    },
	
	    /**
	     * @private
	     * @return {Number} leftToOriginX Distance from left edge of canvas to originX of Line.
	     */
	    _getLeftToOriginX: makeEdgeToOriginGetter(
	      { // property names
	        origin: 'originX',
	        axis1: 'x1',
	        axis2: 'x2',
	        dimension: 'width'
	      },
	      { // possible values of origin
	        nearest: 'left',
	        center: 'center',
	        farthest: 'right'
	      }
	    ),
	
	    /**
	     * @private
	     * @return {Number} topToOriginY Distance from top edge of canvas to originY of Line.
	     */
	    _getTopToOriginY: makeEdgeToOriginGetter(
	      { // property names
	        origin: 'originY',
	        axis1: 'y1',
	        axis2: 'y2',
	        dimension: 'height'
	      },
	      { // possible values of origin
	        nearest: 'top',
	        center: 'center',
	        farthest: 'bottom'
	      }
	    ),
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} noTransform
	     */
	    _render: function(ctx, noTransform) {
	      ctx.beginPath();
	
	      if (noTransform) {
	        //  Line coords are distances from left-top of canvas to origin of line.
	        //  To render line in a path-group, we need to translate them to
	        //  distances from center of path-group to center of line.
	        var cp = this.getCenterPoint();
	        ctx.translate(
	          cp.x - this.strokeWidth / 2,
	          cp.y - this.strokeWidth / 2
	        );
	      }
	
	      if (!this.strokeDashArray || this.strokeDashArray && supportsLineDash) {
	        // move from center (of virtual box) to its left/top corner
	        // we can't assume x1, y1 is top left and x2, y2 is bottom right
	        var p = this.calcLinePoints();
	        ctx.moveTo(p.x1, p.y1);
	        ctx.lineTo(p.x2, p.y2);
	      }
	
	      ctx.lineWidth = this.strokeWidth;
	
	      // TODO: test this
	      // make sure setting "fill" changes color of a line
	      // (by copying fillStyle to strokeStyle, since line is stroked, not filled)
	      var origStrokeStyle = ctx.strokeStyle;
	      ctx.strokeStyle = this.stroke || ctx.fillStyle;
	      this.stroke && this._renderStroke(ctx);
	      ctx.strokeStyle = origStrokeStyle;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderDashedStroke: function(ctx) {
	      var p = this.calcLinePoints();
	
	      ctx.beginPath();
	      fabric.util.drawDashedLine(ctx, p.x1, p.y1, p.x2, p.y2, this.strokeDashArray);
	      ctx.closePath();
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @methd toObject
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      return extend(this.callSuper('toObject', propertiesToInclude), this.calcLinePoints());
	    },
	
	    /*
	     * Calculate object dimensions from its properties
	     * @private
	     */
	    _getNonTransformedDimensions: function() {
	      var dim = this.callSuper('_getNonTransformedDimensions');
	      if (this.strokeLineCap === 'butt') {
	        if (dim.x === 0) {
	          dim.y -= this.strokeWidth;
	        }
	        if (dim.y === 0) {
	          dim.x -= this.strokeWidth;
	        }
	      }
	      return dim;
	    },
	
	    /**
	     * Recalculates line points given width and height
	     * @private
	     */
	    calcLinePoints: function() {
	      var xMult = this.x1 <= this.x2 ? -1 : 1,
	          yMult = this.y1 <= this.y2 ? -1 : 1,
	          x1 = (xMult * this.width * 0.5),
	          y1 = (yMult * this.height * 0.5),
	          x2 = (xMult * this.width * -0.5),
	          y2 = (yMult * this.height * -0.5);
	
	      return {
	        x1: x1,
	        x2: x2,
	        y1: y1,
	        y2: y2
	      };
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns SVG representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var markup = this._createBaseSVGMarkup(),
	          p = { x1: this.x1, x2: this.x2, y1: this.y1, y2: this.y2 };
	
	      if (!(this.group && this.group.type === 'path-group')) {
	        p = this.calcLinePoints();
	      }
	      markup.push(
	        '<line ', this.getSvgId(),
	          'x1="', p.x1,
	          '" y1="', p.y1,
	          '" x2="', p.x2,
	          '" y2="', p.y2,
	          '" style="', this.getSvgStyles(),
	          '" transform="', this.getSvgTransform(),
	          this.getSvgTransformMatrix(),
	        '"/>\n'
	      );
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity
	     */
	    complexity: function() {
	      return 1;
	    }
	  });
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Line.fromElement})
	   * @static
	   * @memberOf fabric.Line
	   * @see http://www.w3.org/TR/SVG/shapes.html#LineElement
	   */
	  fabric.Line.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x1 y1 x2 y2'.split(' '));
	
	  /**
	   * Returns fabric.Line instance from an SVG element
	   * @static
	   * @memberOf fabric.Line
	   * @param {SVGElement} element Element to parse
	   * @param {Object} [options] Options object
	   * @return {fabric.Line} instance of fabric.Line
	   */
	  fabric.Line.fromElement = function(element, options) {
	    options = options || { };
	    var parsedAttributes = fabric.parseAttributes(element, fabric.Line.ATTRIBUTE_NAMES),
	        points = [
	          parsedAttributes.x1 || 0,
	          parsedAttributes.y1 || 0,
	          parsedAttributes.x2 || 0,
	          parsedAttributes.y2 || 0
	        ];
	    options.originX = 'left';
	    options.originY = 'top';
	    return new fabric.Line(points, extend(parsedAttributes, options));
	  };
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Returns fabric.Line instance from an object representation
	   * @static
	   * @memberOf fabric.Line
	   * @param {Object} object Object to create an instance from
	   * @param {function} [callback] invoked with new instance as first argument
	   * @param {Boolean} [forceAsync] Force an async behaviour trying to create pattern first
	   * @return {fabric.Line} instance of fabric.Line
	   */
	  fabric.Line.fromObject = function(object, callback, forceAsync) {
	    function _callback(instance) {
	      delete instance.points;
	      callback && callback(instance);
	    };
	    var options = clone(object, true);
	    options.points = [object.x1, object.y1, object.x2, object.y2];
	    var line = fabric.Object._fromObject('Line', options, _callback, forceAsync, 'points');
	    if (line) {
	      delete line.points;
	    }
	    return line;
	  };
	
	  /**
	   * Produces a function that calculates distance from canvas edge to Line origin.
	   */
	  function makeEdgeToOriginGetter(propertyNames, originValues) {
	    var origin = propertyNames.origin,
	        axis1 = propertyNames.axis1,
	        axis2 = propertyNames.axis2,
	        dimension = propertyNames.dimension,
	        nearest = originValues.nearest,
	        center = originValues.center,
	        farthest = originValues.farthest;
	
	    return function() {
	      switch (this.get(origin)) {
	        case nearest:
	          return Math.min(this.get(axis1), this.get(axis2));
	        case center:
	          return Math.min(this.get(axis1), this.get(axis2)) + (0.5 * this.get(dimension));
	        case farthest:
	          return Math.max(this.get(axis1), this.get(axis2));
	      }
	    };
	
	  }
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      pi = Math.PI,
	      extend = fabric.util.object.extend;
	
	  if (fabric.Circle) {
	    fabric.warn('fabric.Circle is already defined.');
	    return;
	  }
	
	  var cacheProperties = fabric.Object.prototype.cacheProperties.concat();
	  cacheProperties.push(
	    'radius'
	  );
	
	  /**
	   * Circle class
	   * @class fabric.Circle
	   * @extends fabric.Object
	   * @see {@link fabric.Circle#initialize} for constructor definition
	   */
	  fabric.Circle = fabric.util.createClass(fabric.Object, /** @lends fabric.Circle.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'circle',
	
	    /**
	     * Radius of this circle
	     * @type Number
	     * @default
	     */
	    radius: 0,
	
	    /**
	     * Start angle of the circle, moving clockwise
	     * @type Number
	     * @default 0
	     */
	    startAngle: 0,
	
	    /**
	     * End angle of the circle
	     * @type Number
	     * @default 2Pi
	     */
	    endAngle: pi * 2,
	
	    cacheProperties: cacheProperties,
	
	    /**
	     * Constructor
	     * @param {Object} [options] Options object
	     * @return {fabric.Circle} thisArg
	     */
	    initialize: function(options) {
	      this.callSuper('initialize', options);
	      this.set('radius', options && options.radius || 0);
	    },
	
	    /**
	     * @private
	     * @param {String} key
	     * @param {*} value
	     * @return {fabric.Circle} thisArg
	     */
	    _set: function(key, value) {
	      this.callSuper('_set', key, value);
	
	      if (key === 'radius') {
	        this.setRadius(value);
	      }
	
	      return this;
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      return this.callSuper('toObject', ['radius', 'startAngle', 'endAngle'].concat(propertiesToInclude));
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns svg representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var markup = this._createBaseSVGMarkup(), x = 0, y = 0,
	          angle = (this.endAngle - this.startAngle) % ( 2 * pi);
	
	      if (angle === 0) {
	        if (this.group && this.group.type === 'path-group') {
	          x = this.left + this.radius;
	          y = this.top + this.radius;
	        }
	        markup.push(
	          '<circle ', this.getSvgId(),
	            'cx="' + x + '" cy="' + y + '" ',
	            'r="', this.radius,
	            '" style="', this.getSvgStyles(),
	            '" transform="', this.getSvgTransform(),
	            ' ', this.getSvgTransformMatrix(),
	          '"/>\n'
	        );
	      }
	      else {
	        var startX = Math.cos(this.startAngle) * this.radius,
	            startY = Math.sin(this.startAngle) * this.radius,
	            endX = Math.cos(this.endAngle) * this.radius,
	            endY = Math.sin(this.endAngle) * this.radius,
	            largeFlag = angle > pi ? '1' : '0';
	
	        markup.push(
	          '<path d="M ' + startX + ' ' + startY,
	          ' A ' + this.radius + ' ' + this.radius,
	          ' 0 ', +largeFlag + ' 1', ' ' + endX + ' ' + endY,
	          '" style="', this.getSvgStyles(),
	          '" transform="', this.getSvgTransform(),
	          ' ', this.getSvgTransformMatrix(),
	          '"/>\n'
	        );
	      }
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx context to render on
	     * @param {Boolean} [noTransform] When true, context is not transformed
	     */
	    _render: function(ctx, noTransform) {
	      ctx.beginPath();
	      ctx.arc(noTransform ? this.left + this.radius : 0,
	              noTransform ? this.top + this.radius : 0,
	              this.radius,
	              this.startAngle,
	              this.endAngle, false);
	      this._renderFill(ctx);
	      this._renderStroke(ctx);
	    },
	
	    /**
	     * Returns horizontal radius of an object (according to how an object is scaled)
	     * @return {Number}
	     */
	    getRadiusX: function() {
	      return this.get('radius') * this.get('scaleX');
	    },
	
	    /**
	     * Returns vertical radius of an object (according to how an object is scaled)
	     * @return {Number}
	     */
	    getRadiusY: function() {
	      return this.get('radius') * this.get('scaleY');
	    },
	
	    /**
	     * Sets radius of an object (and updates width accordingly)
	     * @return {fabric.Circle} thisArg
	     */
	    setRadius: function(value) {
	      this.radius = value;
	      return this.set('width', value * 2).set('height', value * 2);
	    },
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity of this instance
	     */
	    complexity: function() {
	      return 1;
	    }
	  });
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Circle.fromElement})
	   * @static
	   * @memberOf fabric.Circle
	   * @see: http://www.w3.org/TR/SVG/shapes.html#CircleElement
	   */
	  fabric.Circle.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy r'.split(' '));
	
	  /**
	   * Returns {@link fabric.Circle} instance from an SVG element
	   * @static
	   * @memberOf fabric.Circle
	   * @param {SVGElement} element Element to parse
	   * @param {Object} [options] Options object
	   * @throws {Error} If value of `r` attribute is missing or invalid
	   * @return {fabric.Circle} Instance of fabric.Circle
	   */
	  fabric.Circle.fromElement = function(element, options) {
	    options || (options = { });
	
	    var parsedAttributes = fabric.parseAttributes(element, fabric.Circle.ATTRIBUTE_NAMES);
	
	    if (!isValidRadius(parsedAttributes)) {
	      throw new Error('value of `r` attribute is required and can not be negative');
	    }
	
	    parsedAttributes.left = parsedAttributes.left || 0;
	    parsedAttributes.top = parsedAttributes.top || 0;
	
	    var obj = new fabric.Circle(extend(parsedAttributes, options));
	
	    obj.left -= obj.radius;
	    obj.top -= obj.radius;
	    return obj;
	  };
	
	  /**
	   * @private
	   */
	  function isValidRadius(attributes) {
	    return (('radius' in attributes) && (attributes.radius >= 0));
	  }
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Returns {@link fabric.Circle} instance from an object representation
	   * @static
	   * @memberOf fabric.Circle
	   * @param {Object} object Object to create an instance from
	   * @param {function} [callback] invoked with new instance as first argument
	   * @param {Boolean} [forceAsync] Force an async behaviour trying to create pattern first
	   * @return {Object} Instance of fabric.Circle
	   */
	  fabric.Circle.fromObject = function(object, callback, forceAsync) {
	    return fabric.Object._fromObject('Circle', object, callback, forceAsync);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { });
	
	  if (fabric.Triangle) {
	    fabric.warn('fabric.Triangle is already defined');
	    return;
	  }
	
	  /**
	   * Triangle class
	   * @class fabric.Triangle
	   * @extends fabric.Object
	   * @return {fabric.Triangle} thisArg
	   * @see {@link fabric.Triangle#initialize} for constructor definition
	   */
	  fabric.Triangle = fabric.util.createClass(fabric.Object, /** @lends fabric.Triangle.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'triangle',
	
	    /**
	     * Constructor
	     * @param {Object} [options] Options object
	     * @return {Object} thisArg
	     */
	    initialize: function(options) {
	      this.callSuper('initialize', options);
	      this.set('width', options && options.width || 100)
	          .set('height', options && options.height || 100);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _render: function(ctx) {
	      var widthBy2 = this.width / 2,
	          heightBy2 = this.height / 2;
	
	      ctx.beginPath();
	      ctx.moveTo(-widthBy2, heightBy2);
	      ctx.lineTo(0, -heightBy2);
	      ctx.lineTo(widthBy2, heightBy2);
	      ctx.closePath();
	
	      this._renderFill(ctx);
	      this._renderStroke(ctx);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderDashedStroke: function(ctx) {
	      var widthBy2 = this.width / 2,
	          heightBy2 = this.height / 2;
	
	      ctx.beginPath();
	      fabric.util.drawDashedLine(ctx, -widthBy2, heightBy2, 0, -heightBy2, this.strokeDashArray);
	      fabric.util.drawDashedLine(ctx, 0, -heightBy2, widthBy2, heightBy2, this.strokeDashArray);
	      fabric.util.drawDashedLine(ctx, widthBy2, heightBy2, -widthBy2, heightBy2, this.strokeDashArray);
	      ctx.closePath();
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns SVG representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var markup = this._createBaseSVGMarkup(),
	          widthBy2 = this.width / 2,
	          heightBy2 = this.height / 2,
	          points = [
	            -widthBy2 + ' ' + heightBy2,
	            '0 ' + -heightBy2,
	            widthBy2 + ' ' + heightBy2
	          ]
	          .join(',');
	
	      markup.push(
	        '<polygon ', this.getSvgId(),
	          'points="', points,
	          '" style="', this.getSvgStyles(),
	          '" transform="', this.getSvgTransform(),
	        '"/>'
	      );
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity of this instance
	     */
	    complexity: function() {
	      return 1;
	    }
	  });
	
	  /**
	   * Returns {@link fabric.Triangle} instance from an object representation
	   * @static
	   * @memberOf fabric.Triangle
	   * @param {Object} object Object to create an instance from
	   * @param {function} [callback] invoked with new instance as first argument
	   * @param {Boolean} [forceAsync] Force an async behaviour trying to create pattern first
	   * @return {fabric.Triangle}
	   */
	  fabric.Triangle.fromObject = function(object, callback, forceAsync) {
	    return fabric.Object._fromObject('Triangle', object, callback, forceAsync);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      piBy2   = Math.PI * 2,
	      extend = fabric.util.object.extend;
	
	  if (fabric.Ellipse) {
	    fabric.warn('fabric.Ellipse is already defined.');
	    return;
	  }
	
	  var cacheProperties = fabric.Object.prototype.cacheProperties.concat();
	  cacheProperties.push(
	    'rx',
	    'ry'
	  );
	
	  /**
	   * Ellipse class
	   * @class fabric.Ellipse
	   * @extends fabric.Object
	   * @return {fabric.Ellipse} thisArg
	   * @see {@link fabric.Ellipse#initialize} for constructor definition
	   */
	  fabric.Ellipse = fabric.util.createClass(fabric.Object, /** @lends fabric.Ellipse.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'ellipse',
	
	    /**
	     * Horizontal radius
	     * @type Number
	     * @default
	     */
	    rx:   0,
	
	    /**
	     * Vertical radius
	     * @type Number
	     * @default
	     */
	    ry:   0,
	
	    cacheProperties: cacheProperties,
	
	    /**
	     * Constructor
	     * @param {Object} [options] Options object
	     * @return {fabric.Ellipse} thisArg
	     */
	    initialize: function(options) {
	      this.callSuper('initialize', options);
	      this.set('rx', options && options.rx || 0);
	      this.set('ry', options && options.ry || 0);
	    },
	
	    /**
	     * @private
	     * @param {String} key
	     * @param {*} value
	     * @return {fabric.Ellipse} thisArg
	     */
	    _set: function(key, value) {
	      this.callSuper('_set', key, value);
	      switch (key) {
	
	        case 'rx':
	          this.rx = value;
	          this.set('width', value * 2);
	          break;
	
	        case 'ry':
	          this.ry = value;
	          this.set('height', value * 2);
	          break;
	
	      }
	      return this;
	    },
	
	    /**
	     * Returns horizontal radius of an object (according to how an object is scaled)
	     * @return {Number}
	     */
	    getRx: function() {
	      return this.get('rx') * this.get('scaleX');
	    },
	
	    /**
	     * Returns Vertical radius of an object (according to how an object is scaled)
	     * @return {Number}
	     */
	    getRy: function() {
	      return this.get('ry') * this.get('scaleY');
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns svg representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var markup = this._createBaseSVGMarkup(), x = 0, y = 0;
	      if (this.group && this.group.type === 'path-group') {
	        x = this.left + this.rx;
	        y = this.top + this.ry;
	      }
	      markup.push(
	        '<ellipse ', this.getSvgId(),
	          'cx="', x, '" cy="', y, '" ',
	          'rx="', this.rx,
	          '" ry="', this.ry,
	          '" style="', this.getSvgStyles(),
	          '" transform="', this.getSvgTransform(),
	          this.getSvgTransformMatrix(),
	        '"/>\n'
	      );
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx context to render on
	     * @param {Boolean} [noTransform] When true, context is not transformed
	     */
	    _render: function(ctx, noTransform) {
	      ctx.beginPath();
	      ctx.save();
	      ctx.transform(1, 0, 0, this.ry / this.rx, 0, 0);
	      ctx.arc(
	        noTransform ? this.left + this.rx : 0,
	        noTransform ? (this.top + this.ry) * this.rx / this.ry : 0,
	        this.rx,
	        0,
	        piBy2,
	        false);
	      ctx.restore();
	      this._renderFill(ctx);
	      this._renderStroke(ctx);
	    },
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity
	     */
	    complexity: function() {
	      return 1;
	    }
	  });
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Ellipse.fromElement})
	   * @static
	   * @memberOf fabric.Ellipse
	   * @see http://www.w3.org/TR/SVG/shapes.html#EllipseElement
	   */
	  fabric.Ellipse.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy rx ry'.split(' '));
	
	  /**
	   * Returns {@link fabric.Ellipse} instance from an SVG element
	   * @static
	   * @memberOf fabric.Ellipse
	   * @param {SVGElement} element Element to parse
	   * @param {Object} [options] Options object
	   * @return {fabric.Ellipse}
	   */
	  fabric.Ellipse.fromElement = function(element, options) {
	    options || (options = { });
	
	    var parsedAttributes = fabric.parseAttributes(element, fabric.Ellipse.ATTRIBUTE_NAMES);
	
	    parsedAttributes.left = parsedAttributes.left || 0;
	    parsedAttributes.top = parsedAttributes.top || 0;
	
	    var ellipse = new fabric.Ellipse(extend(parsedAttributes, options));
	
	    ellipse.top -= ellipse.ry;
	    ellipse.left -= ellipse.rx;
	    return ellipse;
	  };
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Returns {@link fabric.Ellipse} instance from an object representation
	   * @static
	   * @memberOf fabric.Ellipse
	   * @param {Object} object Object to create an instance from
	   * @param {function} [callback] invoked with new instance as first argument
	   * @param {Boolean} [forceAsync] Force an async behaviour trying to create pattern first
	   * @return {fabric.Ellipse}
	   */
	  fabric.Ellipse.fromObject = function(object, callback, forceAsync) {
	    return fabric.Object._fromObject('Ellipse', object, callback, forceAsync);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend;
	
	  if (fabric.Rect) {
	    fabric.warn('fabric.Rect is already defined');
	    return;
	  }
	
	  var stateProperties = fabric.Object.prototype.stateProperties.concat();
	  stateProperties.push('rx', 'ry');
	
	  /**
	   * Rectangle class
	   * @class fabric.Rect
	   * @extends fabric.Object
	   * @return {fabric.Rect} thisArg
	   * @see {@link fabric.Rect#initialize} for constructor definition
	   */
	  fabric.Rect = fabric.util.createClass(fabric.Object, /** @lends fabric.Rect.prototype */ {
	
	    /**
	     * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})
	     * as well as for history (undo/redo) purposes
	     * @type Array
	     */
	    stateProperties: stateProperties,
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'rect',
	
	    /**
	     * Horizontal border radius
	     * @type Number
	     * @default
	     */
	    rx:   0,
	
	    /**
	     * Vertical border radius
	     * @type Number
	     * @default
	     */
	    ry:   0,
	
	    /**
	     * Used to specify dash pattern for stroke on this object
	     * @type Array
	     */
	    strokeDashArray: null,
	
	    /**
	     * Constructor
	     * @param {Object} [options] Options object
	     * @return {Object} thisArg
	     */
	    initialize: function(options) {
	      this.callSuper('initialize', options);
	      this._initRxRy();
	    },
	
	    /**
	     * Initializes rx/ry attributes
	     * @private
	     */
	    _initRxRy: function() {
	      if (this.rx && !this.ry) {
	        this.ry = this.rx;
	      }
	      else if (this.ry && !this.rx) {
	        this.rx = this.ry;
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} noTransform
	     */
	    _render: function(ctx, noTransform) {
	
	      // optimize 1x1 case (used in spray brush)
	      if (this.width === 1 && this.height === 1) {
	        ctx.fillRect(-0.5, -0.5, 1, 1);
	        return;
	      }
	
	      var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0,
	          ry = this.ry ? Math.min(this.ry, this.height / 2) : 0,
	          w = this.width,
	          h = this.height,
	          x = noTransform ? this.left : -this.width / 2,
	          y = noTransform ? this.top : -this.height / 2,
	          isRounded = rx !== 0 || ry !== 0,
	          /* "magic number" for bezier approximations of arcs (http://itc.ktu.lt/itc354/Riskus354.pdf) */
	          k = 1 - 0.5522847498;
	      ctx.beginPath();
	
	      ctx.moveTo(x + rx, y);
	
	      ctx.lineTo(x + w - rx, y);
	      isRounded && ctx.bezierCurveTo(x + w - k * rx, y, x + w, y + k * ry, x + w, y + ry);
	
	      ctx.lineTo(x + w, y + h - ry);
	      isRounded && ctx.bezierCurveTo(x + w, y + h - k * ry, x + w - k * rx, y + h, x + w - rx, y + h);
	
	      ctx.lineTo(x + rx, y + h);
	      isRounded && ctx.bezierCurveTo(x + k * rx, y + h, x, y + h - k * ry, x, y + h - ry);
	
	      ctx.lineTo(x, y + ry);
	      isRounded && ctx.bezierCurveTo(x, y + k * ry, x + k * rx, y, x + rx, y);
	
	      ctx.closePath();
	
	      this._renderFill(ctx);
	      this._renderStroke(ctx);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderDashedStroke: function(ctx) {
	      var x = -this.width / 2,
	          y = -this.height / 2,
	          w = this.width,
	          h = this.height;
	
	      ctx.beginPath();
	      fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);
	      fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);
	      fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);
	      fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);
	      ctx.closePath();
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns svg representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var markup = this._createBaseSVGMarkup(), x = this.left, y = this.top;
	      if (!(this.group && this.group.type === 'path-group')) {
	        x = -this.width / 2;
	        y = -this.height / 2;
	      }
	      markup.push(
	        '<rect ', this.getSvgId(),
	          'x="', x, '" y="', y,
	          '" rx="', this.get('rx'), '" ry="', this.get('ry'),
	          '" width="', this.width, '" height="', this.height,
	          '" style="', this.getSvgStyles(),
	          '" transform="', this.getSvgTransform(),
	          this.getSvgTransformMatrix(),
	        '"/>\n');
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity
	     */
	    complexity: function() {
	      return 1;
	    }
	  });
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by `fabric.Rect.fromElement`)
	   * @static
	   * @memberOf fabric.Rect
	   * @see: http://www.w3.org/TR/SVG/shapes.html#RectElement
	   */
	  fabric.Rect.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x y rx ry width height'.split(' '));
	
	  /**
	   * Returns {@link fabric.Rect} instance from an SVG element
	   * @static
	   * @memberOf fabric.Rect
	   * @param {SVGElement} element Element to parse
	   * @param {Object} [options] Options object
	   * @return {fabric.Rect} Instance of fabric.Rect
	   */
	  fabric.Rect.fromElement = function(element, options) {
	    if (!element) {
	      return null;
	    }
	    options = options || { };
	
	    var parsedAttributes = fabric.parseAttributes(element, fabric.Rect.ATTRIBUTE_NAMES);
	
	    parsedAttributes.left = parsedAttributes.left || 0;
	    parsedAttributes.top  = parsedAttributes.top  || 0;
	    var rect = new fabric.Rect(extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));
	    rect.visible = rect.visible && rect.width > 0 && rect.height > 0;
	    return rect;
	  };
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Returns {@link fabric.Rect} instance from an object representation
	   * @static
	   * @memberOf fabric.Rect
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] Callback to invoke when an fabric.Rect instance is created
	   * @param {Boolean} [forceAsync] Force an async behaviour trying to create pattern first
	   * @return {Object} instance of fabric.Rect
	   */
	  fabric.Rect.fromObject = function(object, callback, forceAsync) {
	    return fabric.Object._fromObject('Rect', object, callback, forceAsync);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { });
	
	  if (fabric.Polyline) {
	    fabric.warn('fabric.Polyline is already defined');
	    return;
	  }
	
	  var cacheProperties = fabric.Object.prototype.cacheProperties.concat();
	  cacheProperties.push('points');
	
	  /**
	   * Polyline class
	   * @class fabric.Polyline
	   * @extends fabric.Object
	   * @see {@link fabric.Polyline#initialize} for constructor definition
	   */
	  fabric.Polyline = fabric.util.createClass(fabric.Object, /** @lends fabric.Polyline.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'polyline',
	
	    /**
	     * Points array
	     * @type Array
	     * @default
	     */
	    points: null,
	
	    /**
	     * Minimum X from points values, necessary to offset points
	     * @type Number
	     * @default
	     */
	    minX: 0,
	
	    /**
	     * Minimum Y from points values, necessary to offset points
	     * @type Number
	     * @default
	     */
	    minY: 0,
	
	    cacheProperties: cacheProperties,
	
	    /**
	     * Constructor
	     * @param {Array} points Array of points (where each point is an object with x and y)
	     * @param {Object} [options] Options object
	     * @return {fabric.Polyline} thisArg
	     * @example
	     * var poly = new fabric.Polyline([
	     *     { x: 10, y: 10 },
	     *     { x: 50, y: 30 },
	     *     { x: 40, y: 70 },
	     *     { x: 60, y: 50 },
	     *     { x: 100, y: 150 },
	     *     { x: 40, y: 100 }
	     *   ], {
	     *   stroke: 'red',
	     *   left: 100,
	     *   top: 100
	     * });
	     */
	    initialize: function(points, options) {
	      return fabric.Polygon.prototype.initialize.call(this, points, options);
	    },
	
	    /**
	     * @private
	     */
	    _calcDimensions: function() {
	      return fabric.Polygon.prototype._calcDimensions.call(this);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      return fabric.Polygon.prototype.toObject.call(this, propertiesToInclude);
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns SVG representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      return fabric.Polygon.prototype.toSVG.call(this, reviver);
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} noTransform
	     */
	    _render: function(ctx, noTransform) {
	      if (!fabric.Polygon.prototype.commonRender.call(this, ctx, noTransform)) {
	        return;
	      }
	      this._renderFill(ctx);
	      this._renderStroke(ctx);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderDashedStroke: function(ctx) {
	      var p1, p2;
	
	      ctx.beginPath();
	      for (var i = 0, len = this.points.length; i < len; i++) {
	        p1 = this.points[i];
	        p2 = this.points[i + 1] || p1;
	        fabric.util.drawDashedLine(ctx, p1.x, p1.y, p2.x, p2.y, this.strokeDashArray);
	      }
	    },
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity of this instance
	     */
	    complexity: function() {
	      return this.get('points').length;
	    }
	  });
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Polyline.fromElement})
	   * @static
	   * @memberOf fabric.Polyline
	   * @see: http://www.w3.org/TR/SVG/shapes.html#PolylineElement
	   */
	  fabric.Polyline.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();
	
	  /**
	   * Returns fabric.Polyline instance from an SVG element
	   * @static
	   * @memberOf fabric.Polyline
	   * @param {SVGElement} element Element to parse
	   * @param {Object} [options] Options object
	   * @return {fabric.Polyline} Instance of fabric.Polyline
	   */
	  fabric.Polyline.fromElement = function(element, options) {
	    if (!element) {
	      return null;
	    }
	    options || (options = { });
	
	    var points = fabric.parsePointsAttribute(element.getAttribute('points')),
	        parsedAttributes = fabric.parseAttributes(element, fabric.Polyline.ATTRIBUTE_NAMES);
	
	    return new fabric.Polyline(points, fabric.util.object.extend(parsedAttributes, options));
	  };
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Returns fabric.Polyline instance from an object representation
	   * @static
	   * @memberOf fabric.Polyline
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
	   * @param {Boolean} [forceAsync] Force an async behaviour trying to create pattern first
	   * @return {fabric.Polyline} Instance of fabric.Polyline
	   */
	  fabric.Polyline.fromObject = function(object, callback, forceAsync) {
	    return fabric.Object._fromObject('Polyline', object, callback, forceAsync, 'points');
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      min = fabric.util.array.min,
	      max = fabric.util.array.max,
	      toFixed = fabric.util.toFixed;
	
	  if (fabric.Polygon) {
	    fabric.warn('fabric.Polygon is already defined');
	    return;
	  }
	
	  var cacheProperties = fabric.Object.prototype.cacheProperties.concat();
	  cacheProperties.push('points');
	
	  /**
	   * Polygon class
	   * @class fabric.Polygon
	   * @extends fabric.Object
	   * @see {@link fabric.Polygon#initialize} for constructor definition
	   */
	  fabric.Polygon = fabric.util.createClass(fabric.Object, /** @lends fabric.Polygon.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'polygon',
	
	    /**
	     * Points array
	     * @type Array
	     * @default
	     */
	    points: null,
	
	    /**
	     * Minimum X from points values, necessary to offset points
	     * @type Number
	     * @default
	     */
	    minX: 0,
	
	    /**
	     * Minimum Y from points values, necessary to offset points
	     * @type Number
	     * @default
	     */
	    minY: 0,
	
	    cacheProperties: cacheProperties,
	
	    /**
	     * Constructor
	     * @param {Array} points Array of points
	     * @param {Object} [options] Options object
	     * @return {fabric.Polygon} thisArg
	     */
	    initialize: function(points, options) {
	      options = options || {};
	      this.points = points || [];
	      this.callSuper('initialize', options);
	      this._calcDimensions();
	      if (!('top' in options)) {
	        this.top = this.minY;
	      }
	      if (!('left' in options)) {
	        this.left = this.minX;
	      }
	      this.pathOffset = {
	        x: this.minX + this.width / 2,
	        y: this.minY + this.height / 2
	      };
	    },
	
	    /**
	     * @private
	     */
	    _calcDimensions: function() {
	
	      var points = this.points,
	          minX = min(points, 'x'),
	          minY = min(points, 'y'),
	          maxX = max(points, 'x'),
	          maxY = max(points, 'y');
	
	      this.width = (maxX - minX) || 0;
	      this.height = (maxY - minY) || 0;
	      this.minX = minX || 0;
	      this.minY = minY || 0;
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      return extend(this.callSuper('toObject', propertiesToInclude), {
	        points: this.points.concat()
	      });
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns svg representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var points = [], addTransform,
	          markup = this._createBaseSVGMarkup();
	
	      for (var i = 0, len = this.points.length; i < len; i++) {
	        points.push(toFixed(this.points[i].x, 2), ',', toFixed(this.points[i].y, 2), ' ');
	      }
	      if (!(this.group && this.group.type === 'path-group')) {
	        addTransform = ' translate(' + (-this.pathOffset.x) + ', ' + (-this.pathOffset.y) + ') ';
	      }
	      markup.push(
	        '<', this.type, ' ', this.getSvgId(),
	          'points="', points.join(''),
	          '" style="', this.getSvgStyles(),
	          '" transform="', this.getSvgTransform(), addTransform,
	          ' ', this.getSvgTransformMatrix(),
	        '"/>\n'
	      );
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} noTransform
	     */
	    _render: function(ctx, noTransform) {
	      if (!this.commonRender(ctx, noTransform)) {
	        return;
	      }
	      this._renderFill(ctx);
	      if (this.stroke || this.strokeDashArray) {
	        ctx.closePath();
	        this._renderStroke(ctx);
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} noTransform
	     */
	    commonRender: function(ctx, noTransform) {
	      var point, len = this.points.length,
	          x = noTransform ? 0 : this.pathOffset.x,
	          y = noTransform ? 0 : this.pathOffset.y;
	
	      if (!len || isNaN(this.points[len - 1].y)) {
	        // do not draw if no points or odd points
	        // NaN comes from parseFloat of a empty string in parser
	        return false;
	      }
	      ctx.beginPath();
	      ctx.moveTo(this.points[0].x - x, this.points[0].y - y);
	      for (var i = 0; i < len; i++) {
	        point = this.points[i];
	        ctx.lineTo(point.x - x, point.y - y);
	      }
	      return true;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderDashedStroke: function(ctx) {
	      fabric.Polyline.prototype._renderDashedStroke.call(this, ctx);
	      ctx.closePath();
	    },
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity of this instance
	     */
	    complexity: function() {
	      return this.points.length;
	    }
	  });
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by `fabric.Polygon.fromElement`)
	   * @static
	   * @memberOf fabric.Polygon
	   * @see: http://www.w3.org/TR/SVG/shapes.html#PolygonElement
	   */
	  fabric.Polygon.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();
	
	  /**
	   * Returns {@link fabric.Polygon} instance from an SVG element
	   * @static
	   * @memberOf fabric.Polygon
	   * @param {SVGElement} element Element to parse
	   * @param {Object} [options] Options object
	   * @return {fabric.Polygon} Instance of fabric.Polygon
	   */
	  fabric.Polygon.fromElement = function(element, options) {
	    if (!element) {
	      return null;
	    }
	
	    options || (options = { });
	
	    var points = fabric.parsePointsAttribute(element.getAttribute('points')),
	        parsedAttributes = fabric.parseAttributes(element, fabric.Polygon.ATTRIBUTE_NAMES);
	
	    return new fabric.Polygon(points, extend(parsedAttributes, options));
	  };
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Returns fabric.Polygon instance from an object representation
	   * @static
	   * @memberOf fabric.Polygon
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
	   * @param {Boolean} [forceAsync] Force an async behaviour trying to create pattern first
	   * @return {fabric.Polygon} Instance of fabric.Polygon
	   */
	  fabric.Polygon.fromObject = function(object, callback, forceAsync) {
	    return fabric.Object._fromObject('Polygon', object, callback, forceAsync, 'points');
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      min = fabric.util.array.min,
	      max = fabric.util.array.max,
	      extend = fabric.util.object.extend,
	      _toString = Object.prototype.toString,
	      drawArc = fabric.util.drawArc,
	      commandLengths = {
	        m: 2,
	        l: 2,
	        h: 1,
	        v: 1,
	        c: 6,
	        s: 4,
	        q: 4,
	        t: 2,
	        a: 7
	      },
	      repeatedCommands = {
	        m: 'l',
	        M: 'L'
	      };
	
	  if (fabric.Path) {
	    fabric.warn('fabric.Path is already defined');
	    return;
	  }
	
	  var cacheProperties = fabric.Object.prototype.cacheProperties.concat();
	  cacheProperties.push('path');
	
	  /**
	   * Path class
	   * @class fabric.Path
	   * @extends fabric.Object
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#path_and_pathgroup}
	   * @see {@link fabric.Path#initialize} for constructor definition
	   */
	  fabric.Path = fabric.util.createClass(fabric.Object, /** @lends fabric.Path.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'path',
	
	    /**
	     * Array of path points
	     * @type Array
	     * @default
	     */
	    path: null,
	
	    /**
	     * Minimum X from points values, necessary to offset points
	     * @type Number
	     * @default
	     */
	    minX: 0,
	
	    /**
	     * Minimum Y from points values, necessary to offset points
	     * @type Number
	     * @default
	     */
	    minY: 0,
	
	    cacheProperties: cacheProperties,
	
	    /**
	     * Constructor
	     * @param {Array|String} path Path data (sequence of coordinates and corresponding "command" tokens)
	     * @param {Object} [options] Options object
	     * @return {fabric.Path} thisArg
	     */
	    initialize: function(path, options) {
	      options = options || { };
	
	      if (options) {
	        this.setOptions(options);
	      }
	
	      if (!path) {
	        path = [];
	      }
	
	      var fromArray = _toString.call(path) === '[object Array]';
	
	      this.path = fromArray
	        ? path
	        // one of commands (m,M,l,L,q,Q,c,C,etc.) followed by non-command characters (i.e. command values)
	        : path.match && path.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
	
	      if (!this.path) {
	        return;
	      }
	
	      if (!fromArray) {
	        this.path = this._parsePath();
	      }
	
	      this._setPositionDimensions(options);
	
	      if (options.sourcePath) {
	        this.setSourcePath(options.sourcePath);
	      }
	      if (this.objectCaching) {
	        this._createCacheCanvas();
	        this.setupState({ propertySet: 'cacheProperties' });
	      }
	    },
	
	    /**
	     * @private
	     * @param {Object} options Options object
	     */
	    _setPositionDimensions: function(options) {
	      var calcDim = this._parseDimensions();
	
	      this.minX = calcDim.left;
	      this.minY = calcDim.top;
	      this.width = calcDim.width;
	      this.height = calcDim.height;
	
	      if (typeof options.left === 'undefined') {
	        this.left = calcDim.left + (this.originX === 'center'
	          ? this.width / 2
	          : this.originX === 'right'
	            ? this.width
	            : 0);
	      }
	
	      if (typeof options.top === 'undefined') {
	        this.top = calcDim.top + (this.originY === 'center'
	          ? this.height / 2
	          : this.originY === 'bottom'
	            ? this.height
	            : 0);
	      }
	
	      this.pathOffset = this.pathOffset || {
	        x: this.minX + this.width / 2,
	        y: this.minY + this.height / 2
	      };
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx context to render path on
	     */
	    _renderPathCommands: function(ctx) {
	      var current, // current instruction
	          previous = null,
	          subpathStartX = 0,
	          subpathStartY = 0,
	          x = 0, // current x
	          y = 0, // current y
	          controlX = 0, // current control point x
	          controlY = 0, // current control point y
	          tempX,
	          tempY,
	          l = -this.pathOffset.x,
	          t = -this.pathOffset.y;
	
	      if (this.group && this.group.type === 'path-group') {
	        l = 0;
	        t = 0;
	      }
	
	      ctx.beginPath();
	
	      for (var i = 0, len = this.path.length; i < len; ++i) {
	
	        current = this.path[i];
	
	        switch (current[0]) { // first letter
	
	          case 'l': // lineto, relative
	            x += current[1];
	            y += current[2];
	            ctx.lineTo(x + l, y + t);
	            break;
	
	          case 'L': // lineto, absolute
	            x = current[1];
	            y = current[2];
	            ctx.lineTo(x + l, y + t);
	            break;
	
	          case 'h': // horizontal lineto, relative
	            x += current[1];
	            ctx.lineTo(x + l, y + t);
	            break;
	
	          case 'H': // horizontal lineto, absolute
	            x = current[1];
	            ctx.lineTo(x + l, y + t);
	            break;
	
	          case 'v': // vertical lineto, relative
	            y += current[1];
	            ctx.lineTo(x + l, y + t);
	            break;
	
	          case 'V': // verical lineto, absolute
	            y = current[1];
	            ctx.lineTo(x + l, y + t);
	            break;
	
	          case 'm': // moveTo, relative
	            x += current[1];
	            y += current[2];
	            subpathStartX = x;
	            subpathStartY = y;
	            ctx.moveTo(x + l, y + t);
	            break;
	
	          case 'M': // moveTo, absolute
	            x = current[1];
	            y = current[2];
	            subpathStartX = x;
	            subpathStartY = y;
	            ctx.moveTo(x + l, y + t);
	            break;
	
	          case 'c': // bezierCurveTo, relative
	            tempX = x + current[5];
	            tempY = y + current[6];
	            controlX = x + current[3];
	            controlY = y + current[4];
	            ctx.bezierCurveTo(
	              x + current[1] + l, // x1
	              y + current[2] + t, // y1
	              controlX + l, // x2
	              controlY + t, // y2
	              tempX + l,
	              tempY + t
	            );
	            x = tempX;
	            y = tempY;
	            break;
	
	          case 'C': // bezierCurveTo, absolute
	            x = current[5];
	            y = current[6];
	            controlX = current[3];
	            controlY = current[4];
	            ctx.bezierCurveTo(
	              current[1] + l,
	              current[2] + t,
	              controlX + l,
	              controlY + t,
	              x + l,
	              y + t
	            );
	            break;
	
	          case 's': // shorthand cubic bezierCurveTo, relative
	
	            // transform to absolute x,y
	            tempX = x + current[3];
	            tempY = y + current[4];
	
	            if (previous[0].match(/[CcSs]/) === null) {
	              // If there is no previous command or if the previous command was not a C, c, S, or s,
	              // the control point is coincident with the current point
	              controlX = x;
	              controlY = y;
	            }
	            else {
	              // calculate reflection of previous control points
	              controlX = 2 * x - controlX;
	              controlY = 2 * y - controlY;
	            }
	
	            ctx.bezierCurveTo(
	              controlX + l,
	              controlY + t,
	              x + current[1] + l,
	              y + current[2] + t,
	              tempX + l,
	              tempY + t
	            );
	            // set control point to 2nd one of this command
	            // "... the first control point is assumed to be
	            // the reflection of the second control point on
	            // the previous command relative to the current point."
	            controlX = x + current[1];
	            controlY = y + current[2];
	
	            x = tempX;
	            y = tempY;
	            break;
	
	          case 'S': // shorthand cubic bezierCurveTo, absolute
	            tempX = current[3];
	            tempY = current[4];
	            if (previous[0].match(/[CcSs]/) === null) {
	              // If there is no previous command or if the previous command was not a C, c, S, or s,
	              // the control point is coincident with the current point
	              controlX = x;
	              controlY = y;
	            }
	            else {
	              // calculate reflection of previous control points
	              controlX = 2 * x - controlX;
	              controlY = 2 * y - controlY;
	            }
	            ctx.bezierCurveTo(
	              controlX + l,
	              controlY + t,
	              current[1] + l,
	              current[2] + t,
	              tempX + l,
	              tempY + t
	            );
	            x = tempX;
	            y = tempY;
	
	            // set control point to 2nd one of this command
	            // "... the first control point is assumed to be
	            // the reflection of the second control point on
	            // the previous command relative to the current point."
	            controlX = current[1];
	            controlY = current[2];
	
	            break;
	
	          case 'q': // quadraticCurveTo, relative
	            // transform to absolute x,y
	            tempX = x + current[3];
	            tempY = y + current[4];
	
	            controlX = x + current[1];
	            controlY = y + current[2];
	
	            ctx.quadraticCurveTo(
	              controlX + l,
	              controlY + t,
	              tempX + l,
	              tempY + t
	            );
	            x = tempX;
	            y = tempY;
	            break;
	
	          case 'Q': // quadraticCurveTo, absolute
	            tempX = current[3];
	            tempY = current[4];
	
	            ctx.quadraticCurveTo(
	              current[1] + l,
	              current[2] + t,
	              tempX + l,
	              tempY + t
	            );
	            x = tempX;
	            y = tempY;
	            controlX = current[1];
	            controlY = current[2];
	            break;
	
	          case 't': // shorthand quadraticCurveTo, relative
	
	            // transform to absolute x,y
	            tempX = x + current[1];
	            tempY = y + current[2];
	
	            if (previous[0].match(/[QqTt]/) === null) {
	              // If there is no previous command or if the previous command was not a Q, q, T or t,
	              // assume the control point is coincident with the current point
	              controlX = x;
	              controlY = y;
	            }
	            else {
	              // calculate reflection of previous control point
	              controlX = 2 * x - controlX;
	              controlY = 2 * y - controlY;
	            }
	
	            ctx.quadraticCurveTo(
	              controlX + l,
	              controlY + t,
	              tempX + l,
	              tempY + t
	            );
	            x = tempX;
	            y = tempY;
	
	            break;
	
	          case 'T':
	            tempX = current[1];
	            tempY = current[2];
	
	            if (previous[0].match(/[QqTt]/) === null) {
	              // If there is no previous command or if the previous command was not a Q, q, T or t,
	              // assume the control point is coincident with the current point
	              controlX = x;
	              controlY = y;
	            }
	            else {
	              // calculate reflection of previous control point
	              controlX = 2 * x - controlX;
	              controlY = 2 * y - controlY;
	            }
	            ctx.quadraticCurveTo(
	              controlX + l,
	              controlY + t,
	              tempX + l,
	              tempY + t
	            );
	            x = tempX;
	            y = tempY;
	            break;
	
	          case 'a':
	            // TODO: optimize this
	            drawArc(ctx, x + l, y + t, [
	              current[1],
	              current[2],
	              current[3],
	              current[4],
	              current[5],
	              current[6] + x + l,
	              current[7] + y + t
	            ]);
	            x += current[6];
	            y += current[7];
	            break;
	
	          case 'A':
	            // TODO: optimize this
	            drawArc(ctx, x + l, y + t, [
	              current[1],
	              current[2],
	              current[3],
	              current[4],
	              current[5],
	              current[6] + l,
	              current[7] + t
	            ]);
	            x = current[6];
	            y = current[7];
	            break;
	
	          case 'z':
	          case 'Z':
	            x = subpathStartX;
	            y = subpathStartY;
	            ctx.closePath();
	            break;
	        }
	        previous = current;
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx context to render path on
	     */
	    _render: function(ctx) {
	      this._renderPathCommands(ctx);
	      this._renderFill(ctx);
	      this._renderStroke(ctx);
	    },
	
	    /**
	     * Returns string representation of an instance
	     * @return {String} string representation of an instance
	     */
	    toString: function() {
	      return '#<fabric.Path (' + this.complexity() +
	        '): { "top": ' + this.top + ', "left": ' + this.left + ' }>';
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      var o = extend(this.callSuper('toObject', ['sourcePath', 'pathOffset'].concat(propertiesToInclude)), {
	        path: this.path.map(function(item) { return item.slice(); })
	      });
	      return o;
	    },
	
	    /**
	     * Returns dataless object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toDatalessObject: function(propertiesToInclude) {
	      var o = this.toObject(propertiesToInclude);
	      if (this.sourcePath) {
	        o.path = this.sourcePath;
	      }
	      delete o.sourcePath;
	      return o;
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns svg representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var chunks = [],
	          markup = this._createBaseSVGMarkup(), addTransform = '';
	
	      for (var i = 0, len = this.path.length; i < len; i++) {
	        chunks.push(this.path[i].join(' '));
	      }
	      var path = chunks.join(' ');
	      if (!(this.group && this.group.type === 'path-group')) {
	        addTransform = ' translate(' + (-this.pathOffset.x) + ', ' + (-this.pathOffset.y) + ') ';
	      }
	      markup.push(
	        '<path ', this.getSvgId(),
	          'd="', path,
	          '" style="', this.getSvgStyles(),
	          '" transform="', this.getSvgTransform(), addTransform,
	          this.getSvgTransformMatrix(), '" stroke-linecap="round" ',
	        '/>\n'
	      );
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns number representation of an instance complexity
	     * @return {Number} complexity of this instance
	     */
	    complexity: function() {
	      return this.path.length;
	    },
	
	    /**
	     * @private
	     */
	    _parsePath: function() {
	      var result = [],
	          coords = [],
	          currentPath,
	          parsed,
	          re = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/ig,
	          match,
	          coordsStr;
	
	      for (var i = 0, coordsParsed, len = this.path.length; i < len; i++) {
	        currentPath = this.path[i];
	
	        coordsStr = currentPath.slice(1).trim();
	        coords.length = 0;
	
	        while ((match = re.exec(coordsStr))) {
	          coords.push(match[0]);
	        }
	
	        coordsParsed = [currentPath.charAt(0)];
	
	        for (var j = 0, jlen = coords.length; j < jlen; j++) {
	          parsed = parseFloat(coords[j]);
	          if (!isNaN(parsed)) {
	            coordsParsed.push(parsed);
	          }
	        }
	
	        var command = coordsParsed[0],
	            commandLength = commandLengths[command.toLowerCase()],
	            repeatedCommand = repeatedCommands[command] || command;
	
	        if (coordsParsed.length - 1 > commandLength) {
	          for (var k = 1, klen = coordsParsed.length; k < klen; k += commandLength) {
	            result.push([command].concat(coordsParsed.slice(k, k + commandLength)));
	            command = repeatedCommand;
	          }
	        }
	        else {
	          result.push(coordsParsed);
	        }
	      }
	
	      return result;
	    },
	
	    /**
	     * @private
	     */
	    _parseDimensions: function() {
	
	      var aX = [],
	          aY = [],
	          current, // current instruction
	          previous = null,
	          subpathStartX = 0,
	          subpathStartY = 0,
	          x = 0, // current x
	          y = 0, // current y
	          controlX = 0, // current control point x
	          controlY = 0, // current control point y
	          tempX,
	          tempY,
	          bounds;
	
	      for (var i = 0, len = this.path.length; i < len; ++i) {
	
	        current = this.path[i];
	
	        switch (current[0]) { // first letter
	
	          case 'l': // lineto, relative
	            x += current[1];
	            y += current[2];
	            bounds = [];
	            break;
	
	          case 'L': // lineto, absolute
	            x = current[1];
	            y = current[2];
	            bounds = [];
	            break;
	
	          case 'h': // horizontal lineto, relative
	            x += current[1];
	            bounds = [];
	            break;
	
	          case 'H': // horizontal lineto, absolute
	            x = current[1];
	            bounds = [];
	            break;
	
	          case 'v': // vertical lineto, relative
	            y += current[1];
	            bounds = [];
	            break;
	
	          case 'V': // verical lineto, absolute
	            y = current[1];
	            bounds = [];
	            break;
	
	          case 'm': // moveTo, relative
	            x += current[1];
	            y += current[2];
	            subpathStartX = x;
	            subpathStartY = y;
	            bounds = [];
	            break;
	
	          case 'M': // moveTo, absolute
	            x = current[1];
	            y = current[2];
	            subpathStartX = x;
	            subpathStartY = y;
	            bounds = [];
	            break;
	
	          case 'c': // bezierCurveTo, relative
	            tempX = x + current[5];
	            tempY = y + current[6];
	            controlX = x + current[3];
	            controlY = y + current[4];
	            bounds = fabric.util.getBoundsOfCurve(x, y,
	              x + current[1], // x1
	              y + current[2], // y1
	              controlX, // x2
	              controlY, // y2
	              tempX,
	              tempY
	            );
	            x = tempX;
	            y = tempY;
	            break;
	
	          case 'C': // bezierCurveTo, absolute
	            x = current[5];
	            y = current[6];
	            controlX = current[3];
	            controlY = current[4];
	            bounds = fabric.util.getBoundsOfCurve(x, y,
	              current[1],
	              current[2],
	              controlX,
	              controlY,
	              x,
	              y
	            );
	            break;
	
	          case 's': // shorthand cubic bezierCurveTo, relative
	
	            // transform to absolute x,y
	            tempX = x + current[3];
	            tempY = y + current[4];
	
	            if (previous[0].match(/[CcSs]/) === null) {
	              // If there is no previous command or if the previous command was not a C, c, S, or s,
	              // the control point is coincident with the current point
	              controlX = x;
	              controlY = y;
	            }
	            else {
	              // calculate reflection of previous control points
	              controlX = 2 * x - controlX;
	              controlY = 2 * y - controlY;
	            }
	
	            bounds = fabric.util.getBoundsOfCurve(x, y,
	              controlX,
	              controlY,
	              x + current[1],
	              y + current[2],
	              tempX,
	              tempY
	            );
	            // set control point to 2nd one of this command
	            // "... the first control point is assumed to be
	            // the reflection of the second control point on
	            // the previous command relative to the current point."
	            controlX = x + current[1];
	            controlY = y + current[2];
	            x = tempX;
	            y = tempY;
	            break;
	
	          case 'S': // shorthand cubic bezierCurveTo, absolute
	            tempX = current[3];
	            tempY = current[4];
	            if (previous[0].match(/[CcSs]/) === null) {
	              // If there is no previous command or if the previous command was not a C, c, S, or s,
	              // the control point is coincident with the current point
	              controlX = x;
	              controlY = y;
	            }
	            else {
	              // calculate reflection of previous control points
	              controlX = 2 * x - controlX;
	              controlY = 2 * y - controlY;
	            }
	            bounds = fabric.util.getBoundsOfCurve(x, y,
	              controlX,
	              controlY,
	              current[1],
	              current[2],
	              tempX,
	              tempY
	            );
	            x = tempX;
	            y = tempY;
	            // set control point to 2nd one of this command
	            // "... the first control point is assumed to be
	            // the reflection of the second control point on
	            // the previous command relative to the current point."
	            controlX = current[1];
	            controlY = current[2];
	            break;
	
	          case 'q': // quadraticCurveTo, relative
	            // transform to absolute x,y
	            tempX = x + current[3];
	            tempY = y + current[4];
	            controlX = x + current[1];
	            controlY = y + current[2];
	            bounds = fabric.util.getBoundsOfCurve(x, y,
	              controlX,
	              controlY,
	              controlX,
	              controlY,
	              tempX,
	              tempY
	            );
	            x = tempX;
	            y = tempY;
	            break;
	
	          case 'Q': // quadraticCurveTo, absolute
	            controlX = current[1];
	            controlY = current[2];
	            bounds = fabric.util.getBoundsOfCurve(x, y,
	              controlX,
	              controlY,
	              controlX,
	              controlY,
	              current[3],
	              current[4]
	            );
	            x = current[3];
	            y = current[4];
	            break;
	
	          case 't': // shorthand quadraticCurveTo, relative
	            // transform to absolute x,y
	            tempX = x + current[1];
	            tempY = y + current[2];
	            if (previous[0].match(/[QqTt]/) === null) {
	              // If there is no previous command or if the previous command was not a Q, q, T or t,
	              // assume the control point is coincident with the current point
	              controlX = x;
	              controlY = y;
	            }
	            else {
	              // calculate reflection of previous control point
	              controlX = 2 * x - controlX;
	              controlY = 2 * y - controlY;
	            }
	
	            bounds = fabric.util.getBoundsOfCurve(x, y,
	              controlX,
	              controlY,
	              controlX,
	              controlY,
	              tempX,
	              tempY
	            );
	            x = tempX;
	            y = tempY;
	
	            break;
	
	          case 'T':
	            tempX = current[1];
	            tempY = current[2];
	
	            if (previous[0].match(/[QqTt]/) === null) {
	              // If there is no previous command or if the previous command was not a Q, q, T or t,
	              // assume the control point is coincident with the current point
	              controlX = x;
	              controlY = y;
	            }
	            else {
	              // calculate reflection of previous control point
	              controlX = 2 * x - controlX;
	              controlY = 2 * y - controlY;
	            }
	            bounds = fabric.util.getBoundsOfCurve(x, y,
	              controlX,
	              controlY,
	              controlX,
	              controlY,
	              tempX,
	              tempY
	            );
	            x = tempX;
	            y = tempY;
	            break;
	
	          case 'a':
	            // TODO: optimize this
	            bounds = fabric.util.getBoundsOfArc(x, y,
	              current[1],
	              current[2],
	              current[3],
	              current[4],
	              current[5],
	              current[6] + x,
	              current[7] + y
	            );
	            x += current[6];
	            y += current[7];
	            break;
	
	          case 'A':
	            // TODO: optimize this
	            bounds = fabric.util.getBoundsOfArc(x, y,
	              current[1],
	              current[2],
	              current[3],
	              current[4],
	              current[5],
	              current[6],
	              current[7]
	            );
	            x = current[6];
	            y = current[7];
	            break;
	
	          case 'z':
	          case 'Z':
	            x = subpathStartX;
	            y = subpathStartY;
	            break;
	        }
	        previous = current;
	        bounds.forEach(function (point) {
	          aX.push(point.x);
	          aY.push(point.y);
	        });
	        aX.push(x);
	        aY.push(y);
	      }
	
	      var minX = min(aX) || 0,
	          minY = min(aY) || 0,
	          maxX = max(aX) || 0,
	          maxY = max(aY) || 0,
	          deltaX = maxX - minX,
	          deltaY = maxY - minY,
	
	          o = {
	            left: minX,
	            top: minY,
	            width: deltaX,
	            height: deltaY
	          };
	
	      return o;
	    }
	  });
	
	  /**
	   * Creates an instance of fabric.Path from an object
	   * @static
	   * @memberOf fabric.Path
	   * @param {Object} object
	   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
	   * @param {Boolean} [forceAsync] Force an async behaviour trying to create pattern first
	   */
	  fabric.Path.fromObject = function(object, callback, forceAsync) {
	    // remove this pattern rom 2.0, accept just object.
	    var path;
	    if (typeof object.path === 'string') {
	      fabric.loadSVGFromURL(object.path, function (elements) {
	        var pathUrl = object.path;
	        path = elements[0];
	        delete object.path;
	
	        fabric.util.object.extend(path, object);
	        path.setSourcePath(pathUrl);
	
	        callback && callback(path);
	      });
	    }
	    else {
	      return fabric.Object._fromObject('Path', object, callback, forceAsync, 'path');
	    }
	  };
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by `fabric.Path.fromElement`)
	   * @static
	   * @memberOf fabric.Path
	   * @see http://www.w3.org/TR/SVG/paths.html#PathElement
	   */
	  fabric.Path.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(['d']);
	
	  /**
	   * Creates an instance of fabric.Path from an SVG <path> element
	   * @static
	   * @memberOf fabric.Path
	   * @param {SVGElement} element to parse
	   * @param {Function} callback Callback to invoke when an fabric.Path instance is created
	   * @param {Object} [options] Options object
	   */
	  fabric.Path.fromElement = function(element, callback, options) {
	    var parsedAttributes = fabric.parseAttributes(element, fabric.Path.ATTRIBUTE_NAMES);
	    callback && callback(new fabric.Path(parsedAttributes.d, extend(parsedAttributes, options)));
	  };
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Indicates that instances of this type are async
	   * @static
	   * @memberOf fabric.Path
	   * @type Boolean
	   * @default
	   */
	  fabric.Path.async = true;
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend;
	
	  if (fabric.PathGroup) {
	    fabric.warn('fabric.PathGroup is already defined');
	    return;
	  }
	
	  /**
	   * Path group class
	   * @class fabric.PathGroup
	   * @extends fabric.Path
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#path_and_pathgroup}
	   * @see {@link fabric.PathGroup#initialize} for constructor definition
	   */
	  fabric.PathGroup = fabric.util.createClass(fabric.Object, /** @lends fabric.PathGroup.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'path-group',
	
	    /**
	     * Fill value
	     * @type String
	     * @default
	     */
	    fill: '',
	
	    /**
	     * Constructor
	     * @param {Array} paths
	     * @param {Object} [options] Options object
	     * @return {fabric.PathGroup} thisArg
	     */
	    initialize: function(paths, options) {
	
	      options = options || { };
	      this.paths = paths || [];
	
	      for (var i = this.paths.length; i--;) {
	        this.paths[i].group = this;
	      }
	
	      if (options.toBeParsed) {
	        this.parseDimensionsFromPaths(options);
	        delete options.toBeParsed;
	      }
	      this.setOptions(options);
	      this.setCoords();
	      if (options.sourcePath) {
	        this.setSourcePath(options.sourcePath);
	      }
	      if (this.objectCaching) {
	        this._createCacheCanvas();
	        this.setupState({ propertySet: 'cacheProperties' });
	      }
	    },
	
	    /**
	     * Calculate width and height based on paths contained
	     */
	    parseDimensionsFromPaths: function(options) {
	      var points, p, xC = [], yC = [], path, height, width,
	          m;
	      for (var j = this.paths.length; j--;) {
	        path = this.paths[j];
	        height = path.height + path.strokeWidth;
	        width = path.width + path.strokeWidth;
	        points = [
	          { x: path.left, y: path.top },
	          { x: path.left + width, y: path.top },
	          { x: path.left, y: path.top + height },
	          { x: path.left + width, y: path.top + height }
	        ];
	        m = this.paths[j].transformMatrix;
	        for (var i = 0; i < points.length; i++) {
	          p = points[i];
	          if (m) {
	            p = fabric.util.transformPoint(p, m, false);
	          }
	          xC.push(p.x);
	          yC.push(p.y);
	        }
	      }
	      options.width = Math.max.apply(null, xC);
	      options.height = Math.max.apply(null, yC);
	    },
	
	    /**
	     * Execute the drawing operation for an object on a specified context
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} [noTransform] When true, context is not transformed
	     */
	    drawObject: function(ctx) {
	      ctx.save();
	      ctx.translate(-this.width / 2, -this.height / 2);
	      for (var i = 0, l = this.paths.length; i < l; ++i) {
	        this.paths[i].render(ctx, true);
	      }
	      ctx.restore();
	    },
	
	    /**
	     * Check if cache is dirty
	     */
	    isCacheDirty: function() {
	      if (this.callSuper('isCacheDirty')) {
	        return true;
	      }
	      if (!this.statefullCache) {
	        return false;
	      }
	      for (var i = 0, len = this.paths.length; i < len; i++) {
	        if (this.paths[i].isCacheDirty(true)) {
	          var dim = this._getNonTransformedDimensions();
	          this._cacheContext.clearRect(-dim.x / 2, -dim.y / 2, dim.x, dim.y);
	          return true;
	        }
	      }
	      return false;
	    },
	
	    /**
	     * Sets certain property to a certain value
	     * @param {String} prop
	     * @param {*} value
	     * @return {fabric.PathGroup} thisArg
	     */
	    _set: function(prop, value) {
	
	      if (prop === 'fill' && value && this.isSameColor()) {
	        var i = this.paths.length;
	        while (i--) {
	          this.paths[i]._set(prop, value);
	        }
	      }
	
	      return this.callSuper('_set', prop, value);
	    },
	
	    /**
	     * Returns object representation of this path group
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      var pathsToObject = this.paths.map(function(path) {
	        var originalDefaults = path.includeDefaultValues;
	        path.includeDefaultValues = path.group.includeDefaultValues;
	        var obj = path.toObject(propertiesToInclude);
	        path.includeDefaultValues = originalDefaults;
	        return obj;
	      });
	      var o = extend(this.callSuper('toObject', ['sourcePath'].concat(propertiesToInclude)), {
	        paths: pathsToObject
	      });
	      return o;
	    },
	
	    /**
	     * Returns dataless object representation of this path group
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} dataless object representation of an instance
	     */
	    toDatalessObject: function(propertiesToInclude) {
	      var o = this.toObject(propertiesToInclude);
	      if (this.sourcePath) {
	        o.paths = this.sourcePath;
	      }
	      return o;
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns svg representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var objects = this.getObjects(),
	          p = this.getPointByOrigin('left', 'top'),
	          translatePart = 'translate(' + p.x + ' ' + p.y + ')',
	          markup = this._createBaseSVGMarkup();
	      markup.push(
	        '<g ', this.getSvgId(),
	        'style="', this.getSvgStyles(), '" ',
	        'transform="', this.getSvgTransformMatrix(), translatePart, this.getSvgTransform(), '" ',
	        '>\n'
	      );
	
	      for (var i = 0, len = objects.length; i < len; i++) {
	        markup.push('\t', objects[i].toSVG(reviver));
	      }
	      markup.push('</g>\n');
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns a string representation of this path group
	     * @return {String} string representation of an object
	     */
	    toString: function() {
	      return '#<fabric.PathGroup (' + this.complexity() +
	        '): { top: ' + this.top + ', left: ' + this.left + ' }>';
	    },
	
	    /**
	     * Returns true if all paths in this group are of same color
	     * @return {Boolean} true if all paths are of the same color (`fill`)
	     */
	    isSameColor: function() {
	      var firstPathFill = this.getObjects()[0].get('fill') || '';
	      if (typeof firstPathFill !== 'string') {
	        return false;
	      }
	      firstPathFill = firstPathFill.toLowerCase();
	      return this.getObjects().every(function(path) {
	        var pathFill = path.get('fill') || '';
	        return typeof pathFill === 'string' && (pathFill).toLowerCase() === firstPathFill;
	      });
	    },
	
	    /**
	     * Returns number representation of object's complexity
	     * @return {Number} complexity
	     */
	    complexity: function() {
	      return this.paths.reduce(function(total, path) {
	        return total + ((path && path.complexity) ? path.complexity() : 0);
	      }, 0);
	    },
	
	    /**
	     * Returns all paths in this path group
	     * @return {Array} array of path objects included in this path group
	     */
	    getObjects: function() {
	      return this.paths;
	    }
	  });
	
	  /**
	   * Creates fabric.PathGroup instance from an object representation
	   * @static
	   * @memberOf fabric.PathGroup
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] Callback to invoke when an fabric.PathGroup instance is created
	   */
	  fabric.PathGroup.fromObject = function(object, callback) {
	    // remove this pattern from 2.0 accepts only object
	    if (typeof object.paths === 'string') {
	      fabric.loadSVGFromURL(object.paths, function (elements) {
	
	        var pathUrl = object.paths;
	        delete object.paths;
	
	        var pathGroup = fabric.util.groupSVGElements(elements, object, pathUrl);
	
	        callback(pathGroup);
	      });
	    }
	    else {
	      fabric.util.enlivenObjects(object.paths, function(enlivenedObjects) {
	        delete object.paths;
	        callback(new fabric.PathGroup(enlivenedObjects, object));
	      });
	    }
	  };
	
	  /**
	   * Indicates that instances of this type are async
	   * @static
	   * @memberOf fabric.PathGroup
	   * @type Boolean
	   * @default
	   */
	  fabric.PathGroup.async = true;
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      min = fabric.util.array.min,
	      max = fabric.util.array.max;
	
	  if (fabric.Group) {
	    return;
	  }
	
	  // lock-related properties, for use in fabric.Group#get
	  // to enable locking behavior on group
	  // when one of its objects has lock-related properties set
	  var _lockProperties = {
	    lockMovementX:  true,
	    lockMovementY:  true,
	    lockRotation:   true,
	    lockScalingX:   true,
	    lockScalingY:   true,
	    lockUniScaling: true
	  };
	
	  /**
	   * Group class
	   * @class fabric.Group
	   * @extends fabric.Object
	   * @mixes fabric.Collection
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}
	   * @see {@link fabric.Group#initialize} for constructor definition
	   */
	  fabric.Group = fabric.util.createClass(fabric.Object, fabric.Collection, /** @lends fabric.Group.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'group',
	
	    /**
	     * Width of stroke
	     * @type Number
	     * @default
	     */
	    strokeWidth: 0,
	
	    /**
	     * Indicates if click events should also check for subtargets
	     * @type Boolean
	     * @default
	     */
	    subTargetCheck: false,
	
	    /**
	     * Constructor
	     * @param {Object} objects Group objects
	     * @param {Object} [options] Options object
	     * @param {Boolean} [isAlreadyGrouped] if true, objects have been grouped already.
	     * @return {Object} thisArg
	     */
	    initialize: function(objects, options, isAlreadyGrouped) {
	      options = options || { };
	
	      this._objects = [];
	      // if objects enclosed in a group have been grouped already,
	      // we cannot change properties of objects.
	      // Thus we need to set options to group without objects,
	      // because delegatedProperties propagate to objects.
	      isAlreadyGrouped && this.callSuper('initialize', options);
	
	      this._objects = objects || [];
	      for (var i = this._objects.length; i--; ) {
	        this._objects[i].group = this;
	      }
	
	      this.originalState = { };
	
	      if (options.originX) {
	        this.originX = options.originX;
	      }
	      if (options.originY) {
	        this.originY = options.originY;
	      }
	
	      if (isAlreadyGrouped) {
	        // do not change coordinate of objects enclosed in a group,
	        // because objects coordinate system have been group coodinate system already.
	        this._updateObjectsCoords(true);
	      }
	      else {
	        this._calcBounds();
	        this._updateObjectsCoords();
	        this.callSuper('initialize', options);
	      }
	
	      this.setCoords();
	      this.saveCoords();
	    },
	
	    /**
	     * @private
	     * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change
	     */
	    _updateObjectsCoords: function(skipCoordsChange) {
	      var center = this.getCenterPoint();
	      for (var i = this._objects.length; i--; ){
	        this._updateObjectCoords(this._objects[i], center, skipCoordsChange);
	      }
	    },
	
	    /**
	     * @private
	     * @param {Object} object
	     * @param {fabric.Point} center, current center of group.
	     * @param {Boolean} [skipCoordsChange] if true, coordinates of object dose not change
	     */
	    _updateObjectCoords: function(object, center, skipCoordsChange) {
	      // do not display corners of objects enclosed in a group
	      object.__origHasControls = object.hasControls;
	      object.hasControls = false;
	
	      if (skipCoordsChange) {
	        return;
	      }
	
	      var objectLeft = object.getLeft(),
	          objectTop = object.getTop(),
	          ignoreZoom = true;
	
	      object.set({
	        originalLeft: objectLeft,
	        originalTop: objectTop,
	        left: objectLeft - center.x,
	        top: objectTop - center.y
	      });
	      object.setCoords(ignoreZoom);
	    },
	
	    /**
	     * Returns string represenation of a group
	     * @return {String}
	     */
	    toString: function() {
	      return '#<fabric.Group: (' + this.complexity() + ')>';
	    },
	
	    /**
	     * Adds an object to a group; Then recalculates group's dimension, position.
	     * @param {Object} object
	     * @return {fabric.Group} thisArg
	     * @chainable
	     */
	    addWithUpdate: function(object) {
	      this._restoreObjectsState();
	      fabric.util.resetObjectTransform(this);
	      if (object) {
	        this._objects.push(object);
	        object.group = this;
	        object._set('canvas', this.canvas);
	      }
	      // since _restoreObjectsState set objects inactive
	      this.forEachObject(this._setObjectActive, this);
	      this._calcBounds();
	      this._updateObjectsCoords();
	      this.dirty = true;
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _setObjectActive: function(object) {
	      object.set('active', true);
	      object.group = this;
	    },
	
	    /**
	     * Removes an object from a group; Then recalculates group's dimension, position.
	     * @param {Object} object
	     * @return {fabric.Group} thisArg
	     * @chainable
	     */
	    removeWithUpdate: function(object) {
	      this._restoreObjectsState();
	      fabric.util.resetObjectTransform(this);
	      // since _restoreObjectsState set objects inactive
	      this.forEachObject(this._setObjectActive, this);
	
	      this.remove(object);
	      this._calcBounds();
	      this._updateObjectsCoords();
	      this.dirty = true;
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _onObjectAdded: function(object) {
	      this.dirty = true;
	      object.group = this;
	      object._set('canvas', this.canvas);
	    },
	
	    /**
	     * @private
	     */
	    _onObjectRemoved: function(object) {
	      this.dirty = true;
	      delete object.group;
	      object.set('active', false);
	    },
	
	    /**
	     * Properties that are delegated to group objects when reading/writing
	     * @param {Object} delegatedProperties
	     */
	    delegatedProperties: {
	      fill:             true,
	      stroke:           true,
	      strokeWidth:      true,
	      fontFamily:       true,
	      fontWeight:       true,
	      fontSize:         true,
	      fontStyle:        true,
	      lineHeight:       true,
	      textDecoration:   true,
	      textAlign:        true,
	      backgroundColor:  true
	    },
	
	    /**
	     * @private
	     */
	    _set: function(key, value) {
	      var i = this._objects.length;
	
	      if (this.delegatedProperties[key] || key === 'canvas') {
	        while (i--) {
	          this._objects[i].set(key, value);
	        }
	      }
	      else {
	        while (i--) {
	          this._objects[i].setOnGroup(key, value);
	        }
	      }
	
	      this.callSuper('_set', key, value);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      var objsToObject = this.getObjects().map(function(obj) {
	        var originalDefaults = obj.includeDefaultValues;
	        obj.includeDefaultValues = obj.group.includeDefaultValues;
	        var _obj = obj.toObject(propertiesToInclude);
	        obj.includeDefaultValues = originalDefaults;
	        return _obj;
	      });
	      return extend(this.callSuper('toObject', propertiesToInclude), {
	        objects: objsToObject
	      });
	    },
	
	    /**
	     * Renders instance on a given context
	     * @param {CanvasRenderingContext2D} ctx context to render instance on
	     */
	    render: function(ctx) {
	      this._transformDone = true;
	      this.callSuper('render', ctx);
	      this._transformDone = false;
	    },
	
	    /**
	     * Execute the drawing operation for an object on a specified context
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} [noTransform] When true, context is not transformed
	     */
	    drawObject: function(ctx) {
	      for (var i = 0, len = this._objects.length; i < len; i++) {
	        this._renderObject(this._objects[i], ctx);
	      }
	    },
	
	    /**
	     * Check if cache is dirty
	     */
	    isCacheDirty: function() {
	      if (this.callSuper('isCacheDirty')) {
	        return true;
	      }
	      if (!this.statefullCache) {
	        return false;
	      }
	      for (var i = 0, len = this._objects.length; i < len; i++) {
	        if (this._objects[i].isCacheDirty(true)) {
	          var dim = this._getNonTransformedDimensions();
	          this._cacheContext.clearRect(-dim.x / 2, -dim.y / 2, dim.x, dim.y);
	          return true;
	        }
	      }
	      return false;
	    },
	
	    /**
	     * Renders controls and borders for the object
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} [noTransform] When true, context is not transformed
	     */
	    _renderControls: function(ctx, noTransform) {
	      ctx.save();
	      ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
	      this.callSuper('_renderControls', ctx, noTransform);
	      for (var i = 0, len = this._objects.length; i < len; i++) {
	        this._objects[i]._renderControls(ctx);
	      }
	      ctx.restore();
	    },
	
	    /**
	     * @private
	     */
	    _renderObject: function(object, ctx) {
	      // do not render if object is not visible
	      if (!object.visible) {
	        return;
	      }
	
	      var originalHasRotatingPoint = object.hasRotatingPoint;
	      object.hasRotatingPoint = false;
	      object.render(ctx);
	      object.hasRotatingPoint = originalHasRotatingPoint;
	    },
	
	    /**
	     * Retores original state of each of group objects (original state is that which was before group was created).
	     * @private
	     * @return {fabric.Group} thisArg
	     * @chainable
	     */
	    _restoreObjectsState: function() {
	      this._objects.forEach(this._restoreObjectState, this);
	      return this;
	    },
	
	    /**
	     * Realises the transform from this group onto the supplied object
	     * i.e. it tells you what would happen if the supplied object was in
	     * the group, and then the group was destroyed. It mutates the supplied
	     * object.
	     * @param {fabric.Object} object
	     * @return {fabric.Object} transformedObject
	     */
	    realizeTransform: function(object) {
	      var matrix = object.calcTransformMatrix(),
	          options = fabric.util.qrDecompose(matrix),
	          center = new fabric.Point(options.translateX, options.translateY);
	      object.flipX = false;
	      object.flipY = false;
	      object.set('scaleX', options.scaleX);
	      object.set('scaleY', options.scaleY);
	      object.skewX = options.skewX;
	      object.skewY = options.skewY;
	      object.angle = options.angle;
	      object.setPositionByOrigin(center, 'center', 'center');
	      return object;
	    },
	
	    /**
	     * Restores original state of a specified object in group
	     * @private
	     * @param {fabric.Object} object
	     * @return {fabric.Group} thisArg
	     */
	    _restoreObjectState: function(object) {
	      this.realizeTransform(object);
	      object.setCoords();
	      object.hasControls = object.__origHasControls;
	      delete object.__origHasControls;
	      object.set('active', false);
	      delete object.group;
	
	      return this;
	    },
	
	    /**
	     * Destroys a group (restoring state of its objects)
	     * @return {fabric.Group} thisArg
	     * @chainable
	     */
	    destroy: function() {
	      return this._restoreObjectsState();
	    },
	
	    /**
	     * Saves coordinates of this instance (to be used together with `hasMoved`)
	     * @saveCoords
	     * @return {fabric.Group} thisArg
	     * @chainable
	     */
	    saveCoords: function() {
	      this._originalLeft = this.get('left');
	      this._originalTop = this.get('top');
	      return this;
	    },
	
	    /**
	     * Checks whether this group was moved (since `saveCoords` was called last)
	     * @return {Boolean} true if an object was moved (since fabric.Group#saveCoords was called)
	     */
	    hasMoved: function() {
	      return this._originalLeft !== this.get('left') ||
	             this._originalTop !== this.get('top');
	    },
	
	    /**
	     * Sets coordinates of all group objects
	     * @return {fabric.Group} thisArg
	     * @chainable
	     */
	    setObjectsCoords: function() {
	      var ignoreZoom = true;
	      this.forEachObject(function(object) {
	        object.setCoords(ignoreZoom);
	      });
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _calcBounds: function(onlyWidthHeight) {
	      var aX = [],
	          aY = [],
	          o, prop,
	          props = ['tr', 'br', 'bl', 'tl'],
	          i = 0, iLen = this._objects.length,
	          j, jLen = props.length,
	          ignoreZoom = true;
	
	      for ( ; i < iLen; ++i) {
	        o = this._objects[i];
	        o.setCoords(ignoreZoom);
	        for (j = 0; j < jLen; j++) {
	          prop = props[j];
	          aX.push(o.oCoords[prop].x);
	          aY.push(o.oCoords[prop].y);
	        }
	      }
	
	      this.set(this._getBounds(aX, aY, onlyWidthHeight));
	    },
	
	    /**
	     * @private
	     */
	    _getBounds: function(aX, aY, onlyWidthHeight) {
	      var minXY = new fabric.Point(min(aX), min(aY)),
	          maxXY = new fabric.Point(max(aX), max(aY)),
	          obj = {
	            width: (maxXY.x - minXY.x) || 0,
	            height: (maxXY.y - minXY.y) || 0
	          };
	
	      if (!onlyWidthHeight) {
	        obj.left = minXY.x || 0;
	        obj.top = minXY.y || 0;
	        if (this.originX === 'center') {
	          obj.left += obj.width / 2;
	        }
	        if (this.originX === 'right') {
	          obj.left += obj.width;
	        }
	        if (this.originY === 'center') {
	          obj.top += obj.height / 2;
	        }
	        if (this.originY === 'bottom') {
	          obj.top += obj.height;
	        }
	      }
	      return obj;
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns svg representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var markup = this._createBaseSVGMarkup();
	      markup.push(
	        '<g ', this.getSvgId(), 'transform="',
	        /* avoiding styles intentionally */
	        this.getSvgTransform(),
	        this.getSvgTransformMatrix(),
	        '" style="',
	        this.getSvgFilter(),
	        '">\n'
	      );
	
	      for (var i = 0, len = this._objects.length; i < len; i++) {
	        markup.push('\t', this._objects[i].toSVG(reviver));
	      }
	
	      markup.push('</g>\n');
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns requested property
	     * @param {String} prop Property to get
	     * @return {*}
	     */
	    get: function(prop) {
	      if (prop in _lockProperties) {
	        if (this[prop]) {
	          return this[prop];
	        }
	        else {
	          for (var i = 0, len = this._objects.length; i < len; i++) {
	            if (this._objects[i][prop]) {
	              return true;
	            }
	          }
	          return false;
	        }
	      }
	      else {
	        if (prop in this.delegatedProperties) {
	          return this._objects[0] && this._objects[0].get(prop);
	        }
	        return this[prop];
	      }
	    }
	  });
	
	  /**
	   * Returns {@link fabric.Group} instance from an object representation
	   * @static
	   * @memberOf fabric.Group
	   * @param {Object} object Object to create a group from
	   * @param {Function} [callback] Callback to invoke when an group instance is created
	   */
	  fabric.Group.fromObject = function(object, callback) {
	    fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {
	      delete object.objects;
	      callback && callback(new fabric.Group(enlivenedObjects, object, true));
	    });
	  };
	
	  /**
	   * Indicates that instances of this type are async
	   * @static
	   * @memberOf fabric.Group
	   * @type Boolean
	   * @default
	   */
	  fabric.Group.async = true;
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var extend = fabric.util.object.extend;
	
	  if (!global.fabric) {
	    global.fabric = { };
	  }
	
	  if (global.fabric.Image) {
	    fabric.warn('fabric.Image is already defined.');
	    return;
	  }
	
	  var stateProperties = fabric.Object.prototype.stateProperties.concat();
	  stateProperties.push(
	    'alignX',
	    'alignY',
	    'meetOrSlice'
	  );
	
	  /**
	   * Image class
	   * @class fabric.Image
	   * @extends fabric.Object
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#images}
	   * @see {@link fabric.Image#initialize} for constructor definition
	   */
	  fabric.Image = fabric.util.createClass(fabric.Object, /** @lends fabric.Image.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'image',
	
	    /**
	     * crossOrigin value (one of "", "anonymous", "use-credentials")
	     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes
	     * @type String
	     * @default
	     */
	    crossOrigin: '',
	
	    /**
	     * AlignX value, part of preserveAspectRatio (one of "none", "mid", "min", "max")
	     * @see http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
	     * This parameter defines how the picture is aligned to its viewport when image element width differs from image width.
	     * @type String
	     * @default
	     */
	    alignX: 'none',
	
	    /**
	     * AlignY value, part of preserveAspectRatio (one of "none", "mid", "min", "max")
	     * @see http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
	     * This parameter defines how the picture is aligned to its viewport when image element height differs from image height.
	     * @type String
	     * @default
	     */
	    alignY: 'none',
	
	    /**
	     * meetOrSlice value, part of preserveAspectRatio  (one of "meet", "slice").
	     * if meet the image is always fully visibile, if slice the viewport is always filled with image.
	     * @see http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
	     * @type String
	     * @default
	     */
	    meetOrSlice: 'meet',
	
	    /**
	     * Width of a stroke.
	     * For image quality a stroke multiple of 2 gives better results.
	     * @type Number
	     * @default
	     */
	    strokeWidth: 0,
	
	    /**
	     * private
	     * contains last value of scaleX to detect
	     * if the Image got resized after the last Render
	     * @type Number
	     */
	    _lastScaleX: 1,
	
	    /**
	     * private
	     * contains last value of scaleY to detect
	     * if the Image got resized after the last Render
	     * @type Number
	     */
	    _lastScaleY: 1,
	
	    /**
	     * minimum scale factor under which any resizeFilter is triggered to resize the image
	     * 0 will disable the automatic resize. 1 will trigger automatically always.
	     * number bigger than 1 can be used in case we want to scale with some filter above
	     * the natural image dimensions
	     * @type Number
	     */
	    minimumScaleTrigger: 0.5,
	
	    /**
	     * List of properties to consider when checking if
	     * state of an object is changed ({@link fabric.Object#hasStateChanged})
	     * as well as for history (undo/redo) purposes
	     * @type Array
	     */
	    stateProperties: stateProperties,
	
	    /**
	     * When `true`, object is cached on an additional canvas.
	     * default to false for images
	     * since 1.7.0
	     * @type Boolean
	     * @default
	     */
	    objectCaching: false,
	
	    /**
	     * Constructor
	     * @param {HTMLImageElement | String} element Image element
	     * @param {Object} [options] Options object
	     * @param {function} [callback] callback function to call after eventual filters applied.
	     * @return {fabric.Image} thisArg
	     */
	    initialize: function(element, options, callback) {
	      options || (options = { });
	      this.filters = [];
	      this.resizeFilters = [];
	      this.callSuper('initialize', options);
	      this._initElement(element, options, callback);
	    },
	
	    /**
	     * Returns image element which this instance if based on
	     * @return {HTMLImageElement} Image element
	     */
	    getElement: function() {
	      return this._element;
	    },
	
	    /**
	     * Sets image element for this instance to a specified one.
	     * If filters defined they are applied to new image.
	     * You might need to call `canvas.renderAll` and `object.setCoords` after replacing, to render new image and update controls area.
	     * @param {HTMLImageElement} element
	     * @param {Function} [callback] Callback is invoked when all filters have been applied and new image is generated
	     * @param {Object} [options] Options object
	     * @return {fabric.Image} thisArg
	     * @chainable
	     */
	    setElement: function(element, callback, options) {
	
	      var _callback, _this;
	
	      this._element = element;
	      this._originalElement = element;
	      this._initConfig(options);
	
	      if (this.resizeFilters.length === 0) {
	        _callback = callback;
	      }
	      else {
	        _this = this;
	        _callback = function() {
	          _this.applyFilters(callback, _this.resizeFilters, _this._filteredEl || _this._originalElement, true);
	        };
	      }
	
	      if (this.filters.length !== 0) {
	        this.applyFilters(_callback);
	      }
	      else if (_callback) {
	        _callback(this);
	      }
	
	      return this;
	    },
	
	    /**
	     * Sets crossOrigin value (on an instance and corresponding image element)
	     * @return {fabric.Image} thisArg
	     * @chainable
	     */
	    setCrossOrigin: function(value) {
	      this.crossOrigin = value;
	      this._element.crossOrigin = value;
	
	      return this;
	    },
	
	    /**
	     * Returns original size of an image
	     * @return {Object} Object with "width" and "height" properties
	     */
	    getOriginalSize: function() {
	      var element = this.getElement();
	      return {
	        width: element.width,
	        height: element.height
	      };
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _stroke: function(ctx) {
	      if (!this.stroke || this.strokeWidth === 0) {
	        return;
	      }
	      var w = this.width / 2, h = this.height / 2;
	      ctx.beginPath();
	      ctx.moveTo(-w, -h);
	      ctx.lineTo(w, -h);
	      ctx.lineTo(w, h);
	      ctx.lineTo(-w, h);
	      ctx.lineTo(-w, -h);
	      ctx.closePath();
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderDashedStroke: function(ctx) {
	      var x = -this.width / 2,
	          y = -this.height / 2,
	          w = this.width,
	          h = this.height;
	
	      ctx.save();
	      this._setStrokeStyles(ctx);
	
	      ctx.beginPath();
	      fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);
	      fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);
	      fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);
	      fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);
	      ctx.closePath();
	      ctx.restore();
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      var filters = [], resizeFilters = [],
	          scaleX = 1, scaleY = 1;
	
	      this.filters.forEach(function(filterObj) {
	        if (filterObj) {
	          if (filterObj.type === 'Resize') {
	            scaleX *= filterObj.scaleX;
	            scaleY *= filterObj.scaleY;
	          }
	          filters.push(filterObj.toObject());
	        }
	      });
	
	      this.resizeFilters.forEach(function(filterObj) {
	        filterObj && resizeFilters.push(filterObj.toObject());
	      });
	      var object = extend(
	        this.callSuper(
	          'toObject',
	          ['crossOrigin', 'alignX', 'alignY', 'meetOrSlice'].concat(propertiesToInclude)
	        ), {
	          src: this.getSrc(),
	          filters: filters,
	          resizeFilters: resizeFilters,
	        });
	
	      object.width /= scaleX;
	      object.height /= scaleY;
	
	      return object;
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns SVG representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var markup = this._createBaseSVGMarkup(), x = -this.width / 2, y = -this.height / 2,
	          preserveAspectRatio = 'none', filtered = true;
	      if (this.group && this.group.type === 'path-group') {
	        x = this.left;
	        y = this.top;
	      }
	      if (this.alignX !== 'none' && this.alignY !== 'none') {
	        preserveAspectRatio = 'x' + this.alignX + 'Y' + this.alignY + ' ' + this.meetOrSlice;
	      }
	      markup.push(
	        '<g transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '">\n',
	          '<image ', this.getSvgId(), 'xlink:href="', this.getSvgSrc(filtered),
	            '" x="', x, '" y="', y,
	            '" style="', this.getSvgStyles(),
	            // we're essentially moving origin of transformation from top/left corner to the center of the shape
	            // by wrapping it in container <g> element with actual transformation, then offsetting object to the top/left
	            // so that object's center aligns with container's left/top
	            '" width="', this.width,
	            '" height="', this.height,
	            '" preserveAspectRatio="', preserveAspectRatio, '"',
	          '></image>\n'
	      );
	
	      if (this.stroke || this.strokeDashArray) {
	        var origFill = this.fill;
	        this.fill = null;
	        markup.push(
	          '<rect ',
	            'x="', x, '" y="', y,
	            '" width="', this.width, '" height="', this.height,
	            '" style="', this.getSvgStyles(),
	          '"/>\n'
	        );
	        this.fill = origFill;
	      }
	
	      markup.push('</g>\n');
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns source of an image
	     * @param {Boolean} filtered indicates if the src is needed for svg
	     * @return {String} Source of an image
	     */
	    getSrc: function(filtered) {
	      var element = filtered ? this._element : this._originalElement;
	      if (element) {
	        return fabric.isLikelyNode ? element._src : element.src;
	      }
	      else {
	        return this.src || '';
	      }
	    },
	
	    /**
	     * Sets source of an image
	     * @param {String} src Source string (URL)
	     * @param {Function} [callback] Callback is invoked when image has been loaded (and all filters have been applied)
	     * @param {Object} [options] Options object
	     * @return {fabric.Image} thisArg
	     * @chainable
	     */
	    setSrc: function(src, callback, options) {
	      fabric.util.loadImage(src, function(img) {
	        return this.setElement(img, callback, options);
	      }, this, options && options.crossOrigin);
	    },
	
	    /**
	     * Returns string representation of an instance
	     * @return {String} String representation of an instance
	     */
	    toString: function() {
	      return '#<fabric.Image: { src: "' + this.getSrc() + '" }>';
	    },
	
	    /**
	     * Applies filters assigned to this image (from "filters" array)
	     * @method applyFilters
	     * @param {Function} callback Callback is invoked when all filters have been applied and new image is generated
	     * @param {Array} filters to be applied
	     * @param {fabric.Image} imgElement image to filter ( default to this._element )
	     * @param {Boolean} forResizing
	     * @return {CanvasElement} canvasEl to be drawn immediately
	     * @chainable
	     */
	    applyFilters: function(callback, filters, imgElement, forResizing) {
	
	      filters = filters || this.filters;
	      imgElement = imgElement || this._originalElement;
	
	      if (!imgElement) {
	        return;
	      }
	
	      var replacement = fabric.util.createImage(),
	          retinaScaling = this.canvas ? this.canvas.getRetinaScaling() : fabric.devicePixelRatio,
	          minimumScale = this.minimumScaleTrigger / retinaScaling,
	          _this = this, scaleX, scaleY;
	
	      if (filters.length === 0) {
	        this._element = imgElement;
	        callback && callback(this);
	        return imgElement;
	      }
	
	      var canvasEl = fabric.util.createCanvasElement();
	      canvasEl.width = imgElement.width;
	      canvasEl.height = imgElement.height;
	      canvasEl.getContext('2d').drawImage(imgElement, 0, 0, imgElement.width, imgElement.height);
	
	      filters.forEach(function(filter) {
	        if (!filter) {
	          return;
	        }
	        if (forResizing) {
	          scaleX = _this.scaleX < minimumScale ? _this.scaleX : 1;
	          scaleY = _this.scaleY < minimumScale ? _this.scaleY : 1;
	          if (scaleX * retinaScaling < 1) {
	            scaleX *= retinaScaling;
	          }
	          if (scaleY * retinaScaling < 1) {
	            scaleY *= retinaScaling;
	          }
	        }
	        else {
	          scaleX = filter.scaleX;
	          scaleY = filter.scaleY;
	        }
	        filter.applyTo(canvasEl, scaleX, scaleY);
	        if (!forResizing && filter.type === 'Resize') {
	          _this.width *= filter.scaleX;
	          _this.height *= filter.scaleY;
	        }
	      });
	
	      /** @ignore */
	      replacement.width = canvasEl.width;
	      replacement.height = canvasEl.height;
	      if (fabric.isLikelyNode) {
	        replacement.src = canvasEl.toBuffer(undefined, fabric.Image.pngCompression);
	        // onload doesn't fire in some node versions, so we invoke callback manually
	        _this._element = replacement;
	        !forResizing && (_this._filteredEl = replacement);
	        callback && callback(_this);
	      }
	      else {
	        replacement.onload = function() {
	          _this._element = replacement;
	          !forResizing && (_this._filteredEl = replacement);
	          callback && callback(_this);
	          replacement.onload = canvasEl = null;
	        };
	        replacement.src = canvasEl.toDataURL('image/png');
	      }
	      return canvasEl;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} noTransform
	     */
	    _render: function(ctx, noTransform) {
	      var x, y, imageMargins = this._findMargins(), elementToDraw;
	
	      x = (noTransform ? this.left : -this.width / 2);
	      y = (noTransform ? this.top : -this.height / 2);
	
	      if (this.meetOrSlice === 'slice') {
	        ctx.beginPath();
	        ctx.rect(x, y, this.width, this.height);
	        ctx.clip();
	      }
	
	      if (this.isMoving === false && this.resizeFilters.length && this._needsResize()) {
	        this._lastScaleX = this.scaleX;
	        this._lastScaleY = this.scaleY;
	        elementToDraw = this.applyFilters(null, this.resizeFilters, this._filteredEl || this._originalElement, true);
	      }
	      else {
	        elementToDraw = this._element;
	      }
	      elementToDraw && ctx.drawImage(elementToDraw,
	                                     x + imageMargins.marginX,
	                                     y + imageMargins.marginY,
	                                     imageMargins.width,
	                                     imageMargins.height
	                                    );
	
	      this._stroke(ctx);
	      this._renderStroke(ctx);
	    },
	
	    /**
	     * @private, needed to check if image needs resize
	     */
	    _needsResize: function() {
	      return (this.scaleX !== this._lastScaleX || this.scaleY !== this._lastScaleY);
	    },
	
	    /**
	     * @private
	     */
	    _findMargins: function() {
	      var width = this.width, height = this.height, scales,
	          scale, marginX = 0, marginY = 0;
	
	      if (this.alignX !== 'none' || this.alignY !== 'none') {
	        scales = [this.width / this._element.width, this.height / this._element.height];
	        scale = this.meetOrSlice === 'meet'
	                ? Math.min.apply(null, scales) : Math.max.apply(null, scales);
	        width = this._element.width * scale;
	        height = this._element.height * scale;
	        if (this.alignX === 'Mid') {
	          marginX = (this.width - width) / 2;
	        }
	        if (this.alignX === 'Max') {
	          marginX = this.width - width;
	        }
	        if (this.alignY === 'Mid') {
	          marginY = (this.height - height) / 2;
	        }
	        if (this.alignY === 'Max') {
	          marginY = this.height - height;
	        }
	      }
	      return {
	        width:  width,
	        height: height,
	        marginX: marginX,
	        marginY: marginY
	      };
	    },
	
	    /**
	     * @private
	     */
	    _resetWidthHeight: function() {
	      var element = this.getElement();
	
	      this.set('width', element.width);
	      this.set('height', element.height);
	    },
	
	    /**
	     * The Image class's initialization method. This method is automatically
	     * called by the constructor.
	     * @private
	     * @param {HTMLImageElement|String} element The element representing the image
	     * @param {Object} [options] Options object
	     */
	    _initElement: function(element, options, callback) {
	      this.setElement(fabric.util.getById(element), callback, options);
	      fabric.util.addClass(this.getElement(), fabric.Image.CSS_CANVAS);
	    },
	
	    /**
	     * @private
	     * @param {Object} [options] Options object
	     */
	    _initConfig: function(options) {
	      options || (options = { });
	      this.setOptions(options);
	      this._setWidthHeight(options);
	      if (this._element && this.crossOrigin) {
	        this._element.crossOrigin = this.crossOrigin;
	      }
	    },
	
	    /**
	     * @private
	     * @param {Array} filters to be initialized
	     * @param {Function} callback Callback to invoke when all fabric.Image.filters instances are created
	     */
	    _initFilters: function(filters, callback) {
	      if (filters && filters.length) {
	        fabric.util.enlivenObjects(filters, function(enlivenedObjects) {
	          callback && callback(enlivenedObjects);
	        }, 'fabric.Image.filters');
	      }
	      else {
	        callback && callback();
	      }
	    },
	
	    /**
	     * @private
	     * @param {Object} [options] Object with width/height properties
	     */
	    _setWidthHeight: function(options) {
	      this.width = 'width' in options
	        ? options.width
	        : (this.getElement()
	            ? this.getElement().width || 0
	            : 0);
	
	      this.height = 'height' in options
	        ? options.height
	        : (this.getElement()
	            ? this.getElement().height || 0
	            : 0);
	    },
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity of this instance
	     */
	    complexity: function() {
	      return 1;
	    }
	  });
	
	  /**
	   * Default CSS class name for canvas
	   * @static
	   * @type String
	   * @default
	   */
	  fabric.Image.CSS_CANVAS = 'canvas-img';
	
	  /**
	   * Alias for getSrc
	   * @static
	   */
	  fabric.Image.prototype.getSvgSrc = fabric.Image.prototype.getSrc;
	
	  /**
	   * Creates an instance of fabric.Image from its object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @param {Function} callback Callback to invoke when an image instance is created
	   */
	  fabric.Image.fromObject = function(object, callback) {
	    fabric.util.loadImage(object.src, function(img, error) {
	      if (error) {
	        callback && callback(null, error);
	        return;
	      }
	      fabric.Image.prototype._initFilters.call(object, object.filters, function(filters) {
	        object.filters = filters || [];
	        fabric.Image.prototype._initFilters.call(object, object.resizeFilters, function(resizeFilters) {
	          object.resizeFilters = resizeFilters || [];
	          return new fabric.Image(img, object, callback);
	        });
	      });
	    }, null, object.crossOrigin);
	  };
	
	  /**
	   * Creates an instance of fabric.Image from an URL string
	   * @static
	   * @param {String} url URL to create an image from
	   * @param {Function} [callback] Callback to invoke when image is created (newly created image is passed as a first argument)
	   * @param {Object} [imgOptions] Options object
	   */
	  fabric.Image.fromURL = function(url, callback, imgOptions) {
	    fabric.util.loadImage(url, function(img) {
	      callback && callback(new fabric.Image(img, imgOptions));
	    }, null, imgOptions && imgOptions.crossOrigin);
	  };
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Image.fromElement})
	   * @static
	   * @see {@link http://www.w3.org/TR/SVG/struct.html#ImageElement}
	   */
	  fabric.Image.ATTRIBUTE_NAMES =
	    fabric.SHARED_ATTRIBUTES.concat('x y width height preserveAspectRatio xlink:href'.split(' '));
	
	  /**
	   * Returns {@link fabric.Image} instance from an SVG element
	   * @static
	   * @param {SVGElement} element Element to parse
	   * @param {Function} callback Callback to execute when fabric.Image object is created
	   * @param {Object} [options] Options object
	   * @return {fabric.Image} Instance of fabric.Image
	   */
	  fabric.Image.fromElement = function(element, callback, options) {
	    var parsedAttributes = fabric.parseAttributes(element, fabric.Image.ATTRIBUTE_NAMES),
	        preserveAR;
	
	    if (parsedAttributes.preserveAspectRatio) {
	      preserveAR = fabric.util.parsePreserveAspectRatioAttribute(parsedAttributes.preserveAspectRatio);
	      extend(parsedAttributes, preserveAR);
	    }
	
	    fabric.Image.fromURL(parsedAttributes['xlink:href'], callback,
	      extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));
	  };
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Indicates that instances of this type are async
	   * @static
	   * @type Boolean
	   * @default
	   */
	  fabric.Image.async = true;
	
	  /**
	   * Indicates compression level used when generating PNG under Node (in applyFilters). Any of 0-9
	   * @static
	   * @type Number
	   * @default
	   */
	  fabric.Image.pngCompression = 1;
	
	})( true ? exports : this);
	
	
	fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
	
	  /**
	   * @private
	   * @return {Number} angle value
	   */
	  _getAngleValueForStraighten: function() {
	    var angle = this.getAngle() % 360;
	    if (angle > 0) {
	      return Math.round((angle - 1) / 90) * 90;
	    }
	    return Math.round(angle / 90) * 90;
	  },
	
	  /**
	   * Straightens an object (rotating it from current angle to one of 0, 90, 180, 270, etc. depending on which is closer)
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  straighten: function() {
	    this.setAngle(this._getAngleValueForStraighten());
	    return this;
	  },
	
	  /**
	   * Same as {@link fabric.Object.prototype.straighten} but with animation
	   * @param {Object} callbacks Object with callback functions
	   * @param {Function} [callbacks.onComplete] Invoked on completion
	   * @param {Function} [callbacks.onChange] Invoked on every step of animation
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  fxStraighten: function(callbacks) {
	    callbacks = callbacks || { };
	
	    var empty = function() { },
	        onComplete = callbacks.onComplete || empty,
	        onChange = callbacks.onChange || empty,
	        _this = this;
	
	    fabric.util.animate({
	      startValue: this.get('angle'),
	      endValue: this._getAngleValueForStraighten(),
	      duration: this.FX_DURATION,
	      onChange: function(value) {
	        _this.setAngle(value);
	        onChange();
	      },
	      onComplete: function() {
	        _this.setCoords();
	        onComplete();
	      },
	      onStart: function() {
	        _this.set('active', false);
	      }
	    });
	
	    return this;
	  }
	});
	
	fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {
	
	  /**
	   * Straightens object, then rerenders canvas
	   * @param {fabric.Object} object Object to straighten
	   * @return {fabric.Canvas} thisArg
	   * @chainable
	   */
	  straightenObject: function (object) {
	    object.straighten();
	    this.renderAll();
	    return this;
	  },
	
	  /**
	   * Same as {@link fabric.Canvas.prototype.straightenObject}, but animated
	   * @param {fabric.Object} object Object to straighten
	   * @return {fabric.Canvas} thisArg
	   * @chainable
	   */
	  fxStraightenObject: function (object) {
	    object.fxStraighten({
	      onChange: this.renderAll.bind(this)
	    });
	    return this;
	  }
	});
	
	
	/**
	 * @namespace fabric.Image.filters
	 * @memberOf fabric.Image
	 * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#image_filters}
	 * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	 */
	fabric.Image.filters = fabric.Image.filters || { };
	
	/**
	 * Root filter class from which all filter classes inherit from
	 * @class fabric.Image.filters.BaseFilter
	 * @memberOf fabric.Image.filters
	 */
	fabric.Image.filters.BaseFilter = fabric.util.createClass(/** @lends fabric.Image.filters.BaseFilter.prototype */ {
	
	  /**
	   * Filter type
	   * @param {String} type
	   * @default
	   */
	  type: 'BaseFilter',
	
	  /**
	   * Constructor
	   * @param {Object} [options] Options object
	   */
	  initialize: function(options) {
	    if (options) {
	      this.setOptions(options);
	    }
	  },
	
	  /**
	   * Sets filter's properties from options
	   * @param {Object} [options] Options object
	   */
	  setOptions: function(options) {
	    for (var prop in options) {
	      this[prop] = options[prop];
	    }
	  },
	
	  /**
	   * Returns object representation of an instance
	   * @return {Object} Object representation of an instance
	   */
	  toObject: function() {
	    return { type: this.type };
	  },
	
	  /**
	   * Returns a JSON representation of an instance
	   * @return {Object} JSON
	   */
	  toJSON: function() {
	    // delegate, not alias
	    return this.toObject();
	  }
	});
	
	fabric.Image.filters.BaseFilter.fromObject = function(object, callback) {
	  var filter = new fabric.Image.filters[object.type](object);
	  callback && callback(filter);
	  return filter;
	};
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Brightness filter class
	   * @class fabric.Image.filters.Brightness
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.Brightness#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Brightness({
	   *   brightness: 200
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Brightness = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Brightness.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Brightness',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.Brightness.prototype
	     * @param {Object} [options] Options object
	     * @param {Number} [options.brightness=0] Value to brighten the image up (-255..255)
	     */
	    initialize: function(options) {
	      options = options || { };
	      this.brightness = options.brightness || 0;
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          brightness = this.brightness;
	
	      for (var i = 0, len = data.length; i < len; i += 4) {
	        data[i] += brightness;
	        data[i + 1] += brightness;
	        data[i + 2] += brightness;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        brightness: this.brightness
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @param {function} [callback] to be invoked after filter creation
	   * @return {fabric.Image.filters.Brightness} Instance of fabric.Image.filters.Brightness
	   */
	  fabric.Image.filters.Brightness.fromObject = fabric.Image.filters.BaseFilter.fromObject;
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Adapted from <a href="http://www.html5rocks.com/en/tutorials/canvas/imagefilters/">html5rocks article</a>
	   * @class fabric.Image.filters.Convolute
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.Convolute#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example <caption>Sharpen filter</caption>
	   * var filter = new fabric.Image.filters.Convolute({
	   *   matrix: [ 0, -1,  0,
	   *            -1,  5, -1,
	   *             0, -1,  0 ]
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   * @example <caption>Blur filter</caption>
	   * var filter = new fabric.Image.filters.Convolute({
	   *   matrix: [ 1/9, 1/9, 1/9,
	   *             1/9, 1/9, 1/9,
	   *             1/9, 1/9, 1/9 ]
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   * @example <caption>Emboss filter</caption>
	   * var filter = new fabric.Image.filters.Convolute({
	   *   matrix: [ 1,   1,  1,
	   *             1, 0.7, -1,
	   *            -1,  -1, -1 ]
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   * @example <caption>Emboss filter with opaqueness</caption>
	   * var filter = new fabric.Image.filters.Convolute({
	   *   opaque: true,
	   *   matrix: [ 1,   1,  1,
	   *             1, 0.7, -1,
	   *            -1,  -1, -1 ]
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Convolute = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Convolute.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Convolute',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.Convolute.prototype
	     * @param {Object} [options] Options object
	     * @param {Boolean} [options.opaque=false] Opaque value (true/false)
	     * @param {Array} [options.matrix] Filter matrix
	     */
	    initialize: function(options) {
	      options = options || { };
	
	      this.opaque = options.opaque;
	      this.matrix = options.matrix || [
	        0, 0, 0,
	        0, 1, 0,
	        0, 0, 0
	      ];
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	
	      var weights = this.matrix,
	          context = canvasEl.getContext('2d'),
	          pixels = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	
	          side = Math.round(Math.sqrt(weights.length)),
	          halfSide = Math.floor(side / 2),
	          src = pixels.data,
	          sw = pixels.width,
	          sh = pixels.height,
	          output = context.createImageData(sw, sh),
	          dst = output.data,
	          // go through the destination image pixels
	          alphaFac = this.opaque ? 1 : 0,
	          r, g, b, a, dstOff,
	          scx, scy, srcOff, wt;
	
	      for (var y = 0; y < sh; y++) {
	        for (var x = 0; x < sw; x++) {
	          dstOff = (y * sw + x) * 4;
	          // calculate the weighed sum of the source image pixels that
	          // fall under the convolution matrix
	          r = 0; g = 0; b = 0; a = 0;
	
	          for (var cy = 0; cy < side; cy++) {
	            for (var cx = 0; cx < side; cx++) {
	              scy = y + cy - halfSide;
	              scx = x + cx - halfSide;
	
	              // eslint-disable-next-line max-depth
	              if (scy < 0 || scy > sh || scx < 0 || scx > sw) {
	                continue;
	              }
	
	              srcOff = (scy * sw + scx) * 4;
	              wt = weights[cy * side + cx];
	
	              r += src[srcOff] * wt;
	              g += src[srcOff + 1] * wt;
	              b += src[srcOff + 2] * wt;
	              a += src[srcOff + 3] * wt;
	            }
	          }
	          dst[dstOff] = r;
	          dst[dstOff + 1] = g;
	          dst[dstOff + 2] = b;
	          dst[dstOff + 3] = a + alphaFac * (255 - a);
	        }
	      }
	
	      context.putImageData(output, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        opaque: this.opaque,
	        matrix: this.matrix
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @param {function} [callback] to be invoked after filter creation
	   * @return {fabric.Image.filters.Convolute} Instance of fabric.Image.filters.Convolute
	   */
	  fabric.Image.filters.Convolute.fromObject = fabric.Image.filters.BaseFilter.fromObject;
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * GradientTransparency filter class
	   * @class fabric.Image.filters.GradientTransparency
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.GradientTransparency#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.GradientTransparency({
	   *   threshold: 200
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	   // eslint-disable-next-line max-len
	  filters.GradientTransparency = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.GradientTransparency.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'GradientTransparency',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.GradientTransparency.prototype
	     * @param {Object} [options] Options object
	     * @param {Number} [options.threshold=100] Threshold value
	     */
	    initialize: function(options) {
	      options = options || { };
	      this.threshold = options.threshold || 100;
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          threshold = this.threshold,
	          total = data.length;
	
	      for (var i = 0, len = data.length; i < len; i += 4) {
	        data[i + 3] = threshold + 255 * (total - i) / total;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        threshold: this.threshold
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @param {function} [callback] to be invoked after filter creation
	   * @return {fabric.Image.filters.GradientTransparency} Instance of fabric.Image.filters.GradientTransparency
	   */
	  fabric.Image.filters.GradientTransparency.fromObject = fabric.Image.filters.BaseFilter.fromObject;
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Grayscale image filter class
	   * @class fabric.Image.filters.Grayscale
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Grayscale();
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Grayscale = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Grayscale.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Grayscale',
	
	    /**
	     * Applies filter to canvas element
	     * @memberOf fabric.Image.filters.Grayscale.prototype
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          len = imageData.width * imageData.height * 4,
	          index = 0,
	          average;
	
	      while (index < len) {
	        average = (data[index] + data[index + 1] + data[index + 2]) / 3;
	        data[index]     = average;
	        data[index + 1] = average;
	        data[index + 2] = average;
	        index += 4;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @param {function} [callback] to be invoked after filter creation
	   * @return {fabric.Image.filters.Grayscale} Instance of fabric.Image.filters.Grayscale
	   */
	  fabric.Image.filters.Grayscale.fromObject = function(object, callback) {
	    object = object || { };
	    object.type = 'Grayscale';
	    return fabric.Image.filters.BaseFilter.fromObject(object, callback);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Invert filter class
	   * @class fabric.Image.filters.Invert
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Invert();
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Invert = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Invert.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Invert',
	
	    /**
	     * Applies filter to canvas element
	     * @memberOf fabric.Image.filters.Invert.prototype
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          iLen = data.length, i;
	
	      for (i = 0; i < iLen; i += 4) {
	        data[i] = 255 - data[i];
	        data[i + 1] = 255 - data[i + 1];
	        data[i + 2] = 255 - data[i + 2];
	      }
	
	      context.putImageData(imageData, 0, 0);
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @param {function} [callback] to be invoked after filter creation
	   * @return {fabric.Image.filters.Invert} Instance of fabric.Image.filters.Invert
	   */
	  fabric.Image.filters.Invert.fromObject = function(object, callback) {
	    object = object || { };
	    object.type = 'Invert';
	    return fabric.Image.filters.BaseFilter.fromObject(object, callback);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Mask filter class
	   * See http://resources.aleph-1.com/mask/
	   * @class fabric.Image.filters.Mask
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.Mask#initialize} for constructor definition
	   */
	  filters.Mask = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Mask.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Mask',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.Mask.prototype
	     * @param {Object} [options] Options object
	     * @param {fabric.Image} [options.mask] Mask image object
	     * @param {Number} [options.channel=0] Rgb channel (0, 1, 2 or 3)
	     */
	    initialize: function(options) {
	      options = options || { };
	
	      this.mask = options.mask;
	      this.channel = [0, 1, 2, 3].indexOf(options.channel) > -1 ? options.channel : 0;
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      if (!this.mask) {
	        return;
	      }
	
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          maskEl = this.mask.getElement(),
	          maskCanvasEl = fabric.util.createCanvasElement(),
	          channel = this.channel,
	          i,
	          iLen = imageData.width * imageData.height * 4;
	
	      maskCanvasEl.width = canvasEl.width;
	      maskCanvasEl.height = canvasEl.height;
	
	      maskCanvasEl.getContext('2d').drawImage(maskEl, 0, 0, canvasEl.width, canvasEl.height);
	
	      var maskImageData = maskCanvasEl.getContext('2d').getImageData(0, 0, canvasEl.width, canvasEl.height),
	          maskData = maskImageData.data;
	
	      for (i = 0; i < iLen; i += 4) {
	        data[i + 3] = maskData[i + channel];
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        mask: this.mask.toObject(),
	        channel: this.channel
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] Callback to invoke when a mask filter instance is created
	   */
	  fabric.Image.filters.Mask.fromObject = function(object, callback) {
	    fabric.util.loadImage(object.mask.src, function(img) {
	      object.mask = new fabric.Image(img, object.mask);
	      return fabric.Image.filters.BaseFilter.fromObject(object, callback);
	    });
	  };
	
	  /**
	   * Indicates that instances of this type are async
	   * @static
	   * @type Boolean
	   * @default
	   */
	  fabric.Image.filters.Mask.async = true;
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Noise filter class
	   * @class fabric.Image.filters.Noise
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.Noise#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Noise({
	   *   noise: 700
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Noise = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Noise.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Noise',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.Noise.prototype
	     * @param {Object} [options] Options object
	     * @param {Number} [options.noise=0] Noise value
	     */
	    initialize: function(options) {
	      options = options || { };
	      this.noise = options.noise || 0;
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          noise = this.noise, rand;
	
	      for (var i = 0, len = data.length; i < len; i += 4) {
	
	        rand = (0.5 - Math.random()) * noise;
	
	        data[i] += rand;
	        data[i + 1] += rand;
	        data[i + 2] += rand;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        noise: this.noise
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] to be invoked after filter creation
	   * @return {fabric.Image.filters.Noise} Instance of fabric.Image.filters.Noise
	   */
	  fabric.Image.filters.Noise.fromObject = fabric.Image.filters.BaseFilter.fromObject;
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Pixelate filter class
	   * @class fabric.Image.filters.Pixelate
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.Pixelate#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Pixelate({
	   *   blocksize: 8
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Pixelate = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Pixelate.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Pixelate',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.Pixelate.prototype
	     * @param {Object} [options] Options object
	     * @param {Number} [options.blocksize=4] Blocksize for pixelate
	     */
	    initialize: function(options) {
	      options = options || { };
	      this.blocksize = options.blocksize || 4;
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          iLen = imageData.height,
	          jLen = imageData.width,
	          index, i, j, r, g, b, a;
	
	      for (i = 0; i < iLen; i += this.blocksize) {
	        for (j = 0; j < jLen; j += this.blocksize) {
	
	          index = (i * 4) * jLen + (j * 4);
	
	          r = data[index];
	          g = data[index + 1];
	          b = data[index + 2];
	          a = data[index + 3];
	
	          /*
	           blocksize: 4
	
	           [1,x,x,x,1]
	           [x,x,x,x,1]
	           [x,x,x,x,1]
	           [x,x,x,x,1]
	           [1,1,1,1,1]
	           */
	
	          for (var _i = i, _ilen = i + this.blocksize; _i < _ilen; _i++) {
	            for (var _j = j, _jlen = j + this.blocksize; _j < _jlen; _j++) {
	              index = (_i * 4) * jLen + (_j * 4);
	              data[index] = r;
	              data[index + 1] = g;
	              data[index + 2] = b;
	              data[index + 3] = a;
	            }
	          }
	        }
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        blocksize: this.blocksize
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] to be invoked after filter creation
	   * @return {fabric.Image.filters.Pixelate} Instance of fabric.Image.filters.Pixelate
	   */
	  fabric.Image.filters.Pixelate.fromObject = fabric.Image.filters.BaseFilter.fromObject;
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Remove white filter class
	   * @class fabric.Image.filters.RemoveWhite
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.RemoveWhite#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.RemoveWhite({
	   *   threshold: 40,
	   *   distance: 140
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.RemoveWhite = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.RemoveWhite.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'RemoveWhite',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.RemoveWhite.prototype
	     * @param {Object} [options] Options object
	     * @param {Number} [options.threshold=30] Threshold value
	     * @param {Number} [options.distance=20] Distance value
	     */
	    initialize: function(options) {
	      options = options || { };
	      this.threshold = options.threshold || 30;
	      this.distance = options.distance || 20;
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          threshold = this.threshold,
	          distance = this.distance,
	          limit = 255 - threshold,
	          abs = Math.abs,
	          r, g, b;
	
	      for (var i = 0, len = data.length; i < len; i += 4) {
	        r = data[i];
	        g = data[i + 1];
	        b = data[i + 2];
	
	        if (r > limit &&
	            g > limit &&
	            b > limit &&
	            abs(r - g) < distance &&
	            abs(r - b) < distance &&
	            abs(g - b) < distance
	        ) {
	          data[i + 3] = 0;
	        }
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        threshold: this.threshold,
	        distance: this.distance
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] to be invoked after filter creation
	   * @return {fabric.Image.filters.RemoveWhite} Instance of fabric.Image.filters.RemoveWhite
	   */
	  fabric.Image.filters.RemoveWhite.fromObject = fabric.Image.filters.BaseFilter.fromObject;
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Sepia filter class
	   * @class fabric.Image.filters.Sepia
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Sepia();
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Sepia = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Sepia.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Sepia',
	
	    /**
	     * Applies filter to canvas element
	     * @memberOf fabric.Image.filters.Sepia.prototype
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          iLen = data.length, i, avg;
	
	      for (i = 0; i < iLen; i += 4) {
	        avg = 0.3  * data[i] + 0.59 * data[i + 1] + 0.11 * data[i + 2];
	        data[i] = avg + 100;
	        data[i + 1] = avg + 50;
	        data[i + 2] = avg + 255;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] to be invoked after filter creation
	   * @return {fabric.Image.filters.Sepia} Instance of fabric.Image.filters.Sepia
	   */
	  fabric.Image.filters.Sepia.fromObject = function(object, callback) {
	    object = object || { };
	    object.type = 'Sepia';
	    return new fabric.Image.filters.BaseFilter.fromObject(object, callback);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Sepia2 filter class
	   * @class fabric.Image.filters.Sepia2
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Sepia2();
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Sepia2 = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Sepia2.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Sepia2',
	
	    /**
	     * Applies filter to canvas element
	     * @memberOf fabric.Image.filters.Sepia.prototype
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          iLen = data.length, i, r, g, b;
	
	      for (i = 0; i < iLen; i += 4) {
	        r = data[i];
	        g = data[i + 1];
	        b = data[i + 2];
	
	        data[i] = (r * 0.393 + g * 0.769 + b * 0.189 ) / 1.351;
	        data[i + 1] = (r * 0.349 + g * 0.686 + b * 0.168 ) / 1.203;
	        data[i + 2] = (r * 0.272 + g * 0.534 + b * 0.131 ) / 2.140;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] to be invoked after filter creation
	   * @return {fabric.Image.filters.Sepia2} Instance of fabric.Image.filters.Sepia2
	   */
	  fabric.Image.filters.Sepia2.fromObject = function(object, callback) {
	    object = object || { };
	    object.type = 'Sepia2';
	    return new fabric.Image.filters.BaseFilter.fromObject(object, callback);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Tint filter class
	   * Adapted from <a href="https://github.com/mezzoblue/PaintbrushJS">https://github.com/mezzoblue/PaintbrushJS</a>
	   * @class fabric.Image.filters.Tint
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.Tint#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example <caption>Tint filter with hex color and opacity</caption>
	   * var filter = new fabric.Image.filters.Tint({
	   *   color: '#3513B0',
	   *   opacity: 0.5
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   * @example <caption>Tint filter with rgba color</caption>
	   * var filter = new fabric.Image.filters.Tint({
	   *   color: 'rgba(53, 21, 176, 0.5)'
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Tint = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Tint.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Tint',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.Tint.prototype
	     * @param {Object} [options] Options object
	     * @param {String} [options.color=#000000] Color to tint the image with
	     * @param {Number} [options.opacity] Opacity value that controls the tint effect's transparency (0..1)
	     */
	    initialize: function(options) {
	      options = options || { };
	
	      this.color = options.color || '#000000';
	      this.opacity = typeof options.opacity !== 'undefined'
	                      ? options.opacity
	                      : new fabric.Color(this.color).getAlpha();
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          iLen = data.length, i,
	          tintR, tintG, tintB,
	          r, g, b, alpha1,
	          source;
	
	      source = new fabric.Color(this.color).getSource();
	
	      tintR = source[0] * this.opacity;
	      tintG = source[1] * this.opacity;
	      tintB = source[2] * this.opacity;
	
	      alpha1 = 1 - this.opacity;
	
	      for (i = 0; i < iLen; i += 4) {
	        r = data[i];
	        g = data[i + 1];
	        b = data[i + 2];
	
	        // alpha compositing
	        data[i] = tintR + r * alpha1;
	        data[i + 1] = tintG + g * alpha1;
	        data[i + 2] = tintB + b * alpha1;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        color: this.color,
	        opacity: this.opacity
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] to be invoked after filter creation
	   * @return {fabric.Image.filters.Tint} Instance of fabric.Image.filters.Tint
	   */
	  fabric.Image.filters.Tint.fromObject = fabric.Image.filters.BaseFilter.fromObject;
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Multiply filter class
	   * Adapted from <a href="http://www.laurenscorijn.com/articles/colormath-basics">http://www.laurenscorijn.com/articles/colormath-basics</a>
	   * @class fabric.Image.filters.Multiply
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @example <caption>Multiply filter with hex color</caption>
	   * var filter = new fabric.Image.filters.Multiply({
	   *   color: '#F0F'
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   * @example <caption>Multiply filter with rgb color</caption>
	   * var filter = new fabric.Image.filters.Multiply({
	   *   color: 'rgb(53, 21, 176)'
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Multiply = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Multiply.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Multiply',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.Multiply.prototype
	     * @param {Object} [options] Options object
	     * @param {String} [options.color=#000000] Color to multiply the image pixels with
	     */
	    initialize: function(options) {
	      options = options || { };
	
	      this.color = options.color || '#000000';
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          iLen = data.length, i,
	          source;
	
	      source = new fabric.Color(this.color).getSource();
	
	      for (i = 0; i < iLen; i += 4) {
	        data[i] *= source[0] / 255;
	        data[i + 1] *= source[1] / 255;
	        data[i + 2] *= source[2] / 255;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        color: this.color
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] to be invoked after filter creation
	   * @return {fabric.Image.filters.Multiply} Instance of fabric.Image.filters.Multiply
	   */
	  fabric.Image.filters.Multiply.fromObject = fabric.Image.filters.BaseFilter.fromObject;
	
	})( true ? exports : this);
	
	
	(function(global) {
	  'use strict';
	
	  var fabric = global.fabric,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Color Blend filter class
	   * @class fabric.Image.filter.Blend
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @example
	   * var filter = new fabric.Image.filters.Blend({
	   *  color: '#000',
	   *  mode: 'multiply'
	   * });
	   *
	   * var filter = new fabric.Image.filters.Blend({
	   *  image: fabricImageObject,
	   *  mode: 'multiply',
	   *  alpha: 0.5
	   * });
	
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	
	  filters.Blend = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blend.prototype */ {
	    type: 'Blend',
	
	    initialize: function(options) {
	      options = options || {};
	      this.color = options.color || '#000';
	      this.image = options.image || false;
	      this.mode = options.mode || 'multiply';
	      this.alpha = options.alpha || 1;
	    },
	
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          tr, tg, tb,
	          r, g, b,
	          _r, _g, _b,
	          source,
	          isImage = false;
	
	      if (this.image) {
	        // Blend images
	        isImage = true;
	
	        var _el = fabric.util.createCanvasElement();
	        _el.width = this.image.width;
	        _el.height = this.image.height;
	
	        var tmpCanvas = new fabric.StaticCanvas(_el);
	        tmpCanvas.add(this.image);
	        var context2 =  tmpCanvas.getContext('2d');
	        source = context2.getImageData(0, 0, tmpCanvas.width, tmpCanvas.height).data;
	      }
	      else {
	        // Blend color
	        source = new fabric.Color(this.color).getSource();
	
	        tr = source[0] * this.alpha;
	        tg = source[1] * this.alpha;
	        tb = source[2] * this.alpha;
	      }
	
	      for (var i = 0, len = data.length; i < len; i += 4) {
	
	        r = data[i];
	        g = data[i + 1];
	        b = data[i + 2];
	
	        if (isImage) {
	          tr = source[i] * this.alpha;
	          tg = source[i + 1] * this.alpha;
	          tb = source[i + 2] * this.alpha;
	        }
	
	        switch (this.mode) {
	          case 'multiply':
	            data[i] = r * tr / 255;
	            data[i + 1] = g * tg / 255;
	            data[i + 2] = b * tb / 255;
	            break;
	          case 'screen':
	            data[i] = 1 - (1 - r) * (1 - tr);
	            data[i + 1] = 1 - (1 - g) * (1 - tg);
	            data[i + 2] = 1 - (1 - b) * (1 - tb);
	            break;
	          case 'add':
	            data[i] = Math.min(255, r + tr);
	            data[i + 1] = Math.min(255, g + tg);
	            data[i + 2] = Math.min(255, b + tb);
	            break;
	          case 'diff':
	          case 'difference':
	            data[i] = Math.abs(r - tr);
	            data[i + 1] = Math.abs(g - tg);
	            data[i + 2] = Math.abs(b - tb);
	            break;
	          case 'subtract':
	            _r = r - tr;
	            _g = g - tg;
	            _b = b - tb;
	
	            data[i] = (_r < 0) ? 0 : _r;
	            data[i + 1] = (_g < 0) ? 0 : _g;
	            data[i + 2] = (_b < 0) ? 0 : _b;
	            break;
	          case 'darken':
	            data[i] = Math.min(r, tr);
	            data[i + 1] = Math.min(g, tg);
	            data[i + 2] = Math.min(b, tb);
	            break;
	          case 'lighten':
	            data[i] = Math.max(r, tr);
	            data[i + 1] = Math.max(g, tg);
	            data[i + 2] = Math.max(b, tb);
	            break;
	        }
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return {
	        color: this.color,
	        image: this.image,
	        mode: this.mode,
	        alpha: this.alpha
	      };
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @param {function} [callback] to be invoked after filter creation
	   * @return {fabric.Image.filters.Blend} Instance of fabric.Image.filters.Blend
	   */
	  fabric.Image.filters.Blend.fromObject = fabric.Image.filters.BaseFilter.fromObject;
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }), pow = Math.pow, floor = Math.floor,
	      sqrt = Math.sqrt, abs = Math.abs, max = Math.max, round = Math.round, sin = Math.sin,
	      ceil = Math.ceil,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Resize image filter class
	   * @class fabric.Image.filters.Resize
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Resize();
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Resize = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Resize.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Resize',
	
	    /**
	     * Resize type
	     * @param {String} resizeType
	     * @default
	     */
	    resizeType: 'hermite',
	
	    /**
	     * Scale factor for resizing, x axis
	     * @param {Number} scaleX
	     * @default
	     */
	    scaleX: 0,
	
	    /**
	     * Scale factor for resizing, y axis
	     * @param {Number} scaleY
	     * @default
	     */
	    scaleY: 0,
	
	    /**
	     * LanczosLobes parameter for lanczos filter
	     * @param {Number} lanczosLobes
	     * @default
	     */
	    lanczosLobes: 3,
	
	    /**
	     * Applies filter to canvas element
	     * @memberOf fabric.Image.filters.Resize.prototype
	     * @param {Object} canvasEl Canvas element to apply filter to
	     * @param {Number} scaleX
	     * @param {Number} scaleY
	     */
	    applyTo: function(canvasEl, scaleX, scaleY) {
	      if (scaleX === 1 && scaleY === 1) {
	        return;
	      }
	
	      this.rcpScaleX = 1 / scaleX;
	      this.rcpScaleY = 1 / scaleY;
	
	      var oW = canvasEl.width, oH = canvasEl.height,
	          dW = round(oW * scaleX), dH = round(oH * scaleY),
	          imageData;
	
	      if (this.resizeType === 'sliceHack') {
	        imageData = this.sliceByTwo(canvasEl, oW, oH, dW, dH);
	      }
	      if (this.resizeType === 'hermite') {
	        imageData = this.hermiteFastResize(canvasEl, oW, oH, dW, dH);
	      }
	      if (this.resizeType === 'bilinear') {
	        imageData = this.bilinearFiltering(canvasEl, oW, oH, dW, dH);
	      }
	      if (this.resizeType === 'lanczos') {
	        imageData = this.lanczosResize(canvasEl, oW, oH, dW, dH);
	      }
	      canvasEl.width = dW;
	      canvasEl.height = dH;
	      canvasEl.getContext('2d').putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Filter sliceByTwo
	     * @param {Object} canvasEl Canvas element to apply filter to
	     * @param {Number} oW Original Width
	     * @param {Number} oH Original Height
	     * @param {Number} dW Destination Width
	     * @param {Number} dH Destination Height
	     * @returns {ImageData}
	     */
	    sliceByTwo: function(canvasEl, oW, oH, dW, dH) {
	      var context = canvasEl.getContext('2d'), imageData,
	          multW = 0.5, multH = 0.5, signW = 1, signH = 1,
	          doneW = false, doneH = false, stepW = oW, stepH = oH,
	          tmpCanvas = fabric.util.createCanvasElement(),
	          tmpCtx = tmpCanvas.getContext('2d');
	      dW = floor(dW);
	      dH = floor(dH);
	      tmpCanvas.width = max(dW, oW);
	      tmpCanvas.height = max(dH, oH);
	
	      if (dW > oW) {
	        multW = 2;
	        signW = -1;
	      }
	      if (dH > oH) {
	        multH = 2;
	        signH = -1;
	      }
	      imageData = context.getImageData(0, 0, oW, oH);
	      canvasEl.width = max(dW, oW);
	      canvasEl.height = max(dH, oH);
	      context.putImageData(imageData, 0, 0);
	
	      while (!doneW || !doneH) {
	        oW = stepW;
	        oH = stepH;
	        if (dW * signW < floor(stepW * multW * signW)) {
	          stepW = floor(stepW * multW);
	        }
	        else {
	          stepW = dW;
	          doneW = true;
	        }
	        if (dH * signH < floor(stepH * multH * signH)) {
	          stepH = floor(stepH * multH);
	        }
	        else {
	          stepH = dH;
	          doneH = true;
	        }
	        imageData = context.getImageData(0, 0, oW, oH);
	        tmpCtx.putImageData(imageData, 0, 0);
	        context.clearRect(0, 0, stepW, stepH);
	        context.drawImage(tmpCanvas, 0, 0, oW, oH, 0, 0, stepW, stepH);
	      }
	      return context.getImageData(0, 0, dW, dH);
	    },
	
	    /**
	     * Filter lanczosResize
	     * @param {Object} canvasEl Canvas element to apply filter to
	     * @param {Number} oW Original Width
	     * @param {Number} oH Original Height
	     * @param {Number} dW Destination Width
	     * @param {Number} dH Destination Height
	     * @returns {ImageData}
	     */
	    lanczosResize: function(canvasEl, oW, oH, dW, dH) {
	
	      function lanczosCreate(lobes) {
	        return function(x) {
	          if (x > lobes) {
	            return 0;
	          }
	          x *= Math.PI;
	          if (abs(x) < 1e-16) {
	            return 1;
	          }
	          var xx = x / lobes;
	          return sin(x) * sin(xx) / x / xx;
	        };
	      }
	
	      function process(u) {
	        var v, i, weight, idx, a, red, green,
	            blue, alpha, fX, fY;
	        center.x = (u + 0.5) * ratioX;
	        icenter.x = floor(center.x);
	        for (v = 0; v < dH; v++) {
	          center.y = (v + 0.5) * ratioY;
	          icenter.y = floor(center.y);
	          a = 0; red = 0; green = 0; blue = 0; alpha = 0;
	          for (i = icenter.x - range2X; i <= icenter.x + range2X; i++) {
	            if (i < 0 || i >= oW) {
	              continue;
	            }
	            fX = floor(1000 * abs(i - center.x));
	            if (!cacheLanc[fX]) {
	              cacheLanc[fX] = { };
	            }
	            for (var j = icenter.y - range2Y; j <= icenter.y + range2Y; j++) {
	              if (j < 0 || j >= oH) {
	                continue;
	              }
	              fY = floor(1000 * abs(j - center.y));
	              if (!cacheLanc[fX][fY]) {
	                cacheLanc[fX][fY] = lanczos(sqrt(pow(fX * rcpRatioX, 2) + pow(fY * rcpRatioY, 2)) / 1000);
	              }
	              weight = cacheLanc[fX][fY];
	              if (weight > 0) {
	                idx = (j * oW + i) * 4;
	                a += weight;
	                red += weight * srcData[idx];
	                green += weight * srcData[idx + 1];
	                blue += weight * srcData[idx + 2];
	                alpha += weight * srcData[idx + 3];
	              }
	            }
	          }
	          idx = (v * dW + u) * 4;
	          destData[idx] = red / a;
	          destData[idx + 1] = green / a;
	          destData[idx + 2] = blue / a;
	          destData[idx + 3] = alpha / a;
	        }
	
	        if (++u < dW) {
	          return process(u);
	        }
	        else {
	          return destImg;
	        }
	      }
	
	      var context = canvasEl.getContext('2d'),
	          srcImg = context.getImageData(0, 0, oW, oH),
	          destImg = context.getImageData(0, 0, dW, dH),
	          srcData = srcImg.data, destData = destImg.data,
	          lanczos = lanczosCreate(this.lanczosLobes),
	          ratioX = this.rcpScaleX, ratioY = this.rcpScaleY,
	          rcpRatioX = 2 / this.rcpScaleX, rcpRatioY = 2 / this.rcpScaleY,
	          range2X = ceil(ratioX * this.lanczosLobes / 2),
	          range2Y = ceil(ratioY * this.lanczosLobes / 2),
	          cacheLanc = { }, center = { }, icenter = { };
	
	      return process(0);
	    },
	
	    /**
	     * bilinearFiltering
	     * @param {Object} canvasEl Canvas element to apply filter to
	     * @param {Number} oW Original Width
	     * @param {Number} oH Original Height
	     * @param {Number} dW Destination Width
	     * @param {Number} dH Destination Height
	     * @returns {ImageData}
	     */
	    bilinearFiltering: function(canvasEl, oW, oH, dW, dH) {
	      var a, b, c, d, x, y, i, j, xDiff, yDiff, chnl,
	          color, offset = 0, origPix, ratioX = this.rcpScaleX,
	          ratioY = this.rcpScaleY, context = canvasEl.getContext('2d'),
	          w4 = 4 * (oW - 1), img = context.getImageData(0, 0, oW, oH),
	          pixels = img.data, destImage = context.getImageData(0, 0, dW, dH),
	          destPixels = destImage.data;
	      for (i = 0; i < dH; i++) {
	        for (j = 0; j < dW; j++) {
	          x = floor(ratioX * j);
	          y = floor(ratioY * i);
	          xDiff = ratioX * j - x;
	          yDiff = ratioY * i - y;
	          origPix = 4 * (y * oW + x);
	
	          for (chnl = 0; chnl < 4; chnl++) {
	            a = pixels[origPix + chnl];
	            b = pixels[origPix + 4 + chnl];
	            c = pixels[origPix + w4 + chnl];
	            d = pixels[origPix + w4 + 4 + chnl];
	            color = a * (1 - xDiff) * (1 - yDiff) + b * xDiff * (1 - yDiff) +
	                    c * yDiff * (1 - xDiff) + d * xDiff * yDiff;
	            destPixels[offset++] = color;
	          }
	        }
	      }
	      return destImage;
	    },
	
	    /**
	     * hermiteFastResize
	     * @param {Object} canvasEl Canvas element to apply filter to
	     * @param {Number} oW Original Width
	     * @param {Number} oH Original Height
	     * @param {Number} dW Destination Width
	     * @param {Number} dH Destination Height
	     * @returns {ImageData}
	     */
	    hermiteFastResize: function(canvasEl, oW, oH, dW, dH) {
	      var ratioW = this.rcpScaleX, ratioH = this.rcpScaleY,
	          ratioWHalf = ceil(ratioW / 2),
	          ratioHHalf = ceil(ratioH / 2),
	          context = canvasEl.getContext('2d'),
	          img = context.getImageData(0, 0, oW, oH), data = img.data,
	          img2 = context.getImageData(0, 0, dW, dH), data2 = img2.data;
	      for (var j = 0; j < dH; j++) {
	        for (var i = 0; i < dW; i++) {
	          var x2 = (i + j * dW) * 4, weight = 0, weights = 0, weightsAlpha = 0,
	              gxR = 0, gxG = 0, gxB = 0, gxA = 0, centerY = (j + 0.5) * ratioH;
	          for (var yy = floor(j * ratioH); yy < (j + 1) * ratioH; yy++) {
	            var dy = abs(centerY - (yy + 0.5)) / ratioHHalf,
	                centerX = (i + 0.5) * ratioW, w0 = dy * dy;
	            for (var xx = floor(i * ratioW); xx < (i + 1) * ratioW; xx++) {
	              var dx = abs(centerX - (xx + 0.5)) / ratioWHalf,
	                  w = sqrt(w0 + dx * dx);
	              /* eslint-disable max-depth */
	              if (w > 1 && w < -1) {
	                continue;
	              }
	              //hermite filter
	              weight = 2 * w * w * w - 3 * w * w + 1;
	              if (weight > 0) {
	                dx = 4 * (xx + yy * oW);
	                //alpha
	                gxA += weight * data[dx + 3];
	                weightsAlpha += weight;
	                //colors
	                if (data[dx + 3] < 255) {
	                  weight = weight * data[dx + 3] / 250;
	                }
	                gxR += weight * data[dx];
	                gxG += weight * data[dx + 1];
	                gxB += weight * data[dx + 2];
	                weights += weight;
	              }
	              /* eslint-enable max-depth */
	            }
	          }
	          data2[x2] = gxR / weights;
	          data2[x2 + 1] = gxG / weights;
	          data2[x2 + 2] = gxB / weights;
	          data2[x2 + 3] = gxA / weightsAlpha;
	        }
	      }
	      return img2;
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return {
	        type: this.type,
	        scaleX: this.scaleX,
	        scaleY: this.scaleY,
	        resizeType: this.resizeType,
	        lanczosLobes: this.lanczosLobes
	      };
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] to be invoked after filter creation
	   * @return {fabric.Image.filters.Resize} Instance of fabric.Image.filters.Resize
	   */
	  fabric.Image.filters.Resize.fromObject = fabric.Image.filters.BaseFilter.fromObject;
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Color Matrix filter class
	   * @class fabric.Image.filters.ColorMatrix
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.ColorMatrix#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @see {@Link http://www.webwasp.co.uk/tutorials/219/Color_Matrix_Filter.php}
	   * @see {@Link http://phoboslab.org/log/2013/11/fast-image-filters-with-webgl}
	   * @example <caption>Kodachrome filter</caption>
	   * var filter = new fabric.Image.filters.ColorMatrix({
	   *  matrix: [
	       1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,
	       -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,
	       -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,
	       0, 0, 0, 1, 0
	      ]
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.ColorMatrix = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.ColorMatrix.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'ColorMatrix',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.ColorMatrix.prototype
	     * @param {Object} [options] Options object
	     * @param {Array} [options.matrix] Color Matrix to modify the image data with
	     */
	    initialize: function( options ) {
	      options || ( options = {} );
	      this.matrix = options.matrix || [
	        1, 0, 0, 0, 0,
	        0, 1, 0, 0, 0,
	        0, 0, 1, 0, 0,
	        0, 0, 0, 1, 0
	      ];
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function( canvasEl ) {
	      var context = canvasEl.getContext( '2d' ),
	          imageData = context.getImageData( 0, 0, canvasEl.width, canvasEl.height ),
	          data = imageData.data,
	          iLen = data.length,
	          i,
	          r,
	          g,
	          b,
	          a,
	          m = this.matrix;
	
	      for ( i = 0; i < iLen; i += 4 ) {
	        r = data[ i ];
	        g = data[ i + 1 ];
	        b = data[ i + 2 ];
	        a = data[ i + 3 ];
	
	        data[ i ] = r * m[ 0 ] + g * m[ 1 ] + b * m[ 2 ] + a * m[ 3 ] + m[ 4 ];
	        data[ i + 1 ] = r * m[ 5 ] + g * m[ 6 ] + b * m[ 7 ] + a * m[ 8 ] + m[ 9 ];
	        data[ i + 2 ] = r * m[ 10 ] + g * m[ 11 ] + b * m[ 12 ] + a * m[ 13 ] + m[ 14 ];
	        data[ i + 3 ] = r * m[ 15 ] + g * m[ 16 ] + b * m[ 17 ] + a * m[ 18 ] + m[ 19 ];
	      }
	
	      context.putImageData( imageData, 0, 0 );
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        type: this.type,
	        matrix: this.matrix
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @param {function} [callback] function to invoke after filter creation
	   * @return {fabric.Image.filters.ColorMatrix} Instance of fabric.Image.filters.ColorMatrix
	   */
	  fabric.Image.filters.ColorMatrix.fromObject = fabric.Image.filters.BaseFilter.fromObject;
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Contrast filter class
	   * @class fabric.Image.filters.Contrast
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.Contrast#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Contrast({
	   *   contrast: 40
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Contrast = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Contrast.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Contrast',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.Contrast.prototype
	     * @param {Object} [options] Options object
	     * @param {Number} [options.contrast=0] Value to contrast the image up (-255...255)
	     */
	    initialize: function(options) {
	      options = options || { };
	      this.contrast = options.contrast || 0;
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          contrastF = 259 * (this.contrast + 255) / (255 * (259 - this.contrast));
	
	      for (var i = 0, len = data.length; i < len; i += 4) {
	        data[i] = contrastF * (data[i] - 128) + 128;
	        data[i + 1] = contrastF * (data[i + 1] - 128) + 128;
	        data[i + 2] = contrastF * (data[i + 2] - 128) + 128;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        contrast: this.contrast
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @param {function} [callback] to be invoked after filter creation
	   * @return {fabric.Image.filters.Contrast} Instance of fabric.Image.filters.Contrast
	   */
	  fabric.Image.filters.Contrast.fromObject = fabric.Image.filters.BaseFilter.fromObject;
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      filters = fabric.Image.filters,
	      createClass = fabric.util.createClass;
	
	  /**
	   * Saturate filter class
	   * @class fabric.Image.filters.Saturate
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.Saturate#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Saturate({
	   *   saturate: 100
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  filters.Saturate = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Saturate.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Saturate',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.Saturate.prototype
	     * @param {Object} [options] Options object
	     * @param {Number} [options.saturate=0] Value to saturate the image (-100...100)
	     */
	    initialize: function(options) {
	      options = options || { };
	      this.saturate = options.saturate || 0;
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          max, adjust = -this.saturate * 0.01;
	
	      for (var i = 0, len = data.length; i < len; i += 4) {
	        max = Math.max(data[i], data[i + 1], data[i + 2]);
	        data[i] += max !== data[i] ? (max - data[i]) * adjust : 0;
	        data[i + 1] += max !== data[i + 1] ? (max - data[i + 1]) * adjust : 0;
	        data[i + 2] += max !== data[i + 2] ? (max - data[i + 2]) * adjust : 0;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        saturate: this.saturate
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] to be invoked after filter creation
	   * @return {fabric.Image.filters.Saturate} Instance of fabric.Image.filters.Saturate
	   */
	  fabric.Image.filters.Saturate.fromObject = fabric.Image.filters.BaseFilter.fromObject;
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      toFixed = fabric.util.toFixed,
	      NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
	      MIN_TEXT_WIDTH = 2;
	
	  if (fabric.Text) {
	    fabric.warn('fabric.Text is already defined');
	    return;
	  }
	
	  var stateProperties = fabric.Object.prototype.stateProperties.concat();
	  stateProperties.push(
	    'fontFamily',
	    'fontWeight',
	    'fontSize',
	    'text',
	    'textDecoration',
	    'textAlign',
	    'fontStyle',
	    'lineHeight',
	    'textBackgroundColor',
	    'charSpacing'
	  );
	
	  var cacheProperties = fabric.Object.prototype.cacheProperties.concat();
	  cacheProperties.push(
	    'fontFamily',
	    'fontWeight',
	    'fontSize',
	    'text',
	    'textDecoration',
	    'textAlign',
	    'fontStyle',
	    'lineHeight',
	    'textBackgroundColor',
	    'charSpacing',
	    'styles'
	  );
	  /**
	   * Text class
	   * @class fabric.Text
	   * @extends fabric.Object
	   * @return {fabric.Text} thisArg
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#text}
	   * @see {@link fabric.Text#initialize} for constructor definition
	   */
	  fabric.Text = fabric.util.createClass(fabric.Object, /** @lends fabric.Text.prototype */ {
	
	    /**
	     * Properties which when set cause object to change dimensions
	     * @type Object
	     * @private
	     */
	    _dimensionAffectingProps: [
	      'fontSize',
	      'fontWeight',
	      'fontFamily',
	      'fontStyle',
	      'lineHeight',
	      'text',
	      'charSpacing',
	      'textAlign'
	    ],
	
	    /**
	     * @private
	     */
	    _reNewline: /\r?\n/,
	
	    /**
	     * Use this regular expression to filter for whitespace that is not a new line.
	     * Mostly used when text is 'justify' aligned.
	     * @private
	     */
	    _reSpacesAndTabs: /[ \t\r]+/g,
	
	    /**
	     * Retrieves object's fontSize
	     * @method getFontSize
	     * @memberOf fabric.Text.prototype
	     * @return {String} Font size (in pixels)
	     */
	
	    /**
	     * Sets object's fontSize
	     * Does not update the object .width and .height,
	     * call ._initDimensions() to update the values.
	     * @method setFontSize
	     * @memberOf fabric.Text.prototype
	     * @param {Number} fontSize Font size (in pixels)
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's fontWeight
	     * @method getFontWeight
	     * @memberOf fabric.Text.prototype
	     * @return {(String|Number)} Font weight
	     */
	
	    /**
	     * Sets object's fontWeight
	     * Does not update the object .width and .height,
	     * call ._initDimensions() to update the values.
	     * @method setFontWeight
	     * @memberOf fabric.Text.prototype
	     * @param {(Number|String)} fontWeight Font weight
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's fontFamily
	     * @method getFontFamily
	     * @memberOf fabric.Text.prototype
	     * @return {String} Font family
	     */
	
	    /**
	     * Sets object's fontFamily
	     * Does not update the object .width and .height,
	     * call ._initDimensions() to update the values.
	     * @method setFontFamily
	     * @memberOf fabric.Text.prototype
	     * @param {String} fontFamily Font family
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's text
	     * @method getText
	     * @memberOf fabric.Text.prototype
	     * @return {String} text
	     */
	
	    /**
	     * Sets object's text
	     * Does not update the object .width and .height,
	     * call ._initDimensions() to update the values.
	     * @method setText
	     * @memberOf fabric.Text.prototype
	     * @param {String} text Text
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's textDecoration
	     * @method getTextDecoration
	     * @memberOf fabric.Text.prototype
	     * @return {String} Text decoration
	     */
	
	    /**
	     * Sets object's textDecoration
	     * @method setTextDecoration
	     * @memberOf fabric.Text.prototype
	     * @param {String} textDecoration Text decoration
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's fontStyle
	     * @method getFontStyle
	     * @memberOf fabric.Text.prototype
	     * @return {String} Font style
	     */
	
	    /**
	     * Sets object's fontStyle
	     * Does not update the object .width and .height,
	     * call ._initDimensions() to update the values.
	     * @method setFontStyle
	     * @memberOf fabric.Text.prototype
	     * @param {String} fontStyle Font style
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's lineHeight
	     * @method getLineHeight
	     * @memberOf fabric.Text.prototype
	     * @return {Number} Line height
	     */
	
	    /**
	     * Sets object's lineHeight
	     * @method setLineHeight
	     * @memberOf fabric.Text.prototype
	     * @param {Number} lineHeight Line height
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's textAlign
	     * @method getTextAlign
	     * @memberOf fabric.Text.prototype
	     * @return {String} Text alignment
	     */
	
	    /**
	     * Sets object's textAlign
	     * @method setTextAlign
	     * @memberOf fabric.Text.prototype
	     * @param {String} textAlign Text alignment
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's textBackgroundColor
	     * @method getTextBackgroundColor
	     * @memberOf fabric.Text.prototype
	     * @return {String} Text background color
	     */
	
	    /**
	     * Sets object's textBackgroundColor
	     * @method setTextBackgroundColor
	     * @memberOf fabric.Text.prototype
	     * @param {String} textBackgroundColor Text background color
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type:                 'text',
	
	    /**
	     * Font size (in pixels)
	     * @type Number
	     * @default
	     */
	    fontSize:             40,
	
	    /**
	     * Font weight (e.g. bold, normal, 400, 600, 800)
	     * @type {(Number|String)}
	     * @default
	     */
	    fontWeight:           'normal',
	
	    /**
	     * Font family
	     * @type String
	     * @default
	     */
	    fontFamily:           'Times New Roman',
	
	    /**
	     * Text decoration Possible values: "", "underline", "overline" or "line-through".
	     * @type String
	     * @default
	     */
	    textDecoration:       '',
	
	    /**
	     * Text alignment. Possible values: "left", "center", "right" or "justify".
	     * @type String
	     * @default
	     */
	    textAlign:            'left',
	
	    /**
	     * Font style . Possible values: "", "normal", "italic" or "oblique".
	     * @type String
	     * @default
	     */
	    fontStyle:            '',
	
	    /**
	     * Line height
	     * @type Number
	     * @default
	     */
	    lineHeight:           1.16,
	
	    /**
	     * Background color of text lines
	     * @type String
	     * @default
	     */
	    textBackgroundColor:  '',
	
	    /**
	     * List of properties to consider when checking if
	     * state of an object is changed ({@link fabric.Object#hasStateChanged})
	     * as well as for history (undo/redo) purposes
	     * @type Array
	     */
	    stateProperties:      stateProperties,
	
	    /**
	     * List of properties to consider when checking if cache needs refresh
	     * @type Array
	     */
	    cacheProperties:      cacheProperties,
	
	    /**
	     * When defined, an object is rendered via stroke and this property specifies its color.
	     * <b>Backwards incompatibility note:</b> This property was named "strokeStyle" until v1.1.6
	     * @type String
	     * @default
	     */
	    stroke:               null,
	
	    /**
	     * Shadow object representing shadow of this shape.
	     * <b>Backwards incompatibility note:</b> This property was named "textShadow" (String) until v1.2.11
	     * @type fabric.Shadow
	     * @default
	     */
	    shadow:               null,
	
	    /**
	     * @private
	     */
	    _fontSizeFraction: 0.25,
	
	    /**
	     * Text Line proportion to font Size (in pixels)
	     * @type Number
	     * @default
	     */
	    _fontSizeMult:             1.13,
	
	    /**
	     * additional space between characters
	     * expressed in thousands of em unit
	     * @type Number
	     * @default
	     */
	    charSpacing:             0,
	
	    /**
	     * Constructor
	     * @param {String} text Text string
	     * @param {Object} [options] Options object
	     * @return {fabric.Text} thisArg
	     */
	    initialize: function(text, options) {
	      options = options || { };
	      this.text = text;
	      this.__skipDimension = true;
	      this.callSuper('initialize', options);
	      this.__skipDimension = false;
	      this._initDimensions();
	      this.setupState({ propertySet: '_dimensionAffectingProps' });
	    },
	
	    /**
	     * Initialize text dimensions. Render all text on given context
	     * or on a offscreen canvas to get the text width with measureText.
	     * Updates this.width and this.height with the proper values.
	     * Does not return dimensions.
	     * @param {CanvasRenderingContext2D} [ctx] Context to render on
	     * @private
	     */
	    _initDimensions: function(ctx) {
	      if (this.__skipDimension) {
	        return;
	      }
	      if (!ctx) {
	        ctx = fabric.util.createCanvasElement().getContext('2d');
	        this._setTextStyles(ctx);
	      }
	      this._textLines = this._splitTextIntoLines();
	      this._clearCache();
	      this.width = this._getTextWidth(ctx) || this.cursorWidth || MIN_TEXT_WIDTH;
	      this.height = this._getTextHeight(ctx);
	    },
	
	    /**
	     * Returns string representation of an instance
	     * @return {String} String representation of text object
	     */
	    toString: function() {
	      return '#<fabric.Text (' + this.complexity() +
	        '): { "text": "' + this.text + '", "fontFamily": "' + this.fontFamily + '" }>';
	    },
	
	    /**
	     * Return the dimension and the zoom level needed to create a cache canvas
	     * big enough to host the object to be cached.
	     * @private
	     * @return {Object}.width width of canvas
	     * @return {Object}.height height of canvas
	     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
	     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
	     */
	    _getCacheCanvasDimensions: function() {
	      var dim = this.callSuper('_getCacheCanvasDimensions');
	      var fontSize = Math.ceil(this.fontSize) * 2;
	      dim.width += fontSize;
	      dim.height += fontSize;
	      return dim;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _render: function(ctx) {
	      this._setTextStyles(ctx);
	      if (this.group && this.group.type === 'path-group') {
	        ctx.translate(this.left, this.top);
	      }
	      this._renderTextLinesBackground(ctx);
	      this._renderText(ctx);
	      this._renderTextDecoration(ctx);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderText: function(ctx) {
	      this._renderTextFill(ctx);
	      this._renderTextStroke(ctx);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _setTextStyles: function(ctx) {
	      ctx.textBaseline = 'alphabetic';
	      ctx.font = this._getFontDeclaration();
	    },
	
	    /**
	     * @private
	     * @return {Number} Height of fabric.Text object
	     */
	    _getTextHeight: function() {
	      return this._getHeightOfSingleLine() + (this._textLines.length - 1) * this._getHeightOfLine();
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @return {Number} Maximum width of fabric.Text object
	     */
	    _getTextWidth: function(ctx) {
	      var maxWidth = this._getLineWidth(ctx, 0);
	
	      for (var i = 1, len = this._textLines.length; i < len; i++) {
	        var currentLineWidth = this._getLineWidth(ctx, i);
	        if (currentLineWidth > maxWidth) {
	          maxWidth = currentLineWidth;
	        }
	      }
	      return maxWidth;
	    },
	
	    /**
	     * @private
	     * @param {String} method Method name ("fillText" or "strokeText")
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {String} chars Chars to render
	     * @param {Number} left Left position of text
	     * @param {Number} top Top position of text
	     */
	    _renderChars: function(method, ctx, chars, left, top) {
	      // remove Text word from method var
	      var shortM = method.slice(0, -4), char, width;
	      if (this[shortM].toLive) {
	        var offsetX = -this.width / 2 + this[shortM].offsetX || 0,
	            offsetY = -this.height / 2 + this[shortM].offsetY || 0;
	        ctx.save();
	        ctx.translate(offsetX, offsetY);
	        left -= offsetX;
	        top -= offsetY;
	      }
	      if (this.charSpacing !== 0) {
	        var additionalSpace = this._getWidthOfCharSpacing();
	        chars = chars.split('');
	        for (var i = 0, len = chars.length; i < len; i++) {
	          char = chars[i];
	          width = ctx.measureText(char).width + additionalSpace;
	          ctx[method](char, left, top);
	          left += width > 0 ? width : 0;
	        }
	      }
	      else {
	        ctx[method](chars, left, top);
	      }
	      this[shortM].toLive && ctx.restore();
	    },
	
	    /**
	     * @private
	     * @param {String} method Method name ("fillText" or "strokeText")
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {String} line Text to render
	     * @param {Number} left Left position of text
	     * @param {Number} top Top position of text
	     * @param {Number} lineIndex Index of a line in a text
	     */
	    _renderTextLine: function(method, ctx, line, left, top, lineIndex) {
	      // lift the line by quarter of fontSize
	      top -= this.fontSize * this._fontSizeFraction;
	
	      // short-circuit
	      var lineWidth = this._getLineWidth(ctx, lineIndex);
	      if (this.textAlign !== 'justify' || this.width < lineWidth) {
	        this._renderChars(method, ctx, line, left, top, lineIndex);
	        return;
	      }
	
	      // stretch the line
	      var words = line.split(/\s+/),
	          charOffset = 0,
	          wordsWidth = this._getWidthOfWords(ctx, words.join(' '), lineIndex, 0),
	          widthDiff = this.width - wordsWidth,
	          numSpaces = words.length - 1,
	          spaceWidth = numSpaces > 0 ? widthDiff / numSpaces : 0,
	          leftOffset = 0, word;
	
	      for (var i = 0, len = words.length; i < len; i++) {
	        while (line[charOffset] === ' ' && charOffset < line.length) {
	          charOffset++;
	        }
	        word = words[i];
	        this._renderChars(method, ctx, word, left + leftOffset, top, lineIndex, charOffset);
	        leftOffset += this._getWidthOfWords(ctx, word, lineIndex, charOffset) + spaceWidth;
	        charOffset += word.length;
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {String} word
	     */
	    _getWidthOfWords: function (ctx, word) {
	      var width = ctx.measureText(word).width, charCount, additionalSpace;
	      if (this.charSpacing !== 0) {
	        charCount = word.split('').length;
	        additionalSpace = charCount * this._getWidthOfCharSpacing();
	        width += additionalSpace;
	      }
	      return width > 0 ? width : 0;
	    },
	
	    /**
	     * @private
	     * @return {Number} Left offset
	     */
	    _getLeftOffset: function() {
	      return -this.width / 2;
	    },
	
	    /**
	     * @private
	     * @return {Number} Top offset
	     */
	    _getTopOffset: function() {
	      return -this.height / 2;
	    },
	
	    /**
	     * Returns true because text has no style
	     */
	    isEmptyStyles: function() {
	      return true;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {String} method Method name ("fillText" or "strokeText")
	     */
	    _renderTextCommon: function(ctx, method) {
	
	      var lineHeights = 0, left = this._getLeftOffset(), top = this._getTopOffset();
	
	      for (var i = 0, len = this._textLines.length; i < len; i++) {
	        var heightOfLine = this._getHeightOfLine(ctx, i),
	            maxHeight = heightOfLine / this.lineHeight,
	            lineWidth = this._getLineWidth(ctx, i),
	            leftOffset = this._getLineLeftOffset(lineWidth);
	        this._renderTextLine(
	          method,
	          ctx,
	          this._textLines[i],
	          left + leftOffset,
	          top + lineHeights + maxHeight,
	          i
	        );
	        lineHeights += heightOfLine;
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderTextFill: function(ctx) {
	      if (!this.fill && this.isEmptyStyles()) {
	        return;
	      }
	
	      this._renderTextCommon(ctx, 'fillText');
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderTextStroke: function(ctx) {
	      if ((!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles()) {
	        return;
	      }
	
	      if (this.shadow && !this.shadow.affectStroke) {
	        this._removeShadow(ctx);
	      }
	
	      ctx.save();
	      this._setLineDash(ctx, this.strokeDashArray);
	      ctx.beginPath();
	      this._renderTextCommon(ctx, 'strokeText');
	      ctx.closePath();
	      ctx.restore();
	    },
	
	    /**
	     * @private
	     * @return {Number} height of line
	     */
	    _getHeightOfLine: function() {
	      return this._getHeightOfSingleLine() * this.lineHeight;
	    },
	
	    /**
	     * @private
	     * @return {Number} height of line without lineHeight
	     */
	    _getHeightOfSingleLine: function() {
	      return this.fontSize * this._fontSizeMult;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderTextLinesBackground: function(ctx) {
	      if (!this.textBackgroundColor) {
	        return;
	      }
	      var lineTopOffset = 0, heightOfLine,
	          lineWidth, lineLeftOffset, originalFill = ctx.fillStyle;
	
	      ctx.fillStyle = this.textBackgroundColor;
	      for (var i = 0, len = this._textLines.length; i < len; i++) {
	        heightOfLine = this._getHeightOfLine(ctx, i);
	        lineWidth = this._getLineWidth(ctx, i);
	        if (lineWidth > 0) {
	          lineLeftOffset = this._getLineLeftOffset(lineWidth);
	          ctx.fillRect(
	            this._getLeftOffset() + lineLeftOffset,
	            this._getTopOffset() + lineTopOffset,
	            lineWidth,
	            heightOfLine / this.lineHeight
	          );
	        }
	        lineTopOffset += heightOfLine;
	      }
	      ctx.fillStyle = originalFill;
	      // if there is text background color no
	      // other shadows should be casted
	      this._removeShadow(ctx);
	    },
	
	    /**
	     * @private
	     * @param {Number} lineWidth Width of text line
	     * @return {Number} Line left offset
	     */
	    _getLineLeftOffset: function(lineWidth) {
	      if (this.textAlign === 'center') {
	        return (this.width - lineWidth) / 2;
	      }
	      if (this.textAlign === 'right') {
	        return this.width - lineWidth;
	      }
	      return 0;
	    },
	
	    /**
	     * @private
	     */
	    _clearCache: function() {
	      this.__lineWidths = [];
	      this.__lineHeights = [];
	    },
	
	    /**
	     * @private
	     */
	    _shouldClearDimensionCache: function() {
	      var shouldClear = this._forceClearCache;
	      shouldClear || (shouldClear = this.hasStateChanged('_dimensionAffectingProps'));
	      if (shouldClear) {
	        this.saveState({ propertySet: '_dimensionAffectingProps' });
	        this.dirty = true;
	      }
	      return shouldClear;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Number} lineIndex line number
	     * @return {Number} Line width
	     */
	    _getLineWidth: function(ctx, lineIndex) {
	      if (this.__lineWidths[lineIndex]) {
	        return this.__lineWidths[lineIndex] === -1 ? this.width : this.__lineWidths[lineIndex];
	      }
	
	      var width, wordCount, line = this._textLines[lineIndex];
	
	      if (line === '') {
	        width = 0;
	      }
	      else {
	        width = this._measureLine(ctx, lineIndex);
	      }
	      this.__lineWidths[lineIndex] = width;
	
	      if (width && this.textAlign === 'justify') {
	        wordCount = line.split(/\s+/);
	        if (wordCount.length > 1) {
	          this.__lineWidths[lineIndex] = -1;
	        }
	      }
	      return width;
	    },
	
	    _getWidthOfCharSpacing: function() {
	      if (this.charSpacing !== 0) {
	        return this.fontSize * this.charSpacing / 1000;
	      }
	      return 0;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Number} lineIndex line number
	     * @return {Number} Line width
	     */
	    _measureLine: function(ctx, lineIndex) {
	      var line = this._textLines[lineIndex],
	          width = ctx.measureText(line).width,
	          additionalSpace = 0, charCount, finalWidth;
	      if (this.charSpacing !== 0) {
	        charCount = line.split('').length;
	        additionalSpace = (charCount - 1) * this._getWidthOfCharSpacing();
	      }
	      finalWidth = width + additionalSpace;
	      return finalWidth > 0 ? finalWidth : 0;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderTextDecoration: function(ctx) {
	      if (!this.textDecoration) {
	        return;
	      }
	      var halfOfVerticalBox = this.height / 2,
	          _this = this, offsets = [];
	
	      /** @ignore */
	      function renderLinesAtOffset(offsets) {
	        var i, lineHeight = 0, len, j, oLen, lineWidth,
	            lineLeftOffset, heightOfLine;
	
	        for (i = 0, len = _this._textLines.length; i < len; i++) {
	
	          lineWidth = _this._getLineWidth(ctx, i);
	          lineLeftOffset = _this._getLineLeftOffset(lineWidth);
	          heightOfLine = _this._getHeightOfLine(ctx, i);
	
	          for (j = 0, oLen = offsets.length; j < oLen; j++) {
	            ctx.fillRect(
	              _this._getLeftOffset() + lineLeftOffset,
	              lineHeight + (_this._fontSizeMult - 1 + offsets[j] ) * _this.fontSize - halfOfVerticalBox,
	              lineWidth,
	              _this.fontSize / 15);
	          }
	          lineHeight += heightOfLine;
	        }
	      }
	
	      if (this.textDecoration.indexOf('underline') > -1) {
	        offsets.push(0.85); // 1 - 3/16
	      }
	      if (this.textDecoration.indexOf('line-through') > -1) {
	        offsets.push(0.43);
	      }
	      if (this.textDecoration.indexOf('overline') > -1) {
	        offsets.push(-0.12);
	      }
	      if (offsets.length > 0) {
	        renderLinesAtOffset(offsets);
	      }
	    },
	
	    /**
	     * return font declaration string for canvas context
	     * @returns {String} font declaration formatted for canvas context.
	     */
	    _getFontDeclaration: function() {
	      return [
	        // node-canvas needs "weight style", while browsers need "style weight"
	        (fabric.isLikelyNode ? this.fontWeight : this.fontStyle),
	        (fabric.isLikelyNode ? this.fontStyle : this.fontWeight),
	        this.fontSize + 'px',
	        (fabric.isLikelyNode ? ('"' + this.fontFamily + '"') : this.fontFamily)
	      ].join(' ');
	    },
	
	    /**
	     * Renders text instance on a specified context
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} noTransform
	     */
	    render: function(ctx, noTransform) {
	      // do not render if object is not visible
	      if (!this.visible) {
	        return;
	      }
	      if (this._shouldClearDimensionCache()) {
	        this._setTextStyles(ctx);
	        this._initDimensions(ctx);
	      }
	      this.callSuper('render', ctx, noTransform);
	    },
	
	    /**
	     * Returns the text as an array of lines.
	     * @returns {Array} Lines in the text
	     */
	    _splitTextIntoLines: function() {
	      return this.text.split(this._reNewline);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      var additionalProperties = [
	        'text',
	        'fontSize',
	        'fontWeight',
	        'fontFamily',
	        'fontStyle',
	        'lineHeight',
	        'textDecoration',
	        'textAlign',
	        'textBackgroundColor',
	        'charSpacing'
	      ].concat(propertiesToInclude);
	      return this.callSuper('toObject', additionalProperties);
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns SVG representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      if (!this.ctx) {
	        this.ctx = fabric.util.createCanvasElement().getContext('2d');
	      }
	      var markup = this._createBaseSVGMarkup(),
	          offsets = this._getSVGLeftTopOffsets(this.ctx),
	          textAndBg = this._getSVGTextAndBg(offsets.textTop, offsets.textLeft);
	      this._wrapSVGTextAndBg(markup, textAndBg);
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	
	    /**
	     * @private
	     */
	    _getSVGLeftTopOffsets: function(ctx) {
	      var lineTop = this._getHeightOfLine(ctx, 0),
	          textLeft = -this.width / 2,
	          textTop = 0;
	
	      return {
	        textLeft: textLeft + (this.group && this.group.type === 'path-group' ? this.left : 0),
	        textTop: textTop + (this.group && this.group.type === 'path-group' ? -this.top : 0),
	        lineTop: lineTop
	      };
	    },
	
	    /**
	     * @private
	     */
	    _wrapSVGTextAndBg: function(markup, textAndBg) {
	      var noShadow = true, filter = this.getSvgFilter(),
	          style = filter === '' ? '' : ' style="' + filter + '"';
	
	      markup.push(
	        '\t<g ', this.getSvgId(), 'transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '"',
	          style, '>\n',
	          textAndBg.textBgRects.join(''),
	          '\t\t<text ',
	            (this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, '\'') + '" ' : ''),
	            (this.fontSize ? 'font-size="' + this.fontSize + '" ' : ''),
	            (this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : ''),
	            (this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : ''),
	            (this.textDecoration ? 'text-decoration="' + this.textDecoration + '" ' : ''),
	            'style="', this.getSvgStyles(noShadow), '" >\n',
	            textAndBg.textSpans.join(''),
	          '\t\t</text>\n',
	        '\t</g>\n'
	      );
	    },
	
	    /**
	     * @private
	     * @param {Number} textTopOffset Text top offset
	     * @param {Number} textLeftOffset Text left offset
	     * @return {Object}
	     */
	    _getSVGTextAndBg: function(textTopOffset, textLeftOffset) {
	      var textSpans = [],
	          textBgRects = [],
	          height = 0;
	      // bounding-box background
	      this._setSVGBg(textBgRects);
	
	      // text and text-background
	      for (var i = 0, len = this._textLines.length; i < len; i++) {
	        if (this.textBackgroundColor) {
	          this._setSVGTextLineBg(textBgRects, i, textLeftOffset, textTopOffset, height);
	        }
	        this._setSVGTextLineText(i, textSpans, height, textLeftOffset, textTopOffset, textBgRects);
	        height += this._getHeightOfLine(this.ctx, i);
	      }
	
	      return {
	        textSpans: textSpans,
	        textBgRects: textBgRects
	      };
	    },
	
	    _setSVGTextLineText: function(i, textSpans, height, textLeftOffset, textTopOffset) {
	      var yPos = this.fontSize * (this._fontSizeMult - this._fontSizeFraction)
	        - textTopOffset + height - this.height / 2;
	      if (this.textAlign === 'justify') {
	        // i call from here to do not intefere with IText
	        this._setSVGTextLineJustifed(i, textSpans, yPos, textLeftOffset);
	        return;
	      }
	      textSpans.push(
	        '\t\t\t<tspan x="',
	          toFixed(textLeftOffset + this._getLineLeftOffset(this._getLineWidth(this.ctx, i)), NUM_FRACTION_DIGITS), '" ',
	          'y="',
	          toFixed(yPos, NUM_FRACTION_DIGITS),
	          '" ',
	          // doing this on <tspan> elements since setting opacity
	          // on containing <text> one doesn't work in Illustrator
	          this._getFillAttributes(this.fill), '>',
	          fabric.util.string.escapeXml(this._textLines[i]),
	        '</tspan>\n'
	      );
	    },
	
	    _setSVGTextLineJustifed: function(i, textSpans, yPos, textLeftOffset) {
	      var ctx = fabric.util.createCanvasElement().getContext('2d');
	
	      this._setTextStyles(ctx);
	
	      var line = this._textLines[i],
	          words = line.split(/\s+/),
	          wordsWidth = this._getWidthOfWords(ctx, words.join('')),
	          widthDiff = this.width - wordsWidth,
	          numSpaces = words.length - 1,
	          spaceWidth = numSpaces > 0 ? widthDiff / numSpaces : 0,
	          word, attributes = this._getFillAttributes(this.fill),
	          len;
	
	      textLeftOffset += this._getLineLeftOffset(this._getLineWidth(ctx, i));
	
	      for (i = 0, len = words.length; i < len; i++) {
	        word = words[i];
	        textSpans.push(
	          '\t\t\t<tspan x="',
	            toFixed(textLeftOffset, NUM_FRACTION_DIGITS), '" ',
	            'y="',
	            toFixed(yPos, NUM_FRACTION_DIGITS),
	            '" ',
	            // doing this on <tspan> elements since setting opacity
	            // on containing <text> one doesn't work in Illustrator
	            attributes, '>',
	            fabric.util.string.escapeXml(word),
	          '</tspan>\n'
	        );
	        textLeftOffset += this._getWidthOfWords(ctx, word) + spaceWidth;
	      }
	    },
	
	    _setSVGTextLineBg: function(textBgRects, i, textLeftOffset, textTopOffset, height) {
	      textBgRects.push(
	        '\t\t<rect ',
	          this._getFillAttributes(this.textBackgroundColor),
	          ' x="',
	          toFixed(textLeftOffset + this._getLineLeftOffset(this._getLineWidth(this.ctx, i)), NUM_FRACTION_DIGITS),
	          '" y="',
	          toFixed(height - this.height / 2, NUM_FRACTION_DIGITS),
	          '" width="',
	          toFixed(this._getLineWidth(this.ctx, i), NUM_FRACTION_DIGITS),
	          '" height="',
	          toFixed(this._getHeightOfLine(this.ctx, i) / this.lineHeight, NUM_FRACTION_DIGITS),
	        '"></rect>\n');
	    },
	
	    _setSVGBg: function(textBgRects) {
	      if (this.backgroundColor) {
	        textBgRects.push(
	          '\t\t<rect ',
	            this._getFillAttributes(this.backgroundColor),
	            ' x="',
	            toFixed(-this.width / 2, NUM_FRACTION_DIGITS),
	            '" y="',
	            toFixed(-this.height / 2, NUM_FRACTION_DIGITS),
	            '" width="',
	            toFixed(this.width, NUM_FRACTION_DIGITS),
	            '" height="',
	            toFixed(this.height, NUM_FRACTION_DIGITS),
	          '"></rect>\n');
	      }
	    },
	
	    /**
	     * Adobe Illustrator (at least CS5) is unable to render rgba()-based fill values
	     * we work around it by "moving" alpha channel into opacity attribute and setting fill's alpha to 1
	     *
	     * @private
	     * @param {*} value
	     * @return {String}
	     */
	    _getFillAttributes: function(value) {
	      var fillColor = (value && typeof value === 'string') ? new fabric.Color(value) : '';
	      if (!fillColor || !fillColor.getSource() || fillColor.getAlpha() === 1) {
	        return 'fill="' + value + '"';
	      }
	      return 'opacity="' + fillColor.getAlpha() + '" fill="' + fillColor.setAlpha(1).toRgb() + '"';
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Sets specified property to a specified value
	     * @param {String} key
	     * @param {*} value
	     * @return {fabric.Text} thisArg
	     * @chainable
	     */
	    _set: function(key, value) {
	      this.callSuper('_set', key, value);
	
	      if (this._dimensionAffectingProps.indexOf(key) > -1) {
	        this._initDimensions();
	        this.setCoords();
	      }
	    },
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity
	     */
	    complexity: function() {
	      return 1;
	    }
	  });
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Text.fromElement})
	   * @static
	   * @memberOf fabric.Text
	   * @see: http://www.w3.org/TR/SVG/text.html#TextElement
	   */
	  fabric.Text.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(
	    'x y dx dy font-family font-style font-weight font-size text-decoration text-anchor'.split(' '));
	
	  /**
	   * Default SVG font size
	   * @static
	   * @memberOf fabric.Text
	   */
	  fabric.Text.DEFAULT_SVG_FONT_SIZE = 16;
	
	  /**
	   * Returns fabric.Text instance from an SVG element (<b>not yet implemented</b>)
	   * @static
	   * @memberOf fabric.Text
	   * @param {SVGElement} element Element to parse
	   * @param {Object} [options] Options object
	   * @return {fabric.Text} Instance of fabric.Text
	   */
	  fabric.Text.fromElement = function(element, options) {
	    if (!element) {
	      return null;
	    }
	
	    var parsedAttributes = fabric.parseAttributes(element, fabric.Text.ATTRIBUTE_NAMES);
	    options = fabric.util.object.extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes);
	
	    options.top = options.top || 0;
	    options.left = options.left || 0;
	    if ('dx' in parsedAttributes) {
	      options.left += parsedAttributes.dx;
	    }
	    if ('dy' in parsedAttributes) {
	      options.top += parsedAttributes.dy;
	    }
	    if (!('fontSize' in options)) {
	      options.fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;
	    }
	
	    if (!options.originX) {
	      options.originX = 'left';
	    }
	
	    var textContent = '';
	
	    // The XML is not properly parsed in IE9 so a workaround to get
	    // textContent is through firstChild.data. Another workaround would be
	    // to convert XML loaded from a file to be converted using DOMParser (same way loadSVGFromString() does)
	    if (!('textContent' in element)) {
	      if ('firstChild' in element && element.firstChild !== null) {
	        if ('data' in element.firstChild && element.firstChild.data !== null) {
	          textContent = element.firstChild.data;
	        }
	      }
	    }
	    else {
	      textContent = element.textContent;
	    }
	
	    textContent = textContent.replace(/^\s+|\s+$|\n+/g, '').replace(/\s+/g, ' ');
	
	    var text = new fabric.Text(textContent, options),
	        textHeightScaleFactor = text.getHeight() / text.height,
	        lineHeightDiff = (text.height + text.strokeWidth) * text.lineHeight - text.height,
	        scaledDiff = lineHeightDiff * textHeightScaleFactor,
	        textHeight = text.getHeight() + scaledDiff,
	        offX = 0;
	    /*
	      Adjust positioning:
	        x/y attributes in SVG correspond to the bottom-left corner of text bounding box
	        top/left properties in Fabric correspond to center point of text bounding box
	    */
	    if (text.originX === 'left') {
	      offX = text.getWidth() / 2;
	    }
	    if (text.originX === 'right') {
	      offX = -text.getWidth() / 2;
	    }
	    text.set({
	      left: text.getLeft() + offX,
	      top: text.getTop() - textHeight / 2 + text.fontSize * (0.18 + text._fontSizeFraction) / text.lineHeight /* 0.3 is the old lineHeight */
	    });
	
	    return text;
	  };
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Returns fabric.Text instance from an object representation
	   * @static
	   * @memberOf fabric.Text
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] Callback to invoke when an fabric.Text instance is created
	   * @param {Boolean} [forceAsync] Force an async behaviour trying to create pattern first
	   * @return {fabric.Text} Instance of fabric.Text
	   */
	  fabric.Text.fromObject = function(object, callback, forceAsync) {
	    return fabric.Object._fromObject('Text', object, callback, forceAsync, 'text');
	  };
	
	  fabric.util.createAccessors(fabric.Text);
	
	})( true ? exports : this);
	
	
	(function() {
	
	  var clone = fabric.util.object.clone;
	
	  /**
	   * IText class (introduced in <b>v1.4</b>) Events are also fired with "text:"
	   * prefix when observing canvas.
	   * @class fabric.IText
	   * @extends fabric.Text
	   * @mixes fabric.Observable
	   *
	   * @fires changed
	   * @fires selection:changed
	   * @fires editing:entered
	   * @fires editing:exited
	   *
	   * @return {fabric.IText} thisArg
	   * @see {@link fabric.IText#initialize} for constructor definition
	   *
	   * <p>Supported key combinations:</p>
	   * <pre>
	   *   Move cursor:                    left, right, up, down
	   *   Select character:               shift + left, shift + right
	   *   Select text vertically:         shift + up, shift + down
	   *   Move cursor by word:            alt + left, alt + right
	   *   Select words:                   shift + alt + left, shift + alt + right
	   *   Move cursor to line start/end:  cmd + left, cmd + right or home, end
	   *   Select till start/end of line:  cmd + shift + left, cmd + shift + right or shift + home, shift + end
	   *   Jump to start/end of text:      cmd + up, cmd + down
	   *   Select till start/end of text:  cmd + shift + up, cmd + shift + down or shift + pgUp, shift + pgDown
	   *   Delete character:               backspace
	   *   Delete word:                    alt + backspace
	   *   Delete line:                    cmd + backspace
	   *   Forward delete:                 delete
	   *   Copy text:                      ctrl/cmd + c
	   *   Paste text:                     ctrl/cmd + v
	   *   Cut text:                       ctrl/cmd + x
	   *   Select entire text:             ctrl/cmd + a
	   *   Quit editing                    tab or esc
	   * </pre>
	   *
	   * <p>Supported mouse/touch combination</p>
	   * <pre>
	   *   Position cursor:                click/touch
	   *   Create selection:               click/touch & drag
	   *   Create selection:               click & shift + click
	   *   Select word:                    double click
	   *   Select line:                    triple click
	   * </pre>
	   */
	  fabric.IText = fabric.util.createClass(fabric.Text, fabric.Observable, /** @lends fabric.IText.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'i-text',
	
	    /**
	     * Index where text selection starts (or where cursor is when there is no selection)
	     * @type Number
	     * @default
	     */
	    selectionStart: 0,
	
	    /**
	     * Index where text selection ends
	     * @type Number
	     * @default
	     */
	    selectionEnd: 0,
	
	    /**
	     * Color of text selection
	     * @type String
	     * @default
	     */
	    selectionColor: 'rgba(17,119,255,0.3)',
	
	    /**
	     * Indicates whether text is in editing mode
	     * @type Boolean
	     * @default
	     */
	    isEditing: false,
	
	    /**
	     * Indicates whether a text can be edited
	     * @type Boolean
	     * @default
	     */
	    editable: true,
	
	    /**
	     * Border color of text object while it's in editing mode
	     * @type String
	     * @default
	     */
	    editingBorderColor: 'rgba(102,153,255,0.25)',
	
	    /**
	     * Width of cursor (in px)
	     * @type Number
	     * @default
	     */
	    cursorWidth: 2,
	
	    /**
	     * Color of default cursor (when not overwritten by character style)
	     * @type String
	     * @default
	     */
	    cursorColor: '#333',
	
	    /**
	     * Delay between cursor blink (in ms)
	     * @type Number
	     * @default
	     */
	    cursorDelay: 1000,
	
	    /**
	     * Duration of cursor fadein (in ms)
	     * @type Number
	     * @default
	     */
	    cursorDuration: 600,
	
	    /**
	     * Object containing character styles
	     * (where top-level properties corresponds to line number and 2nd-level properties -- to char number in a line)
	     * @type Object
	     * @default
	     */
	    styles: null,
	
	    /**
	     * Indicates whether internal text char widths can be cached
	     * @type Boolean
	     * @default
	     */
	    caching: true,
	
	    /**
	     * @private
	     */
	    _reSpace: /\s|\n/,
	
	    /**
	     * @private
	     */
	    _currentCursorOpacity: 0,
	
	    /**
	     * @private
	     */
	    _selectionDirection: null,
	
	    /**
	     * @private
	     */
	    _abortCursorAnimation: false,
	
	    /**
	     * @private
	     */
	    __widthOfSpace: [],
	
	    /**
	     * Constructor
	     * @param {String} text Text string
	     * @param {Object} [options] Options object
	     * @return {fabric.IText} thisArg
	     */
	    initialize: function(text, options) {
	      this.styles = options ? (options.styles || { }) : { };
	      this.callSuper('initialize', text, options);
	      this.initBehavior();
	    },
	
	    /**
	     * @private
	     */
	    _clearCache: function() {
	      this.callSuper('_clearCache');
	      this.__widthOfSpace = [];
	    },
	
	    /**
	     * Returns true if object has no styling
	     */
	    isEmptyStyles: function() {
	      if (!this.styles) {
	        return true;
	      }
	      var obj = this.styles;
	
	      for (var p1 in obj) {
	        for (var p2 in obj[p1]) {
	          // eslint-disable-next-line no-unused-vars
	          for (var p3 in obj[p1][p2]) {
	            return false;
	          }
	        }
	      }
	      return true;
	    },
	
	    /**
	     * Sets selection start (left boundary of a selection)
	     * @param {Number} index Index to set selection start to
	     */
	    setSelectionStart: function(index) {
	      index = Math.max(index, 0);
	      this._updateAndFire('selectionStart', index);
	    },
	
	    /**
	     * Sets selection end (right boundary of a selection)
	     * @param {Number} index Index to set selection end to
	     */
	    setSelectionEnd: function(index) {
	      index = Math.min(index, this.text.length);
	      this._updateAndFire('selectionEnd', index);
	    },
	
	    /**
	     * @private
	     * @param {String} property 'selectionStart' or 'selectionEnd'
	     * @param {Number} index new position of property
	     */
	    _updateAndFire: function(property, index) {
	      if (this[property] !== index) {
	        this._fireSelectionChanged();
	        this[property] = index;
	      }
	      this._updateTextarea();
	    },
	
	    /**
	     * Fires the even of selection changed
	     * @private
	     */
	    _fireSelectionChanged: function() {
	      this.fire('selection:changed');
	      this.canvas && this.canvas.fire('text:selection:changed', { target: this });
	    },
	
	    /**
	     * Gets style of a current selection/cursor (at the start position)
	     * @param {Number} [startIndex] Start index to get styles at
	     * @param {Number} [endIndex] End index to get styles at
	     * @return {Object} styles Style object at a specified (or current) index
	     */
	    getSelectionStyles: function(startIndex, endIndex) {
	
	      if (arguments.length === 2) {
	        var styles = [];
	        for (var i = startIndex; i < endIndex; i++) {
	          styles.push(this.getSelectionStyles(i));
	        }
	        return styles;
	      }
	
	      var loc = this.get2DCursorLocation(startIndex),
	          style = this._getStyleDeclaration(loc.lineIndex, loc.charIndex);
	
	      return style || {};
	    },
	
	    /**
	     * Sets style of a current selection
	     * @param {Object} [styles] Styles object
	     * @return {fabric.IText} thisArg
	     * @chainable
	     */
	    setSelectionStyles: function(styles) {
	      if (this.selectionStart === this.selectionEnd) {
	        this._extendStyles(this.selectionStart, styles);
	      }
	      else {
	        for (var i = this.selectionStart; i < this.selectionEnd; i++) {
	          this._extendStyles(i, styles);
	        }
	      }
	      /* not included in _extendStyles to avoid clearing cache more than once */
	      this._forceClearCache = true;
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _extendStyles: function(index, styles) {
	      var loc = this.get2DCursorLocation(index);
	
	      if (!this._getLineStyle(loc.lineIndex)) {
	        this._setLineStyle(loc.lineIndex, {});
	      }
	
	      if (!this._getStyleDeclaration(loc.lineIndex, loc.charIndex)) {
	        this._setStyleDeclaration(loc.lineIndex, loc.charIndex, {});
	      }
	
	      fabric.util.object.extend(this._getStyleDeclaration(loc.lineIndex, loc.charIndex), styles);
	    },
	
	    /**
	     * Initialize text dimensions. Render all text on given context
	     * or on a offscreen canvas to get the text width with measureText.
	     * Updates this.width and this.height with the proper values.
	     * Does not return dimensions.
	     * @param {CanvasRenderingContext2D} [ctx] Context to render on
	     * @private
	     */
	    _initDimensions: function(ctx) {
	      if (!ctx) {
	        this.clearContextTop();
	      }
	      this.callSuper('_initDimensions', ctx);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} noTransform
	     */
	    render: function(ctx, noTransform) {
	      this.clearContextTop();
	      this.callSuper('render', ctx, noTransform);
	      // clear the cursorOffsetCache, so we ensure to calculate once per renderCursor
	      // the correct position but not at every cursor animation.
	      this.cursorOffsetCache = { };
	      this.renderCursorOrSelection();
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _render: function(ctx) {
	      this.callSuper('_render', ctx);
	      this.ctx = ctx;
	    },
	
	    /**
	     * Prepare and clean the contextTop
	     */
	    clearContextTop: function() {
	      if (!this.active || !this.isEditing) {
	        return;
	      }
	      if (this.canvas && this.canvas.contextTop) {
	        var ctx = this.canvas.contextTop;
	        ctx.save();
	        ctx.transform.apply(ctx, this.canvas.viewportTransform);
	        this.transform(ctx);
	        this.transformMatrix && ctx.transform.apply(ctx, this.transformMatrix);
	        this._clearTextArea(ctx);
	        ctx.restore();
	      }
	    },
	
	    /**
	     * Renders cursor or selection (depending on what exists)
	     */
	    renderCursorOrSelection: function() {
	      if (!this.active || !this.isEditing) {
	        return;
	      }
	      var chars = this.text.split(''),
	          boundaries, ctx;
	      if (this.canvas && this.canvas.contextTop) {
	        ctx = this.canvas.contextTop;
	        ctx.save();
	        ctx.transform.apply(ctx, this.canvas.viewportTransform);
	        this.transform(ctx);
	        this.transformMatrix && ctx.transform.apply(ctx, this.transformMatrix);
	        this._clearTextArea(ctx);
	      }
	      else {
	        ctx = this.ctx;
	        ctx.save();
	      }
	      if (this.selectionStart === this.selectionEnd) {
	        boundaries = this._getCursorBoundaries(chars, 'cursor');
	        this.renderCursor(boundaries, ctx);
	      }
	      else {
	        boundaries = this._getCursorBoundaries(chars, 'selection');
	        this.renderSelection(chars, boundaries, ctx);
	      }
	      ctx.restore();
	    },
	
	    _clearTextArea: function(ctx) {
	      // we add 4 pixel, to be sure to do not leave any pixel out
	      var width = this.width + 4, height = this.height + 4;
	      ctx.clearRect(-width / 2, -height / 2, width, height);
	    },
	    /**
	     * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start)
	     * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.
	     */
	    get2DCursorLocation: function(selectionStart) {
	      if (typeof selectionStart === 'undefined') {
	        selectionStart = this.selectionStart;
	      }
	      var len = this._textLines.length;
	      for (var i = 0; i < len; i++) {
	        if (selectionStart <= this._textLines[i].length) {
	          return {
	            lineIndex: i,
	            charIndex: selectionStart
	          };
	        }
	        selectionStart -= this._textLines[i].length + 1;
	      }
	      return {
	        lineIndex: i - 1,
	        charIndex: this._textLines[i - 1].length < selectionStart ? this._textLines[i - 1].length : selectionStart
	      };
	    },
	
	    /**
	     * Returns complete style of char at the current cursor
	     * @param {Number} lineIndex Line index
	     * @param {Number} charIndex Char index
	     * @return {Object} Character style
	     */
	    getCurrentCharStyle: function(lineIndex, charIndex) {
	      var style = this._getStyleDeclaration(lineIndex, charIndex === 0 ? 0 : charIndex - 1);
	
	      return {
	        fontSize: style && style.fontSize || this.fontSize,
	        fill: style && style.fill || this.fill,
	        textBackgroundColor: style && style.textBackgroundColor || this.textBackgroundColor,
	        textDecoration: style && style.textDecoration || this.textDecoration,
	        fontFamily: style && style.fontFamily || this.fontFamily,
	        fontWeight: style && style.fontWeight || this.fontWeight,
	        fontStyle: style && style.fontStyle || this.fontStyle,
	        stroke: style && style.stroke || this.stroke,
	        strokeWidth: style && style.strokeWidth || this.strokeWidth
	      };
	    },
	
	    /**
	     * Returns fontSize of char at the current cursor
	     * @param {Number} lineIndex Line index
	     * @param {Number} charIndex Char index
	     * @return {Number} Character font size
	     */
	    getCurrentCharFontSize: function(lineIndex, charIndex) {
	      var style = this._getStyleDeclaration(lineIndex, charIndex === 0 ? 0 : charIndex - 1);
	      return style && style.fontSize ? style.fontSize : this.fontSize;
	    },
	
	    /**
	     * Returns color (fill) of char at the current cursor
	     * @param {Number} lineIndex Line index
	     * @param {Number} charIndex Char index
	     * @return {String} Character color (fill)
	     */
	    getCurrentCharColor: function(lineIndex, charIndex) {
	      var style = this._getStyleDeclaration(lineIndex, charIndex === 0 ? 0 : charIndex - 1);
	      return style && style.fill ? style.fill : this.cursorColor;
	    },
	
	    /**
	     * Returns cursor boundaries (left, top, leftOffset, topOffset)
	     * @private
	     * @param {Array} chars Array of characters
	     * @param {String} typeOfBoundaries
	     */
	    _getCursorBoundaries: function(chars, typeOfBoundaries) {
	
	      // left/top are left/top of entire text box
	      // leftOffset/topOffset are offset from that left/top point of a text box
	
	      var left = Math.round(this._getLeftOffset()),
	          top = this._getTopOffset(),
	
	          offsets = this._getCursorBoundariesOffsets(
	                      chars, typeOfBoundaries);
	
	      return {
	        left: left,
	        top: top,
	        leftOffset: offsets.left + offsets.lineLeft,
	        topOffset: offsets.top
	      };
	    },
	
	    /**
	     * @private
	     */
	    _getCursorBoundariesOffsets: function(chars, typeOfBoundaries) {
	      if (this.cursorOffsetCache && 'top' in this.cursorOffsetCache) {
	        return this.cursorOffsetCache;
	      }
	      var lineLeftOffset = 0,
	          lineIndex = 0,
	          charIndex = 0,
	          topOffset = 0,
	          leftOffset = 0,
	          boundaries;
	
	      for (var i = 0; i < this.selectionStart; i++) {
	        if (chars[i] === '\n') {
	          leftOffset = 0;
	          topOffset += this._getHeightOfLine(this.ctx, lineIndex);
	
	          lineIndex++;
	          charIndex = 0;
	        }
	        else {
	          leftOffset += this._getWidthOfChar(this.ctx, chars[i], lineIndex, charIndex);
	          charIndex++;
	        }
	
	        lineLeftOffset = this._getLineLeftOffset(this._getLineWidth(this.ctx, lineIndex));
	      }
	      if (typeOfBoundaries === 'cursor') {
	        topOffset += (1 - this._fontSizeFraction) * this._getHeightOfLine(this.ctx, lineIndex) / this.lineHeight
	          - this.getCurrentCharFontSize(lineIndex, charIndex) * (1 - this._fontSizeFraction);
	      }
	      if (this.charSpacing !== 0 && charIndex === this._textLines[lineIndex].length) {
	        leftOffset -= this._getWidthOfCharSpacing();
	      }
	      boundaries = {
	        top: topOffset,
	        left: leftOffset > 0 ? leftOffset : 0,
	        lineLeft: lineLeftOffset
	      };
	      this.cursorOffsetCache = boundaries;
	      return this.cursorOffsetCache;
	    },
	
	    /**
	     * Renders cursor
	     * @param {Object} boundaries
	     * @param {CanvasRenderingContext2D} ctx transformed context to draw on
	     */
	    renderCursor: function(boundaries, ctx) {
	
	      var cursorLocation = this.get2DCursorLocation(),
	          lineIndex = cursorLocation.lineIndex,
	          charIndex = cursorLocation.charIndex,
	          charHeight = this.getCurrentCharFontSize(lineIndex, charIndex),
	          leftOffset = (lineIndex === 0 && charIndex === 0)
	                    ? this._getLineLeftOffset(this._getLineWidth(ctx, lineIndex))
	                    : boundaries.leftOffset,
	          multiplier = this.scaleX * this.canvas.getZoom(),
	          cursorWidth = this.cursorWidth / multiplier;
	
	      ctx.fillStyle = this.getCurrentCharColor(lineIndex, charIndex);
	      ctx.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity;
	
	      ctx.fillRect(
	        boundaries.left + leftOffset - cursorWidth / 2,
	        boundaries.top + boundaries.topOffset,
	        cursorWidth,
	        charHeight);
	    },
	
	    /**
	     * Renders text selection
	     * @param {Array} chars Array of characters
	     * @param {Object} boundaries Object with left/top/leftOffset/topOffset
	     * @param {CanvasRenderingContext2D} ctx transformed context to draw on
	     */
	    renderSelection: function(chars, boundaries, ctx) {
	
	      ctx.fillStyle = this.selectionColor;
	
	      var start = this.get2DCursorLocation(this.selectionStart),
	          end = this.get2DCursorLocation(this.selectionEnd),
	          startLine = start.lineIndex,
	          endLine = end.lineIndex;
	      for (var i = startLine; i <= endLine; i++) {
	        var lineOffset = this._getLineLeftOffset(this._getLineWidth(ctx, i)) || 0,
	            lineHeight = this._getHeightOfLine(this.ctx, i),
	            realLineHeight = 0, boxWidth = 0, line = this._textLines[i];
	
	        if (i === startLine) {
	          for (var j = 0, len = line.length; j < len; j++) {
	            if (j >= start.charIndex && (i !== endLine || j < end.charIndex)) {
	              boxWidth += this._getWidthOfChar(ctx, line[j], i, j);
	            }
	            if (j < start.charIndex) {
	              lineOffset += this._getWidthOfChar(ctx, line[j], i, j);
	            }
	          }
	          if (j === line.length) {
	            boxWidth -= this._getWidthOfCharSpacing();
	          }
	        }
	        else if (i > startLine && i < endLine) {
	          boxWidth += this._getLineWidth(ctx, i) || 5;
	        }
	        else if (i === endLine) {
	          for (var j2 = 0, j2len = end.charIndex; j2 < j2len; j2++) {
	            boxWidth += this._getWidthOfChar(ctx, line[j2], i, j2);
	          }
	          if (end.charIndex === line.length) {
	            boxWidth -= this._getWidthOfCharSpacing();
	          }
	        }
	        realLineHeight = lineHeight;
	        if (this.lineHeight < 1 || (i === endLine && this.lineHeight > 1)) {
	          lineHeight /= this.lineHeight;
	        }
	        ctx.fillRect(
	          boundaries.left + lineOffset,
	          boundaries.top + boundaries.topOffset,
	          boxWidth > 0 ? boxWidth : 0,
	          lineHeight);
	
	        boundaries.topOffset += realLineHeight;
	      }
	    },
	
	    /**
	     * @private
	     * @param {String} method
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {String} line Content of the line
	     * @param {Number} left
	     * @param {Number} top
	     * @param {Number} lineIndex
	     * @param {Number} charOffset
	     */
	    _renderChars: function(method, ctx, line, left, top, lineIndex, charOffset) {
	
	      if (this.isEmptyStyles()) {
	        return this._renderCharsFast(method, ctx, line, left, top);
	      }
	
	      charOffset = charOffset || 0;
	
	      // set proper line offset
	      var lineHeight = this._getHeightOfLine(ctx, lineIndex),
	          prevStyle,
	          thisStyle,
	          charsToRender = '';
	
	      ctx.save();
	      top -= lineHeight / this.lineHeight * this._fontSizeFraction;
	      for (var i = charOffset, len = line.length + charOffset; i <= len; i++) {
	        prevStyle = prevStyle || this.getCurrentCharStyle(lineIndex, i);
	        thisStyle = this.getCurrentCharStyle(lineIndex, i + 1);
	
	        if (this._hasStyleChanged(prevStyle, thisStyle) || i === len) {
	          this._renderChar(method, ctx, lineIndex, i - 1, charsToRender, left, top, lineHeight);
	          charsToRender = '';
	          prevStyle = thisStyle;
	        }
	        charsToRender += line[i - charOffset];
	      }
	      ctx.restore();
	    },
	
	    /**
	     * @private
	     * @param {String} method
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {String} line Content of the line
	     * @param {Number} left Left coordinate
	     * @param {Number} top Top coordinate
	     */
	    _renderCharsFast: function(method, ctx, line, left, top) {
	
	      if (method === 'fillText' && this.fill) {
	        this.callSuper('_renderChars', method, ctx, line, left, top);
	      }
	      if (method === 'strokeText' && ((this.stroke && this.strokeWidth > 0) || this.skipFillStrokeCheck)) {
	        this.callSuper('_renderChars', method, ctx, line, left, top);
	      }
	    },
	
	    /**
	     * @private
	     * @param {String} method
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Number} lineIndex
	     * @param {Number} i
	     * @param {String} _char
	     * @param {Number} left Left coordinate
	     * @param {Number} top Top coordinate
	     * @param {Number} lineHeight Height of the line
	     */
	    _renderChar: function(method, ctx, lineIndex, i, _char, left, top, lineHeight) {
	      var charWidth, charHeight, shouldFill, shouldStroke,
	          decl = this._getStyleDeclaration(lineIndex, i),
	          offset, textDecoration, chars, additionalSpace, _charWidth;
	
	      if (decl) {
	        charHeight = this._getHeightOfChar(ctx, _char, lineIndex, i);
	        shouldStroke = decl.stroke;
	        shouldFill = decl.fill;
	        textDecoration = decl.textDecoration;
	      }
	      else {
	        charHeight = this.fontSize;
	      }
	
	      shouldStroke = (shouldStroke || this.stroke) && method === 'strokeText';
	      shouldFill = (shouldFill || this.fill) && method === 'fillText';
	
	      decl && ctx.save();
	
	      charWidth = this._applyCharStylesGetWidth(ctx, _char, lineIndex, i, decl || null);
	      textDecoration = textDecoration || this.textDecoration;
	
	      if (decl && decl.textBackgroundColor) {
	        this._removeShadow(ctx);
	      }
	      if (this.charSpacing !== 0) {
	        additionalSpace = this._getWidthOfCharSpacing();
	        chars = _char.split('');
	        charWidth = 0;
	        for (var j = 0, len = chars.length, char; j < len; j++) {
	          char = chars[j];
	          shouldFill && ctx.fillText(char, left + charWidth, top);
	          shouldStroke && ctx.strokeText(char, left + charWidth, top);
	          _charWidth = ctx.measureText(char).width + additionalSpace;
	          charWidth += _charWidth > 0 ? _charWidth : 0;
	        }
	      }
	      else {
	        shouldFill && ctx.fillText(_char, left, top);
	        shouldStroke && ctx.strokeText(_char, left, top);
	      }
	
	      if (textDecoration || textDecoration !== '') {
	        offset = this._fontSizeFraction * lineHeight / this.lineHeight;
	        this._renderCharDecoration(ctx, textDecoration, left, top, offset, charWidth, charHeight);
	      }
	
	      decl && ctx.restore();
	      ctx.translate(charWidth, 0);
	    },
	
	    /**
	     * @private
	     * @param {Object} prevStyle
	     * @param {Object} thisStyle
	     */
	    _hasStyleChanged: function(prevStyle, thisStyle) {
	      return (prevStyle.fill !== thisStyle.fill ||
	              prevStyle.fontSize !== thisStyle.fontSize ||
	              prevStyle.textBackgroundColor !== thisStyle.textBackgroundColor ||
	              prevStyle.textDecoration !== thisStyle.textDecoration ||
	              prevStyle.fontFamily !== thisStyle.fontFamily ||
	              prevStyle.fontWeight !== thisStyle.fontWeight ||
	              prevStyle.fontStyle !== thisStyle.fontStyle ||
	              prevStyle.stroke !== thisStyle.stroke ||
	              prevStyle.strokeWidth !== thisStyle.strokeWidth
	      );
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderCharDecoration: function(ctx, textDecoration, left, top, offset, charWidth, charHeight) {
	
	      if (!textDecoration) {
	        return;
	      }
	
	      var decorationWeight = charHeight / 15,
	          positions = {
	            underline: top + charHeight / 10,
	            'line-through': top - charHeight * (this._fontSizeFraction + this._fontSizeMult - 1) + decorationWeight,
	            overline: top - (this._fontSizeMult - this._fontSizeFraction) * charHeight
	          },
	          decorations = ['underline', 'line-through', 'overline'], i, decoration;
	
	      for (i = 0; i < decorations.length; i++) {
	        decoration = decorations[i];
	        if (textDecoration.indexOf(decoration) > -1) {
	          ctx.fillRect(left, positions[decoration], charWidth , decorationWeight);
	        }
	      }
	    },
	
	    /**
	     * @private
	     * @param {String} method
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {String} line
	     * @param {Number} left
	     * @param {Number} top
	     * @param {Number} lineIndex
	     */
	    _renderTextLine: function(method, ctx, line, left, top, lineIndex) {
	      // to "cancel" this.fontSize subtraction in fabric.Text#_renderTextLine
	      // the adding 0.03 is just to align text with itext by overlap test
	      if (!this.isEmptyStyles()) {
	        top += this.fontSize * (this._fontSizeFraction + 0.03);
	      }
	      this.callSuper('_renderTextLine', method, ctx, line, left, top, lineIndex);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderTextDecoration: function(ctx) {
	      if (this.isEmptyStyles()) {
	        return this.callSuper('_renderTextDecoration', ctx);
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderTextLinesBackground: function(ctx) {
	      this.callSuper('_renderTextLinesBackground', ctx);
	
	      var lineTopOffset = 0, heightOfLine,
	          lineWidth, lineLeftOffset,
	          leftOffset = this._getLeftOffset(),
	          topOffset = this._getTopOffset(),
	          line, _char, style;
	      ctx.save();
	      for (var i = 0, len = this._textLines.length; i < len; i++) {
	        heightOfLine = this._getHeightOfLine(ctx, i);
	        line = this._textLines[i];
	
	        if (line === '' || !this.styles || !this._getLineStyle(i)) {
	          lineTopOffset += heightOfLine;
	          continue;
	        }
	
	        lineWidth = this._getLineWidth(ctx, i);
	        lineLeftOffset = this._getLineLeftOffset(lineWidth);
	
	        for (var j = 0, jlen = line.length; j < jlen; j++) {
	          style = this._getStyleDeclaration(i, j);
	          if (!style || !style.textBackgroundColor) {
	            continue;
	          }
	          _char = line[j];
	
	          ctx.fillStyle = style.textBackgroundColor;
	
	          ctx.fillRect(
	            leftOffset + lineLeftOffset + this._getWidthOfCharsAt(ctx, i, j),
	            topOffset + lineTopOffset,
	            this._getWidthOfChar(ctx, _char, i, j),
	            heightOfLine / this.lineHeight
	          );
	        }
	        lineTopOffset += heightOfLine;
	      }
	      ctx.restore();
	    },
	
	    /**
	     * @private
	     */
	    _getCacheProp: function(_char, styleDeclaration) {
	      return _char +
	             styleDeclaration.fontSize +
	             styleDeclaration.fontWeight +
	             styleDeclaration.fontStyle;
	    },
	
	    /**
	     * @private
	     * @param {String} fontFamily name
	     * @return {Object} reference to cache
	     */
	    _getFontCache: function(fontFamily) {
	      if (!fabric.charWidthsCache[fontFamily]) {
	        fabric.charWidthsCache[fontFamily] = { };
	      }
	      return fabric.charWidthsCache[fontFamily];
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {String} _char
	     * @param {Number} lineIndex
	     * @param {Number} charIndex
	     * @param {Object} [decl]
	     */
	    _applyCharStylesGetWidth: function(ctx, _char, lineIndex, charIndex, decl) {
	      var charDecl = decl || this._getStyleDeclaration(lineIndex, charIndex),
	          styleDeclaration = clone(charDecl),
	          width, cacheProp, charWidthsCache;
	
	      this._applyFontStyles(styleDeclaration);
	      charWidthsCache = this._getFontCache(styleDeclaration.fontFamily);
	      cacheProp = this._getCacheProp(_char, styleDeclaration);
	
	      // short-circuit if no styles for this char
	      // global style from object is always applyed and handled by save and restore
	      if (!charDecl && charWidthsCache[cacheProp] && this.caching) {
	        return charWidthsCache[cacheProp];
	      }
	
	      if (typeof styleDeclaration.shadow === 'string') {
	        styleDeclaration.shadow = new fabric.Shadow(styleDeclaration.shadow);
	      }
	
	      var fill = styleDeclaration.fill || this.fill;
	      ctx.fillStyle = fill.toLive
	        ? fill.toLive(ctx, this)
	        : fill;
	
	      if (styleDeclaration.stroke) {
	        ctx.strokeStyle = (styleDeclaration.stroke && styleDeclaration.stroke.toLive)
	          ? styleDeclaration.stroke.toLive(ctx, this)
	          : styleDeclaration.stroke;
	      }
	
	      ctx.lineWidth = styleDeclaration.strokeWidth || this.strokeWidth;
	      ctx.font = this._getFontDeclaration.call(styleDeclaration);
	
	      //if we want this._setShadow.call to work with styleDeclarion
	      //we have to add those references
	      if (styleDeclaration.shadow) {
	        styleDeclaration.scaleX = this.scaleX;
	        styleDeclaration.scaleY = this.scaleY;
	        styleDeclaration.canvas = this.canvas;
	        styleDeclaration.getObjectScaling = this.getObjectScaling;
	        this._setShadow.call(styleDeclaration, ctx);
	      }
	
	      if (!this.caching || !charWidthsCache[cacheProp]) {
	        width = ctx.measureText(_char).width;
	        this.caching && (charWidthsCache[cacheProp] = width);
	        return width;
	      }
	
	      return charWidthsCache[cacheProp];
	    },
	
	    /**
	     * @private
	     * @param {Object} styleDeclaration
	     */
	    _applyFontStyles: function(styleDeclaration) {
	      if (!styleDeclaration.fontFamily) {
	        styleDeclaration.fontFamily = this.fontFamily;
	      }
	      if (!styleDeclaration.fontSize) {
	        styleDeclaration.fontSize = this.fontSize;
	      }
	      if (!styleDeclaration.fontWeight) {
	        styleDeclaration.fontWeight = this.fontWeight;
	      }
	      if (!styleDeclaration.fontStyle) {
	        styleDeclaration.fontStyle = this.fontStyle;
	      }
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @param {Number} charIndex
	     * @param {Boolean} [returnCloneOrEmpty=false]
	     * @private
	     */
	    _getStyleDeclaration: function(lineIndex, charIndex, returnCloneOrEmpty) {
	      if (returnCloneOrEmpty) {
	        return (this.styles[lineIndex] && this.styles[lineIndex][charIndex])
	          ? clone(this.styles[lineIndex][charIndex])
	          : { };
	      }
	
	      return this.styles[lineIndex] && this.styles[lineIndex][charIndex] ? this.styles[lineIndex][charIndex] : null;
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @param {Number} charIndex
	     * @param {Object} style
	     * @private
	     */
	    _setStyleDeclaration: function(lineIndex, charIndex, style) {
	      this.styles[lineIndex][charIndex] = style;
	    },
	
	    /**
	     *
	     * @param {Number} lineIndex
	     * @param {Number} charIndex
	     * @private
	     */
	    _deleteStyleDeclaration: function(lineIndex, charIndex) {
	      delete this.styles[lineIndex][charIndex];
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @private
	     */
	    _getLineStyle: function(lineIndex) {
	      return this.styles[lineIndex];
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @param {Object} style
	     * @private
	     */
	    _setLineStyle: function(lineIndex, style) {
	      this.styles[lineIndex] = style;
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @private
	     */
	    _deleteLineStyle: function(lineIndex) {
	      delete this.styles[lineIndex];
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _getWidthOfChar: function(ctx, _char, lineIndex, charIndex) {
	      if (!this._isMeasuring && this.textAlign === 'justify' && this._reSpacesAndTabs.test(_char)) {
	        return this._getWidthOfSpace(ctx, lineIndex);
	      }
	      ctx.save();
	      var width = this._applyCharStylesGetWidth(ctx, _char, lineIndex, charIndex);
	      if (this.charSpacing !== 0) {
	        width += this._getWidthOfCharSpacing();
	      }
	      ctx.restore();
	      return width > 0 ? width : 0;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Number} lineIndex
	     * @param {Number} charIndex
	     */
	    _getHeightOfChar: function(ctx, lineIndex, charIndex) {
	      var style = this._getStyleDeclaration(lineIndex, charIndex);
	      return style && style.fontSize ? style.fontSize : this.fontSize;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Number} lineIndex
	     * @param {Number} charIndex
	     */
	    _getWidthOfCharsAt: function(ctx, lineIndex, charIndex) {
	      var width = 0, i, _char;
	      for (i = 0; i < charIndex; i++) {
	        _char = this._textLines[lineIndex][i];
	        width += this._getWidthOfChar(ctx, _char, lineIndex, i);
	      }
	      return width;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Number} lineIndex line number
	     * @return {Number} Line width
	     */
	    _measureLine: function(ctx, lineIndex) {
	      this._isMeasuring = true;
	      var width = this._getWidthOfCharsAt(ctx, lineIndex, this._textLines[lineIndex].length);
	      if (this.charSpacing !== 0) {
	        width -= this._getWidthOfCharSpacing();
	      }
	      this._isMeasuring = false;
	      return width > 0 ? width : 0;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Number} lineIndex
	     */
	    _getWidthOfSpace: function (ctx, lineIndex) {
	      if (this.__widthOfSpace[lineIndex]) {
	        return this.__widthOfSpace[lineIndex];
	      }
	      var line = this._textLines[lineIndex],
	          wordsWidth = this._getWidthOfWords(ctx, line, lineIndex, 0),
	          widthDiff = this.width - wordsWidth,
	          numSpaces = line.length - line.replace(this._reSpacesAndTabs, '').length,
	          width = Math.max(widthDiff / numSpaces, ctx.measureText(' ').width);
	      this.__widthOfSpace[lineIndex] = width;
	      return width;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {String} line
	     * @param {Number} lineIndex
	     * @param {Number} charOffset
	     */
	    _getWidthOfWords: function (ctx, line, lineIndex, charOffset) {
	      var width = 0;
	
	      for (var charIndex = 0; charIndex < line.length; charIndex++) {
	        var _char = line[charIndex];
	
	        if (!_char.match(/\s/)) {
	          width += this._getWidthOfChar(ctx, _char, lineIndex, charIndex + charOffset);
	        }
	      }
	
	      return width;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _getHeightOfLine: function(ctx, lineIndex) {
	      if (this.__lineHeights[lineIndex]) {
	        return this.__lineHeights[lineIndex];
	      }
	
	      var line = this._textLines[lineIndex],
	          maxHeight = this._getHeightOfChar(ctx, lineIndex, 0);
	
	      for (var i = 1, len = line.length; i < len; i++) {
	        var currentCharHeight = this._getHeightOfChar(ctx, lineIndex, i);
	        if (currentCharHeight > maxHeight) {
	          maxHeight = currentCharHeight;
	        }
	      }
	      this.__lineHeights[lineIndex] = maxHeight * this.lineHeight * this._fontSizeMult;
	      return this.__lineHeights[lineIndex];
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _getTextHeight: function(ctx) {
	      var lineHeight, height = 0;
	      for (var i = 0, len = this._textLines.length; i < len; i++) {
	        lineHeight = this._getHeightOfLine(ctx, i);
	        height += (i === len - 1 ? lineHeight / this.lineHeight : lineHeight);
	      }
	      return height;
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @method toObject
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      return fabric.util.object.extend(this.callSuper('toObject', propertiesToInclude), {
	        styles: clone(this.styles, true)
	      });
	    }
	  });
	
	  /**
	   * Returns fabric.IText instance from an object representation
	   * @static
	   * @memberOf fabric.IText
	   * @param {Object} object Object to create an instance from
	   * @param {function} [callback] invoked with new instance as argument
	   * @param {Boolean} [forceAsync] Force an async behaviour trying to create pattern first
	   * @return {fabric.IText} instance of fabric.IText
	   */
	  fabric.IText.fromObject = function(object, callback, forceAsync) {
	    return fabric.Object._fromObject('IText', object, callback, forceAsync, 'text');
	  };
	})();
	
	
	(function() {
	
	  var clone = fabric.util.object.clone;
	
	  fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {
	
	    /**
	     * Initializes all the interactive behavior of IText
	     */
	    initBehavior: function() {
	      this.initAddedHandler();
	      this.initRemovedHandler();
	      this.initCursorSelectionHandlers();
	      this.initDoubleClickSimulation();
	      this.mouseMoveHandler = this.mouseMoveHandler.bind(this);
	    },
	
	    /**
	     * Initializes "selected" event handler
	     */
	    initSelectedHandler: function() {
	      this.on('selected', function() {
	
	        var _this = this;
	        setTimeout(function() {
	          _this.selected = true;
	        }, 100);
	      });
	    },
	
	    /**
	     * Initializes "added" event handler
	     */
	    initAddedHandler: function() {
	      var _this = this;
	      this.on('added', function() {
	        var canvas = _this.canvas;
	        if (canvas) {
	          if (!canvas._hasITextHandlers) {
	            canvas._hasITextHandlers = true;
	            _this._initCanvasHandlers(canvas);
	          }
	          canvas._iTextInstances = canvas._iTextInstances || [];
	          canvas._iTextInstances.push(_this);
	        }
	      });
	    },
	
	    initRemovedHandler: function() {
	      var _this = this;
	      this.on('removed', function() {
	        var canvas = _this.canvas;
	        if (canvas) {
	          canvas._iTextInstances = canvas._iTextInstances || [];
	          fabric.util.removeFromArray(canvas._iTextInstances, _this);
	          if (canvas._iTextInstances.length === 0) {
	            canvas._hasITextHandlers = false;
	            _this._removeCanvasHandlers(canvas);
	          }
	        }
	      });
	    },
	
	    /**
	     * register canvas event to manage exiting on other instances
	     * @private
	     */
	    _initCanvasHandlers: function(canvas) {
	      canvas._canvasITextSelectionClearedHanlder = (function() {
	        fabric.IText.prototype.exitEditingOnOthers(canvas);
	      }).bind(this);
	      canvas._mouseUpITextHandler = (function() {
	        if (canvas._iTextInstances) {
	          canvas._iTextInstances.forEach(function(obj) {
	            obj.__isMousedown = false;
	          });
	        }
	      }).bind(this);
	      canvas.on('selection:cleared', canvas._canvasITextSelectionClearedHanlder);
	      canvas.on('object:selected', canvas._canvasITextSelectionClearedHanlder);
	      canvas.on('mouse:up', canvas._mouseUpITextHandler);
	    },
	
	    /**
	     * remove canvas event to manage exiting on other instances
	     * @private
	     */
	    _removeCanvasHandlers: function(canvas) {
	      canvas.off('selection:cleared', canvas._canvasITextSelectionClearedHanlder);
	      canvas.off('object:selected', canvas._canvasITextSelectionClearedHanlder);
	      canvas.off('mouse:up', canvas._mouseUpITextHandler);
	    },
	
	    /**
	     * @private
	     */
	    _tick: function() {
	      this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, '_onTickComplete');
	    },
	
	    /**
	     * @private
	     */
	    _animateCursor: function(obj, targetOpacity, duration, completeMethod) {
	
	      var tickState;
	
	      tickState = {
	        isAborted: false,
	        abort: function() {
	          this.isAborted = true;
	        },
	      };
	
	      obj.animate('_currentCursorOpacity', targetOpacity, {
	        duration: duration,
	        onComplete: function() {
	          if (!tickState.isAborted) {
	            obj[completeMethod]();
	          }
	        },
	        onChange: function() {
	          // we do not want to animate a selection, only cursor
	          if (obj.canvas && obj.selectionStart === obj.selectionEnd) {
	            obj.renderCursorOrSelection();
	          }
	        },
	        abort: function() {
	          return tickState.isAborted;
	        }
	      });
	      return tickState;
	    },
	
	    /**
	     * @private
	     */
	    _onTickComplete: function() {
	
	      var _this = this;
	
	      if (this._cursorTimeout1) {
	        clearTimeout(this._cursorTimeout1);
	      }
	      this._cursorTimeout1 = setTimeout(function() {
	        _this._currentTickCompleteState = _this._animateCursor(_this, 0, this.cursorDuration / 2, '_tick');
	      }, 100);
	    },
	
	    /**
	     * Initializes delayed cursor
	     */
	    initDelayedCursor: function(restart) {
	      var _this = this,
	          delay = restart ? 0 : this.cursorDelay;
	
	      this.abortCursorAnimation();
	      this._currentCursorOpacity = 1;
	      this._cursorTimeout2 = setTimeout(function() {
	        _this._tick();
	      }, delay);
	    },
	
	    /**
	     * Aborts cursor animation and clears all timeouts
	     */
	    abortCursorAnimation: function() {
	      var shouldClear = this._currentTickState || this._currentTickCompleteState;
	      this._currentTickState && this._currentTickState.abort();
	      this._currentTickCompleteState && this._currentTickCompleteState.abort();
	
	      clearTimeout(this._cursorTimeout1);
	      clearTimeout(this._cursorTimeout2);
	
	      this._currentCursorOpacity = 0;
	      // to clear just itext area we need to transform the context
	      // it may not be worth it
	      if (shouldClear) {
	        this.canvas && this.canvas.clearContext(this.canvas.contextTop || this.ctx);
	      }
	
	    },
	
	    /**
	     * Selects entire text
	     */
	    selectAll: function() {
	      this.selectionStart = 0;
	      this.selectionEnd = this.text.length;
	      this._fireSelectionChanged();
	      this._updateTextarea();
	    },
	
	    /**
	     * Returns selected text
	     * @return {String}
	     */
	    getSelectedText: function() {
	      return this.text.slice(this.selectionStart, this.selectionEnd);
	    },
	
	    /**
	     * Find new selection index representing start of current word according to current selection index
	     * @param {Number} startFrom Surrent selection index
	     * @return {Number} New selection index
	     */
	    findWordBoundaryLeft: function(startFrom) {
	      var offset = 0, index = startFrom - 1;
	
	      // remove space before cursor first
	      if (this._reSpace.test(this.text.charAt(index))) {
	        while (this._reSpace.test(this.text.charAt(index))) {
	          offset++;
	          index--;
	        }
	      }
	      while (/\S/.test(this.text.charAt(index)) && index > -1) {
	        offset++;
	        index--;
	      }
	
	      return startFrom - offset;
	    },
	
	    /**
	     * Find new selection index representing end of current word according to current selection index
	     * @param {Number} startFrom Current selection index
	     * @return {Number} New selection index
	     */
	    findWordBoundaryRight: function(startFrom) {
	      var offset = 0, index = startFrom;
	
	      // remove space after cursor first
	      if (this._reSpace.test(this.text.charAt(index))) {
	        while (this._reSpace.test(this.text.charAt(index))) {
	          offset++;
	          index++;
	        }
	      }
	      while (/\S/.test(this.text.charAt(index)) && index < this.text.length) {
	        offset++;
	        index++;
	      }
	
	      return startFrom + offset;
	    },
	
	    /**
	     * Find new selection index representing start of current line according to current selection index
	     * @param {Number} startFrom Current selection index
	     * @return {Number} New selection index
	     */
	    findLineBoundaryLeft: function(startFrom) {
	      var offset = 0, index = startFrom - 1;
	
	      while (!/\n/.test(this.text.charAt(index)) && index > -1) {
	        offset++;
	        index--;
	      }
	
	      return startFrom - offset;
	    },
	
	    /**
	     * Find new selection index representing end of current line according to current selection index
	     * @param {Number} startFrom Current selection index
	     * @return {Number} New selection index
	     */
	    findLineBoundaryRight: function(startFrom) {
	      var offset = 0, index = startFrom;
	
	      while (!/\n/.test(this.text.charAt(index)) && index < this.text.length) {
	        offset++;
	        index++;
	      }
	
	      return startFrom + offset;
	    },
	
	    /**
	     * Returns number of newlines in selected text
	     * @return {Number} Number of newlines in selected text
	     */
	    getNumNewLinesInSelectedText: function() {
	      var selectedText = this.getSelectedText(),
	          numNewLines  = 0;
	
	      for (var i = 0, len = selectedText.length; i < len; i++) {
	        if (selectedText[i] === '\n') {
	          numNewLines++;
	        }
	      }
	      return numNewLines;
	    },
	
	    /**
	     * Finds index corresponding to beginning or end of a word
	     * @param {Number} selectionStart Index of a character
	     * @param {Number} direction 1 or -1
	     * @return {Number} Index of the beginning or end of a word
	     */
	    searchWordBoundary: function(selectionStart, direction) {
	      var index     = this._reSpace.test(this.text.charAt(selectionStart)) ? selectionStart - 1 : selectionStart,
	          _char     = this.text.charAt(index),
	          reNonWord = /[ \n\.,;!\?\-]/;
	
	      while (!reNonWord.test(_char) && index > 0 && index < this.text.length) {
	        index += direction;
	        _char = this.text.charAt(index);
	      }
	      if (reNonWord.test(_char) && _char !== '\n') {
	        index += direction === 1 ? 0 : 1;
	      }
	      return index;
	    },
	
	    /**
	     * Selects a word based on the index
	     * @param {Number} selectionStart Index of a character
	     */
	    selectWord: function(selectionStart) {
	      selectionStart = selectionStart || this.selectionStart;
	      var newSelectionStart = this.searchWordBoundary(selectionStart, -1), /* search backwards */
	          newSelectionEnd = this.searchWordBoundary(selectionStart, 1); /* search forward */
	
	      this.selectionStart = newSelectionStart;
	      this.selectionEnd = newSelectionEnd;
	      this._fireSelectionChanged();
	      this._updateTextarea();
	      this.renderCursorOrSelection();
	    },
	
	    /**
	     * Selects a line based on the index
	     * @param {Number} selectionStart Index of a character
	     */
	    selectLine: function(selectionStart) {
	      selectionStart = selectionStart || this.selectionStart;
	      var newSelectionStart = this.findLineBoundaryLeft(selectionStart),
	          newSelectionEnd = this.findLineBoundaryRight(selectionStart);
	
	      this.selectionStart = newSelectionStart;
	      this.selectionEnd = newSelectionEnd;
	      this._fireSelectionChanged();
	      this._updateTextarea();
	    },
	
	    /**
	     * Enters editing state
	     * @return {fabric.IText} thisArg
	     * @chainable
	     */
	    enterEditing: function(e) {
	      if (this.isEditing || !this.editable) {
	        return;
	      }
	
	      if (this.canvas) {
	        this.exitEditingOnOthers(this.canvas);
	      }
	
	      this.isEditing = true;
	
	      this.initHiddenTextarea(e);
	      this.hiddenTextarea.focus();
	      this._updateTextarea();
	      this._saveEditingProps();
	      this._setEditingProps();
	      this._textBeforeEdit = this.text;
	
	      this._tick();
	      this.fire('editing:entered');
	
	      if (!this.canvas) {
	        return this;
	      }
	      this.canvas.fire('text:editing:entered', { target: this });
	      this.initMouseMoveHandler();
	      this.canvas.renderAll();
	      return this;
	    },
	
	    exitEditingOnOthers: function(canvas) {
	      if (canvas._iTextInstances) {
	        canvas._iTextInstances.forEach(function(obj) {
	          obj.selected = false;
	          if (obj.isEditing) {
	            obj.exitEditing();
	          }
	        });
	      }
	    },
	
	    /**
	     * Initializes "mousemove" event handler
	     */
	    initMouseMoveHandler: function() {
	      this.canvas.on('mouse:move', this.mouseMoveHandler);
	    },
	
	    /**
	     * @private
	     */
	    mouseMoveHandler: function(options) {
	      if (!this.__isMousedown || !this.isEditing) {
	        return;
	      }
	
	      var newSelectionStart = this.getSelectionStartFromPointer(options.e),
	          currentStart = this.selectionStart,
	          currentEnd = this.selectionEnd;
	      if (newSelectionStart === this.__selectionStartOnMouseDown) {
	        return;
	      }
	      if (newSelectionStart > this.__selectionStartOnMouseDown) {
	        this.selectionStart = this.__selectionStartOnMouseDown;
	        this.selectionEnd = newSelectionStart;
	      }
	      else {
	        this.selectionStart = newSelectionStart;
	        this.selectionEnd = this.__selectionStartOnMouseDown;
	      }
	      if (this.selectionStart !== currentStart || this.selectionEnd !== currentEnd) {
	        this._fireSelectionChanged();
	        this._updateTextarea();
	        this.renderCursorOrSelection();
	      }
	    },
	
	    /**
	     * @private
	     */
	    _setEditingProps: function() {
	      this.hoverCursor = 'text';
	
	      if (this.canvas) {
	        this.canvas.defaultCursor = this.canvas.moveCursor = 'text';
	      }
	
	      this.borderColor = this.editingBorderColor;
	
	      this.hasControls = this.selectable = false;
	      this.lockMovementX = this.lockMovementY = true;
	    },
	
	    /**
	     * @private
	     */
	    _updateTextarea: function() {
	      if (!this.hiddenTextarea || this.inCompositionMode) {
	        return;
	      }
	      this.cursorOffsetCache = { };
	      this.hiddenTextarea.value = this.text;
	      this.hiddenTextarea.selectionStart = this.selectionStart;
	      this.hiddenTextarea.selectionEnd = this.selectionEnd;
	      if (this.selectionStart === this.selectionEnd) {
	        var style = this._calcTextareaPosition();
	        this.hiddenTextarea.style.left = style.left;
	        this.hiddenTextarea.style.top = style.top;
	        this.hiddenTextarea.style.fontSize = style.fontSize;
	      }
	    },
	
	    /**
	     * @private
	     * @return {Object} style contains style for hiddenTextarea
	     */
	    _calcTextareaPosition: function() {
	      if (!this.canvas) {
	        return { x: 1, y: 1 };
	      }
	      var chars = this.text.split(''),
	          boundaries = this._getCursorBoundaries(chars, 'cursor'),
	          cursorLocation = this.get2DCursorLocation(),
	          lineIndex = cursorLocation.lineIndex,
	          charIndex = cursorLocation.charIndex,
	          charHeight = this.getCurrentCharFontSize(lineIndex, charIndex),
	          leftOffset = (lineIndex === 0 && charIndex === 0)
	                    ? this._getLineLeftOffset(this._getLineWidth(this.ctx, lineIndex))
	                    : boundaries.leftOffset,
	          m = this.calcTransformMatrix(),
	          p = {
	            x: boundaries.left + leftOffset,
	            y: boundaries.top + boundaries.topOffset + charHeight
	          },
	          upperCanvas = this.canvas.upperCanvasEl,
	          maxWidth = upperCanvas.width - charHeight,
	          maxHeight = upperCanvas.height - charHeight;
	
	      p = fabric.util.transformPoint(p, m);
	      p = fabric.util.transformPoint(p, this.canvas.viewportTransform);
	
	      if (p.x < 0) {
	        p.x = 0;
	      }
	      if (p.x > maxWidth) {
	        p.x = maxWidth;
	      }
	      if (p.y < 0) {
	        p.y = 0;
	      }
	      if (p.y > maxHeight) {
	        p.y = maxHeight;
	      }
	
	      // add canvas offset on document
	      p.x += this.canvas._offset.left;
	      p.y += this.canvas._offset.top;
	
	      return { left: p.x + 'px', top: p.y + 'px', fontSize: charHeight };
	    },
	
	    /**
	     * @private
	     */
	    _saveEditingProps: function() {
	      this._savedProps = {
	        hasControls: this.hasControls,
	        borderColor: this.borderColor,
	        lockMovementX: this.lockMovementX,
	        lockMovementY: this.lockMovementY,
	        hoverCursor: this.hoverCursor,
	        defaultCursor: this.canvas && this.canvas.defaultCursor,
	        moveCursor: this.canvas && this.canvas.moveCursor
	      };
	    },
	
	    /**
	     * @private
	     */
	    _restoreEditingProps: function() {
	      if (!this._savedProps) {
	        return;
	      }
	
	      this.hoverCursor = this._savedProps.overCursor;
	      this.hasControls = this._savedProps.hasControls;
	      this.borderColor = this._savedProps.borderColor;
	      this.lockMovementX = this._savedProps.lockMovementX;
	      this.lockMovementY = this._savedProps.lockMovementY;
	
	      if (this.canvas) {
	        this.canvas.defaultCursor = this._savedProps.defaultCursor;
	        this.canvas.moveCursor = this._savedProps.moveCursor;
	      }
	    },
	
	    /**
	     * Exits from editing state
	     * @return {fabric.IText} thisArg
	     * @chainable
	     */
	    exitEditing: function() {
	      var isTextChanged = (this._textBeforeEdit !== this.text);
	      this.selected = false;
	      this.isEditing = false;
	      this.selectable = true;
	
	      this.selectionEnd = this.selectionStart;
	      this.hiddenTextarea.blur && this.hiddenTextarea.blur();
	      this.hiddenTextarea && this.canvas && this.hiddenTextarea.parentNode.removeChild(this.hiddenTextarea);
	      this.hiddenTextarea = null;
	
	      this.abortCursorAnimation();
	      this._restoreEditingProps();
	      this._currentCursorOpacity = 0;
	
	      this.fire('editing:exited');
	      isTextChanged && this.fire('modified');
	      if (this.canvas) {
	        this.canvas.off('mouse:move', this.mouseMoveHandler);
	        this.canvas.fire('text:editing:exited', { target: this });
	        isTextChanged && this.canvas.fire('object:modified', { target: this });
	      }
	
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _removeExtraneousStyles: function() {
	      for (var prop in this.styles) {
	        if (!this._textLines[prop]) {
	          delete this.styles[prop];
	        }
	      }
	    },
	
	    /**
	     * @private
	     */
	    _removeCharsFromTo: function(start, end) {
	      while (end !== start) {
	        this._removeSingleCharAndStyle(start + 1);
	        end--;
	      }
	      this.selectionStart = start;
	      this.selectionEnd = start;
	    },
	
	    _removeSingleCharAndStyle: function(index) {
	      var isBeginningOfLine = this.text[index - 1] === '\n',
	          indexStyle        = isBeginningOfLine ? index : index - 1;
	      this.removeStyleObject(isBeginningOfLine, indexStyle);
	      this.text = this.text.slice(0, index - 1) +
	        this.text.slice(index);
	
	      this._textLines = this._splitTextIntoLines();
	    },
	
	    /**
	     * Inserts characters where cursor is (replacing selection if one exists)
	     * @param {String} _chars Characters to insert
	     * @param {Boolean} useCopiedStyle use fabric.copiedTextStyle
	     */
	    insertChars: function(_chars, useCopiedStyle) {
	      var style;
	
	      if (this.selectionEnd - this.selectionStart > 1) {
	        this._removeCharsFromTo(this.selectionStart, this.selectionEnd);
	      }
	      //short circuit for block paste
	      if (!useCopiedStyle && this.isEmptyStyles()) {
	        this.insertChar(_chars, false);
	        return;
	      }
	      for (var i = 0, len = _chars.length; i < len; i++) {
	        if (useCopiedStyle) {
	          style = fabric.util.object.clone(fabric.copiedTextStyle[i], true);
	        }
	        this.insertChar(_chars[i], i < len - 1, style);
	      }
	    },
	
	    /**
	     * Inserts a character where cursor is
	     * @param {String} _char Characters to insert
	     * @param {Boolean} skipUpdate trigger rendering and updates at the end of text insert
	     * @param {Object} styleObject Style to be inserted for the new char
	     */
	    insertChar: function(_char, skipUpdate, styleObject) {
	      var isEndOfLine = this.text[this.selectionStart] === '\n';
	      this.text = this.text.slice(0, this.selectionStart) +
	        _char + this.text.slice(this.selectionEnd);
	      this._textLines = this._splitTextIntoLines();
	      this.insertStyleObjects(_char, isEndOfLine, styleObject);
	      this.selectionStart += _char.length;
	      this.selectionEnd = this.selectionStart;
	      if (skipUpdate) {
	        return;
	      }
	      this._updateTextarea();
	      this.setCoords();
	      this._fireSelectionChanged();
	      this.fire('changed');
	      this.canvas && this.canvas.fire('text:changed', { target: this });
	      this.canvas && this.canvas.renderAll();
	    },
	
	    /**
	     * Inserts new style object
	     * @param {Number} lineIndex Index of a line
	     * @param {Number} charIndex Index of a char
	     * @param {Boolean} isEndOfLine True if it's end of line
	     */
	    insertNewlineStyleObject: function(lineIndex, charIndex, isEndOfLine) {
	
	      this.shiftLineStyles(lineIndex, +1);
	
	      if (!this.styles[lineIndex + 1]) {
	        this.styles[lineIndex + 1] = {};
	      }
	
	      var currentCharStyle = {},
	          newLineStyles    = {};
	
	      if (this.styles[lineIndex] && this.styles[lineIndex][charIndex - 1]) {
	        currentCharStyle = this.styles[lineIndex][charIndex - 1];
	      }
	
	      // if there's nothing after cursor,
	      // we clone current char style onto the next (otherwise empty) line
	      if (isEndOfLine) {
	        newLineStyles[0] = clone(currentCharStyle);
	        this.styles[lineIndex + 1] = newLineStyles;
	      }
	      // otherwise we clone styles of all chars
	      // after cursor onto the next line, from the beginning
	      else {
	        for (var index in this.styles[lineIndex]) {
	          if (parseInt(index, 10) >= charIndex) {
	            newLineStyles[parseInt(index, 10) - charIndex] = this.styles[lineIndex][index];
	            // remove lines from the previous line since they're on a new line now
	            delete this.styles[lineIndex][index];
	          }
	        }
	        this.styles[lineIndex + 1] = newLineStyles;
	      }
	      this._forceClearCache = true;
	    },
	
	    /**
	     * Inserts style object for a given line/char index
	     * @param {Number} lineIndex Index of a line
	     * @param {Number} charIndex Index of a char
	     * @param {Object} [style] Style object to insert, if given
	     */
	    insertCharStyleObject: function(lineIndex, charIndex, style) {
	
	      var currentLineStyles       = this.styles[lineIndex],
	          currentLineStylesCloned = clone(currentLineStyles);
	
	      if (charIndex === 0 && !style) {
	        charIndex = 1;
	      }
	
	      // shift all char styles by 1 forward
	      // 0,1,2,3 -> (charIndex=2) -> 0,1,3,4 -> (insert 2) -> 0,1,2,3,4
	      for (var index in currentLineStylesCloned) {
	        var numericIndex = parseInt(index, 10);
	
	        if (numericIndex >= charIndex) {
	          currentLineStyles[numericIndex + 1] = currentLineStylesCloned[numericIndex];
	
	          // only delete the style if there was nothing moved there
	          if (!currentLineStylesCloned[numericIndex - 1]) {
	            delete currentLineStyles[numericIndex];
	          }
	        }
	      }
	
	      this.styles[lineIndex][charIndex] =
	        style || clone(currentLineStyles[charIndex - 1]);
	      this._forceClearCache = true;
	    },
	
	    /**
	     * Inserts style object(s)
	     * @param {String} _chars Characters at the location where style is inserted
	     * @param {Boolean} isEndOfLine True if it's end of line
	     * @param {Object} [styleObject] Style to insert
	     */
	    insertStyleObjects: function(_chars, isEndOfLine, styleObject) {
	      // removed shortcircuit over isEmptyStyles
	
	      var cursorLocation = this.get2DCursorLocation(),
	          lineIndex      = cursorLocation.lineIndex,
	          charIndex      = cursorLocation.charIndex;
	
	      if (!this._getLineStyle(lineIndex)) {
	        this._setLineStyle(lineIndex, {});
	      }
	
	      if (_chars === '\n') {
	        this.insertNewlineStyleObject(lineIndex, charIndex, isEndOfLine);
	      }
	      else {
	        this.insertCharStyleObject(lineIndex, charIndex, styleObject);
	      }
	    },
	
	    /**
	     * Shifts line styles up or down
	     * @param {Number} lineIndex Index of a line
	     * @param {Number} offset Can be -1 or +1
	     */
	    shiftLineStyles: function(lineIndex, offset) {
	      // shift all line styles by 1 upward
	      var clonedStyles = clone(this.styles);
	      for (var line in this.styles) {
	        var numericLine = parseInt(line, 10);
	        if (numericLine > lineIndex) {
	          this.styles[numericLine + offset] = clonedStyles[numericLine];
	          if (!clonedStyles[numericLine - offset]) {
	            delete this.styles[numericLine];
	          }
	        }
	      }
	      //TODO: evaluate if delete old style lines with offset -1
	    },
	
	    /**
	     * Removes style object
	     * @param {Boolean} isBeginningOfLine True if cursor is at the beginning of line
	     * @param {Number} [index] Optional index. When not given, current selectionStart is used.
	     */
	    removeStyleObject: function(isBeginningOfLine, index) {
	
	      var cursorLocation = this.get2DCursorLocation(index),
	          lineIndex      = cursorLocation.lineIndex,
	          charIndex      = cursorLocation.charIndex;
	
	      this._removeStyleObject(isBeginningOfLine, cursorLocation, lineIndex, charIndex);
	    },
	
	    _getTextOnPreviousLine: function(lIndex) {
	      return this._textLines[lIndex - 1];
	    },
	
	    _removeStyleObject: function(isBeginningOfLine, cursorLocation, lineIndex, charIndex) {
	
	      if (isBeginningOfLine) {
	        var textOnPreviousLine     = this._getTextOnPreviousLine(cursorLocation.lineIndex),
	            newCharIndexOnPrevLine = textOnPreviousLine ? textOnPreviousLine.length : 0;
	
	        if (!this.styles[lineIndex - 1]) {
	          this.styles[lineIndex - 1] = {};
	        }
	        for (charIndex in this.styles[lineIndex]) {
	          this.styles[lineIndex - 1][parseInt(charIndex, 10) + newCharIndexOnPrevLine]
	            = this.styles[lineIndex][charIndex];
	        }
	        this.shiftLineStyles(cursorLocation.lineIndex, -1);
	      }
	      else {
	        var currentLineStyles = this.styles[lineIndex];
	
	        if (currentLineStyles) {
	          delete currentLineStyles[charIndex];
	        }
	        var currentLineStylesCloned = clone(currentLineStyles);
	        // shift all styles by 1 backwards
	        for (var i in currentLineStylesCloned) {
	          var numericIndex = parseInt(i, 10);
	          if (numericIndex >= charIndex && numericIndex !== 0) {
	            currentLineStyles[numericIndex - 1] = currentLineStylesCloned[numericIndex];
	            delete currentLineStyles[numericIndex];
	          }
	        }
	      }
	    },
	
	    /**
	     * Inserts new line
	     */
	    insertNewline: function() {
	      this.insertChars('\n');
	    },
	
	    /**
	     * Set the selectionStart and selectionEnd according to the ne postion of cursor
	     * mimic the key - mouse navigation when shift is pressed.
	     */
	    setSelectionStartEndWithShift: function(start, end, newSelection) {
	      if (newSelection <= start) {
	        if (end === start) {
	          this._selectionDirection = 'left';
	        }
	        else if (this._selectionDirection === 'right') {
	          this._selectionDirection = 'left';
	          this.selectionEnd = start;
	        }
	        this.selectionStart = newSelection;
	      }
	      else if (newSelection > start && newSelection < end) {
	        if (this._selectionDirection === 'right') {
	          this.selectionEnd = newSelection;
	        }
	        else {
	          this.selectionStart = newSelection;
	        }
	      }
	      else {
	        // newSelection is > selection start and end
	        if (end === start) {
	          this._selectionDirection = 'right';
	        }
	        else if (this._selectionDirection === 'left') {
	          this._selectionDirection = 'right';
	          this.selectionStart = end;
	        }
	        this.selectionEnd = newSelection;
	      }
	    },
	
	    setSelectionInBoundaries: function() {
	      var length = this.text.length;
	      if (this.selectionStart > length) {
	        this.selectionStart = length;
	      }
	      else if (this.selectionStart < 0) {
	        this.selectionStart = 0;
	      }
	      if (this.selectionEnd > length) {
	        this.selectionEnd = length;
	      }
	      else if (this.selectionEnd < 0) {
	        this.selectionEnd = 0;
	      }
	    }
	  });
	})();
	
	
	fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {
	  /**
	   * Initializes "dbclick" event handler
	   */
	  initDoubleClickSimulation: function() {
	
	    // for double click
	    this.__lastClickTime = +new Date();
	
	    // for triple click
	    this.__lastLastClickTime = +new Date();
	
	    this.__lastPointer = { };
	
	    this.on('mousedown', this.onMouseDown.bind(this));
	  },
	
	  onMouseDown: function(options) {
	
	    this.__newClickTime = +new Date();
	    var newPointer = this.canvas.getPointer(options.e);
	
	    if (this.isTripleClick(newPointer)) {
	      this.fire('tripleclick', options);
	      this._stopEvent(options.e);
	    }
	    else if (this.isDoubleClick(newPointer)) {
	      this.fire('dblclick', options);
	      this._stopEvent(options.e);
	    }
	
	    this.__lastLastClickTime = this.__lastClickTime;
	    this.__lastClickTime = this.__newClickTime;
	    this.__lastPointer = newPointer;
	    this.__lastIsEditing = this.isEditing;
	    this.__lastSelected = this.selected;
	  },
	
	  isDoubleClick: function(newPointer) {
	    return this.__newClickTime - this.__lastClickTime < 500 &&
	        this.__lastPointer.x === newPointer.x &&
	        this.__lastPointer.y === newPointer.y && this.__lastIsEditing;
	  },
	
	  isTripleClick: function(newPointer) {
	    return this.__newClickTime - this.__lastClickTime < 500 &&
	        this.__lastClickTime - this.__lastLastClickTime < 500 &&
	        this.__lastPointer.x === newPointer.x &&
	        this.__lastPointer.y === newPointer.y;
	  },
	
	  /**
	   * @private
	   */
	  _stopEvent: function(e) {
	    e.preventDefault && e.preventDefault();
	    e.stopPropagation && e.stopPropagation();
	  },
	
	  /**
	   * Initializes event handlers related to cursor or selection
	   */
	  initCursorSelectionHandlers: function() {
	    this.initSelectedHandler();
	    this.initMousedownHandler();
	    this.initMouseupHandler();
	    this.initClicks();
	  },
	
	  /**
	   * Initializes double and triple click event handlers
	   */
	  initClicks: function() {
	    this.on('dblclick', function(options) {
	      this.selectWord(this.getSelectionStartFromPointer(options.e));
	    });
	    this.on('tripleclick', function(options) {
	      this.selectLine(this.getSelectionStartFromPointer(options.e));
	    });
	  },
	
	  /**
	   * Initializes "mousedown" event handler
	   */
	  initMousedownHandler: function() {
	    this.on('mousedown', function(options) {
	      if (!this.editable) {
	        return;
	      }
	      var pointer = this.canvas.getPointer(options.e);
	
	      this.__mousedownX = pointer.x;
	      this.__mousedownY = pointer.y;
	      this.__isMousedown = true;
	
	      if (this.selected) {
	        this.setCursorByClick(options.e);
	      }
	
	      if (this.isEditing) {
	        this.__selectionStartOnMouseDown = this.selectionStart;
	        if (this.selectionStart === this.selectionEnd) {
	          this.abortCursorAnimation();
	        }
	        this.renderCursorOrSelection();
	      }
	    });
	  },
	
	  /**
	   * @private
	   */
	  _isObjectMoved: function(e) {
	    var pointer = this.canvas.getPointer(e);
	
	    return this.__mousedownX !== pointer.x ||
	           this.__mousedownY !== pointer.y;
	  },
	
	  /**
	   * Initializes "mouseup" event handler
	   */
	  initMouseupHandler: function() {
	    this.on('mouseup', function(options) {
	      this.__isMousedown = false;
	      if (!this.editable || this._isObjectMoved(options.e)) {
	        return;
	      }
	
	      if (this.__lastSelected && !this.__corner) {
	        this.enterEditing(options.e);
	        if (this.selectionStart === this.selectionEnd) {
	          this.initDelayedCursor(true);
	        }
	        else {
	          this.renderCursorOrSelection();
	        }
	      }
	      this.selected = true;
	    });
	  },
	
	  /**
	   * Changes cursor location in a text depending on passed pointer (x/y) object
	   * @param {Event} e Event object
	   */
	  setCursorByClick: function(e) {
	    var newSelection = this.getSelectionStartFromPointer(e),
	        start = this.selectionStart, end = this.selectionEnd;
	    if (e.shiftKey) {
	      this.setSelectionStartEndWithShift(start, end, newSelection);
	    }
	    else {
	      this.selectionStart = newSelection;
	      this.selectionEnd = newSelection;
	    }
	    this._fireSelectionChanged();
	    this._updateTextarea();
	  },
	
	  /**
	   * Returns index of a character corresponding to where an object was clicked
	   * @param {Event} e Event object
	   * @return {Number} Index of a character
	   */
	  getSelectionStartFromPointer: function(e) {
	    var mouseOffset = this.getLocalPointer(e),
	        prevWidth = 0,
	        width = 0,
	        height = 0,
	        charIndex = 0,
	        newSelectionStart,
	        line;
	
	    for (var i = 0, len = this._textLines.length; i < len; i++) {
	      line = this._textLines[i];
	      height += this._getHeightOfLine(this.ctx, i) * this.scaleY;
	
	      var widthOfLine = this._getLineWidth(this.ctx, i),
	          lineLeftOffset = this._getLineLeftOffset(widthOfLine);
	
	      width = lineLeftOffset * this.scaleX;
	
	      for (var j = 0, jlen = line.length; j < jlen; j++) {
	
	        prevWidth = width;
	
	        width += this._getWidthOfChar(this.ctx, line[j], i, this.flipX ? jlen - j : j) *
	                 this.scaleX;
	
	        if (height <= mouseOffset.y || width <= mouseOffset.x) {
	          charIndex++;
	          continue;
	        }
	
	        return this._getNewSelectionStartFromOffset(
	          mouseOffset, prevWidth, width, charIndex + i, jlen);
	      }
	
	      if (mouseOffset.y < height) {
	        //this happens just on end of lines.
	        return this._getNewSelectionStartFromOffset(
	          mouseOffset, prevWidth, width, charIndex + i - 1, jlen);
	      }
	    }
	
	    // clicked somewhere after all chars, so set at the end
	    if (typeof newSelectionStart === 'undefined') {
	      return this.text.length;
	    }
	  },
	
	  /**
	   * @private
	   */
	  _getNewSelectionStartFromOffset: function(mouseOffset, prevWidth, width, index, jlen) {
	
	    var distanceBtwLastCharAndCursor = mouseOffset.x - prevWidth,
	        distanceBtwNextCharAndCursor = width - mouseOffset.x,
	        offset = distanceBtwNextCharAndCursor > distanceBtwLastCharAndCursor ? 0 : 1,
	        newSelectionStart = index + offset;
	
	    // if object is horizontally flipped, mirror cursor location from the end
	    if (this.flipX) {
	      newSelectionStart = jlen - newSelectionStart;
	    }
	
	    if (newSelectionStart > this.text.length) {
	      newSelectionStart = this.text.length;
	    }
	
	    return newSelectionStart;
	  }
	});
	
	
	fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {
	
	  /**
	   * Initializes hidden textarea (needed to bring up keyboard in iOS)
	   */
	  initHiddenTextarea: function() {
	    this.hiddenTextarea = fabric.document.createElement('textarea');
	    this.hiddenTextarea.setAttribute('autocapitalize', 'off');
	    var style = this._calcTextareaPosition();
	    this.hiddenTextarea.style.cssText = 'position: absolute; top: ' + style.top + '; left: ' + style.left + ';'
	                                        + ' opacity: 0; width: 0px; height: 0px; z-index: -999;';
	    fabric.document.body.appendChild(this.hiddenTextarea);
	
	    fabric.util.addListener(this.hiddenTextarea, 'keydown', this.onKeyDown.bind(this));
	    fabric.util.addListener(this.hiddenTextarea, 'keyup', this.onKeyUp.bind(this));
	    fabric.util.addListener(this.hiddenTextarea, 'input', this.onInput.bind(this));
	    fabric.util.addListener(this.hiddenTextarea, 'copy', this.copy.bind(this));
	    fabric.util.addListener(this.hiddenTextarea, 'cut', this.cut.bind(this));
	    fabric.util.addListener(this.hiddenTextarea, 'paste', this.paste.bind(this));
	    fabric.util.addListener(this.hiddenTextarea, 'compositionstart', this.onCompositionStart.bind(this));
	    fabric.util.addListener(this.hiddenTextarea, 'compositionupdate', this.onCompositionUpdate.bind(this));
	    fabric.util.addListener(this.hiddenTextarea, 'compositionend', this.onCompositionEnd.bind(this));
	
	    if (!this._clickHandlerInitialized && this.canvas) {
	      fabric.util.addListener(this.canvas.upperCanvasEl, 'click', this.onClick.bind(this));
	      this._clickHandlerInitialized = true;
	    }
	  },
	
	  /**
	   * @private
	   */
	  _keysMap: {
	    8:  'removeChars',
	    9:  'exitEditing',
	    27: 'exitEditing',
	    13: 'insertNewline',
	    33: 'moveCursorUp',
	    34: 'moveCursorDown',
	    35: 'moveCursorRight',
	    36: 'moveCursorLeft',
	    37: 'moveCursorLeft',
	    38: 'moveCursorUp',
	    39: 'moveCursorRight',
	    40: 'moveCursorDown',
	    46: 'forwardDelete'
	  },
	
	  /**
	   * @private
	   */
	  _ctrlKeysMapUp: {
	    67: 'copy',
	    88: 'cut'
	  },
	
	  /**
	   * @private
	   */
	  _ctrlKeysMapDown: {
	    65: 'selectAll'
	  },
	
	  onClick: function() {
	    // No need to trigger click event here, focus is enough to have the keyboard appear on Android
	    this.hiddenTextarea && this.hiddenTextarea.focus();
	  },
	
	  /**
	   * Handles keyup event
	   * @param {Event} e Event object
	   */
	  onKeyDown: function(e) {
	    if (!this.isEditing) {
	      return;
	    }
	    if (e.keyCode in this._keysMap) {
	      this[this._keysMap[e.keyCode]](e);
	    }
	    else if ((e.keyCode in this._ctrlKeysMapDown) && (e.ctrlKey || e.metaKey)) {
	      this[this._ctrlKeysMapDown[e.keyCode]](e);
	    }
	    else {
	      return;
	    }
	    e.stopImmediatePropagation();
	    e.preventDefault();
	    if (e.keyCode >= 33 && e.keyCode <= 40) {
	      // if i press an arrow key just update selection
	      this.clearContextTop();
	      this.renderCursorOrSelection();
	    }
	    else {
	      this.canvas && this.canvas.renderAll();
	    }
	  },
	
	  /**
	   * Handles keyup event
	   * We handle KeyUp because ie11 and edge have difficulties copy/pasting
	   * if a copy/cut event fired, keyup is dismissed
	   * @param {Event} e Event object
	   */
	  onKeyUp: function(e) {
	    if (!this.isEditing || this._copyDone) {
	      this._copyDone = false;
	      return;
	    }
	    if ((e.keyCode in this._ctrlKeysMapUp) && (e.ctrlKey || e.metaKey)) {
	      this[this._ctrlKeysMapUp[e.keyCode]](e);
	    }
	    else {
	      return;
	    }
	    e.stopImmediatePropagation();
	    e.preventDefault();
	    this.canvas && this.canvas.renderAll();
	  },
	
	  /**
	   * Handles onInput event
	   * @param {Event} e Event object
	   */
	  onInput: function(e) {
	    if (!this.isEditing || this.inCompositionMode) {
	      return;
	    }
	    var offset = this.selectionStart || 0,
	        offsetEnd = this.selectionEnd || 0,
	        textLength = this.text.length,
	        newTextLength = this.hiddenTextarea.value.length,
	        diff, charsToInsert, start;
	    if (newTextLength > textLength) {
	      //we added some character
	      start = this._selectionDirection === 'left' ? offsetEnd : offset;
	      diff = newTextLength - textLength;
	      charsToInsert = this.hiddenTextarea.value.slice(start, start + diff);
	    }
	    else {
	      //we selected a portion of text and then input something else.
	      //Internet explorer does not trigger this else
	      diff = newTextLength - textLength + offsetEnd - offset;
	      charsToInsert = this.hiddenTextarea.value.slice(offset, offset + diff);
	    }
	    this.insertChars(charsToInsert);
	    e.stopPropagation();
	  },
	
	  /**
	   * Composition start
	   */
	  onCompositionStart: function() {
	    this.inCompositionMode = true;
	    this.prevCompositionLength = 0;
	    this.compositionStart = this.selectionStart;
	  },
	
	  /**
	   * Composition end
	   */
	  onCompositionEnd: function() {
	    this.inCompositionMode = false;
	  },
	
	  /**
	   * Composition update
	   */
	  onCompositionUpdate: function(e) {
	    var data = e.data;
	    this.selectionStart = this.compositionStart;
	    this.selectionEnd = this.selectionEnd === this.selectionStart ?
	      this.compositionStart + this.prevCompositionLength : this.selectionEnd;
	    this.insertChars(data, false);
	    this.prevCompositionLength = data.length;
	  },
	
	  /**
	   * Forward delete
	   */
	  forwardDelete: function(e) {
	    if (this.selectionStart === this.selectionEnd) {
	      if (this.selectionStart === this.text.length) {
	        return;
	      }
	      this.moveCursorRight(e);
	    }
	    this.removeChars(e);
	  },
	
	  /**
	   * Copies selected text
	   * @param {Event} e Event object
	   */
	  copy: function(e) {
	    if (this.selectionStart === this.selectionEnd) {
	      //do not cut-copy if no selection
	      return;
	    }
	    var selectedText = this.getSelectedText(),
	        clipboardData = this._getClipboardData(e);
	
	    // Check for backward compatibility with old browsers
	    if (clipboardData) {
	      clipboardData.setData('text', selectedText);
	    }
	
	    fabric.copiedText = selectedText;
	    fabric.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd);
	    e.stopImmediatePropagation();
	    e.preventDefault();
	    this._copyDone = true;
	  },
	
	  /**
	   * Pastes text
	   * @param {Event} e Event object
	   */
	  paste: function(e) {
	    var copiedText = null,
	        clipboardData = this._getClipboardData(e),
	        useCopiedStyle = true;
	
	    // Check for backward compatibility with old browsers
	    if (clipboardData) {
	      copiedText = clipboardData.getData('text').replace(/\r/g, '');
	      if (!fabric.copiedTextStyle || fabric.copiedText !== copiedText) {
	        useCopiedStyle = false;
	      }
	    }
	    else {
	      copiedText = fabric.copiedText;
	    }
	
	    if (copiedText) {
	      this.insertChars(copiedText, useCopiedStyle);
	    }
	    e.stopImmediatePropagation();
	    e.preventDefault();
	  },
	
	  /**
	   * Cuts text
	   * @param {Event} e Event object
	   */
	  cut: function(e) {
	    if (this.selectionStart === this.selectionEnd) {
	      return;
	    }
	
	    this.copy(e);
	    this.removeChars(e);
	  },
	
	  /**
	   * @private
	   * @param {Event} e Event object
	   * @return {Object} Clipboard data object
	   */
	  _getClipboardData: function(e) {
	    return (e && e.clipboardData) || fabric.window.clipboardData;
	  },
	
	  /**
	   * Finds the width in pixels before the cursor on the same line
	   * @private
	   * @param {Number} lineIndex
	   * @param {Number} charIndex
	   * @return {Number} widthBeforeCursor width before cursor
	   */
	  _getWidthBeforeCursor: function(lineIndex, charIndex) {
	    var textBeforeCursor = this._textLines[lineIndex].slice(0, charIndex),
	        widthOfLine = this._getLineWidth(this.ctx, lineIndex),
	        widthBeforeCursor = this._getLineLeftOffset(widthOfLine), _char;
	
	    for (var i = 0, len = textBeforeCursor.length; i < len; i++) {
	      _char = textBeforeCursor[i];
	      widthBeforeCursor += this._getWidthOfChar(this.ctx, _char, lineIndex, i);
	    }
	    return widthBeforeCursor;
	  },
	
	  /**
	   * Gets start offset of a selection
	   * @param {Event} e Event object
	   * @param {Boolean} isRight
	   * @return {Number}
	   */
	  getDownCursorOffset: function(e, isRight) {
	    var selectionProp = this._getSelectionForOffset(e, isRight),
	        cursorLocation = this.get2DCursorLocation(selectionProp),
	        lineIndex = cursorLocation.lineIndex;
	    // if on last line, down cursor goes to end of line
	    if (lineIndex === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) {
	      // move to the end of a text
	      return this.text.length - selectionProp;
	    }
	    var charIndex = cursorLocation.charIndex,
	        widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),
	        indexOnOtherLine = this._getIndexOnLine(lineIndex + 1, widthBeforeCursor),
	        textAfterCursor = this._textLines[lineIndex].slice(charIndex);
	
	    return textAfterCursor.length + indexOnOtherLine + 2;
	  },
	
	  /**
	   * private
	   * Helps finding if the offset should be counted from Start or End
	   * @param {Event} e Event object
	   * @param {Boolean} isRight
	   * @return {Number}
	   */
	  _getSelectionForOffset: function(e, isRight) {
	    if (e.shiftKey && this.selectionStart !== this.selectionEnd && isRight) {
	      return this.selectionEnd;
	    }
	    else {
	      return this.selectionStart;
	    }
	  },
	
	  /**
	   * @param {Event} e Event object
	   * @param {Boolean} isRight
	   * @return {Number}
	   */
	  getUpCursorOffset: function(e, isRight) {
	    var selectionProp = this._getSelectionForOffset(e, isRight),
	        cursorLocation = this.get2DCursorLocation(selectionProp),
	        lineIndex = cursorLocation.lineIndex;
	    if (lineIndex === 0 || e.metaKey || e.keyCode === 33) {
	      // if on first line, up cursor goes to start of line
	      return -selectionProp;
	    }
	    var charIndex = cursorLocation.charIndex,
	        widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),
	        indexOnOtherLine = this._getIndexOnLine(lineIndex - 1, widthBeforeCursor),
	        textBeforeCursor = this._textLines[lineIndex].slice(0, charIndex);
	    // return a negative offset
	    return -this._textLines[lineIndex - 1].length + indexOnOtherLine - textBeforeCursor.length;
	  },
	
	  /**
	   * find for a given width it founds the matching character.
	   * @private
	   */
	  _getIndexOnLine: function(lineIndex, width) {
	
	    var widthOfLine = this._getLineWidth(this.ctx, lineIndex),
	        textOnLine = this._textLines[lineIndex],
	        lineLeftOffset = this._getLineLeftOffset(widthOfLine),
	        widthOfCharsOnLine = lineLeftOffset,
	        indexOnLine = 0,
	        foundMatch;
	
	    for (var j = 0, jlen = textOnLine.length; j < jlen; j++) {
	
	      var _char = textOnLine[j],
	          widthOfChar = this._getWidthOfChar(this.ctx, _char, lineIndex, j);
	
	      widthOfCharsOnLine += widthOfChar;
	
	      if (widthOfCharsOnLine > width) {
	
	        foundMatch = true;
	
	        var leftEdge = widthOfCharsOnLine - widthOfChar,
	            rightEdge = widthOfCharsOnLine,
	            offsetFromLeftEdge = Math.abs(leftEdge - width),
	            offsetFromRightEdge = Math.abs(rightEdge - width);
	
	        indexOnLine = offsetFromRightEdge < offsetFromLeftEdge ? j : (j - 1);
	
	        break;
	      }
	    }
	
	    // reached end
	    if (!foundMatch) {
	      indexOnLine = textOnLine.length - 1;
	    }
	
	    return indexOnLine;
	  },
	
	
	  /**
	   * Moves cursor down
	   * @param {Event} e Event object
	   */
	  moveCursorDown: function(e) {
	    if (this.selectionStart >= this.text.length && this.selectionEnd >= this.text.length) {
	      return;
	    }
	    this._moveCursorUpOrDown('Down', e);
	  },
	
	  /**
	   * Moves cursor up
	   * @param {Event} e Event object
	   */
	  moveCursorUp: function(e) {
	    if (this.selectionStart === 0 && this.selectionEnd === 0) {
	      return;
	    }
	    this._moveCursorUpOrDown('Up', e);
	  },
	
	  /**
	   * Moves cursor up or down, fires the events
	   * @param {String} direction 'Up' or 'Down'
	   * @param {Event} e Event object
	   */
	  _moveCursorUpOrDown: function(direction, e) {
	    // getUpCursorOffset
	    // getDownCursorOffset
	    var action = 'get' + direction + 'CursorOffset',
	        offset = this[action](e, this._selectionDirection === 'right');
	    if (e.shiftKey) {
	      this.moveCursorWithShift(offset);
	    }
	    else {
	      this.moveCursorWithoutShift(offset);
	    }
	    if (offset !== 0) {
	      this.setSelectionInBoundaries();
	      this.abortCursorAnimation();
	      this._currentCursorOpacity = 1;
	      this.initDelayedCursor();
	      this._fireSelectionChanged();
	      this._updateTextarea();
	    }
	  },
	
	  /**
	   * Moves cursor with shift
	   * @param {Number} offset
	   */
	  moveCursorWithShift: function(offset) {
	    var newSelection = this._selectionDirection === 'left'
	    ? this.selectionStart + offset
	    : this.selectionEnd + offset;
	    this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, newSelection);
	    return offset !== 0;
	  },
	
	  /**
	   * Moves cursor up without shift
	   * @param {Number} offset
	   */
	  moveCursorWithoutShift: function(offset) {
	    if (offset < 0) {
	      this.selectionStart += offset;
	      this.selectionEnd = this.selectionStart;
	    }
	    else {
	      this.selectionEnd += offset;
	      this.selectionStart = this.selectionEnd;
	    }
	    return offset !== 0;
	  },
	
	  /**
	   * Moves cursor left
	   * @param {Event} e Event object
	   */
	  moveCursorLeft: function(e) {
	    if (this.selectionStart === 0 && this.selectionEnd === 0) {
	      return;
	    }
	    this._moveCursorLeftOrRight('Left', e);
	  },
	
	  /**
	   * @private
	   * @return {Boolean} true if a change happened
	   */
	  _move: function(e, prop, direction) {
	    var newValue;
	    if (e.altKey) {
	      newValue = this['findWordBoundary' + direction](this[prop]);
	    }
	    else if (e.metaKey || e.keyCode === 35 ||  e.keyCode === 36 ) {
	      newValue = this['findLineBoundary' + direction](this[prop]);
	    }
	    else {
	      this[prop] += direction === 'Left' ? -1 : 1;
	      return true;
	    }
	    if (typeof newValue !== undefined && this[prop] !== newValue) {
	      this[prop] = newValue;
	      return true;
	    }
	  },
	
	  /**
	   * @private
	   */
	  _moveLeft: function(e, prop) {
	    return this._move(e, prop, 'Left');
	  },
	
	  /**
	   * @private
	   */
	  _moveRight: function(e, prop) {
	    return this._move(e, prop, 'Right');
	  },
	
	  /**
	   * Moves cursor left without keeping selection
	   * @param {Event} e
	   */
	  moveCursorLeftWithoutShift: function(e) {
	    var change = true;
	    this._selectionDirection = 'left';
	
	    // only move cursor when there is no selection,
	    // otherwise we discard it, and leave cursor on same place
	    if (this.selectionEnd === this.selectionStart && this.selectionStart !== 0) {
	      change = this._moveLeft(e, 'selectionStart');
	
	    }
	    this.selectionEnd = this.selectionStart;
	    return change;
	  },
	
	  /**
	   * Moves cursor left while keeping selection
	   * @param {Event} e
	   */
	  moveCursorLeftWithShift: function(e) {
	    if (this._selectionDirection === 'right' && this.selectionStart !== this.selectionEnd) {
	      return this._moveLeft(e, 'selectionEnd');
	    }
	    else if (this.selectionStart !== 0){
	      this._selectionDirection = 'left';
	      return this._moveLeft(e, 'selectionStart');
	    }
	  },
	
	  /**
	   * Moves cursor right
	   * @param {Event} e Event object
	   */
	  moveCursorRight: function(e) {
	    if (this.selectionStart >= this.text.length && this.selectionEnd >= this.text.length) {
	      return;
	    }
	    this._moveCursorLeftOrRight('Right', e);
	  },
	
	  /**
	   * Moves cursor right or Left, fires event
	   * @param {String} direction 'Left', 'Right'
	   * @param {Event} e Event object
	   */
	  _moveCursorLeftOrRight: function(direction, e) {
	    var actionName = 'moveCursor' + direction + 'With';
	    this._currentCursorOpacity = 1;
	
	    if (e.shiftKey) {
	      actionName += 'Shift';
	    }
	    else {
	      actionName += 'outShift';
	    }
	    if (this[actionName](e)) {
	      this.abortCursorAnimation();
	      this.initDelayedCursor();
	      this._fireSelectionChanged();
	      this._updateTextarea();
	    }
	  },
	
	  /**
	   * Moves cursor right while keeping selection
	   * @param {Event} e
	   */
	  moveCursorRightWithShift: function(e) {
	    if (this._selectionDirection === 'left' && this.selectionStart !== this.selectionEnd) {
	      return this._moveRight(e, 'selectionStart');
	    }
	    else if (this.selectionEnd !== this.text.length) {
	      this._selectionDirection = 'right';
	      return this._moveRight(e, 'selectionEnd');
	    }
	  },
	
	  /**
	   * Moves cursor right without keeping selection
	   * @param {Event} e Event object
	   */
	  moveCursorRightWithoutShift: function(e) {
	    var changed = true;
	    this._selectionDirection = 'right';
	
	    if (this.selectionStart === this.selectionEnd) {
	      changed = this._moveRight(e, 'selectionStart');
	      this.selectionEnd = this.selectionStart;
	    }
	    else {
	      this.selectionStart = this.selectionEnd;
	    }
	    return changed;
	  },
	
	  /**
	   * Removes characters selected by selection
	   * @param {Event} e Event object
	   */
	  removeChars: function(e) {
	    if (this.selectionStart === this.selectionEnd) {
	      this._removeCharsNearCursor(e);
	    }
	    else {
	      this._removeCharsFromTo(this.selectionStart, this.selectionEnd);
	    }
	
	    this.set('dirty', true);
	    this.setSelectionEnd(this.selectionStart);
	
	    this._removeExtraneousStyles();
	
	    this.canvas && this.canvas.renderAll();
	
	    this.setCoords();
	    this.fire('changed');
	    this.canvas && this.canvas.fire('text:changed', { target: this });
	  },
	
	  /**
	   * @private
	   * @param {Event} e Event object
	   */
	  _removeCharsNearCursor: function(e) {
	    if (this.selectionStart === 0) {
	      return;
	    }
	    if (e.metaKey) {
	      // remove all till the start of current line
	      var leftLineBoundary = this.findLineBoundaryLeft(this.selectionStart);
	
	      this._removeCharsFromTo(leftLineBoundary, this.selectionStart);
	      this.setSelectionStart(leftLineBoundary);
	    }
	    else if (e.altKey) {
	      // remove all till the start of current word
	      var leftWordBoundary = this.findWordBoundaryLeft(this.selectionStart);
	
	      this._removeCharsFromTo(leftWordBoundary, this.selectionStart);
	      this.setSelectionStart(leftWordBoundary);
	    }
	    else {
	      this._removeSingleCharAndStyle(this.selectionStart);
	      this.setSelectionStart(this.selectionStart - 1);
	    }
	  }
	});
	
	
	/* _TO_SVG_START_ */
	(function() {
	  var toFixed = fabric.util.toFixed,
	      NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
	
	  fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {
	
	    /**
	     * @private
	     */
	    _setSVGTextLineText: function(lineIndex, textSpans, height, textLeftOffset, textTopOffset, textBgRects) {
	      if (!this._getLineStyle(lineIndex)) {
	        fabric.Text.prototype._setSVGTextLineText.call(this,
	          lineIndex, textSpans, height, textLeftOffset, textTopOffset);
	      }
	      else {
	        this._setSVGTextLineChars(
	          lineIndex, textSpans, height, textLeftOffset, textBgRects);
	      }
	    },
	
	    /**
	     * @private
	     */
	    _setSVGTextLineChars: function(lineIndex, textSpans, height, textLeftOffset, textBgRects) {
	
	      var chars = this._textLines[lineIndex],
	          charOffset = 0,
	          lineLeftOffset = this._getLineLeftOffset(this._getLineWidth(this.ctx, lineIndex)) - this.width / 2,
	          lineOffset = this._getSVGLineTopOffset(lineIndex),
	          heightOfLine = this._getHeightOfLine(this.ctx, lineIndex);
	
	      for (var i = 0, len = chars.length; i < len; i++) {
	        var styleDecl = this._getStyleDeclaration(lineIndex, i) || { };
	
	        textSpans.push(
	          this._createTextCharSpan(
	            chars[i], styleDecl, lineLeftOffset, lineOffset.lineTop + lineOffset.offset, charOffset));
	
	        var charWidth = this._getWidthOfChar(this.ctx, chars[i], lineIndex, i);
	
	        if (styleDecl.textBackgroundColor) {
	          textBgRects.push(
	            this._createTextCharBg(
	              styleDecl, lineLeftOffset, lineOffset.lineTop, heightOfLine, charWidth, charOffset));
	        }
	
	        charOffset += charWidth;
	      }
	    },
	
	    /**
	     * @private
	     */
	    _getSVGLineTopOffset: function(lineIndex) {
	      var lineTopOffset = 0, lastHeight = 0;
	      for (var j = 0; j < lineIndex; j++) {
	        lineTopOffset += this._getHeightOfLine(this.ctx, j);
	      }
	      lastHeight = this._getHeightOfLine(this.ctx, j);
	      return {
	        lineTop: lineTopOffset,
	        offset: (this._fontSizeMult - this._fontSizeFraction) * lastHeight / (this.lineHeight * this._fontSizeMult)
	      };
	    },
	
	    /**
	     * @private
	     */
	    _createTextCharBg: function(styleDecl, lineLeftOffset, lineTopOffset, heightOfLine, charWidth, charOffset) {
	      return [
	        '\t\t<rect fill="', styleDecl.textBackgroundColor,
	        '" x="', toFixed(lineLeftOffset + charOffset, NUM_FRACTION_DIGITS),
	        '" y="', toFixed(lineTopOffset - this.height / 2, NUM_FRACTION_DIGITS),
	        '" width="', toFixed(charWidth, NUM_FRACTION_DIGITS),
	        '" height="', toFixed(heightOfLine / this.lineHeight, NUM_FRACTION_DIGITS),
	        '"></rect>\n'
	      ].join('');
	    },
	
	    /**
	     * @private
	     */
	    _createTextCharSpan: function(_char, styleDecl, lineLeftOffset, lineTopOffset, charOffset) {
	
	      var fillStyles = this.getSvgStyles.call(fabric.util.object.extend({
	        visible: true,
	        fill: this.fill,
	        stroke: this.stroke,
	        type: 'text',
	        getSvgFilter: fabric.Object.prototype.getSvgFilter
	      }, styleDecl));
	
	      return [
	        '\t\t\t<tspan x="', toFixed(lineLeftOffset + charOffset, NUM_FRACTION_DIGITS), '" y="',
	        toFixed(lineTopOffset - this.height / 2, NUM_FRACTION_DIGITS), '" ',
	          (styleDecl.fontFamily ? 'font-family="' + styleDecl.fontFamily.replace(/"/g, '\'') + '" ' : ''),
	          (styleDecl.fontSize ? 'font-size="' + styleDecl.fontSize + '" ' : ''),
	          (styleDecl.fontStyle ? 'font-style="' + styleDecl.fontStyle + '" ' : ''),
	          (styleDecl.fontWeight ? 'font-weight="' + styleDecl.fontWeight + '" ' : ''),
	          (styleDecl.textDecoration ? 'text-decoration="' + styleDecl.textDecoration + '" ' : ''),
	        'style="', fillStyles, '">',
	        fabric.util.string.escapeXml(_char),
	        '</tspan>\n'
	      ].join('');
	    }
	  });
	})();
	/* _TO_SVG_END_ */
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = {});
	
	  /**
	   * Textbox class, based on IText, allows the user to resize the text rectangle
	   * and wraps lines automatically. Textboxes have their Y scaling locked, the
	   * user can only change width. Height is adjusted automatically based on the
	   * wrapping of lines.
	   * @class fabric.Textbox
	   * @extends fabric.IText
	   * @mixes fabric.Observable
	   * @return {fabric.Textbox} thisArg
	   * @see {@link fabric.Textbox#initialize} for constructor definition
	   */
	  fabric.Textbox = fabric.util.createClass(fabric.IText, fabric.Observable, {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'textbox',
	
	    /**
	     * Minimum width of textbox, in pixels.
	     * @type Number
	     * @default
	     */
	    minWidth: 20,
	
	    /**
	     * Minimum calculated width of a textbox, in pixels.
	     * fixed to 2 so that an empty textbox cannot go to 0
	     * and is still selectable without text.
	     * @type Number
	     * @default
	     */
	    dynamicMinWidth: 2,
	
	    /**
	     * Cached array of text wrapping.
	     * @type Array
	     */
	    __cachedLines: null,
	
	    /**
	     * Override standard Object class values
	     */
	    lockScalingY: true,
	
	    /**
	     * Override standard Object class values
	     */
	    lockScalingFlip: true,
	
	    /**
	     * Override standard Object class values
	     * Textbox needs this on false
	     */
	    noScaleCache: false,
	
	    /**
	     * Constructor. Some scaling related property values are forced. Visibility
	     * of controls is also fixed; only the rotation and width controls are
	     * made available.
	     * @param {String} text Text string
	     * @param {Object} [options] Options object
	     * @return {fabric.Textbox} thisArg
	     */
	    initialize: function(text, options) {
	
	      this.callSuper('initialize', text, options);
	      this.setControlsVisibility(fabric.Textbox.getTextboxControlVisibility());
	      this.ctx = this.objectCaching ? this._cacheContext : fabric.util.createCanvasElement().getContext('2d');
	      // add width to this list of props that effect line wrapping.
	      this._dimensionAffectingProps.push('width');
	    },
	
	    /**
	     * Unlike superclass's version of this function, Textbox does not update
	     * its width.
	     * @param {CanvasRenderingContext2D} ctx Context to use for measurements
	     * @private
	     * @override
	     */
	    _initDimensions: function(ctx) {
	      if (this.__skipDimension) {
	        return;
	      }
	
	      if (!ctx) {
	        ctx = fabric.util.createCanvasElement().getContext('2d');
	        this._setTextStyles(ctx);
	        this.clearContextTop();
	      }
	
	      // clear dynamicMinWidth as it will be different after we re-wrap line
	      this.dynamicMinWidth = 0;
	
	      // wrap lines
	      this._textLines = this._splitTextIntoLines(ctx);
	      // if after wrapping, the width is smaller than dynamicMinWidth, change the width and re-wrap
	      if (this.dynamicMinWidth > this.width) {
	        this._set('width', this.dynamicMinWidth);
	      }
	
	      // clear cache and re-calculate height
	      this._clearCache();
	      this.height = this._getTextHeight(ctx);
	    },
	
	    /**
	     * Generate an object that translates the style object so that it is
	     * broken up by visual lines (new lines and automatic wrapping).
	     * The original text styles object is broken up by actual lines (new lines only),
	     * which is only sufficient for Text / IText
	     * @private
	     */
	    _generateStyleMap: function() {
	      var realLineCount     = 0,
	          realLineCharCount = 0,
	          charCount         = 0,
	          map               = {};
	
	      for (var i = 0; i < this._textLines.length; i++) {
	        if (this.text[charCount] === '\n' && i > 0) {
	          realLineCharCount = 0;
	          charCount++;
	          realLineCount++;
	        }
	        else if (this.text[charCount] === ' ' && i > 0) {
	          // this case deals with space's that are removed from end of lines when wrapping
	          realLineCharCount++;
	          charCount++;
	        }
	
	        map[i] = { line: realLineCount, offset: realLineCharCount };
	
	        charCount += this._textLines[i].length;
	        realLineCharCount += this._textLines[i].length;
	      }
	
	      return map;
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @param {Number} charIndex
	     * @param {Boolean} [returnCloneOrEmpty=false]
	     * @private
	     */
	    _getStyleDeclaration: function(lineIndex, charIndex, returnCloneOrEmpty) {
	      if (this._styleMap) {
	        var map = this._styleMap[lineIndex];
	        if (!map) {
	          return returnCloneOrEmpty ? { } : null;
	        }
	        lineIndex = map.line;
	        charIndex = map.offset + charIndex;
	      }
	      return this.callSuper('_getStyleDeclaration', lineIndex, charIndex, returnCloneOrEmpty);
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @param {Number} charIndex
	     * @param {Object} style
	     * @private
	     */
	    _setStyleDeclaration: function(lineIndex, charIndex, style) {
	      var map = this._styleMap[lineIndex];
	      lineIndex = map.line;
	      charIndex = map.offset + charIndex;
	
	      this.styles[lineIndex][charIndex] = style;
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @param {Number} charIndex
	     * @private
	     */
	    _deleteStyleDeclaration: function(lineIndex, charIndex) {
	      var map = this._styleMap[lineIndex];
	      lineIndex = map.line;
	      charIndex = map.offset + charIndex;
	
	      delete this.styles[lineIndex][charIndex];
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @private
	     */
	    _getLineStyle: function(lineIndex) {
	      var map = this._styleMap[lineIndex];
	      return this.styles[map.line];
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @param {Object} style
	     * @private
	     */
	    _setLineStyle: function(lineIndex, style) {
	      var map = this._styleMap[lineIndex];
	      this.styles[map.line] = style;
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @private
	     */
	    _deleteLineStyle: function(lineIndex) {
	      var map = this._styleMap[lineIndex];
	      delete this.styles[map.line];
	    },
	
	    /**
	     * Wraps text using the 'width' property of Textbox. First this function
	     * splits text on newlines, so we preserve newlines entered by the user.
	     * Then it wraps each line using the width of the Textbox by calling
	     * _wrapLine().
	     * @param {CanvasRenderingContext2D} ctx Context to use for measurements
	     * @param {String} text The string of text that is split into lines
	     * @returns {Array} Array of lines
	     */
	    _wrapText: function(ctx, text) {
	      var lines = text.split(this._reNewline), wrapped = [], i;
	
	      for (i = 0; i < lines.length; i++) {
	        wrapped = wrapped.concat(this._wrapLine(ctx, lines[i], i));
	      }
	
	      return wrapped;
	    },
	
	    /**
	     * Helper function to measure a string of text, given its lineIndex and charIndex offset
	     *
	     * @param {CanvasRenderingContext2D} ctx
	     * @param {String} text
	     * @param {number} lineIndex
	     * @param {number} charOffset
	     * @returns {number}
	     * @private
	     */
	    _measureText: function(ctx, text, lineIndex, charOffset) {
	      var width = 0;
	      charOffset = charOffset || 0;
	      for (var i = 0, len = text.length; i < len; i++) {
	        width += this._getWidthOfChar(ctx, text[i], lineIndex, i + charOffset);
	      }
	      return width;
	    },
	
	    /**
	     * Wraps a line of text using the width of the Textbox and a context.
	     * @param {CanvasRenderingContext2D} ctx Context to use for measurements
	     * @param {String} text The string of text to split into lines
	     * @param {Number} lineIndex
	     * @returns {Array} Array of line(s) into which the given text is wrapped
	     * to.
	     */
	    _wrapLine: function(ctx, text, lineIndex) {
	      var lineWidth        = 0,
	          lines            = [],
	          line             = '',
	          words            = text.split(' '),
	          word             = '',
	          offset           = 0,
	          infix            = ' ',
	          wordWidth        = 0,
	          infixWidth       = 0,
	          largestWordWidth = 0,
	          lineJustStarted = true,
	          additionalSpace = this._getWidthOfCharSpacing();
	
	      for (var i = 0; i < words.length; i++) {
	        word = words[i];
	        wordWidth = this._measureText(ctx, word, lineIndex, offset);
	
	        offset += word.length;
	
	        lineWidth += infixWidth + wordWidth - additionalSpace;
	
	        if (lineWidth >= this.width && !lineJustStarted) {
	          lines.push(line);
	          line = '';
	          lineWidth = wordWidth;
	          lineJustStarted = true;
	        }
	        else {
	          lineWidth += additionalSpace;
	        }
	
	        if (!lineJustStarted) {
	          line += infix;
	        }
	        line += word;
	
	        infixWidth = this._measureText(ctx, infix, lineIndex, offset);
	        offset++;
	        lineJustStarted = false;
	        // keep track of largest word
	        if (wordWidth > largestWordWidth) {
	          largestWordWidth = wordWidth;
	        }
	      }
	
	      i && lines.push(line);
	
	      if (largestWordWidth > this.dynamicMinWidth) {
	        this.dynamicMinWidth = largestWordWidth - additionalSpace;
	      }
	
	      return lines;
	    },
	    /**
	     * Gets lines of text to render in the Textbox. This function calculates
	     * text wrapping on the fly everytime it is called.
	     * @returns {Array} Array of lines in the Textbox.
	     * @override
	     */
	    _splitTextIntoLines: function(ctx) {
	      ctx = ctx || this.ctx;
	      var originalAlign = this.textAlign;
	      this._styleMap = null;
	      ctx.save();
	      this._setTextStyles(ctx);
	      this.textAlign = 'left';
	      var lines = this._wrapText(ctx, this.text);
	      this.textAlign = originalAlign;
	      ctx.restore();
	      this._textLines = lines;
	      this._styleMap = this._generateStyleMap();
	      return lines;
	    },
	
	    /**
	     * When part of a group, we don't want the Textbox's scale to increase if
	     * the group's increases. That's why we reduce the scale of the Textbox by
	     * the amount that the group's increases. This is to maintain the effective
	     * scale of the Textbox at 1, so that font-size values make sense. Otherwise
	     * the same font-size value would result in different actual size depending
	     * on the value of the scale.
	     * @param {String} key
	     * @param {*} value
	     */
	    setOnGroup: function(key, value) {
	      if (key === 'scaleX') {
	        this.set('scaleX', Math.abs(1 / value));
	        this.set('width', (this.get('width') * value) /
	          (typeof this.__oldScaleX === 'undefined' ? 1 : this.__oldScaleX));
	        this.__oldScaleX = value;
	      }
	    },
	
	    /**
	     * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start).
	     * Overrides the superclass function to take into account text wrapping.
	     *
	     * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.
	     */
	    get2DCursorLocation: function(selectionStart) {
	      if (typeof selectionStart === 'undefined') {
	        selectionStart = this.selectionStart;
	      }
	
	      var numLines = this._textLines.length,
	          removed  = 0;
	
	      for (var i = 0; i < numLines; i++) {
	        var line    = this._textLines[i],
	            lineLen = line.length;
	
	        if (selectionStart <= removed + lineLen) {
	          return {
	            lineIndex: i,
	            charIndex: selectionStart - removed
	          };
	        }
	
	        removed += lineLen;
	
	        if (this.text[removed] === '\n' || this.text[removed] === ' ') {
	          removed++;
	        }
	      }
	
	      return {
	        lineIndex: numLines - 1,
	        charIndex: this._textLines[numLines - 1].length
	      };
	    },
	
	    /**
	     * Overrides superclass function and uses text wrapping data to get cursor
	     * boundary offsets instead of the array of chars.
	     * @param {Array} chars Unused
	     * @param {String} typeOfBoundaries Can be 'cursor' or 'selection'
	     * @returns {Object} Object with 'top', 'left', and 'lineLeft' properties set.
	     */
	    _getCursorBoundariesOffsets: function(chars, typeOfBoundaries) {
	      var topOffset      = 0,
	          leftOffset     = 0,
	          cursorLocation = this.get2DCursorLocation(),
	          lineChars      = this._textLines[cursorLocation.lineIndex].split(''),
	          lineLeftOffset = this._getLineLeftOffset(this._getLineWidth(this.ctx, cursorLocation.lineIndex));
	
	      for (var i = 0; i < cursorLocation.charIndex; i++) {
	        leftOffset += this._getWidthOfChar(this.ctx, lineChars[i], cursorLocation.lineIndex, i);
	      }
	
	      for (i = 0; i < cursorLocation.lineIndex; i++) {
	        topOffset += this._getHeightOfLine(this.ctx, i);
	      }
	
	      if (typeOfBoundaries === 'cursor') {
	        topOffset += (1 - this._fontSizeFraction) * this._getHeightOfLine(this.ctx, cursorLocation.lineIndex)
	          / this.lineHeight - this.getCurrentCharFontSize(cursorLocation.lineIndex, cursorLocation.charIndex)
	          * (1 - this._fontSizeFraction);
	      }
	
	      return {
	        top: topOffset,
	        left: leftOffset,
	        lineLeft: lineLeftOffset
	      };
	    },
	
	    getMinWidth: function() {
	      return Math.max(this.minWidth, this.dynamicMinWidth);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @method toObject
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      return this.callSuper('toObject', ['minWidth'].concat(propertiesToInclude));
	    }
	  });
	
	  /**
	   * Returns fabric.Textbox instance from an object representation
	   * @static
	   * @memberOf fabric.Textbox
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] Callback to invoke when an fabric.Textbox instance is created
	   * @param {Boolean} [forceAsync] Force an async behaviour trying to create pattern first
	   * @return {fabric.Textbox} instance of fabric.Textbox
	   */
	  fabric.Textbox.fromObject = function(object, callback, forceAsync) {
	    return fabric.Object._fromObject('Textbox', object, callback, forceAsync, 'text');
	  };
	
	  /**
	   * Returns the default controls visibility required for Textboxes.
	   * @returns {Object}
	   */
	  fabric.Textbox.getTextboxControlVisibility = function() {
	    return {
	      tl: false,
	      tr: false,
	      br: false,
	      bl: false,
	      ml: true,
	      mt: false,
	      mr: true,
	      mb: false,
	      mtr: true
	    };
	  };
	
	})( true ? exports : this);
	
	
	(function() {
	
	  /**
	   * Override _setObjectScale and add Textbox specific resizing behavior. Resizing
	   * a Textbox doesn't scale text, it only changes width and makes text wrap automatically.
	   */
	  var setObjectScaleOverridden = fabric.Canvas.prototype._setObjectScale;
	
	  fabric.Canvas.prototype._setObjectScale = function(localMouse, transform,
	                                                     lockScalingX, lockScalingY, by, lockScalingFlip, _dim) {
	
	    var t = transform.target;
	    if (t instanceof fabric.Textbox) {
	      var w = t.width * ((localMouse.x / transform.scaleX) / (t.width + t.strokeWidth));
	      if (w >= t.getMinWidth()) {
	        t.set('width', w);
	        return true;
	      }
	    }
	    else {
	      return setObjectScaleOverridden.call(fabric.Canvas.prototype, localMouse, transform,
	        lockScalingX, lockScalingY, by, lockScalingFlip, _dim);
	    }
	  };
	
	  /**
	   * Sets controls of this group to the Textbox's special configuration if
	   * one is present in the group. Deletes _controlsVisibility otherwise, so that
	   * it gets initialized to default value at runtime.
	   */
	  fabric.Group.prototype._refreshControlsVisibility = function() {
	    if (typeof fabric.Textbox === 'undefined') {
	      return;
	    }
	    for (var i = this._objects.length; i--;) {
	      if (this._objects[i] instanceof fabric.Textbox) {
	        this.setControlsVisibility(fabric.Textbox.getTextboxControlVisibility());
	        return;
	      }
	    }
	  };
	
	  var clone = fabric.util.object.clone;
	
	  fabric.util.object.extend(fabric.Textbox.prototype, /** @lends fabric.IText.prototype */ {
	    /**
	     * @private
	     */
	    _removeExtraneousStyles: function() {
	      for (var prop in this._styleMap) {
	        if (!this._textLines[prop]) {
	          delete this.styles[this._styleMap[prop].line];
	        }
	      }
	    },
	
	    /**
	     * Inserts style object for a given line/char index
	     * @param {Number} lineIndex Index of a line
	     * @param {Number} charIndex Index of a char
	     * @param {Object} [style] Style object to insert, if given
	     */
	    insertCharStyleObject: function(lineIndex, charIndex, style) {
	      // adjust lineIndex and charIndex
	      var map = this._styleMap[lineIndex];
	      lineIndex = map.line;
	      charIndex = map.offset + charIndex;
	
	      fabric.IText.prototype.insertCharStyleObject.apply(this, [lineIndex, charIndex, style]);
	    },
	
	    /**
	     * Inserts new style object
	     * @param {Number} lineIndex Index of a line
	     * @param {Number} charIndex Index of a char
	     * @param {Boolean} isEndOfLine True if it's end of line
	     */
	    insertNewlineStyleObject: function(lineIndex, charIndex, isEndOfLine) {
	      // adjust lineIndex and charIndex
	      var map = this._styleMap[lineIndex];
	      lineIndex = map.line;
	      charIndex = map.offset + charIndex;
	
	      fabric.IText.prototype.insertNewlineStyleObject.apply(this, [lineIndex, charIndex, isEndOfLine]);
	    },
	
	    /**
	     * Shifts line styles up or down. This function is slightly different than the one in
	     * itext_behaviour as it takes into account the styleMap.
	     *
	     * @param {Number} lineIndex Index of a line
	     * @param {Number} offset Can be -1 or +1
	     */
	    shiftLineStyles: function(lineIndex, offset) {
	      // shift all line styles by 1 upward
	      var clonedStyles = clone(this.styles),
	          map          = this._styleMap[lineIndex];
	
	      // adjust line index
	      lineIndex = map.line;
	
	      for (var line in this.styles) {
	        var numericLine = parseInt(line, 10);
	
	        if (numericLine > lineIndex) {
	          this.styles[numericLine + offset] = clonedStyles[numericLine];
	
	          if (!clonedStyles[numericLine - offset]) {
	            delete this.styles[numericLine];
	          }
	        }
	      }
	      //TODO: evaluate if delete old style lines with offset -1
	    },
	
	    /**
	     * Figure out programatically the text on previous actual line (actual = separated by \n);
	     *
	     * @param {Number} lIndex
	     * @returns {String}
	     * @private
	     */
	    _getTextOnPreviousLine: function(lIndex) {
	      var textOnPreviousLine = this._textLines[lIndex - 1];
	
	      while (this._styleMap[lIndex - 2] && this._styleMap[lIndex - 2].line === this._styleMap[lIndex - 1].line) {
	        textOnPreviousLine = this._textLines[lIndex - 2] + textOnPreviousLine;
	
	        lIndex--;
	      }
	
	      return textOnPreviousLine;
	    },
	
	    /**
	     * Removes style object
	     * @param {Boolean} isBeginningOfLine True if cursor is at the beginning of line
	     * @param {Number} [index] Optional index. When not given, current selectionStart is used.
	     */
	    removeStyleObject: function(isBeginningOfLine, index) {
	
	      var cursorLocation = this.get2DCursorLocation(index),
	          map            = this._styleMap[cursorLocation.lineIndex],
	          lineIndex      = map.line,
	          charIndex      = map.offset + cursorLocation.charIndex;
	      this._removeStyleObject(isBeginningOfLine, cursorLocation, lineIndex, charIndex);
	    }
	  });
	})();
	
	
	(function() {
	  var override = fabric.IText.prototype._getNewSelectionStartFromOffset;
	  /**
	   * Overrides the IText implementation and adjusts character index as there is not always a linebreak
	   *
	   * @param {Number} mouseOffset
	   * @param {Number} prevWidth
	   * @param {Number} width
	   * @param {Number} index
	   * @param {Number} jlen
	   * @returns {Number}
	   */
	  fabric.IText.prototype._getNewSelectionStartFromOffset = function(mouseOffset, prevWidth, width, index, jlen) {
	    index = override.call(this, mouseOffset, prevWidth, width, index, jlen);
	
	    // the index passed into the function is padded by the amount of lines from _textLines (to account for \n)
	    // we need to remove this padding, and pad it by actual lines, and / or spaces that are meant to be there
	    var tmp     = 0,
	        removed = 0;
	
	    // account for removed characters
	    for (var i = 0; i < this._textLines.length; i++) {
	      tmp += this._textLines[i].length;
	
	      if (tmp + removed >= index) {
	        break;
	      }
	
	      if (this.text[tmp + removed] === '\n' || this.text[tmp + removed] === ' ') {
	        removed++;
	      }
	    }
	
	    return index - i + removed;
	  };
	})();
	
	
	(function() {
	
	  if (typeof document !== 'undefined' && typeof window !== 'undefined') {
	    return;
	  }
	
	  var DOMParser = __webpack_require__(11).DOMParser,
	      URL = __webpack_require__(12),
	      HTTP = __webpack_require__(19),
	      HTTPS = __webpack_require__(48),
	
	      Canvas = __webpack_require__(10),
	      Image = __webpack_require__(10).Image;
	
	  /** @private */
	  function request(url, encoding, callback) {
	    var oURL = URL.parse(url);
	
	    // detect if http or https is used
	    if ( !oURL.port ) {
	      oURL.port = ( oURL.protocol.indexOf('https:') === 0 ) ? 443 : 80;
	    }
	
	    // assign request handler based on protocol
	    var reqHandler = (oURL.protocol.indexOf('https:') === 0 ) ? HTTPS : HTTP,
	        req = reqHandler.request({
	          hostname: oURL.hostname,
	          port: oURL.port,
	          path: oURL.path,
	          method: 'GET'
	        }, function(response) {
	          var body = '';
	          if (encoding) {
	            response.setEncoding(encoding);
	          }
	          response.on('end', function () {
	            callback(body);
	          });
	          response.on('data', function (chunk) {
	            if (response.statusCode === 200) {
	              body += chunk;
	            }
	          });
	        });
	
	    req.on('error', function(err) {
	      if (err.errno === process.ECONNREFUSED) {
	        fabric.log('ECONNREFUSED: connection refused to ' + oURL.hostname + ':' + oURL.port);
	      }
	      else {
	        fabric.log(err.message);
	      }
	      callback(null);
	    });
	
	    req.end();
	  }
	
	  /** @private */
	  function requestFs(path, callback) {
	    var fs = __webpack_require__(49);
	    fs.readFile(path, function (err, data) {
	      if (err) {
	        fabric.log(err);
	        throw err;
	      }
	      else {
	        callback(data);
	      }
	    });
	  }
	
	  fabric.util.loadImage = function(url, callback, context) {
	    function createImageAndCallBack(data) {
	      if (data) {
	        img.src = new Buffer(data, 'binary');
	        // preserving original url, which seems to be lost in node-canvas
	        img._src = url;
	        callback && callback.call(context, img);
	      }
	      else {
	        img = null;
	        callback && callback.call(context, null, true);
	      }
	    }
	    var img = new Image();
	    if (url && (url instanceof Buffer || url.indexOf('data') === 0)) {
	      img.src = img._src = url;
	      callback && callback.call(context, img);
	    }
	    else if (url && url.indexOf('http') !== 0) {
	      requestFs(url, createImageAndCallBack);
	    }
	    else if (url) {
	      request(url, 'binary', createImageAndCallBack);
	    }
	    else {
	      callback && callback.call(context, url);
	    }
	  };
	
	  fabric.loadSVGFromURL = function(url, callback, reviver) {
	    url = url.replace(/^\n\s*/, '').replace(/\?.*$/, '').trim();
	    if (url.indexOf('http') !== 0) {
	      requestFs(url, function(body) {
	        fabric.loadSVGFromString(body.toString(), callback, reviver);
	      });
	    }
	    else {
	      request(url, '', function(body) {
	        fabric.loadSVGFromString(body, callback, reviver);
	      });
	    }
	  };
	
	  fabric.loadSVGFromString = function(string, callback, reviver) {
	    var doc = new DOMParser().parseFromString(string);
	    fabric.parseSVGDocument(doc.documentElement, function(results, options) {
	      callback && callback(results, options);
	    }, reviver);
	  };
	
	  fabric.util.getScript = function(url, callback) {
	    request(url, '', function(body) {
	      // eslint-disable-next-line no-eval
	      eval(body);
	      callback && callback();
	    });
	  };
	
	  // fabric.util.createCanvasElement = function(_, width, height) {
	  //   return new Canvas(width, height);
	  // }
	
	  /**
	   * Only available when running fabric on node.js
	   * @param {Number} width Canvas width
	   * @param {Number} height Canvas height
	   * @param {Object} [options] Options to pass to FabricCanvas.
	   * @param {Object} [nodeCanvasOptions] Options to pass to NodeCanvas.
	   * @return {Object} wrapped canvas instance
	   */
	  fabric.createCanvasForNode = function(width, height, options, nodeCanvasOptions) {
	    nodeCanvasOptions = nodeCanvasOptions || options;
	
	    var canvasEl = fabric.document.createElement('canvas'),
	        nodeCanvas = new Canvas(width || 600, height || 600, nodeCanvasOptions),
	        nodeCacheCanvas = new Canvas(width || 600, height || 600, nodeCanvasOptions);
	
	    // jsdom doesn't create style on canvas element, so here be temp. workaround
	    canvasEl.style = { };
	
	    canvasEl.width = nodeCanvas.width;
	    canvasEl.height = nodeCanvas.height;
	    options = options || { };
	    options.nodeCanvas = nodeCanvas;
	    options.nodeCacheCanvas = nodeCacheCanvas;
	    var FabricCanvas = fabric.Canvas || fabric.StaticCanvas,
	        fabricCanvas = new FabricCanvas(canvasEl, options);
	    fabricCanvas.nodeCanvas = nodeCanvas;
	    fabricCanvas.nodeCacheCanvas = nodeCacheCanvas;
	    fabricCanvas.contextContainer = nodeCanvas.getContext('2d');
	    fabricCanvas.contextCache = nodeCacheCanvas.getContext('2d');
	    fabricCanvas.Font = Canvas.Font;
	    return fabricCanvas;
	  };
	
	  var originaInitStatic = fabric.StaticCanvas.prototype._initStatic;
	  fabric.StaticCanvas.prototype._initStatic = function(el, options) {
	    el = el || fabric.document.createElement('canvas');
	    this.nodeCanvas = new Canvas(el.width, el.height);
	    this.nodeCacheCanvas = new Canvas(el.width, el.height);
	    originaInitStatic.call(this, el, options);
	    this.contextContainer = this.nodeCanvas.getContext('2d');
	    this.contextCache = this.nodeCacheCanvas.getContext('2d');
	    this.Font = Canvas.Font;
	  };
	
	  /** @ignore */
	  fabric.StaticCanvas.prototype.createPNGStream = function() {
	    return this.nodeCanvas.createPNGStream();
	  };
	
	  fabric.StaticCanvas.prototype.createJPEGStream = function(opts) {
	    return this.nodeCanvas.createJPEGStream(opts);
	  };
	
	  fabric.StaticCanvas.prototype._initRetinaScaling = function() {
	    if (!this._isRetinaScaling()) {
	      return;
	    }
	
	    this.lowerCanvasEl.setAttribute('width', this.width * fabric.devicePixelRatio);
	    this.lowerCanvasEl.setAttribute('height', this.height * fabric.devicePixelRatio);
	    this.nodeCanvas.width = this.width * fabric.devicePixelRatio;
	    this.nodeCanvas.height = this.height * fabric.devicePixelRatio;
	    this.contextContainer.scale(fabric.devicePixelRatio, fabric.devicePixelRatio);
	    return this;
	  };
	  if (fabric.Canvas) {
	    fabric.Canvas.prototype._initRetinaScaling = fabric.StaticCanvas.prototype._initRetinaScaling;
	  }
	
	  var origSetBackstoreDimension = fabric.StaticCanvas.prototype._setBackstoreDimension;
	  fabric.StaticCanvas.prototype._setBackstoreDimension = function(prop, value) {
	    origSetBackstoreDimension.call(this, prop, value);
	    this.nodeCanvas[prop] = value;
	    return this;
	  };
	  if (fabric.Canvas) {
	    fabric.Canvas.prototype._setBackstoreDimension = fabric.StaticCanvas.prototype._setBackstoreDimension;
	  }
	
	})();
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer, __webpack_require__(8)))

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(5)
	var ieee754 = __webpack_require__(6)
	var isArray = __webpack_require__(7)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()
	
	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length)
	    }
	    that.length = length
	  }
	
	  return that
	}
	
	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */
	
	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}
	
	Buffer.poolSize = 8192 // not used by this implementation
	
	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}
	
	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }
	
	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }
	
	  return fromObject(that, value)
	}
	
	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	}
	
	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}
	
	function alloc (that, size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}
	
	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	}
	
	function allocUnsafe (that, size) {
	  assertSize(size)
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }
	
	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }
	
	  var length = byteLength(string, encoding) | 0
	  that = createBuffer(that, length)
	
	  var actual = that.write(string, encoding)
	
	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual)
	  }
	
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0
	  that = createBuffer(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer
	
	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }
	
	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }
	
	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array)
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset)
	  } else {
	    array = new Uint8Array(array, byteOffset, length)
	  }
	
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array)
	  }
	  return that
	}
	
	function fromObject (that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    that = createBuffer(that, len)
	
	    if (that.length === 0) {
	      return that
	    }
	
	    obj.copy(that, 0, 0, len)
	    return that
	  }
	
	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }
	
	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }
	
	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }
	
	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }
	
	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}
	
	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.
	
	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }
	
	  if (end === undefined || end > this.length) {
	    end = this.length
	  }
	
	  if (end <= 0) {
	    return ''
	  }
	
	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0
	
	  if (end <= start) {
	    return ''
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true
	
	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}
	
	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}
	
	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}
	
	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7)
	    swap(this, i + 1, i + 6)
	    swap(this, i + 2, i + 5)
	    swap(this, i + 3, i + 4)
	  }
	  return this
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }
	
	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }
	
	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }
	
	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }
	
	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0
	
	  if (this === target) return 0
	
	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)
	
	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)
	
	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1
	
	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset = +byteOffset  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1)
	  }
	
	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0
	    else return -1
	  }
	
	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }
	
	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length
	
	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }
	
	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }
	
	  var i
	  if (dir) {
	    var foundIndex = -1
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex
	        foundIndex = -1
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false
	          break
	        }
	      }
	      if (found) return i
	    }
	  }
	
	  return -1
	}
	
	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}
	
	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function latin1Slice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }
	
	  return len
	}
	
	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }
	
	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }
	
	  if (end <= start) {
	    return this
	  }
	
	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0
	
	  if (!val) val = 0
	
	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString())
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 5 */
/***/ function(module, exports) {

	'use strict'
	
	exports.byteLength = byteLength
	exports.toByteArray = toByteArray
	exports.fromByteArray = fromByteArray
	
	var lookup = []
	var revLookup = []
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
	
	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i]
	  revLookup[code.charCodeAt(i)] = i
	}
	
	revLookup['-'.charCodeAt(0)] = 62
	revLookup['_'.charCodeAt(0)] = 63
	
	function placeHoldersCount (b64) {
	  var len = b64.length
	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }
	
	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
	}
	
	function byteLength (b64) {
	  // base64 is 4/3 + up to two characters of the original data
	  return b64.length * 3 / 4 - placeHoldersCount(b64)
	}
	
	function toByteArray (b64) {
	  var i, j, l, tmp, placeHolders, arr
	  var len = b64.length
	  placeHolders = placeHoldersCount(b64)
	
	  arr = new Arr(len * 3 / 4 - placeHolders)
	
	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len
	
	  var L = 0
	
	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
	    arr[L++] = (tmp >> 16) & 0xFF
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }
	
	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
	    arr[L++] = tmp & 0xFF
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }
	
	  return arr
	}
	
	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}
	
	function encodeChunk (uint8, start, end) {
	  var tmp
	  var output = []
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
	    output.push(tripletToBase64(tmp))
	  }
	  return output.join('')
	}
	
	function fromByteArray (uint8) {
	  var tmp
	  var len = uint8.length
	  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
	  var output = ''
	  var parts = []
	  var maxChunkLength = 16383 // must be multiple of 3
	
	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
	  }
	
	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1]
	    output += lookup[tmp >> 2]
	    output += lookup[(tmp << 4) & 0x3F]
	    output += '=='
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
	    output += lookup[tmp >> 10]
	    output += lookup[(tmp >> 4) & 0x3F]
	    output += lookup[(tmp << 2) & 0x3F]
	    output += '='
	  }
	
	  parts.push(output)
	
	  return parts.join('')
	}


/***/ },
/* 6 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 7 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 8 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 9 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 10 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 11 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var punycode = __webpack_require__(13);
	var util = __webpack_require__(15);
	
	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;
	
	exports.Url = Url;
	
	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}
	
	// Reference: RFC 3986, RFC 1808, RFC 2396
	
	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,
	
	    // Special case for a simple path URL
	    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
	
	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
	
	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
	
	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = __webpack_require__(16);
	
	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && util.isObject(url) && url instanceof Url) return url;
	
	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}
	
	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!util.isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }
	
	  // Copy chrome, IE, opera backslash-handling behavior.
	  // Back slashes before the query string get converted to forward slashes
	  // See: https://code.google.com/p/chromium/issues/detail?id=25916
	  var queryIndex = url.indexOf('?'),
	      splitter =
	          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
	      uSplit = url.split(splitter),
	      slashRegex = /\\/g;
	  uSplit[0] = uSplit[0].replace(slashRegex, '/');
	  url = uSplit.join(splitter);
	
	  var rest = url;
	
	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();
	
	  if (!slashesDenoteHost && url.split('#').length === 1) {
	    // Try fast path regexp
	    var simplePath = simplePathPattern.exec(rest);
	    if (simplePath) {
	      this.path = rest;
	      this.href = rest;
	      this.pathname = simplePath[1];
	      if (simplePath[2]) {
	        this.search = simplePath[2];
	        if (parseQueryString) {
	          this.query = querystring.parse(this.search.substr(1));
	        } else {
	          this.query = this.search.substr(1);
	        }
	      } else if (parseQueryString) {
	        this.search = '';
	        this.query = {};
	      }
	      return this;
	    }
	  }
	
	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }
	
	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }
	
	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {
	
	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c
	
	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.
	
	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	
	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }
	
	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }
	
	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;
	
	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);
	
	    // pull out port.
	    this.parseHost();
	
	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';
	
	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';
	
	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }
	
	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }
	
	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a punycoded representation of "domain".
	      // It only converts parts of the domain name that
	      // have non-ASCII characters, i.e. it doesn't matter if
	      // you call it with a domain that already is ASCII-only.
	      this.hostname = punycode.toASCII(this.hostname);
	    }
	
	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;
	
	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }
	
	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {
	
	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      if (rest.indexOf(ae) === -1)
	        continue;
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }
	
	
	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }
	
	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }
	
	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};
	
	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (util.isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}
	
	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }
	
	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';
	
	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }
	
	  if (this.query &&
	      util.isObject(this.query) &&
	      Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }
	
	  var search = this.search || (query && ('?' + query)) || '';
	
	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';
	
	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }
	
	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;
	
	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');
	
	  return protocol + host + pathname + search + hash;
	};
	
	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}
	
	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};
	
	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}
	
	Url.prototype.resolveObject = function(relative) {
	  if (util.isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }
	
	  var result = new Url();
	  var tkeys = Object.keys(this);
	  for (var tk = 0; tk < tkeys.length; tk++) {
	    var tkey = tkeys[tk];
	    result[tkey] = this[tkey];
	  }
	
	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;
	
	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }
	
	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    var rkeys = Object.keys(relative);
	    for (var rk = 0; rk < rkeys.length; rk++) {
	      var rkey = rkeys[rk];
	      if (rkey !== 'protocol')
	        result[rkey] = relative[rkey];
	    }
	
	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }
	
	    result.href = result.format();
	    return result;
	  }
	
	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      var keys = Object.keys(relative);
	      for (var v = 0; v < keys.length; v++) {
	        var k = keys[v];
	        result[k] = relative[k];
	      }
	      result.href = result.format();
	      return result;
	    }
	
	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }
	
	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];
	
	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }
	
	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!util.isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especially happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host || srcPath.length > 1) &&
	      (last === '.' || last === '..') || last === '');
	
	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last === '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }
	
	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }
	
	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }
	
	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');
	
	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especially happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }
	
	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);
	
	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }
	
	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }
	
	  //to support request.http
	  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};
	
	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function(root) {
	
		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}
	
		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,
	
		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
	
		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'
	
		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
	
		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},
	
		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,
	
		/** Temporary variable */
		key;
	
		/*--------------------------------------------------------------------------*/
	
		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw RangeError(errors[type]);
		}
	
		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}
	
		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}
	
		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}
	
		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}
	
		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}
	
		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * http://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}
	
		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;
	
			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.
	
			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}
	
			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}
	
			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.
	
			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {
	
				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {
	
					if (index >= inputLength) {
						error('invalid-input');
					}
	
					digit = basicToDigit(input.charCodeAt(index++));
	
					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}
	
					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
	
					if (digit < t) {
						break;
					}
	
					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}
	
					w *= baseMinusT;
	
				}
	
				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);
	
				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}
	
				n += floor(i / out);
				i %= out;
	
				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);
	
			}
	
			return ucs2encode(output);
		}
	
		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;
	
			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);
	
			// Cache the length
			inputLength = input.length;
	
			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;
	
			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}
	
			handledCPCount = basicLength = output.length;
	
			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.
	
			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}
	
			// Main encoding loop:
			while (handledCPCount < inputLength) {
	
				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}
	
				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}
	
				delta += (m - n) * handledCPCountPlusOne;
				n = m;
	
				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];
	
					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}
	
					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}
	
						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}
	
				++delta;
				++n;
	
			}
			return output.join('');
		}
	
		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}
	
		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}
	
		/*--------------------------------------------------------------------------*/
	
		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};
	
		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.punycode = punycode;
		}
	
	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)(module), (function() { return this; }())))

/***/ },
/* 14 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 15 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	  isString: function(arg) {
	    return typeof(arg) === 'string';
	  },
	  isObject: function(arg) {
	    return typeof(arg) === 'object' && arg !== null;
	  },
	  isNull: function(arg) {
	    return arg === null;
	  },
	  isNullOrUndefined: function(arg) {
	    return arg == null;
	  }
	};


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.decode = exports.parse = __webpack_require__(17);
	exports.encode = exports.stringify = __webpack_require__(18);


/***/ },
/* 17 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};
	
	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }
	
	  var regexp = /\+/g;
	  qs = qs.split(sep);
	
	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }
	
	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }
	
	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;
	
	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }
	
	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);
	
	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }
	
	  return obj;
	};


/***/ },
/* 18 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;
	
	    case 'boolean':
	      return v ? 'true' : 'false';
	
	    case 'number':
	      return isFinite(v) ? v : '';
	
	    default:
	      return '';
	  }
	};
	
	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }
	
	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);
	
	  }
	
	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {var ClientRequest = __webpack_require__(20)
	var extend = __webpack_require__(46)
	var statusCodes = __webpack_require__(47)
	var url = __webpack_require__(12)
	
	var http = exports
	
	http.request = function (opts, cb) {
		if (typeof opts === 'string')
			opts = url.parse(opts)
		else
			opts = extend(opts)
	
		// Normally, the page is loaded from http or https, so not specifying a protocol
		// will result in a (valid) protocol-relative url. However, this won't work if
		// the protocol is something else, like 'file:'
		var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''
	
		var protocol = opts.protocol || defaultProtocol
		var host = opts.hostname || opts.host
		var port = opts.port
		var path = opts.path || '/'
	
		// Necessary for IPv6 addresses
		if (host && host.indexOf(':') !== -1)
			host = '[' + host + ']'
	
		// This may be a relative url. The browser should always be able to interpret it correctly.
		opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
		opts.method = (opts.method || 'GET').toUpperCase()
		opts.headers = opts.headers || {}
	
		// Also valid opts.auth, opts.mode
	
		var req = new ClientRequest(opts)
		if (cb)
			req.on('response', cb)
		return req
	}
	
	http.get = function get (opts, cb) {
		var req = http.request(opts, cb)
		req.end()
		return req
	}
	
	http.Agent = function () {}
	http.Agent.defaultMaxSockets = 4
	
	http.STATUS_CODES = statusCodes
	
	http.METHODS = [
		'CHECKOUT',
		'CONNECT',
		'COPY',
		'DELETE',
		'GET',
		'HEAD',
		'LOCK',
		'M-SEARCH',
		'MERGE',
		'MKACTIVITY',
		'MKCOL',
		'MOVE',
		'NOTIFY',
		'OPTIONS',
		'PATCH',
		'POST',
		'PROPFIND',
		'PROPPATCH',
		'PURGE',
		'PUT',
		'REPORT',
		'SEARCH',
		'SUBSCRIBE',
		'TRACE',
		'UNLOCK',
		'UNSUBSCRIBE'
	]
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global, process) {var capability = __webpack_require__(21)
	var inherits = __webpack_require__(22)
	var response = __webpack_require__(23)
	var stream = __webpack_require__(24)
	var toArrayBuffer = __webpack_require__(45)
	
	var IncomingMessage = response.IncomingMessage
	var rStates = response.readyStates
	
	function decideMode (preferBinary, useFetch) {
		if (capability.fetch && useFetch) {
			return 'fetch'
		} else if (capability.mozchunkedarraybuffer) {
			return 'moz-chunked-arraybuffer'
		} else if (capability.msstream) {
			return 'ms-stream'
		} else if (capability.arraybuffer && preferBinary) {
			return 'arraybuffer'
		} else if (capability.vbArray && preferBinary) {
			return 'text:vbarray'
		} else {
			return 'text'
		}
	}
	
	var ClientRequest = module.exports = function (opts) {
		var self = this
		stream.Writable.call(self)
	
		self._opts = opts
		self._body = []
		self._headers = {}
		if (opts.auth)
			self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))
		Object.keys(opts.headers).forEach(function (name) {
			self.setHeader(name, opts.headers[name])
		})
	
		var preferBinary
		var useFetch = true
		if (opts.mode === 'disable-fetch' || 'timeout' in opts) {
			// If the use of XHR should be preferred and includes preserving the 'content-type' header.
			// Force XHR to be used since the Fetch API does not yet support timeouts.
			useFetch = false
			preferBinary = true
		} else if (opts.mode === 'prefer-streaming') {
			// If streaming is a high priority but binary compatibility and
			// the accuracy of the 'content-type' header aren't
			preferBinary = false
		} else if (opts.mode === 'allow-wrong-content-type') {
			// If streaming is more important than preserving the 'content-type' header
			preferBinary = !capability.overrideMimeType
		} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
			// Use binary if text streaming may corrupt data or the content-type header, or for speed
			preferBinary = true
		} else {
			throw new Error('Invalid value for opts.mode')
		}
		self._mode = decideMode(preferBinary, useFetch)
	
		self.on('finish', function () {
			self._onFinish()
		})
	}
	
	inherits(ClientRequest, stream.Writable)
	
	ClientRequest.prototype.setHeader = function (name, value) {
		var self = this
		var lowerName = name.toLowerCase()
		// This check is not necessary, but it prevents warnings from browsers about setting unsafe
		// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
		// http-browserify did it, so I will too.
		if (unsafeHeaders.indexOf(lowerName) !== -1)
			return
	
		self._headers[lowerName] = {
			name: name,
			value: value
		}
	}
	
	ClientRequest.prototype.getHeader = function (name) {
		var self = this
		return self._headers[name.toLowerCase()].value
	}
	
	ClientRequest.prototype.removeHeader = function (name) {
		var self = this
		delete self._headers[name.toLowerCase()]
	}
	
	ClientRequest.prototype._onFinish = function () {
		var self = this
	
		if (self._destroyed)
			return
		var opts = self._opts
	
		var headersObj = self._headers
		var body = null
		if (opts.method === 'POST' || opts.method === 'PUT' || opts.method === 'PATCH' || opts.method === 'MERGE') {
			if (capability.blobConstructor) {
				body = new global.Blob(self._body.map(function (buffer) {
					return toArrayBuffer(buffer)
				}), {
					type: (headersObj['content-type'] || {}).value || ''
				})
			} else {
				// get utf8 string
				body = Buffer.concat(self._body).toString()
			}
		}
	
		if (self._mode === 'fetch') {
			var headers = Object.keys(headersObj).map(function (name) {
				return [headersObj[name].name, headersObj[name].value]
			})
	
			global.fetch(self._opts.url, {
				method: self._opts.method,
				headers: headers,
				body: body || undefined,
				mode: 'cors',
				credentials: opts.withCredentials ? 'include' : 'same-origin'
			}).then(function (response) {
				self._fetchResponse = response
				self._connect()
			}, function (reason) {
				self.emit('error', reason)
			})
		} else {
			var xhr = self._xhr = new global.XMLHttpRequest()
			try {
				xhr.open(self._opts.method, self._opts.url, true)
			} catch (err) {
				process.nextTick(function () {
					self.emit('error', err)
				})
				return
			}
	
			// Can't set responseType on really old browsers
			if ('responseType' in xhr)
				xhr.responseType = self._mode.split(':')[0]
	
			if ('withCredentials' in xhr)
				xhr.withCredentials = !!opts.withCredentials
	
			if (self._mode === 'text' && 'overrideMimeType' in xhr)
				xhr.overrideMimeType('text/plain; charset=x-user-defined')
	
			if ('timeout' in opts) {
				xhr.timeout = opts.timeout
				xhr.ontimeout = function () {
					self.emit('timeout')
				}
			}
	
			Object.keys(headersObj).forEach(function (name) {
				xhr.setRequestHeader(headersObj[name].name, headersObj[name].value)
			})
	
			self._response = null
			xhr.onreadystatechange = function () {
				switch (xhr.readyState) {
					case rStates.LOADING:
					case rStates.DONE:
						self._onXHRProgress()
						break
				}
			}
			// Necessary for streaming in Firefox, since xhr.response is ONLY defined
			// in onprogress, not in onreadystatechange with xhr.readyState = 3
			if (self._mode === 'moz-chunked-arraybuffer') {
				xhr.onprogress = function () {
					self._onXHRProgress()
				}
			}
	
			xhr.onerror = function () {
				if (self._destroyed)
					return
				self.emit('error', new Error('XHR error'))
			}
	
			try {
				xhr.send(body)
			} catch (err) {
				process.nextTick(function () {
					self.emit('error', err)
				})
				return
			}
		}
	}
	
	/**
	 * Checks if xhr.status is readable and non-zero, indicating no error.
	 * Even though the spec says it should be available in readyState 3,
	 * accessing it throws an exception in IE8
	 */
	function statusValid (xhr) {
		try {
			var status = xhr.status
			return (status !== null && status !== 0)
		} catch (e) {
			return false
		}
	}
	
	ClientRequest.prototype._onXHRProgress = function () {
		var self = this
	
		if (!statusValid(self._xhr) || self._destroyed)
			return
	
		if (!self._response)
			self._connect()
	
		self._response._onXHRProgress()
	}
	
	ClientRequest.prototype._connect = function () {
		var self = this
	
		if (self._destroyed)
			return
	
		self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode)
		self._response.on('error', function(err) {
			self.emit('error', err)
		})
	
		self.emit('response', self._response)
	}
	
	ClientRequest.prototype._write = function (chunk, encoding, cb) {
		var self = this
	
		self._body.push(chunk)
		cb()
	}
	
	ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
		var self = this
		self._destroyed = true
		if (self._response)
			self._response._destroyed = true
		if (self._xhr)
			self._xhr.abort()
		// Currently, there isn't a way to truly abort a fetch.
		// If you like bikeshedding, see https://github.com/whatwg/fetch/issues/27
	}
	
	ClientRequest.prototype.end = function (data, encoding, cb) {
		var self = this
		if (typeof data === 'function') {
			cb = data
			data = undefined
		}
	
		stream.Writable.prototype.end.call(self, data, encoding, cb)
	}
	
	ClientRequest.prototype.flushHeaders = function () {}
	ClientRequest.prototype.setTimeout = function () {}
	ClientRequest.prototype.setNoDelay = function () {}
	ClientRequest.prototype.setSocketKeepAlive = function () {}
	
	// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
	var unsafeHeaders = [
		'accept-charset',
		'accept-encoding',
		'access-control-request-headers',
		'access-control-request-method',
		'connection',
		'content-length',
		'cookie',
		'cookie2',
		'date',
		'dnt',
		'expect',
		'host',
		'keep-alive',
		'origin',
		'referer',
		'te',
		'trailer',
		'transfer-encoding',
		'upgrade',
		'user-agent',
		'via'
	]
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer, (function() { return this; }()), __webpack_require__(8)))

/***/ },
/* 21 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)
	
	exports.blobConstructor = false
	try {
		new Blob([new ArrayBuffer(1)])
		exports.blobConstructor = true
	} catch (e) {}
	
	// The xhr request to example.com may violate some restrictive CSP configurations,
	// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
	// and assume support for certain features below.
	var xhr
	function getXHR () {
		// Cache the xhr value
		if (xhr !== undefined) return xhr
	
		if (global.XMLHttpRequest) {
			xhr = new global.XMLHttpRequest()
			// If XDomainRequest is available (ie only, where xhr might not work
			// cross domain), use the page location. Otherwise use example.com
			// Note: this doesn't actually make an http request.
			try {
				xhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')
			} catch(e) {
				xhr = null
			}
		} else {
			// Service workers don't have XHR
			xhr = null
		}
		return xhr
	}
	
	function checkTypeSupport (type) {
		var xhr = getXHR()
		if (!xhr) return false
		try {
			xhr.responseType = type
			return xhr.responseType === type
		} catch (e) {}
		return false
	}
	
	// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
	// Safari 7.1 appears to have fixed this bug.
	var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'
	var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)
	
	// If fetch is supported, then arraybuffer will be supported too. Skip calling
	// checkTypeSupport(), since that calls getXHR().
	exports.arraybuffer = exports.fetch || (haveArrayBuffer && checkTypeSupport('arraybuffer'))
	
	// These next two tests unavoidably show warnings in Chrome. Since fetch will always
	// be used if it's available, just return false for these to avoid the warnings.
	exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')
	exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&
		checkTypeSupport('moz-chunked-arraybuffer')
	
	// If fetch is supported, then overrideMimeType will be supported too. Skip calling
	// getXHR().
	exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)
	
	exports.vbArray = isFunction(global.VBArray)
	
	function isFunction (value) {
		return typeof value === 'function'
	}
	
	xhr = null // Help gc
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 22 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer, global) {var capability = __webpack_require__(21)
	var inherits = __webpack_require__(22)
	var stream = __webpack_require__(24)
	
	var rStates = exports.readyStates = {
		UNSENT: 0,
		OPENED: 1,
		HEADERS_RECEIVED: 2,
		LOADING: 3,
		DONE: 4
	}
	
	var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode) {
		var self = this
		stream.Readable.call(self)
	
		self._mode = mode
		self.headers = {}
		self.rawHeaders = []
		self.trailers = {}
		self.rawTrailers = []
	
		// Fake the 'close' event, but only once 'end' fires
		self.on('end', function () {
			// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
			process.nextTick(function () {
				self.emit('close')
			})
		})
	
		if (mode === 'fetch') {
			self._fetchResponse = response
	
			self.url = response.url
			self.statusCode = response.status
			self.statusMessage = response.statusText
			
			response.headers.forEach(function(header, key){
				self.headers[key.toLowerCase()] = header
				self.rawHeaders.push(key, header)
			})
	
	
			// TODO: this doesn't respect backpressure. Once WritableStream is available, this can be fixed
			var reader = response.body.getReader()
			function read () {
				reader.read().then(function (result) {
					if (self._destroyed)
						return
					if (result.done) {
						self.push(null)
						return
					}
					self.push(new Buffer(result.value))
					read()
				}).catch(function(err) {
					self.emit('error', err)
				})
			}
			read()
	
		} else {
			self._xhr = xhr
			self._pos = 0
	
			self.url = xhr.responseURL
			self.statusCode = xhr.status
			self.statusMessage = xhr.statusText
			var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
			headers.forEach(function (header) {
				var matches = header.match(/^([^:]+):\s*(.*)/)
				if (matches) {
					var key = matches[1].toLowerCase()
					if (key === 'set-cookie') {
						if (self.headers[key] === undefined) {
							self.headers[key] = []
						}
						self.headers[key].push(matches[2])
					} else if (self.headers[key] !== undefined) {
						self.headers[key] += ', ' + matches[2]
					} else {
						self.headers[key] = matches[2]
					}
					self.rawHeaders.push(matches[1], matches[2])
				}
			})
	
			self._charset = 'x-user-defined'
			if (!capability.overrideMimeType) {
				var mimeType = self.rawHeaders['mime-type']
				if (mimeType) {
					var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
					if (charsetMatch) {
						self._charset = charsetMatch[1].toLowerCase()
					}
				}
				if (!self._charset)
					self._charset = 'utf-8' // best guess
			}
		}
	}
	
	inherits(IncomingMessage, stream.Readable)
	
	IncomingMessage.prototype._read = function () {}
	
	IncomingMessage.prototype._onXHRProgress = function () {
		var self = this
	
		var xhr = self._xhr
	
		var response = null
		switch (self._mode) {
			case 'text:vbarray': // For IE9
				if (xhr.readyState !== rStates.DONE)
					break
				try {
					// This fails in IE8
					response = new global.VBArray(xhr.responseBody).toArray()
				} catch (e) {}
				if (response !== null) {
					self.push(new Buffer(response))
					break
				}
				// Falls through in IE8	
			case 'text':
				try { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
					response = xhr.responseText
				} catch (e) {
					self._mode = 'text:vbarray'
					break
				}
				if (response.length > self._pos) {
					var newData = response.substr(self._pos)
					if (self._charset === 'x-user-defined') {
						var buffer = new Buffer(newData.length)
						for (var i = 0; i < newData.length; i++)
							buffer[i] = newData.charCodeAt(i) & 0xff
	
						self.push(buffer)
					} else {
						self.push(newData, self._charset)
					}
					self._pos = response.length
				}
				break
			case 'arraybuffer':
				if (xhr.readyState !== rStates.DONE || !xhr.response)
					break
				response = xhr.response
				self.push(new Buffer(new Uint8Array(response)))
				break
			case 'moz-chunked-arraybuffer': // take whole
				response = xhr.response
				if (xhr.readyState !== rStates.LOADING || !response)
					break
				self.push(new Buffer(new Uint8Array(response)))
				break
			case 'ms-stream':
				response = xhr.response
				if (xhr.readyState !== rStates.LOADING)
					break
				var reader = new global.MSStreamReader()
				reader.onprogress = function () {
					if (reader.result.byteLength > self._pos) {
						self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))
						self._pos = reader.result.byteLength
					}
				}
				reader.onload = function () {
					self.push(null)
				}
				// reader.onerror = ??? // TODO: this
				reader.readAsArrayBuffer(response)
				break
		}
	
		// The ms-stream case handles end separately in reader.onload()
		if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
			self.push(null)
		}
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8), __webpack_require__(4).Buffer, (function() { return this; }())))

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var Stream = (function (){
	  try {
	    return __webpack_require__(25); // hack to fix a circular dependency issue when used with browserify
	  } catch(_){}
	}());
	exports = module.exports = __webpack_require__(36);
	exports.Stream = Stream || exports;
	exports.Readable = exports;
	exports.Writable = __webpack_require__(28);
	exports.Duplex = __webpack_require__(35);
	exports.Transform = __webpack_require__(42);
	exports.PassThrough = __webpack_require__(44);
	
	if (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {
	  module.exports = Stream;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	module.exports = Stream;
	
	var EE = __webpack_require__(26).EventEmitter;
	var inherits = __webpack_require__(22);
	
	inherits(Stream, EE);
	Stream.Readable = __webpack_require__(24);
	Stream.Writable = __webpack_require__(27);
	Stream.Duplex = __webpack_require__(40);
	Stream.Transform = __webpack_require__(41);
	Stream.PassThrough = __webpack_require__(43);
	
	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;
	
	
	
	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.
	
	function Stream() {
	  EE.call(this);
	}
	
	Stream.prototype.pipe = function(dest, options) {
	  var source = this;
	
	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }
	
	  source.on('data', ondata);
	
	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }
	
	  dest.on('drain', ondrain);
	
	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }
	
	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;
	
	    dest.end();
	  }
	
	
	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;
	
	    if (typeof dest.destroy === 'function') dest.destroy();
	  }
	
	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }
	
	  source.on('error', onerror);
	  dest.on('error', onerror);
	
	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);
	
	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);
	
	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);
	
	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);
	
	    dest.removeListener('close', cleanup);
	  }
	
	  source.on('end', cleanup);
	  source.on('close', cleanup);
	
	  dest.on('close', cleanup);
	
	  dest.emit('pipe', source);
	
	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};


/***/ },
/* 26 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(28)


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, setImmediate) {// A bit simpler than readable streams.
	// Implement an async ._write(chunk, encoding, cb), and it'll handle all
	// the drain event emission and buffering.
	
	'use strict';
	
	module.exports = Writable;
	
	/*<replacement>*/
	var processNextTick = __webpack_require__(31);
	/*</replacement>*/
	
	/*<replacement>*/
	var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
	/*</replacement>*/
	
	/*<replacement>*/
	var Duplex;
	/*</replacement>*/
	
	Writable.WritableState = WritableState;
	
	/*<replacement>*/
	var util = __webpack_require__(32);
	util.inherits = __webpack_require__(22);
	/*</replacement>*/
	
	/*<replacement>*/
	var internalUtil = {
	  deprecate: __webpack_require__(33)
	};
	/*</replacement>*/
	
	/*<replacement>*/
	var Stream;
	(function () {
	  try {
	    Stream = __webpack_require__(25);
	  } catch (_) {} finally {
	    if (!Stream) Stream = __webpack_require__(26).EventEmitter;
	  }
	})();
	/*</replacement>*/
	
	var Buffer = __webpack_require__(4).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(34);
	/*</replacement>*/
	
	util.inherits(Writable, Stream);
	
	function nop() {}
	
	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	  this.next = null;
	}
	
	function WritableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(35);
	
	  options = options || {};
	
	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
	
	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;
	
	  // drain event flag.
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;
	
	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;
	
	  // a flag to see when we're in the middle of a write.
	  this.writing = false;
	
	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;
	
	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };
	
	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;
	
	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	
	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;
	
	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;
	
	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;
	
	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	
	  // count buffered requests
	  this.bufferedRequestCount = 0;
	
	  // allocate the first CorkedRequest, there is always
	  // one allocated and free to use, and we maintain at most two
	  this.corkedRequestsFree = new CorkedRequest(this);
	}
	
	WritableState.prototype.getBuffer = function getBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};
	
	(function () {
	  try {
	    Object.defineProperty(WritableState.prototype, 'buffer', {
	      get: internalUtil.deprecate(function () {
	        return this.getBuffer();
	      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
	    });
	  } catch (_) {}
	})();
	
	// Test _writableState for inheritance to account for Duplex streams,
	// whose prototype chain only points to Readable.
	var realHasInstance;
	if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
	  realHasInstance = Function.prototype[Symbol.hasInstance];
	  Object.defineProperty(Writable, Symbol.hasInstance, {
	    value: function (object) {
	      if (realHasInstance.call(this, object)) return true;
	
	      return object && object._writableState instanceof WritableState;
	    }
	  });
	} else {
	  realHasInstance = function (object) {
	    return object instanceof this;
	  };
	}
	
	function Writable(options) {
	  Duplex = Duplex || __webpack_require__(35);
	
	  // Writable ctor is applied to Duplexes, too.
	  // `realHasInstance` is necessary because using plain `instanceof`
	  // would return false, as no `_writableState` property is attached.
	
	  // Trying to use the custom `instanceof` for Writable here will also break the
	  // Node.js LazyTransform implementation, which has a non-trivial getter for
	  // `_writableState` that would lead to infinite recursion.
	  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
	    return new Writable(options);
	  }
	
	  this._writableState = new WritableState(options, this);
	
	  // legacy.
	  this.writable = true;
	
	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;
	
	    if (typeof options.writev === 'function') this._writev = options.writev;
	  }
	
	  Stream.call(this);
	}
	
	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  this.emit('error', new Error('Cannot pipe, not readable'));
	};
	
	function writeAfterEnd(stream, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  processNextTick(cb, er);
	}
	
	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  var er = false;
	  // Always throw error if a null is written
	  // if we are not in object mode then throw
	  // if it is not a buffer, string, or undefined.
	  if (chunk === null) {
	    er = new TypeError('May not write null values to stream');
	  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  if (er) {
	    stream.emit('error', er);
	    processNextTick(cb, er);
	    valid = false;
	  }
	  return valid;
	}
	
	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	
	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
	
	  if (typeof cb !== 'function') cb = nop;
	
	  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }
	
	  return ret;
	};
	
	Writable.prototype.cork = function () {
	  var state = this._writableState;
	
	  state.corked++;
	};
	
	Writable.prototype.uncork = function () {
	  var state = this._writableState;
	
	  if (state.corked) {
	    state.corked--;
	
	    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};
	
	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
	  this._writableState.defaultEncoding = encoding;
	  return this;
	};
	
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = bufferShim.from(chunk, encoding);
	  }
	  return chunk;
	}
	
	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	
	  if (Buffer.isBuffer(chunk)) encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;
	
	  state.length += len;
	
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;
	
	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }
	
	  return ret;
	}
	
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	
	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	  if (sync) processNextTick(cb, er);else cb(er);
	
	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}
	
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	
	  onwriteStateUpdate(state);
	
	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state);
	
	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }
	
	    if (sync) {
	      /*<replacement>*/
	      asyncWrite(afterWrite, stream, state, finished, cb);
	      /*</replacement>*/
	    } else {
	        afterWrite(stream, state, finished, cb);
	      }
	  }
	}
	
	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}
	
	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}
	
	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;
	
	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;
	
	    var count = 0;
	    while (entry) {
	      buffer[count] = entry;
	      entry = entry.next;
	      count += 1;
	    }
	
	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);
	
	    // doWrite is almost always async, defer these to save a bit of time
	    // as the hot path ends with doWrite
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    if (holder.next) {
	      state.corkedRequestsFree = holder.next;
	      holder.next = null;
	    } else {
	      state.corkedRequestsFree = new CorkedRequest(state);
	    }
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;
	
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }
	
	    if (entry === null) state.lastBufferedRequest = null;
	  }
	
	  state.bufferedRequestCount = 0;
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}
	
	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new Error('_write() is not implemented'));
	};
	
	Writable.prototype._writev = null;
	
	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;
	
	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
	
	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }
	
	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished) endWritable(this, state, cb);
	};
	
	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}
	
	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}
	
	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else {
	      prefinish(stream, state);
	    }
	  }
	  return need;
	}
	
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	  stream.writable = false;
	}
	
	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
	  var _this = this;
	
	  this.next = null;
	  this.entry = null;
	
	  this.finish = function (err) {
	    var entry = _this.entry;
	    _this.entry = null;
	    while (entry) {
	      var cb = entry.callback;
	      state.pendingcb--;
	      cb(err);
	      entry = entry.next;
	    }
	    if (state.corkedRequestsFree) {
	      state.corkedRequestsFree.next = _this;
	    } else {
	      state.corkedRequestsFree = _this;
	    }
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8), __webpack_require__(29).setImmediate))

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var apply = Function.prototype.apply;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) {
	  if (timeout) {
	    timeout.close();
	  }
	};
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// setimmediate attaches itself to the global object
	__webpack_require__(30);
	exports.setImmediate = setImmediate;
	exports.clearImmediate = clearImmediate;


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
	    "use strict";
	
	    if (global.setImmediate) {
	        return;
	    }
	
	    var nextHandle = 1; // Spec says greater than zero
	    var tasksByHandle = {};
	    var currentlyRunningATask = false;
	    var doc = global.document;
	    var registerImmediate;
	
	    function setImmediate(callback) {
	      // Callback can either be a function or a string
	      if (typeof callback !== "function") {
	        callback = new Function("" + callback);
	      }
	      // Copy function arguments
	      var args = new Array(arguments.length - 1);
	      for (var i = 0; i < args.length; i++) {
	          args[i] = arguments[i + 1];
	      }
	      // Store and register the task
	      var task = { callback: callback, args: args };
	      tasksByHandle[nextHandle] = task;
	      registerImmediate(nextHandle);
	      return nextHandle++;
	    }
	
	    function clearImmediate(handle) {
	        delete tasksByHandle[handle];
	    }
	
	    function run(task) {
	        var callback = task.callback;
	        var args = task.args;
	        switch (args.length) {
	        case 0:
	            callback();
	            break;
	        case 1:
	            callback(args[0]);
	            break;
	        case 2:
	            callback(args[0], args[1]);
	            break;
	        case 3:
	            callback(args[0], args[1], args[2]);
	            break;
	        default:
	            callback.apply(undefined, args);
	            break;
	        }
	    }
	
	    function runIfPresent(handle) {
	        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
	        // So if we're currently running a task, we'll need to delay this invocation.
	        if (currentlyRunningATask) {
	            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	            // "too much recursion" error.
	            setTimeout(runIfPresent, 0, handle);
	        } else {
	            var task = tasksByHandle[handle];
	            if (task) {
	                currentlyRunningATask = true;
	                try {
	                    run(task);
	                } finally {
	                    clearImmediate(handle);
	                    currentlyRunningATask = false;
	                }
	            }
	        }
	    }
	
	    function installNextTickImplementation() {
	        registerImmediate = function(handle) {
	            process.nextTick(function () { runIfPresent(handle); });
	        };
	    }
	
	    function canUsePostMessage() {
	        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	        // where `global.postMessage` means something completely different and can't be used for this purpose.
	        if (global.postMessage && !global.importScripts) {
	            var postMessageIsAsynchronous = true;
	            var oldOnMessage = global.onmessage;
	            global.onmessage = function() {
	                postMessageIsAsynchronous = false;
	            };
	            global.postMessage("", "*");
	            global.onmessage = oldOnMessage;
	            return postMessageIsAsynchronous;
	        }
	    }
	
	    function installPostMessageImplementation() {
	        // Installs an event handler on `global` for the `message` event: see
	        // * https://developer.mozilla.org/en/DOM/window.postMessage
	        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
	
	        var messagePrefix = "setImmediate$" + Math.random() + "$";
	        var onGlobalMessage = function(event) {
	            if (event.source === global &&
	                typeof event.data === "string" &&
	                event.data.indexOf(messagePrefix) === 0) {
	                runIfPresent(+event.data.slice(messagePrefix.length));
	            }
	        };
	
	        if (global.addEventListener) {
	            global.addEventListener("message", onGlobalMessage, false);
	        } else {
	            global.attachEvent("onmessage", onGlobalMessage);
	        }
	
	        registerImmediate = function(handle) {
	            global.postMessage(messagePrefix + handle, "*");
	        };
	    }
	
	    function installMessageChannelImplementation() {
	        var channel = new MessageChannel();
	        channel.port1.onmessage = function(event) {
	            var handle = event.data;
	            runIfPresent(handle);
	        };
	
	        registerImmediate = function(handle) {
	            channel.port2.postMessage(handle);
	        };
	    }
	
	    function installReadyStateChangeImplementation() {
	        var html = doc.documentElement;
	        registerImmediate = function(handle) {
	            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	            var script = doc.createElement("script");
	            script.onreadystatechange = function () {
	                runIfPresent(handle);
	                script.onreadystatechange = null;
	                html.removeChild(script);
	                script = null;
	            };
	            html.appendChild(script);
	        };
	    }
	
	    function installSetTimeoutImplementation() {
	        registerImmediate = function(handle) {
	            setTimeout(runIfPresent, 0, handle);
	        };
	    }
	
	    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
	    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
	    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
	
	    // Don't get fooled by e.g. browserify environments.
	    if ({}.toString.call(global.process) === "[object process]") {
	        // For Node.js before 0.9
	        installNextTickImplementation();
	
	    } else if (canUsePostMessage()) {
	        // For non-IE10 modern browsers
	        installPostMessageImplementation();
	
	    } else if (global.MessageChannel) {
	        // For web workers, where supported
	        installMessageChannelImplementation();
	
	    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
	        // For IE 6–8
	        installReadyStateChangeImplementation();
	
	    } else {
	        // For older browsers
	        installSetTimeoutImplementation();
	    }
	
	    attachTo.setImmediate = setImmediate;
	    attachTo.clearImmediate = clearImmediate;
	}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(8)))

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	if (!process.version ||
	    process.version.indexOf('v0.') === 0 ||
	    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
	  module.exports = nextTick;
	} else {
	  module.exports = process.nextTick;
	}
	
	function nextTick(fn, arg1, arg2, arg3) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('"callback" argument must be a function');
	  }
	  var len = arguments.length;
	  var args, i;
	  switch (len) {
	  case 0:
	  case 1:
	    return process.nextTick(fn);
	  case 2:
	    return process.nextTick(function afterTickOne() {
	      fn.call(null, arg1);
	    });
	  case 3:
	    return process.nextTick(function afterTickTwo() {
	      fn.call(null, arg1, arg2);
	    });
	  case 4:
	    return process.nextTick(function afterTickThree() {
	      fn.call(null, arg1, arg2, arg3);
	    });
	  default:
	    args = new Array(len - 1);
	    i = 0;
	    while (i < args.length) {
	      args[i++] = arguments[i];
	    }
	    return process.nextTick(function afterTick() {
	      fn.apply(null, args);
	    });
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	
	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = Buffer.isBuffer;
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer))

/***/ },
/* 33 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module exports.
	 */
	
	module.exports = deprecate;
	
	/**
	 * Mark that a method should not be used.
	 * Returns a modified function which warns once by default.
	 *
	 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
	 *
	 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
	 * will throw an Error when invoked.
	 *
	 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
	 * will invoke `console.trace()` instead of `console.error()`.
	 *
	 * @param {Function} fn - the function to deprecate
	 * @param {String} msg - the string to print to the console when `fn` is invoked
	 * @returns {Function} a new "deprecated" version of `fn`
	 * @api public
	 */
	
	function deprecate (fn, msg) {
	  if (config('noDeprecation')) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (config('throwDeprecation')) {
	        throw new Error(msg);
	      } else if (config('traceDeprecation')) {
	        console.trace(msg);
	      } else {
	        console.warn(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	}
	
	/**
	 * Checks `localStorage` for boolean values for the given `name`.
	 *
	 * @param {String} name
	 * @returns {Boolean}
	 * @api private
	 */
	
	function config (name) {
	  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
	  try {
	    if (!global.localStorage) return false;
	  } catch (_) {
	    return false;
	  }
	  var val = global.localStorage[name];
	  if (null == val) return false;
	  return String(val).toLowerCase() === 'true';
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var buffer = __webpack_require__(4);
	var Buffer = buffer.Buffer;
	var SlowBuffer = buffer.SlowBuffer;
	var MAX_LEN = buffer.kMaxLength || 2147483647;
	exports.alloc = function alloc(size, fill, encoding) {
	  if (typeof Buffer.alloc === 'function') {
	    return Buffer.alloc(size, fill, encoding);
	  }
	  if (typeof encoding === 'number') {
	    throw new TypeError('encoding must not be number');
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size > MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  var enc = encoding;
	  var _fill = fill;
	  if (_fill === undefined) {
	    enc = undefined;
	    _fill = 0;
	  }
	  var buf = new Buffer(size);
	  if (typeof _fill === 'string') {
	    var fillBuf = new Buffer(_fill, enc);
	    var flen = fillBuf.length;
	    var i = -1;
	    while (++i < size) {
	      buf[i] = fillBuf[i % flen];
	    }
	  } else {
	    buf.fill(_fill);
	  }
	  return buf;
	}
	exports.allocUnsafe = function allocUnsafe(size) {
	  if (typeof Buffer.allocUnsafe === 'function') {
	    return Buffer.allocUnsafe(size);
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size > MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  return new Buffer(size);
	}
	exports.from = function from(value, encodingOrOffset, length) {
	  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
	    return Buffer.from(value, encodingOrOffset, length);
	  }
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number');
	  }
	  if (typeof value === 'string') {
	    return new Buffer(value, encodingOrOffset);
	  }
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    var offset = encodingOrOffset;
	    if (arguments.length === 1) {
	      return new Buffer(value);
	    }
	    if (typeof offset === 'undefined') {
	      offset = 0;
	    }
	    var len = length;
	    if (typeof len === 'undefined') {
	      len = value.byteLength - offset;
	    }
	    if (offset >= value.byteLength) {
	      throw new RangeError('\'offset\' is out of bounds');
	    }
	    if (len > value.byteLength - offset) {
	      throw new RangeError('\'length\' is out of bounds');
	    }
	    return new Buffer(value.slice(offset, offset + len));
	  }
	  if (Buffer.isBuffer(value)) {
	    var out = new Buffer(value.length);
	    value.copy(out, 0, 0, value.length);
	    return out;
	  }
	  if (value) {
	    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {
	      return new Buffer(value);
	    }
	    if (value.type === 'Buffer' && Array.isArray(value.data)) {
	      return new Buffer(value.data);
	    }
	  }
	
	  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
	}
	exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
	  if (typeof Buffer.allocUnsafeSlow === 'function') {
	    return Buffer.allocUnsafeSlow(size);
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size >= MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  return new SlowBuffer(size);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.
	
	'use strict';
	
	/*<replacement>*/
	
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    keys.push(key);
	  }return keys;
	};
	/*</replacement>*/
	
	module.exports = Duplex;
	
	/*<replacement>*/
	var processNextTick = __webpack_require__(31);
	/*</replacement>*/
	
	/*<replacement>*/
	var util = __webpack_require__(32);
	util.inherits = __webpack_require__(22);
	/*</replacement>*/
	
	var Readable = __webpack_require__(36);
	var Writable = __webpack_require__(28);
	
	util.inherits(Duplex, Readable);
	
	var keys = objectKeys(Writable.prototype);
	for (var v = 0; v < keys.length; v++) {
	  var method = keys[v];
	  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	}
	
	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);
	
	  Readable.call(this, options);
	  Writable.call(this, options);
	
	  if (options && options.readable === false) this.readable = false;
	
	  if (options && options.writable === false) this.writable = false;
	
	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
	
	  this.once('end', onend);
	}
	
	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended) return;
	
	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  processNextTick(onEndNT, this);
	}
	
	function onEndNT(self) {
	  self.end();
	}
	
	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	module.exports = Readable;
	
	/*<replacement>*/
	var processNextTick = __webpack_require__(31);
	/*</replacement>*/
	
	/*<replacement>*/
	var isArray = __webpack_require__(7);
	/*</replacement>*/
	
	/*<replacement>*/
	var Duplex;
	/*</replacement>*/
	
	Readable.ReadableState = ReadableState;
	
	/*<replacement>*/
	var EE = __webpack_require__(26).EventEmitter;
	
	var EElistenerCount = function (emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/
	
	/*<replacement>*/
	var Stream;
	(function () {
	  try {
	    Stream = __webpack_require__(25);
	  } catch (_) {} finally {
	    if (!Stream) Stream = __webpack_require__(26).EventEmitter;
	  }
	})();
	/*</replacement>*/
	
	var Buffer = __webpack_require__(4).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(34);
	/*</replacement>*/
	
	/*<replacement>*/
	var util = __webpack_require__(32);
	util.inherits = __webpack_require__(22);
	/*</replacement>*/
	
	/*<replacement>*/
	var debugUtil = __webpack_require__(37);
	var debug = void 0;
	if (debugUtil && debugUtil.debuglog) {
	  debug = debugUtil.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/
	
	var BufferList = __webpack_require__(38);
	var StringDecoder;
	
	util.inherits(Readable, Stream);
	
	function prependListener(emitter, event, fn) {
	  // Sadly this is not cacheable as some libraries bundle their own
	  // event emitter implementation with them.
	  if (typeof emitter.prependListener === 'function') {
	    return emitter.prependListener(event, fn);
	  } else {
	    // This is a hack to make sure that our error handler is attached before any
	    // userland ones.  NEVER DO THIS. This is here only because this code needs
	    // to continue to work with older versions of Node.js that do not include
	    // the prependListener() method. The goal is to eventually remove this hack.
	    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
	  }
	}
	
	function ReadableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(35);
	
	  options = options || {};
	
	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
	
	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;
	
	  // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift()
	  this.buffer = new BufferList();
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;
	
	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;
	
	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder) StringDecoder = __webpack_require__(39).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	
	function Readable(options) {
	  Duplex = Duplex || __webpack_require__(35);
	
	  if (!(this instanceof Readable)) return new Readable(options);
	
	  this._readableState = new ReadableState(options, this);
	
	  // legacy
	  this.readable = true;
	
	  if (options && typeof options.read === 'function') this._read = options.read;
	
	  Stream.call(this);
	}
	
	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;
	
	  if (!state.objectMode && typeof chunk === 'string') {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = bufferShim.from(chunk, encoding);
	      encoding = '';
	    }
	  }
	
	  return readableAddChunk(this, state, chunk, encoding, false);
	};
	
	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};
	
	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	};
	
	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var _e = new Error('stream.unshift() after end event');
	      stream.emit('error', _e);
	    } else {
	      var skipAdd;
	      if (state.decoder && !addToFront && !encoding) {
	        chunk = state.decoder.write(chunk);
	        skipAdd = !state.objectMode && chunk.length === 0;
	      }
	
	      if (!addToFront) state.reading = false;
	
	      // Don't add to the buffer if we've decoded to an empty string chunk and
	      // we're not in object mode
	      if (!skipAdd) {
	        // if we want the data now, just emit it.
	        if (state.flowing && state.length === 0 && !state.sync) {
	          stream.emit('data', chunk);
	          stream.read(0);
	        } else {
	          // update the buffer info.
	          state.length += state.objectMode ? 1 : chunk.length;
	          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
	
	          if (state.needReadable) emitReadable(stream);
	        }
	      }
	
	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }
	
	  return needMoreData(state);
	}
	
	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
	}
	
	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  if (!StringDecoder) StringDecoder = __webpack_require__(39).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};
	
	// Don't raise the hwm > 8MB
	var MAX_HWM = 0x800000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}
	
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
	  if (n <= 0 || state.length === 0 && state.ended) return 0;
	  if (state.objectMode) return 1;
	  if (n !== n) {
	    // Only flow one buffer at a time
	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
	  }
	  // If we're asking for more than the current hwm, then raise the hwm.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n <= state.length) return n;
	  // Don't have enough
	  if (!state.ended) {
	    state.needReadable = true;
	    return 0;
	  }
	  return state.length;
	}
	
	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  n = parseInt(n, 10);
	  var state = this._readableState;
	  var nOrig = n;
	
	  if (n !== 0) state.emittedReadable = false;
	
	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }
	
	  n = howMuchToRead(n, state);
	
	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }
	
	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.
	
	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);
	
	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }
	
	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  } else if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	    // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.
	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }
	
	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;
	
	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  } else {
	    state.length -= n;
	  }
	
	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true;
	
	    // If we tried to read() past the EOF, then emit end on the next tick.
	    if (nOrig !== n && state.ended) endReadable(this);
	  }
	
	  if (ret !== null) this.emit('data', ret);
	
	  return ret;
	};
	
	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}
	
	function onEofChunk(stream, state) {
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	
	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}
	
	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
	  }
	}
	
	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}
	
	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    processNextTick(maybeReadMore_, stream, state);
	  }
	}
	
	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;else len = state.length;
	  }
	  state.readingMore = false;
	}
	
	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  this.emit('error', new Error('_read() is not implemented'));
	};
	
	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
	
	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);
	
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }
	
	  function onend() {
	    debug('onend');
	    dest.end();
	  }
	
	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	
	  var cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);
	
	    cleanedUp = true;
	
	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }
	
	  // If the user pushes more data while we're writing to dest then we'll end up
	  // in ondata again. However, we only want to increase awaitDrain once because
	  // dest will only emit one 'drain' event for the multiple writes.
	  // => Introduce a guard on increasing awaitDrain.
	  var increasedAwaitDrain = false;
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    increasedAwaitDrain = false;
	    var ret = dest.write(chunk);
	    if (false === ret && !increasedAwaitDrain) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      // => Check whether `dest` is still a piping destination.
	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
	        debug('false write response, pause', src._readableState.awaitDrain);
	        src._readableState.awaitDrain++;
	        increasedAwaitDrain = true;
	      }
	      src.pause();
	    }
	  }
	
	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
	  }
	
	  // Make sure our error handler is attached before userland ones.
	  prependListener(dest, 'error', onerror);
	
	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }
	
	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);
	
	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	
	  return dest;
	};
	
	function pipeOnDrain(src) {
	  return function () {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}
	
	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;
	
	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;
	
	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;
	
	    if (!dest) dest = state.pipes;
	
	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this);
	    return this;
	  }
	
	  // slow case. multiple pipe destinations.
	
	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	
	    for (var i = 0; i < len; i++) {
	      dests[i].emit('unpipe', this);
	    }return this;
	  }
	
	  // try to find the right one.
	  var index = indexOf(state.pipes, dest);
	  if (index === -1) return this;
	
	  state.pipes.splice(index, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];
	
	  dest.emit('unpipe', this);
	
	  return this;
	};
	
	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	
	  if (ev === 'data') {
	    // Start flowing on next tick if stream isn't explicitly paused
	    if (this._readableState.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    var state = this._readableState;
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.emittedReadable = false;
	      if (!state.reading) {
	        processNextTick(nReadingNextTick, this);
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }
	
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	
	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}
	
	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    resume(this, state);
	  }
	  return this;
	};
	
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    processNextTick(resume_, stream, state);
	  }
	}
	
	function resume_(stream, state) {
	  if (!state.reading) {
	    debug('resume read 0');
	    stream.read(0);
	  }
	
	  state.resumeScheduled = false;
	  state.awaitDrain = 0;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}
	
	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};
	
	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  while (state.flowing && stream.read() !== null) {}
	}
	
	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var state = this._readableState;
	  var paused = false;
	
	  var self = this;
	  stream.on('end', function () {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) self.push(chunk);
	    }
	
	    self.push(null);
	  });
	
	  stream.on('data', function (chunk) {
	    debug('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);
	
	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
	
	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });
	
	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function (method) {
	        return function () {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }
	
	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function (ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });
	
	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function (n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	
	  return self;
	};
	
	// exposed for testing purposes only.
	Readable._fromList = fromList;
	
	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
	  // nothing buffered
	  if (state.length === 0) return null;
	
	  var ret;
	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
	    // read it all, truncate the list
	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list
	    ret = fromListPartial(n, state.buffer, state.decoder);
	  }
	
	  return ret;
	}
	
	// Extracts only enough buffered data to satisfy the amount requested.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromListPartial(n, list, hasStrings) {
	  var ret;
	  if (n < list.head.data.length) {
	    // slice is the same for buffers and strings
	    ret = list.head.data.slice(0, n);
	    list.head.data = list.head.data.slice(n);
	  } else if (n === list.head.data.length) {
	    // first chunk is a perfect match
	    ret = list.shift();
	  } else {
	    // result spans more than one buffer
	    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
	  }
	  return ret;
	}
	
	// Copies a specified amount of characters from the list of buffered data
	// chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBufferString(n, list) {
	  var p = list.head;
	  var c = 1;
	  var ret = p.data;
	  n -= ret.length;
	  while (p = p.next) {
	    var str = p.data;
	    var nb = n > str.length ? str.length : n;
	    if (nb === str.length) ret += str;else ret += str.slice(0, n);
	    n -= nb;
	    if (n === 0) {
	      if (nb === str.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = str.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}
	
	// Copies a specified amount of bytes from the list of buffered data chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBuffer(n, list) {
	  var ret = bufferShim.allocUnsafe(n);
	  var p = list.head;
	  var c = 1;
	  p.data.copy(ret);
	  n -= p.data.length;
	  while (p = p.next) {
	    var buf = p.data;
	    var nb = n > buf.length ? buf.length : n;
	    buf.copy(ret, ret.length - n, 0, nb);
	    n -= nb;
	    if (n === 0) {
	      if (nb === buf.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = buf.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}
	
	function endReadable(stream) {
	  var state = stream._readableState;
	
	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
	
	  if (!state.endEmitted) {
	    state.ended = true;
	    processNextTick(endReadableNT, state, stream);
	  }
	}
	
	function endReadableNT(state, stream) {
	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	  }
	}
	
	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ },
/* 37 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Buffer = __webpack_require__(4).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(34);
	/*</replacement>*/
	
	module.exports = BufferList;
	
	function BufferList() {
	  this.head = null;
	  this.tail = null;
	  this.length = 0;
	}
	
	BufferList.prototype.push = function (v) {
	  var entry = { data: v, next: null };
	  if (this.length > 0) this.tail.next = entry;else this.head = entry;
	  this.tail = entry;
	  ++this.length;
	};
	
	BufferList.prototype.unshift = function (v) {
	  var entry = { data: v, next: this.head };
	  if (this.length === 0) this.tail = entry;
	  this.head = entry;
	  ++this.length;
	};
	
	BufferList.prototype.shift = function () {
	  if (this.length === 0) return;
	  var ret = this.head.data;
	  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
	  --this.length;
	  return ret;
	};
	
	BufferList.prototype.clear = function () {
	  this.head = this.tail = null;
	  this.length = 0;
	};
	
	BufferList.prototype.join = function (s) {
	  if (this.length === 0) return '';
	  var p = this.head;
	  var ret = '' + p.data;
	  while (p = p.next) {
	    ret += s + p.data;
	  }return ret;
	};
	
	BufferList.prototype.concat = function (n) {
	  if (this.length === 0) return bufferShim.alloc(0);
	  if (this.length === 1) return this.head.data;
	  var ret = bufferShim.allocUnsafe(n >>> 0);
	  var p = this.head;
	  var i = 0;
	  while (p) {
	    p.data.copy(ret, i);
	    i += p.data.length;
	    p = p.next;
	  }
	  return ret;
	};

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var Buffer = __webpack_require__(4).Buffer;
	
	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }
	
	
	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}
	
	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }
	
	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};
	
	
	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;
	
	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;
	
	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }
	
	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);
	
	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
	
	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;
	
	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }
	
	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);
	
	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }
	
	  charStr += buffer.toString(this.encoding, 0, end);
	
	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }
	
	  // or just emit the charStr
	  return charStr;
	};
	
	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;
	
	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];
	
	    // See http://en.wikipedia.org/wiki/UTF-8#Description
	
	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }
	
	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }
	
	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};
	
	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);
	
	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }
	
	  return res;
	};
	
	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}
	
	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}
	
	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(35)


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(42)


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.
	
	'use strict';
	
	module.exports = Transform;
	
	var Duplex = __webpack_require__(35);
	
	/*<replacement>*/
	var util = __webpack_require__(32);
	util.inherits = __webpack_require__(22);
	/*</replacement>*/
	
	util.inherits(Transform, Duplex);
	
	function TransformState(stream) {
	  this.afterTransform = function (er, data) {
	    return afterTransform(stream, er, data);
	  };
	
	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	  this.writeencoding = null;
	}
	
	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;
	
	  var cb = ts.writecb;
	
	  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));
	
	  ts.writechunk = null;
	  ts.writecb = null;
	
	  if (data !== null && data !== undefined) stream.push(data);
	
	  cb(er);
	
	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}
	
	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);
	
	  Duplex.call(this, options);
	
	  this._transformState = new TransformState(this);
	
	  var stream = this;
	
	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;
	
	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	
	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;
	
	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }
	
	  // When the writable side finishes, then flush out anything remaining.
	  this.once('prefinish', function () {
	    if (typeof this._flush === 'function') this._flush(function (er, data) {
	      done(stream, er, data);
	    });else done(stream);
	  });
	}
	
	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};
	
	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  throw new Error('_transform() is not implemented');
	};
	
	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};
	
	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;
	
	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	
	function done(stream, er, data) {
	  if (er) return stream.emit('error', er);
	
	  if (data !== null && data !== undefined) stream.push(data);
	
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;
	
	  if (ws.length) throw new Error('Calling transform done when ws.length != 0');
	
	  if (ts.transforming) throw new Error('Calling transform done when still transforming');
	
	  return stream.push(null);
	}

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(44)


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.
	
	'use strict';
	
	module.exports = PassThrough;
	
	var Transform = __webpack_require__(42);
	
	/*<replacement>*/
	var util = __webpack_require__(32);
	util.inherits = __webpack_require__(22);
	/*</replacement>*/
	
	util.inherits(PassThrough, Transform);
	
	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);
	
	  Transform.call(this, options);
	}
	
	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var Buffer = __webpack_require__(4).Buffer
	
	module.exports = function (buf) {
		// If the buffer is backed by a Uint8Array, a faster version will work
		if (buf instanceof Uint8Array) {
			// If the buffer isn't a subarray, return the underlying ArrayBuffer
			if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
				return buf.buffer
			} else if (typeof buf.buffer.slice === 'function') {
				// Otherwise we need to get a proper copy
				return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
			}
		}
	
		if (Buffer.isBuffer(buf)) {
			// This is the slow version that will work with any Buffer
			// implementation (even in old browsers)
			var arrayCopy = new Uint8Array(buf.length)
			var len = buf.length
			for (var i = 0; i < len; i++) {
				arrayCopy[i] = buf[i]
			}
			return arrayCopy.buffer
		} else {
			throw new Error('Argument must be a Buffer')
		}
	}


/***/ },
/* 46 */
/***/ function(module, exports) {

	module.exports = extend
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	function extend() {
	    var target = {}
	
	    for (var i = 0; i < arguments.length; i++) {
	        var source = arguments[i]
	
	        for (var key in source) {
	            if (hasOwnProperty.call(source, key)) {
	                target[key] = source[key]
	            }
	        }
	    }
	
	    return target
	}


/***/ },
/* 47 */
/***/ function(module, exports) {

	module.exports = {
	  "100": "Continue",
	  "101": "Switching Protocols",
	  "102": "Processing",
	  "200": "OK",
	  "201": "Created",
	  "202": "Accepted",
	  "203": "Non-Authoritative Information",
	  "204": "No Content",
	  "205": "Reset Content",
	  "206": "Partial Content",
	  "207": "Multi-Status",
	  "208": "Already Reported",
	  "226": "IM Used",
	  "300": "Multiple Choices",
	  "301": "Moved Permanently",
	  "302": "Found",
	  "303": "See Other",
	  "304": "Not Modified",
	  "305": "Use Proxy",
	  "307": "Temporary Redirect",
	  "308": "Permanent Redirect",
	  "400": "Bad Request",
	  "401": "Unauthorized",
	  "402": "Payment Required",
	  "403": "Forbidden",
	  "404": "Not Found",
	  "405": "Method Not Allowed",
	  "406": "Not Acceptable",
	  "407": "Proxy Authentication Required",
	  "408": "Request Timeout",
	  "409": "Conflict",
	  "410": "Gone",
	  "411": "Length Required",
	  "412": "Precondition Failed",
	  "413": "Payload Too Large",
	  "414": "URI Too Long",
	  "415": "Unsupported Media Type",
	  "416": "Range Not Satisfiable",
	  "417": "Expectation Failed",
	  "418": "I'm a teapot",
	  "421": "Misdirected Request",
	  "422": "Unprocessable Entity",
	  "423": "Locked",
	  "424": "Failed Dependency",
	  "425": "Unordered Collection",
	  "426": "Upgrade Required",
	  "428": "Precondition Required",
	  "429": "Too Many Requests",
	  "431": "Request Header Fields Too Large",
	  "451": "Unavailable For Legal Reasons",
	  "500": "Internal Server Error",
	  "501": "Not Implemented",
	  "502": "Bad Gateway",
	  "503": "Service Unavailable",
	  "504": "Gateway Timeout",
	  "505": "HTTP Version Not Supported",
	  "506": "Variant Also Negotiates",
	  "507": "Insufficient Storage",
	  "508": "Loop Detected",
	  "509": "Bandwidth Limit Exceeded",
	  "510": "Not Extended",
	  "511": "Network Authentication Required"
	}


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	var http = __webpack_require__(19);
	
	var https = module.exports;
	
	for (var key in http) {
	    if (http.hasOwnProperty(key)) https[key] = http[key];
	};
	
	https.request = function (params, cb) {
	    if (!params) params = {};
	    params.scheme = 'https';
	    params.protocol = 'https:';
	    return http.request.call(this, params, cb);
	}


/***/ },
/* 49 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 50 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var defaultParams = {
	    proportions: 0.5,
	    cornerSize: 20
	};
	
	exports.default = defaultParams;

/***/ },
/* 51 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 *
	 * @param title {String}
	 * @param urls {Object}
	 * @param urls.eot {String}
	 * @param urls.ttf {String}
	 * @param urls.woff {String}
	 * @param urls.woff2 {String}
	 * @param urls.svg {String}
	 */
	function fontLoader(title, urls) {
	
	  var fontFace = '@font-face {font-family: \'' + title + '\';\n    src: url(\'' + (urls.eot || '') + '\');\n    src: url(\'' + (urls.eot || '') + '?#iefix\') format(\'embedded-opentype\'),\n      url(\'' + (urls.woff2 || '') + '\') format(\'woff2\'),\n      url(\'' + (urls.woff || '') + '\') format(\'woff\'),\n      url(\'' + (urls.ttf || '') + '\') format(\'truetype\'),\n      url(\'' + (urls.svg || '') + '\') format(\'svg\');\n    font-weight: normal;\n    font-style: normal;\n  }';
	
	  this.fonts[title] = urls;
	
	  var style = document.createElement('style');
	  style.innerText = fontFace;
	  document.head.appendChild(style);
	
	  var forceCall = document.createElement('span');
	  forceCall.innerText = '&nbsp;';
	  forceCall.style.fontFamily = title;
	  forceCall.style.textIndent = '-99999px';
	  forceCall.style.position = 'absolute';
	  forceCall.style.zIndex = '0';
	  forceCall.style.left = '-9999px';
	  forceCall.style.top = '-9999px';
	
	  document.body.appendChild(forceCall);
	}
	
	exports.default = fontLoader;

/***/ },
/* 52 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var errors = {
	  sideNoSize: {
	    code: 1,
	    message: 'Side has no size'
	  },
	  sideNoBorder: {
	    code: 2,
	    message: 'Side has no work area'
	  },
	  HTMLElementUndefined: {
	    code: 3,
	    message: 'DrawTool: Target should be a HTMLElement'
	  }
	};
	
	exports.default = errors;

/***/ },
/* 53 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	function escapeJSON(string) {
	
	  var str = string.replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
	
	  return str;
	}
	
	exports.default = escapeJSON;

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _fabric = __webpack_require__(3);
	
	function uuid() {
	  return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	    var r = Math.random() * 16 | 0,
	        v = c == 'x' ? r : r & 0x3 | 0x8;
	    return v.toString(16);
	  });
	}
	
	_fabric.fabric.Object.prototype.setOptions = function (setOptions) {
	  return function (options) {
	    setOptions.apply(this, [options]);
	    this.uuid = this.uuid || uuid();
	  };
	}(_fabric.fabric.Object.prototype.setOptions);
	
	_fabric.fabric.Object.prototype.toObject = function (toObject) {
	  return function (propertiesToInclude) {
	    propertiesToInclude = (propertiesToInclude || []).concat(['uuid']);
	    return toObject.apply(this, [propertiesToInclude]);
	  };
	}(_fabric.fabric.Object.prototype.toObject);

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _fabric = __webpack_require__(3);
	
	var _DrawTool = __webpack_require__(1);
	
	var _DrawTool2 = _interopRequireDefault(_DrawTool);
	
	var _Side = __webpack_require__(56);
	
	var _Side2 = _interopRequireDefault(_Side);
	
	var _escapeJSON = __webpack_require__(53);
	
	var _escapeJSON2 = _interopRequireDefault(_escapeJSON);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Sides class
	 */
	var Sides = function () {
	  function Sides() {
	    _classCallCheck(this, Sides);
	
	    this._collection = [];
	    /**
	     * Currently selected side
	     * @default null
	     * @type {Side}
	     */
	    this.selected = null;
	  }
	
	  /**
	   * Adding a side
	   * @param id
	   * @return {Side}
	   */
	
	
	  _createClass(Sides, [{
	    key: 'addSide',
	    value: function addSide(id) {
	      var newSide = new _Side2.default(id);
	      this._collection.push(newSide);
	      return newSide;
	    }
	
	    /**
	     * Get side as plain JAvaScript object.
	     * @param id {String} Id of side
	     * @return sides {Object}
	     */
	
	  }, {
	    key: 'getSide',
	    value: function getSide(id) {
	      return this._collection.find(function (side) {
	        return side.id === id;
	      });
	    }
	
	    /**
	     * Select side
	     * @param id {String}
	     */
	
	  }, {
	    key: 'select',
	    value: function select(id) {
	
	      this.selected = this._collection.find(function (side) {
	        return side.id === id;
	      });
	
	      if (!this.selected) {
	        return false;
	      }
	
	      this._collection.forEach(function (side) {
	        return side.FabricCanvas.wrapperEl.style.display = 'none';
	      });
	      this.selected.FabricCanvas.wrapperEl.style.display = 'block';
	
	      return this.selected;
	    }
	
	    /**
	     * Getting whole collection as JSON
	     * @return {String}
	     */
	
	  }, {
	    key: 'toJSON',
	    value: function toJSON() {
	
	      var sides = [];
	
	      this._collection.forEach(function (side) {
	        sides.push(side.toObject());
	      });
	
	      return JSON.stringify(sides);
	    }
	
	    /**
	     * Remove side by id
	     * @param id
	     * @return {boolean}
	     */
	
	  }, {
	    key: 'removeSide',
	    value: function removeSide(id) {
	      var side = this._collection.find(function (side) {
	        return side.id === id;
	      });
	      var index = this._collection.findIndex(function (side) {
	        return side.id === id;
	      });
	
	      if (!side) return false;
	
	      side.FabricCanvas.clear();
	      side.FabricCanvas = undefined;
	      side.canvas.parentNode.removeChild(side.canvas);
	
	      this.selected = null;
	
	      this._collection.splice(index, 1);
	
	      return true;
	    }
	
	    /**
	     * Empty sides
	     * @return {Array}
	     */
	
	  }, {
	    key: 'empty',
	    value: function empty() {
	      var _this = this;
	
	      var collection = this._collection.map(function (side) {
	        return side.id;
	      });
	
	      collection.forEach(function (id) {
	        _this.removeSide(id);
	      });
	
	      return this._collection;
	    }
	  }]);
	
	  return Sides;
	}();
	
	exports.default = Sides;

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _fabric = __webpack_require__(3);
	
	var _DrawTool = __webpack_require__(1);
	
	var _DrawTool2 = _interopRequireDefault(_DrawTool);
	
	var _Items = __webpack_require__(57);
	
	var _Items2 = _interopRequireDefault(_Items);
	
	var _Layers = __webpack_require__(60);
	
	var _Layers2 = _interopRequireDefault(_Layers);
	
	var _errors = __webpack_require__(52);
	
	var _errors2 = _interopRequireDefault(_errors);
	
	var _escapeJSON = __webpack_require__(53);
	
	var _escapeJSON2 = _interopRequireDefault(_escapeJSON);
	
	var _colorPicker = __webpack_require__(61);
	
	var _colorPicker2 = _interopRequireDefault(_colorPicker);
	
	var _clip = __webpack_require__(59);
	
	var _clip2 = _interopRequireDefault(_clip);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Side class
	 */
	var Side = function () {
	
	  /**
	   * Side constructor
	   * @param id {String}
	   */
	  function Side(id) {
	    _classCallCheck(this, Side);
	
	    var that = this;
	
	    /**
	     *
	     * @type {String}
	     */
	    this.id = id;
	
	    /**
	     *
	     * @type {HTMLElement}
	     */
	    this.container = document.createElement('div');
	
	    /**
	     *
	     * @type {HTMLElement}
	     */
	    this.canvas = document.createElement('canvas');
	
	    /**
	     * @type {Number}
	     */
	    this.padding = 10;
	
	    /**
	     * Canvas panning
	     * @default false
	     * @type {Boolean}
	     */
	    this._panning = false;
	
	    /**
	     * Backdrop image url
	     * @type {string}
	     */
	    this.imageUrl = null;
	
	    this.container.width = _DrawTool2.default.container.size.width || _DrawTool2.default.container.target.clientWidth;
	    this.container.height = _DrawTool2.default.container.size.height || _DrawTool2.default.container.target.clientHeight;
	    this.container.style.position = 'absolute';
	    this.container.style.top = '0';
	    this.container.style.left = '0';
	
	    this.canvas.width = _DrawTool2.default.container.size.width || _DrawTool2.default.container.target.clientWidth;
	    this.canvas.height = _DrawTool2.default.container.size.height || _DrawTool2.default.container.target.clientHeight;
	
	    this.container.appendChild(this.canvas);
	
	    _DrawTool2.default.container.target.appendChild(this.container);
	
	    this._initFabric();
	    this._initEvents();
	
	    this.items = new _Items2.default(this);
	
	    this.layers = new _Layers2.default(this);
	
	    this.currentBrush = 'PencilBrush';
	
	    this.colorPicker = new _colorPicker2.default(this);
	
	    return this;
	  }
	
	  _createClass(Side, [{
	    key: 'setImage',
	
	
	    /**
	     * Set side image
	     * @param {String} url
	     * @param size {Object} size
	     * @param size.width {Number} Width of image in centimeters
	     * @param size.height {Number} Height of image in centimeters
	     * @param proportions {Number}
	     * @param borderSize {Object}
	     * @return {Promise}
	     */
	    value: function setImage(url, size) {
	      var _this = this;
	
	      var proportions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
	      var borderSize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	
	
	      this.size = size;
	
	      this.imageUrl = url;
	
	      var center = this.FabricCanvas.getCenter();
	
	      return new Promise(function (resolve, reject) {
	
	        _this.FabricCanvas.setBackgroundColor('#ffffff');
	
	        _this.FabricCanvas.setBackgroundImage(url, function (img) {
	
	          _this.backdrop = _this.FabricCanvas.backgroundImage;
	
	          _this.backdrop.excludeFromExport = true;
	
	          var canvasAspectRatio = _this.canvas.width / _this.canvas.height;
	          var borderAspectRatio = borderSize.width / borderSize.height;
	
	          if (canvasAspectRatio < borderAspectRatio) {
	            var canvasProportions = _this.FabricCanvas.width / _this.size.width;
	            _this.bgProportions = _this.FabricCanvas.width * proportions / (borderSize.width * canvasProportions);
	
	            _this.backdrop.scaleToWidth(_this.size.width * canvasProportions * _this.bgProportions);
	          } else {
	            var _canvasProportions = _this.FabricCanvas.height / _this.size.height;
	            _this.bgProportions = _this.FabricCanvas.height * proportions / (borderSize.height * _canvasProportions);
	
	            _this.backdrop.scaleToHeight(_this.size.height * _canvasProportions * _this.bgProportions);
	          }
	
	          _this._setOffset(borderSize);
	
	          _this.FabricCanvas.backgroundImage.top -= _this.bgOffset.top;
	          _this.FabricCanvas.backgroundImage.left -= _this.bgOffset.left;
	
	          _this.cmSize = _this._calculateSize();
	
	          _this.FabricCanvas.renderAll();
	
	          _DrawTool2.default.trigger('backdrop:loaded', { side: { id: _this.id } });
	
	          _DrawTool2.default.history.pushState(_this.id);
	          resolve({ side: { id: _this.id } });
	        }, {
	          top: center.top,
	          left: center.left,
	          originX: 'center',
	          originY: 'center',
	          opacity: 1,
	          crossOrigin: 'anonymous'
	        });
	      });
	    }
	
	    /**
	     * Update image size
	     * @param size
	     * @param size {Object} size
	     * @param size.width {Number} Width of image in centimeters
	     * @param size.height {Number} Height of image in centimeters
	     */
	
	  }, {
	    key: 'updateSize',
	    value: function updateSize(size) {
	
	      this.size = size;
	
	      this.cmSize = this._calculateSize();
	
	      this.initGrid();
	      this.initRuler();
	
	      if (this.FabricBorder) {
	        this.initWorkspaceGrid();
	        this.initWorkspaceRuler();
	      }
	
	      return this;
	    }
	
	    /**
	     * Remove image
	     */
	
	  }, {
	    key: 'removeImage',
	    value: function removeImage() {
	      this.FabricCanvas.remove(this.backdrop);
	      this.backdrop = undefined;
	      this.FabricCanvas.renderAll();
	      return this;
	    }
	
	    /**
	     *
	     * @param options {Object} options
	     * @param options.width {Number} Width of border
	     * @param options.height {Number} Height of border
	     * @param options.top {Number} Top position
	     * @param options.left {Number} Left position
	     */
	
	  }, {
	    key: 'setBorder',
	    value: function setBorder(options) {
	
	      if (!this.cmSize) {
	        throw new Error(JSON.stringify({ error: _errors2.default.sideNoSize }));
	        return false;
	      }
	
	      if (!options) {
	        return false;
	      }
	
	      if (this.FabricBorder) {
	        this.FabricBorder.remove();
	      }
	
	      this.border = options;
	
	      var _opts = {
	        strokeWidth: _DrawTool2.default.border.strokeWidth,
	        stroke: _DrawTool2.default.border.color,
	        fill: _DrawTool2.default.border.backgroundColor,
	        hasRotatingPoint: false,
	        lockRotation: true,
	        strokeDashArray: _DrawTool2.default.border.strokeDashArray
	      };
	
	      var paddingTop = (this.FabricCanvas.height - this.backdrop.height * this.backdrop.scaleY) / 2;
	      var paddingLeft = (this.FabricCanvas.width - this.backdrop.width * this.backdrop.scaleX) / 2;
	
	      var _options = {
	        width: options.width * this.cmSize.width,
	        height: options.height * this.cmSize.height,
	        top: options.top * this.cmSize.height + paddingTop - this.bgOffset.top,
	        left: options.left * this.cmSize.width + paddingLeft - this.bgOffset.left
	      };
	
	      this.FabricBorder = new _fabric.fabric.Rect(_extends({}, _opts, _options));
	
	      this.FabricBorder.setCoords();
	      this.FabricBorder.id = 'FabricBorder';
	
	      this.FabricBorder.excludeFromExport = true;
	      this.FabricBorder.selectable = _DrawTool2.default.editable;
	      this.FabricBorder.hoverCursor = 'default';
	
	      this.FabricCanvas.add(this.FabricBorder);
	      this.center = this.FabricBorder.getCenterPoint();
	
	      this.FabricCanvas.renderAll();
	
	      return this;
	    }
	
	    /**
	     * Get border
	     * @return { cm: {left: number, top: number, width: number, height: number}, pixel: {}}
	     */
	
	  }, {
	    key: 'getBorder',
	    value: function getBorder() {
	
	      var paddingTop = (this.FabricCanvas.height - this.backdrop.height * this.backdrop.scaleY) / 2;
	      var paddingLeft = (this.FabricCanvas.width - this.backdrop.width * this.backdrop.scaleX) / 2;
	
	      return {
	        cm: {
	          left: (this.FabricBorder.left + this.bgOffset.left - paddingLeft) / this.cmSize.width,
	          top: (this.FabricBorder.top + this.bgOffset.top - paddingTop) / this.cmSize.height,
	          width: this.FabricBorder.width * this.FabricBorder.scaleX / this.cmSize.width,
	          height: this.FabricBorder.height * this.FabricBorder.scaleY / this.cmSize.height
	        },
	        pixel: {
	          left: this.FabricBorder.left + this.bgOffset.left - paddingLeft,
	          top: this.FabricBorder.top + this.bgOffset.top - paddingTop,
	          width: this.FabricBorder.width * this.FabricBorder.scaleX,
	          height: this.FabricBorder.height * this.FabricBorder.scaleY
	        }
	      };
	    }
	  }, {
	    key: 'zoomToVal',
	    value: function zoomToVal(val) {
	      var center = this.FabricBorder.getCenterPoint();
	      this.FabricCanvas.zoomToPoint(center, val);
	      return this;
	    }
	
	    /**
	     * Zoom relative to border
	     * @return {Side}
	     */
	
	  }, {
	    key: 'zoomIn',
	    value: function zoomIn() {
	      var zoom = this.FabricCanvas.getZoom();
	      if (zoom <= 2) {
	        var center = this.FabricBorder.getCenterPoint();
	        this.FabricCanvas.zoomToPoint(center, zoom * 1.1);
	      }
	      return this;
	    }
	
	    /**
	     * Zoom relative to border
	     * @return {Side}
	     */
	
	  }, {
	    key: 'zoomOut',
	    value: function zoomOut() {
	      var zoom = this.FabricCanvas.getZoom();
	      if (zoom >= 0.2) {
	        var center = this.FabricBorder.getCenterPoint();
	        this.FabricCanvas.zoomToPoint(center, zoom / 1.1);
	      }
	      return this;
	    }
	
	    /**
	     * Zoom relative to viewport
	     * @return {Side}
	     */
	
	  }, {
	    key: 'zoomInVP',
	    value: function zoomInVP() {
	      var zoom = this.FabricCanvas.getZoom();
	      var center = new _fabric.fabric.Point(this.FabricCanvas.getWidth() / 2, this.FabricCanvas.getHeight() / 2);
	      this.FabricCanvas.zoomToPoint(center, zoom * 1.1);
	
	      return this;
	    }
	
	    /**
	     * Zoom relative to viewport
	     * @return {Side}
	     */
	
	  }, {
	    key: 'zoomOutVP',
	    value: function zoomOutVP() {
	      var zoom = this.FabricCanvas.getZoom();
	      var center = new _fabric.fabric.Point(this.FabricCanvas.getWidth() / 2, this.FabricCanvas.getHeight() / 2);
	      this.FabricCanvas.zoomToPoint(center, zoom / 1.1);
	
	      return this;
	    }
	
	    /**
	     * Get
	     * @return {Object}
	     */
	
	  }, {
	    key: 'toObject',
	    value: function toObject() {
	      var _this2 = this;
	
	      var _formattedSide = {
	        id: this.id,
	        imageUrl: this.imageUrl,
	        size: this.size,
	        canvas: this.FabricCanvas.toObject(['brush', 'editable', 'vertical']),
	        fonts: _DrawTool2.default.fonts
	      };
	
	      _formattedSide.canvas.objects.forEach(function (item) {
	        item.left = item.left - _this2.center.x;
	        item.top = item.top - _this2.center.y;
	        item.clipTo = null;
	
	        if (item.selected) {
	          item.selectable = false;
	        }
	      });
	
	      if (this.backdrop) {
	
	        _formattedSide.imageUrl = this.imageUrl;
	      }
	
	      if (this.FabricBorder) {
	
	        _formattedSide.border = this.getBorder();
	
	        _formattedSide.factor = {
	          x: this.getBorder().pixel.width / this.defaultWorkspaceSize.width,
	          y: this.getBorder().pixel.height / this.defaultWorkspaceSize.height
	        };
	      }
	
	      return _formattedSide;
	    }
	
	    /**
	     * Get
	     * @return {String}
	     */
	
	  }, {
	    key: 'toJSON',
	    value: function toJSON() {
	      return JSON.stringify(this.toObject());
	    }
	
	    /**
	     *
	     * @param {String} json
	     */
	
	  }, {
	    key: 'fromJSON',
	    value: function fromJSON(json) {
	      var _this3 = this;
	
	      var data = JSON.parse((0, _escapeJSON2.default)(json));
	
	      this._removeEvents();
	
	      this.items._collection = [];
	
	      var canvasData = JSON.stringify({ objects: data.canvas.objects });
	
	      this.FabricCanvas.loadFromJSON(canvasData, function () {
	        if (_this3.backdrop) {
	          _this3.FabricCanvas.backgroundImage = _this3.backdrop;
	        }
	        _this3.setBorder(_this3.border);
	        _this3.FabricBorder.sendToBack();
	        _this3.FabricCanvas.renderAll.bind(_this3.FabricCanvas);
	        _this3._initEvents();
	      }, function (o, item) {
	
	        item.set({
	          left: _this3.center.x + item.left / data.factor.x * ((_this3.getBorder().pixel.left || 1) / (_this3.defaultWorkspaceSize.left || 1)),
	          top: _this3.center.y + item.top / data.factor.y * ((_this3.getBorder().pixel.top || 1) / (_this3.defaultWorkspaceSize.top || 1)),
	          scaleX: item.scaleX / data.factor.x * (_this3.getBorder().pixel.width / _this3.defaultWorkspaceSize.width),
	          scaleY: item.scaleY / data.factor.y * (_this3.getBorder().pixel.height / _this3.defaultWorkspaceSize.height),
	          clipTo: (0, _clip2.default)(_this3.FabricBorder)
	        });
	
	        _this3.items._collection.push(item);
	      });
	    }
	
	    /**
	     *
	     */
	
	  }, {
	    key: 'toSVG',
	    value: function toSVG(callback) {
	      var _this4 = this;
	
	      var withoutBg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	
	
	      if (!this.cmSize) {
	        throw new Error(JSON.stringify({ error: _errors2.default.sideNoSize }));
	        return false;
	      }
	
	      if (!this.FabricBorder) {
	        throw new Error(JSON.stringify({ error: _errors2.default.sideNoBorder }));
	        return false;
	      }
	
	      this.FabricCanvas.clone(function (clone) {
	
	        clone.forEachObject(function (item) {
	          if (item.type === 'i-text') {
	            item.clipTo = null;
	            var base64 = item.toDataURL({ enableRetina: true });
	            var image = new Image();
	            image.src = base64;
	            var fabricImage = new _fabric.fabric.Image(image, {
	              top: item.top,
	              left: item.left,
	              // width: item.width,
	              // height: item.height,
	              scaleX: item.scaleX,
	              scaleY: item.scaleY,
	              originX: 'center',
	              originY: 'center'
	            });
	            var index = clone.getObjects().indexOf(item);
	            clone.add(fabricImage);
	            fabricImage.moveTo(index);
	            fabricImage.setCoords();
	            item.remove();
	            clone.renderAll();
	          }
	        });
	
	        var svg = clone.toSVG({
	          suppressPreamble: true,
	          viewBox: {
	            x: _this4.FabricBorder.left,
	            y: _this4.FabricBorder.top,
	            width: _this4.FabricBorder.width,
	            height: _this4.FabricBorder.height
	          }
	        }, function (el) {
	          if (!el.includes(_this4.imageUrl)) {
	            return el;
	          }
	        });
	
	        var parser = new DOMParser();
	        var doc = parser.parseFromString(svg, "image/svg+xml");
	
	        var svgObj = doc.getElementsByTagName('svg')[0];
	
	        svgObj.setAttribute('width', _this4.FabricBorder.width);
	        svgObj.setAttribute('height', _this4.FabricBorder.height);
	        svgObj.setAttribute('style', 'background-color: transparent');
	
	        if (withoutBg) {
	          var rect = svgObj.getElementsByTagName('rect')[0];
	
	          if (typeof rect !== 'undefined') rect.setAttribute('fill', 'none');
	        }
	
	        var container = document.createElement('div');
	
	        container.appendChild(svgObj);
	
	        callback && callback(container.innerHTML);
	      });
	    }
	
	    /**
	     *
	     * @return {String} Base 64 representation of canvas
	     */
	
	  }, {
	    key: 'getPreview',
	    value: function getPreview() {
	
	      this.FabricBorder.setVisible(false);
	
	      var zoom = this.FabricCanvas.getZoom();
	      var center = this.FabricCanvas.getVpCenter();
	
	      this.FabricCanvas.setZoom(1);
	      this.FabricCanvas.absolutePan({ x: 0, y: 0 });
	
	      var preview = this.FabricCanvas.toDataURL({
	        multiplier: 0.5
	      });
	      this.FabricBorder.setVisible(true);
	
	      this.FabricCanvas.setZoom(zoom);
	      this.FabricCanvas.absolutePan({ x: center.x * zoom - this.FabricCanvas.getWidth() / 2, y: center.y * zoom - this.FabricCanvas.getHeight() / 2 });
	
	      this.FabricCanvas.renderAll();
	
	      return preview;
	    }
	
	    /**
	     *
	     * @return {String} Base 64 representation of canvas
	     */
	
	  }, {
	    key: 'getImagePreview',
	    value: function getImagePreview() {
	
	      this.FabricBorder.setVisible(false);
	      this.backdrop.setVisible(false);
	
	      var zoom = this.FabricCanvas.getZoom();
	      var center = this.FabricCanvas.getVpCenter();
	
	      this.FabricCanvas.setZoom(1);
	      this.FabricCanvas.absolutePan({ x: 0, y: 0 });
	
	      var preview = this.FabricCanvas.toDataURL({
	        multiplier: 0.5,
	        left: this.FabricBorder.left,
	        top: this.FabricBorder.top,
	        width: this.FabricBorder.width,
	        height: this.FabricBorder.height
	      });
	      this.FabricBorder.setVisible(true);
	      this.backdrop.setVisible(true);
	
	      this.FabricCanvas.setZoom(zoom);
	      this.FabricCanvas.absolutePan({ x: center.x * zoom - this.FabricCanvas.getWidth() / 2, y: center.y * zoom - this.FabricCanvas.getHeight() / 2 });
	
	      this.FabricCanvas.renderAll();
	
	      return preview;
	    }
	  }, {
	    key: 'drawingMode',
	    value: function drawingMode(val) {
	      if (val === undefined) {
	        return this.FabricCanvas.isDrawingMode;
	      }
	
	      if (this.panning === true) {
	        return false;
	      }
	
	      this.FabricCanvas.isDrawingMode = val;
	      this.FabricCanvas.freeDrawingBrush = new _fabric.fabric.PencilBrushC(this.FabricCanvas, { color: '#000000' });
	      this.currentBrush = 'PencilBrush';
	    }
	
	    /**
	     * @private
	     */
	
	  }, {
	    key: '_initFabric',
	    value: function _initFabric() {
	
	      this.FabricCanvas = new _fabric.fabric.Canvas(this.canvas, {
	        selection: false,
	        enableRetinaScaling: true,
	        preserveObjectStacking: true
	      });
	
	      this.FabricCanvas.wrapperEl.style.display = 'none';
	
	      this.FabricCanvas.upperCanvasEl.style['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
	      this.FabricCanvas.lowerCanvasEl.style['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
	    }
	
	    /**
	     * @private
	     */
	
	  }, {
	    key: '_initEvents',
	    value: function _initEvents() {
	      var _this5 = this;
	
	      this.FabricCanvas.on({
	        'object:added': function objectAdded(e) {
	          if (!e.target.excludeFromExport) {
	            _DrawTool2.default.trigger('object:added', { side: { id: _this5.id }, item: e.target.toObject(['brush', 'editable', 'vertical', 'uuid']).uuid });
	          }
	        },
	        'selection:cleared': function selectionCleared(e) {
	          if (_this5.items.selected.item) {
	            _this5.items.selected.item.selected = false;
	          }
	          _this5.items.selected.item = null;
	          _DrawTool2.default.trigger('selection:cleared', e);
	        },
	        'selection:created': function selectionCreated(e) {
	          _DrawTool2.default.trigger('selection:created', e);
	        },
	        'object:selected': function objectSelected(e) {
	          if (e.target.id === 'FabricBorder') {
	            e.target.setCoords();
	            _this5.center = _this5.FabricBorder.getCenterPoint();
	          }
	          _this5.items.selected.item = e.target;
	          _this5.items.selected.item.selected = true;
	          _DrawTool2.default.trigger('object:selected', { side: { id: _this5.id }, isWorkSpaceBorder: e.target.id === 'FabricBorder' });
	        },
	        'object:modified': function objectModified(e) {
	          if (e.target.id === 'FabricBorder') {
	            e.target.setCoords();
	            _this5.center = _this5.FabricBorder.getCenterPoint();
	            _this5.initWorkspaceGrid();
	            _this5.initWorkspaceRuler();
	          }
	          _DrawTool2.default.trigger('object:modified', { side: { id: _this5.id }, isWorkSpaceBorder: e.target.id === 'FabricBorder', item: e.target.toObject(['brush', 'editable', 'vertical', 'uuid']).uuid });
	          if (!e.target.excludeFromExport) {
	            _DrawTool2.default.trigger('history:update', { side: { id: _this5.id }, isWorkSpaceBorder: false });
	          }
	        },
	        'object:removed': function objectRemoved(e) {
	          if (e.target && !e.target.excludeFromExport) {
	            _DrawTool2.default.trigger('object:removed', { side: { id: _this5.id }, item: e.target.toObject(['brush', 'editable', 'vertical', 'uuid']).uuid });
	            _DrawTool2.default.trigger('history:update', { side: { id: _this5.id } });
	          }
	        },
	        'editing:exited': function editingExited() {
	          _DrawTool2.default.trigger('editing:exited', { side: { id: _this5.id } });
	        },
	        'editing:entered': function editingEntered() {
	          _DrawTool2.default.trigger('editing:entered', { side: { id: _this5.id } });
	        },
	        'mouse:up': function mouseUp(e) {
	          _this5._panningDown = false;
	        },
	        'mouse:down': function mouseDown(e) {
	          _this5._panningDown = true;
	
	          var touches = e.e.touches && e.e.touches.length ? e.e.touches : [e.e];
	          var evt = e.e.changedTouches && e.e.changedTouches[0] || touches[0];
	
	          _this5._pan_x0 = evt.layerX || evt.pageX || 0;
	          _this5._pan_y0 = evt.layerY || evt.pageY || 0;
	
	          if (_this5.colorPicker.active) {
	            _this5.colorPicker.move(e);
	            _DrawTool2.default.trigger('colorpicker:update', _this5.colorPicker.color);
	          }
	        },
	        'mouse:move': function mouseMove(e) {
	
	          _DrawTool2.default.trigger('mouse:move');
	
	          if (!!(_this5._panning && _this5._panningDown && e && e.e)) {
	
	            var touches = e.e.touches && e.e.touches.length ? e.e.touches : [e.e];
	            var evt = e.e.changedTouches && e.e.changedTouches[0] || touches[0];
	
	            var x = evt.layerX || evt.pageX || 0;
	            var y = evt.layerY || evt.pageY || 0;
	
	            _this5.FabricCanvas.relativePan({ x: x - _this5._pan_x0, y: y - _this5._pan_y0 });
	            _this5._pan_x0 = x;
	            _this5._pan_y0 = y;
	          }
	          if (_this5.colorPicker.active) {
	            _this5.colorPicker.move(e);
	          }
	        },
	        'object:scaling': function objectScaling(e) {
	          var obj = e.target;
	
	          if (obj.type.includes('path')) {
	            return false;
	          }
	
	          if (obj.type.includes('i-text')) {
	            return false;
	          }
	
	          var w = obj.width * obj.scaleX;
	          var h = obj.height * obj.scaleY;
	          var s = obj.strokeWidth;
	
	          obj.set({
	            'height': h,
	            'width': w,
	            'scaleX': 1,
	            'scaleY': 1
	          });
	        }
	      });
	    }
	  }, {
	    key: '_removeEvents',
	    value: function _removeEvents() {
	      this.FabricCanvas.off();
	    }
	
	    /**
	     *
	     * @private
	     */
	
	  }, {
	    key: 'initGrid',
	    value: function initGrid() {
	
	      if (!this.cmSize) {
	        throw new Error(JSON.stringify({ error: _errors2.default.sideNoSize }));
	        return false;
	      }
	
	      var state;
	
	      if (this.grid) {
	        state = this.grid.visible;
	        this.grid.destroy();
	        this.FabricCanvas.remove(this.grid);
	      } else {
	        state = false;
	      }
	
	      var cm = this.cmSize;
	
	      var stepX = cm.width;
	      var stepY = cm.height;
	
	      this.grid = new _fabric.fabric.Group(null, {
	        excludeFromExport: true,
	        hasControls: false,
	        hoverCursor: 'default',
	        selectable: false
	      });
	
	      this.FabricCanvas.add(this.grid);
	
	      this.grid.sendToBack();
	
	      this.grid.enable = function () {
	        var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	
	        this.setVisible(val);
	        this.canvas.renderAll();
	      };
	
	      this.grid.setVisible(state);
	      this.FabricCanvas.renderAll();
	    }
	
	    /**
	     *
	     * @private
	     */
	
	  }, {
	    key: 'initRuler',
	    value: function initRuler() {
	
	      if (!this.cmSize) {
	        throw new Error(JSON.stringify({ error: _errors2.default.sideNoSize }));
	        return false;
	      }
	
	      var state;
	
	      if (this.ruler) {
	        state = this.ruler.visible;
	        this.ruler.destroy();
	        this.FabricCanvas.remove(this.ruler);
	      } else {
	        state = false;
	      }
	
	      var cm = this.cmSize;
	
	      var stepX = cm.width;
	      var stepY = cm.height;
	
	      this.ruler = new _fabric.fabric.Group(null, {
	        excludeFromExport: true,
	        hasControls: false,
	        hoverCursor: 'default',
	        selectable: false
	      });
	
	      for (var x = stepX * 2; x <= this.FabricCanvas.width; x += stepX) {
	        this.ruler.add(new _fabric.fabric.Line([x, 0, x, stepY * 2], { stroke: 'rgba(0, 0, 0, 0.2)', selectable: false, hoverCursor: 'default' }));
	      }
	
	      for (var y = stepY * 2; y <= this.FabricCanvas.height; y += stepY) {
	        this.ruler.add(new _fabric.fabric.Line([0, y, stepX * 2, y], { stroke: 'rgba(0, 0, 0, 0.2)', selectable: false, hoverCursor: 'default' }));
	      }
	
	      this.FabricCanvas.add(this.ruler);
	
	      this.ruler.enable = function () {
	        var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	
	        this.setVisible(val);
	        this.canvas.renderAll();
	      };
	
	      this.ruler.setVisible(state);
	      this.FabricCanvas.renderAll();
	    }
	
	    /**
	     *
	     * @private
	     */
	
	  }, {
	    key: 'initWorkspaceGrid',
	    value: function initWorkspaceGrid() {
	
	      if (!this.cmSize) {
	        throw new Error(JSON.stringify({ error: _errors2.default.sideNoSize }));
	        return false;
	      }
	
	      var state;
	
	      if (this.workspaceGrid) {
	        state = this.workspaceGrid.visible;
	        this.workspaceGrid.destroy();
	        this.FabricCanvas.remove(this.workspaceGrid);
	      } else {
	        state = false;
	      }
	
	      var cm = this.cmSize;
	
	      this.workspaceGrid = new _fabric.fabric.Group(null, {
	        excludeFromExport: true,
	        hasControls: false,
	        hoverCursor: 'default',
	        selectable: false
	      });
	
	      for (var x = this.FabricBorder.left; x <= this.FabricBorder.left + this.FabricBorder.width; x += cm.width) {
	        this.workspaceGrid.add(new _fabric.fabric.Line([x, this.FabricBorder.top, x, this.FabricBorder.top + this.FabricBorder.height], { stroke: _DrawTool2.default.grid.color, strokeWidth: _DrawTool2.default.grid.strokeWidth, selectable: false, hoverCursor: 'default' }));
	      }
	
	      for (var y = this.FabricBorder.top; y <= this.FabricBorder.top + this.FabricBorder.height; y += cm.height) {
	        this.workspaceGrid.add(new _fabric.fabric.Line([this.FabricBorder.left, y, this.FabricBorder.left + this.FabricBorder.width, y], { stroke: _DrawTool2.default.grid.color, strokeWidth: _DrawTool2.default.grid.strokeWidth, selectable: false, hoverCursor: 'default' }));
	      }
	
	      this.FabricCanvas.add(this.workspaceGrid);
	
	      this.grid.sendToBack();
	
	      this.workspaceGrid.enable = function () {
	        var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	
	        this.setVisible(val);
	        this.canvas.renderAll();
	      };
	
	      this.workspaceGrid.setVisible(state);
	      this.FabricCanvas.renderAll();
	    }
	
	    /**
	     *
	     * @private
	     */
	
	  }, {
	    key: 'initWorkspaceRuler',
	    value: function initWorkspaceRuler() {
	
	      if (!this.cmSize) {
	        throw new Error(JSON.stringify({ error: _errors2.default.sideNoSize }));
	        return false;
	      }
	
	      var state;
	
	      if (this.workspaceRuler) {
	        state = this.workspaceRuler.visible;
	        this.workspaceRuler.destroy();
	        this.FabricCanvas.remove(this.workspaceRuler);
	      } else {
	        state = false;
	      }
	
	      var cm = this.cmSize;
	
	      this.workspaceRuler = new _fabric.fabric.Group(null, {
	        excludeFromExport: true,
	        hasControls: false,
	        hoverCursor: 'default',
	        selectable: false
	      });
	
	      for (var x = this.FabricBorder.left; x <= this.FabricBorder.left + this.FabricBorder.width; x += cm.width) {
	        this.workspaceRuler.add(new _fabric.fabric.Line([x, cm.height, x, cm.height * 2], { stroke: 'rgba(0, 0, 0, 0.2)', selectable: false, hoverCursor: 'default' }));
	      }
	
	      for (var y = this.FabricBorder.top; y <= this.FabricBorder.top + this.FabricBorder.height; y += cm.height) {
	        this.workspaceRuler.add(new _fabric.fabric.Line([cm.width, y, cm.width * 2, y], { stroke: 'rgba(0, 0, 0, 0.2)', selectable: false, hoverCursor: 'default' }));
	      }
	
	      this.workspaceRuler.add(new _fabric.fabric.Line([this.FabricBorder.left, cm.height * 1.5, this.FabricBorder.left + this.FabricBorder.width, cm.height * 1.5], { stroke: 'rgba(0, 0, 0, 0.2)', selectable: false, hoverCursor: 'default' }));
	      this.workspaceRuler.add(new _fabric.fabric.Line([cm.width * 1.5, this.FabricBorder.top, cm.width * 1.5, this.FabricBorder.top + this.FabricBorder.height], { stroke: 'rgba(0, 0, 0, 0.2)', selectable: false, hoverCursor: 'default' }));
	
	      this.FabricCanvas.add(this.workspaceRuler);
	
	      this.workspaceRuler.enable = function () {
	        var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	
	        this.setVisible(val);
	        this.canvas.renderAll();
	      };
	
	      this.workspaceRuler.setVisible(state);
	      this.FabricCanvas.renderAll();
	    }
	
	    /**
	     * Calculate pixels in centimeter
	     * @return {Object} {width: Number, height: Number}
	     * @private
	     */
	
	  }, {
	    key: '_calculateSize',
	    value: function _calculateSize() {
	      this.cmSize = {
	        width: this.backdrop.width * this.backdrop.scaleX / this.size.width,
	        height: this.backdrop.height * this.backdrop.scaleY / this.size.height
	      };
	      return this.cmSize;
	    }
	
	    /**
	     * Calculate offset for background image and main border
	     * @param proportions {Number}
	     * @param borderSize {Object} size
	     * @param borderSize.width {Number} Width of border
	     * @param borderSize.height {Number} Height of border
	     * @private
	     */
	
	  }, {
	    key: '_setOffset',
	    value: function _setOffset(borderSize) {
	      this.bgOffset = {
	        left: 0,
	        top: 0
	      };
	
	      this.bgOffset.left = (borderSize.left - (this.size.width - borderSize.width) / 2) * this.backdrop.scaleX;
	      this.bgOffset.top = (borderSize.top - (this.size.height - borderSize.height) / 2) * this.backdrop.scaleY;
	
	      return true;
	    }
	  }, {
	    key: 'setPadding',
	    value: function setPadding(number) {
	      if (typeof number !== 'number') return false;
	
	      this.padding = number;
	
	      if (this.backdrop) {
	
	        if (this.backdrop.width >= this.backdrop.height) {
	          this.backdrop.scaleToWidth(this.FabricCanvas.width - this.padding * window.devicePixelRatio);
	        } else {
	          this.backdrop.scaleToHeight(this.FabricCanvas.height - this.padding * window.devicePixelRatio);
	        }
	
	        this._calculateSize();
	
	        this.initGrid();
	        this.initRuler();
	
	        if (this.FabricBorder) {
	          this.initWorkspaceGrid();
	          this.initWorkspaceRuler();
	
	          this.setBorder(this.border);
	        }
	
	        this.FabricCanvas.renderAll();
	      }
	    }
	  }, {
	    key: 'loadFromJSON',
	    value: function loadFromJSON(json) {
	      var _this6 = this;
	
	      this.FabricCanvas.loadFromJSON(json, function () {
	        return _this6._update();
	      });
	    }
	  }, {
	    key: '_update',
	    value: function _update() {
	      if (this.backdrop) {
	        this.FabricCanvas.backgroundImage.scaleX = this.backdrop.scaleX;
	        this.FabricCanvas.backgroundImage.scaleY = this.backdrop.scaleY;
	      }
	      if (this.FabricBorder) {
	        this.FabricCanvas.add(this.FabricBorder);
	        this.FabricBorder.sendToBack();
	      }
	      if (this.ruler) {
	        this.FabricCanvas.add(this.ruler);
	        this.ruler.setVisible(this.ruler.visible);
	      }
	      if (this.grid) {
	        this.FabricCanvas.add(this.grid);
	        this.grid.setVisible(this.grid.visible);
	      }
	
	      this.FabricCanvas.renderAll();
	    }
	  }, {
	    key: 'panning',
	    set: function set(val) {
	      if (Boolean(val) === true && this.FabricCanvas.isDrawingMode === true) {
	        return this._panning = false;
	      }
	      this.items.selected.deactivate();
	      this.items._collection.forEach(function (object) {
	        return object.selectable = !val;
	      });
	      return this._panning = val;
	    },
	    get: function get() {
	      return this._panning;
	    }
	  }]);
	
	  return Side;
	}();
	
	exports.default = Side;

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _fabric = __webpack_require__(3);
	
	var _DrawTool = __webpack_require__(1);
	
	var _DrawTool2 = _interopRequireDefault(_DrawTool);
	
	var _Item = __webpack_require__(58);
	
	var _Item2 = _interopRequireDefault(_Item);
	
	var _clip = __webpack_require__(59);
	
	var _clip2 = _interopRequireDefault(_clip);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Items collection
	 */
	var Items = function () {
	
	  /**
	   *
	   * @param side
	   */
	  function Items(side) {
	    _classCallCheck(this, Items);
	
	    this.side = side;
	    this._collection = [];
	
	    this.selected = new _Item2.default(this.side);
	  }
	
	  _createClass(Items, [{
	    key: 'getItemByUUID',
	    value: function getItemByUUID(uuid) {
	      var __item = this.side.FabricCanvas.getObjects().find(function (item) {
	        return item.uuid === uuid;
	      });
	
	      if (__item) {
	        var item = __item.toObject(['brush', 'editable', 'vertical', 'uuid']);
	        item.left = item.left - this.side.center.x;
	        item.top = item.top - this.side.center.y;
	        item.clipTo = null;
	
	        if (item.selected) {
	          item.selectable = false;
	        }
	
	        return {
	          item: item,
	          factor: {
	            x: this.side.getBorder().pixel.width / this.side.defaultWorkspaceSize.width,
	            y: this.side.getBorder().pixel.height / this.side.defaultWorkspaceSize.height
	          }
	        };
	      }
	    }
	  }, {
	    key: 'removeItem',
	    value: function removeItem(uuid) {
	      var item = this._collection.find(function (item) {
	        return item.uuid === uuid;
	      });
	      if (item) {
	        this.side._removeEvents();
	        item.remove();
	        this.side.FabricCanvas.renderAll();
	        this.side._initEvents();
	      }
	    }
	  }, {
	    key: 'updateItem',
	    value: function updateItem(data) {
	      var localItem = this._collection.find(function (item) {
	        return item.uuid === data.item.uuid;
	      });
	
	      if (localItem) {
	
	        this.side._removeEvents();
	
	        delete data.item.clipTo;
	        delete data.item.paths;
	
	        localItem.set(data.item);
	        localItem.set({
	          left: this.side.center.x + data.item.left / data.factor.x * ((this.side.getBorder().pixel.left || 1) / (this.side.defaultWorkspaceSize.left || 1)),
	          top: this.side.center.y + data.item.top / data.factor.y * ((this.side.getBorder().pixel.top || 1) / (this.side.defaultWorkspaceSize.top || 1)),
	          scaleX: data.item.scaleX / data.factor.x * (this.side.getBorder().pixel.width / this.side.defaultWorkspaceSize.width),
	          scaleY: data.item.scaleY / data.factor.y * (this.side.getBorder().pixel.height / this.side.defaultWorkspaceSize.height),
	          clipTo: (0, _clip2.default)(this.side.FabricBorder)
	        });
	        this.side.FabricCanvas.renderAll();
	        this.side._initEvents();
	      }
	    }
	  }, {
	    key: 'insertPlainItem',
	    value: function insertPlainItem(data) {
	      var _this = this;
	
	      if (!data.item.uuid) {
	        return false;
	      }
	      if (this.getItemByUUID(data.item.uuid)) {
	        return false;
	      }
	      this.side._removeEvents();
	      _fabric.fabric.util.enlivenObjects([data.item], function (objects) {
	        var origRenderOnAddRemove = _this.side.FabricCanvas.renderOnAddRemove;
	        _this.side.FabricCanvas.renderOnAddRemove = false;
	
	        objects.forEach(function (item) {
	          item.set({
	            left: _this.side.center.x + item.left / data.factor.x * ((_this.side.getBorder().pixel.left || 1) / (_this.side.defaultWorkspaceSize.left || 1)),
	            top: _this.side.center.y + item.top / data.factor.y * ((_this.side.getBorder().pixel.top || 1) / (_this.side.defaultWorkspaceSize.top || 1)),
	            scaleX: item.scaleX / data.factor.x * (_this.side.getBorder().pixel.width / _this.side.defaultWorkspaceSize.width),
	            scaleY: item.scaleY / data.factor.y * (_this.side.getBorder().pixel.height / _this.side.defaultWorkspaceSize.height),
	            clipTo: (0, _clip2.default)(_this.side.FabricBorder)
	          });
	
	          _this.side.FabricCanvas.add(item);
	          _this._collection.push(item);
	        });
	
	        _this.side.FabricCanvas.renderOnAddRemove = origRenderOnAddRemove;
	        _this.side.FabricCanvas.renderAll();
	        _this.side._initEvents();
	      });
	    }
	
	    /**
	     *
	     * @param {Array} items
	     * @param {Number} factor
	     */
	
	  }, {
	    key: 'insertPlainItems',
	    value: function insertPlainItems(items, factor) {
	      var _this2 = this;
	
	      this.side._removeEvents();
	      _fabric.fabric.util.enlivenObjects(items, function (objects) {
	        var origRenderOnAddRemove = _this2.side.FabricCanvas.renderOnAddRemove;
	        _this2.side.FabricCanvas.renderOnAddRemove = false;
	
	        objects.forEach(function (item) {
	          item.set({
	            left: _this2.side.center.x + item.left / factor * ((_this2.side.getBorder().pixel.left || 1) / (_this2.side.defaultWorkspaceSize.left || 1)),
	            top: _this2.side.center.y + item.top / factor * ((_this2.side.getBorder().pixel.top || 1) / (_this2.side.defaultWorkspaceSize.top || 1)),
	            scaleX: item.scaleX / factor * (_this2.side.getBorder().pixel.width / _this2.side.defaultWorkspaceSize.width),
	            scaleY: item.scaleY / factor * (_this2.side.getBorder().pixel.height / _this2.side.defaultWorkspaceSize.height),
	            clipTo: (0, _clip2.default)(_this2.side.FabricBorder)
	          });
	
	          _this2.side.FabricCanvas.add(item);
	          _this2._collection.push(item);
	        });
	
	        _this2.side.FabricCanvas.renderOnAddRemove = origRenderOnAddRemove;
	        _this2.side.FabricCanvas.renderAll();
	        _this2.side._initEvents();
	      });
	    }
	
	    /**
	     * Load a SVG image and parse as FabricJS object
	     * @param {String} url
	     */
	
	  }, {
	    key: 'addSVG',
	    value: function addSVG(url, fill) {
	      var _this3 = this;
	
	      _fabric.fabric.loadSVGFromURL(url, function (objects, options) {
	
	        var loadedObject = _fabric.fabric.util.groupSVGElements(objects, options);
	
	        loadedObject.set({
	          'left': _this3.side.center.x,
	          'top': _this3.side.center.y,
	          'originX': 'center',
	          'originY': 'center',
	          'fill': fill || '#000000',
	          clipTo: (0, _clip2.default)(_DrawTool2.default.sides.selected.FabricBorder)
	        });
	
	        if (_this3.side.FabricBorder.width < _this3.side.FabricBorder.height) {
	          loadedObject.scaleToWidth(_this3.side.FabricBorder.width);
	        } else {
	          loadedObject.scaleToHeight(_this3.side.FabricBorder.height);
	        }
	
	        loadedObject.setCoords();
	
	        _this3.side.FabricCanvas.add(loadedObject);
	
	        _this3._collection.push(loadedObject);
	
	        _this3.triggerCreated();
	
	        _this3.side.FabricCanvas.renderAll();
	      });
	    }
	
	    /**
	     * Load a image and parse as FabricJS object
	     * @param url
	     */
	
	  }, {
	    key: 'addImage',
	    value: function addImage(url) {
	      var _this4 = this;
	
	      var svg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	
	
	      return new Promise(function (resolve, reject) {
	        if (!svg) {
	          _fabric.fabric.Image.fromURL(url, function (oImg) {
	            oImg.set({
	              'left': _this4.side.center.x,
	              'top': _this4.side.center.y,
	              'originX': 'center',
	              'originY': 'center',
	              crossOrigin: 'anonymous',
	              clipTo: (0, _clip2.default)(_DrawTool2.default.sides.selected.FabricBorder)
	            });
	
	            if (_this4.side.FabricBorder.width < _this4.side.FabricBorder.height) {
	              oImg.scaleToWidth(_this4.side.FabricBorder.width);
	            } else {
	              oImg.scaleToHeight(_this4.side.FabricBorder.height);
	            }
	
	            _this4.side.FabricCanvas.add(oImg);
	
	            _this4._collection.push(oImg);
	
	            _this4.triggerCreated();
	
	            _this4.side.FabricCanvas.renderAll();
	
	            resolve();
	          }, {
	            crossOrigin: 'anonymous'
	          });
	        } else {
	          _fabric.fabric.loadSVGFromURL(url, function (objects, options) {
	            var oImg = _fabric.fabric.util.groupSVGElements(objects, options);
	
	            oImg.set({
	              'left': _this4.side.center.x,
	              'top': _this4.side.center.y,
	              'originX': 'center',
	              'originY': 'center',
	              crossOrigin: 'anonymous',
	              clipTo: (0, _clip2.default)(_DrawTool2.default.sides.selected.FabricBorder)
	            });
	
	            if (_this4.side.FabricBorder.width < _this4.side.FabricBorder.height) {
	              oImg.scaleToWidth(_this4.side.FabricBorder.width);
	            } else {
	              oImg.scaleToHeight(_this4.side.FabricBorder.height);
	            }
	
	            _this4.side.FabricCanvas.add(oImg);
	
	            _this4._collection.push(oImg);
	
	            _this4.triggerCreated();
	
	            _this4.side.FabricCanvas.renderAll();
	
	            resolve();
	          });
	        }
	      });
	    }
	
	    /**
	     *
	     * @param options
	     * @param options.fontSize {Number} Font size px
	     * @param options.fill {String} Font color: Rgb, hex
	     * @param options.fontFamily {String} Font family
	     * @param options.fontStyle {String} Font style. Possible values: "", "normal", "italic" or "oblique".
	     * @param options.fontWeight {String} Font weight (e.g. bold, normal, 400, 600, 800)
	     * @param options.textAlign {String} Text alignment. Possible values: "left", "center", "right" or "justify".
	     * @param options.editable {Boolean} Text can be edited by double click.
	     * @param txt {String} Text content
	     *
	     */
	
	  }, {
	    key: 'addText',
	    value: function addText(options, txt) {
	
	      var _options = Object.assign({
	        fontSize: 24,
	        fontFamily: 'serif',
	        fontStyle: 'normal',
	        fontWeight: 'normal',
	        fill: '#000000',
	        textAlign: 'center',
	        vertical: false
	      }, options);
	
	      var text = new _fabric.fabric.IText(txt || 'Text', _extends({
	        left: this.side.center.x,
	        top: this.side.center.y,
	        originX: 'center',
	        originY: 'center',
	        // width: this.side.FabricBorder.width,
	        editable: true,
	        clipTo: (0, _clip2.default)(_DrawTool2.default.sides.selected.FabricBorder)
	      }, _options));
	
	      this.side.FabricCanvas.add(text);
	
	      text.vertical = _options.vertical;
	
	      this._collection.push(text);
	
	      this.triggerCreated();
	
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.setActiveObject(text);
	
	      return text;
	    }
	
	    /**
	     * Remove items
	     */
	
	  }, {
	    key: 'empty',
	    value: function empty() {
	      this._collection.forEach(function (item) {
	        item.remove();
	      });
	
	      this.side.FabricCanvas.trigger('object:removed');
	      this._collection = [];
	
	      this.side.FabricCanvas.freeDrawingBrush.clean();
	      this.side.FabricCanvas.renderAll();
	    }
	  }, {
	    key: 'eraserEnable',
	    value: function eraserEnable() {
	      this.side.FabricCanvas.isDrawingMode = true;
	      this.side.FabricCanvas.freeDrawingBrush = new _fabric.fabric.Eraser(this.side.FabricCanvas);
	    }
	  }, {
	    key: 'eraserDisable',
	    value: function eraserDisable() {
	      this.side.FabricCanvas.freeDrawingBrush = new _fabric.fabric.PencilBrushC(this.side.FabricCanvas);
	      this.side.FabricCanvas.isDrawingMode = false;
	    }
	  }, {
	    key: 'pencilBrush',
	    value: function pencilBrush(options) {
	      this.side.FabricCanvas.freeDrawingBrush = new _fabric.fabric.PencilBrushC(this.side.FabricCanvas, options);
	      this.side.currentBrush = 'PencilBrush';
	    }
	  }, {
	    key: 'crayonBrush',
	    value: function crayonBrush(options) {
	      this.side.FabricCanvas.freeDrawingBrush = new _fabric.fabric.CrayonBrush(this.side.FabricCanvas, options);
	      this.side.currentBrush = 'CrayonBrush';
	    }
	  }, {
	    key: 'inkBrush',
	    value: function inkBrush(options) {
	      this.side.FabricCanvas.freeDrawingBrush = new _fabric.fabric.InkBrush(this.side.FabricCanvas, options);
	      this.side.currentBrush = 'InkBrush';
	    }
	  }, {
	    key: 'markerBrush',
	    value: function markerBrush(options) {
	      this.side.FabricCanvas.freeDrawingBrush = new _fabric.fabric.MarkerBrush(this.side.FabricCanvas, options);
	      this.side.currentBrush = 'MarkerBrush';
	    }
	  }, {
	    key: 'sprayBrush',
	    value: function sprayBrush(options) {
	      this.side.FabricCanvas.freeDrawingBrush = new _fabric.fabric.SprayBrush(this.side.FabricCanvas, options);
	      this.side.currentBrush = 'SprayBrush';
	    }
	  }, {
	    key: 'customBrush',
	    value: function customBrush(options) {
	      this.side.FabricCanvas.freeDrawingBrush = new _fabric.fabric.CustomBrush(this.side.FabricCanvas, options);
	      this.side.currentBrush = 'CustomBrush';
	    }
	  }, {
	    key: 'japaneseBrush',
	    value: function japaneseBrush(options) {
	      this.side.FabricCanvas.freeDrawingBrush = new _fabric.fabric.JapaneseBrush(this.side.FabricCanvas, options);
	      this.side.currentBrush = 'JapaneseBrush';
	    }
	  }, {
	    key: 'finalizeBrush',
	    value: function finalizeBrush() {
	      this.side.FabricCanvas.freeDrawingBrush.finalize();
	    }
	  }, {
	    key: 'brushOptions',
	    value: function brushOptions(options) {
	      var _o = {
	        color: this.side.FabricCanvas.freeDrawingBrush.color,
	        width: this.side.FabricCanvas.freeDrawingBrush.width,
	        opacity: this.side.FabricCanvas.freeDrawingBrush.opacity
	      };
	
	      if (options === undefined) {
	        return _o;
	      }
	
	      var o = _extends({}, _o, options);
	
	      this.side.FabricCanvas.freeDrawingBrush.changeColor(o.color);
	      // this.side.FabricCanvas.freeDrawingBrush.changeOpacity(o.opacity);
	      this.side.FabricCanvas.freeDrawingBrush.width = o.width;
	    }
	  }, {
	    key: 'triggerCreated',
	    value: function triggerCreated() {
	      _DrawTool2.default.trigger('history:update', { side: { id: this.side.id } });
	    }
	  }]);
	
	  return Items;
	}();
	
	exports.default = Items;

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _fabric = __webpack_require__(3);
	
	var _DrawTool = __webpack_require__(1);
	
	var _DrawTool2 = _interopRequireDefault(_DrawTool);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Item = function () {
	  function Item(side) {
	    _classCallCheck(this, Item);
	
	    this.side = side;
	
	    this.item = null;
	  }
	
	  /**
	   *
	   * @return {{type: string, top: number, left: number, width: number, height: number}}
	   */
	
	
	  _createClass(Item, [{
	    key: 'toObject',
	    value: function toObject() {
	
	      if (!this.item) return false;
	
	      var data = {
	        type: this.item.type,
	        top: (this.item.top - this.side.FabricBorder.top) / this.side.cmSize.height,
	        left: (this.item.left - this.side.FabricBorder.left) / this.side.cmSize.width,
	        width: this.item.width / this.side.cmSize.width,
	        height: this.item.height / this.side.cmSize.height,
	        angle: this.item.angle,
	        scale: this.item.scaleX,
	        opacity: this.item.opacity
	      };
	
	      if (this.item.type === 'path') {
	        data.fill = this.item.fill;
	      }
	
	      if (this.item.type === 'i-text') {
	        data.fontFamily = this.item.fontFamily;
	        data.fontStyle = this.item.fontStyle;
	        data.fontWeight = this.item.fontWeight;
	        data.fontSize = this.item.fontSize;
	        data.textAlign = this.item.textAlign;
	        data.fill = this.item.fill;
	      }
	
	      if (this.item.brush) {
	        data.type = 'brush';
	        data.fill = this.item.color;
	      }
	
	      return data;
	    }
	
	    /**
	     * @return {String} JSON representation of toObject()
	     */
	
	  }, {
	    key: 'toJSON',
	    value: function toJSON() {
	      return JSON.stringify(this.toObject());
	    }
	  }, {
	    key: 'deactivate',
	    value: function deactivate() {
	      this.side.FabricCanvas.deactivateAll();
	      this.side.FabricCanvas.renderAll();
	      this.item = null;
	      _DrawTool2.default.trigger('selection:cleared');
	    }
	
	    /**
	     * Remove selected item
	     */
	
	  }, {
	    key: 'remove',
	    value: function remove() {
	      if (!this.item) return;
	
	      this.item.remove();
	      this.deactivate();
	    }
	
	    /**
	     * Get/set rotation angle of selected element
	     * @param val
	     * @return
	     */
	
	  }, {
	    key: 'rotation',
	    value: function rotation(val) {
	      if (!this.item) return;
	
	      if (val === undefined) {
	        return this.item.angle;
	      }
	
	      this.item.setAngle(parseInt(val));
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      return this.item;
	    }
	
	    /**
	     * Get/set position of selected element
	     * @param obj
	     * @return
	     */
	
	  }, {
	    key: 'position',
	    value: function position(obj) {
	
	      if (!this.item) return;
	
	      var position = {
	        top: (this.item.top - this.side.FabricBorder.top) / this.side.cmSize.height,
	        left: (this.item.left - this.side.FabricBorder.left) / this.side.cmSize.width
	      };
	
	      if (!obj) {
	        return position;
	      }
	
	      var _position = _extends({}, position, obj);
	
	      var top = this.side.FabricBorder.top + _position.top * this.side.cmSize.height;
	      var left = this.side.FabricBorder.left + _position.left * this.side.cmSize.width;
	
	      this.item.animate('top', top, {
	        onChange: this.side.FabricCanvas.renderAll.bind(this.side.FabricCanvas)
	      });
	      this.item.animate('left', left, {
	        onChange: this.side.FabricCanvas.renderAll.bind(this.side.FabricCanvas)
	      });
	
	      this.item.setCoords();
	
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      return this.item;
	    }
	  }, {
	    key: 'scale',
	    value: function scale(val) {
	
	      if (!this.item) return false;
	
	      if (val === undefined) {
	        return this.item.scaleX;
	      }
	
	      this.item.scale(parseInt(val));
	
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      return this.item;
	    }
	
	    /**
	     * Get set size of selected element
	     * @param obj
	     * @return
	     */
	
	  }, {
	    key: 'size',
	    value: function size(obj) {
	
	      if (!this.item) return;
	
	      var size = {
	        width: this.item.width / this.side.cmSize.width,
	        height: this.item.height / this.side.cmSize.height
	      };
	
	      if (!obj) {
	        return size;
	      }
	
	      var _size = _extends({}, size, obj);
	
	      this.item.animate('height', _size.height * this.side.cmSize.height, {
	        onChange: this.side.FabricCanvas.renderAll.bind(this.side.FabricCanvas)
	      });
	      this.item.animate('width', _size.width * this.side.cmSize.width, {
	        onChange: this.side.FabricCanvas.renderAll.bind(this.side.FabricCanvas)
	      });
	
	      this.item.setCoords();
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      return this.item;
	    }
	  }, {
	    key: 'fill',
	    value: function fill(color) {
	
	      if (!this.item) return false;
	
	      if (color === undefined) {
	        if (this.item.brush) {
	          return this.item.color;
	        }
	      }
	
	      if (this.item.brush) {
	        var filter = new _fabric.fabric.Image.filters.Tint({
	          color: color
	        });
	
	        this.item.filters.push(filter);
	        this.item.applyFilters(this.side.FabricCanvas.renderAll.bind(this.side.FabricCanvas));
	        this.item.color = color;
	      } else {
	        this.item.setColor(color);
	      }
	
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	
	      return this.item;
	    }
	  }, {
	    key: 'opacity',
	    value: function opacity(val) {
	      if (val === undefined) return this.item.opacity;
	      this.item.setOpacity(Number(val));
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      return this.item;
	    }
	
	    // TEXT OPTIONS
	
	    /**
	     *
	     * @param fontFamily {String}
	     */
	
	  }, {
	    key: 'fontFamily',
	    value: function fontFamily(_fontFamily) {
	
	      if (!this.item) return false;
	
	      if (this.item.type !== 'i-text') return false;
	      if (!_fontFamily) {
	        return this.item.getFontFamily();
	      }
	      this.item.setFontFamily(_fontFamily);
	      this.item._initDimensions();
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      return this.item;
	    }
	  }, {
	    key: 'fontStyle',
	    value: function fontStyle(_fontStyle) {
	
	      if (!this.item) return false;
	
	      if (this.item.type !== 'i-text') return false;
	      if (!_fontStyle) {
	        return this.item.getFontStyle();
	      }
	      this.item.setFontStyle(_fontStyle);
	      this.item._initDimensions();
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      return this.item;
	    }
	  }, {
	    key: 'fontWeight',
	    value: function fontWeight(_fontWeight) {
	      if (!this.item) return false;
	
	      if (this.item.type !== 'i-text') return false;
	      if (!_fontWeight) {
	        return this.item.getFontWeight();
	      }
	      this.item.setFontWeight(_fontWeight);
	      this.item._initDimensions();
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      return this.item;
	    }
	  }, {
	    key: 'fontSize',
	    value: function fontSize(_fontSize) {
	      if (!this.item) return false;
	
	      if (this.item.type !== 'i-text') return false;
	      if (_fontSize === undefined) {
	        return this.item.getFontSize();
	      }
	      this.item.setFontSize(_fontSize);
	      this.item._initDimensions();
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      return this.item;
	    }
	  }, {
	    key: 'textAlign',
	    value: function textAlign(_textAlign) {
	      if (!this.item) return false;
	
	      if (this.item.type !== 'i-text') return false;
	      if (!_textAlign) {
	        return this.item.getTextAlign();
	      }
	      this.item.setTextAlign(_textAlign);
	      this.item._initDimensions();
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      return this.item;
	    }
	  }, {
	    key: 'text',
	    value: function text(_text) {
	      if (!this.item) return false;
	
	      if (this.item.type !== 'i-text') return false;
	      if (_text === undefined) {
	        return this.item.getText();
	      }
	      this.item.setText(_text);
	      this.item._initDimensions();
	      this.side.FabricCanvas.renderAll();
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      return this.item;
	    }
	  }, {
	    key: 'removeColor',
	    value: function removeColor(color, distance) {
	      if (!this.item) return false;
	
	      if (this.item.type === 'i-text') {
	        if (new _fabric.fabric.Color(this.item.fill).toHex() === new _fabric.fabric.Color(color).toHex()) {
	          this.fill('transparent');
	        }
	        this.side.FabricCanvas.renderAll();
	        return true;
	      }
	
	      if (this.item.type.includes('path')) {
	        this.item.paths.forEach(function (path) {
	          var _fill = new _fabric.fabric.Color(path.fill).toHex();
	          var _color = new _fabric.fabric.Color(color).toHex();
	          path.fill = _fill === _color ? 'transparent' : path.fill;
	        });
	        this.side.FabricCanvas.renderAll();
	        return true;
	      }
	
	      var filter = new _fabric.fabric.Image.filters.RemoveColor({
	        color: color,
	        distance: distance
	      });
	
	      this.item.filters.push(filter);
	      this.item.applyFilters(this.side.FabricCanvas.renderAll.bind(this.side.FabricCanvas));
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	    }
	  }, {
	    key: 'enterEditing',
	    value: function enterEditing() {
	      if (!this.item) return false;
	      if (this.item.type !== 'i-text') return false;
	      this.item.enterEditing();
	    }
	  }, {
	    key: 'exitEditing',
	    value: function exitEditing() {
	      if (!this.item) return false;
	      if (this.item.type !== 'i-text') return false;
	      this.item.exitEditing();
	    }
	  }, {
	    key: 'toVCenter',
	    value: function toVCenter() {
	      if (!this.item) return false;
	      this.item.set('top', this.side.FabricBorder.top + this.side.FabricBorder.height / 2);
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      this.side.FabricCanvas.renderAll();
	    }
	  }, {
	    key: 'toHCenter',
	    value: function toHCenter() {
	      if (!this.item) return false;
	      this.item.set('left', this.side.FabricBorder.left + this.side.FabricBorder.width / 2);
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      this.side.FabricCanvas.renderAll();
	    }
	  }, {
	    key: 'toLeft',
	    value: function toLeft() {
	      this.item.set('left', this.side.FabricBorder.left + this.item.width * this.item.scaleX / 2);
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      this.side.FabricCanvas.renderAll();
	    }
	  }, {
	    key: 'toRight',
	    value: function toRight() {
	      if (!this.item) return false;
	      this.item.set('left', this.side.FabricBorder.left + this.side.FabricBorder.width - this.item.width * this.item.scaleX / 2);
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      this.side.FabricCanvas.renderAll();
	    }
	  }, {
	    key: 'toTop',
	    value: function toTop() {
	      if (!this.item) return false;
	      this.item.set('top', this.side.FabricBorder.top + this.item.height * this.item.scaleY / 2);
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      this.side.FabricCanvas.renderAll();
	    }
	  }, {
	    key: 'toBottom',
	    value: function toBottom() {
	      if (!this.item) return false;
	      this.item.set('top', this.side.FabricBorder.top + this.side.FabricBorder.height - this.item.height * this.item.scaleY / 2);
	
	      this.side.FabricCanvas.trigger('object:modified', { target: this.item });
	      this.side.FabricCanvas.renderAll();
	    }
	  }]);
	
	  return Item;
	}();
	
	exports.default = Item;

/***/ },
/* 59 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function (border) {
	
	  var rect = Object.assign({}, {
	    left: border.left,
	    top: border.top,
	    width: border.width,
	    height: border.height,
	    strokeWidth: border.strokeWidth
	  });
	
	  var generate = function generate() {
	    return 'this.setCoords();\n      var clipRect = ' + JSON.stringify(rect) + ';\n      ctx.save();\n      var m = this.calcTransformMatrix();\n      var iM = fabric.util.invertTransform(m);\n      ctx.transform.apply(ctx, iM);\n      ctx.beginPath();\n\n      ctx.rect(\n        clipRect.left,\n        clipRect.top,\n        clipRect.width - clipRect.strokeWidth,\n        clipRect.height - clipRect.strokeWidth\n      );\n      ctx.closePath();\n      ctx.restore();';
	  };
	
	  return new Function('ctx', generate());
	};
	
	;

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _DrawTool = __webpack_require__(1);
	
	var _DrawTool2 = _interopRequireDefault(_DrawTool);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Layers = function () {
	  function Layers(side) {
	    _classCallCheck(this, Layers);
	
	    this.side = side;
	    this.list = null;
	    this.update();
	  }
	
	  _createClass(Layers, [{
	    key: 'update',
	    value: function update() {
	      var layers = [];
	
	      var opt = {
	        quality: 0.5,
	        enableRetina: false
	      };
	
	      this.side.FabricCanvas.forEachObject(function (obj) {
	        if (!obj.excludeFromExport) {
	          var clipto = obj.getClipTo();
	          obj.setClipTo(null);
	          layers.push({ index: obj.uuid, preview: obj.toDataURL(opt) });
	          obj.setClipTo(clipto);
	        }
	      });
	
	      this.list = layers;
	
	      return layers;
	    }
	  }, {
	    key: '_getItemsByIndex',
	    value: function _getItemsByIndex(indexes) {
	      var objects = this.side.FabricCanvas.getObjects().filter(function (obj) {
	        return indexes.includes(obj.uuid);
	      });
	      return objects;
	    }
	  }, {
	    key: 'bringToFront',
	    value: function bringToFront() {
	      var _this = this;
	
	      for (var _len = arguments.length, indexes = Array(_len), _key = 0; _key < _len; _key++) {
	        indexes[_key] = arguments[_key];
	      }
	
	      var items = this._getItemsByIndex(indexes);
	      var offset = this.side.FabricCanvas.getObjects().filter(function (o) {
	        return o.excludeFromExport;
	      }).length;
	      var newIndexes = [];
	
	      items.forEach(function (item) {
	        item.bringToFront();
	        newIndexes.push({ uuid: item.uuid, index: _this.side.FabricCanvas.getObjects().findIndex(function (o) {
	            return o.uuid === item.uuid;
	          }) - offset });
	      });
	      _DrawTool2.default.trigger('object:indexUpdate', JSON.stringify({ side: { id: this.side.id }, items: newIndexes }));
	      _DrawTool2.default.trigger('history:update', { side: { id: this.side.id } });
	    }
	  }, {
	    key: 'bringForward',
	    value: function bringForward() {
	      var _this2 = this;
	
	      for (var _len2 = arguments.length, indexes = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        indexes[_key2] = arguments[_key2];
	      }
	
	      var items = this._getItemsByIndex(indexes);
	      var offset = this.side.FabricCanvas.getObjects().filter(function (o) {
	        return o.excludeFromExport;
	      }).length;
	      var newIndexes = [];
	
	      items.forEach(function (item) {
	        item.bringForward();
	        newIndexes.push({ uuid: item.uuid, index: _this2.side.FabricCanvas.getObjects().findIndex(function (o) {
	            return o.uuid === item.uuid;
	          }) - offset });
	      });
	      _DrawTool2.default.trigger('object:indexUpdate', JSON.stringify({ side: { id: this.side.id }, items: newIndexes }));
	      _DrawTool2.default.trigger('history:update', { side: { id: this.side.id } });
	    }
	  }, {
	    key: 'sendBackwards',
	    value: function sendBackwards() {
	      var _this3 = this;
	
	      for (var _len3 = arguments.length, indexes = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	        indexes[_key3] = arguments[_key3];
	      }
	
	      var items = this._getItemsByIndex(indexes);
	      var offset = this.side.FabricCanvas.getObjects().filter(function (o) {
	        return o.excludeFromExport;
	      }).length;
	      var newIndexes = [];
	
	      items.forEach(function (item) {
	        item.sendBackwards();
	        newIndexes.push({ uuid: item.uuid, index: _this3.side.FabricCanvas.getObjects().findIndex(function (o) {
	            return o.uuid === item.uuid;
	          }) - offset });
	      });
	      _DrawTool2.default.trigger('object:indexUpdate', JSON.stringify({ side: { id: this.side.id }, items: newIndexes }));
	      _DrawTool2.default.trigger('history:update', { side: { id: this.side.id } });
	    }
	  }, {
	    key: 'sendToBack',
	    value: function sendToBack() {
	      var _this4 = this;
	
	      for (var _len4 = arguments.length, indexes = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	        indexes[_key4] = arguments[_key4];
	      }
	
	      var items = this._getItemsByIndex(indexes);
	      var offset = this.side.FabricCanvas.getObjects().filter(function (o) {
	        return o.excludeFromExport;
	      }).length;
	      var newIndexes = [];
	
	      items.forEach(function (item) {
	        item.sendToBack();
	        newIndexes.push({ uuid: item.uuid, index: _this4.side.FabricCanvas.getObjects().findIndex(function (o) {
	            return o.uuid === item.uuid;
	          }) - offset });
	      });
	      _DrawTool2.default.trigger('object:indexUpdate', JSON.stringify({ side: { id: this.side.id }, items: newIndexes }));
	      _DrawTool2.default.trigger('history:update', { side: { id: this.side.id } });
	    }
	
	    /**
	     *
	     * @param data
	     * @param data.index
	     * @param data.uuid
	     */
	
	  }, {
	    key: 'moveToIndex',
	    value: function moveToIndex(data) {
	      var item = this._getItemsByIndex(data.uuid)[0];
	
	      if (!item) return;
	
	      var offset = this.side.FabricCanvas.getObjects().filter(function (o) {
	        return o.excludeFromExport;
	      }).length;
	
	      var oldIndex = this.side.FabricCanvas.getObjects().findIndex(function (o) {
	        return o.uuid === item.uuid;
	      }) - offset;
	      var diff = data.index - oldIndex;
	
	      if (diff > 0) {
	        for (var i = 0; i < diff; i++) {
	          item.bringForward();
	        }
	      } else if (diff < 0) {
	        for (var _i = 0; _i > diff; _i--) {
	          item.sendBackwards();
	        }
	      }
	
	      _DrawTool2.default.trigger('history:update', { side: { id: this.side.id } });
	    }
	  }, {
	    key: 'toVCenter',
	    value: function toVCenter() {
	      var _this5 = this;
	
	      for (var _len5 = arguments.length, indexes = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
	        indexes[_key5] = arguments[_key5];
	      }
	
	      var items = this._getItemsByIndex(indexes);
	
	      items.forEach(function (item) {
	        return item.set('top', _this5.side.FabricBorder.top + _this5.side.FabricBorder.height / 2);
	      });
	      this.side.FabricCanvas.renderAll();
	    }
	  }, {
	    key: 'toHCenter',
	    value: function toHCenter() {
	      var _this6 = this;
	
	      for (var _len6 = arguments.length, indexes = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
	        indexes[_key6] = arguments[_key6];
	      }
	
	      var items = this._getItemsByIndex(indexes);
	
	      items.forEach(function (item) {
	        item.set('left', _this6.side.FabricBorder.left + _this6.side.FabricBorder.width / 2);
	        _this6.side.FabricCanvas.trigger('object:modified', { target: item });
	      });
	      this.side.FabricCanvas.renderAll();
	    }
	  }, {
	    key: 'toLeft',
	    value: function toLeft() {
	      var _this7 = this;
	
	      for (var _len7 = arguments.length, indexes = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
	        indexes[_key7] = arguments[_key7];
	      }
	
	      var items = this._getItemsByIndex(indexes);
	
	      items.forEach(function (item) {
	        item.set('left', _this7.side.FabricBorder.left + item.width * item.scaleX / 2);
	        _this7.side.FabricCanvas.trigger('object:modified', { target: item });
	      });
	      this.side.FabricCanvas.renderAll();
	    }
	  }, {
	    key: 'toRight',
	    value: function toRight() {
	      var _this8 = this;
	
	      for (var _len8 = arguments.length, indexes = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
	        indexes[_key8] = arguments[_key8];
	      }
	
	      var items = this._getItemsByIndex(indexes);
	
	      items.forEach(function (item) {
	        item.set('left', _this8.side.FabricBorder.left + _this8.side.FabricBorder.width - item.width * item.scaleX / 2);
	        _this8.side.FabricCanvas.trigger('object:modified', { target: item });
	      });
	      this.side.FabricCanvas.renderAll();
	    }
	  }, {
	    key: 'toTop',
	    value: function toTop() {
	      var _this9 = this;
	
	      for (var _len9 = arguments.length, indexes = Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
	        indexes[_key9] = arguments[_key9];
	      }
	
	      var items = this._getItemsByIndex(indexes);
	
	      items.forEach(function (item) {
	        item.set('top', _this9.side.FabricBorder.top + item.height * item.scaleY / 2);
	        _this9.side.FabricCanvas.trigger('object:modified', { target: item });
	      });
	      this.side.FabricCanvas.renderAll();
	    }
	  }, {
	    key: 'toBottom',
	    value: function toBottom() {
	      var _this10 = this;
	
	      for (var _len10 = arguments.length, indexes = Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
	        indexes[_key10] = arguments[_key10];
	      }
	
	      var items = this._getItemsByIndex(indexes);
	
	      items.forEach(function (item) {
	        item.set('top', _this10.side.FabricBorder.top + _this10.side.FabricBorder.height - item.height * item.scaleY / 2);
	        _this10.side.FabricCanvas.trigger('object:modified', { target: item });
	      });
	      this.side.FabricCanvas.renderAll();
	    }
	  }]);
	
	  return Layers;
	}();
	
	exports.default = Layers;

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _fabric = __webpack_require__(3);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var colorPicker = function () {
	  function colorPicker(side) {
	    _classCallCheck(this, colorPicker);
	
	    var that = this;
	
	    this.side = side;
	
	    this._active = false;
	
	    this._color = '#000000';
	
	    this.cursor = new _fabric.fabric.Circle({
	      left: 0,
	      top: 0,
	      radius: 20,
	      strokeWidth: 3,
	      stroke: '#ffffff',
	      originX: 'center',
	      originY: 'center',
	      selectable: false,
	      excludeFromExport: true,
	      evented: false,
	      shadow: new _fabric.fabric.Shadow('2px 2px 10px rgba(0,0,0,0.2)'),
	      lockUniScaling: true
	    });
	
	    return this;
	  }
	
	  _createClass(colorPicker, [{
	    key: 'move',
	    value: function move(e) {
	      // let pointer = this.side.FabricCanvas.getPointer(e.e);
	
	      this.color = this.getColor(e.e.layerX * window.devicePixelRatio, e.e.layerY * window.devicePixelRatio);
	
	      // this.side.FabricCanvas.remove(this.cursor);
	      // this.side.FabricCanvas.add(this.cursor);
	      // this.cursor.bringToFront();
	      //
	      // if(e.e.layerX < 50 || e.e.layerY < 50){
	      //   this.cursor.top = pointer.y + 30;
	      //   this.cursor.left = pointer.x + 30;
	      // } else {
	      //   this.cursor.top = pointer.y - 30;
	      //   this.cursor.left = pointer.x - 30;
	      // }
	      //
	      // this.side.FabricCanvas.renderAll()
	    }
	  }, {
	    key: 'getColor',
	    value: function getColor(x, y) {
	
	      var px = this.side.FabricCanvas.contextContainer.getImageData(x, y, 1, 1).data;
	
	      return '#' + new _fabric.fabric.Color('rgb(' + px[0] + ', ' + px[1] + ', ' + px[2] + ')').toHex();
	    }
	  }, {
	    key: 'active',
	    set: function set(value) {
	      this._active = value;
	      if (value !== undefined && !value) {
	        this.side.FabricCanvas.remove(this.cursor);
	        this.side.items._collection.forEach(function (object) {
	          return object.selectable = !value;
	        });
	        this.side.FabricCanvas.hoverCursor = 'all-scroll';
	      } else if (value === true) {
	        this.side.items._collection.forEach(function (object) {
	          return object.selectable = !value;
	        });
	        this.side.FabricCanvas.hoverCursor = 'url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAAbFBMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB0Iv+qAAAAJHRSTlMAz7bnBNm547yTjhD+697Hw7KJfcumoJJ2XCkYCvDBVElEMiHmZ6DLAAAAiElEQVQY023ORw6EMBQDUBMI6Y3ept//jqNILEKCl0//W8Zb9yjCxGgL7kd86DNX9wJIlWEXoc114Hdatygbmpqct6WS+waHdbvchjhE117lDROFJEiVymkAmEMapSs0diYixZUCVuAwqe6+YzJ+mCXRH6/CAeCb7ZVGAY3HNfNjQ+DIsjDK9z+4kgU9DvokHAAAAABJRU5ErkJggg=="), auto';
	        // this.side.items.selected.deactivate();
	      }
	    },
	    get: function get() {
	      return this._active;
	    }
	  }, {
	    key: 'color',
	    set: function set(color) {
	      if (color !== undefined && color) {
	        this._color = color;
	        this.cursor.setFill(color);
	      }
	    },
	    get: function get() {
	      return this._color;
	    }
	  }]);
	
	  return colorPicker;
	}();
	
	;
	
	exports.default = colorPicker;

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _DrawTool = __webpack_require__(1);
	
	var _DrawTool2 = _interopRequireDefault(_DrawTool);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var DrawHistory = function () {
	  function DrawHistory() {
	    _classCallCheck(this, DrawHistory);
	
	    this.history = {};
	  }
	
	  _createClass(DrawHistory, [{
	    key: 'pushState',
	    value: function pushState(id) {
	
	      if (typeof this.history[id] === 'undefined') {
	        this.history[id] = {
	          collection: [],
	          currentIndex: 0
	        };
	      }
	
	      var side = _DrawTool2.default.sides.getSide(id);
	      var state = JSON.stringify(side.FabricCanvas);
	
	      this.history[id].collection = this.history[id].collection.slice(0, this.history[id].currentIndex + 1);
	      this.history[id].collection.push(state);
	      this.history[id].currentIndex = this.history[id].collection.length - 1;
	    }
	  }, {
	    key: 'undo',
	    value: function undo(id) {
	
	      var side = _DrawTool2.default.sides.getSide(id);
	
	      if (!this.history[id].collection.length) {
	        this.history[id].currentIndex = 0;
	        return false;
	      }
	
	      if (this.history[id].currentIndex <= 0) {
	        this.history[id].currentIndex = 0;
	        return false;
	      }
	
	      var state = this.history[id].collection[this.history[id].currentIndex - 1];
	      this.history[id].currentIndex -= 1;
	
	      side.loadFromJSON(state);
	    }
	  }, {
	    key: 'redo',
	    value: function redo(id) {
	
	      var side = _DrawTool2.default.sides.getSide(id);
	
	      if (!this.history[id].collection.length) {
	        return false;
	      }
	
	      if (this.history[id].currentIndex >= this.history[id].collection.length - 1) {
	        return false;
	      }
	
	      var state = this.history[id].collection[this.history[id].currentIndex + 1];
	      this.history[id].currentIndex += 1;
	
	      side.loadFromJSON(state);
	    }
	  }]);
	
	  return DrawHistory;
	}();
	
	exports.default = DrawHistory;

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _fabric = __webpack_require__(3);
	
	_fabric.fabric.Eraser = _fabric.fabric.util.createClass(_fabric.fabric.BaseBrush, {
	
	  initialize: function initialize(canvas) {
	    this.canvas = canvas;
	  },
	
	  onMouseDown: function onMouseDown(pointer) {
	    this.remove(pointer);
	  },
	
	  onMouseMove: function onMouseMove(pointer) {
	    this.remove(pointer);
	  },
	
	  onMouseUp: function onMouseUp(pointer) {},
	
	  remove: function remove(pointer) {
	    var _this = this;
	
	    var targets = this.canvas.getObjects().filter(function (obj) {
	      return obj.containsPoint(pointer) && !_this.canvas.isTargetTransparent(obj, pointer.x, pointer.y);
	    });
	
	    targets.forEach(function (obj) {
	
	      if (obj.id !== 'FabricBorder') {
	        obj.remove();
	      }
	    });
	  }
	
	});

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _fabric = __webpack_require__(3);
	
	_fabric.fabric.util.getRandom = function (max, min) {
	  min = min ? min : 0;
	  return Math.random() * ((max ? max : 1) - min) + min;
	};
	
	_fabric.fabric.util.clamp = function (n, max, min) {
	  if (typeof min !== 'number') min = 0;
	  return n > max ? max : n < min ? min : n;
	};
	
	_fabric.fabric.util.trim = function (context) {
	  var copy = document.createElement('canvas').getContext('2d'),
	      pixels = context.getImageData(0, 0, context.canvas.width, context.canvas.height),
	      l = pixels.data.length,
	      i,
	      bound = {
	    top: null,
	    left: null,
	    right: null,
	    bottom: null
	  },
	      x,
	      y,
	      img;
	
	  for (i = 0; i < l; i += 4) {
	    if (pixels.data[i + 3] !== 0) {
	      x = i / 4 % context.canvas.width;
	      y = ~~(i / 4 / context.canvas.width);
	
	      if (bound.top === null) {
	        bound.top = y;
	      }
	
	      if (bound.left === null) {
	        bound.left = x;
	      } else if (x < bound.left) {
	        bound.left = x;
	      }
	
	      if (bound.right === null) {
	        bound.right = x;
	      } else if (bound.right < x) {
	        bound.right = x;
	      }
	
	      if (bound.bottom === null) {
	        bound.bottom = y;
	      } else if (bound.bottom < y) {
	        bound.bottom = y;
	      }
	    }
	  }
	
	  var trimHeight = bound.bottom - bound.top;
	  var trimWidth = bound.right - bound.left;
	  if (!trimHeight || !trimWidth) {
	    return false;
	  }
	  var trimmed = context.getImageData(bound.left, bound.top, trimWidth + 10, trimHeight + 10);
	
	  copy.canvas.width = trimWidth;
	  copy.canvas.height = trimHeight;
	  copy.putImageData(trimmed, 0, 0);
	  img = copy.canvas.toDataURL('image/png');
	
	  return {
	    img: img,
	    left: bound.left,
	    top: bound.top,
	    width: trimWidth,
	    height: trimHeight
	  };
	};

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _fabric = __webpack_require__(3);
	
	var _clip = __webpack_require__(59);
	
	var _clip2 = _interopRequireDefault(_clip);
	
	var _DrawTool = __webpack_require__(1);
	
	var _DrawTool2 = _interopRequireDefault(_DrawTool);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_fabric.fabric.BaseBrush.prototype.finalize = function () {
	  var _this = this;
	
	  if (!this.moved) return false;
	  var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;
	
	  var vt = this.canvas.viewportTransform;
	  var raster = _fabric.fabric.util.trim(this.canvas.contextTop);
	
	  _fabric.fabric.Image.fromURL(raster.img, function (oImg) {
	
	    _this.canvas.clearContext(_this.canvas.contextTop);
	    _this._resetShadow();
	
	    oImg.set({
	      top: raster.top / vt[0] - vt[5] / vt[0],
	      left: raster.left / vt[0] - vt[4] / vt[0],
	      width: oImg.width / vt[0],
	      height: oImg.height / vt[0],
	      brush: true,
	      color: _this.color
	    });
	
	    oImg.set({
	      originX: 'center',
	      originY: 'center',
	      top: oImg.top + oImg.height / 2,
	      left: oImg.left + oImg.width / 2,
	      clipTo: (0, _clip2.default)(_DrawTool2.default.sides.selected.FabricBorder)
	    });
	
	    _this.canvas.add(oImg);
	
	    _DrawTool2.default.sides.selected.items._collection.push(oImg);
	
	    _this.canvas.renderAll();
	
	    _DrawTool2.default.trigger('history:update', { side: { id: _DrawTool2.default.sides.selected.id } });
	
	    _this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
	
	    _this.moved = false;
	  }, {
	    crossOrigin: 'Anonymous'
	  });
	};
	
	_fabric.fabric.BaseBrush.prototype.clean = function () {
	  this.canvas.clearContext(this.canvas.contextTop);
	};

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _fabric = __webpack_require__(3);
	
	_fabric.fabric.Point.prototype.angleBetween = function (that) {
	  return Math.atan2(this.x - that.x, this.y - that.y);
	};
	
	_fabric.fabric.Point.prototype.normalize = function (thickness) {
	  if (null === thickness || undefined === thickness) {
	    thickness = 1;
	  }
	
	  var length = this.distanceFrom({ x: 0, y: 0 });
	
	  if (length > 0) {
	    this.x = this.x / length * thickness;
	    this.y = this.y / length * thickness;
	  }
	
	  return this;
	};

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _fabric = __webpack_require__(3);
	
	_fabric.fabric.Stroke = _fabric.fabric.util.createClass(_fabric.fabric.Object, {
	  color: null,
	  inkAmount: null,
	  lineWidth: null,
	  _point: null,
	  _lastPoint: null,
	  _currentLineWidth: null,
	
	  initialize: function initialize(ctx, pointer, range, color, lineWidth, inkAmount) {
	
	    var rx = _fabric.fabric.util.getRandom(range),
	        c = _fabric.fabric.util.getRandom(Math.PI * 2),
	        c0 = _fabric.fabric.util.getRandom(Math.PI * 2),
	        x0 = rx * Math.sin(c0),
	        y0 = rx / 2 * Math.cos(c0),
	        cos = Math.cos(c),
	        sin = Math.sin(c);
	
	    this.ctx = ctx;
	    this.color = color;
	    this._point = new _fabric.fabric.Point(pointer.x + x0 * cos - y0 * sin, pointer.y + x0 * sin + y0 * cos);
	    this.lineWidth = lineWidth;
	    this.inkAmount = inkAmount;
	    this._currentLineWidth = lineWidth;
	
	    ctx.lineCap = "round";
	  },
	
	  update: function update(pointer, subtractPoint, distance) {
	    this._lastPoint = _fabric.fabric.util.object.clone(this._point);
	    this._point = this._point.addEquals({ x: subtractPoint.x, y: subtractPoint.y });
	
	    var n = this.inkAmount / (distance + 1);
	    var per = n > 0.3 ? 0.2 : n < 0 ? 0 : n;
	    this._currentLineWidth = this.lineWidth * per;
	  },
	
	  draw: function draw() {
	    var ctx = this.ctx;
	    ctx.save();
	    this.line(ctx, this._lastPoint, this._point, this.color, this._currentLineWidth);
	    ctx.restore();
	  },
	
	  line: function line(ctx, point1, point2, color, lineWidth) {
	    ctx.strokeStyle = color;
	    ctx.lineWidth = lineWidth;
	    ctx.beginPath();
	    ctx.moveTo(point1.x, point1.y);
	    ctx.lineTo(point2.x, point2.y);
	
	    ctx.stroke();
	  }
	});

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _fabric = __webpack_require__(3);
	
	_fabric.fabric.PencilBrushC = _fabric.fabric.util.createClass(_fabric.fabric.BaseBrush, {
	
	  color: "#000000",
	  width: 1,
	
	  _baseWidth: 1,
	  _lastPoint: null,
	  _lineWidth: 1,
	  _point: null,
	  _size: 0,
	  moved: false,
	
	  initialize: function initialize(canvas) {
	    var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	
	    this.canvas = canvas;
	    this.width = opt.width || canvas.freeDrawingBrush.width;
	    this.color = opt.color || canvas.freeDrawingBrush.color;
	    this._point = new _fabric.fabric.Point();
	
	    this.canvas.contextTop.lineJoin = 'round';
	    this.canvas.contextTop.lineCap = 'round';
	  },
	
	  changeColor: function changeColor(color) {
	    this.color = color;
	  },
	
	  _render: function _render(pointer) {
	    var ctx, lineWidthDiff, i, len;
	    var vt = this.canvas.viewportTransform;
	
	    ctx = this.canvas.contextTop;
	
	    ctx.save();
	
	    ctx.transform(vt[0], vt[1], vt[2], vt[3], vt[4], vt[5]);
	    ctx.beginPath();
	    ctx.lineWidth = this._size;
	
	    for (i = 0, len = this._size / this._size / 2; i < len; i++) {
	      lineWidthDiff = (this._size - 1) * i;
	      ctx.moveTo(this._lastPoint.x + lineWidthDiff, this._lastPoint.y + lineWidthDiff);
	      ctx.lineTo(pointer.x + lineWidthDiff, pointer.y + lineWidthDiff);
	      ctx.stroke();
	    }
	
	    ctx.restore();
	
	    this._lastPoint = new _fabric.fabric.Point(pointer.x, pointer.y);
	  },
	
	  onMouseDown: function onMouseDown(pointer) {
	    this._lastPoint = pointer;
	    this.canvas.contextTop.strokeStyle = this.color;
	    this._size = this.width;
	    this.moved = false;
	  },
	
	  onMouseMove: function onMouseMove(pointer) {
	    if (this.canvas._isCurrentlyDrawing) {
	      this._render(pointer);
	    }
	    this.moved = true;
	  },
	
	  onMouseUp: function onMouseUp() {}
	});

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _fabric = __webpack_require__(3);
	
	_fabric.fabric.CrayonBrush = _fabric.fabric.util.createClass(_fabric.fabric.BaseBrush, {
	
	  color: "#000000",
	  width: 30,
	
	  _baseWidth: 20,
	  _inkAmount: 10,
	  _latestStrokeLength: 0,
	  _point: null,
	  _sep: 5,
	  _size: 0,
	  moved: false,
	
	  initialize: function initialize(canvas) {
	    var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	
	    this.canvas = canvas;
	    this.width = opt.width || canvas.freeDrawingBrush.width;
	    this.color = opt.color || canvas.freeDrawingBrush.color;
	    this._point = new _fabric.fabric.Point(0, 0);
	  },
	
	  changeColor: function changeColor(color) {
	    this.color = color;
	  },
	
	  onMouseDown: function onMouseDown(pointer) {
	    this._size = this.width;
	    this.set(pointer);
	    this.moved = false;
	  },
	
	  onMouseMove: function onMouseMove(pointer) {
	    this.update(pointer);
	    this.render(this.canvas.contextTop);
	    this.moved = true;
	  },
	
	  onMouseUp: function onMouseUp(pointer) {},
	
	  set: function set(p) {
	    if (this._latest) {
	      this._latest.setFromPoint(this._point);
	    } else {
	      this._latest = new _fabric.fabric.Point(p.x, p.y);
	    }
	    _fabric.fabric.Point.prototype.setFromPoint.call(this._point, p);
	  },
	
	  update: function update(p) {
	    this.set(p);
	    this._latestStrokeLength = this._point.subtract(this._latest).distanceFrom({ x: 0, y: 0 });
	  },
	
	  render: function render() {
	    var ctx = this.canvas.contextTop;
	    var vt = this.canvas.viewportTransform;
	    var i, j, p, r, c, x, y, w, h, v, s, stepNum, dotSize, dotNum, range;
	    v = this._point.subtract(this._latest);
	    s = Math.ceil(this._size / 2);
	    stepNum = Math.floor(v.distanceFrom({ x: 0, y: 0 }) / s) + 1;
	    v.normalize(s);
	
	    dotSize = this._sep * _fabric.fabric.util.clamp(this._inkAmount / this._latestStrokeLength * 3, 1, 0.5);
	    dotNum = Math.ceil(this._size * this._sep);
	
	    range = this._size / 2;
	
	    ctx.save();
	    ctx.transform(vt[0], vt[1], vt[2], vt[3], vt[4], vt[5]);
	    ctx.fillStyle = this.color;
	    ctx.beginPath();
	    for (i = 0; i < dotNum; i++) {
	      for (j = 0; j < stepNum; j++) {
	        p = this._latest.add(v.multiply(j));
	        r = _fabric.fabric.util.getRandom(range);
	        c = _fabric.fabric.util.getRandom(Math.PI * 2);
	        w = _fabric.fabric.util.getRandom(dotSize, dotSize / 2);
	        h = _fabric.fabric.util.getRandom(dotSize, dotSize / 2);
	        x = p.x + r * Math.sin(c) - w / 2;
	        y = p.y + r * Math.cos(c) - h / 2;
	        ctx.rect(x, y, w, h);
	      }
	    }
	
	    ctx.fill();
	    ctx.restore();
	  }
	
	});

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _fabric = __webpack_require__(3);
	
	_fabric.fabric.InkBrush = _fabric.fabric.util.createClass(_fabric.fabric.BaseBrush, {
	
	  color: "#000000",
	  width: 30,
	
	  _baseWidth: 20,
	  _inkAmount: 7,
	  _lastPoint: null,
	  _point: null,
	  _range: 10,
	  _strokeCount: 0,
	  _strokeId: null,
	  _strokeNum: 40,
	  _strokes: null,
	  moved: false,
	
	  initialize: function initialize(canvas) {
	    var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	
	    this.canvas = canvas;
	    this.width = opt.width || canvas.freeDrawingBrush.width;
	    this.color = opt.color || canvas.freeDrawingBrush.color;
	
	    this._point = new _fabric.fabric.Point();
	  },
	
	  changeColor: function changeColor(color) {
	    this.color = color;
	  },
	
	  _render: function _render(pointer) {
	    var subtractPoint, distance, point, i, len, strokes, stroke;
	    this._strokeCount++;
	
	    var ctx = this.canvas.contextTop;
	    var vt = this.canvas.viewportTransform;
	
	    point = this.setPointer(pointer);
	    subtractPoint = point.subtract(this._lastPoint);
	    distance = point.distanceFrom(this._lastPoint);
	    strokes = this._strokes;
	
	    ctx.save();
	    ctx.transform(vt[0], vt[1], vt[2], vt[3], vt[4], vt[5]);
	    for (i = 0, len = strokes.length; i < len; i++) {
	      stroke = strokes[i];
	      stroke.update(point, subtractPoint, distance);
	      stroke.draw();
	    }
	
	    if (distance > 30) {
	      this.drawSplash(point, this._inkAmount);
	    }
	    ctx.restore();
	  },
	
	  onMouseDown: function onMouseDown(pointer) {
	    this._resetTip(pointer);
	    this._strokeId = +new Date();
	    this.moved = false;
	  },
	
	  onMouseMove: function onMouseMove(pointer) {
	    if (this.canvas._isCurrentlyDrawing) {
	      this._render(pointer);
	    }
	    this.moved = true;
	  },
	
	  onMouseUp: function onMouseUp() {
	    this._strokeCount = 0;
	    this._strokeId = null;
	  },
	
	  drawSplash: function drawSplash(pointer, maxSize) {
	    var c,
	        r,
	        i,
	        point,
	        ctx = this.canvas.contextTop,
	        num = _fabric.fabric.util.getRandom(12),
	        range = maxSize * 10,
	        color = this.color;
	
	    ctx.save();
	    for (i = 0; i < num; i++) {
	      r = _fabric.fabric.util.getRandom(range, 1);
	      c = _fabric.fabric.util.getRandom(Math.PI * 2);
	      point = new _fabric.fabric.Point(pointer.x + r * Math.sin(c), pointer.y + r * Math.cos(c));
	
	      ctx.fillStyle = color;
	      ctx.beginPath();
	      ctx.arc(point.x, point.y, _fabric.fabric.util.getRandom(maxSize) / 2, 0, Math.PI * 2, false);
	      ctx.fill();
	    }
	    ctx.restore();
	  },
	
	  setPointer: function setPointer(pointer) {
	    var point = new _fabric.fabric.Point(pointer.x, pointer.y);
	
	    this._lastPoint = _fabric.fabric.util.object.clone(this._point);
	    this._point = point;
	
	    return point;
	  },
	
	  _resetTip: function _resetTip(pointer) {
	    var strokes, point, len, i;
	
	    point = this.setPointer(pointer);
	    strokes = this._strokes = [];
	    this.size = this.width / 5 + this._baseWidth;
	    this._strokeNum = this.size;
	    this._range = this.size / 2;
	
	    for (i = 0, len = this._strokeNum; i < len; i++) {
	      strokes[i] = new _fabric.fabric.Stroke(this.canvas.contextTop, point, this._range, this.color, this.width, this._inkAmount);
	    }
	  }
	});

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _fabric = __webpack_require__(3);
	
	_fabric.fabric.SprayBrush = _fabric.fabric.util.createClass(_fabric.fabric.BaseBrush, {
	
	  color: "#000000",
	  width: 1,
	
	  _drips: [],
	  _dripThreshold: 15,
	  _inkAmount: 0,
	  _interval: 20,
	  _lastPoint: null,
	  _point: null,
	  _strokeId: 0,
	  brush: null,
	  sprayBrushDataUrl: "data:image/png;base64,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",
	  moved: false,
	
	  initialize: function initialize(canvas) {
	    var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	    var context = this;
	
	    this.canvas = canvas;
	    this.width = opt.width || canvas.freeDrawingBrush.width;
	    this.color = opt.color || canvas.freeDrawingBrush.color;
	
	    this.canvas.contextTop.lineJoin = "round";
	    this.canvas.contextTop.lineCap = "round";
	
	    this._reset();
	
	    _fabric.fabric.Image.fromURL(this.sprayBrushDataUrl, function (brush) {
	      context.brush = brush;
	      context.brush.filters = [];
	      context.changeColor(opt.color);
	    }, { crossOrigin: "anonymous" });
	  },
	
	  changeColor: function changeColor(color) {
	    this.color = new _fabric.fabric.Color(color).toRgba();
	    this.opacity = /(,(\s)*(\d(\.\d(\d*))*)\))/g.exec(this.color)[3];
	    this.brush.filters[0] = new _fabric.fabric.Image.filters.Tint({ color: '#' + new _fabric.fabric.Color(color).toHex() });
	    this.brush.applyFilters(this.canvas.renderAll.bind(this.canvas));
	  },
	
	  onMouseDown: function onMouseDown(pointer) {
	    this._point = new _fabric.fabric.Point(pointer.x, pointer.y);
	    this._lastPoint = this._point;
	
	    this.size = this.width;
	    this._strokeId = +new Date();
	    this._inkAmount = 0;
	
	    this.changeColor(this.color);
	    this._render();
	  },
	
	  onMouseMove: function onMouseMove(pointer) {
	    this.moved = true;
	    this._lastPoint = this._point;
	    this._point = new _fabric.fabric.Point(pointer.x, pointer.y);
	  },
	
	  onMouseUp: function onMouseUp(pointer) {},
	
	  _render: function _render() {
	    var context = this;
	
	    setTimeout(draw, this._interval);
	
	    function draw() {
	      var point, distance, angle, amount, x, y;
	
	      var ctx = context.canvas.contextTop;
	      var vt = context.canvas.viewportTransform;
	      ctx.save();
	      ctx.transform(vt[0], vt[1], vt[2], vt[3], vt[4], vt[5]);
	      ctx.globalAlpha = this.opacity;
	      point = new _fabric.fabric.Point(context._point.x || 0, context._point.y || 0);
	      distance = point.distanceFrom(context._lastPoint);
	      angle = point.angleBetween(context._lastPoint);
	      amount = 100 / context.size / (Math.pow(distance, 2) + 1);
	
	      context._inkAmount += amount;
	      context._inkAmount = Math.max(context._inkAmount - distance / 10, 0);
	
	      x = context._lastPoint.x + Math.sin(angle) - context.size / 2;
	      y = context._lastPoint.y + Math.cos(angle) - context.size / 2;
	      context.canvas.contextTop.drawImage(context.brush._element, x, y, context.size, context.size);
	
	      ctx.restore();
	
	      if (context.canvas._isCurrentlyDrawing) {
	        setTimeout(draw, context._interval);
	      } else {
	        context._reset();
	      }
	    }
	  },
	
	  _reset: function _reset() {
	    this._point = null;
	    this._lastPoint = null;
	  }
	});

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _fabric = __webpack_require__(3);
	
	_fabric.fabric.MarkerBrush = _fabric.fabric.util.createClass(_fabric.fabric.BaseBrush, {
	
	  color: "#000000",
	  width: 30,
	
	  _baseWidth: 10,
	  _lastPoint: null,
	  _lineWidth: 3,
	  _point: null,
	  _size: 0,
	  moved: false,
	
	  initialize: function initialize(canvas) {
	    var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	
	    this.canvas = canvas;
	    this.width = opt.width || canvas.freeDrawingBrush.width;
	    this.color = opt.color || canvas.freeDrawingBrush.color;
	    this._point = new _fabric.fabric.Point();
	
	    this.canvas.contextTop.lineJoin = 'round';
	    this.canvas.contextTop.lineCap = 'round';
	  },
	
	  changeColor: function changeColor(color) {
	    this.color = color;
	  },
	
	  _render: function _render(pointer) {
	    var ctx, lineWidthDiff, i, len;
	    var vt = this.canvas.viewportTransform;
	
	    ctx = this.canvas.contextTop;
	
	    ctx.save();
	
	    ctx.transform(vt[0], vt[1], vt[2], vt[3], vt[4], vt[5]);
	    ctx.beginPath();
	
	    for (i = 0, len = this._size / this._lineWidth / 2; i < len; i++) {
	      lineWidthDiff = (this._lineWidth - 1) * i;
	
	      ctx.moveTo(this._lastPoint.x + lineWidthDiff, this._lastPoint.y + lineWidthDiff);
	      ctx.lineTo(pointer.x + lineWidthDiff, pointer.y + lineWidthDiff);
	      ctx.stroke();
	    }
	
	    ctx.restore();
	
	    this._lastPoint = new _fabric.fabric.Point(pointer.x, pointer.y);
	  },
	
	  onMouseDown: function onMouseDown(pointer) {
	    this._lastPoint = pointer;
	    this.canvas.contextTop.strokeStyle = this.color;
	    this.canvas.contextTop.lineWidth = this._lineWidth;
	    this._size = this.width;
	    this.moved = false;
	  },
	
	  onMouseMove: function onMouseMove(pointer) {
	    if (this.canvas._isCurrentlyDrawing) {
	      this._render(pointer);
	    }
	    this.moved = true;
	  },
	
	  onMouseUp: function onMouseUp() {}
	});

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _fabric = __webpack_require__(3);
	
	_fabric.fabric.CustomBrush = _fabric.fabric.util.createClass(_fabric.fabric.BaseBrush, {
	
	  color: "#000000",
	  width: 30,
	
	  _baseWidth: 10,
	  _lastPoint: null,
	  _lineWidth: 3,
	  _point: null,
	  _size: 0,
	  sprayBrushDataUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAE0lEQVR42mNgwAF+AfEPvAJwAAB+vgPlDsQoGAAAAABJRU5ErkJggg==",
	  moved: false,
	
	  initialize: function initialize(canvas) {
	    var _this = this;
	
	    var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	
	    this.canvas = canvas;
	    this.width = opt.width || canvas.freeDrawingBrush.width;
	    this.color = opt.color || canvas.freeDrawingBrush.color;
	    this._point = new _fabric.fabric.Point();
	    this.sprayBrushDataUrl = opt.image || this.sprayBrushDataUrl;
	
	    this.canvas.contextTop.lineJoin = 'round';
	    this.canvas.contextTop.lineCap = 'round';
	
	    _fabric.fabric.Image.fromURL(this.sprayBrushDataUrl, function (brush) {
	      _this.brush = brush;
	      _this.brush.filters = [];
	      _this.changeColor(_this.color);
	    }, { crossOrigin: "anonymous" });
	  },
	
	  changeColor: function changeColor(color) {
	    this.color = color;
	    this.brush.filters[0] = new _fabric.fabric.Image.filters.Tint({ color: color });
	    this.brush.applyFilters(this.canvas.renderAll.bind(this.canvas));
	  },
	
	  _render: function _render() {
	    var ctx, lineWidthDiff, i, len, x, y;
	    var vt = this.canvas.viewportTransform;
	
	    ctx = this.canvas.contextTop;
	
	    ctx.save();
	    ctx.transform(vt[0], vt[1], vt[2], vt[3], vt[4], vt[5]);
	
	    var dist = this._point.distanceFrom(this._lastPoint);
	    var angle = this._point.angleBetween(this._lastPoint);
	
	    for (var i = 0; i < dist; i++) {
	      x = this._lastPoint.x + Math.sin(angle) * i - this._size / 2;
	      y = this._lastPoint.y + Math.cos(angle) * i - this._size / 2;
	      this.canvas.contextTop.drawImage(this.brush._element, x, y, this._size, this._size);
	    }
	
	    ctx.restore();
	  },
	
	  onMouseDown: function onMouseDown(pointer) {
	    this._point = new _fabric.fabric.Point(pointer.x, pointer.y);
	    this._lastPoint = this._point;
	    this.canvas.contextTop.strokeStyle = this.color;
	    this.canvas.contextTop.lineWidth = this._lineWidth;
	    this._size = this.width;
	    this.moved = false;
	  },
	
	  onMouseMove: function onMouseMove(pointer) {
	    this._lastPoint = this._point;
	    this._point = new _fabric.fabric.Point(pointer.x, pointer.y);
	    if (this.canvas._isCurrentlyDrawing) {
	      this._render();
	    }
	    this.moved = true;
	  },
	
	  onMouseUp: function onMouseUp() {}
	});

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _fabric = __webpack_require__(3);
	
	_fabric.fabric.JapaneseBrush = _fabric.fabric.util.createClass(_fabric.fabric.BaseBrush, {
	
	  color: "#000000",
	  width: 30,
	  minWidth: 1,
	
	  _lastPoint: null,
	  _lineWidth: 3,
	  _point: null,
	  _size: 0,
	  JapaneseBrushBase64: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAACXBIWXMAABYlAAAWJQFJUiTwAAABNmlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjarY6xSsNQFEDPi6LiUCsEcXB4kygotupgxqQtRRCs1SHJ1qShSmkSXl7VfoSjWwcXd7/AyVFwUPwC/0Bx6uAQIYODCJ7p3MPlcsGo2HWnYZRhEGvVbjrS9Xw5+8QMUwDQCbPUbrUOAOIkjvjB5ysC4HnTrjsN/sZ8mCoNTIDtbpSFICpA/0KnGsQYMIN+qkHcAaY6addAPAClXu4vQCnI/Q0oKdfzQXwAZs/1fDDmADPIfQUwdXSpAWpJOlJnvVMtq5ZlSbubBJE8HmU6GmRyPw4TlSaqo6MukP8HwGK+2G46cq1qWXvr/DOu58vc3o8QgFh6LFpBOFTn3yqMnd/n4sZ4GQ5vYXpStN0ruNmAheuirVahvAX34y/Axk/96FpPYgAAO/lpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+Cjx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgICAgICAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyI+CiAgICAgICAgIDx4bXA6Q3JlYXRvclRvb2w+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKTwveG1wOkNyZWF0b3JUb29sPgogICAgICAgICA8eG1wOkNyZWF0ZURhdGU+MjAxNi0xMS0xNFQxNzozMDo1NCswMzowMDwveG1wOkNyZWF0ZURhdGU+CiAgICAgICAgIDx4bXA6TWV0YWRhdGFEYXRlPjIwMTYtMTEtMTRUMTg6MTQ6MjMrMDM6MDA8L3htcDpNZXRhZGF0YURhdGU+CiAgICAgICAgIDx4bXA6TW9kaWZ5RGF0ZT4yMDE2LTExLTE0VDE4OjE0OjIzKzAzOjAwPC94bXA6TW9kaWZ5RGF0ZT4KICAgICAgICAgPHhtcE1NOkluc3RhbmNlSUQ+eG1wLmlpZDpkMWNlZTlkYS04OGI5LTQ3YTAtOWZlOS1iNDM3OWNiMzU4ZDg8L3htcE1NOkluc3RhbmNlSUQ+CiAgICAgICAgIDx4bXBNTTpEb2N1bWVudElEPmFkb2JlOmRvY2lkOnBob3Rvc2hvcDo2YTQ3MjgyYS1lYjBiLTExNzktYTM4Ni04MmUwMGVkNWI3YWY8L3htcE1NOkRvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+eG1wLmRpZDpkYTE3N2MxNC03NWU0LWQyNGItYTg2Zi1lNzRhNDcxNjAwYzk8L3htcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOkhpc3Rvcnk+CiAgICAgICAgICAgIDxyZGY6U2VxPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jcmVhdGVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6ZGExNzdjMTQtNzVlNC1kMjRiLWE4NmYtZTc0YTQ3MTYwMGM5PC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE2LTExLTE0VDE3OjMwOjU0KzAzOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOmI3ZTNhODBmLTU1MmQtNzA0NC1iYzBhLTk1OGQwMTM0ZjQzNTwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNi0xMS0xNFQxNzozMDo1NCswMzowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDpkMWNlZTlkYS04OGI5LTQ3YTAtOWZlOS1iNDM3OWNiMzU4ZDg8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTYtMTEtMTRUMTg6MTQ6MjMrMDM6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1LjUgKE1hY2ludG9zaCk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICA8L3JkZjpTZXE+CiAgICAgICAgIDwveG1wTU06SGlzdG9yeT4KICAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9wbmc8L2RjOmZvcm1hdD4KICAgICAgICAgPHBob3Rvc2hvcDpDb2xvck1vZGU+MzwvcGhvdG9zaG9wOkNvbG9yTW9kZT4KICAgICAgICAgPHBob3Rvc2hvcDpJQ0NQcm9maWxlPkFkb2JlIFJHQiAoMTk5OCk8L3Bob3Rvc2hvcDpJQ0NQcm9maWxlPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICAgICA8dGlmZjpYUmVzb2x1dGlvbj4xNDQwMDAwLzEwMDAwPC90aWZmOlhSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpZUmVzb2x1dGlvbj4xNDQwMDAwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjY1NTM1PC9leGlmOkNvbG9yU3BhY2U+CiAgICAgICAgIDxleGlmOlBpeGVsWERpbWVuc2lvbj4xMDA8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+MTAwPC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4CybhPAAAAIGNIUk0AAHolAACAgwAA+f8AAIDoAABSCAABFVgAADqXAAAXb9daH5AAAB2dSURBVHja7L1LjyRXlt/5+59rZu6eycisSnaymtWlgZoCJEHZwEDo0W6A4WK2WrI/xHwJsb9Ef4naazULzkrQQrshFzNoNacFkYKS+YqXuz3u+c/imkdEPljF4jNIpQEO9/AIzzS3n533OffKNm+P23PE20vwFsjb4y2Qt0DeHm+BvAXy9ngL5Jd/6E/5m2PE8rdf87l/t/7JH/lH3wY+3wKIAD5enz/lIwE84vHV37/P2dXrf86J/69X/oFPeXjjwv+e9vkG44+A81sgr7z3MehTPtIjHut9zvQlH+gB53rKXvcYdcok+O1rH7zHVwY4ZWOAJ+yuLu67/KPfZ+v/BPyWEwN8Ajzkod8ETP+DgtKbYMCHAQ8DHgecBGwDzgP2seGuNiw6sLz02S2dT4ENnUd6bzn3M2BH7x2995z6LoMv2PgeX/m/APfZ+AjtVWD/iof+PfCI3/umStQvHJJehfEFf13+ivfiKV2BpdsQxWTXodIRZeJQuu2gmdQWOKwf7gkfgO4wWfTZUzwTXhgNmxw4eKYYptzSWexy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',
	  moved: false,
	  points: [],
	  velocityFilterWeight: 0.1,
	  _lastVelocity: 0,
	  _lastWidth: 0,
	
	  initialize: function initialize(canvas) {
	    var _this = this;
	
	    var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	
	    this.canvas = canvas;
	    this.width = opt.width || canvas.freeDrawingBrush.width;
	    this.color = opt.color || canvas.freeDrawingBrush.color;
	    this._point = new _fabric.fabric.Point();
	    this.JapaneseBrushBase64 = opt.image || this.JapaneseBrushBase64;
	
	    this.canvas.contextTop.lineJoin = 'round';
	    this.canvas.contextTop.lineCap = 'round';
	
	    _fabric.fabric.Image.fromURL(this.JapaneseBrushBase64, function (brush) {
	      _this.brush = brush;
	      _this.brush.filters = [];
	      _this.changeColor(_this.color);
	    }, { crossOrigin: "anonymous" });
	  },
	
	  changeColor: function changeColor(color) {
	    this.color = new _fabric.fabric.Color(color).toRgba();
	    this.opacity = /(,(\s)*(\d(\.\d(\d*))*)\))/g.exec(this.color)[3];
	    this.brush.filters[0] = new _fabric.fabric.Image.filters.Tint({ color: '#' + new _fabric.fabric.Color(color).toHex() });
	    this.brush.applyFilters(this.canvas.renderAll.bind(this.canvas));
	  },
	
	  onMouseDown: function onMouseDown(pointer) {
	    this.moved = false;
	    this.points = [];
	    this._lastVelocity = 0;
	    this._lastWidth = 0;
	    this._strokeUpdate(pointer);
	  },
	
	  onMouseMove: function onMouseMove(pointer) {
	
	    this.moved = true;
	    if (this.canvas._isCurrentlyDrawing) {
	      this._strokeUpdate(pointer);
	    }
	  },
	
	  onMouseUp: function onMouseUp() {
	    var canDrawCurve = this.points.length > 2;
	    var point = this.points[0];
	
	    if (!canDrawCurve && point) {
	      var vt = this.canvas.viewportTransform;
	      var ctx = this.canvas.contextTop;
	
	      ctx.save();
	      ctx.transform(vt[0], vt[1], vt[2], vt[3], vt[4], vt[5]);
	      ctx.globalAlpha = this.opacity;
	      this._drawPoint(ctx, point.x, point.y, (this.width + this.minWidth) / 2);
	      ctx.restore();
	    }
	
	    this.points = [];
	    this._lastVelocity = 0;
	    this._lastWidth = 0;
	  },
	
	  _strokeUpdate: function _strokeUpdate(pointer) {
	    var point = new Point(pointer.x, pointer.y);
	    this._addPoint(point);
	  },
	  _addPoint: function _addPoint(point) {
	    var _points = this.points,
	        c2,
	        c3,
	        curve,
	        tmp;
	
	    _points.push(point);
	
	    if (_points.length > 2) {
	      // To reduce the initial lag make it work with 3 _points
	      // by copying the first point to the beginning.
	      if (_points.length === 3) _points.unshift(_points[0]);
	
	      tmp = this._calculateCurveControlPoints(_points[0], _points[1], _points[2]);
	      c2 = tmp.c2;
	      tmp = this._calculateCurveControlPoints(_points[1], _points[2], _points[3]);
	      c3 = tmp.c1;
	      curve = new Bezier(_points[1], c2, c3, _points[2]);
	      this._addCurve(curve);
	
	      // Remove the first element from the list,
	      // so that we always have no more than 4 _points in _points array.
	      _points.shift();
	    }
	  },
	  _calculateCurveControlPoints: function _calculateCurveControlPoints(s1, s2, s3) {
	    var dx1 = s1.x - s2.x,
	        dy1 = s1.y - s2.y,
	        dx2 = s2.x - s3.x,
	        dy2 = s2.y - s3.y,
	        m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 },
	        m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 },
	        l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1),
	        l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2),
	        dxm = m1.x - m2.x,
	        dym = m1.y - m2.y,
	        k = l2 / (l1 + l2),
	        cm = { x: m2.x + dxm * k, y: m2.y + dym * k },
	        tx = s2.x - cm.x,
	        ty = s2.y - cm.y;
	
	    return {
	      c1: new Point(m1.x + tx, m1.y + ty),
	      c2: new Point(m2.x + tx, m2.y + ty)
	    };
	  },
	  _addCurve: function _addCurve(curve) {
	    var startPoint = curve.startPoint,
	        endPoint = curve.endPoint,
	        velocity,
	        newWidth;
	
	    velocity = endPoint.velocityFrom(startPoint);
	    velocity = this.velocityFilterWeight * velocity + (1 - this.velocityFilterWeight) * this._lastVelocity;
	
	    newWidth = this._strokeWidth(velocity);
	    this._drawCurve(curve, this._lastWidth, newWidth);
	
	    this._lastVelocity = velocity;
	    this._lastWidth = newWidth;
	  },
	  _drawPoint: function _drawPoint(ctx, x, y, size) {
	    ctx.drawImage(this.brush._element, x - size / 2, y - size / 2, size, size);
	  },
	  _drawCurve: function _drawCurve(curve, startWidth, endWidth) {
	    var ctx = this.canvas.contextTop;
	
	    var widthDelta = endWidth - startWidth,
	        drawSteps,
	        width,
	        i,
	        t,
	        tt,
	        ttt,
	        u,
	        uu,
	        uuu,
	        x,
	        y;
	
	    var vt = this.canvas.viewportTransform;
	
	    ctx.save();
	    ctx.transform(vt[0], vt[1], vt[2], vt[3], vt[4], vt[5]);
	    ctx.globalAlpha = this.opacity;
	
	    drawSteps = Math.floor(curve.length());
	    ctx.beginPath();
	    for (i = 0; i < drawSteps; i++) {
	      // Calculate the Bezier (x, y) coordinate for this step.
	      t = i / drawSteps;
	      tt = t * t;
	      ttt = tt * t;
	      u = 1 - t;
	      uu = u * u;
	      uuu = uu * u;
	
	      x = uuu * curve.startPoint.x;
	      x += 3 * uu * t * curve.control1.x;
	      x += 3 * u * tt * curve.control2.x;
	      x += ttt * curve.endPoint.x;
	
	      y = uuu * curve.startPoint.y;
	      y += 3 * uu * t * curve.control1.y;
	      y += 3 * u * tt * curve.control2.y;
	      y += ttt * curve.endPoint.y;
	
	      width = startWidth + t * widthDelta;
	      this._drawPoint(ctx, x, y, width);
	    }
	    ctx.closePath();
	    ctx.fill();
	    ctx.restore();
	  },
	  _strokeWidth: function _strokeWidth(velocity) {
	    return Math.max(this.width / (velocity + 1), this.minWidth);
	  }
	});
	
	var Point = function Point(x, y, time) {
	  this.x = x;
	  this.y = y;
	  this.time = time || new Date().getTime();
	};
	
	Point.prototype.velocityFrom = function (start) {
	  return this.time !== start.time ? this.distanceTo(start) / (this.time - start.time) : 1;
	};
	
	Point.prototype.distanceTo = function (start) {
	  return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));
	};
	
	var Bezier = function Bezier(startPoint, control1, control2, endPoint) {
	  this.startPoint = startPoint;
	  this.control1 = control1;
	  this.control2 = control2;
	  this.endPoint = endPoint;
	};
	
	// Returns approximated length.
	Bezier.prototype.length = function () {
	  var steps = 10,
	      length = 0,
	      i,
	      t,
	      cx,
	      cy,
	      px,
	      py,
	      xdiff,
	      ydiff;
	
	  for (i = 0; i <= steps; i++) {
	    t = i / steps;
	    cx = this._point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);
	    cy = this._point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);
	    if (i > 0) {
	      xdiff = cx - px;
	      ydiff = cy - py;
	      length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);
	    }
	    px = cx;
	    py = cy;
	  }
	  return length;
	};
	
	Bezier.prototype._point = function (t, start, c1, c2, end) {
	  return start * (1.0 - t) * (1.0 - t) * (1.0 - t) + 3.0 * c1 * (1.0 - t) * (1.0 - t) * t + 3.0 * c2 * (1.0 - t) * t * t + end * t * t * t;
	};

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _fabric = __webpack_require__(3);
	
	var extend = _fabric.fabric.util.object.extend;
	var filters = _fabric.fabric.Image.filters;
	var createClass = _fabric.fabric.util.createClass;
	
	filters.RemoveColor = createClass(filters.BaseFilter, {
	
	  type: 'RemoveColor',
	
	  initialize: function initialize(options) {
	    options = options || {};
	
	    this.color = options.color || '#ffffff';
	
	    this.distance = options.distance === undefined ? 1 : Number(options.distance);
	  },
	
	  applyTo: function applyTo(canvasEl) {
	    var context = canvasEl.getContext('2d'),
	        imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	        data = imageData.data,
	        color = new _fabric.fabric.Color(this.color),
	        threshold = 60,
	        distance = this.distance,
	        limit = 255 - threshold,
	        r,
	        g,
	        b;
	
	    for (var i = 0, len = data.length; i < len; i += 4) {
	      r = data[i];
	      g = data[i + 1];
	      b = data[i + 2];
	
	      if (Math.abs(r - color._source[0]) < distance && Math.abs(g - color._source[1]) < distance && Math.abs(b - color._source[2]) < distance) {
	        data[i + 3] = 0;
	      }
	    }
	    context.putImageData(imageData, 0, 0);
	  },
	
	  toObject: function toObject() {
	    return extend(this.callSuper('toObject'), {
	      color: this.color,
	      distance: this.distance
	    });
	  }
	});
	
	_fabric.fabric.Image.filters.RemoveColor.fromObject = function (object) {
	  return new _fabric.fabric.Image.filters.RemoveColor(object);
	};

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	__webpack_require__(77);
	
	__webpack_require__(368);
	
	__webpack_require__(369);
	
	if (global._babelPolyfill) {
	  throw new Error("only one instance of babel-polyfill is allowed");
	}
	global._babelPolyfill = true;
	
	var DEFINE_PROPERTY = "defineProperty";
	function define(O, key, value) {
	  O[key] || Object[DEFINE_PROPERTY](O, key, {
	    writable: true,
	    configurable: true,
	    value: value
	  });
	}
	
	define(String.prototype, "padLeft", "".padStart);
	define(String.prototype, "padRight", "".padEnd);
	
	"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
	  [][key] && define(Array, key, Function.call.bind([][key]));
	});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(78);
	__webpack_require__(127);
	__webpack_require__(128);
	__webpack_require__(129);
	__webpack_require__(130);
	__webpack_require__(132);
	__webpack_require__(135);
	__webpack_require__(136);
	__webpack_require__(137);
	__webpack_require__(138);
	__webpack_require__(139);
	__webpack_require__(140);
	__webpack_require__(141);
	__webpack_require__(142);
	__webpack_require__(143);
	__webpack_require__(145);
	__webpack_require__(147);
	__webpack_require__(149);
	__webpack_require__(151);
	__webpack_require__(154);
	__webpack_require__(155);
	__webpack_require__(156);
	__webpack_require__(160);
	__webpack_require__(162);
	__webpack_require__(164);
	__webpack_require__(167);
	__webpack_require__(168);
	__webpack_require__(169);
	__webpack_require__(170);
	__webpack_require__(172);
	__webpack_require__(173);
	__webpack_require__(174);
	__webpack_require__(175);
	__webpack_require__(176);
	__webpack_require__(177);
	__webpack_require__(178);
	__webpack_require__(180);
	__webpack_require__(181);
	__webpack_require__(182);
	__webpack_require__(184);
	__webpack_require__(185);
	__webpack_require__(186);
	__webpack_require__(188);
	__webpack_require__(189);
	__webpack_require__(190);
	__webpack_require__(191);
	__webpack_require__(192);
	__webpack_require__(193);
	__webpack_require__(194);
	__webpack_require__(195);
	__webpack_require__(196);
	__webpack_require__(197);
	__webpack_require__(198);
	__webpack_require__(199);
	__webpack_require__(200);
	__webpack_require__(201);
	__webpack_require__(206);
	__webpack_require__(207);
	__webpack_require__(211);
	__webpack_require__(212);
	__webpack_require__(213);
	__webpack_require__(214);
	__webpack_require__(216);
	__webpack_require__(217);
	__webpack_require__(218);
	__webpack_require__(219);
	__webpack_require__(220);
	__webpack_require__(221);
	__webpack_require__(222);
	__webpack_require__(223);
	__webpack_require__(224);
	__webpack_require__(225);
	__webpack_require__(226);
	__webpack_require__(227);
	__webpack_require__(228);
	__webpack_require__(229);
	__webpack_require__(230);
	__webpack_require__(231);
	__webpack_require__(232);
	__webpack_require__(234);
	__webpack_require__(235);
	__webpack_require__(241);
	__webpack_require__(242);
	__webpack_require__(244);
	__webpack_require__(245);
	__webpack_require__(246);
	__webpack_require__(250);
	__webpack_require__(251);
	__webpack_require__(252);
	__webpack_require__(253);
	__webpack_require__(254);
	__webpack_require__(256);
	__webpack_require__(257);
	__webpack_require__(258);
	__webpack_require__(259);
	__webpack_require__(262);
	__webpack_require__(264);
	__webpack_require__(265);
	__webpack_require__(266);
	__webpack_require__(268);
	__webpack_require__(270);
	__webpack_require__(272);
	__webpack_require__(273);
	__webpack_require__(274);
	__webpack_require__(276);
	__webpack_require__(277);
	__webpack_require__(278);
	__webpack_require__(279);
	__webpack_require__(286);
	__webpack_require__(289);
	__webpack_require__(290);
	__webpack_require__(292);
	__webpack_require__(293);
	__webpack_require__(296);
	__webpack_require__(297);
	__webpack_require__(299);
	__webpack_require__(300);
	__webpack_require__(301);
	__webpack_require__(302);
	__webpack_require__(303);
	__webpack_require__(304);
	__webpack_require__(305);
	__webpack_require__(306);
	__webpack_require__(307);
	__webpack_require__(308);
	__webpack_require__(309);
	__webpack_require__(310);
	__webpack_require__(311);
	__webpack_require__(312);
	__webpack_require__(313);
	__webpack_require__(314);
	__webpack_require__(315);
	__webpack_require__(316);
	__webpack_require__(317);
	__webpack_require__(319);
	__webpack_require__(320);
	__webpack_require__(321);
	__webpack_require__(322);
	__webpack_require__(323);
	__webpack_require__(324);
	__webpack_require__(326);
	__webpack_require__(327);
	__webpack_require__(328);
	__webpack_require__(329);
	__webpack_require__(330);
	__webpack_require__(331);
	__webpack_require__(332);
	__webpack_require__(333);
	__webpack_require__(335);
	__webpack_require__(336);
	__webpack_require__(338);
	__webpack_require__(339);
	__webpack_require__(340);
	__webpack_require__(341);
	__webpack_require__(344);
	__webpack_require__(345);
	__webpack_require__(346);
	__webpack_require__(347);
	__webpack_require__(348);
	__webpack_require__(349);
	__webpack_require__(350);
	__webpack_require__(351);
	__webpack_require__(353);
	__webpack_require__(354);
	__webpack_require__(355);
	__webpack_require__(356);
	__webpack_require__(357);
	__webpack_require__(358);
	__webpack_require__(359);
	__webpack_require__(360);
	__webpack_require__(361);
	__webpack_require__(362);
	__webpack_require__(363);
	__webpack_require__(366);
	__webpack_require__(367);
	module.exports = __webpack_require__(84);

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(79)
	  , has            = __webpack_require__(80)
	  , DESCRIPTORS    = __webpack_require__(81)
	  , $export        = __webpack_require__(83)
	  , redefine       = __webpack_require__(93)
	  , META           = __webpack_require__(97).KEY
	  , $fails         = __webpack_require__(82)
	  , shared         = __webpack_require__(98)
	  , setToStringTag = __webpack_require__(99)
	  , uid            = __webpack_require__(94)
	  , wks            = __webpack_require__(100)
	  , wksExt         = __webpack_require__(101)
	  , wksDefine      = __webpack_require__(102)
	  , keyOf          = __webpack_require__(104)
	  , enumKeys       = __webpack_require__(117)
	  , isArray        = __webpack_require__(120)
	  , anObject       = __webpack_require__(87)
	  , toIObject      = __webpack_require__(107)
	  , toPrimitive    = __webpack_require__(91)
	  , createDesc     = __webpack_require__(92)
	  , _create        = __webpack_require__(121)
	  , gOPNExt        = __webpack_require__(124)
	  , $GOPD          = __webpack_require__(126)
	  , $DP            = __webpack_require__(86)
	  , $keys          = __webpack_require__(105)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(125).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(119).f  = $propertyIsEnumerable;
	  __webpack_require__(118).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(103)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);
	
	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(85)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 79 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 80 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(82)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 82 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(79)
	  , core      = __webpack_require__(84)
	  , hide      = __webpack_require__(85)
	  , redefine  = __webpack_require__(93)
	  , ctx       = __webpack_require__(95)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
	    , key, own, out, exp;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // extend global
	    if(target)redefine(target, key, out, type & $export.U);
	    // export
	    if(exports[key] != out)hide(exports, key, exp);
	    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
	  }
	};
	global.core = core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 84 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(86)
	  , createDesc = __webpack_require__(92);
	module.exports = __webpack_require__(81) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(87)
	  , IE8_DOM_DEFINE = __webpack_require__(89)
	  , toPrimitive    = __webpack_require__(91)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(81) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(88);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 88 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(81) && !__webpack_require__(82)(function(){
	  return Object.defineProperty(__webpack_require__(90)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(88)
	  , document = __webpack_require__(79).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(88);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 92 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(79)
	  , hide      = __webpack_require__(85)
	  , has       = __webpack_require__(80)
	  , SRC       = __webpack_require__(94)('src')
	  , TO_STRING = 'toString'
	  , $toString = Function[TO_STRING]
	  , TPL       = ('' + $toString).split(TO_STRING);
	
	__webpack_require__(84).inspectSource = function(it){
	  return $toString.call(it);
	};
	
	(module.exports = function(O, key, val, safe){
	  var isFunction = typeof val == 'function';
	  if(isFunction)has(val, 'name') || hide(val, 'name', key);
	  if(O[key] === val)return;
	  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	  if(O === global){
	    O[key] = val;
	  } else {
	    if(!safe){
	      delete O[key];
	      hide(O, key, val);
	    } else {
	      if(O[key])O[key] = val;
	      else hide(O, key, val);
	    }
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString(){
	  return typeof this == 'function' && this[SRC] || $toString.call(this);
	});

/***/ },
/* 94 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(96);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 96 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(94)('meta')
	  , isObject = __webpack_require__(88)
	  , has      = __webpack_require__(80)
	  , setDesc  = __webpack_require__(86).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(82)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(79)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(86).f
	  , has = __webpack_require__(80)
	  , TAG = __webpack_require__(100)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(98)('wks')
	  , uid        = __webpack_require__(94)
	  , Symbol     = __webpack_require__(79).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(100);

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(79)
	  , core           = __webpack_require__(84)
	  , LIBRARY        = __webpack_require__(103)
	  , wksExt         = __webpack_require__(101)
	  , defineProperty = __webpack_require__(86).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 103 */
/***/ function(module, exports) {

	module.exports = false;

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(105)
	  , toIObject = __webpack_require__(107);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(106)
	  , enumBugKeys = __webpack_require__(116);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(80)
	  , toIObject    = __webpack_require__(107)
	  , arrayIndexOf = __webpack_require__(111)(false)
	  , IE_PROTO     = __webpack_require__(115)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(108)
	  , defined = __webpack_require__(110);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(109);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 109 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 110 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(107)
	  , toLength  = __webpack_require__(112)
	  , toIndex   = __webpack_require__(114);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(113)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 113 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(113)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(98)('keys')
	  , uid    = __webpack_require__(94);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 116 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(105)
	  , gOPS    = __webpack_require__(118)
	  , pIE     = __webpack_require__(119);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 118 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 119 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(109);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(87)
	  , dPs         = __webpack_require__(122)
	  , enumBugKeys = __webpack_require__(116)
	  , IE_PROTO    = __webpack_require__(115)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(90)('iframe')
	    , i      = enumBugKeys.length
	    , lt     = '<'
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(123).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(86)
	  , anObject = __webpack_require__(87)
	  , getKeys  = __webpack_require__(105);
	
	module.exports = __webpack_require__(81) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(79).document && document.documentElement;

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(107)
	  , gOPN      = __webpack_require__(125).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(106)
	  , hiddenKeys = __webpack_require__(116).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(119)
	  , createDesc     = __webpack_require__(92)
	  , toIObject      = __webpack_require__(107)
	  , toPrimitive    = __webpack_require__(91)
	  , has            = __webpack_require__(80)
	  , IE8_DOM_DEFINE = __webpack_require__(89)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(81) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(83)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(121)});

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(83);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(81), 'Object', {defineProperty: __webpack_require__(86).f});

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(83);
	// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
	$export($export.S + $export.F * !__webpack_require__(81), 'Object', {defineProperties: __webpack_require__(122)});

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	var toIObject                 = __webpack_require__(107)
	  , $getOwnPropertyDescriptor = __webpack_require__(126).f;
	
	__webpack_require__(131)('getOwnPropertyDescriptor', function(){
	  return function getOwnPropertyDescriptor(it, key){
	    return $getOwnPropertyDescriptor(toIObject(it), key);
	  };
	});

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(83)
	  , core    = __webpack_require__(84)
	  , fails   = __webpack_require__(82);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject        = __webpack_require__(133)
	  , $getPrototypeOf = __webpack_require__(134);
	
	__webpack_require__(131)('getPrototypeOf', function(){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(110);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(80)
	  , toObject    = __webpack_require__(133)
	  , IE_PROTO    = __webpack_require__(115)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(133)
	  , $keys    = __webpack_require__(105);
	
	__webpack_require__(131)('keys', function(){
	  return function keys(it){
	    return $keys(toObject(it));
	  };
	});

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 Object.getOwnPropertyNames(O)
	__webpack_require__(131)('getOwnPropertyNames', function(){
	  return __webpack_require__(124).f;
	});

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.5 Object.freeze(O)
	var isObject = __webpack_require__(88)
	  , meta     = __webpack_require__(97).onFreeze;
	
	__webpack_require__(131)('freeze', function($freeze){
	  return function freeze(it){
	    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
	  };
	});

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.17 Object.seal(O)
	var isObject = __webpack_require__(88)
	  , meta     = __webpack_require__(97).onFreeze;
	
	__webpack_require__(131)('seal', function($seal){
	  return function seal(it){
	    return $seal && isObject(it) ? $seal(meta(it)) : it;
	  };
	});

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.15 Object.preventExtensions(O)
	var isObject = __webpack_require__(88)
	  , meta     = __webpack_require__(97).onFreeze;
	
	__webpack_require__(131)('preventExtensions', function($preventExtensions){
	  return function preventExtensions(it){
	    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
	  };
	});

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.12 Object.isFrozen(O)
	var isObject = __webpack_require__(88);
	
	__webpack_require__(131)('isFrozen', function($isFrozen){
	  return function isFrozen(it){
	    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
	  };
	});

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.13 Object.isSealed(O)
	var isObject = __webpack_require__(88);
	
	__webpack_require__(131)('isSealed', function($isSealed){
	  return function isSealed(it){
	    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
	  };
	});

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.11 Object.isExtensible(O)
	var isObject = __webpack_require__(88);
	
	__webpack_require__(131)('isExtensible', function($isExtensible){
	  return function isExtensible(it){
	    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
	  };
	});

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(83);
	
	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(144)});

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(105)
	  , gOPS     = __webpack_require__(118)
	  , pIE      = __webpack_require__(119)
	  , toObject = __webpack_require__(133)
	  , IObject  = __webpack_require__(108)
	  , $assign  = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(82)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.10 Object.is(value1, value2)
	var $export = __webpack_require__(83);
	$export($export.S, 'Object', {is: __webpack_require__(146)});

/***/ },
/* 146 */
/***/ function(module, exports) {

	// 7.2.9 SameValue(x, y)
	module.exports = Object.is || function is(x, y){
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(83);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(148).set});

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(88)
	  , anObject = __webpack_require__(87);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(95)(Function.call, __webpack_require__(126).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.3.6 Object.prototype.toString()
	var classof = __webpack_require__(150)
	  , test    = {};
	test[__webpack_require__(100)('toStringTag')] = 'z';
	if(test + '' != '[object z]'){
	  __webpack_require__(93)(Object.prototype, 'toString', function toString(){
	    return '[object ' + classof(this) + ']';
	  }, true);
	}

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(109)
	  , TAG = __webpack_require__(100)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
	var $export = __webpack_require__(83);
	
	$export($export.P, 'Function', {bind: __webpack_require__(152)});

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var aFunction  = __webpack_require__(96)
	  , isObject   = __webpack_require__(88)
	  , invoke     = __webpack_require__(153)
	  , arraySlice = [].slice
	  , factories  = {};
	
	var construct = function(F, len, args){
	  if(!(len in factories)){
	    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
	    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
	  } return factories[len](F, args);
	};
	
	module.exports = Function.bind || function bind(that /*, args... */){
	  var fn       = aFunction(this)
	    , partArgs = arraySlice.call(arguments, 1);
	  var bound = function(/* args... */){
	    var args = partArgs.concat(arraySlice.call(arguments));
	    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
	  };
	  if(isObject(fn.prototype))bound.prototype = fn.prototype;
	  return bound;
	};

/***/ },
/* 153 */
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(86).f
	  , createDesc = __webpack_require__(92)
	  , has        = __webpack_require__(80)
	  , FProto     = Function.prototype
	  , nameRE     = /^\s*function ([^ (]*)/
	  , NAME       = 'name';
	
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	
	// 19.2.4.2 name
	NAME in FProto || __webpack_require__(81) && dP(FProto, NAME, {
	  configurable: true,
	  get: function(){
	    try {
	      var that = this
	        , name = ('' + that).match(nameRE)[1];
	      has(that, NAME) || !isExtensible(that) || dP(that, NAME, createDesc(5, name));
	      return name;
	    } catch(e){
	      return '';
	    }
	  }
	});

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var isObject       = __webpack_require__(88)
	  , getPrototypeOf = __webpack_require__(134)
	  , HAS_INSTANCE   = __webpack_require__(100)('hasInstance')
	  , FunctionProto  = Function.prototype;
	// 19.2.3.6 Function.prototype[@@hasInstance](V)
	if(!(HAS_INSTANCE in FunctionProto))__webpack_require__(86).f(FunctionProto, HAS_INSTANCE, {value: function(O){
	  if(typeof this != 'function' || !isObject(O))return false;
	  if(!isObject(this.prototype))return O instanceof this;
	  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	  while(O = getPrototypeOf(O))if(this.prototype === O)return true;
	  return false;
	}});

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(83)
	  , $parseInt = __webpack_require__(157);
	// 18.2.5 parseInt(string, radix)
	$export($export.G + $export.F * (parseInt != $parseInt), {parseInt: $parseInt});

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	var $parseInt = __webpack_require__(79).parseInt
	  , $trim     = __webpack_require__(158).trim
	  , ws        = __webpack_require__(159)
	  , hex       = /^[\-+]?0[xX]/;
	
	module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix){
	  var string = $trim(String(str), 3);
	  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
	} : $parseInt;

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(83)
	  , defined = __webpack_require__(110)
	  , fails   = __webpack_require__(82)
	  , spaces  = __webpack_require__(159)
	  , space   = '[' + spaces + ']'
	  , non     = '\u200b\u0085'
	  , ltrim   = RegExp('^' + space + space + '*')
	  , rtrim   = RegExp(space + space + '*$');
	
	var exporter = function(KEY, exec, ALIAS){
	  var exp   = {};
	  var FORCE = fails(function(){
	    return !!spaces[KEY]() || non[KEY]() != non;
	  });
	  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
	  if(ALIAS)exp[ALIAS] = fn;
	  $export($export.P + $export.F * FORCE, 'String', exp);
	};
	
	// 1 -> String#trimLeft
	// 2 -> String#trimRight
	// 3 -> String#trim
	var trim = exporter.trim = function(string, TYPE){
	  string = String(defined(string));
	  if(TYPE & 1)string = string.replace(ltrim, '');
	  if(TYPE & 2)string = string.replace(rtrim, '');
	  return string;
	};
	
	module.exports = exporter;

/***/ },
/* 159 */
/***/ function(module, exports) {

	module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	var $export     = __webpack_require__(83)
	  , $parseFloat = __webpack_require__(161);
	// 18.2.4 parseFloat(string)
	$export($export.G + $export.F * (parseFloat != $parseFloat), {parseFloat: $parseFloat});

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	var $parseFloat = __webpack_require__(79).parseFloat
	  , $trim       = __webpack_require__(158).trim;
	
	module.exports = 1 / $parseFloat(__webpack_require__(159) + '-0') !== -Infinity ? function parseFloat(str){
	  var string = $trim(String(str), 3)
	    , result = $parseFloat(string);
	  return result === 0 && string.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global            = __webpack_require__(79)
	  , has               = __webpack_require__(80)
	  , cof               = __webpack_require__(109)
	  , inheritIfRequired = __webpack_require__(163)
	  , toPrimitive       = __webpack_require__(91)
	  , fails             = __webpack_require__(82)
	  , gOPN              = __webpack_require__(125).f
	  , gOPD              = __webpack_require__(126).f
	  , dP                = __webpack_require__(86).f
	  , $trim             = __webpack_require__(158).trim
	  , NUMBER            = 'Number'
	  , $Number           = global[NUMBER]
	  , Base              = $Number
	  , proto             = $Number.prototype
	  // Opera ~12 has broken Object#toString
	  , BROKEN_COF        = cof(__webpack_require__(121)(proto)) == NUMBER
	  , TRIM              = 'trim' in String.prototype;
	
	// 7.1.3 ToNumber(argument)
	var toNumber = function(argument){
	  var it = toPrimitive(argument, false);
	  if(typeof it == 'string' && it.length > 2){
	    it = TRIM ? it.trim() : $trim(it, 3);
	    var first = it.charCodeAt(0)
	      , third, radix, maxCode;
	    if(first === 43 || first === 45){
	      third = it.charCodeAt(2);
	      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if(first === 48){
	      switch(it.charCodeAt(1)){
	        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
	        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
	        default : return +it;
	      }
	      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){
	        code = digits.charCodeAt(i);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if(code < 48 || code > maxCode)return NaN;
	      } return parseInt(digits, radix);
	    }
	  } return +it;
	};
	
	if(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){
	  $Number = function Number(value){
	    var it = arguments.length < 1 ? 0 : value
	      , that = this;
	    return that instanceof $Number
	      // check on 1..constructor(foo) case
	      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)
	        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
	  };
	  for(var keys = __webpack_require__(81) ? gOPN(Base) : (
	    // ES3:
	    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	    // ES6 (in case, if modules with ES6 Number statics required before):
	    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
	    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
	  ).split(','), j = 0, key; keys.length > j; j++){
	    if(has(Base, key = keys[j]) && !has($Number, key)){
	      dP($Number, key, gOPD(Base, key));
	    }
	  }
	  $Number.prototype = proto;
	  proto.constructor = $Number;
	  __webpack_require__(93)(global, NUMBER, $Number);
	}

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	var isObject       = __webpack_require__(88)
	  , setPrototypeOf = __webpack_require__(148).set;
	module.exports = function(that, target, C){
	  var P, S = target.constructor;
	  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){
	    setPrototypeOf(that, P);
	  } return that;
	};

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(83)
	  , toInteger    = __webpack_require__(113)
	  , aNumberValue = __webpack_require__(165)
	  , repeat       = __webpack_require__(166)
	  , $toFixed     = 1..toFixed
	  , floor        = Math.floor
	  , data         = [0, 0, 0, 0, 0, 0]
	  , ERROR        = 'Number.toFixed: incorrect invocation!'
	  , ZERO         = '0';
	
	var multiply = function(n, c){
	  var i  = -1
	    , c2 = c;
	  while(++i < 6){
	    c2 += n * data[i];
	    data[i] = c2 % 1e7;
	    c2 = floor(c2 / 1e7);
	  }
	};
	var divide = function(n){
	  var i = 6
	    , c = 0;
	  while(--i >= 0){
	    c += data[i];
	    data[i] = floor(c / n);
	    c = (c % n) * 1e7;
	  }
	};
	var numToString = function(){
	  var i = 6
	    , s = '';
	  while(--i >= 0){
	    if(s !== '' || i === 0 || data[i] !== 0){
	      var t = String(data[i]);
	      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
	    }
	  } return s;
	};
	var pow = function(x, n, acc){
	  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
	};
	var log = function(x){
	  var n  = 0
	    , x2 = x;
	  while(x2 >= 4096){
	    n += 12;
	    x2 /= 4096;
	  }
	  while(x2 >= 2){
	    n  += 1;
	    x2 /= 2;
	  } return n;
	};
	
	$export($export.P + $export.F * (!!$toFixed && (
	  0.00008.toFixed(3) !== '0.000' ||
	  0.9.toFixed(0) !== '1' ||
	  1.255.toFixed(2) !== '1.25' ||
	  1000000000000000128..toFixed(0) !== '1000000000000000128'
	) || !__webpack_require__(82)(function(){
	  // V8 ~ Android 4.3-
	  $toFixed.call({});
	})), 'Number', {
	  toFixed: function toFixed(fractionDigits){
	    var x = aNumberValue(this, ERROR)
	      , f = toInteger(fractionDigits)
	      , s = ''
	      , m = ZERO
	      , e, z, j, k;
	    if(f < 0 || f > 20)throw RangeError(ERROR);
	    if(x != x)return 'NaN';
	    if(x <= -1e21 || x >= 1e21)return String(x);
	    if(x < 0){
	      s = '-';
	      x = -x;
	    }
	    if(x > 1e-21){
	      e = log(x * pow(2, 69, 1)) - 69;
	      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;
	      if(e > 0){
	        multiply(0, z);
	        j = f;
	        while(j >= 7){
	          multiply(1e7, 0);
	          j -= 7;
	        }
	        multiply(pow(10, j, 1), 0);
	        j = e - 1;
	        while(j >= 23){
	          divide(1 << 23);
	          j -= 23;
	        }
	        divide(1 << j);
	        multiply(1, 1);
	        divide(2);
	        m = numToString();
	      } else {
	        multiply(0, z);
	        multiply(1 << -e, 0);
	        m = numToString() + repeat.call(ZERO, f);
	      }
	    }
	    if(f > 0){
	      k = m.length;
	      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
	    } else {
	      m = s + m;
	    } return m;
	  }
	});

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	var cof = __webpack_require__(109);
	module.exports = function(it, msg){
	  if(typeof it != 'number' && cof(it) != 'Number')throw TypeError(msg);
	  return +it;
	};

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var toInteger = __webpack_require__(113)
	  , defined   = __webpack_require__(110);
	
	module.exports = function repeat(count){
	  var str = String(defined(this))
	    , res = ''
	    , n   = toInteger(count);
	  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
	  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
	  return res;
	};

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(83)
	  , $fails       = __webpack_require__(82)
	  , aNumberValue = __webpack_require__(165)
	  , $toPrecision = 1..toPrecision;
	
	$export($export.P + $export.F * ($fails(function(){
	  // IE7-
	  return $toPrecision.call(1, undefined) !== '1';
	}) || !$fails(function(){
	  // V8 ~ Android 4.3-
	  $toPrecision.call({});
	})), 'Number', {
	  toPrecision: function toPrecision(precision){
	    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
	    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision); 
	  }
	});

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.1 Number.EPSILON
	var $export = __webpack_require__(83);
	
	$export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.2 Number.isFinite(number)
	var $export   = __webpack_require__(83)
	  , _isFinite = __webpack_require__(79).isFinite;
	
	$export($export.S, 'Number', {
	  isFinite: function isFinite(it){
	    return typeof it == 'number' && _isFinite(it);
	  }
	});

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var $export = __webpack_require__(83);
	
	$export($export.S, 'Number', {isInteger: __webpack_require__(171)});

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var isObject = __webpack_require__(88)
	  , floor    = Math.floor;
	module.exports = function isInteger(it){
	  return !isObject(it) && isFinite(it) && floor(it) === it;
	};

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.4 Number.isNaN(number)
	var $export = __webpack_require__(83);
	
	$export($export.S, 'Number', {
	  isNaN: function isNaN(number){
	    return number != number;
	  }
	});

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.5 Number.isSafeInteger(number)
	var $export   = __webpack_require__(83)
	  , isInteger = __webpack_require__(171)
	  , abs       = Math.abs;
	
	$export($export.S, 'Number', {
	  isSafeInteger: function isSafeInteger(number){
	    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
	  }
	});

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.6 Number.MAX_SAFE_INTEGER
	var $export = __webpack_require__(83);
	
	$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.10 Number.MIN_SAFE_INTEGER
	var $export = __webpack_require__(83);
	
	$export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	var $export     = __webpack_require__(83)
	  , $parseFloat = __webpack_require__(161);
	// 20.1.2.12 Number.parseFloat(string)
	$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {parseFloat: $parseFloat});

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(83)
	  , $parseInt = __webpack_require__(157);
	// 20.1.2.13 Number.parseInt(string, radix)
	$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {parseInt: $parseInt});

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.3 Math.acosh(x)
	var $export = __webpack_require__(83)
	  , log1p   = __webpack_require__(179)
	  , sqrt    = Math.sqrt
	  , $acosh  = Math.acosh;
	
	$export($export.S + $export.F * !($acosh
	  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
	  && Math.floor($acosh(Number.MAX_VALUE)) == 710
	  // Tor Browser bug: Math.acosh(Infinity) -> NaN 
	  && $acosh(Infinity) == Infinity
	), 'Math', {
	  acosh: function acosh(x){
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156
	      ? Math.log(x) + Math.LN2
	      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
	  }
	});

/***/ },
/* 179 */
/***/ function(module, exports) {

	// 20.2.2.20 Math.log1p(x)
	module.exports = Math.log1p || function log1p(x){
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
	};

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.5 Math.asinh(x)
	var $export = __webpack_require__(83)
	  , $asinh  = Math.asinh;
	
	function asinh(x){
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
	}
	
	// Tor Browser bug: Math.asinh(0) -> -0 
	$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {asinh: asinh});

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.7 Math.atanh(x)
	var $export = __webpack_require__(83)
	  , $atanh  = Math.atanh;
	
	// Tor Browser bug: Math.atanh(-0) -> 0 
	$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
	  atanh: function atanh(x){
	    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
	  }
	});

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.9 Math.cbrt(x)
	var $export = __webpack_require__(83)
	  , sign    = __webpack_require__(183);
	
	$export($export.S, 'Math', {
	  cbrt: function cbrt(x){
	    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
	  }
	});

/***/ },
/* 183 */
/***/ function(module, exports) {

	// 20.2.2.28 Math.sign(x)
	module.exports = Math.sign || function sign(x){
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.11 Math.clz32(x)
	var $export = __webpack_require__(83);
	
	$export($export.S, 'Math', {
	  clz32: function clz32(x){
	    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
	  }
	});

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.12 Math.cosh(x)
	var $export = __webpack_require__(83)
	  , exp     = Math.exp;
	
	$export($export.S, 'Math', {
	  cosh: function cosh(x){
	    return (exp(x = +x) + exp(-x)) / 2;
	  }
	});

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.14 Math.expm1(x)
	var $export = __webpack_require__(83)
	  , $expm1  = __webpack_require__(187);
	
	$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {expm1: $expm1});

/***/ },
/* 187 */
/***/ function(module, exports) {

	// 20.2.2.14 Math.expm1(x)
	var $expm1 = Math.expm1;
	module.exports = (!$expm1
	  // Old FF bug
	  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
	  // Tor Browser bug
	  || $expm1(-2e-17) != -2e-17
	) ? function expm1(x){
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
	} : $expm1;

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.16 Math.fround(x)
	var $export   = __webpack_require__(83)
	  , sign      = __webpack_require__(183)
	  , pow       = Math.pow
	  , EPSILON   = pow(2, -52)
	  , EPSILON32 = pow(2, -23)
	  , MAX32     = pow(2, 127) * (2 - EPSILON32)
	  , MIN32     = pow(2, -126);
	
	var roundTiesToEven = function(n){
	  return n + 1 / EPSILON - 1 / EPSILON;
	};
	
	
	$export($export.S, 'Math', {
	  fround: function fround(x){
	    var $abs  = Math.abs(x)
	      , $sign = sign(x)
	      , a, result;
	    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	    a = (1 + EPSILON32 / EPSILON) * $abs;
	    result = a - (a - $abs);
	    if(result > MAX32 || result != result)return $sign * Infinity;
	    return $sign * result;
	  }
	});

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
	var $export = __webpack_require__(83)
	  , abs     = Math.abs;
	
	$export($export.S, 'Math', {
	  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
	    var sum  = 0
	      , i    = 0
	      , aLen = arguments.length
	      , larg = 0
	      , arg, div;
	    while(i < aLen){
	      arg = abs(arguments[i++]);
	      if(larg < arg){
	        div  = larg / arg;
	        sum  = sum * div * div + 1;
	        larg = arg;
	      } else if(arg > 0){
	        div  = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }
	    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
	  }
	});

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.18 Math.imul(x, y)
	var $export = __webpack_require__(83)
	  , $imul   = Math.imul;
	
	// some WebKit versions fails with big numbers, some has wrong arity
	$export($export.S + $export.F * __webpack_require__(82)(function(){
	  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
	}), 'Math', {
	  imul: function imul(x, y){
	    var UINT16 = 0xffff
	      , xn = +x
	      , yn = +y
	      , xl = UINT16 & xn
	      , yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.21 Math.log10(x)
	var $export = __webpack_require__(83);
	
	$export($export.S, 'Math', {
	  log10: function log10(x){
	    return Math.log(x) / Math.LN10;
	  }
	});

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.20 Math.log1p(x)
	var $export = __webpack_require__(83);
	
	$export($export.S, 'Math', {log1p: __webpack_require__(179)});

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.22 Math.log2(x)
	var $export = __webpack_require__(83);
	
	$export($export.S, 'Math', {
	  log2: function log2(x){
	    return Math.log(x) / Math.LN2;
	  }
	});

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.28 Math.sign(x)
	var $export = __webpack_require__(83);
	
	$export($export.S, 'Math', {sign: __webpack_require__(183)});

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.30 Math.sinh(x)
	var $export = __webpack_require__(83)
	  , expm1   = __webpack_require__(187)
	  , exp     = Math.exp;
	
	// V8 near Chromium 38 has a problem with very small numbers
	$export($export.S + $export.F * __webpack_require__(82)(function(){
	  return !Math.sinh(-2e-17) != -2e-17;
	}), 'Math', {
	  sinh: function sinh(x){
	    return Math.abs(x = +x) < 1
	      ? (expm1(x) - expm1(-x)) / 2
	      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
	  }
	});

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.33 Math.tanh(x)
	var $export = __webpack_require__(83)
	  , expm1   = __webpack_require__(187)
	  , exp     = Math.exp;
	
	$export($export.S, 'Math', {
	  tanh: function tanh(x){
	    var a = expm1(x = +x)
	      , b = expm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
	  }
	});

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.34 Math.trunc(x)
	var $export = __webpack_require__(83);
	
	$export($export.S, 'Math', {
	  trunc: function trunc(it){
	    return (it > 0 ? Math.floor : Math.ceil)(it);
	  }
	});

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	var $export        = __webpack_require__(83)
	  , toIndex        = __webpack_require__(114)
	  , fromCharCode   = String.fromCharCode
	  , $fromCodePoint = String.fromCodePoint;
	
	// length should be 1, old FF problem
	$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
	    var res  = []
	      , aLen = arguments.length
	      , i    = 0
	      , code;
	    while(aLen > i){
	      code = +arguments[i++];
	      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
	      res.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
	      );
	    } return res.join('');
	  }
	});

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(83)
	  , toIObject = __webpack_require__(107)
	  , toLength  = __webpack_require__(112);
	
	$export($export.S, 'String', {
	  // 21.1.2.4 String.raw(callSite, ...substitutions)
	  raw: function raw(callSite){
	    var tpl  = toIObject(callSite.raw)
	      , len  = toLength(tpl.length)
	      , aLen = arguments.length
	      , res  = []
	      , i    = 0;
	    while(len > i){
	      res.push(String(tpl[i++]));
	      if(i < aLen)res.push(String(arguments[i]));
	    } return res.join('');
	  }
	});

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 21.1.3.25 String.prototype.trim()
	__webpack_require__(158)('trim', function($trim){
	  return function trim(){
	    return $trim(this, 3);
	  };
	});

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(202)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(203)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(113)
	  , defined   = __webpack_require__(110);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(103)
	  , $export        = __webpack_require__(83)
	  , redefine       = __webpack_require__(93)
	  , hide           = __webpack_require__(85)
	  , has            = __webpack_require__(80)
	  , Iterators      = __webpack_require__(204)
	  , $iterCreate    = __webpack_require__(205)
	  , setToStringTag = __webpack_require__(99)
	  , getPrototypeOf = __webpack_require__(134)
	  , ITERATOR       = __webpack_require__(100)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 204 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(121)
	  , descriptor     = __webpack_require__(92)
	  , setToStringTag = __webpack_require__(99)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(85)(IteratorPrototype, __webpack_require__(100)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(83)
	  , $at     = __webpack_require__(202)(false);
	$export($export.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
	'use strict';
	var $export   = __webpack_require__(83)
	  , toLength  = __webpack_require__(112)
	  , context   = __webpack_require__(208)
	  , ENDS_WITH = 'endsWith'
	  , $endsWith = ''[ENDS_WITH];
	
	$export($export.P + $export.F * __webpack_require__(210)(ENDS_WITH), 'String', {
	  endsWith: function endsWith(searchString /*, endPosition = @length */){
	    var that = context(this, searchString, ENDS_WITH)
	      , endPosition = arguments.length > 1 ? arguments[1] : undefined
	      , len    = toLength(that.length)
	      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)
	      , search = String(searchString);
	    return $endsWith
	      ? $endsWith.call(that, search, end)
	      : that.slice(end - search.length, end) === search;
	  }
	});

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	// helper for String#{startsWith, endsWith, includes}
	var isRegExp = __webpack_require__(209)
	  , defined  = __webpack_require__(110);
	
	module.exports = function(that, searchString, NAME){
	  if(isRegExp(searchString))throw TypeError('String#' + NAME + " doesn't accept regex!");
	  return String(defined(that));
	};

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.8 IsRegExp(argument)
	var isObject = __webpack_require__(88)
	  , cof      = __webpack_require__(109)
	  , MATCH    = __webpack_require__(100)('match');
	module.exports = function(it){
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
	};

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var MATCH = __webpack_require__(100)('match');
	module.exports = function(KEY){
	  var re = /./;
	  try {
	    '/./'[KEY](re);
	  } catch(e){
	    try {
	      re[MATCH] = false;
	      return !'/./'[KEY](re);
	    } catch(f){ /* empty */ }
	  } return true;
	};

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.7 String.prototype.includes(searchString, position = 0)
	'use strict';
	var $export  = __webpack_require__(83)
	  , context  = __webpack_require__(208)
	  , INCLUDES = 'includes';
	
	$export($export.P + $export.F * __webpack_require__(210)(INCLUDES), 'String', {
	  includes: function includes(searchString /*, position = 0 */){
	    return !!~context(this, searchString, INCLUDES)
	      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(83);
	
	$export($export.P, 'String', {
	  // 21.1.3.13 String.prototype.repeat(count)
	  repeat: __webpack_require__(166)
	});

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
	'use strict';
	var $export     = __webpack_require__(83)
	  , toLength    = __webpack_require__(112)
	  , context     = __webpack_require__(208)
	  , STARTS_WITH = 'startsWith'
	  , $startsWith = ''[STARTS_WITH];
	
	$export($export.P + $export.F * __webpack_require__(210)(STARTS_WITH), 'String', {
	  startsWith: function startsWith(searchString /*, position = 0 */){
	    var that   = context(this, searchString, STARTS_WITH)
	      , index  = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length))
	      , search = String(searchString);
	    return $startsWith
	      ? $startsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.2 String.prototype.anchor(name)
	__webpack_require__(215)('anchor', function(createHTML){
	  return function anchor(name){
	    return createHTML(this, 'a', 'name', name);
	  }
	});

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(83)
	  , fails   = __webpack_require__(82)
	  , defined = __webpack_require__(110)
	  , quot    = /"/g;
	// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
	var createHTML = function(string, tag, attribute, value) {
	  var S  = String(defined(string))
	    , p1 = '<' + tag;
	  if(attribute !== '')p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
	  return p1 + '>' + S + '</' + tag + '>';
	};
	module.exports = function(NAME, exec){
	  var O = {};
	  O[NAME] = exec(createHTML);
	  $export($export.P + $export.F * fails(function(){
	    var test = ''[NAME]('"');
	    return test !== test.toLowerCase() || test.split('"').length > 3;
	  }), 'String', O);
	};

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.3 String.prototype.big()
	__webpack_require__(215)('big', function(createHTML){
	  return function big(){
	    return createHTML(this, 'big', '', '');
	  }
	});

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.4 String.prototype.blink()
	__webpack_require__(215)('blink', function(createHTML){
	  return function blink(){
	    return createHTML(this, 'blink', '', '');
	  }
	});

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.5 String.prototype.bold()
	__webpack_require__(215)('bold', function(createHTML){
	  return function bold(){
	    return createHTML(this, 'b', '', '');
	  }
	});

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.6 String.prototype.fixed()
	__webpack_require__(215)('fixed', function(createHTML){
	  return function fixed(){
	    return createHTML(this, 'tt', '', '');
	  }
	});

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.7 String.prototype.fontcolor(color)
	__webpack_require__(215)('fontcolor', function(createHTML){
	  return function fontcolor(color){
	    return createHTML(this, 'font', 'color', color);
	  }
	});

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.8 String.prototype.fontsize(size)
	__webpack_require__(215)('fontsize', function(createHTML){
	  return function fontsize(size){
	    return createHTML(this, 'font', 'size', size);
	  }
	});

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.9 String.prototype.italics()
	__webpack_require__(215)('italics', function(createHTML){
	  return function italics(){
	    return createHTML(this, 'i', '', '');
	  }
	});

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.10 String.prototype.link(url)
	__webpack_require__(215)('link', function(createHTML){
	  return function link(url){
	    return createHTML(this, 'a', 'href', url);
	  }
	});

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.11 String.prototype.small()
	__webpack_require__(215)('small', function(createHTML){
	  return function small(){
	    return createHTML(this, 'small', '', '');
	  }
	});

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.12 String.prototype.strike()
	__webpack_require__(215)('strike', function(createHTML){
	  return function strike(){
	    return createHTML(this, 'strike', '', '');
	  }
	});

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.13 String.prototype.sub()
	__webpack_require__(215)('sub', function(createHTML){
	  return function sub(){
	    return createHTML(this, 'sub', '', '');
	  }
	});

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.14 String.prototype.sup()
	__webpack_require__(215)('sup', function(createHTML){
	  return function sup(){
	    return createHTML(this, 'sup', '', '');
	  }
	});

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	// 20.3.3.1 / 15.9.4.4 Date.now()
	var $export = __webpack_require__(83);
	
	$export($export.S, 'Date', {now: function(){ return new Date().getTime(); }});

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export     = __webpack_require__(83)
	  , toObject    = __webpack_require__(133)
	  , toPrimitive = __webpack_require__(91);
	
	$export($export.P + $export.F * __webpack_require__(82)(function(){
	  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({toISOString: function(){ return 1; }}) !== 1;
	}), 'Date', {
	  toJSON: function toJSON(key){
	    var O  = toObject(this)
	      , pv = toPrimitive(O);
	    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
	  }
	});

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
	var $export = __webpack_require__(83)
	  , fails   = __webpack_require__(82)
	  , getTime = Date.prototype.getTime;
	
	var lz = function(num){
	  return num > 9 ? num : '0' + num;
	};
	
	// PhantomJS / old WebKit has a broken implementations
	$export($export.P + $export.F * (fails(function(){
	  return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';
	}) || !fails(function(){
	  new Date(NaN).toISOString();
	})), 'Date', {
	  toISOString: function toISOString(){
	    if(!isFinite(getTime.call(this)))throw RangeError('Invalid time value');
	    var d = this
	      , y = d.getUTCFullYear()
	      , m = d.getUTCMilliseconds()
	      , s = y < 0 ? '-' : y > 9999 ? '+' : '';
	    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
	      '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
	      'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
	      ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
	  }
	});

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	var DateProto    = Date.prototype
	  , INVALID_DATE = 'Invalid Date'
	  , TO_STRING    = 'toString'
	  , $toString    = DateProto[TO_STRING]
	  , getTime      = DateProto.getTime;
	if(new Date(NaN) + '' != INVALID_DATE){
	  __webpack_require__(93)(DateProto, TO_STRING, function toString(){
	    var value = getTime.call(this);
	    return value === value ? $toString.call(this) : INVALID_DATE;
	  });
	}

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	var TO_PRIMITIVE = __webpack_require__(100)('toPrimitive')
	  , proto        = Date.prototype;
	
	if(!(TO_PRIMITIVE in proto))__webpack_require__(85)(proto, TO_PRIMITIVE, __webpack_require__(233));

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var anObject    = __webpack_require__(87)
	  , toPrimitive = __webpack_require__(91)
	  , NUMBER      = 'number';
	
	module.exports = function(hint){
	  if(hint !== 'string' && hint !== NUMBER && hint !== 'default')throw TypeError('Incorrect hint');
	  return toPrimitive(anObject(this), hint != NUMBER);
	};

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
	var $export = __webpack_require__(83);
	
	$export($export.S, 'Array', {isArray: __webpack_require__(120)});

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx            = __webpack_require__(95)
	  , $export        = __webpack_require__(83)
	  , toObject       = __webpack_require__(133)
	  , call           = __webpack_require__(236)
	  , isArrayIter    = __webpack_require__(237)
	  , toLength       = __webpack_require__(112)
	  , createProperty = __webpack_require__(238)
	  , getIterFn      = __webpack_require__(239);
	
	$export($export.S + $export.F * !__webpack_require__(240)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(87);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(204)
	  , ITERATOR   = __webpack_require__(100)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(86)
	  , createDesc      = __webpack_require__(92);
	
	module.exports = function(object, index, value){
	  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(150)
	  , ITERATOR  = __webpack_require__(100)('iterator')
	  , Iterators = __webpack_require__(204);
	module.exports = __webpack_require__(84).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(100)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export        = __webpack_require__(83)
	  , createProperty = __webpack_require__(238);
	
	// WebKit Array.of isn't generic
	$export($export.S + $export.F * __webpack_require__(82)(function(){
	  function F(){}
	  return !(Array.of.call(F) instanceof F);
	}), 'Array', {
	  // 22.1.2.3 Array.of( ...items)
	  of: function of(/* ...args */){
	    var index  = 0
	      , aLen   = arguments.length
	      , result = new (typeof this == 'function' ? this : Array)(aLen);
	    while(aLen > index)createProperty(result, index, arguments[index++]);
	    result.length = aLen;
	    return result;
	  }
	});

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.13 Array.prototype.join(separator)
	var $export   = __webpack_require__(83)
	  , toIObject = __webpack_require__(107)
	  , arrayJoin = [].join;
	
	// fallback for not array-like strings
	$export($export.P + $export.F * (__webpack_require__(108) != Object || !__webpack_require__(243)(arrayJoin)), 'Array', {
	  join: function join(separator){
	    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
	  }
	});

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	var fails = __webpack_require__(82);
	
	module.exports = function(method, arg){
	  return !!method && fails(function(){
	    arg ? method.call(null, function(){}, 1) : method.call(null);
	  });
	};

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export    = __webpack_require__(83)
	  , html       = __webpack_require__(123)
	  , cof        = __webpack_require__(109)
	  , toIndex    = __webpack_require__(114)
	  , toLength   = __webpack_require__(112)
	  , arraySlice = [].slice;
	
	// fallback for not array-like ES3 strings and DOM objects
	$export($export.P + $export.F * __webpack_require__(82)(function(){
	  if(html)arraySlice.call(html);
	}), 'Array', {
	  slice: function slice(begin, end){
	    var len   = toLength(this.length)
	      , klass = cof(this);
	    end = end === undefined ? len : end;
	    if(klass == 'Array')return arraySlice.call(this, begin, end);
	    var start  = toIndex(begin, len)
	      , upTo   = toIndex(end, len)
	      , size   = toLength(upTo - start)
	      , cloned = Array(size)
	      , i      = 0;
	    for(; i < size; i++)cloned[i] = klass == 'String'
	      ? this.charAt(start + i)
	      : this[start + i];
	    return cloned;
	  }
	});

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export   = __webpack_require__(83)
	  , aFunction = __webpack_require__(96)
	  , toObject  = __webpack_require__(133)
	  , fails     = __webpack_require__(82)
	  , $sort     = [].sort
	  , test      = [1, 2, 3];
	
	$export($export.P + $export.F * (fails(function(){
	  // IE8-
	  test.sort(undefined);
	}) || !fails(function(){
	  // V8 bug
	  test.sort(null);
	  // Old WebKit
	}) || !__webpack_require__(243)($sort)), 'Array', {
	  // 22.1.3.25 Array.prototype.sort(comparefn)
	  sort: function sort(comparefn){
	    return comparefn === undefined
	      ? $sort.call(toObject(this))
	      : $sort.call(toObject(this), aFunction(comparefn));
	  }
	});

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export  = __webpack_require__(83)
	  , $forEach = __webpack_require__(247)(0)
	  , STRICT   = __webpack_require__(243)([].forEach, true);
	
	$export($export.P + $export.F * !STRICT, 'Array', {
	  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
	  forEach: function forEach(callbackfn /* , thisArg */){
	    return $forEach(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(95)
	  , IObject  = __webpack_require__(108)
	  , toObject = __webpack_require__(133)
	  , toLength = __webpack_require__(112)
	  , asc      = __webpack_require__(248);
	module.exports = function(TYPE, $create){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
	    , create        = $create || asc;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(249);
	
	module.exports = function(original, length){
	  return new (speciesConstructor(original))(length);
	};

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(88)
	  , isArray  = __webpack_require__(120)
	  , SPECIES  = __webpack_require__(100)('species');
	
	module.exports = function(original){
	  var C;
	  if(isArray(original)){
	    C = original.constructor;
	    // cross-realm fallback
	    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
	    if(isObject(C)){
	      C = C[SPECIES];
	      if(C === null)C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(83)
	  , $map    = __webpack_require__(247)(1);
	
	$export($export.P + $export.F * !__webpack_require__(243)([].map, true), 'Array', {
	  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
	  map: function map(callbackfn /* , thisArg */){
	    return $map(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(83)
	  , $filter = __webpack_require__(247)(2);
	
	$export($export.P + $export.F * !__webpack_require__(243)([].filter, true), 'Array', {
	  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
	  filter: function filter(callbackfn /* , thisArg */){
	    return $filter(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(83)
	  , $some   = __webpack_require__(247)(3);
	
	$export($export.P + $export.F * !__webpack_require__(243)([].some, true), 'Array', {
	  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
	  some: function some(callbackfn /* , thisArg */){
	    return $some(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(83)
	  , $every  = __webpack_require__(247)(4);
	
	$export($export.P + $export.F * !__webpack_require__(243)([].every, true), 'Array', {
	  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
	  every: function every(callbackfn /* , thisArg */){
	    return $every(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(83)
	  , $reduce = __webpack_require__(255);
	
	$export($export.P + $export.F * !__webpack_require__(243)([].reduce, true), 'Array', {
	  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
	  reduce: function reduce(callbackfn /* , initialValue */){
	    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
	  }
	});

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	var aFunction = __webpack_require__(96)
	  , toObject  = __webpack_require__(133)
	  , IObject   = __webpack_require__(108)
	  , toLength  = __webpack_require__(112);
	
	module.exports = function(that, callbackfn, aLen, memo, isRight){
	  aFunction(callbackfn);
	  var O      = toObject(that)
	    , self   = IObject(O)
	    , length = toLength(O.length)
	    , index  = isRight ? length - 1 : 0
	    , i      = isRight ? -1 : 1;
	  if(aLen < 2)for(;;){
	    if(index in self){
	      memo = self[index];
	      index += i;
	      break;
	    }
	    index += i;
	    if(isRight ? index < 0 : length <= index){
	      throw TypeError('Reduce of empty array with no initial value');
	    }
	  }
	  for(;isRight ? index >= 0 : length > index; index += i)if(index in self){
	    memo = callbackfn(memo, self[index], index, O);
	  }
	  return memo;
	};

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(83)
	  , $reduce = __webpack_require__(255);
	
	$export($export.P + $export.F * !__webpack_require__(243)([].reduceRight, true), 'Array', {
	  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
	  reduceRight: function reduceRight(callbackfn /* , initialValue */){
	    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
	  }
	});

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export       = __webpack_require__(83)
	  , $indexOf      = __webpack_require__(111)(false)
	  , $native       = [].indexOf
	  , NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
	
	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(243)($native)), 'Array', {
	  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
	  indexOf: function indexOf(searchElement /*, fromIndex = 0 */){
	    return NEGATIVE_ZERO
	      // convert -0 to +0
	      ? $native.apply(this, arguments) || 0
	      : $indexOf(this, searchElement, arguments[1]);
	  }
	});

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export       = __webpack_require__(83)
	  , toIObject     = __webpack_require__(107)
	  , toInteger     = __webpack_require__(113)
	  , toLength      = __webpack_require__(112)
	  , $native       = [].lastIndexOf
	  , NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;
	
	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(243)($native)), 'Array', {
	  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
	  lastIndexOf: function lastIndexOf(searchElement /*, fromIndex = @[*-1] */){
	    // convert -0 to +0
	    if(NEGATIVE_ZERO)return $native.apply(this, arguments) || 0;
	    var O      = toIObject(this)
	      , length = toLength(O.length)
	      , index  = length - 1;
	    if(arguments.length > 1)index = Math.min(index, toInteger(arguments[1]));
	    if(index < 0)index = length + index;
	    for(;index >= 0; index--)if(index in O)if(O[index] === searchElement)return index || 0;
	    return -1;
	  }
	});

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	var $export = __webpack_require__(83);
	
	$export($export.P, 'Array', {copyWithin: __webpack_require__(260)});
	
	__webpack_require__(261)('copyWithin');

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	'use strict';
	var toObject = __webpack_require__(133)
	  , toIndex  = __webpack_require__(114)
	  , toLength = __webpack_require__(112);
	
	module.exports = [].copyWithin || function copyWithin(target/*= 0*/, start/*= 0, end = @length*/){
	  var O     = toObject(this)
	    , len   = toLength(O.length)
	    , to    = toIndex(target, len)
	    , from  = toIndex(start, len)
	    , end   = arguments.length > 2 ? arguments[2] : undefined
	    , count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to)
	    , inc   = 1;
	  if(from < to && to < from + count){
	    inc  = -1;
	    from += count - 1;
	    to   += count - 1;
	  }
	  while(count-- > 0){
	    if(from in O)O[to] = O[from];
	    else delete O[to];
	    to   += inc;
	    from += inc;
	  } return O;
	};

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = __webpack_require__(100)('unscopables')
	  , ArrayProto  = Array.prototype;
	if(ArrayProto[UNSCOPABLES] == undefined)__webpack_require__(85)(ArrayProto, UNSCOPABLES, {});
	module.exports = function(key){
	  ArrayProto[UNSCOPABLES][key] = true;
	};

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	var $export = __webpack_require__(83);
	
	$export($export.P, 'Array', {fill: __webpack_require__(263)});
	
	__webpack_require__(261)('fill');

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	'use strict';
	var toObject = __webpack_require__(133)
	  , toIndex  = __webpack_require__(114)
	  , toLength = __webpack_require__(112);
	module.exports = function fill(value /*, start = 0, end = @length */){
	  var O      = toObject(this)
	    , length = toLength(O.length)
	    , aLen   = arguments.length
	    , index  = toIndex(aLen > 1 ? arguments[1] : undefined, length)
	    , end    = aLen > 2 ? arguments[2] : undefined
	    , endPos = end === undefined ? length : toIndex(end, length);
	  while(endPos > index)O[index++] = value;
	  return O;
	};

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
	var $export = __webpack_require__(83)
	  , $find   = __webpack_require__(247)(5)
	  , KEY     = 'find'
	  , forced  = true;
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  find: function find(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(261)(KEY);

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
	var $export = __webpack_require__(83)
	  , $find   = __webpack_require__(247)(6)
	  , KEY     = 'findIndex'
	  , forced  = true;
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  findIndex: function findIndex(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(261)(KEY);

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(267)('Array');

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(79)
	  , dP          = __webpack_require__(86)
	  , DESCRIPTORS = __webpack_require__(81)
	  , SPECIES     = __webpack_require__(100)('species');
	
	module.exports = function(KEY){
	  var C = global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(261)
	  , step             = __webpack_require__(269)
	  , Iterators        = __webpack_require__(204)
	  , toIObject        = __webpack_require__(107);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(203)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 269 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	var global            = __webpack_require__(79)
	  , inheritIfRequired = __webpack_require__(163)
	  , dP                = __webpack_require__(86).f
	  , gOPN              = __webpack_require__(125).f
	  , isRegExp          = __webpack_require__(209)
	  , $flags            = __webpack_require__(271)
	  , $RegExp           = global.RegExp
	  , Base              = $RegExp
	  , proto             = $RegExp.prototype
	  , re1               = /a/g
	  , re2               = /a/g
	  // "new" creates a new object, old webkit buggy here
	  , CORRECT_NEW       = new $RegExp(re1) !== re1;
	
	if(__webpack_require__(81) && (!CORRECT_NEW || __webpack_require__(82)(function(){
	  re2[__webpack_require__(100)('match')] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
	}))){
	  $RegExp = function RegExp(p, f){
	    var tiRE = this instanceof $RegExp
	      , piRE = isRegExp(p)
	      , fiU  = f === undefined;
	    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
	      : inheritIfRequired(CORRECT_NEW
	        ? new Base(piRE && !fiU ? p.source : p, f)
	        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
	      , tiRE ? this : proto, $RegExp);
	  };
	  var proxy = function(key){
	    key in $RegExp || dP($RegExp, key, {
	      configurable: true,
	      get: function(){ return Base[key]; },
	      set: function(it){ Base[key] = it; }
	    });
	  };
	  for(var keys = gOPN(Base), i = 0; keys.length > i; )proxy(keys[i++]);
	  proto.constructor = $RegExp;
	  $RegExp.prototype = proto;
	  __webpack_require__(93)(global, 'RegExp', $RegExp);
	}
	
	__webpack_require__(267)('RegExp');

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 21.2.5.3 get RegExp.prototype.flags
	var anObject = __webpack_require__(87);
	module.exports = function(){
	  var that   = anObject(this)
	    , result = '';
	  if(that.global)     result += 'g';
	  if(that.ignoreCase) result += 'i';
	  if(that.multiline)  result += 'm';
	  if(that.unicode)    result += 'u';
	  if(that.sticky)     result += 'y';
	  return result;
	};

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	__webpack_require__(273);
	var anObject    = __webpack_require__(87)
	  , $flags      = __webpack_require__(271)
	  , DESCRIPTORS = __webpack_require__(81)
	  , TO_STRING   = 'toString'
	  , $toString   = /./[TO_STRING];
	
	var define = function(fn){
	  __webpack_require__(93)(RegExp.prototype, TO_STRING, fn, true);
	};
	
	// 21.2.5.14 RegExp.prototype.toString()
	if(__webpack_require__(82)(function(){ return $toString.call({source: 'a', flags: 'b'}) != '/a/b'; })){
	  define(function toString(){
	    var R = anObject(this);
	    return '/'.concat(R.source, '/',
	      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
	  });
	// FF44- RegExp#toString has a wrong name
	} else if($toString.name != TO_STRING){
	  define(function toString(){
	    return $toString.call(this);
	  });
	}

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	// 21.2.5.3 get RegExp.prototype.flags()
	if(__webpack_require__(81) && /./g.flags != 'g')__webpack_require__(86).f(RegExp.prototype, 'flags', {
	  configurable: true,
	  get: __webpack_require__(271)
	});

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	// @@match logic
	__webpack_require__(275)('match', 1, function(defined, MATCH, $match){
	  // 21.1.3.11 String.prototype.match(regexp)
	  return [function match(regexp){
	    'use strict';
	    var O  = defined(this)
	      , fn = regexp == undefined ? undefined : regexp[MATCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	  }, $match];
	});

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var hide     = __webpack_require__(85)
	  , redefine = __webpack_require__(93)
	  , fails    = __webpack_require__(82)
	  , defined  = __webpack_require__(110)
	  , wks      = __webpack_require__(100);
	
	module.exports = function(KEY, length, exec){
	  var SYMBOL   = wks(KEY)
	    , fns      = exec(defined, SYMBOL, ''[KEY])
	    , strfn    = fns[0]
	    , rxfn     = fns[1];
	  if(fails(function(){
	    var O = {};
	    O[SYMBOL] = function(){ return 7; };
	    return ''[KEY](O) != 7;
	  })){
	    redefine(String.prototype, KEY, strfn);
	    hide(RegExp.prototype, SYMBOL, length == 2
	      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	      ? function(string, arg){ return rxfn.call(string, this, arg); }
	      // 21.2.5.6 RegExp.prototype[@@match](string)
	      // 21.2.5.9 RegExp.prototype[@@search](string)
	      : function(string){ return rxfn.call(string, this); }
	    );
	  }
	};

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	// @@replace logic
	__webpack_require__(275)('replace', 2, function(defined, REPLACE, $replace){
	  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
	  return [function replace(searchValue, replaceValue){
	    'use strict';
	    var O  = defined(this)
	      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	    return fn !== undefined
	      ? fn.call(searchValue, O, replaceValue)
	      : $replace.call(String(O), searchValue, replaceValue);
	  }, $replace];
	});

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	// @@search logic
	__webpack_require__(275)('search', 1, function(defined, SEARCH, $search){
	  // 21.1.3.15 String.prototype.search(regexp)
	  return [function search(regexp){
	    'use strict';
	    var O  = defined(this)
	      , fn = regexp == undefined ? undefined : regexp[SEARCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	  }, $search];
	});

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	// @@split logic
	__webpack_require__(275)('split', 2, function(defined, SPLIT, $split){
	  'use strict';
	  var isRegExp   = __webpack_require__(209)
	    , _split     = $split
	    , $push      = [].push
	    , $SPLIT     = 'split'
	    , LENGTH     = 'length'
	    , LAST_INDEX = 'lastIndex';
	  if(
	    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
	    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
	    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
	    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
	    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
	    ''[$SPLIT](/.?/)[LENGTH]
	  ){
	    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
	    // based on es5-shim implementation, need to rework it
	    $split = function(separator, limit){
	      var string = String(this);
	      if(separator === undefined && limit === 0)return [];
	      // If `separator` is not a regex, use native split
	      if(!isRegExp(separator))return _split.call(string, separator, limit);
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') +
	                  (separator.multiline ? 'm' : '') +
	                  (separator.unicode ? 'u' : '') +
	                  (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var separator2, match, lastIndex, lastLength, i;
	      // Doesn't need flags gy, but they don't hurt
	      if(!NPCG)separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
	      while(match = separatorCopy.exec(string)){
	        // `separatorCopy.lastIndex` is not reliable cross-browser
	        lastIndex = match.index + match[0][LENGTH];
	        if(lastIndex > lastLastIndex){
	          output.push(string.slice(lastLastIndex, match.index));
	          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
	          if(!NPCG && match[LENGTH] > 1)match[0].replace(separator2, function(){
	            for(i = 1; i < arguments[LENGTH] - 2; i++)if(arguments[i] === undefined)match[i] = undefined;
	          });
	          if(match[LENGTH] > 1 && match.index < string[LENGTH])$push.apply(output, match.slice(1));
	          lastLength = match[0][LENGTH];
	          lastLastIndex = lastIndex;
	          if(output[LENGTH] >= splitLimit)break;
	        }
	        if(separatorCopy[LAST_INDEX] === match.index)separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
	      }
	      if(lastLastIndex === string[LENGTH]){
	        if(lastLength || !separatorCopy.test(''))output.push('');
	      } else output.push(string.slice(lastLastIndex));
	      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
	    };
	  // Chakra, V8
	  } else if('0'[$SPLIT](undefined, 0)[LENGTH]){
	    $split = function(separator, limit){
	      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
	    };
	  }
	  // 21.1.3.17 String.prototype.split(separator, limit)
	  return [function split(separator, limit){
	    var O  = defined(this)
	      , fn = separator == undefined ? undefined : separator[SPLIT];
	    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
	  }, $split];
	});

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(103)
	  , global             = __webpack_require__(79)
	  , ctx                = __webpack_require__(95)
	  , classof            = __webpack_require__(150)
	  , $export            = __webpack_require__(83)
	  , isObject           = __webpack_require__(88)
	  , aFunction          = __webpack_require__(96)
	  , anInstance         = __webpack_require__(280)
	  , forOf              = __webpack_require__(281)
	  , speciesConstructor = __webpack_require__(282)
	  , task               = __webpack_require__(283).set
	  , microtask          = __webpack_require__(284)()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;
	
	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(100)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();
	
	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};
	
	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(285)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(99)($Promise, PROMISE);
	__webpack_require__(267)(PROMISE);
	Wrapper = __webpack_require__(84)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(240)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 280 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(95)
	  , call        = __webpack_require__(236)
	  , isArrayIter = __webpack_require__(237)
	  , anObject    = __webpack_require__(87)
	  , toLength    = __webpack_require__(112)
	  , getIterFn   = __webpack_require__(239)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(87)
	  , aFunction = __webpack_require__(96)
	  , SPECIES   = __webpack_require__(100)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(95)
	  , invoke             = __webpack_require__(153)
	  , html               = __webpack_require__(123)
	  , cel                = __webpack_require__(90)
	  , global             = __webpack_require__(79)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(109)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(79)
	  , macrotask = __webpack_require__(283).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(109)(process) == 'process';
	
	module.exports = function(){
	  var head, last, notify;
	
	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };
	
	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }
	
	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	var redefine = __webpack_require__(93);
	module.exports = function(target, src, safe){
	  for(var key in src)redefine(target, key, src[key], safe);
	  return target;
	};

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(287);
	
	// 23.1 Map Objects
	module.exports = __webpack_require__(288)('Map', function(get){
	  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key){
	    var entry = strong.getEntry(this, key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value){
	    return strong.def(this, key === 0 ? 0 : key, value);
	  }
	}, strong, true);

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var dP          = __webpack_require__(86).f
	  , create      = __webpack_require__(121)
	  , redefineAll = __webpack_require__(285)
	  , ctx         = __webpack_require__(95)
	  , anInstance  = __webpack_require__(280)
	  , defined     = __webpack_require__(110)
	  , forOf       = __webpack_require__(281)
	  , $iterDefine = __webpack_require__(203)
	  , step        = __webpack_require__(269)
	  , setSpecies  = __webpack_require__(267)
	  , DESCRIPTORS = __webpack_require__(81)
	  , fastKey     = __webpack_require__(97).fastKey
	  , SIZE        = DESCRIPTORS ? '_s' : 'size';
	
	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        anInstance(this, C, 'forEach');
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)dP(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global            = __webpack_require__(79)
	  , $export           = __webpack_require__(83)
	  , redefine          = __webpack_require__(93)
	  , redefineAll       = __webpack_require__(285)
	  , meta              = __webpack_require__(97)
	  , forOf             = __webpack_require__(281)
	  , anInstance        = __webpack_require__(280)
	  , isObject          = __webpack_require__(88)
	  , fails             = __webpack_require__(82)
	  , $iterDetect       = __webpack_require__(240)
	  , setToStringTag    = __webpack_require__(99)
	  , inheritIfRequired = __webpack_require__(163);
	
	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  var fixMethod = function(KEY){
	    var fn = proto[KEY];
	    redefine(proto, KEY,
	      KEY == 'delete' ? function(a){
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'has' ? function has(a){
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'get' ? function get(a){
	        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
	        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
	    );
	  };
	  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    var instance             = new C
	      // early implementations not supports chaining
	      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance
	      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
	      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })
	      // most early implementations doesn't supports iterables, most modern - not close it correctly
	      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new
	      // for early implementations -0 and +0 not the same
	      , BUGGY_ZERO = !IS_WEAK && fails(function(){
	        // V8 ~ Chromium 42- fails only with 5+ elements
	        var $instance = new C()
	          , index     = 5;
	        while(index--)$instance[ADDER](index, index);
	        return !$instance.has(-0);
	      });
	    if(!ACCEPT_ITERABLES){ 
	      C = wrapper(function(target, iterable){
	        anInstance(target, C, NAME);
	        var that = inheritIfRequired(new Base, target, C);
	        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	        return that;
	      });
	      C.prototype = proto;
	      proto.constructor = C;
	    }
	    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);
	    // weak collections should not contains .clear method
	    if(IS_WEAK && proto.clear)delete proto.clear;
	  }
	
	  setToStringTag(C, NAME);
	
	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F * (C != Base), O);
	
	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(287);
	
	// 23.2 Set Objects
	module.exports = __webpack_require__(288)('Set', function(get){
	  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var each         = __webpack_require__(247)(0)
	  , redefine     = __webpack_require__(93)
	  , meta         = __webpack_require__(97)
	  , assign       = __webpack_require__(144)
	  , weak         = __webpack_require__(291)
	  , isObject     = __webpack_require__(88)
	  , getWeak      = meta.getWeak
	  , isExtensible = Object.isExtensible
	  , uncaughtFrozenStore = weak.ufstore
	  , tmp          = {}
	  , InternalMap;
	
	var wrapper = function(get){
	  return function WeakMap(){
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	};
	
	var methods = {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key){
	    if(isObject(key)){
	      var data = getWeak(key);
	      if(data === true)return uncaughtFrozenStore(this).get(key);
	      return data ? data[this._i] : undefined;
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value){
	    return weak.def(this, key, value);
	  }
	};
	
	// 23.3 WeakMap Objects
	var $WeakMap = module.exports = __webpack_require__(288)('WeakMap', wrapper, methods, weak, true, true);
	
	// IE11 WeakMap frozen keys fix
	if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
	  InternalMap = weak.getConstructor(wrapper);
	  assign(InternalMap.prototype, methods);
	  meta.NEED = true;
	  each(['delete', 'has', 'get', 'set'], function(key){
	    var proto  = $WeakMap.prototype
	      , method = proto[key];
	    redefine(proto, key, function(a, b){
	      // store frozen objects on internal weakmap shim
	      if(isObject(a) && !isExtensible(a)){
	        if(!this._f)this._f = new InternalMap;
	        var result = this._f[key](a, b);
	        return key == 'set' ? this : result;
	      // store all the rest on native weakmap
	      } return method.call(this, a, b);
	    });
	  });
	}

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var redefineAll       = __webpack_require__(285)
	  , getWeak           = __webpack_require__(97).getWeak
	  , anObject          = __webpack_require__(87)
	  , isObject          = __webpack_require__(88)
	  , anInstance        = __webpack_require__(280)
	  , forOf             = __webpack_require__(281)
	  , createArrayMethod = __webpack_require__(247)
	  , $has              = __webpack_require__(80)
	  , arrayFind         = createArrayMethod(5)
	  , arrayFindIndex    = createArrayMethod(6)
	  , id                = 0;
	
	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function(that){
	  return that._l || (that._l = new UncaughtFrozenStore);
	};
	var UncaughtFrozenStore = function(){
	  this.a = [];
	};
	var findUncaughtFrozen = function(store, key){
	  return arrayFind(store.a, function(it){
	    return it[0] === key;
	  });
	};
	UncaughtFrozenStore.prototype = {
	  get: function(key){
	    var entry = findUncaughtFrozen(this, key);
	    if(entry)return entry[1];
	  },
	  has: function(key){
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function(key, value){
	    var entry = findUncaughtFrozen(this, key);
	    if(entry)entry[1] = value;
	    else this.a.push([key, value]);
	  },
	  'delete': function(key){
	    var index = arrayFindIndex(this.a, function(it){
	      return it[0] === key;
	    });
	    if(~index)this.a.splice(index, 1);
	    return !!~index;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = id++;      // collection id
	      that._l = undefined; // leak store for uncaught frozen objects
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function(key){
	        if(!isObject(key))return false;
	        var data = getWeak(key);
	        if(data === true)return uncaughtFrozenStore(this)['delete'](key);
	        return data && $has(data, this._i) && delete data[this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has(key){
	        if(!isObject(key))return false;
	        var data = getWeak(key);
	        if(data === true)return uncaughtFrozenStore(this).has(key);
	        return data && $has(data, this._i);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var data = getWeak(anObject(key), true);
	    if(data === true)uncaughtFrozenStore(that).set(key, value);
	    else data[that._i] = value;
	    return that;
	  },
	  ufstore: uncaughtFrozenStore
	};

/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var weak = __webpack_require__(291);
	
	// 23.4 WeakSet Objects
	__webpack_require__(288)('WeakSet', function(get){
	  return function WeakSet(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.4.3.1 WeakSet.prototype.add(value)
	  add: function add(value){
	    return weak.def(this, value, true);
	  }
	}, weak, false, true);

/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(83)
	  , $typed       = __webpack_require__(294)
	  , buffer       = __webpack_require__(295)
	  , anObject     = __webpack_require__(87)
	  , toIndex      = __webpack_require__(114)
	  , toLength     = __webpack_require__(112)
	  , isObject     = __webpack_require__(88)
	  , ArrayBuffer  = __webpack_require__(79).ArrayBuffer
	  , speciesConstructor = __webpack_require__(282)
	  , $ArrayBuffer = buffer.ArrayBuffer
	  , $DataView    = buffer.DataView
	  , $isView      = $typed.ABV && ArrayBuffer.isView
	  , $slice       = $ArrayBuffer.prototype.slice
	  , VIEW         = $typed.VIEW
	  , ARRAY_BUFFER = 'ArrayBuffer';
	
	$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {ArrayBuffer: $ArrayBuffer});
	
	$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
	  // 24.1.3.1 ArrayBuffer.isView(arg)
	  isView: function isView(it){
	    return $isView && $isView(it) || isObject(it) && VIEW in it;
	  }
	});
	
	$export($export.P + $export.U + $export.F * __webpack_require__(82)(function(){
	  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
	}), ARRAY_BUFFER, {
	  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
	  slice: function slice(start, end){
	    if($slice !== undefined && end === undefined)return $slice.call(anObject(this), start); // FF fix
	    var len    = anObject(this).byteLength
	      , first  = toIndex(start, len)
	      , final  = toIndex(end === undefined ? len : end, len)
	      , result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first))
	      , viewS  = new $DataView(this)
	      , viewT  = new $DataView(result)
	      , index  = 0;
	    while(first < final){
	      viewT.setUint8(index++, viewS.getUint8(first++));
	    } return result;
	  }
	});
	
	__webpack_require__(267)(ARRAY_BUFFER);

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(79)
	  , hide   = __webpack_require__(85)
	  , uid    = __webpack_require__(94)
	  , TYPED  = uid('typed_array')
	  , VIEW   = uid('view')
	  , ABV    = !!(global.ArrayBuffer && global.DataView)
	  , CONSTR = ABV
	  , i = 0, l = 9, Typed;
	
	var TypedArrayConstructors = (
	  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
	).split(',');
	
	while(i < l){
	  if(Typed = global[TypedArrayConstructors[i++]]){
	    hide(Typed.prototype, TYPED, true);
	    hide(Typed.prototype, VIEW, true);
	  } else CONSTR = false;
	}
	
	module.exports = {
	  ABV:    ABV,
	  CONSTR: CONSTR,
	  TYPED:  TYPED,
	  VIEW:   VIEW
	};

/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global         = __webpack_require__(79)
	  , DESCRIPTORS    = __webpack_require__(81)
	  , LIBRARY        = __webpack_require__(103)
	  , $typed         = __webpack_require__(294)
	  , hide           = __webpack_require__(85)
	  , redefineAll    = __webpack_require__(285)
	  , fails          = __webpack_require__(82)
	  , anInstance     = __webpack_require__(280)
	  , toInteger      = __webpack_require__(113)
	  , toLength       = __webpack_require__(112)
	  , gOPN           = __webpack_require__(125).f
	  , dP             = __webpack_require__(86).f
	  , arrayFill      = __webpack_require__(263)
	  , setToStringTag = __webpack_require__(99)
	  , ARRAY_BUFFER   = 'ArrayBuffer'
	  , DATA_VIEW      = 'DataView'
	  , PROTOTYPE      = 'prototype'
	  , WRONG_LENGTH   = 'Wrong length!'
	  , WRONG_INDEX    = 'Wrong index!'
	  , $ArrayBuffer   = global[ARRAY_BUFFER]
	  , $DataView      = global[DATA_VIEW]
	  , Math           = global.Math
	  , RangeError     = global.RangeError
	  , Infinity       = global.Infinity
	  , BaseBuffer     = $ArrayBuffer
	  , abs            = Math.abs
	  , pow            = Math.pow
	  , floor          = Math.floor
	  , log            = Math.log
	  , LN2            = Math.LN2
	  , BUFFER         = 'buffer'
	  , BYTE_LENGTH    = 'byteLength'
	  , BYTE_OFFSET    = 'byteOffset'
	  , $BUFFER        = DESCRIPTORS ? '_b' : BUFFER
	  , $LENGTH        = DESCRIPTORS ? '_l' : BYTE_LENGTH
	  , $OFFSET        = DESCRIPTORS ? '_o' : BYTE_OFFSET;
	
	// IEEE754 conversions based on https://github.com/feross/ieee754
	var packIEEE754 = function(value, mLen, nBytes){
	  var buffer = Array(nBytes)
	    , eLen   = nBytes * 8 - mLen - 1
	    , eMax   = (1 << eLen) - 1
	    , eBias  = eMax >> 1
	    , rt     = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0
	    , i      = 0
	    , s      = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0
	    , e, m, c;
	  value = abs(value)
	  if(value != value || value === Infinity){
	    m = value != value ? 1 : 0;
	    e = eMax;
	  } else {
	    e = floor(log(value) / LN2);
	    if(value * (c = pow(2, -e)) < 1){
	      e--;
	      c *= 2;
	    }
	    if(e + eBias >= 1){
	      value += rt / c;
	    } else {
	      value += rt * pow(2, 1 - eBias);
	    }
	    if(value * c >= 2){
	      e++;
	      c /= 2;
	    }
	    if(e + eBias >= eMax){
	      m = 0;
	      e = eMax;
	    } else if(e + eBias >= 1){
	      m = (value * c - 1) * pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * pow(2, eBias - 1) * pow(2, mLen);
	      e = 0;
	    }
	  }
	  for(; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
	  e = e << mLen | m;
	  eLen += mLen;
	  for(; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
	  buffer[--i] |= s * 128;
	  return buffer;
	};
	var unpackIEEE754 = function(buffer, mLen, nBytes){
	  var eLen  = nBytes * 8 - mLen - 1
	    , eMax  = (1 << eLen) - 1
	    , eBias = eMax >> 1
	    , nBits = eLen - 7
	    , i     = nBytes - 1
	    , s     = buffer[i--]
	    , e     = s & 127
	    , m;
	  s >>= 7;
	  for(; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
	  m = e & (1 << -nBits) - 1;
	  e >>= -nBits;
	  nBits += mLen;
	  for(; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
	  if(e === 0){
	    e = 1 - eBias;
	  } else if(e === eMax){
	    return m ? NaN : s ? -Infinity : Infinity;
	  } else {
	    m = m + pow(2, mLen);
	    e = e - eBias;
	  } return (s ? -1 : 1) * m * pow(2, e - mLen);
	};
	
	var unpackI32 = function(bytes){
	  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
	};
	var packI8 = function(it){
	  return [it & 0xff];
	};
	var packI16 = function(it){
	  return [it & 0xff, it >> 8 & 0xff];
	};
	var packI32 = function(it){
	  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
	};
	var packF64 = function(it){
	  return packIEEE754(it, 52, 8);
	};
	var packF32 = function(it){
	  return packIEEE754(it, 23, 4);
	};
	
	var addGetter = function(C, key, internal){
	  dP(C[PROTOTYPE], key, {get: function(){ return this[internal]; }});
	};
	
	var get = function(view, bytes, index, isLittleEndian){
	  var numIndex = +index
	    , intIndex = toInteger(numIndex);
	  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b
	    , start = intIndex + view[$OFFSET]
	    , pack  = store.slice(start, start + bytes);
	  return isLittleEndian ? pack : pack.reverse();
	};
	var set = function(view, bytes, index, conversion, value, isLittleEndian){
	  var numIndex = +index
	    , intIndex = toInteger(numIndex);
	  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b
	    , start = intIndex + view[$OFFSET]
	    , pack  = conversion(+value);
	  for(var i = 0; i < bytes; i++)store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
	};
	
	var validateArrayBufferArguments = function(that, length){
	  anInstance(that, $ArrayBuffer, ARRAY_BUFFER);
	  var numberLength = +length
	    , byteLength   = toLength(numberLength);
	  if(numberLength != byteLength)throw RangeError(WRONG_LENGTH);
	  return byteLength;
	};
	
	if(!$typed.ABV){
	  $ArrayBuffer = function ArrayBuffer(length){
	    var byteLength = validateArrayBufferArguments(this, length);
	    this._b       = arrayFill.call(Array(byteLength), 0);
	    this[$LENGTH] = byteLength;
	  };
	
	  $DataView = function DataView(buffer, byteOffset, byteLength){
	    anInstance(this, $DataView, DATA_VIEW);
	    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
	    var bufferLength = buffer[$LENGTH]
	      , offset       = toInteger(byteOffset);
	    if(offset < 0 || offset > bufferLength)throw RangeError('Wrong offset!');
	    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	    if(offset + byteLength > bufferLength)throw RangeError(WRONG_LENGTH);
	    this[$BUFFER] = buffer;
	    this[$OFFSET] = offset;
	    this[$LENGTH] = byteLength;
	  };
	
	  if(DESCRIPTORS){
	    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
	    addGetter($DataView, BUFFER, '_b');
	    addGetter($DataView, BYTE_LENGTH, '_l');
	    addGetter($DataView, BYTE_OFFSET, '_o');
	  }
	
	  redefineAll($DataView[PROTOTYPE], {
	    getInt8: function getInt8(byteOffset){
	      return get(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset){
	      return get(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset /*, littleEndian */){
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset /*, littleEndian */){
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset /*, littleEndian */){
	      return unpackI32(get(this, 4, byteOffset, arguments[1]));
	    },
	    getUint32: function getUint32(byteOffset /*, littleEndian */){
	      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset /*, littleEndian */){
	      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
	    },
	    getFloat64: function getFloat64(byteOffset /*, littleEndian */){
	      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
	    },
	    setInt8: function setInt8(byteOffset, value){
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setUint8: function setUint8(byteOffset, value){
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setInt16: function setInt16(byteOffset, value /*, littleEndian */){
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setUint16: function setUint16(byteOffset, value /*, littleEndian */){
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setInt32: function setInt32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setUint32: function setUint32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setFloat32: function setFloat32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packF32, value, arguments[2]);
	    },
	    setFloat64: function setFloat64(byteOffset, value /*, littleEndian */){
	      set(this, 8, byteOffset, packF64, value, arguments[2]);
	    }
	  });
	} else {
	  if(!fails(function(){
	    new $ArrayBuffer;     // eslint-disable-line no-new
	  }) || !fails(function(){
	    new $ArrayBuffer(.5); // eslint-disable-line no-new
	  })){
	    $ArrayBuffer = function ArrayBuffer(length){
	      return new BaseBuffer(validateArrayBufferArguments(this, length));
	    };
	    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
	    for(var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j; ){
	      if(!((key = keys[j++]) in $ArrayBuffer))hide($ArrayBuffer, key, BaseBuffer[key]);
	    };
	    if(!LIBRARY)ArrayBufferProto.constructor = $ArrayBuffer;
	  }
	  // iOS Safari 7.x bug
	  var view = new $DataView(new $ArrayBuffer(2))
	    , $setInt8 = $DataView[PROTOTYPE].setInt8;
	  view.setInt8(0, 2147483648);
	  view.setInt8(1, 2147483649);
	  if(view.getInt8(0) || !view.getInt8(1))redefineAll($DataView[PROTOTYPE], {
	    setInt8: function setInt8(byteOffset, value){
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value){
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    }
	  }, true);
	}
	setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	setToStringTag($DataView, DATA_VIEW);
	hide($DataView[PROTOTYPE], $typed.VIEW, true);
	exports[ARRAY_BUFFER] = $ArrayBuffer;
	exports[DATA_VIEW] = $DataView;

/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(83);
	$export($export.G + $export.W + $export.F * !__webpack_require__(294).ABV, {
	  DataView: __webpack_require__(295).DataView
	});

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(298)('Int8', 1, function(init){
	  return function Int8Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	if(__webpack_require__(81)){
	  var LIBRARY             = __webpack_require__(103)
	    , global              = __webpack_require__(79)
	    , fails               = __webpack_require__(82)
	    , $export             = __webpack_require__(83)
	    , $typed              = __webpack_require__(294)
	    , $buffer             = __webpack_require__(295)
	    , ctx                 = __webpack_require__(95)
	    , anInstance          = __webpack_require__(280)
	    , propertyDesc        = __webpack_require__(92)
	    , hide                = __webpack_require__(85)
	    , redefineAll         = __webpack_require__(285)
	    , toInteger           = __webpack_require__(113)
	    , toLength            = __webpack_require__(112)
	    , toIndex             = __webpack_require__(114)
	    , toPrimitive         = __webpack_require__(91)
	    , has                 = __webpack_require__(80)
	    , same                = __webpack_require__(146)
	    , classof             = __webpack_require__(150)
	    , isObject            = __webpack_require__(88)
	    , toObject            = __webpack_require__(133)
	    , isArrayIter         = __webpack_require__(237)
	    , create              = __webpack_require__(121)
	    , getPrototypeOf      = __webpack_require__(134)
	    , gOPN                = __webpack_require__(125).f
	    , getIterFn           = __webpack_require__(239)
	    , uid                 = __webpack_require__(94)
	    , wks                 = __webpack_require__(100)
	    , createArrayMethod   = __webpack_require__(247)
	    , createArrayIncludes = __webpack_require__(111)
	    , speciesConstructor  = __webpack_require__(282)
	    , ArrayIterators      = __webpack_require__(268)
	    , Iterators           = __webpack_require__(204)
	    , $iterDetect         = __webpack_require__(240)
	    , setSpecies          = __webpack_require__(267)
	    , arrayFill           = __webpack_require__(263)
	    , arrayCopyWithin     = __webpack_require__(260)
	    , $DP                 = __webpack_require__(86)
	    , $GOPD               = __webpack_require__(126)
	    , dP                  = $DP.f
	    , gOPD                = $GOPD.f
	    , RangeError          = global.RangeError
	    , TypeError           = global.TypeError
	    , Uint8Array          = global.Uint8Array
	    , ARRAY_BUFFER        = 'ArrayBuffer'
	    , SHARED_BUFFER       = 'Shared' + ARRAY_BUFFER
	    , BYTES_PER_ELEMENT   = 'BYTES_PER_ELEMENT'
	    , PROTOTYPE           = 'prototype'
	    , ArrayProto          = Array[PROTOTYPE]
	    , $ArrayBuffer        = $buffer.ArrayBuffer
	    , $DataView           = $buffer.DataView
	    , arrayForEach        = createArrayMethod(0)
	    , arrayFilter         = createArrayMethod(2)
	    , arraySome           = createArrayMethod(3)
	    , arrayEvery          = createArrayMethod(4)
	    , arrayFind           = createArrayMethod(5)
	    , arrayFindIndex      = createArrayMethod(6)
	    , arrayIncludes       = createArrayIncludes(true)
	    , arrayIndexOf        = createArrayIncludes(false)
	    , arrayValues         = ArrayIterators.values
	    , arrayKeys           = ArrayIterators.keys
	    , arrayEntries        = ArrayIterators.entries
	    , arrayLastIndexOf    = ArrayProto.lastIndexOf
	    , arrayReduce         = ArrayProto.reduce
	    , arrayReduceRight    = ArrayProto.reduceRight
	    , arrayJoin           = ArrayProto.join
	    , arraySort           = ArrayProto.sort
	    , arraySlice          = ArrayProto.slice
	    , arrayToString       = ArrayProto.toString
	    , arrayToLocaleString = ArrayProto.toLocaleString
	    , ITERATOR            = wks('iterator')
	    , TAG                 = wks('toStringTag')
	    , TYPED_CONSTRUCTOR   = uid('typed_constructor')
	    , DEF_CONSTRUCTOR     = uid('def_constructor')
	    , ALL_CONSTRUCTORS    = $typed.CONSTR
	    , TYPED_ARRAY         = $typed.TYPED
	    , VIEW                = $typed.VIEW
	    , WRONG_LENGTH        = 'Wrong length!';
	
	  var $map = createArrayMethod(1, function(O, length){
	    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
	  });
	
	  var LITTLE_ENDIAN = fails(function(){
	    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
	  });
	
	  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function(){
	    new Uint8Array(1).set({});
	  });
	
	  var strictToLength = function(it, SAME){
	    if(it === undefined)throw TypeError(WRONG_LENGTH);
	    var number = +it
	      , length = toLength(it);
	    if(SAME && !same(number, length))throw RangeError(WRONG_LENGTH);
	    return length;
	  };
	
	  var toOffset = function(it, BYTES){
	    var offset = toInteger(it);
	    if(offset < 0 || offset % BYTES)throw RangeError('Wrong offset!');
	    return offset;
	  };
	
	  var validate = function(it){
	    if(isObject(it) && TYPED_ARRAY in it)return it;
	    throw TypeError(it + ' is not a typed array!');
	  };
	
	  var allocate = function(C, length){
	    if(!(isObject(C) && TYPED_CONSTRUCTOR in C)){
	      throw TypeError('It is not a typed array constructor!');
	    } return new C(length);
	  };
	
	  var speciesFromList = function(O, list){
	    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
	  };
	
	  var fromList = function(C, list){
	    var index  = 0
	      , length = list.length
	      , result = allocate(C, length);
	    while(length > index)result[index] = list[index++];
	    return result;
	  };
	
	  var addGetter = function(it, key, internal){
	    dP(it, key, {get: function(){ return this._d[internal]; }});
	  };
	
	  var $from = function from(source /*, mapfn, thisArg */){
	    var O       = toObject(source)
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , iterFn  = getIterFn(O)
	      , i, length, values, result, step, iterator;
	    if(iterFn != undefined && !isArrayIter(iterFn)){
	      for(iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++){
	        values.push(step.value);
	      } O = values;
	    }
	    if(mapping && aLen > 2)mapfn = ctx(mapfn, arguments[2], 2);
	    for(i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++){
	      result[i] = mapping ? mapfn(O[i], i) : O[i];
	    }
	    return result;
	  };
	
	  var $of = function of(/*...items*/){
	    var index  = 0
	      , length = arguments.length
	      , result = allocate(this, length);
	    while(length > index)result[index] = arguments[index++];
	    return result;
	  };
	
	  // iOS Safari 6.x fails here
	  var TO_LOCALE_BUG = !!Uint8Array && fails(function(){ arrayToLocaleString.call(new Uint8Array(1)); });
	
	  var $toLocaleString = function toLocaleString(){
	    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
	  };
	
	  var proto = {
	    copyWithin: function copyWithin(target, start /*, end */){
	      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    every: function every(callbackfn /*, thisArg */){
	      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    fill: function fill(value /*, start, end */){ // eslint-disable-line no-unused-vars
	      return arrayFill.apply(validate(this), arguments);
	    },
	    filter: function filter(callbackfn /*, thisArg */){
	      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
	        arguments.length > 1 ? arguments[1] : undefined));
	    },
	    find: function find(predicate /*, thisArg */){
	      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    findIndex: function findIndex(predicate /*, thisArg */){
	      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    forEach: function forEach(callbackfn /*, thisArg */){
	      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    indexOf: function indexOf(searchElement /*, fromIndex */){
	      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    includes: function includes(searchElement /*, fromIndex */){
	      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    join: function join(separator){ // eslint-disable-line no-unused-vars
	      return arrayJoin.apply(validate(this), arguments);
	    },
	    lastIndexOf: function lastIndexOf(searchElement /*, fromIndex */){ // eslint-disable-line no-unused-vars
	      return arrayLastIndexOf.apply(validate(this), arguments);
	    },
	    map: function map(mapfn /*, thisArg */){
	      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    reduce: function reduce(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
	      return arrayReduce.apply(validate(this), arguments);
	    },
	    reduceRight: function reduceRight(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
	      return arrayReduceRight.apply(validate(this), arguments);
	    },
	    reverse: function reverse(){
	      var that   = this
	        , length = validate(that).length
	        , middle = Math.floor(length / 2)
	        , index  = 0
	        , value;
	      while(index < middle){
	        value         = that[index];
	        that[index++] = that[--length];
	        that[length]  = value;
	      } return that;
	    },
	    some: function some(callbackfn /*, thisArg */){
	      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    sort: function sort(comparefn){
	      return arraySort.call(validate(this), comparefn);
	    },
	    subarray: function subarray(begin, end){
	      var O      = validate(this)
	        , length = O.length
	        , $begin = toIndex(begin, length);
	      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
	        O.buffer,
	        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
	        toLength((end === undefined ? length : toIndex(end, length)) - $begin)
	      );
	    }
	  };
	
	  var $slice = function slice(start, end){
	    return speciesFromList(this, arraySlice.call(validate(this), start, end));
	  };
	
	  var $set = function set(arrayLike /*, offset */){
	    validate(this);
	    var offset = toOffset(arguments[1], 1)
	      , length = this.length
	      , src    = toObject(arrayLike)
	      , len    = toLength(src.length)
	      , index  = 0;
	    if(len + offset > length)throw RangeError(WRONG_LENGTH);
	    while(index < len)this[offset + index] = src[index++];
	  };
	
	  var $iterators = {
	    entries: function entries(){
	      return arrayEntries.call(validate(this));
	    },
	    keys: function keys(){
	      return arrayKeys.call(validate(this));
	    },
	    values: function values(){
	      return arrayValues.call(validate(this));
	    }
	  };
	
	  var isTAIndex = function(target, key){
	    return isObject(target)
	      && target[TYPED_ARRAY]
	      && typeof key != 'symbol'
	      && key in target
	      && String(+key) == String(key);
	  };
	  var $getDesc = function getOwnPropertyDescriptor(target, key){
	    return isTAIndex(target, key = toPrimitive(key, true))
	      ? propertyDesc(2, target[key])
	      : gOPD(target, key);
	  };
	  var $setDesc = function defineProperty(target, key, desc){
	    if(isTAIndex(target, key = toPrimitive(key, true))
	      && isObject(desc)
	      && has(desc, 'value')
	      && !has(desc, 'get')
	      && !has(desc, 'set')
	      // TODO: add validation descriptor w/o calling accessors
	      && !desc.configurable
	      && (!has(desc, 'writable') || desc.writable)
	      && (!has(desc, 'enumerable') || desc.enumerable)
	    ){
	      target[key] = desc.value;
	      return target;
	    } else return dP(target, key, desc);
	  };
	
	  if(!ALL_CONSTRUCTORS){
	    $GOPD.f = $getDesc;
	    $DP.f   = $setDesc;
	  }
	
	  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
	    getOwnPropertyDescriptor: $getDesc,
	    defineProperty:           $setDesc
	  });
	
	  if(fails(function(){ arrayToString.call({}); })){
	    arrayToString = arrayToLocaleString = function toString(){
	      return arrayJoin.call(this);
	    }
	  }
	
	  var $TypedArrayPrototype$ = redefineAll({}, proto);
	  redefineAll($TypedArrayPrototype$, $iterators);
	  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
	  redefineAll($TypedArrayPrototype$, {
	    slice:          $slice,
	    set:            $set,
	    constructor:    function(){ /* noop */ },
	    toString:       arrayToString,
	    toLocaleString: $toLocaleString
	  });
	  addGetter($TypedArrayPrototype$, 'buffer', 'b');
	  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
	  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
	  addGetter($TypedArrayPrototype$, 'length', 'e');
	  dP($TypedArrayPrototype$, TAG, {
	    get: function(){ return this[TYPED_ARRAY]; }
	  });
	
	  module.exports = function(KEY, BYTES, wrapper, CLAMPED){
	    CLAMPED = !!CLAMPED;
	    var NAME       = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'
	      , ISNT_UINT8 = NAME != 'Uint8Array'
	      , GETTER     = 'get' + KEY
	      , SETTER     = 'set' + KEY
	      , TypedArray = global[NAME]
	      , Base       = TypedArray || {}
	      , TAC        = TypedArray && getPrototypeOf(TypedArray)
	      , FORCED     = !TypedArray || !$typed.ABV
	      , O          = {}
	      , TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
	    var getter = function(that, index){
	      var data = that._d;
	      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
	    };
	    var setter = function(that, index, value){
	      var data = that._d;
	      if(CLAMPED)value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
	      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
	    };
	    var addElement = function(that, index){
	      dP(that, index, {
	        get: function(){
	          return getter(this, index);
	        },
	        set: function(value){
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };
	    if(FORCED){
	      TypedArray = wrapper(function(that, data, $offset, $length){
	        anInstance(that, TypedArray, NAME, '_d');
	        var index  = 0
	          , offset = 0
	          , buffer, byteLength, length, klass;
	        if(!isObject(data)){
	          length     = strictToLength(data, true)
	          byteLength = length * BYTES;
	          buffer     = new $ArrayBuffer(byteLength);
	        } else if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
	          buffer = data;
	          offset = toOffset($offset, BYTES);
	          var $len = data.byteLength;
	          if($length === undefined){
	            if($len % BYTES)throw RangeError(WRONG_LENGTH);
	            byteLength = $len - offset;
	            if(byteLength < 0)throw RangeError(WRONG_LENGTH);
	          } else {
	            byteLength = toLength($length) * BYTES;
	            if(byteLength + offset > $len)throw RangeError(WRONG_LENGTH);
	          }
	          length = byteLength / BYTES;
	        } else if(TYPED_ARRAY in data){
	          return fromList(TypedArray, data);
	        } else {
	          return $from.call(TypedArray, data);
	        }
	        hide(that, '_d', {
	          b: buffer,
	          o: offset,
	          l: byteLength,
	          e: length,
	          v: new $DataView(buffer)
	        });
	        while(index < length)addElement(that, index++);
	      });
	      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
	      hide(TypedArrayPrototype, 'constructor', TypedArray);
	    } else if(!$iterDetect(function(iter){
	      // V8 works with iterators, but fails in many other cases
	      // https://code.google.com/p/v8/issues/detail?id=4552
	      new TypedArray(null); // eslint-disable-line no-new
	      new TypedArray(iter); // eslint-disable-line no-new
	    }, true)){
	      TypedArray = wrapper(function(that, data, $offset, $length){
	        anInstance(that, TypedArray, NAME);
	        var klass;
	        // `ws` module bug, temporarily remove validation length for Uint8Array
	        // https://github.com/websockets/ws/pull/645
	        if(!isObject(data))return new Base(strictToLength(data, ISNT_UINT8));
	        if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
	          return $length !== undefined
	            ? new Base(data, toOffset($offset, BYTES), $length)
	            : $offset !== undefined
	              ? new Base(data, toOffset($offset, BYTES))
	              : new Base(data);
	        }
	        if(TYPED_ARRAY in data)return fromList(TypedArray, data);
	        return $from.call(TypedArray, data);
	      });
	      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key){
	        if(!(key in TypedArray))hide(TypedArray, key, Base[key]);
	      });
	      TypedArray[PROTOTYPE] = TypedArrayPrototype;
	      if(!LIBRARY)TypedArrayPrototype.constructor = TypedArray;
	    }
	    var $nativeIterator   = TypedArrayPrototype[ITERATOR]
	      , CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined)
	      , $iterator         = $iterators.values;
	    hide(TypedArray, TYPED_CONSTRUCTOR, true);
	    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
	    hide(TypedArrayPrototype, VIEW, true);
	    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);
	
	    if(CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)){
	      dP(TypedArrayPrototype, TAG, {
	        get: function(){ return NAME; }
	      });
	    }
	
	    O[NAME] = TypedArray;
	
	    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
	
	    $export($export.S, NAME, {
	      BYTES_PER_ELEMENT: BYTES,
	      from: $from,
	      of: $of
	    });
	
	    if(!(BYTES_PER_ELEMENT in TypedArrayPrototype))hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
	
	    $export($export.P, NAME, proto);
	
	    setSpecies(NAME);
	
	    $export($export.P + $export.F * FORCED_SET, NAME, {set: $set});
	
	    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
	
	    $export($export.P + $export.F * (TypedArrayPrototype.toString != arrayToString), NAME, {toString: arrayToString});
	
	    $export($export.P + $export.F * fails(function(){
	      new TypedArray(1).slice();
	    }), NAME, {slice: $slice});
	
	    $export($export.P + $export.F * (fails(function(){
	      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()
	    }) || !fails(function(){
	      TypedArrayPrototype.toLocaleString.call([1, 2]);
	    })), NAME, {toLocaleString: $toLocaleString});
	
	    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
	    if(!LIBRARY && !CORRECT_ITER_NAME)hide(TypedArrayPrototype, ITERATOR, $iterator);
	  };
	} else module.exports = function(){ /* empty */ };

/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(298)('Uint8', 1, function(init){
	  return function Uint8Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(298)('Uint8', 1, function(init){
	  return function Uint8ClampedArray(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	}, true);

/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(298)('Int16', 2, function(init){
	  return function Int16Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(298)('Uint16', 2, function(init){
	  return function Uint16Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(298)('Int32', 4, function(init){
	  return function Int32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(298)('Uint32', 4, function(init){
	  return function Uint32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(298)('Float32', 4, function(init){
	  return function Float32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(298)('Float64', 8, function(init){
	  return function Float64Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
	var $export   = __webpack_require__(83)
	  , aFunction = __webpack_require__(96)
	  , anObject  = __webpack_require__(87)
	  , rApply    = (__webpack_require__(79).Reflect || {}).apply
	  , fApply    = Function.apply;
	// MS Edge argumentsList argument is optional
	$export($export.S + $export.F * !__webpack_require__(82)(function(){
	  rApply(function(){});
	}), 'Reflect', {
	  apply: function apply(target, thisArgument, argumentsList){
	    var T = aFunction(target)
	      , L = anObject(argumentsList);
	    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
	  }
	});

/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
	var $export    = __webpack_require__(83)
	  , create     = __webpack_require__(121)
	  , aFunction  = __webpack_require__(96)
	  , anObject   = __webpack_require__(87)
	  , isObject   = __webpack_require__(88)
	  , fails      = __webpack_require__(82)
	  , bind       = __webpack_require__(152)
	  , rConstruct = (__webpack_require__(79).Reflect || {}).construct;
	
	// MS Edge supports only 2 arguments and argumentsList argument is optional
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	var NEW_TARGET_BUG = fails(function(){
	  function F(){}
	  return !(rConstruct(function(){}, [], F) instanceof F);
	});
	var ARGS_BUG = !fails(function(){
	  rConstruct(function(){});
	});
	
	$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
	  construct: function construct(Target, args /*, newTarget*/){
	    aFunction(Target);
	    anObject(args);
	    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
	    if(ARGS_BUG && !NEW_TARGET_BUG)return rConstruct(Target, args, newTarget);
	    if(Target == newTarget){
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch(args.length){
	        case 0: return new Target;
	        case 1: return new Target(args[0]);
	        case 2: return new Target(args[0], args[1]);
	        case 3: return new Target(args[0], args[1], args[2]);
	        case 4: return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (bind.apply(Target, $args));
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto    = newTarget.prototype
	      , instance = create(isObject(proto) ? proto : Object.prototype)
	      , result   = Function.apply.call(Target, instance, args);
	    return isObject(result) ? result : instance;
	  }
	});

/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
	var dP          = __webpack_require__(86)
	  , $export     = __webpack_require__(83)
	  , anObject    = __webpack_require__(87)
	  , toPrimitive = __webpack_require__(91);
	
	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
	$export($export.S + $export.F * __webpack_require__(82)(function(){
	  Reflect.defineProperty(dP.f({}, 1, {value: 1}), 1, {value: 2});
	}), 'Reflect', {
	  defineProperty: function defineProperty(target, propertyKey, attributes){
	    anObject(target);
	    propertyKey = toPrimitive(propertyKey, true);
	    anObject(attributes);
	    try {
	      dP.f(target, propertyKey, attributes);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.4 Reflect.deleteProperty(target, propertyKey)
	var $export  = __webpack_require__(83)
	  , gOPD     = __webpack_require__(126).f
	  , anObject = __webpack_require__(87);
	
	$export($export.S, 'Reflect', {
	  deleteProperty: function deleteProperty(target, propertyKey){
	    var desc = gOPD(anObject(target), propertyKey);
	    return desc && !desc.configurable ? false : delete target[propertyKey];
	  }
	});

/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 26.1.5 Reflect.enumerate(target)
	var $export  = __webpack_require__(83)
	  , anObject = __webpack_require__(87);
	var Enumerate = function(iterated){
	  this._t = anObject(iterated); // target
	  this._i = 0;                  // next index
	  var keys = this._k = []       // keys
	    , key;
	  for(key in iterated)keys.push(key);
	};
	__webpack_require__(205)(Enumerate, 'Object', function(){
	  var that = this
	    , keys = that._k
	    , key;
	  do {
	    if(that._i >= keys.length)return {value: undefined, done: true};
	  } while(!((key = keys[that._i++]) in that._t));
	  return {value: key, done: false};
	});
	
	$export($export.S, 'Reflect', {
	  enumerate: function enumerate(target){
	    return new Enumerate(target);
	  }
	});

/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.6 Reflect.get(target, propertyKey [, receiver])
	var gOPD           = __webpack_require__(126)
	  , getPrototypeOf = __webpack_require__(134)
	  , has            = __webpack_require__(80)
	  , $export        = __webpack_require__(83)
	  , isObject       = __webpack_require__(88)
	  , anObject       = __webpack_require__(87);
	
	function get(target, propertyKey/*, receiver*/){
	  var receiver = arguments.length < 3 ? target : arguments[2]
	    , desc, proto;
	  if(anObject(target) === receiver)return target[propertyKey];
	  if(desc = gOPD.f(target, propertyKey))return has(desc, 'value')
	    ? desc.value
	    : desc.get !== undefined
	      ? desc.get.call(receiver)
	      : undefined;
	  if(isObject(proto = getPrototypeOf(target)))return get(proto, propertyKey, receiver);
	}
	
	$export($export.S, 'Reflect', {get: get});

/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
	var gOPD     = __webpack_require__(126)
	  , $export  = __webpack_require__(83)
	  , anObject = __webpack_require__(87);
	
	$export($export.S, 'Reflect', {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
	    return gOPD.f(anObject(target), propertyKey);
	  }
	});

/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.8 Reflect.getPrototypeOf(target)
	var $export  = __webpack_require__(83)
	  , getProto = __webpack_require__(134)
	  , anObject = __webpack_require__(87);
	
	$export($export.S, 'Reflect', {
	  getPrototypeOf: function getPrototypeOf(target){
	    return getProto(anObject(target));
	  }
	});

/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.9 Reflect.has(target, propertyKey)
	var $export = __webpack_require__(83);
	
	$export($export.S, 'Reflect', {
	  has: function has(target, propertyKey){
	    return propertyKey in target;
	  }
	});

/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.10 Reflect.isExtensible(target)
	var $export       = __webpack_require__(83)
	  , anObject      = __webpack_require__(87)
	  , $isExtensible = Object.isExtensible;
	
	$export($export.S, 'Reflect', {
	  isExtensible: function isExtensible(target){
	    anObject(target);
	    return $isExtensible ? $isExtensible(target) : true;
	  }
	});

/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.11 Reflect.ownKeys(target)
	var $export = __webpack_require__(83);
	
	$export($export.S, 'Reflect', {ownKeys: __webpack_require__(318)});

/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	// all object keys, includes non-enumerable and symbols
	var gOPN     = __webpack_require__(125)
	  , gOPS     = __webpack_require__(118)
	  , anObject = __webpack_require__(87)
	  , Reflect  = __webpack_require__(79).Reflect;
	module.exports = Reflect && Reflect.ownKeys || function ownKeys(it){
	  var keys       = gOPN.f(anObject(it))
	    , getSymbols = gOPS.f;
	  return getSymbols ? keys.concat(getSymbols(it)) : keys;
	};

/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.12 Reflect.preventExtensions(target)
	var $export            = __webpack_require__(83)
	  , anObject           = __webpack_require__(87)
	  , $preventExtensions = Object.preventExtensions;
	
	$export($export.S, 'Reflect', {
	  preventExtensions: function preventExtensions(target){
	    anObject(target);
	    try {
	      if($preventExtensions)$preventExtensions(target);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
	var dP             = __webpack_require__(86)
	  , gOPD           = __webpack_require__(126)
	  , getPrototypeOf = __webpack_require__(134)
	  , has            = __webpack_require__(80)
	  , $export        = __webpack_require__(83)
	  , createDesc     = __webpack_require__(92)
	  , anObject       = __webpack_require__(87)
	  , isObject       = __webpack_require__(88);
	
	function set(target, propertyKey, V/*, receiver*/){
	  var receiver = arguments.length < 4 ? target : arguments[3]
	    , ownDesc  = gOPD.f(anObject(target), propertyKey)
	    , existingDescriptor, proto;
	  if(!ownDesc){
	    if(isObject(proto = getPrototypeOf(target))){
	      return set(proto, propertyKey, V, receiver);
	    }
	    ownDesc = createDesc(0);
	  }
	  if(has(ownDesc, 'value')){
	    if(ownDesc.writable === false || !isObject(receiver))return false;
	    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
	    existingDescriptor.value = V;
	    dP.f(receiver, propertyKey, existingDescriptor);
	    return true;
	  }
	  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
	}
	
	$export($export.S, 'Reflect', {set: set});

/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.14 Reflect.setPrototypeOf(target, proto)
	var $export  = __webpack_require__(83)
	  , setProto = __webpack_require__(148);
	
	if(setProto)$export($export.S, 'Reflect', {
	  setPrototypeOf: function setPrototypeOf(target, proto){
	    setProto.check(target, proto);
	    try {
	      setProto.set(target, proto);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/Array.prototype.includes
	var $export   = __webpack_require__(83)
	  , $includes = __webpack_require__(111)(true);
	
	$export($export.P, 'Array', {
	  includes: function includes(el /*, fromIndex = 0 */){
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	
	__webpack_require__(261)('includes');

/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/mathiasbynens/String.prototype.at
	var $export = __webpack_require__(83)
	  , $at     = __webpack_require__(202)(true);
	
	$export($export.P, 'String', {
	  at: function at(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(83)
	  , $pad    = __webpack_require__(325);
	
	$export($export.P, 'String', {
	  padStart: function padStart(maxLength /*, fillString = ' ' */){
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
	  }
	});

/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-string-pad-start-end
	var toLength = __webpack_require__(112)
	  , repeat   = __webpack_require__(166)
	  , defined  = __webpack_require__(110);
	
	module.exports = function(that, maxLength, fillString, left){
	  var S            = String(defined(that))
	    , stringLength = S.length
	    , fillStr      = fillString === undefined ? ' ' : String(fillString)
	    , intMaxLength = toLength(maxLength);
	  if(intMaxLength <= stringLength || fillStr == '')return S;
	  var fillLen = intMaxLength - stringLength
	    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
	  if(stringFiller.length > fillLen)stringFiller = stringFiller.slice(0, fillLen);
	  return left ? stringFiller + S : S + stringFiller;
	};


/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(83)
	  , $pad    = __webpack_require__(325);
	
	$export($export.P, 'String', {
	  padEnd: function padEnd(maxLength /*, fillString = ' ' */){
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
	  }
	});

/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(158)('trimLeft', function($trim){
	  return function trimLeft(){
	    return $trim(this, 1);
	  };
	}, 'trimStart');

/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(158)('trimRight', function($trim){
	  return function trimRight(){
	    return $trim(this, 2);
	  };
	}, 'trimEnd');

/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/String.prototype.matchAll/
	var $export     = __webpack_require__(83)
	  , defined     = __webpack_require__(110)
	  , toLength    = __webpack_require__(112)
	  , isRegExp    = __webpack_require__(209)
	  , getFlags    = __webpack_require__(271)
	  , RegExpProto = RegExp.prototype;
	
	var $RegExpStringIterator = function(regexp, string){
	  this._r = regexp;
	  this._s = string;
	};
	
	__webpack_require__(205)($RegExpStringIterator, 'RegExp String', function next(){
	  var match = this._r.exec(this._s);
	  return {value: match, done: match === null};
	});
	
	$export($export.P, 'String', {
	  matchAll: function matchAll(regexp){
	    defined(this);
	    if(!isRegExp(regexp))throw TypeError(regexp + ' is not a regexp!');
	    var S     = String(this)
	      , flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp)
	      , rx    = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
	    rx.lastIndex = toLength(regexp.lastIndex);
	    return new $RegExpStringIterator(rx, S);
	  }
	});

/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(102)('asyncIterator');

/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(102)('observable');

/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-getownpropertydescriptors
	var $export        = __webpack_require__(83)
	  , ownKeys        = __webpack_require__(318)
	  , toIObject      = __webpack_require__(107)
	  , gOPD           = __webpack_require__(126)
	  , createProperty = __webpack_require__(238);
	
	$export($export.S, 'Object', {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
	    var O       = toIObject(object)
	      , getDesc = gOPD.f
	      , keys    = ownKeys(O)
	      , result  = {}
	      , i       = 0
	      , key;
	    while(keys.length > i)createProperty(result, key = keys[i++], getDesc(O, key));
	    return result;
	  }
	});

/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export = __webpack_require__(83)
	  , $values = __webpack_require__(334)(false);
	
	$export($export.S, 'Object', {
	  values: function values(it){
	    return $values(it);
	  }
	});

/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(105)
	  , toIObject = __webpack_require__(107)
	  , isEnum    = __webpack_require__(119).f;
	module.exports = function(isEntries){
	  return function(it){
	    var O      = toIObject(it)
	      , keys   = getKeys(O)
	      , length = keys.length
	      , i      = 0
	      , result = []
	      , key;
	    while(length > i)if(isEnum.call(O, key = keys[i++])){
	      result.push(isEntries ? [key, O[key]] : O[key]);
	    } return result;
	  };
	};

/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export  = __webpack_require__(83)
	  , $entries = __webpack_require__(334)(true);
	
	$export($export.S, 'Object', {
	  entries: function entries(it){
	    return $entries(it);
	  }
	});

/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export         = __webpack_require__(83)
	  , toObject        = __webpack_require__(133)
	  , aFunction       = __webpack_require__(96)
	  , $defineProperty = __webpack_require__(86);
	
	// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
	__webpack_require__(81) && $export($export.P + __webpack_require__(337), 'Object', {
	  __defineGetter__: function __defineGetter__(P, getter){
	    $defineProperty.f(toObject(this), P, {get: aFunction(getter), enumerable: true, configurable: true});
	  }
	});

/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	// Forced replacement prototype accessors methods
	module.exports = __webpack_require__(103)|| !__webpack_require__(82)(function(){
	  var K = Math.random();
	  // In FF throws only define methods
	  __defineSetter__.call(null, K, function(){ /* empty */});
	  delete __webpack_require__(79)[K];
	});

/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export         = __webpack_require__(83)
	  , toObject        = __webpack_require__(133)
	  , aFunction       = __webpack_require__(96)
	  , $defineProperty = __webpack_require__(86);
	
	// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
	__webpack_require__(81) && $export($export.P + __webpack_require__(337), 'Object', {
	  __defineSetter__: function __defineSetter__(P, setter){
	    $defineProperty.f(toObject(this), P, {set: aFunction(setter), enumerable: true, configurable: true});
	  }
	});

/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export                  = __webpack_require__(83)
	  , toObject                 = __webpack_require__(133)
	  , toPrimitive              = __webpack_require__(91)
	  , getPrototypeOf           = __webpack_require__(134)
	  , getOwnPropertyDescriptor = __webpack_require__(126).f;
	
	// B.2.2.4 Object.prototype.__lookupGetter__(P)
	__webpack_require__(81) && $export($export.P + __webpack_require__(337), 'Object', {
	  __lookupGetter__: function __lookupGetter__(P){
	    var O = toObject(this)
	      , K = toPrimitive(P, true)
	      , D;
	    do {
	      if(D = getOwnPropertyDescriptor(O, K))return D.get;
	    } while(O = getPrototypeOf(O));
	  }
	});

/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export                  = __webpack_require__(83)
	  , toObject                 = __webpack_require__(133)
	  , toPrimitive              = __webpack_require__(91)
	  , getPrototypeOf           = __webpack_require__(134)
	  , getOwnPropertyDescriptor = __webpack_require__(126).f;
	
	// B.2.2.5 Object.prototype.__lookupSetter__(P)
	__webpack_require__(81) && $export($export.P + __webpack_require__(337), 'Object', {
	  __lookupSetter__: function __lookupSetter__(P){
	    var O = toObject(this)
	      , K = toPrimitive(P, true)
	      , D;
	    do {
	      if(D = getOwnPropertyDescriptor(O, K))return D.set;
	    } while(O = getPrototypeOf(O));
	  }
	});

/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(83);
	
	$export($export.P + $export.R, 'Map', {toJSON: __webpack_require__(342)('Map')});

/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(150)
	  , from    = __webpack_require__(343);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};

/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(281);
	
	module.exports = function(iter, ITERATOR){
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(83);
	
	$export($export.P + $export.R, 'Set', {toJSON: __webpack_require__(342)('Set')});

/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-global
	var $export = __webpack_require__(83);
	
	$export($export.S, 'System', {global: __webpack_require__(79)});

/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-is-error
	var $export = __webpack_require__(83)
	  , cof     = __webpack_require__(109);
	
	$export($export.S, 'Error', {
	  isError: function isError(it){
	    return cof(it) === 'Error';
	  }
	});

/***/ },
/* 347 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(83);
	
	$export($export.S, 'Math', {
	  iaddh: function iaddh(x0, x1, y0, y1){
	    var $x0 = x0 >>> 0
	      , $x1 = x1 >>> 0
	      , $y0 = y0 >>> 0;
	    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
	  }
	});

/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(83);
	
	$export($export.S, 'Math', {
	  isubh: function isubh(x0, x1, y0, y1){
	    var $x0 = x0 >>> 0
	      , $x1 = x1 >>> 0
	      , $y0 = y0 >>> 0;
	    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
	  }
	});

/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(83);
	
	$export($export.S, 'Math', {
	  imulh: function imulh(u, v){
	    var UINT16 = 0xffff
	      , $u = +u
	      , $v = +v
	      , u0 = $u & UINT16
	      , v0 = $v & UINT16
	      , u1 = $u >> 16
	      , v1 = $v >> 16
	      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
	  }
	});

/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(83);
	
	$export($export.S, 'Math', {
	  umulh: function umulh(u, v){
	    var UINT16 = 0xffff
	      , $u = +u
	      , $v = +v
	      , u0 = $u & UINT16
	      , v0 = $v & UINT16
	      , u1 = $u >>> 16
	      , v1 = $v >>> 16
	      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
	  }
	});

/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                  = __webpack_require__(352)
	  , anObject                  = __webpack_require__(87)
	  , toMetaKey                 = metadata.key
	  , ordinaryDefineOwnMetadata = metadata.set;
	
	metadata.exp({defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey){
	  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
	}});

/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	var Map     = __webpack_require__(286)
	  , $export = __webpack_require__(83)
	  , shared  = __webpack_require__(98)('metadata')
	  , store   = shared.store || (shared.store = new (__webpack_require__(290)));
	
	var getOrCreateMetadataMap = function(target, targetKey, create){
	  var targetMetadata = store.get(target);
	  if(!targetMetadata){
	    if(!create)return undefined;
	    store.set(target, targetMetadata = new Map);
	  }
	  var keyMetadata = targetMetadata.get(targetKey);
	  if(!keyMetadata){
	    if(!create)return undefined;
	    targetMetadata.set(targetKey, keyMetadata = new Map);
	  } return keyMetadata;
	};
	var ordinaryHasOwnMetadata = function(MetadataKey, O, P){
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
	};
	var ordinaryGetOwnMetadata = function(MetadataKey, O, P){
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
	};
	var ordinaryDefineOwnMetadata = function(MetadataKey, MetadataValue, O, P){
	  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
	};
	var ordinaryOwnMetadataKeys = function(target, targetKey){
	  var metadataMap = getOrCreateMetadataMap(target, targetKey, false)
	    , keys        = [];
	  if(metadataMap)metadataMap.forEach(function(_, key){ keys.push(key); });
	  return keys;
	};
	var toMetaKey = function(it){
	  return it === undefined || typeof it == 'symbol' ? it : String(it);
	};
	var exp = function(O){
	  $export($export.S, 'Reflect', O);
	};
	
	module.exports = {
	  store: store,
	  map: getOrCreateMetadataMap,
	  has: ordinaryHasOwnMetadata,
	  get: ordinaryGetOwnMetadata,
	  set: ordinaryDefineOwnMetadata,
	  keys: ordinaryOwnMetadataKeys,
	  key: toMetaKey,
	  exp: exp
	};

/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(352)
	  , anObject               = __webpack_require__(87)
	  , toMetaKey              = metadata.key
	  , getOrCreateMetadataMap = metadata.map
	  , store                  = metadata.store;
	
	metadata.exp({deleteMetadata: function deleteMetadata(metadataKey, target /*, targetKey */){
	  var targetKey   = arguments.length < 3 ? undefined : toMetaKey(arguments[2])
	    , metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
	  if(metadataMap === undefined || !metadataMap['delete'](metadataKey))return false;
	  if(metadataMap.size)return true;
	  var targetMetadata = store.get(target);
	  targetMetadata['delete'](targetKey);
	  return !!targetMetadata.size || store['delete'](target);
	}});

/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(352)
	  , anObject               = __webpack_require__(87)
	  , getPrototypeOf         = __webpack_require__(134)
	  , ordinaryHasOwnMetadata = metadata.has
	  , ordinaryGetOwnMetadata = metadata.get
	  , toMetaKey              = metadata.key;
	
	var ordinaryGetMetadata = function(MetadataKey, O, P){
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if(hasOwn)return ordinaryGetOwnMetadata(MetadataKey, O, P);
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
	};
	
	metadata.exp({getMetadata: function getMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	var Set                     = __webpack_require__(289)
	  , from                    = __webpack_require__(343)
	  , metadata                = __webpack_require__(352)
	  , anObject                = __webpack_require__(87)
	  , getPrototypeOf          = __webpack_require__(134)
	  , ordinaryOwnMetadataKeys = metadata.keys
	  , toMetaKey               = metadata.key;
	
	var ordinaryMetadataKeys = function(O, P){
	  var oKeys  = ordinaryOwnMetadataKeys(O, P)
	    , parent = getPrototypeOf(O);
	  if(parent === null)return oKeys;
	  var pKeys  = ordinaryMetadataKeys(parent, P);
	  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
	};
	
	metadata.exp({getMetadataKeys: function getMetadataKeys(target /*, targetKey */){
	  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	}});

/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(352)
	  , anObject               = __webpack_require__(87)
	  , ordinaryGetOwnMetadata = metadata.get
	  , toMetaKey              = metadata.key;
	
	metadata.exp({getOwnMetadata: function getOwnMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                = __webpack_require__(352)
	  , anObject                = __webpack_require__(87)
	  , ordinaryOwnMetadataKeys = metadata.keys
	  , toMetaKey               = metadata.key;
	
	metadata.exp({getOwnMetadataKeys: function getOwnMetadataKeys(target /*, targetKey */){
	  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	}});

/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(352)
	  , anObject               = __webpack_require__(87)
	  , getPrototypeOf         = __webpack_require__(134)
	  , ordinaryHasOwnMetadata = metadata.has
	  , toMetaKey              = metadata.key;
	
	var ordinaryHasMetadata = function(MetadataKey, O, P){
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if(hasOwn)return true;
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
	};
	
	metadata.exp({hasMetadata: function hasMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(352)
	  , anObject               = __webpack_require__(87)
	  , ordinaryHasOwnMetadata = metadata.has
	  , toMetaKey              = metadata.key;
	
	metadata.exp({hasOwnMetadata: function hasOwnMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                  = __webpack_require__(352)
	  , anObject                  = __webpack_require__(87)
	  , aFunction                 = __webpack_require__(96)
	  , toMetaKey                 = metadata.key
	  , ordinaryDefineOwnMetadata = metadata.set;
	
	metadata.exp({metadata: function metadata(metadataKey, metadataValue){
	  return function decorator(target, targetKey){
	    ordinaryDefineOwnMetadata(
	      metadataKey, metadataValue,
	      (targetKey !== undefined ? anObject : aFunction)(target),
	      toMetaKey(targetKey)
	    );
	  };
	}});

/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
	var $export   = __webpack_require__(83)
	  , microtask = __webpack_require__(284)()
	  , process   = __webpack_require__(79).process
	  , isNode    = __webpack_require__(109)(process) == 'process';
	
	$export($export.G, {
	  asap: function asap(fn){
	    var domain = isNode && process.domain;
	    microtask(domain ? domain.bind(fn) : fn);
	  }
	});

/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/zenparsing/es-observable
	var $export     = __webpack_require__(83)
	  , global      = __webpack_require__(79)
	  , core        = __webpack_require__(84)
	  , microtask   = __webpack_require__(284)()
	  , OBSERVABLE  = __webpack_require__(100)('observable')
	  , aFunction   = __webpack_require__(96)
	  , anObject    = __webpack_require__(87)
	  , anInstance  = __webpack_require__(280)
	  , redefineAll = __webpack_require__(285)
	  , hide        = __webpack_require__(85)
	  , forOf       = __webpack_require__(281)
	  , RETURN      = forOf.RETURN;
	
	var getMethod = function(fn){
	  return fn == null ? undefined : aFunction(fn);
	};
	
	var cleanupSubscription = function(subscription){
	  var cleanup = subscription._c;
	  if(cleanup){
	    subscription._c = undefined;
	    cleanup();
	  }
	};
	
	var subscriptionClosed = function(subscription){
	  return subscription._o === undefined;
	};
	
	var closeSubscription = function(subscription){
	  if(!subscriptionClosed(subscription)){
	    subscription._o = undefined;
	    cleanupSubscription(subscription);
	  }
	};
	
	var Subscription = function(observer, subscriber){
	  anObject(observer);
	  this._c = undefined;
	  this._o = observer;
	  observer = new SubscriptionObserver(this);
	  try {
	    var cleanup      = subscriber(observer)
	      , subscription = cleanup;
	    if(cleanup != null){
	      if(typeof cleanup.unsubscribe === 'function')cleanup = function(){ subscription.unsubscribe(); };
	      else aFunction(cleanup);
	      this._c = cleanup;
	    }
	  } catch(e){
	    observer.error(e);
	    return;
	  } if(subscriptionClosed(this))cleanupSubscription(this);
	};
	
	Subscription.prototype = redefineAll({}, {
	  unsubscribe: function unsubscribe(){ closeSubscription(this); }
	});
	
	var SubscriptionObserver = function(subscription){
	  this._s = subscription;
	};
	
	SubscriptionObserver.prototype = redefineAll({}, {
	  next: function next(value){
	    var subscription = this._s;
	    if(!subscriptionClosed(subscription)){
	      var observer = subscription._o;
	      try {
	        var m = getMethod(observer.next);
	        if(m)return m.call(observer, value);
	      } catch(e){
	        try {
	          closeSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      }
	    }
	  },
	  error: function error(value){
	    var subscription = this._s;
	    if(subscriptionClosed(subscription))throw value;
	    var observer = subscription._o;
	    subscription._o = undefined;
	    try {
	      var m = getMethod(observer.error);
	      if(!m)throw value;
	      value = m.call(observer, value);
	    } catch(e){
	      try {
	        cleanupSubscription(subscription);
	      } finally {
	        throw e;
	      }
	    } cleanupSubscription(subscription);
	    return value;
	  },
	  complete: function complete(value){
	    var subscription = this._s;
	    if(!subscriptionClosed(subscription)){
	      var observer = subscription._o;
	      subscription._o = undefined;
	      try {
	        var m = getMethod(observer.complete);
	        value = m ? m.call(observer, value) : undefined;
	      } catch(e){
	        try {
	          cleanupSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      } cleanupSubscription(subscription);
	      return value;
	    }
	  }
	});
	
	var $Observable = function Observable(subscriber){
	  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
	};
	
	redefineAll($Observable.prototype, {
	  subscribe: function subscribe(observer){
	    return new Subscription(observer, this._f);
	  },
	  forEach: function forEach(fn){
	    var that = this;
	    return new (core.Promise || global.Promise)(function(resolve, reject){
	      aFunction(fn);
	      var subscription = that.subscribe({
	        next : function(value){
	          try {
	            return fn(value);
	          } catch(e){
	            reject(e);
	            subscription.unsubscribe();
	          }
	        },
	        error: reject,
	        complete: resolve
	      });
	    });
	  }
	});
	
	redefineAll($Observable, {
	  from: function from(x){
	    var C = typeof this === 'function' ? this : $Observable;
	    var method = getMethod(anObject(x)[OBSERVABLE]);
	    if(method){
	      var observable = anObject(method.call(x));
	      return observable.constructor === C ? observable : new C(function(observer){
	        return observable.subscribe(observer);
	      });
	    }
	    return new C(function(observer){
	      var done = false;
	      microtask(function(){
	        if(!done){
	          try {
	            if(forOf(x, false, function(it){
	              observer.next(it);
	              if(done)return RETURN;
	            }) === RETURN)return;
	          } catch(e){
	            if(done)throw e;
	            observer.error(e);
	            return;
	          } observer.complete();
	        }
	      });
	      return function(){ done = true; };
	    });
	  },
	  of: function of(){
	    for(var i = 0, l = arguments.length, items = Array(l); i < l;)items[i] = arguments[i++];
	    return new (typeof this === 'function' ? this : $Observable)(function(observer){
	      var done = false;
	      microtask(function(){
	        if(!done){
	          for(var i = 0; i < items.length; ++i){
	            observer.next(items[i]);
	            if(done)return;
	          } observer.complete();
	        }
	      });
	      return function(){ done = true; };
	    });
	  }
	});
	
	hide($Observable.prototype, OBSERVABLE, function(){ return this; });
	
	$export($export.G, {Observable: $Observable});
	
	__webpack_require__(267)('Observable');

/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	// ie9- setTimeout & setInterval additional parameters fix
	var global     = __webpack_require__(79)
	  , $export    = __webpack_require__(83)
	  , invoke     = __webpack_require__(153)
	  , partial    = __webpack_require__(364)
	  , navigator  = global.navigator
	  , MSIE       = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
	var wrap = function(set){
	  return MSIE ? function(fn, time /*, ...args */){
	    return set(invoke(
	      partial,
	      [].slice.call(arguments, 2),
	      typeof fn == 'function' ? fn : Function(fn)
	    ), time);
	  } : set;
	};
	$export($export.G + $export.B + $export.F * MSIE, {
	  setTimeout:  wrap(global.setTimeout),
	  setInterval: wrap(global.setInterval)
	});

/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var path      = __webpack_require__(365)
	  , invoke    = __webpack_require__(153)
	  , aFunction = __webpack_require__(96);
	module.exports = function(/* ...pargs */){
	  var fn     = aFunction(this)
	    , length = arguments.length
	    , pargs  = Array(length)
	    , i      = 0
	    , _      = path._
	    , holder = false;
	  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
	  return function(/* ...args */){
	    var that = this
	      , aLen = arguments.length
	      , j = 0, k = 0, args;
	    if(!holder && !aLen)return invoke(fn, pargs, that);
	    args = pargs.slice();
	    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
	    while(aLen > k)args.push(arguments[k++]);
	    return invoke(fn, args, that);
	  };
	};

/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(79);

/***/ },
/* 366 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(83)
	  , $task   = __webpack_require__(283);
	$export($export.G + $export.B, {
	  setImmediate:   $task.set,
	  clearImmediate: $task.clear
	});

/***/ },
/* 367 */
/***/ function(module, exports, __webpack_require__) {

	var $iterators    = __webpack_require__(268)
	  , redefine      = __webpack_require__(93)
	  , global        = __webpack_require__(79)
	  , hide          = __webpack_require__(85)
	  , Iterators     = __webpack_require__(204)
	  , wks           = __webpack_require__(100)
	  , ITERATOR      = wks('iterator')
	  , TO_STRING_TAG = wks('toStringTag')
	  , ArrayValues   = Iterators.Array;
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype
	    , key;
	  if(proto){
	    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);
	    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	    Iterators[NAME] = ArrayValues;
	    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);
	  }
	}

/***/ },
/* 368 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  // This is a polyfill for %IteratorPrototype% for environments that
	  // don't natively support it.
	  var IteratorPrototype = {};
	  IteratorPrototype[iteratorSymbol] = function () {
	    return this;
	  };
	
	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype &&
	      NativeIteratorPrototype !== Op &&
	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    // This environment has a native %IteratorPrototype%; use it instead
	    // of the polyfill.
	    IteratorPrototype = NativeIteratorPrototype;
	  }
	
	  var Gp = GeneratorFunctionPrototype.prototype =
	    Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] =
	    GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
	  // meant to be awaited.
	  runtime.awrap = function(arg) {
	    return { __await: arg };
	  };
	
	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value &&
	            typeof value === "object" &&
	            hasOwn.call(value, "__await")) {
	          return Promise.resolve(value.__await).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	
	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	  runtime.AsyncIterator = AsyncIterator;
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" ||
	              (method === "throw" && delegate.iterator[method] === undefined)) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;
	
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }
	
	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }
	
	          var record = tryCatch(
	            delegate.iterator[method],
	            delegate.iterator,
	            arg
	          );
	
	          if (record.type === "throw") {
	            context.delegate = null;
	
	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }
	
	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;
	
	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }
	
	          context.delegate = null;
	        }
	
	        if (method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = arg;
	
	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }
	
	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }
	
	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          var info = {
	            value: record.arg,
	            done: context.done
	          };
	
	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[toStringTagSymbol] = "Generator";
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }
	
	      return ContinueSentinel;
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(8)))

/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(370);
	module.exports = __webpack_require__(84).RegExp.escape;

/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/benjamingr/RexExp.escape
	var $export = __webpack_require__(83)
	  , $re     = __webpack_require__(371)(/[\\^$*+?.()|[\]{}]/g, '\\$&');
	
	$export($export.S, 'RegExp', {escape: function escape(it){ return $re(it); }});


/***/ },
/* 371 */
/***/ function(module, exports) {

	module.exports = function(regExp, replace){
	  var replacer = replace === Object(replace) ? function(part){
	    return replace[part];
	  } : replace;
	  return function(it){
	    return String(it).replace(regExp, replacer);
	  };
	};

/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA3YmI5YmM5YjA4NzE5YTIyZjFiMiIsIndlYnBhY2s6Ly8vLi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9kcmF3VG9vbC9EcmF3VG9vbC5qcyIsIndlYnBhY2s6Ly8vLi9kcmF3VG9vbC9kZWZhdWx0UGFyYW1zU2V0LmpzIiwid2VicGFjazovLy8uLi9+L2ZhYnJpYy9kaXN0L2ZhYnJpYy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vYmFzZTY0LWpzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vL2pzZG9tIChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vY2FudmFzIChpZ25vcmVkKSIsIndlYnBhY2s6Ly8veG1sZG9tIChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vLi4vfi91cmwvdXJsLmpzIiwid2VicGFjazovLy8uLi9+L3VybC9+L3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovLy8uLi9+L3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vdXJsL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcXVlcnlzdHJpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vcXVlcnlzdHJpbmcvZGVjb2RlLmpzIiwid2VicGFjazovLy8uLi9+L3F1ZXJ5c3RyaW5nL2VuY29kZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9zdHJlYW0taHR0cC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9zdHJlYW0taHR0cC9saWIvcmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9zdHJlYW0taHR0cC9saWIvY2FwYWJpbGl0eS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy8uLi9+L3N0cmVhbS1odHRwL2xpYi9yZXNwb25zZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwid2VicGFjazovLy8uLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJ3ZWJwYWNrOi8vLy4uL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4uL34vdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9idWZmZXItc2hpbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJ3ZWJwYWNrOi8vL3V0aWwgKGlnbm9yZWQpIiwid2VicGFjazovLy8uLi9+L3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0LmpzIiwid2VicGFjazovLy8uLi9+L3N0cmluZ19kZWNvZGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJ3ZWJwYWNrOi8vLy4uL34vdG8tYXJyYXlidWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34veHRlbmQvaW1tdXRhYmxlLmpzIiwid2VicGFjazovLy8uLi9+L2J1aWx0aW4tc3RhdHVzLWNvZGVzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vaHR0cHMtYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vZnMgKGlnbm9yZWQpIiwid2VicGFjazovLy8uL2RyYXdUb29sL2RhZmF1bHRQYXJhbXMuanMiLCJ3ZWJwYWNrOi8vLy4vZHJhd1Rvb2wvdXRpbHMvZm9udExvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9kcmF3VG9vbC91dGlscy9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vZHJhd1Rvb2wvdXRpbHMvZXNjYXBlSlNPTi5qcyIsIndlYnBhY2s6Ly8vLi9kcmF3VG9vbC91dGlscy9mYWJyaWMudXVpZC5qcyIsIndlYnBhY2s6Ly8vLi9kcmF3VG9vbC9TaWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9kcmF3VG9vbC9TaWRlLmpzIiwid2VicGFjazovLy8uL2RyYXdUb29sL0l0ZW1zLmpzIiwid2VicGFjazovLy8uL2RyYXdUb29sL0l0ZW0uanMiLCJ3ZWJwYWNrOi8vLy4vZHJhd1Rvb2wvdXRpbHMvY2xpcC5qcyIsIndlYnBhY2s6Ly8vLi9kcmF3VG9vbC9MYXllcnMuanMiLCJ3ZWJwYWNrOi8vLy4vZHJhd1Rvb2wvdXRpbHMvY29sb3JQaWNrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZHJhd1Rvb2wvRHJhd0hpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vZHJhd1Rvb2wvRXJhc2VyLmpzIiwid2VicGFjazovLy8uL2RyYXdUb29sL2JydXNoZXMvdXRpbC91dGlsLmV4dGVuZC5qcyIsIndlYnBhY2s6Ly8vLi9kcmF3VG9vbC9icnVzaGVzL3V0aWwvYmFzZUJydXNoLmV4dGVuZC5qcyIsIndlYnBhY2s6Ly8vLi9kcmF3VG9vbC9icnVzaGVzL3V0aWwvcG9pbnQuZXh0ZW5kLmpzIiwid2VicGFjazovLy8uL2RyYXdUb29sL2JydXNoZXMvYnJ1c2hlcy9zdHJva2UuanMiLCJ3ZWJwYWNrOi8vLy4vZHJhd1Rvb2wvYnJ1c2hlcy9icnVzaGVzL3BlbmNpbEJydXNoLmpzIiwid2VicGFjazovLy8uL2RyYXdUb29sL2JydXNoZXMvYnJ1c2hlcy9jcmF5b25CcnVzaC5qcyIsIndlYnBhY2s6Ly8vLi9kcmF3VG9vbC9icnVzaGVzL2JydXNoZXMvaW5rQnJ1c2guanMiLCJ3ZWJwYWNrOi8vLy4vZHJhd1Rvb2wvYnJ1c2hlcy9icnVzaGVzL3NwcmF5QnJ1c2guanMiLCJ3ZWJwYWNrOi8vLy4vZHJhd1Rvb2wvYnJ1c2hlcy9icnVzaGVzL21hcmtlckJydXNoLmpzIiwid2VicGFjazovLy8uL2RyYXdUb29sL2JydXNoZXMvYnJ1c2hlcy9jdXN0b21CcnVzaC5qcyIsIndlYnBhY2s6Ly8vLi9kcmF3VG9vbC9icnVzaGVzL2JydXNoZXMvamFwYW5lc2VCcnVzaC5qcyIsIndlYnBhY2s6Ly8vLi9kcmF3VG9vbC91dGlscy9yZW1vdmVDb2xvci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1wb2x5ZmlsbC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9zaGltLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19mYWlscy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fY3R4LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX21ldGEuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3drcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3drcy1leHQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fbGlicmFyeS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2tleW9mLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3Qtc2FwLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL190by1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2VhbC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLXNlYWxlZC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1leHRlbnNpYmxlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19zYW1lLXZhbHVlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19zZXQtcHJvdG8uanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19iaW5kLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9faW52b2tlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWludC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWludC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy10cmltLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXdzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucGFyc2UtZmxvYXQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19wYXJzZS1mbG9hdC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2luaGVyaXQtaWYtcmVxdWlyZWQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIudG8tZml4ZWQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19hLW51bWJlci12YWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1yZXBlYXQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIudG8tcHJlY2lzaW9uLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24uanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtZmluaXRlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19pcy1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYWNvc2guanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19tYXRoLWxvZzFwLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hc2luaC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXRhbmguanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNicnQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19tYXRoLXNpZ24uanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNsejMyLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jb3NoLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5leHBtMS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX21hdGgtZXhwbTEuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmZyb3VuZC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmltdWwuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxcC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2luaC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudGFuaC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudHJ1bmMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJhdy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy50cmltLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1jb250ZXh0LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtcmVnZXhwLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fZmFpbHMtaXMtcmVnZXhwLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5hbmNob3IuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctaHRtbC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5iaWcuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYmxpbmsuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYm9sZC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250Y29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udHNpemUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5saW5rLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnNtYWxsLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0cmlrZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdWIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3VwLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS5ub3cuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24uanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm9mLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuam9pbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmljdC1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zbGljZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvcnQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5tYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb21lLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZXZlcnkuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UtcmlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pbmRleC1vZi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWNvcHktd2l0aGluLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNwZWNpZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1zdGVwLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAudG8tc3RyaW5nLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLm1hdGNoLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnByb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19hbi1pbnN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2Zvci1vZi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL190YXNrLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fbWljcm90YXNrLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWFwLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc2V0LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1tYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXdlYWsuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLXNldC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYnVmZmVyLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZGF0YS12aWV3LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLWFycmF5LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQzMi1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5hcHBseS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuY29uc3RydWN0LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlbGV0ZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZW51bWVyYXRlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuaGFzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5pcy1leHRlbnNpYmxlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5vd24ta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX293bi1rZXlzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLmF0LmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1wYWQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5tYXRjaC1hbGwuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LnZhbHVlcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC10by1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1nZXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZm9yY2VkLXBhbS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtc2V0dGVyLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLXNldHRlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC50by1qc29uLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi10by1qc29uLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LmVycm9yLmlzLWVycm9yLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pYWRkaC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaXN1YmguanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmltdWxoLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC51bXVsaC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlbGV0ZS1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS1rZXlzLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1vd24tbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lm1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuYXNhcC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL3dlYi50aW1lcnMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19wYXJ0aWFsLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fcGF0aC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9mbi9yZWdleHAvZXNjYXBlLmpzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9jb3JlLnJlZ2V4cC5lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19yZXBsYWNlci5qcyJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiZ2xvYmFsIiwiX2JhYmVsUG9seWZpbGwiLCJyZXF1aXJlIiwiRHJhd1Rvb2wiLCJlZGl0YWJsZSIsImNvbnRhaW5lciIsInRhcmdldCIsImRvY3VtZW50IiwiYm9keSIsInNpemUiLCJ3aWR0aCIsImhlaWdodCIsImdyaWRTdGVwIiwiZ3JpZCIsImNvbG9yIiwic3Ryb2tlV2lkdGgiLCJib3JkZXIiLCJiYWNrZ3JvdW5kQ29sb3IiLCJzdHJva2VEYXNoQXJyYXkiLCJfY2FsbGJhY2tzIiwic2lkZXMiLCJfZXZlbnRlZCIsIl9fZGF0YSIsImluaXRpYWxpemUiLCJIVE1MRWxlbWVudCIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImVycm9yIiwiSFRNTEVsZW1lbnRVbmRlZmluZWQiLCJfdGFyZ2V0Iiwid2luZG93IiwiaGFzT3duUHJvcGVydHkiLCJqUXVlcnkiLCJfc2l6ZSIsInRleHRDb250ZW50Iiwic3R5bGUiLCJwb3NpdGlvbiIsImhpc3RvcnkiLCJzZXRFZGl0YWJsZSIsInZhbCIsIl9jb2xsZWN0aW9uIiwiZm9yRWFjaCIsInNpZGUiLCJGYWJyaWNCb3JkZXIiLCJzZXQiLCJGYWJyaWNDYW52YXMiLCJkZWFjdGl2YXRlQWxsIiwicmVuZGVyQWxsIiwib24iLCJldmVudCIsImhhbmRsZXIiLCJwdXNoIiwib2ZmIiwiZGVsZXRlIiwidHJpZ2dlciIsImRhdGEiLCJwdXNoU3RhdGUiLCJpZCIsImdldFNpZGUiLCJsYXllcnMiLCJ1cGRhdGUiLCJjYiIsImV4cG9ydEpTT04iLCJtYXAiLCJ0b09iamVjdCIsImltcG9ydEpTT04iLCJqc29uIiwiaW5pdGlhbFpvb20iLCJwcm9wb3J0aW9ucyIsImxlbmd0aCIsIml0ZW1zIiwiZmluYWxpemVCcnVzaCIsInRvSlNPTiIsImVtcHR5IiwicGFyc2UiLCJwcm9taXNlcyIsIl9zaWRlIiwiYWRkU2lkZSIsInNldEltYWdlIiwiaW1hZ2VVcmwiLCJjbSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiYWxsIiwidGhlbiIsInZhbHVlcyIsImQiLCJpbmRleCIsImRlZmF1bHRXb3Jrc3BhY2VTaXplIiwicGl4ZWwiLCJzZXRCb3JkZXIiLCJ6b29tVG9WYWwiLCJmcm9tSlNPTiIsImJpbmQiLCJzZXRDdXN0b21pc2VDb250cm9scyIsImN1c3RvbWlzZUxpc3QiLCJpc1ZNTCIsIkdfdm1sQ2FudmFzTWFuYWdlciIsImtleSIsImljb25JbWFnZSIsImNyZWF0ZUVsZW1lbnQiLCJzcmMiLCJmYWJyaWMiLCJ1dGlsIiwib2JqZWN0IiwiZXh0ZW5kIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiX2RyYXdDb250cm9sIiwiY29udHJvbCIsImN0eCIsIm1ldGhvZE5hbWUiLCJsZWZ0IiwidG9wIiwiaXNDb250cm9sVmlzaWJsZSIsImNvcm5lclNpemUiLCJzdHJva2UiLCJ0cmFuc3BhcmVudENvcm5lcnMiLCJjb3JuZXJTdHJva2VDb2xvciIsImNsZWFyUmVjdCIsIm9mZnNldCIsIngiLCJ5IiwiZHJhd0ltYWdlIiwiY29ybmVyU3R5bGUiLCJiZWdpblBhdGgiLCJhcmMiLCJNYXRoIiwiUEkiLCJzdHJva2VSZWN0IiwiX3NldENvcm5lckNvb3JkcyIsImNvb3JkcyIsIm9Db29yZHMiLCJuZXdUaGV0YSIsImRlZ3JlZXNUb1JhZGlhbnMiLCJhbmdsZSIsImNvcm5lckh5cG90ZW51c2UiLCJjb3NIYWxmT2Zmc2V0IiwiY29zIiwic2luSGFsZk9mZnNldCIsInNpbiIsInBvaW50IiwiY29ybmVyIiwidGwiLCJ0ciIsImJsIiwiYnIiLCJmb250TG9hZGVyIiwiZm9udHMiLCJkZWZhdWx0UGFyYW1zIiwidGl0bGUiLCJ1cmxzIiwiZm9udEZhY2UiLCJlb3QiLCJ3b2ZmMiIsIndvZmYiLCJ0dGYiLCJzdmciLCJpbm5lclRleHQiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJmb3JjZUNhbGwiLCJmb250RmFtaWx5IiwidGV4dEluZGVudCIsInpJbmRleCIsImVycm9ycyIsInNpZGVOb1NpemUiLCJjb2RlIiwibWVzc2FnZSIsInNpZGVOb0JvcmRlciIsImVzY2FwZUpTT04iLCJzdHJpbmciLCJzdHIiLCJyZXBsYWNlIiwidXVpZCIsImMiLCJyIiwicmFuZG9tIiwidiIsInRvU3RyaW5nIiwic2V0T3B0aW9ucyIsIm9wdGlvbnMiLCJhcHBseSIsInByb3BlcnRpZXNUb0luY2x1ZGUiLCJjb25jYXQiLCJTaWRlcyIsInNlbGVjdGVkIiwibmV3U2lkZSIsImZpbmQiLCJ3cmFwcGVyRWwiLCJkaXNwbGF5IiwiZmluZEluZGV4IiwiY2xlYXIiLCJ1bmRlZmluZWQiLCJjYW52YXMiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJzcGxpY2UiLCJjb2xsZWN0aW9uIiwicmVtb3ZlU2lkZSIsIlNpZGUiLCJ0aGF0IiwicGFkZGluZyIsIl9wYW5uaW5nIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJfaW5pdEZhYnJpYyIsIl9pbml0RXZlbnRzIiwiY3VycmVudEJydXNoIiwiY29sb3JQaWNrZXIiLCJ1cmwiLCJib3JkZXJTaXplIiwiY2VudGVyIiwiZ2V0Q2VudGVyIiwic2V0QmFja2dyb3VuZENvbG9yIiwic2V0QmFja2dyb3VuZEltYWdlIiwiYmFja2Ryb3AiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJleGNsdWRlRnJvbUV4cG9ydCIsImNhbnZhc0FzcGVjdFJhdGlvIiwiYm9yZGVyQXNwZWN0UmF0aW8iLCJjYW52YXNQcm9wb3J0aW9ucyIsImJnUHJvcG9ydGlvbnMiLCJzY2FsZVRvV2lkdGgiLCJzY2FsZVRvSGVpZ2h0IiwiX3NldE9mZnNldCIsImJnT2Zmc2V0IiwiY21TaXplIiwiX2NhbGN1bGF0ZVNpemUiLCJvcmlnaW5YIiwib3JpZ2luWSIsIm9wYWNpdHkiLCJjcm9zc09yaWdpbiIsImluaXRHcmlkIiwiaW5pdFJ1bGVyIiwiaW5pdFdvcmtzcGFjZUdyaWQiLCJpbml0V29ya3NwYWNlUnVsZXIiLCJyZW1vdmUiLCJfb3B0cyIsImZpbGwiLCJoYXNSb3RhdGluZ1BvaW50IiwibG9ja1JvdGF0aW9uIiwicGFkZGluZ1RvcCIsInNjYWxlWSIsInBhZGRpbmdMZWZ0Iiwic2NhbGVYIiwiX29wdGlvbnMiLCJSZWN0Iiwic2V0Q29vcmRzIiwic2VsZWN0YWJsZSIsImhvdmVyQ3Vyc29yIiwiYWRkIiwiZ2V0Q2VudGVyUG9pbnQiLCJ6b29tVG9Qb2ludCIsInpvb20iLCJnZXRab29tIiwiUG9pbnQiLCJnZXRXaWR0aCIsImdldEhlaWdodCIsIl9mb3JtYXR0ZWRTaWRlIiwib2JqZWN0cyIsIml0ZW0iLCJjbGlwVG8iLCJnZXRCb3JkZXIiLCJmYWN0b3IiLCJfcmVtb3ZlRXZlbnRzIiwiY2FudmFzRGF0YSIsImxvYWRGcm9tSlNPTiIsInNlbmRUb0JhY2siLCJvIiwiY2FsbGJhY2siLCJ3aXRob3V0QmciLCJjbG9uZSIsImZvckVhY2hPYmplY3QiLCJ0eXBlIiwiYmFzZTY0IiwidG9EYXRhVVJMIiwiZW5hYmxlUmV0aW5hIiwiaW1hZ2UiLCJJbWFnZSIsImZhYnJpY0ltYWdlIiwiZ2V0T2JqZWN0cyIsImluZGV4T2YiLCJtb3ZlVG8iLCJ0b1NWRyIsInN1cHByZXNzUHJlYW1ibGUiLCJ2aWV3Qm94IiwiZWwiLCJpbmNsdWRlcyIsInBhcnNlciIsIkRPTVBhcnNlciIsImRvYyIsInBhcnNlRnJvbVN0cmluZyIsInN2Z09iaiIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwic2V0QXR0cmlidXRlIiwicmVjdCIsImlubmVySFRNTCIsInNldFZpc2libGUiLCJnZXRWcENlbnRlciIsInNldFpvb20iLCJhYnNvbHV0ZVBhbiIsInByZXZpZXciLCJtdWx0aXBsaWVyIiwiaXNEcmF3aW5nTW9kZSIsInBhbm5pbmciLCJmcmVlRHJhd2luZ0JydXNoIiwiUGVuY2lsQnJ1c2hDIiwiQ2FudmFzIiwic2VsZWN0aW9uIiwiZW5hYmxlUmV0aW5hU2NhbGluZyIsInByZXNlcnZlT2JqZWN0U3RhY2tpbmciLCJ1cHBlckNhbnZhc0VsIiwibG93ZXJDYW52YXNFbCIsImUiLCJpc1dvcmtTcGFjZUJvcmRlciIsIl9wYW5uaW5nRG93biIsInRvdWNoZXMiLCJldnQiLCJjaGFuZ2VkVG91Y2hlcyIsIl9wYW5feDAiLCJsYXllclgiLCJwYWdlWCIsIl9wYW5feTAiLCJsYXllclkiLCJwYWdlWSIsImFjdGl2ZSIsIm1vdmUiLCJyZWxhdGl2ZVBhbiIsIm9iaiIsInciLCJoIiwicyIsInN0YXRlIiwidmlzaWJsZSIsImRlc3Ryb3kiLCJzdGVwWCIsInN0ZXBZIiwiR3JvdXAiLCJoYXNDb250cm9scyIsImVuYWJsZSIsInJ1bGVyIiwiTGluZSIsIndvcmtzcGFjZUdyaWQiLCJ3b3Jrc3BhY2VSdWxlciIsIm51bWJlciIsImRldmljZVBpeGVsUmF0aW8iLCJfdXBkYXRlIiwiQm9vbGVhbiIsImRlYWN0aXZhdGUiLCJJdGVtcyIsIl9faXRlbSIsImxvY2FsSXRlbSIsInBhdGhzIiwiZ2V0SXRlbUJ5VVVJRCIsImVubGl2ZW5PYmplY3RzIiwib3JpZ1JlbmRlck9uQWRkUmVtb3ZlIiwicmVuZGVyT25BZGRSZW1vdmUiLCJsb2FkU1ZHRnJvbVVSTCIsImxvYWRlZE9iamVjdCIsImdyb3VwU1ZHRWxlbWVudHMiLCJ0cmlnZ2VyQ3JlYXRlZCIsImZyb21VUkwiLCJvSW1nIiwidHh0IiwiYXNzaWduIiwiZm9udFNpemUiLCJmb250U3R5bGUiLCJmb250V2VpZ2h0IiwidGV4dEFsaWduIiwidmVydGljYWwiLCJ0ZXh0IiwiSVRleHQiLCJzZXRBY3RpdmVPYmplY3QiLCJjbGVhbiIsIkVyYXNlciIsIkNyYXlvbkJydXNoIiwiSW5rQnJ1c2giLCJNYXJrZXJCcnVzaCIsIlNwcmF5QnJ1c2giLCJDdXN0b21CcnVzaCIsIkphcGFuZXNlQnJ1c2giLCJmaW5hbGl6ZSIsIl9vIiwiY2hhbmdlQ29sb3IiLCJJdGVtIiwic2NhbGUiLCJicnVzaCIsInNldEFuZ2xlIiwicGFyc2VJbnQiLCJfcG9zaXRpb24iLCJhbmltYXRlIiwib25DaGFuZ2UiLCJmaWx0ZXIiLCJmaWx0ZXJzIiwiVGludCIsImFwcGx5RmlsdGVycyIsInNldENvbG9yIiwic2V0T3BhY2l0eSIsIk51bWJlciIsImdldEZvbnRGYW1pbHkiLCJzZXRGb250RmFtaWx5IiwiX2luaXREaW1lbnNpb25zIiwiZ2V0Rm9udFN0eWxlIiwic2V0Rm9udFN0eWxlIiwiZ2V0Rm9udFdlaWdodCIsInNldEZvbnRXZWlnaHQiLCJnZXRGb250U2l6ZSIsInNldEZvbnRTaXplIiwiZ2V0VGV4dEFsaWduIiwic2V0VGV4dEFsaWduIiwiZ2V0VGV4dCIsInNldFRleHQiLCJkaXN0YW5jZSIsIkNvbG9yIiwidG9IZXgiLCJwYXRoIiwiX2ZpbGwiLCJfY29sb3IiLCJSZW1vdmVDb2xvciIsImVudGVyRWRpdGluZyIsImV4aXRFZGl0aW5nIiwiZ2VuZXJhdGUiLCJGdW5jdGlvbiIsIkxheWVycyIsImxpc3QiLCJvcHQiLCJxdWFsaXR5IiwiY2xpcHRvIiwiZ2V0Q2xpcFRvIiwic2V0Q2xpcFRvIiwiaW5kZXhlcyIsIl9nZXRJdGVtc0J5SW5kZXgiLCJuZXdJbmRleGVzIiwiYnJpbmdUb0Zyb250IiwiYnJpbmdGb3J3YXJkIiwic2VuZEJhY2t3YXJkcyIsIm9sZEluZGV4IiwiZGlmZiIsImkiLCJfYWN0aXZlIiwiY3Vyc29yIiwiQ2lyY2xlIiwicmFkaXVzIiwiZXZlbnRlZCIsInNoYWRvdyIsIlNoYWRvdyIsImxvY2tVbmlTY2FsaW5nIiwiZ2V0Q29sb3IiLCJweCIsImNvbnRleHRDb250YWluZXIiLCJnZXRJbWFnZURhdGEiLCJ2YWx1ZSIsInNldEZpbGwiLCJEcmF3SGlzdG9yeSIsImN1cnJlbnRJbmRleCIsInNsaWNlIiwiY3JlYXRlQ2xhc3MiLCJCYXNlQnJ1c2giLCJvbk1vdXNlRG93biIsInBvaW50ZXIiLCJvbk1vdXNlTW92ZSIsIm9uTW91c2VVcCIsInRhcmdldHMiLCJjb250YWluc1BvaW50IiwiaXNUYXJnZXRUcmFuc3BhcmVudCIsImdldFJhbmRvbSIsIm1heCIsIm1pbiIsImNsYW1wIiwibiIsInRyaW0iLCJjb250ZXh0IiwiY29weSIsImdldENvbnRleHQiLCJwaXhlbHMiLCJsIiwiYm91bmQiLCJyaWdodCIsImJvdHRvbSIsImltZyIsInRyaW1IZWlnaHQiLCJ0cmltV2lkdGgiLCJ0cmltbWVkIiwicHV0SW1hZ2VEYXRhIiwibW92ZWQiLCJvcmlnaW5hbFJlbmRlck9uQWRkUmVtb3ZlIiwidnQiLCJ2aWV3cG9ydFRyYW5zZm9ybSIsInJhc3RlciIsImNvbnRleHRUb3AiLCJjbGVhckNvbnRleHQiLCJfcmVzZXRTaGFkb3ciLCJhbmdsZUJldHdlZW4iLCJhdGFuMiIsIm5vcm1hbGl6ZSIsInRoaWNrbmVzcyIsImRpc3RhbmNlRnJvbSIsIlN0cm9rZSIsImlua0Ftb3VudCIsImxpbmVXaWR0aCIsIl9wb2ludCIsIl9sYXN0UG9pbnQiLCJfY3VycmVudExpbmVXaWR0aCIsInJhbmdlIiwicngiLCJjMCIsIngwIiwieTAiLCJsaW5lQ2FwIiwic3VidHJhY3RQb2ludCIsImFkZEVxdWFscyIsInBlciIsImRyYXciLCJzYXZlIiwibGluZSIsInJlc3RvcmUiLCJwb2ludDEiLCJwb2ludDIiLCJzdHJva2VTdHlsZSIsImxpbmVUbyIsIl9iYXNlV2lkdGgiLCJfbGluZVdpZHRoIiwibGluZUpvaW4iLCJfcmVuZGVyIiwibGluZVdpZHRoRGlmZiIsImxlbiIsInRyYW5zZm9ybSIsIl9pc0N1cnJlbnRseURyYXdpbmciLCJfaW5rQW1vdW50IiwiX2xhdGVzdFN0cm9rZUxlbmd0aCIsIl9zZXAiLCJyZW5kZXIiLCJwIiwiX2xhdGVzdCIsInNldEZyb21Qb2ludCIsImNhbGwiLCJzdWJ0cmFjdCIsImoiLCJzdGVwTnVtIiwiZG90U2l6ZSIsImRvdE51bSIsImNlaWwiLCJmbG9vciIsImZpbGxTdHlsZSIsIm11bHRpcGx5IiwiX3JhbmdlIiwiX3N0cm9rZUNvdW50IiwiX3N0cm9rZUlkIiwiX3N0cm9rZU51bSIsIl9zdHJva2VzIiwic3Ryb2tlcyIsInNldFBvaW50ZXIiLCJkcmF3U3BsYXNoIiwiX3Jlc2V0VGlwIiwiRGF0ZSIsIm1heFNpemUiLCJudW0iLCJfZHJpcHMiLCJfZHJpcFRocmVzaG9sZCIsIl9pbnRlcnZhbCIsInNwcmF5QnJ1c2hEYXRhVXJsIiwiX3Jlc2V0IiwidG9SZ2JhIiwiZXhlYyIsInNldFRpbWVvdXQiLCJhbW91bnQiLCJnbG9iYWxBbHBoYSIsInBvdyIsIl9lbGVtZW50IiwiZGlzdCIsIm1pbldpZHRoIiwiSmFwYW5lc2VCcnVzaEJhc2U2NCIsInBvaW50cyIsInZlbG9jaXR5RmlsdGVyV2VpZ2h0IiwiX2xhc3RWZWxvY2l0eSIsIl9sYXN0V2lkdGgiLCJfc3Ryb2tlVXBkYXRlIiwiY2FuRHJhd0N1cnZlIiwiX2RyYXdQb2ludCIsIl9hZGRQb2ludCIsIl9wb2ludHMiLCJjMiIsImMzIiwiY3VydmUiLCJ0bXAiLCJ1bnNoaWZ0IiwiX2NhbGN1bGF0ZUN1cnZlQ29udHJvbFBvaW50cyIsImMxIiwiQmV6aWVyIiwiX2FkZEN1cnZlIiwic2hpZnQiLCJzMSIsInMyIiwiczMiLCJkeDEiLCJkeTEiLCJkeDIiLCJkeTIiLCJtMSIsIm0yIiwibDEiLCJzcXJ0IiwibDIiLCJkeG0iLCJkeW0iLCJrIiwidHgiLCJ0eSIsInN0YXJ0UG9pbnQiLCJlbmRQb2ludCIsInZlbG9jaXR5IiwibmV3V2lkdGgiLCJ2ZWxvY2l0eUZyb20iLCJfc3Ryb2tlV2lkdGgiLCJfZHJhd0N1cnZlIiwic3RhcnRXaWR0aCIsImVuZFdpZHRoIiwid2lkdGhEZWx0YSIsImRyYXdTdGVwcyIsInQiLCJ0dCIsInR0dCIsInUiLCJ1dSIsInV1dSIsImNvbnRyb2wxIiwiY29udHJvbDIiLCJjbG9zZVBhdGgiLCJ0aW1lIiwiZ2V0VGltZSIsInN0YXJ0IiwiZGlzdGFuY2VUbyIsInN0ZXBzIiwiY3giLCJjeSIsInB5IiwieGRpZmYiLCJ5ZGlmZiIsImVuZCIsIkJhc2VGaWx0ZXIiLCJhcHBseVRvIiwiY2FudmFzRWwiLCJpbWFnZURhdGEiLCJ0aHJlc2hvbGQiLCJsaW1pdCIsImciLCJiIiwiYWJzIiwiX3NvdXJjZSIsImNhbGxTdXBlciIsImZyb21PYmplY3QiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7O0FDdENBOzs7Ozs7QUFFQUEsUUFBT0MsT0FBUCxzQjs7Ozs7Ozs7Ozs7O0FDRUE7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7O0FBRUE7Ozs7QUFDQTs7OztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUVBOzs7Ozs7QUE3QkEsS0FBSSxDQUFDQyxPQUFPQyxjQUFaLEVBQTRCO0FBQzFCQyxHQUFBLG1CQUFBQSxDQUFRLEVBQVI7QUFDRDs7QUE2QkQ7OztBQUdBLEtBQUlDLFdBQVc7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U0FBUyw2QkFBNkI7QUFDbkQsY0FBYSxTQUFTLCtCQUErQjtBQUNyRCxjQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTs7QUFFQSxFQUFDOzs7QUFHRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7O0FBR0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQWtELEVBQUU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBcUI7QUFDckIsMEJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQixlQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixtQkFBbUI7QUFDdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUMsS0FBSztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhEQUE2RCxPQUFPO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyREFBMEQsT0FBTztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQixFQUFFOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFlBQVk7QUFDekIsY0FBYSxTQUFTO0FBQ3RCO0FBQ0EsY0FBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZ0U7QUFDaEUsTUFBSzs7QUFFTDtBQUNBLGtDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxZQUFZO0FBQzNCLGlCQUFnQixPQUFPLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsRUFBRSxtQkFBbUI7O0FBRS9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsV0FBVztBQUMxQixnQkFBZSxNQUFNO0FBQ3JCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQThCLEVBQUU7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTyxHQUFHLEVBQUU7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLFNBQVM7QUFDeEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxXQUFXO0FBQzFCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQSxxQkFBb0IsRUFBRTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCLE1BQU07QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxZQUFZO0FBQzNCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQixFQUFFOztBQUV4QjtBQUNBLDJDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF3QyxJQUFJLFVBQVU7QUFDdEQsMkNBQTBDLG9CQUFvQixFQUFFO0FBQ2hFOztBQUVBLGtEQUFpRCxJQUFJLEtBQUs7QUFDMUQsMEJBQXlCLEVBQUU7QUFDM0IsMERBQXlELG1CQUFtQjs7QUFFNUUsMkRBQTBELFNBQVM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWCxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFNBQVM7QUFDeEIsZ0JBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFNBQVM7QUFDeEIsZ0JBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsSUFBRzs7QUFFSCxFQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBLG1EQUFrRCxFQUFFOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsT0FBTztBQUNwQixlQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsYUFBYTtBQUM1QixpQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxhQUFhO0FBQzVCLGlCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixpQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxhQUFhO0FBQzVCLGlCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLGFBQWE7QUFDNUIsaUJBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixpQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixpQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixpQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxhQUFhO0FBQzVCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxhQUFhO0FBQzVCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxhQUFhO0FBQzVCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBO0FBQ0EsZ0JBQWUsYUFBYTtBQUM1QixpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsYUFBYTtBQUM1QixpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsYUFBYTtBQUM1QixnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLGFBQWE7QUFDNUIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxhQUFhO0FBQzVCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxhQUFhO0FBQzVCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxhQUFhO0FBQzVCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7O0FBR0Q7O0FBRUE7O0FBRUE7QUFDQSxtREFBa0QsRUFBRTs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLGFBQWE7QUFDNUIsaUJBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQixpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxhQUFhO0FBQzFCLGNBQWEsYUFBYTtBQUMxQixjQUFhLGFBQWE7QUFDMUIsY0FBYSxhQUFhO0FBQzFCLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsYUFBYTtBQUMxQixjQUFhLGFBQWE7QUFDMUIsY0FBYSxNQUFNO0FBQ25CLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE1BQU07QUFDbkIsY0FBYSxNQUFNO0FBQ25CLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxNQUFNO0FBQ25CLGNBQWEsYUFBYTtBQUMxQixjQUFhLGFBQWE7QUFDMUIsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDOzs7QUFHRDs7QUFFQTs7QUFFQSxtREFBa0QsRUFBRTs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFxQixtQkFBbUI7QUFDeEMsT0FBTSxtQkFBbUIsNENBQTRDLG1CQUFtQjtBQUN4RjtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGVBQWMsYUFBYTtBQUMzQixpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixpQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0EsZ0JBQWUsVUFBVTs7QUFFekI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSw4RUFBNkU7QUFDN0UsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSwyRUFBMEU7QUFDMUUsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsb0JBQW9CO0FBQ25DLGlCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBcUIsT0FBTztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBd0MsSUFBSSx5QkFBeUIsSUFBSSx5QkFBeUIsSUFBSTs7QUFFdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXdDLElBQUksWUFBWSxJQUFJLGNBQWMsSUFBSTs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUU7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsT0FBTztBQUNwQixjQUFhLE9BQU87QUFDcEIsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQixlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGVBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEIsZUFBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQjtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQixlQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEIsZUFBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEIsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGVBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxNQUFNO0FBQ25CLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUEyQzs7QUFFM0M7QUFDQTtBQUNBOztBQUVBLHlDQUF3QyxLQUFLOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEIsWUFBVyxpQ0FBaUM7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBLDhCQUE2QixFQUFFOztBQUUvQixxQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQixpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBcUQsaURBQWlEO0FBQ3RHO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUseUJBQXlCO0FBQ3hDLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0EsZ0JBQWUsbUJBQW1CO0FBQ2xDLGdCQUFlLGNBQWM7QUFDN0IsaUJBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF1QyxLQUFLO0FBQzVDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBLGlCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsOEJBQTZCLEVBQUU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWCxZQUFXO0FBQ1gsWUFBVyxnQ0FBZ0M7QUFDM0M7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFNBQVM7QUFDeEIsaUJBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBLDhCQUE2QixFQUFFOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxjQUFjO0FBQzdCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLHlCQUF5QjtBQUN4QyxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsRUFBQzs7O0FBR0Q7O0FBRUE7O0FBRUEsbURBQWtELEVBQUU7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYLFlBQVcsK0JBQStCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxjQUFjO0FBQzdCLGlCQUFnQixjQUFjO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsY0FBYztBQUM3QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsbUNBQW1DO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixFQUFFOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDOzs7QUFHRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1gsWUFBVyxxQ0FBcUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLHFCQUFxQixRQUFRO0FBQzVDLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBLDhCQUE2QixFQUFFOztBQUUvQjtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLDJCQUEwQiw2Q0FBNkM7QUFDdkUsZUFBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTBCLDZDQUE2QztBQUN2RTtBQUNBO0FBQ0EsYUFBWSwyQkFBMkIsR0FBRyx5QkFBeUIsTUFBTSwwQkFBMEI7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEwQjtBQUMxQjtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEwQiwwQ0FBMEM7QUFDcEU7QUFDQTtBQUNBLGFBQVksd0JBQXdCLE1BQU0sdUJBQXVCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMEIsNEJBQTRCLEdBQUcsaUNBQWlDLE1BQU0sK0JBQStCO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxxQkFBcUIsUUFBUTtBQUM1QyxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSxjQUFhLHFEQUFxRDtBQUNsRSxnQkFBZSxzQkFBc0I7QUFDckMsZ0JBQWUsU0FBUztBQUN4QixnQkFBZSxPQUFPLDRDQUE0QyxpQ0FBaUM7QUFDbkcsaUJBQWdCLGNBQWM7QUFDOUI7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQSxvQkFBbUIsNEVBQTRFO0FBQy9GO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0EsY0FBYSwyREFBMkQ7QUFDeEUsZ0JBQWUsc0JBQXNCO0FBQ3JDLGdCQUFlLFNBQVM7QUFDeEIsZ0JBQWUsT0FBTyw0Q0FBNEMsb0NBQW9DO0FBQ3RHLGlCQUFnQixjQUFjO0FBQzlCO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0Esb0JBQW1CLDRFQUE0RTtBQUMvRjtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLGNBQWEsd0RBQXdEO0FBQ3JFLGdCQUFlLHdCQUF3QjtBQUN2QyxnQkFBZSxTQUFTO0FBQ3hCLGlCQUFnQixjQUFjO0FBQzlCO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSxjQUFhLDJEQUEyRDtBQUN4RSxnQkFBZSx3QkFBd0I7QUFDdkMsZ0JBQWUsU0FBUztBQUN4QixpQkFBZ0IsY0FBYztBQUM5QjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLE9BQU8sNEJBQTRCO0FBQ2xELFlBQVcsb0RBQW9EO0FBQy9ELGdCQUFlLDJCQUEyQjtBQUMxQyxnQkFBZSxTQUFTO0FBQ3hCLGdCQUFlLE9BQU8sNENBQTRDLHlCQUF5QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsT0FBTyw0QkFBNEI7QUFDbEQsWUFBVyxvREFBb0Q7QUFDL0QsZ0JBQWUscUJBQXFCO0FBQ3BDLGdCQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxjQUFjO0FBQzdCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxRQUFRO0FBQ3ZCLGlCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQyxlQUFlO0FBQ2hELE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLGNBQWM7QUFDN0IsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLFFBQVE7QUFDdkIsaUJBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDLGdCQUFnQjtBQUNqRCxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLGNBQWM7QUFDN0IsZ0JBQWUsY0FBYztBQUM3QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsUUFBUTtBQUN2QixpQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixpQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckIsaUJBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxhQUFhO0FBQzVCLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixpQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsYUFBYTtBQUM1QixpQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLGFBQWE7QUFDNUIsaUJBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0Esb0JBQW1CO0FBQ25CLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUMsY0FBYztBQUMvQztBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBLG9DQUFtQyxjQUFjO0FBQ2pEO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSx5QkFBeUI7QUFDeEMsaUJBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxpQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLHlCQUF5QjtBQUN4QyxnQkFBZSxNQUFNO0FBQ3JCLGlCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLHlCQUF5QjtBQUN4QyxnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSwrQ0FBOEMsWUFBWTtBQUMxRDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUseUJBQXlCO0FBQ3hDLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUseUJBQXlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLHlCQUF5QjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsY0FBYztBQUM3QixpQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLGNBQWM7QUFDN0IsaUJBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLGNBQWM7QUFDN0IsaUJBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLGNBQWM7QUFDN0IsaUJBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLGNBQWM7QUFDN0IsaUJBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxjQUFjO0FBQzdCLGlCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUF5QyxnQ0FBZ0M7QUFDekUsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsY0FBYztBQUM3QixnQkFBZSxhQUFhO0FBQzVCLGlCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1AsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxTQUFTO0FBQ3hCLGlCQUFnQixPQUFPO0FBQ3ZCLG1CQUFrQjtBQUNsQixjQUFhO0FBQ2I7QUFDQTtBQUNBLG1FQUFrRTtBQUNsRSxnQ0FBK0IsdUJBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQSxnQ0FBK0IsdUJBQXVCO0FBQ3REO0FBQ0E7QUFDQSxpREFBZ0Qsc0JBQXNCLHdCQUF3Qix1QkFBdUI7QUFDckgsU0FBUTtBQUNSO0FBQ0E7QUFDQSw4QkFBNkIsRUFBRTs7QUFFL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxvQ0FBbUMsRUFBRTtBQUNyQztBQUNBOztBQUVBLDRDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTJCO0FBQzNCLDJDQUEwQztBQUMxQyxtREFBa0Q7QUFDbEQsaUJBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXdFLFNBQVM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxjQUFjO0FBQzdCLGlCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCLEtBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLGNBQWM7QUFDN0IsaUJBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsY0FBYztBQUM3QixnQkFBZSxRQUFRO0FBQ3ZCLGlCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOEJBQTZCLFFBQVE7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxjQUFjO0FBQzdCLGdCQUFlLFFBQVE7QUFDdkIsaUJBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQTZCLEtBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOEJBQTZCLDBCQUEwQjs7QUFFdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLGNBQWM7QUFDN0IsZ0JBQWUsT0FBTztBQUN0QixpQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxpQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLDRDQUE0QztBQUM3RDtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0IscUNBQXFDOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQSxpQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYSxNQUFNO0FBQ25CLGVBQWMsT0FBTztBQUNyQixpQkFBZ0I7QUFDaEIsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWEsY0FBYztBQUMzQixlQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7QUFHRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLGNBQWM7QUFDN0IsaUJBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF3QyxhQUFhO0FBQ3JEO0FBQ0EsSUFBRztBQUNILEVBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFhLGNBQWM7QUFDM0IsZUFBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0EsNENBQTJDLHVDQUF1QztBQUNsRjs7QUFFQTtBQUNBLHVDQUFzQyxjQUFjOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQSxjQUFhLE9BQU87QUFDcEIsZUFBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFhLGNBQWM7QUFDM0IsZUFBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0RBQW1ELFVBQVU7QUFDN0Q7O0FBRUEsZ0RBQStDLFVBQVU7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBeUMsdUNBQXVDO0FBQ2hGOztBQUVBO0FBQ0EsdUNBQXNDLGNBQWM7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYSxNQUFNO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQSx3QkFBdUIsRUFBRTs7QUFFekIsd0NBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdEQUF1RCxTQUFTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW1CLGtCQUFrQjs7QUFFckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxFQUFDOzs7QUFHRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEIsWUFBVywrQkFBK0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxxQkFBcUIsUUFBUTtBQUM1QyxnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQSw4QkFBNkIsRUFBRTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBc0QsWUFBWTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxpQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLGNBQWM7QUFDN0IsZ0JBQWUsT0FBTztBQUN0QixpQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsY0FBYztBQUM3QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEI7QUFDQSxpQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxpQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxpQkFBZ0IsUUFBUTtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLGdCQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLHlCQUF5QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQW9DLG9DQUFvQztBQUN4RTtBQUNBO0FBQ0Esb0NBQW1DLHVCQUF1QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDLG9DQUFvQztBQUNwRTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsUUFBUTtBQUN2QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLG9CQUFtQjtBQUNuQixpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLGNBQWM7QUFDN0IsZ0JBQWUsTUFBTTtBQUNyQixpQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQW9DLHVCQUF1QjtBQUMzRCxnQ0FBK0IsT0FBTztBQUN0QztBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBK0MsY0FBYztBQUM3RDtBQUNBLHlDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckIsaUJBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsNkJBQTZCO0FBQzFFO0FBQ0EsdUNBQXNDLE9BQU87QUFDN0Msd0RBQXVELE9BQU87QUFDOUQ7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLGFBQWE7QUFDNUIsZ0JBQWUsTUFBTTtBQUNyQixpQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDLHNCQUFzQjtBQUM1RCxpQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxpQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxrQkFBa0I7QUFDL0Q7QUFDQSx1Q0FBc0MsT0FBTztBQUM3QztBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUErQyw0Q0FBNEM7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EseUNBQXdDLDZCQUE2QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxpQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSx5QkFBeUI7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxjQUFjO0FBQzdCLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0RBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7QUFHRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EsK0JBQThCLHVCQUF1QjtBQUNyRDtBQUNBLDBDQUF5QyxPQUFPO0FBQ2hELE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDLHFCQUFxQjtBQUN0RDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxjQUFjO0FBQzdCLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esc0JBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXNDLGlCQUFpQjtBQUN2RDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdC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O0FBQ0E7O0FBRUE7QUFDQSw2SEFBNEg7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrSEFBOEg7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsNkJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUIsaUNBQWlDO0FBQzFEO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxhQUFhO0FBQzVCLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLFFBQVE7QUFDdkIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixpQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUSxNQUFNOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSx5QkFBeUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGNBQWEscURBQXFEO0FBQ2xFLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLHFCQUFxQixFQUFFO0FBQ25FLFFBQU87QUFDUDtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsU0FBUztBQUN4QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNERBQTJELFNBQVM7QUFDcEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQTZDLFVBQVU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBcUQsVUFBVTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBNkMsU0FBUzs7QUFFdEQ7O0FBRUEsOEJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQixjQUFhLFNBQVM7QUFDdEIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsV0FBVztBQUN4QixjQUFhLFNBQVM7QUFDdEIs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ZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsa0JBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxFQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMEI7O0FBRTFCO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLElBQUc7O0FBRUg7QUFDQTtBQUNBLGNBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGNBQWEsTUFBTTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGNBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0RBQXFELGVBQWU7QUFDcEUsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQXlDLFNBQVM7QUFDbEQscUVBQW9FOztBQUVwRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNB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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLG1EQUFtRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSx5QkFBd0IsUUFBUTtBQUNoQztBQUNBLHNCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxz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RUE7QUFDQTtBQUNBO0FBQ0EsU0FBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxTQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQSxTQUFRLFVBQVU7O0FBRWxCO0FBQ0E7Ozs7Ozs7QUNuRkEsa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7Ozs7Ozs7QUNKQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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O0FBQ0E7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQSxHQUFFO0FBQ0Y7QUFDQSxHQUFFO0FBQ0Y7QUFDQSxHQUFFO0FBQ0Y7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLDRDQUEyQztBQUMzQyxLQUFJO0FBQ0osSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0gsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDclNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBd0MsZUFBZSxJQUFJO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CLG9CQUFvQjtBQUN4Qzs7QUFFQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDckxBO0FBQ0E7QUFDQSxvQ0FBa0M7QUFDbEMsSUFBRztBQUNILEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRztBQUNILHFCQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDN1NBOzs7Ozs7O0FDQUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUcsYUFBYTtBQUNoQjtBQUNBO0FBQ0EsRUFBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsTUFBSztBQUNMLElBQUc7QUFDSCxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSCxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQWtEOztBQUVsRDs7QUFFQSw0Q0FBMkM7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBbUQ7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQW9DOztBQUVwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFEQUFvRDtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7O0FDemlCQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDcERBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUEsTUFBSztBQUNMO0FBQ0E7O0FBRUEsTUFBSztBQUNMO0FBQ0E7O0FBRUEsTUFBSztBQUNMO0FBQ0E7O0FBRUEsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7Ozs7QUN6TEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3pHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsT0FBTztBQUNsQixjQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbEVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQSxFOzs7Ozs7QUMxRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRyxhQUFhO0FBQ2hCO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTJFLDZFQUE2RTtBQUN4SjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLHVEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUEyRDtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnREFBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFtQixTQUFTO0FBQzVCO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZFQUE0RTs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW1EO0FBQ25EO0FBQ0Esb0RBQW1ELGlFQUFpRTtBQUNwSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF1QztBQUN2QyxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF1QztBQUN2QyxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7OztBQzU2QkEsZ0I7Ozs7OztBQ0FBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZTtBQUNmLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUSxPQUFPO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDNU5BOzs7Ozs7O0FDQUE7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQyxZQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLLEVBQUU7QUFDUCxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsRTs7Ozs7O0FDckxBOzs7Ozs7O0FDQUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDekJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7Ozs7OztBQzFCQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFtQixzQkFBc0I7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQzs7Ozs7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEIscUJBQW9CLHVCQUF1QixTQUFTLElBQUk7QUFDeEQsSUFBRztBQUNILEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVB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O0FDcEZBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF3QixtRUFBbUU7QUFDM0YsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxVOzs7Ozs7QUNYRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsTUFBSztBQUNMLElBQUc7QUFDSCxFOzs7Ozs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckIsMkJBQTBCO0FBQzFCO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRzs7Ozs7O0FDbEZBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE0QixtRUFBbUU7QUFDL0YsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxxQjs7Ozs7O0FDWEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEVBQTZFLDBCQUEwQjs7QUFFdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0EsNEZBQTJGO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEVBQUM7O0FBRUQsd0M7Ozs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPLFdBQVc7QUFDbEI7QUFDQTtBQUNBLFFBQU8sVUFBVTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU8sV0FBVztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxRQUFPLFdBQVc7QUFDbEI7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUF5QixnQkFBZ0IsdUJBQXVCLEdBQUc7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsV0FBVztBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFD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OztBQ1ZEO0FBQ0E7O0FBRUEsZ0NBQStCLGtDQUFnQyxFOzs7Ozs7QUNIL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDZkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUErQixTQUFTLEU7Ozs7OztBQzlCeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ2REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRCxzQzs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ1REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUNURDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ1REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsZTs7Ozs7O0FDTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxhOzs7Ozs7QUNORDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBRUEsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRSxFOzs7Ozs7QUNkRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWM7QUFDZDtBQUNBLEdBQUUsRTs7Ozs7O0FDaEJGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWM7QUFDZDtBQUNBLEdBQUUsRTs7Ozs7O0FDbEJGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWM7QUFDZDtBQUNBO0FBQ0EsR0FBRSxFOzs7Ozs7QUNSRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFjO0FBQ2Q7QUFDQSxHQUFFLEU7Ozs7OztBQ1BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWM7QUFDZDtBQUNBLEdBQUUsRTs7Ozs7O0FDZkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBYztBQUNkO0FBQ0E7QUFDQSxHQUFFLEU7Ozs7OztBQ1JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRSxFOzs7Ozs7QUNkRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ1hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVB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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQXlEO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EseUNBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLCtDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0EsK0NBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0EsK0NBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzFxQkE7QUFDQSx3RDs7Ozs7O0FDREE7QUFDQTtBQUNBLDBEQUF1RDs7QUFFdkQsK0JBQThCLDRCQUE0QixnQkFBZ0IsR0FBRzs7Ozs7OztBQ0o3RTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRyIsImZpbGUiOiJkcmF3dG9vbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkRyYXdUb29sXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkRyYXdUb29sXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDdiYjliYzliMDg3MTlhMjJmMWIyIiwiaW1wb3J0IERyYXdUb29sIGZyb20gJy4vZHJhd1Rvb2wvRHJhd1Rvb2wnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERyYXdUb29sO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2luZGV4LmpzIiwiaWYgKCFnbG9iYWwuX2JhYmVsUG9seWZpbGwpIHtcbiAgcmVxdWlyZSgnYmFiZWwtcG9seWZpbGwnKTtcbn1cblxuaW1wb3J0ICcuL2RlZmF1bHRQYXJhbXNTZXQnO1xuaW1wb3J0IGZvbnRMb2FkZXIgZnJvbSAnLi91dGlscy9mb250TG9hZGVyJztcbmltcG9ydCBlcnJvcnMgZnJvbSAnLi91dGlscy9lcnJvcnMnO1xuaW1wb3J0IGVzY2FwZUpTT04gZnJvbSAnLi91dGlscy9lc2NhcGVKU09OJztcblxuaW1wb3J0ICcuL3V0aWxzL2ZhYnJpYy51dWlkJztcblxuaW1wb3J0IFNpZGVzIGZyb20gJy4vU2lkZXMnO1xuaW1wb3J0IERyYXdIaXN0b3J5IGZyb20gJy4vRHJhd0hpc3RvcnknO1xuXG5pbXBvcnQgJy4vRXJhc2VyJztcbmltcG9ydCAnLi9icnVzaGVzL3V0aWwvdXRpbC5leHRlbmQnO1xuaW1wb3J0ICcuL2JydXNoZXMvdXRpbC9iYXNlQnJ1c2guZXh0ZW5kJztcbmltcG9ydCAnLi9icnVzaGVzL3V0aWwvcG9pbnQuZXh0ZW5kJztcbmltcG9ydCAnLi9icnVzaGVzL2JydXNoZXMvc3Ryb2tlJztcbmltcG9ydCAnLi9icnVzaGVzL2JydXNoZXMvcGVuY2lsQnJ1c2gnO1xuaW1wb3J0ICcuL2JydXNoZXMvYnJ1c2hlcy9jcmF5b25CcnVzaCc7XG5pbXBvcnQgJy4vYnJ1c2hlcy9icnVzaGVzL2lua0JydXNoJztcbmltcG9ydCAnLi9icnVzaGVzL2JydXNoZXMvc3ByYXlCcnVzaCc7XG5pbXBvcnQgJy4vYnJ1c2hlcy9icnVzaGVzL21hcmtlckJydXNoJztcbmltcG9ydCAnLi9icnVzaGVzL2JydXNoZXMvY3VzdG9tQnJ1c2gnO1xuaW1wb3J0ICcuL2JydXNoZXMvYnJ1c2hlcy9qYXBhbmVzZUJydXNoJztcblxuaW1wb3J0ICcuL3V0aWxzL3JlbW92ZUNvbG9yJztcblxuaW1wb3J0IGRlZmF1bHRQYXJhbXMgZnJvbSAnLi9kYWZhdWx0UGFyYW1zJztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIERyYXdUb29sXG4gKi9cbmxldCBEcmF3VG9vbCA9IHtcblxuICAvKipcbiAgICogQHByb3BlcnR5IGVkaXRhYmxlXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEBtZW1iZXJPZiBEcmF3VG9vbFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGVkaXRhYmxlOiBmYWxzZSxcblxuICAvKipcbiAgICogQHByb3BlcnR5IENvbnRhaW5lclxuICAgKiBAZGVmYXVsdCBjb250YWluZXI6IHt0YXJnZXQ6IGRvY3VtZW50LmJvZHksIHNpemU6IHt3aWR0aDogZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCwgaGVpZ2h0OiBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodH19XG4gICAqIEBtZW1iZXJPZiBEcmF3VG9vbFxuICAgKiBAdHlwZSB7e3RhcmdldDogSFRNTEVsZW1lbnQsIHNpemU6IHt3aWR0aDogTnVtYmVyLCBoZWlnaHQ6IE51bWJlcn19fVxuICAgKi9cbiAgY29udGFpbmVyOiB7XG4gICAgdGFyZ2V0OiBkb2N1bWVudC5ib2R5LFxuICAgIHNpemU6IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgR3JpZCBTdGVwXG4gICAqIEBkZWZhdWx0IDEwXG4gICAqIEBtZW1iZXJPZiBEcmF3VG9vbFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ3JpZFN0ZXA6IDEwLFxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgR3JpZFxuICAgKiBAZGVmYXVsdCB7fVxuICAgKiBAbWVtYmVyT2YgRHJhd1Rvb2xcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGdyaWQ6IHtcbiAgICBjb2xvcjogJ3JnYmEoMTUwLCAxNTAsIDE1MCwgMC4xKScsXG4gICAgc3Ryb2tlV2lkdGg6IDFcbiAgfSxcblxuICBib3JkZXI6IHtcbiAgICBjb2xvcjogJ3JnYmEoMTAwLDIwMCwyMDAsMSknLFxuICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMTUwLCAxNTAsIDE1MCwgMC4xKScsXG4gICAgc3Ryb2tlRGFzaEFycmF5OiBbMCwgMF0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBDYWxsYmFja3NcbiAgICogQGRlZmF1bHQge31cbiAgICogQG1lbWJlck9mIERyYXdUb29sXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2FsbGJhY2tzOiB7fSxcblxuICAvKipcbiAgICogQHByb3BlcnR5IFNpZGVzXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQG1lbWJlck9mIERyYXdUb29sXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzaWRlczogbnVsbCxcblxuICBfZXZlbnRlZDogdHJ1ZSxcbiAgXG4gIF9fZGF0YToge30sXG5cbiAgLyoqXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlck9mIERyYXdUb29sXG4gICAqIEBwYXJhbSB0YXJnZXQge0hUTUxFbGVtZW50fSB0YXJnZXQgY29udGFpbmVyXG4gICAqIEBwYXJhbSBzaXplIHtPYmplY3R9IFNpemUgb2YgY2FudmFzXG4gICAqIEBwYXJhbSBzaXplLndpZHRoIHtOdW1iZXJ9IFdpZHRoIG9mIGNhbnZhc1xuICAgKiBAcGFyYW0gc2l6ZS5oZWlnaHQge051bWJlcn0gaGVpZ2h0IG9mIGNhbnZhc1xuICAgKi9cbiAgaW5pdGlhbGl6ZSh0YXJnZXQsIHNpemUpIHtcblxuICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICAgdGhyb3cgKCBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoe2Vycm9yOiBlcnJvcnMuSFRNTEVsZW1lbnRVbmRlZmluZWR9KSkgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgX3RhcmdldCA9IHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnalF1ZXJ5JykgJiYgdGFyZ2V0IGluc3RhbmNlb2YgalF1ZXJ5ID8gdGFyZ2V0WzBdIDogdGFyZ2V0O1xuXG4gICAgbGV0IF9zaXplID0gc2l6ZSB8fCB7fTtcblxuICAgIHRoaXMuY29udGFpbmVyID0ge1xuICAgICAgdGFyZ2V0OiBfdGFyZ2V0LFxuICAgICAgc2l6ZTogX3NpemVcbiAgICB9O1xuXG4gICAgdGhpcy5jb250YWluZXIudGFyZ2V0LnRleHRDb250ZW50ID0gJyc7XG4gICAgdGhpcy5jb250YWluZXIudGFyZ2V0LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcblxuICAgIHRoaXMuc2lkZXMgPSBuZXcgU2lkZXMoKTtcblxuICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBEcmF3SGlzdG9yeSgpO1xuXG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCBzaWRlcyBlZGl0YWJsZVxuICAgKiBAbWVtYmVyT2YgRHJhd1Rvb2xcbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0gdmFsIHtCb29sZWFufSBkZWZhdWx0OiB0cnVlXG4gICAqL1xuICBzZXRFZGl0YWJsZSh2YWwgPSB0cnVlKSB7XG4gICAgdGhpcy5lZGl0YWJsZSA9IHZhbDtcblxuICAgIHRoaXMuc2lkZXMuX2NvbGxlY3Rpb24uZm9yRWFjaCgoc2lkZSkgPT4ge1xuICAgICAgaWYoc2lkZS5GYWJyaWNCb3JkZXIpIHtcbiAgICAgICAgc2lkZS5GYWJyaWNCb3JkZXIuc2V0KCdzZWxlY3RhYmxlJywgdGhpcy5lZGl0YWJsZSk7XG4gICAgICAgIHNpZGUuRmFicmljQ2FudmFzLmRlYWN0aXZhdGVBbGwoKS5yZW5kZXJBbGwoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkIGV2ZW50IGhhbmRsZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IGV2ZW50IG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBIYW5kbGVyIGZ1bmN0aW9uXG4gICAqL1xuICBvbihldmVudCwgaGFuZGxlcil7XG4gICAgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW107XG4gICAgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XS5wdXNoKGhhbmRsZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgZXZlbnQgaGFuZGxlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgZXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIEhhbmRsZXIgZnVuY3Rpb25cbiAgICovXG4gIG9mZihldmVudCwgaGFuZGxlcil7XG4gICAgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XS5kZWxldGUoaGFuZGxlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IGV2ZW50IG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICovXG4gIHRyaWdnZXIoZXZlbnQsIGRhdGEpe1xuICAgIFxuICAgIGlmKCF0aGlzLl9ldmVudGVkKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZihldmVudCA9PT0gJ2hpc3Rvcnk6dXBkYXRlJyl7XG4gICAgICB0aGlzLmhpc3RvcnkucHVzaFN0YXRlKGRhdGEuc2lkZS5pZCk7XG4gICAgICB0aGlzLnNpZGVzLmdldFNpZGUoZGF0YS5zaWRlLmlkKS5sYXllcnMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgaWYodHlwZW9mIHRoaXMuX2NhbGxiYWNrc1tldmVudF0gIT09ICd1bmRlZmluZWQnKSB7XG5cbiAgICAgIHRoaXMuX2NhbGxiYWNrc1tldmVudF0uZm9yRWFjaChjYiA9PiBjYihKU09OLnN0cmluZ2lmeShkYXRhKSkpO1xuXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBFeHBvcnQgcHJvZHVjdCBkYXRhXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGV4cG9ydEpTT04oKXtcbiAgICBsZXQgZGF0YSA9IHRoaXMuc2lkZXMuX2NvbGxlY3Rpb24ubWFwKHNpZGUgPT4gc2lkZS50b09iamVjdCgpKTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEltcG9ydCBwcm9kdWN0IGRhdGFcbiAgICogQHBhcmFtIHtTdHJpbmd9IGpzb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluaXRpYWxab29tXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwcm9wb3J0aW9uc1xuICAgKi9cbiAgaW1wb3J0SlNPTihqc29uLCBpbml0aWFsWm9vbSwgcHJvcG9ydGlvbnMgPSBkZWZhdWx0UGFyYW1zLnByb3BvcnRpb25zKXtcblxuICAgIGlmKHRoaXMuc2lkZXMuX2NvbGxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICB0aGlzLnNpZGVzLl9jb2xsZWN0aW9uLmZvckVhY2goKHNpZGUpID0+IHtcbiAgICAgICAgc2lkZS5pdGVtcy5maW5hbGl6ZUJydXNoKCk7XG4gICAgICAgIHRoaXMuX19kYXRhW3NpZGUuaWRdID0gc2lkZS50b0pTT04oKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zaWRlcy5lbXB0eSgpO1xuICAgICAgdGhpcy5oaXN0b3J5Lmhpc3RvcnkgPSB7fTtcbiAgICB9XG5cbiAgICBsZXQgZGF0YSA9IEpTT04ucGFyc2UoZXNjYXBlSlNPTihqc29uKSk7XG5cbiAgICBsZXQgcHJvbWlzZXMgPSBkYXRhLm1hcChzaWRlID0+IHtcbiAgICAgIGxldCBfc2lkZSA9IHRoaXMuc2lkZXMuYWRkU2lkZShzaWRlLmlkKTtcbiAgICAgIHJldHVybiBfc2lkZS5zZXRJbWFnZShgJHtzaWRlLmltYWdlVXJsfT9fYCwgc2lkZS5zaXplLmNtLCBwcm9wb3J0aW9ucywgc2lkZS5ib3JkZXIuY20pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4odmFsdWVzID0+IHtcbiAgICAgICAgdmFsdWVzLm1hcCgoZCwgaW5kZXgpID0+IHtcblxuICAgICAgICAgIGxldCBfc2lkZSA9IHRoaXMuc2lkZXMuZ2V0U2lkZShkLnNpZGUuaWQpO1xuXG4gICAgICAgICAgX3NpZGUuZGVmYXVsdFdvcmtzcGFjZVNpemUgPSBkYXRhW2luZGV4XS5ib3JkZXIucGl4ZWw7XG5cbiAgICAgICAgICBfc2lkZS5zZXRCb3JkZXIoZGF0YVtpbmRleF0uYm9yZGVyLmNtKTtcblxuICAgICAgICAgIGlmIChpbml0aWFsWm9vbSl7XG4gICAgICAgICAgICBfc2lkZS56b29tVG9WYWwoaW5pdGlhbFpvb20pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLl9fZGF0YVtfc2lkZS5pZF0pIHtcbiAgICAgICAgICAgIF9zaWRlLmZyb21KU09OKHRoaXMuX19kYXRhW19zaWRlLmlkXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3NpZGUuRmFicmljQ2FudmFzLnJlbmRlckFsbC5iaW5kKF9zaWRlLkZhYnJpY0NhbnZhcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBzZXQgY3VzdG9taXNlIGNvbnRyb2xzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjdXN0b21pc2VMaXN0XG4gICAqL1xuICBzZXRDdXN0b21pc2VDb250cm9scyhjdXN0b21pc2VMaXN0KSB7XG4gICAgbGV0IGlzVk1MID0gZnVuY3Rpb24oKSB7IHJldHVybiB0eXBlb2YgR192bWxDYW52YXNNYW5hZ2VyICE9PSAndW5kZWZpbmVkJyB9O1xuXG4gICAgZm9yKHZhciBrZXkgaW4gY3VzdG9taXNlTGlzdCl7XG4gICAgICBsZXQgaWNvbkltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSU1HJyk7XG4gICAgICBpY29uSW1hZ2Uuc3JjID0gY3VzdG9taXNlTGlzdFtrZXldLnNyYztcbiAgICB9XG5cbiAgICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCB7XG4gICAgICBfZHJhd0NvbnRyb2w6IGZ1bmN0aW9uKGNvbnRyb2wsIGN0eCwgbWV0aG9kTmFtZSwgbGVmdCwgdG9wKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0NvbnRyb2xWaXNpYmxlKGNvbnRyb2wpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaXplID0gdGhpcy5jb3JuZXJTaXplLCBzdHJva2UgPSAhdGhpcy50cmFuc3BhcmVudENvcm5lcnMgJiYgdGhpcy5jb3JuZXJTdHJva2VDb2xvcjtcbiAgICAgICAgaWYoY29udHJvbCBpbiBjdXN0b21pc2VMaXN0KSB7XG4gICAgICAgICAgbGV0IGljb25JbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpLFxuICAgICAgICAgICAgICB3aWR0aCA9IHNpemUsXG4gICAgICAgICAgICAgIGhlaWdodCA9IHNpemU7XG5cbiAgICAgICAgICBpc1ZNTCgpIHx8IHRoaXMudHJhbnNwYXJlbnRDb3JuZXJzIHx8IGN0eC5jbGVhclJlY3QobGVmdCwgdG9wLCBzaXplLCBzaXplKTtcblxuICAgICAgICAgIGlmKCdzaXplJyBpbiBjdXN0b21pc2VMaXN0W2NvbnRyb2xdKSB7XG4gICAgICAgICAgICB3aWR0aCA9IGN1c3RvbWlzZUxpc3RbY29udHJvbF0uc2l6ZS53aWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IGN1c3RvbWlzZUxpc3RbY29udHJvbF0uc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoJ29mZnNldCcgaW4gY3VzdG9taXNlTGlzdFtjb250cm9sXSkge1xuICAgICAgICAgICAgbGVmdCArPSBjdXN0b21pc2VMaXN0W2NvbnRyb2xdLm9mZnNldC54ICsgKCh0aGlzLmNvcm5lclNpemUgLSBjdXN0b21pc2VMaXN0W2NvbnRyb2xdLnNpemUud2lkdGgpIC8gMik7XG4gICAgICAgICAgICB0b3AgKz0gY3VzdG9taXNlTGlzdFtjb250cm9sXS5vZmZzZXQueSArICgodGhpcy5jb3JuZXJTaXplIC0gY3VzdG9taXNlTGlzdFtjb250cm9sXS5zaXplLmhlaWdodCkgLyAyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpY29uSW1hZ2Uuc3JjID0gY3VzdG9taXNlTGlzdFtjb250cm9sXS5zcmM7XG4gICAgICAgICAgY3R4LmRyYXdJbWFnZShpY29uSW1hZ2UsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpdGNoICh0aGlzLmNvcm5lclN0eWxlKSB7XG4gICAgICAgICAgICBjYXNlICdjaXJjbGUnOlxuICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgIGN0eC5hcmMobGVmdCArIHNpemUgLyAyLCB0b3AgKyBzaXplIC8gMiwgc2l6ZSAvIDIsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGN0eFttZXRob2ROYW1lXSgpO1xuICAgICAgICAgICAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgaXNWTUwoKSB8fCB0aGlzLnRyYW5zcGFyZW50Q29ybmVycyB8fCBjdHguY2xlYXJSZWN0KGxlZnQsIHRvcCwgc2l6ZSwgc2l6ZSk7XG4gICAgICAgICAgICAgIGN0eFttZXRob2ROYW1lICsgJ1JlY3QnXShsZWZ0LCB0b3AsIHNpemUsIHNpemUpO1xuICAgICAgICAgICAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVJlY3QobGVmdCwgdG9wLCBzaXplLCBzaXplKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9zZXRDb3JuZXJDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29vcmRzID0gdGhpcy5vQ29vcmRzLFxuICAgICAgICAgICAgbmV3VGhldGEgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKDQ1IC0gdGhpcy5hbmdsZSksXG4gICAgICAgICAgICBjb3JuZXJIeXBvdGVudXNlID0gdGhpcy5jb3JuZXJTaXplICogMC43MDcxMDYsXG4gICAgICAgICAgICBjb3NIYWxmT2Zmc2V0ID0gY29ybmVySHlwb3RlbnVzZSAqIE1hdGguY29zKG5ld1RoZXRhKSxcbiAgICAgICAgICAgIHNpbkhhbGZPZmZzZXQgPSBjb3JuZXJIeXBvdGVudXNlICogTWF0aC5zaW4obmV3VGhldGEpLFxuICAgICAgICAgICAgeCwgeTtcblxuICAgICAgICBmb3IgKHZhciBwb2ludCBpbiBjb29yZHMpIHtcbiAgICAgICAgICBsZXQgb2Zmc2V0ID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZihwb2ludCBpbiBjdXN0b21pc2VMaXN0ICYmIHR5cGVvZiBjdXN0b21pc2VMaXN0W3BvaW50XS5vZmZzZXQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG9mZnNldC54ID0gY3VzdG9taXNlTGlzdFtwb2ludF0ub2Zmc2V0Lng7XG4gICAgICAgICAgICBvZmZzZXQueSA9IGN1c3RvbWlzZUxpc3RbcG9pbnRdLm9mZnNldC55O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKHBvaW50IGluIGN1c3RvbWlzZUxpc3QgJiYgdHlwZW9mIGN1c3RvbWlzZUxpc3RbcG9pbnRdLnNpemUgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG9mZnNldC53aWR0aCA9ICh0aGlzLmNvcm5lclNpemUgLSBjdXN0b21pc2VMaXN0W3BvaW50XS5zaXplLndpZHRoKTtcbiAgICAgICAgICAgIG9mZnNldC5oZWlnaHQgPSAodGhpcy5jb3JuZXJTaXplIC0gY3VzdG9taXNlTGlzdFtwb2ludF0uc2l6ZS5oZWlnaHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHggPSBjb29yZHNbcG9pbnRdLnggKyBvZmZzZXQueCArIG9mZnNldC53aWR0aCAvIDI7XG4gICAgICAgICAgeSA9IGNvb3Jkc1twb2ludF0ueSArIG9mZnNldC55ICsgb2Zmc2V0LmhlaWdodCAvIDI7XG4gICAgICAgICAgY29vcmRzW3BvaW50XS5jb3JuZXIgPSB7XG4gICAgICAgICAgICB0bDoge1xuICAgICAgICAgICAgICB4OiB4IC0gc2luSGFsZk9mZnNldCxcbiAgICAgICAgICAgICAgeTogeSAtIGNvc0hhbGZPZmZzZXRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cjoge1xuICAgICAgICAgICAgICB4OiB4ICsgY29zSGFsZk9mZnNldCAtIG9mZnNldC53aWR0aCxcbiAgICAgICAgICAgICAgeTogeSAtIHNpbkhhbGZPZmZzZXRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBibDoge1xuICAgICAgICAgICAgICB4OiB4IC0gY29zSGFsZk9mZnNldCxcbiAgICAgICAgICAgICAgeTogeSArIHNpbkhhbGZPZmZzZXQgLSBvZmZzZXQuaGVpZ2h0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYnI6IHtcbiAgICAgICAgICAgICAgeDogeCArIHNpbkhhbGZPZmZzZXQgLSBvZmZzZXQud2lkdGgsXG4gICAgICAgICAgICAgIHk6IHkgKyBjb3NIYWxmT2Zmc2V0IC0gb2Zmc2V0LmhlaWdodFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSk7XG4gIH0sXG5cbiAgZm9udExvYWRlcjogZm9udExvYWRlcixcblxuICBmb250czoge31cblxufTtcblxuZXhwb3J0IGRlZmF1bHQgRHJhd1Rvb2w7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9kcmF3VG9vbC9EcmF3VG9vbC5qcyIsImltcG9ydCB7ZmFicmljfSBmcm9tICdmYWJyaWMnO1xuXG5pbXBvcnQgZGVmYXVsdFBhcmFtcyBmcm9tICcuL2RhZmF1bHRQYXJhbXMnO1xuXG5mYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jb3JuZXJTaXplID0gZGVmYXVsdFBhcmFtcy5jb3JuZXJTaXplO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RyYXdUb29sL2RlZmF1bHRQYXJhbXNTZXQuanMiLCIvKiBidWlsZDogYG5vZGUgYnVpbGQuanMgbW9kdWxlcz1BTEwgZXhjbHVkZT1qc29uLGdlc3R1cmVzIG1pbmlmaWVyPXVnbGlmeWpzYCAqL1xuIC8qISBGYWJyaWMuanMgQ29weXJpZ2h0IDIwMDgtMjAxNSwgUHJpbnRpbyAoSnVyaXkgWmF5dHNldiwgTWF4aW0gQ2hlcm55YWspICovXG5cbnZhciBmYWJyaWMgPSBmYWJyaWMgfHwgeyB2ZXJzaW9uOiBcIjEuNy4zXCIgfTtcbmlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZXhwb3J0cy5mYWJyaWMgPSBmYWJyaWM7XG59XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGZhYnJpYy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICBmYWJyaWMud2luZG93ID0gd2luZG93O1xuICAvLyBlbnN1cmUgZ2xvYmFsaXR5IGV2ZW4gaWYgZW50aXJlIGxpYnJhcnkgd2VyZSBmdW5jdGlvbiB3cmFwcGVkIChhcyBpbiBNZXRlb3IuanMgcGFja2FnaW5nIHN5c3RlbSlcbiAgd2luZG93LmZhYnJpYyA9IGZhYnJpYztcbn1cbmVsc2Uge1xuICAvLyBhc3N1bWUgd2UncmUgcnVubmluZyB1bmRlciBub2RlLmpzIHdoZW4gZG9jdW1lbnQvd2luZG93IGFyZSBub3QgcHJlc2VudFxuICBmYWJyaWMuZG9jdW1lbnQgPSByZXF1aXJlKFwianNkb21cIilcbiAgICAuanNkb20oXG4gICAgICBkZWNvZGVVUklDb21wb25lbnQoXCIlM0MhRE9DVFlQRSUyMGh0bWwlM0UlM0NodG1sJTNFJTNDaGVhZCUzRSUzQyUyRmhlYWQlM0UlM0Nib2R5JTNFJTNDJTJGYm9keSUzRSUzQyUyRmh0bWwlM0VcIilcbiAgICApO1xuXG4gIGlmIChmYWJyaWMuZG9jdW1lbnQuY3JlYXRlV2luZG93KSB7XG4gICAgZmFicmljLndpbmRvdyA9IGZhYnJpYy5kb2N1bWVudC5jcmVhdGVXaW5kb3coKTtcbiAgfSBlbHNlIHtcbiAgICBmYWJyaWMud2luZG93ID0gZmFicmljLmRvY3VtZW50LnBhcmVudFdpbmRvdztcbiAgfVxufVxuXG4vKipcbiAqIFRydWUgd2hlbiBpbiBlbnZpcm9ubWVudCB0aGF0IHN1cHBvcnRzIHRvdWNoIGV2ZW50c1xuICogQHR5cGUgYm9vbGVhblxuICovXG5mYWJyaWMuaXNUb3VjaFN1cHBvcnRlZCA9IFwib250b3VjaHN0YXJ0XCIgaW4gZmFicmljLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuLyoqXG4gKiBUcnVlIHdoZW4gaW4gZW52aXJvbm1lbnQgdGhhdCdzIHByb2JhYmx5IE5vZGUuanNcbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xuZmFicmljLmlzTGlrZWx5Tm9kZSA9IHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG5cbi8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbi8qKlxuICogQXR0cmlidXRlcyBwYXJzZWQgZnJvbSBhbGwgU1ZHIGVsZW1lbnRzXG4gKiBAdHlwZSBhcnJheVxuICovXG5mYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMgPSBbXG4gIFwiZGlzcGxheVwiLFxuICBcInRyYW5zZm9ybVwiLFxuICBcImZpbGxcIiwgXCJmaWxsLW9wYWNpdHlcIiwgXCJmaWxsLXJ1bGVcIixcbiAgXCJvcGFjaXR5XCIsXG4gIFwic3Ryb2tlXCIsIFwic3Ryb2tlLWRhc2hhcnJheVwiLCBcInN0cm9rZS1saW5lY2FwXCIsXG4gIFwic3Ryb2tlLWxpbmVqb2luXCIsIFwic3Ryb2tlLW1pdGVybGltaXRcIixcbiAgXCJzdHJva2Utb3BhY2l0eVwiLCBcInN0cm9rZS13aWR0aFwiLFxuICBcImlkXCJcbl07XG4vKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4vKipcbiAqIFBpeGVsIHBlciBJbmNoIGFzIGEgZGVmYXVsdCB2YWx1ZSBzZXQgdG8gOTYuIENhbiBiZSBjaGFuZ2VkIGZvciBtb3JlIHJlYWxpc3RpYyBjb252ZXJzaW9uLlxuICovXG5mYWJyaWMuRFBJID0gOTY7XG5mYWJyaWMucmVOdW0gPSAnKD86Wy0rXT8oPzpcXFxcZCt8XFxcXGQqXFxcXC5cXFxcZCspKD86ZVstK10/XFxcXGQrKT8pJztcbmZhYnJpYy5mb250UGF0aHMgPSB7IH07XG5cbi8qKlxuICogQ2FjaGUgT2JqZWN0IGZvciB3aWR0aHMgb2YgY2hhcnMgaW4gdGV4dCByZW5kZXJpbmcuXG4gKi9cbmZhYnJpYy5jaGFyV2lkdGhzQ2FjaGUgPSB7IH07XG5cbi8qKlxuICogRGV2aWNlIFBpeGVsIFJhdGlvXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L3NhZmFyaS9kb2N1bWVudGF0aW9uL0F1ZGlvVmlkZW8vQ29uY2VwdHVhbC9IVE1MLWNhbnZhcy1ndWlkZS9TZXR0aW5nVXB0aGVDYW52YXMvU2V0dGluZ1VwdGhlQ2FudmFzLmh0bWxcbiAqL1xuZmFicmljLmRldmljZVBpeGVsUmF0aW8gPSBmYWJyaWMud2luZG93LmRldmljZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFicmljLndpbmRvdy53ZWJraXREZXZpY2VQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhYnJpYy53aW5kb3cubW96RGV2aWNlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAxO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBmdW5jdGlvbiBfcmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICBpZiAoIXRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBldmVudExpc3RlbmVyID0gdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIGV2ZW50TGlzdGVuZXJbZXZlbnRMaXN0ZW5lci5pbmRleE9mKGhhbmRsZXIpXSA9IGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZhYnJpYy51dGlsLmFycmF5LmZpbGwoZXZlbnRMaXN0ZW5lciwgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPYnNlcnZlcyBzcGVjaWZpZWQgZXZlbnRcbiAgICogQGRlcHJlY2F0ZWQgYG9ic2VydmVgIGRlcHJlY2F0ZWQgc2luY2UgMC44LjM0ICh1c2UgYG9uYCBpbnN0ZWFkKVxuICAgKiBAbWVtYmVyT2YgZmFicmljLk9ic2VydmFibGVcbiAgICogQGFsaWFzIG9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZXZlbnROYW1lIEV2ZW50IG5hbWUgKGVnLiAnYWZ0ZXI6cmVuZGVyJykgb3Igb2JqZWN0IHdpdGgga2V5L3ZhbHVlIHBhaXJzIChlZy4geydhZnRlcjpyZW5kZXInOiBoYW5kbGVyLCAnc2VsZWN0aW9uOmNsZWFyZWQnOiBoYW5kbGVyfSlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBGdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEgbm90aWZpY2F0aW9uIHdoZW4gYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vyc1xuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGZ1bmN0aW9uIG9ic2VydmUoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgaWYgKCF0aGlzLl9fZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX19ldmVudExpc3RlbmVycyA9IHsgfTtcbiAgICB9XG4gICAgLy8gb25lIG9iamVjdCB3aXRoIGtleS92YWx1ZSBwYWlycyB3YXMgcGFzc2VkXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gZXZlbnROYW1lKSB7XG4gICAgICAgIHRoaXMub24ocHJvcCwgZXZlbnROYW1lW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdKSB7XG4gICAgICAgIHRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXS5wdXNoKGhhbmRsZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyBldmVudCBvYnNlcnZpbmcgZm9yIGEgcGFydGljdWxhciBldmVudCBoYW5kbGVyLiBDYWxsaW5nIHRoaXMgbWV0aG9kXG4gICAqIHdpdGhvdXQgYXJndW1lbnRzIHJlbW92ZXMgYWxsIGhhbmRsZXJzIGZvciBhbGwgZXZlbnRzXG4gICAqIEBkZXByZWNhdGVkIGBzdG9wT2JzZXJ2aW5nYCBkZXByZWNhdGVkIHNpbmNlIDAuOC4zNCAodXNlIGBvZmZgIGluc3RlYWQpXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKiBAYWxpYXMgb2ZmXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZXZlbnROYW1lIEV2ZW50IG5hbWUgKGVnLiAnYWZ0ZXI6cmVuZGVyJykgb3Igb2JqZWN0IHdpdGgga2V5L3ZhbHVlIHBhaXJzIChlZy4geydhZnRlcjpyZW5kZXInOiBoYW5kbGVyLCAnc2VsZWN0aW9uOmNsZWFyZWQnOiBoYW5kbGVyfSlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBGdW5jdGlvbiB0byBiZSBkZWxldGVkIGZyb20gRXZlbnRMaXN0ZW5lcnNcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmdW5jdGlvbiBzdG9wT2JzZXJ2aW5nKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIGlmICghdGhpcy5fX2V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGFsbCBrZXkvdmFsdWUgcGFpcnMgKGV2ZW50IG5hbWUgLT4gZXZlbnQgaGFuZGxlcilcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZm9yIChldmVudE5hbWUgaW4gdGhpcy5fX2V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgIF9yZW1vdmVFdmVudExpc3RlbmVyLmNhbGwodGhpcywgZXZlbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gb25lIG9iamVjdCB3aXRoIGtleS92YWx1ZSBwYWlycyB3YXMgcGFzc2VkXG4gICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBldmVudE5hbWUpIHtcbiAgICAgICAgX3JlbW92ZUV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCBwcm9wLCBldmVudE5hbWVbcHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIF9yZW1vdmVFdmVudExpc3RlbmVyLmNhbGwodGhpcywgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRmlyZXMgZXZlbnQgd2l0aCBhbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdFxuICAgKiBAZGVwcmVjYXRlZCBgZmlyZWAgZGVwcmVjYXRlZCBzaW5jZSAxLjAuNyAodXNlIGB0cmlnZ2VyYCBpbnN0ZWFkKVxuICAgKiBAbWVtYmVyT2YgZmFicmljLk9ic2VydmFibGVcbiAgICogQGFsaWFzIHRyaWdnZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZSBFdmVudCBuYW1lIHRvIGZpcmVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGZ1bmN0aW9uIGZpcmUoZXZlbnROYW1lLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLl9fZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGlzdGVuZXJzRm9yRXZlbnQgPSB0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXTtcbiAgICBpZiAoIWxpc3RlbmVyc0ZvckV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVyc0ZvckV2ZW50Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBsaXN0ZW5lcnNGb3JFdmVudFtpXSAmJiBsaXN0ZW5lcnNGb3JFdmVudFtpXS5jYWxsKHRoaXMsIG9wdGlvbnMgfHwgeyB9KTtcbiAgICB9XG4gICAgdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0gPSBsaXN0ZW5lcnNGb3JFdmVudC5maWx0ZXIoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPT0gZmFsc2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWVzcGFjZSBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMiNldmVudHN9XG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZXZlbnRzfEV2ZW50cyBkZW1vfVxuICAgKi9cbiAgZmFicmljLk9ic2VydmFibGUgPSB7XG4gICAgb2JzZXJ2ZTogb2JzZXJ2ZSxcbiAgICBzdG9wT2JzZXJ2aW5nOiBzdG9wT2JzZXJ2aW5nLFxuICAgIGZpcmU6IGZpcmUsXG5cbiAgICBvbjogb2JzZXJ2ZSxcbiAgICBvZmY6IHN0b3BPYnNlcnZpbmcsXG4gICAgdHJpZ2dlcjogZmlyZVxuICB9O1xufSkoKTtcblxuXG4vKipcbiAqIEBuYW1lc3BhY2UgZmFicmljLkNvbGxlY3Rpb25cbiAqL1xuZmFicmljLkNvbGxlY3Rpb24gPSB7XG5cbiAgX29iamVjdHM6IFtdLFxuXG4gIC8qKlxuICAgKiBBZGRzIG9iamVjdHMgdG8gY29sbGVjdGlvbiwgQ2FudmFzIG9yIEdyb3VwLCB0aGVuIHJlbmRlcnMgY2FudmFzXG4gICAqIChpZiBgcmVuZGVyT25BZGRSZW1vdmVgIGlzIG5vdCBgZmFsc2VgKS5cbiAgICogaW4gY2FzZSBvZiBHcm91cCBubyBjaGFuZ2VzIHRvIGJvdW5kaW5nIGJveCBhcmUgbWFkZS5cbiAgICogT2JqZWN0cyBzaG91bGQgYmUgaW5zdGFuY2VzIG9mIChvciBpbmhlcml0IGZyb20pIGZhYnJpYy5PYmplY3RcbiAgICogQHBhcmFtIHsuLi5mYWJyaWMuT2JqZWN0fSBvYmplY3QgWmVybyBvciBtb3JlIGZhYnJpYyBpbnN0YW5jZXNcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBhZGQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9vYmplY3RzLnB1c2guYXBwbHkodGhpcy5fb2JqZWN0cywgYXJndW1lbnRzKTtcbiAgICBpZiAodGhpcy5fb25PYmplY3RBZGRlZCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9vbk9iamVjdEFkZGVkKGFyZ3VtZW50c1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZW5kZXJBbGwoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogSW5zZXJ0cyBhbiBvYmplY3QgaW50byBjb2xsZWN0aW9uIGF0IHNwZWNpZmllZCBpbmRleCwgdGhlbiByZW5kZXJzIGNhbnZhcyAoaWYgYHJlbmRlck9uQWRkUmVtb3ZlYCBpcyBub3QgYGZhbHNlYClcbiAgICogQW4gb2JqZWN0IHNob3VsZCBiZSBhbiBpbnN0YW5jZSBvZiAob3IgaW5oZXJpdCBmcm9tKSBmYWJyaWMuT2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGluc2VydFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggdG8gaW5zZXJ0IG9iamVjdCBhdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG5vblNwbGljaW5nIFdoZW4gYHRydWVgLCBubyBzcGxpY2luZyAoc2hpZnRpbmcpIG9mIG9iamVjdHMgb2NjdXJzXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgaW5zZXJ0QXQ6IGZ1bmN0aW9uIChvYmplY3QsIGluZGV4LCBub25TcGxpY2luZykge1xuICAgIHZhciBvYmplY3RzID0gdGhpcy5nZXRPYmplY3RzKCk7XG4gICAgaWYgKG5vblNwbGljaW5nKSB7XG4gICAgICBvYmplY3RzW2luZGV4XSA9IG9iamVjdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBvYmplY3RzLnNwbGljZShpbmRleCwgMCwgb2JqZWN0KTtcbiAgICB9XG4gICAgdGhpcy5fb25PYmplY3RBZGRlZCAmJiB0aGlzLl9vbk9iamVjdEFkZGVkKG9iamVjdCk7XG4gICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlbmRlckFsbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIG9iamVjdHMgZnJvbSBhIGNvbGxlY3Rpb24sIHRoZW4gcmVuZGVycyBjYW52YXMgKGlmIGByZW5kZXJPbkFkZFJlbW92ZWAgaXMgbm90IGBmYWxzZWApXG4gICAqIEBwYXJhbSB7Li4uZmFicmljLk9iamVjdH0gb2JqZWN0IFplcm8gb3IgbW9yZSBmYWJyaWMgaW5zdGFuY2VzXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2JqZWN0cyA9IHRoaXMuZ2V0T2JqZWN0cygpLFxuICAgICAgICBpbmRleCwgc29tZXRoaW5nUmVtb3ZlZCA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaW5kZXggPSBvYmplY3RzLmluZGV4T2YoYXJndW1lbnRzW2ldKTtcblxuICAgICAgLy8gb25seSBjYWxsIG9uT2JqZWN0UmVtb3ZlZCBpZiBhbiBvYmplY3Qgd2FzIGFjdHVhbGx5IHJlbW92ZWRcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgc29tZXRoaW5nUmVtb3ZlZCA9IHRydWU7XG4gICAgICAgIG9iamVjdHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5fb25PYmplY3RSZW1vdmVkICYmIHRoaXMuX29uT2JqZWN0UmVtb3ZlZChhcmd1bWVudHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgc29tZXRoaW5nUmVtb3ZlZCAmJiB0aGlzLnJlbmRlckFsbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBnaXZlbiBmdW5jdGlvbiBmb3IgZWFjaCBvYmplY3QgaW4gdGhpcyBncm91cFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiAgICAgICAgICAgICAgICAgICBDYWxsYmFjayBpbnZva2VkIHdpdGggY3VycmVudCBvYmplY3QgYXMgZmlyc3QgYXJndW1lbnQsXG4gICAqICAgICAgICAgICAgICAgICAgIGluZGV4IC0gYXMgc2Vjb25kIGFuZCBhbiBhcnJheSBvZiBhbGwgb2JqZWN0cyAtIGFzIHRoaXJkLlxuICAgKiAgICAgICAgICAgICAgICAgICBDYWxsYmFjayBpcyBpbnZva2VkIGluIGEgY29udGV4dCBvZiBHbG9iYWwgT2JqZWN0IChlLmcuIGB3aW5kb3dgKVxuICAgKiAgICAgICAgICAgICAgICAgICB3aGVuIG5vIGBjb250ZXh0YCBhcmd1bWVudCBpcyBnaXZlblxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBDb250ZXh0IChha2EgdGhpc09iamVjdClcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmb3JFYWNoT2JqZWN0OiBmdW5jdGlvbihjYWxsYmFjaywgY29udGV4dCkge1xuICAgIHZhciBvYmplY3RzID0gdGhpcy5nZXRPYmplY3RzKCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgb2JqZWN0c1tpXSwgaSwgb2JqZWN0cyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGNoaWxkcmVuIG9iamVjdHMgb2YgdGhpcyBpbnN0YW5jZVxuICAgKiBUeXBlIHBhcmFtZXRlciBpbnRyb2R1Y2VkIGluIDEuMy4xMFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3R5cGVdIFdoZW4gc3BlY2lmaWVkLCBvbmx5IG9iamVjdHMgb2YgdGhpcyB0eXBlIGFyZSByZXR1cm5lZFxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGdldE9iamVjdHM6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqZWN0cztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX29iamVjdHMuZmlsdGVyKGZ1bmN0aW9uKG8pIHtcbiAgICAgIHJldHVybiBvLnR5cGUgPT09IHR5cGU7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgb2JqZWN0IGF0IHNwZWNpZmllZCBpbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKi9cbiAgaXRlbTogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0cygpW2luZGV4XTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGNvbGxlY3Rpb24gY29udGFpbnMgbm8gb2JqZWN0c1xuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGNvbGxlY3Rpb24gaXMgZW1wdHlcbiAgICovXG4gIGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RzKCkubGVuZ3RoID09PSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2l6ZSBvZiBhIGNvbGxlY3Rpb24gKGkuZTogbGVuZ3RoIG9mIGFuIGFycmF5IGNvbnRhaW5pbmcgaXRzIG9iamVjdHMpXG4gICAqIEByZXR1cm4ge051bWJlcn0gQ29sbGVjdGlvbiBzaXplXG4gICAqL1xuICBzaXplOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RzKCkubGVuZ3RoO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgY29sbGVjdGlvbiBjb250YWlucyBhbiBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2hlY2sgYWdhaW5zdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgY29sbGVjdGlvbiBjb250YWlucyBhbiBvYmplY3RcbiAgICovXG4gIGNvbnRhaW5zOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RzKCkuaW5kZXhPZihvYmplY3QpID4gLTE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgbnVtYmVyIHJlcHJlc2VudGF0aW9uIG9mIGEgY29sbGVjdGlvbiBjb21wbGV4aXR5XG4gICAqIEByZXR1cm4ge051bWJlcn0gY29tcGxleGl0eVxuICAgKi9cbiAgY29tcGxleGl0eTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldE9iamVjdHMoKS5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGN1cnJlbnQpIHtcbiAgICAgIG1lbW8gKz0gY3VycmVudC5jb21wbGV4aXR5ID8gY3VycmVudC5jb21wbGV4aXR5KCkgOiAwO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSwgMCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbmFtZXNwYWNlIGZhYnJpYy5Db21tb25NZXRob2RzXG4gKi9cbmZhYnJpYy5Db21tb25NZXRob2RzID0ge1xuXG4gIC8qKlxuICAgKiBTZXRzIG9iamVjdCdzIHByb3BlcnRpZXMgZnJvbSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIF9zZXRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzLnNldChwcm9wLCBvcHRpb25zW3Byb3BdKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsbGVyXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSBwcm9wZXJ0eSB0byBzZXQgdGhlIEdyYWRpZW50IHRvXG4gICAqL1xuICBfaW5pdEdyYWRpZW50OiBmdW5jdGlvbihmaWxsZXIsIHByb3BlcnR5KSB7XG4gICAgaWYgKGZpbGxlciAmJiBmaWxsZXIuY29sb3JTdG9wcyAmJiAhKGZpbGxlciBpbnN0YW5jZW9mIGZhYnJpYy5HcmFkaWVudCkpIHtcbiAgICAgIHRoaXMuc2V0KHByb3BlcnR5LCBuZXcgZmFicmljLkdyYWRpZW50KGZpbGxlcikpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtmaWxsZXJdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIHByb3BlcnR5IHRvIHNldCB0aGUgUGF0dGVybiB0b1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrIHRvIGludm9rZSBhZnRlciBwYXR0ZXJuIGxvYWRcbiAgICovXG4gIF9pbml0UGF0dGVybjogZnVuY3Rpb24oZmlsbGVyLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICBpZiAoZmlsbGVyICYmIGZpbGxlci5zb3VyY2UgJiYgIShmaWxsZXIgaW5zdGFuY2VvZiBmYWJyaWMuUGF0dGVybikpIHtcbiAgICAgIHRoaXMuc2V0KHByb3BlcnR5LCBuZXcgZmFicmljLlBhdHRlcm4oZmlsbGVyLCBjYWxsYmFjaykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBfaW5pdENsaXBwaW5nOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmNsaXBUbyB8fCB0eXBlb2Ygb3B0aW9ucy5jbGlwVG8gIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZ1bmN0aW9uQm9keSA9IGZhYnJpYy51dGlsLmdldEZ1bmN0aW9uQm9keShvcHRpb25zLmNsaXBUbyk7XG4gICAgaWYgKHR5cGVvZiBmdW5jdGlvbkJvZHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmNsaXBUbyA9IG5ldyBGdW5jdGlvbignY3R4JywgZnVuY3Rpb25Cb2R5KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0T2JqZWN0OiBmdW5jdGlvbihvYmopIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgdGhpcy5fc2V0KHByb3AsIG9ialtwcm9wXSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHByb3BlcnR5IHRvIGEgZ2l2ZW4gdmFsdWUuIFdoZW4gY2hhbmdpbmcgcG9zaXRpb24vZGltZW5zaW9uIC1yZWxhdGVkIHByb3BlcnRpZXMgKGxlZnQsIHRvcCwgc2NhbGUsIGFuZ2xlLCBldGMuKSBgc2V0YCBkb2VzIG5vdCB1cGRhdGUgcG9zaXRpb24gb2Ygb2JqZWN0J3MgYm9yZGVycy9jb250cm9scy4gSWYgeW91IG5lZWQgdG8gdXBkYXRlIHRob3NlLCBjYWxsIGBzZXRDb29yZHMoKWAuXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0ga2V5IFByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IChpZiBvYmplY3QsIGl0ZXJhdGUgb3ZlciB0aGUgb2JqZWN0IHByb3BlcnRpZXMpXG4gICAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSB2YWx1ZSBQcm9wZXJ0eSB2YWx1ZSAoaWYgZnVuY3Rpb24sIHRoZSB2YWx1ZSBpcyBwYXNzZWQgaW50byBpdCBhbmQgaXRzIHJldHVybiB2YWx1ZSBpcyB1c2VkIGFzIGEgbmV3IG9uZSlcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMuX3NldE9iamVjdChrZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYga2V5ICE9PSAnY2xpcFRvJykge1xuICAgICAgICB0aGlzLl9zZXQoa2V5LCB2YWx1ZSh0aGlzLmdldChrZXkpKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdGhpc1trZXldID0gdmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgc3BlY2lmaWVkIHByb3BlcnR5IGZyb20gYHRydWVgIHRvIGBmYWxzZWAgb3IgZnJvbSBgZmFsc2VgIHRvIGB0cnVlYFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdG8gdG9nZ2xlXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgdG9nZ2xlOiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KHByb3BlcnR5KTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHRoaXMuc2V0KHByb3BlcnR5LCAhdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQmFzaWMgZ2V0dGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAqIEByZXR1cm4geyp9IHZhbHVlIG9mIGEgcHJvcGVydHlcbiAgICovXG4gIGdldDogZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICByZXR1cm4gdGhpc1twcm9wZXJ0eV07XG4gIH1cbn07XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gIHZhciBzcXJ0ID0gTWF0aC5zcXJ0LFxuICAgICAgYXRhbjIgPSBNYXRoLmF0YW4yLFxuICAgICAgcG93ID0gTWF0aC5wb3csXG4gICAgICBhYnMgPSBNYXRoLmFicyxcbiAgICAgIFBpQnkxODAgPSBNYXRoLlBJIC8gMTgwO1xuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlIGZhYnJpYy51dGlsXG4gICAqL1xuICBmYWJyaWMudXRpbCA9IHtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdmFsdWUgZnJvbSBhbiBhcnJheS5cbiAgICAgKiBQcmVzZW5jZSBvZiB2YWx1ZSAoYW5kIGl0cyBwb3NpdGlvbiBpbiBhbiBhcnJheSkgaXMgZGV0ZXJtaW5lZCB2aWEgYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gb3JpZ2luYWwgYXJyYXlcbiAgICAgKi9cbiAgICByZW1vdmVGcm9tQXJyYXk6IGZ1bmN0aW9uKGFycmF5LCB2YWx1ZSkge1xuICAgICAgdmFyIGlkeCA9IGFycmF5LmluZGV4T2YodmFsdWUpO1xuICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgYXJyYXkuc3BsaWNlKGlkeCwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmFuZG9tIG51bWJlciBiZXR3ZWVuIDIgc3BlY2lmaWVkIG9uZXMuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtaW4gbG93ZXIgbGltaXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWF4IHVwcGVyIGxpbWl0XG4gICAgICogQHJldHVybiB7TnVtYmVyfSByYW5kb20gdmFsdWUgKGJldHdlZW4gbWluIGFuZCBtYXgpXG4gICAgICovXG4gICAgZ2V0UmFuZG9tSW50OiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgZGVncmVlcyB0byByYWRpYW5zLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVncmVlcyB2YWx1ZSBpbiBkZWdyZWVzXG4gICAgICogQHJldHVybiB7TnVtYmVyfSB2YWx1ZSBpbiByYWRpYW5zXG4gICAgICovXG4gICAgZGVncmVlc1RvUmFkaWFuczogZnVuY3Rpb24oZGVncmVlcykge1xuICAgICAgcmV0dXJuIGRlZ3JlZXMgKiBQaUJ5MTgwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHJhZGlhbnMgdG8gZGVncmVlcy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGlhbnMgdmFsdWUgaW4gcmFkaWFuc1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gdmFsdWUgaW4gZGVncmVlc1xuICAgICAqL1xuICAgIHJhZGlhbnNUb0RlZ3JlZXM6IGZ1bmN0aW9uKHJhZGlhbnMpIHtcbiAgICAgIHJldHVybiByYWRpYW5zIC8gUGlCeTE4MDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUm90YXRlcyBgcG9pbnRgIGFyb3VuZCBgb3JpZ2luYCB3aXRoIGByYWRpYW5zYFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHRvIHJvdGF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBvcmlnaW4gVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaWFucyBUaGUgcmFkaWFucyBvZiB0aGUgYW5nbGUgZm9yIHRoZSByb3RhdGlvblxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gVGhlIG5ldyByb3RhdGVkIHBvaW50XG4gICAgICovXG4gICAgcm90YXRlUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBvcmlnaW4sIHJhZGlhbnMpIHtcbiAgICAgIHBvaW50LnN1YnRyYWN0RXF1YWxzKG9yaWdpbik7XG4gICAgICB2YXIgdiA9IGZhYnJpYy51dGlsLnJvdGF0ZVZlY3Rvcihwb2ludCwgcmFkaWFucyk7XG4gICAgICByZXR1cm4gbmV3IGZhYnJpYy5Qb2ludCh2LngsIHYueSkuYWRkRXF1YWxzKG9yaWdpbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgYHZlY3RvcmAgd2l0aCBgcmFkaWFuc2BcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZlY3RvciBUaGUgdmVjdG9yIHRvIHJvdGF0ZSAoeCBhbmQgeSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaWFucyBUaGUgcmFkaWFucyBvZiB0aGUgYW5nbGUgZm9yIHRoZSByb3RhdGlvblxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyByb3RhdGVkIHBvaW50XG4gICAgICovXG4gICAgcm90YXRlVmVjdG9yOiBmdW5jdGlvbih2ZWN0b3IsIHJhZGlhbnMpIHtcbiAgICAgIHZhciBzaW4gPSBNYXRoLnNpbihyYWRpYW5zKSxcbiAgICAgICAgICBjb3MgPSBNYXRoLmNvcyhyYWRpYW5zKSxcbiAgICAgICAgICByeCA9IHZlY3Rvci54ICogY29zIC0gdmVjdG9yLnkgKiBzaW4sXG4gICAgICAgICAgcnkgPSB2ZWN0b3IueCAqIHNpbiArIHZlY3Rvci55ICogY29zO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcngsXG4gICAgICAgIHk6IHJ5XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0cmFuc2Zvcm0gdCB0byBwb2ludCBwXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSAge2ZhYnJpYy5Qb2ludH0gcCBUaGUgcG9pbnQgdG8gdHJhbnNmb3JtXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHQgVGhlIHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IFtpZ25vcmVPZmZzZXRdIEluZGljYXRlcyB0aGF0IHRoZSBvZmZzZXQgc2hvdWxkIG5vdCBiZSBhcHBsaWVkXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSBUaGUgdHJhbnNmb3JtZWQgcG9pbnRcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1Qb2ludDogZnVuY3Rpb24ocCwgdCwgaWdub3JlT2Zmc2V0KSB7XG4gICAgICBpZiAoaWdub3JlT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgZmFicmljLlBvaW50KFxuICAgICAgICAgIHRbMF0gKiBwLnggKyB0WzJdICogcC55LFxuICAgICAgICAgIHRbMV0gKiBwLnggKyB0WzNdICogcC55XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IGZhYnJpYy5Qb2ludChcbiAgICAgICAgdFswXSAqIHAueCArIHRbMl0gKiBwLnkgKyB0WzRdLFxuICAgICAgICB0WzFdICogcC54ICsgdFszXSAqIHAueSArIHRbNV1cbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29vcmRpbmF0ZXMgb2YgcG9pbnRzJ3MgYm91bmRpbmcgcmVjdGFuZ2xlIChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIDQgcG9pbnRzIGFycmF5XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIG1ha2VCb3VuZGluZ0JveEZyb21Qb2ludHM6IGZ1bmN0aW9uKHBvaW50cykge1xuICAgICAgdmFyIHhQb2ludHMgPSBbcG9pbnRzWzBdLngsIHBvaW50c1sxXS54LCBwb2ludHNbMl0ueCwgcG9pbnRzWzNdLnhdLFxuICAgICAgICAgIG1pblggPSBmYWJyaWMudXRpbC5hcnJheS5taW4oeFBvaW50cyksXG4gICAgICAgICAgbWF4WCA9IGZhYnJpYy51dGlsLmFycmF5Lm1heCh4UG9pbnRzKSxcbiAgICAgICAgICB3aWR0aCA9IE1hdGguYWJzKG1pblggLSBtYXhYKSxcbiAgICAgICAgICB5UG9pbnRzID0gW3BvaW50c1swXS55LCBwb2ludHNbMV0ueSwgcG9pbnRzWzJdLnksIHBvaW50c1szXS55XSxcbiAgICAgICAgICBtaW5ZID0gZmFicmljLnV0aWwuYXJyYXkubWluKHlQb2ludHMpLFxuICAgICAgICAgIG1heFkgPSBmYWJyaWMudXRpbC5hcnJheS5tYXgoeVBvaW50cyksXG4gICAgICAgICAgaGVpZ2h0ID0gTWF0aC5hYnMobWluWSAtIG1heFkpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBtaW5YLFxuICAgICAgICB0b3A6IG1pblksXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludmVydCB0cmFuc2Zvcm1hdGlvbiB0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHQgVGhlIHRyYW5zZm9ybVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgaW52ZXJ0ZWQgdHJhbnNmb3JtXG4gICAgICovXG4gICAgaW52ZXJ0VHJhbnNmb3JtOiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgYSA9IDEgLyAodFswXSAqIHRbM10gLSB0WzFdICogdFsyXSksXG4gICAgICAgICAgciA9IFthICogdFszXSwgLWEgKiB0WzFdLCAtYSAqIHRbMl0sIGEgKiB0WzBdXSxcbiAgICAgICAgICBvID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQoeyB4OiB0WzRdLCB5OiB0WzVdIH0sIHIsIHRydWUpO1xuICAgICAgcls0XSA9IC1vLng7XG4gICAgICByWzVdID0gLW8ueTtcbiAgICAgIHJldHVybiByO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHdyYXBwZXIgYXJvdW5kIE51bWJlciN0b0ZpeGVkLCB3aGljaCBjb250cmFyeSB0byBuYXRpdmUgbWV0aG9kIHJldHVybnMgbnVtYmVyLCBub3Qgc3RyaW5nLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IG51bWJlciBudW1iZXIgdG8gb3BlcmF0ZSBvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFjdGlvbkRpZ2l0cyBudW1iZXIgb2YgZnJhY3Rpb24gZGlnaXRzIHRvIFwibGVhdmVcIlxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICB0b0ZpeGVkOiBmdW5jdGlvbihudW1iZXIsIGZyYWN0aW9uRGlnaXRzKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChOdW1iZXIobnVtYmVyKS50b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGZyb20gYXR0cmlidXRlIHZhbHVlIHRvIHBpeGVsIHZhbHVlIGlmIGFwcGxpY2FibGUuXG4gICAgICogUmV0dXJucyBjb252ZXJ0ZWQgcGl4ZWxzIG9yIG9yaWdpbmFsIHZhbHVlIG5vdCBjb252ZXJ0ZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZSBudW1iZXIgdG8gb3BlcmF0ZSBvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmb250U2l6ZVxuICAgICAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9XG4gICAgICovXG4gICAgcGFyc2VVbml0OiBmdW5jdGlvbih2YWx1ZSwgZm9udFNpemUpIHtcbiAgICAgIHZhciB1bml0ID0gL1xcRHswLDJ9JC8uZXhlYyh2YWx1ZSksXG4gICAgICAgICAgbnVtYmVyID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICBpZiAoIWZvbnRTaXplKSB7XG4gICAgICAgIGZvbnRTaXplID0gZmFicmljLlRleHQuREVGQVVMVF9TVkdfRk9OVF9TSVpFO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh1bml0WzBdKSB7XG4gICAgICAgIGNhc2UgJ21tJzpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyICogZmFicmljLkRQSSAvIDI1LjQ7XG5cbiAgICAgICAgY2FzZSAnY20nOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmYWJyaWMuRFBJIC8gMi41NDtcblxuICAgICAgICBjYXNlICdpbic6XG4gICAgICAgICAgcmV0dXJuIG51bWJlciAqIGZhYnJpYy5EUEk7XG5cbiAgICAgICAgY2FzZSAncHQnOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmYWJyaWMuRFBJIC8gNzI7IC8vIG9yICogNCAvIDNcblxuICAgICAgICBjYXNlICdwYyc6XG4gICAgICAgICAgcmV0dXJuIG51bWJlciAqIGZhYnJpYy5EUEkgLyA3MiAqIDEyOyAvLyBvciAqIDE2XG5cbiAgICAgICAgY2FzZSAnZW0nOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmb250U2l6ZTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHdoaWNoIGFsd2F5cyByZXR1cm5zIGBmYWxzZWAuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZmFsc2VGdW5jdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMga2xhc3MgXCJDbGFzc1wiIG9iamVjdCBvZiBnaXZlbiBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIG9mIG9iamVjdCAoZWcuICdjaXJjbGUnKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgTmFtZXNwYWNlIHRvIGdldCBrbGFzcyBcIkNsYXNzXCIgb2JqZWN0IGZyb21cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGtsYXNzIFwiQ2xhc3NcIlxuICAgICAqL1xuICAgIGdldEtsYXNzOiBmdW5jdGlvbih0eXBlLCBuYW1lc3BhY2UpIHtcbiAgICAgIC8vIGNhcGl0YWxpemUgZmlyc3QgbGV0dGVyIG9ubHlcbiAgICAgIHR5cGUgPSBmYWJyaWMudXRpbC5zdHJpbmcuY2FtZWxpemUodHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHR5cGUuc2xpY2UoMSkpO1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnJlc29sdmVOYW1lc3BhY2UobmFtZXNwYWNlKVt0eXBlXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3Qgb2YgZ2l2ZW4gbmFtZXNwYWNlXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBOYW1lc3BhY2Ugc3RyaW5nIGUuZy4gJ2ZhYnJpYy5JbWFnZS5maWx0ZXInIG9yICdmYWJyaWMnXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgZm9yIGdpdmVuIG5hbWVzcGFjZSAoZGVmYXVsdCBmYWJyaWMpXG4gICAgICovXG4gICAgcmVzb2x2ZU5hbWVzcGFjZTogZnVuY3Rpb24obmFtZXNwYWNlKSB7XG4gICAgICBpZiAoIW5hbWVzcGFjZSkge1xuICAgICAgICByZXR1cm4gZmFicmljO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFydHMgPSBuYW1lc3BhY2Uuc3BsaXQoJy4nKSxcbiAgICAgICAgICBsZW4gPSBwYXJ0cy5sZW5ndGgsIGksXG4gICAgICAgICAgb2JqID0gZ2xvYmFsIHx8IGZhYnJpYy53aW5kb3c7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBvYmogPSBvYmpbcGFydHNbaV1dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBpbWFnZSBlbGVtZW50IGZyb20gZ2l2ZW4gdXJsIGFuZCBwYXNzZXMgaXQgdG8gYSBjYWxsYmFja1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVVJMIHJlcHJlc2VudGluZyBhbiBpbWFnZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrOyBpbnZva2VkIHdpdGggbG9hZGVkIGltYWdlXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF0gQ29udGV4dCB0byBpbnZva2UgY2FsbGJhY2sgaW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2Nyb3NzT3JpZ2luXSBjcm9zc09yaWdpbiB2YWx1ZSB0byBzZXQgaW1hZ2UgZWxlbWVudCB0b1xuICAgICAqL1xuICAgIGxvYWRJbWFnZTogZnVuY3Rpb24odXJsLCBjYWxsYmFjaywgY29udGV4dCwgY3Jvc3NPcmlnaW4pIHtcbiAgICAgIGlmICghdXJsKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgdXJsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW1nID0gZmFicmljLnV0aWwuY3JlYXRlSW1hZ2UoKTtcblxuICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgaW1nKTtcbiAgICAgICAgaW1nID0gaW1nLm9ubG9hZCA9IGltZy5vbmVycm9yID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIC8qKiBAaWdub3JlICovXG4gICAgICBpbWcub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmYWJyaWMubG9nKCdFcnJvciBsb2FkaW5nICcgKyBpbWcuc3JjKTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbChjb250ZXh0LCBudWxsLCB0cnVlKTtcbiAgICAgICAgaW1nID0gaW1nLm9ubG9hZCA9IGltZy5vbmVycm9yID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIC8vIGRhdGEtdXJscyBhcHBlYXIgdG8gYmUgYnVnZ3kgd2l0aCBjcm9zc09yaWdpblxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2thbmdheC9mYWJyaWMuanMvY29tbWl0L2QwYWJiOTBmMWNkNWM1ZWY5ZDJhOTRkM2ZiMjFhMjIzMzBkYTNlMGEjY29tbWl0Y29tbWVudC00NTEzNzY3XG4gICAgICAvLyBzZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTMxNTE1MlxuICAgICAgLy8gICAgIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTkzNTA2OVxuICAgICAgaWYgKHVybC5pbmRleE9mKCdkYXRhJykgIT09IDAgJiYgY3Jvc3NPcmlnaW4pIHtcbiAgICAgICAgaW1nLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG4gICAgICB9XG5cbiAgICAgIGltZy5zcmMgPSB1cmw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgY29ycmVzcG9uZGluZyBmYWJyaWMgaW5zdGFuY2VzIGZyb20gdGhlaXIgb2JqZWN0IHJlcHJlc2VudGF0aW9uc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzIE9iamVjdHMgdG8gZW5saXZlblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFsbCBvYmplY3RzIGFyZSBjcmVhdGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBOYW1lc3BhY2UgdG8gZ2V0IGtsYXNzIFwiQ2xhc3NcIiBvYmplY3QgZnJvbVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJldml2ZXIgTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygb2JqZWN0IGVsZW1lbnRzLFxuICAgICAqIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBlbmxpdmVuT2JqZWN0czogZnVuY3Rpb24ob2JqZWN0cywgY2FsbGJhY2ssIG5hbWVzcGFjZSwgcmV2aXZlcikge1xuICAgICAgb2JqZWN0cyA9IG9iamVjdHMgfHwgW107XG5cbiAgICAgIGZ1bmN0aW9uIG9uTG9hZGVkKCkge1xuICAgICAgICBpZiAoKytudW1Mb2FkZWRPYmplY3RzID09PSBudW1Ub3RhbE9iamVjdHMpIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRPYmplY3RzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZW5saXZlbmVkT2JqZWN0cyA9IFtdLFxuICAgICAgICAgIG51bUxvYWRlZE9iamVjdHMgPSAwLFxuICAgICAgICAgIG51bVRvdGFsT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoLFxuICAgICAgICAgIGZvcmNlQXN5bmMgPSB0cnVlO1xuXG4gICAgICBpZiAoIW51bVRvdGFsT2JqZWN0cykge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRPYmplY3RzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24gKG8sIGluZGV4KSB7XG4gICAgICAgIC8vIGlmIHNwYXJzZSBhcnJheVxuICAgICAgICBpZiAoIW8gfHwgIW8udHlwZSkge1xuICAgICAgICAgIG9uTG9hZGVkKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrbGFzcyA9IGZhYnJpYy51dGlsLmdldEtsYXNzKG8udHlwZSwgbmFtZXNwYWNlKTtcbiAgICAgICAga2xhc3MuZnJvbU9iamVjdChvLCBmdW5jdGlvbiAob2JqLCBlcnJvcikge1xuICAgICAgICAgIGVycm9yIHx8IChlbmxpdmVuZWRPYmplY3RzW2luZGV4XSA9IG9iaik7XG4gICAgICAgICAgcmV2aXZlciAmJiByZXZpdmVyKG8sIG9iaiwgZXJyb3IpO1xuICAgICAgICAgIG9uTG9hZGVkKCk7XG4gICAgICAgIH0sIGZvcmNlQXN5bmMpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgd2FpdCBmb3IgbG9hZGluZyBvZiBwYXR0ZXJuc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzIE9iamVjdHMgdG8gZW5saXZlblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFsbCBvYmplY3RzIGFyZSBjcmVhdGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBOYW1lc3BhY2UgdG8gZ2V0IGtsYXNzIFwiQ2xhc3NcIiBvYmplY3QgZnJvbVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJldml2ZXIgTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygb2JqZWN0IGVsZW1lbnRzLFxuICAgICAqIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBlbmxpdmVuUGF0dGVybnM6IGZ1bmN0aW9uKHBhdHRlcm5zLCBjYWxsYmFjaykge1xuICAgICAgcGF0dGVybnMgPSBwYXR0ZXJucyB8fCBbXTtcblxuICAgICAgZnVuY3Rpb24gb25Mb2FkZWQoKSB7XG4gICAgICAgIGlmICgrK251bUxvYWRlZFBhdHRlcm5zID09PSBudW1QYXR0ZXJucykge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVubGl2ZW5lZFBhdHRlcm5zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZW5saXZlbmVkUGF0dGVybnMgPSBbXSxcbiAgICAgICAgICBudW1Mb2FkZWRQYXR0ZXJucyA9IDAsXG4gICAgICAgICAgbnVtUGF0dGVybnMgPSBwYXR0ZXJucy5sZW5ndGg7XG5cbiAgICAgIGlmICghbnVtUGF0dGVybnMpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZW5saXZlbmVkUGF0dGVybnMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHBhdHRlcm5zLmZvckVhY2goZnVuY3Rpb24gKHAsIGluZGV4KSB7XG4gICAgICAgIGlmIChwICYmIHAuc291cmNlKSB7XG4gICAgICAgICAgbmV3IGZhYnJpYy5QYXR0ZXJuKHAsIGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICAgICAgICAgIGVubGl2ZW5lZFBhdHRlcm5zW2luZGV4XSA9IHBhdHRlcm47XG4gICAgICAgICAgICBvbkxvYWRlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGVubGl2ZW5lZFBhdHRlcm5zW2luZGV4XSA9IHA7XG4gICAgICAgICAgb25Mb2FkZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdyb3VwcyBTVkcgZWxlbWVudHMgKHVzdWFsbHkgdGhvc2UgcmV0cmlldmVkIGZyb20gU1ZHIGRvY3VtZW50KVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBlbGVtZW50cyBTVkcgZWxlbWVudHMgdG8gZ3JvdXBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggVmFsdWUgdG8gc2V0IHNvdXJjZVBhdGggdG9cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fGZhYnJpYy5QYXRoR3JvdXB9XG4gICAgICovXG4gICAgZ3JvdXBTVkdFbGVtZW50czogZnVuY3Rpb24oZWxlbWVudHMsIG9wdGlvbnMsIHBhdGgpIHtcbiAgICAgIHZhciBvYmplY3Q7XG5cbiAgICAgIG9iamVjdCA9IG5ldyBmYWJyaWMuUGF0aEdyb3VwKGVsZW1lbnRzLCBvcHRpb25zKTtcblxuICAgICAgaWYgKHR5cGVvZiBwYXRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvYmplY3Quc2V0U291cmNlUGF0aChwYXRoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBvcHVsYXRlcyBhbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIG9mIGFub3RoZXIgb2JqZWN0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgU291cmNlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbiBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gcHJvcGVydGllcyBQcm9wZXJ0aWUgbmFtZXMgdG8gaW5jbHVkZVxuICAgICAqL1xuICAgIHBvcHVsYXRlV2l0aFByb3BlcnRpZXM6IGZ1bmN0aW9uKHNvdXJjZSwgZGVzdGluYXRpb24sIHByb3BlcnRpZXMpIHtcbiAgICAgIGlmIChwcm9wZXJ0aWVzICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwcm9wZXJ0aWVzKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2ldIGluIHNvdXJjZSkge1xuICAgICAgICAgICAgZGVzdGluYXRpb25bcHJvcGVydGllc1tpXV0gPSBzb3VyY2VbcHJvcGVydGllc1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGEgZGFzaGVkIGxpbmUgYmV0d2VlbiB0d28gcG9pbnRzXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGRyYXcgZGFzaGVkIGxpbmUgYXJvdW5kIHNlbGVjdGlvbiBhcmVhLlxuICAgICAqIFNlZSA8YSBocmVmPVwiaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80NTc2NzI0L2RvdHRlZC1zdHJva2UtaW4tY2FudmFzXCI+ZG90dGVkIHN0cm9rZSBpbiBjYW52YXM8L2E+XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCAgc3RhcnQgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgc3RhcnQgeSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHgyIGVuZCB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geTIgZW5kIHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhIGRhc2ggYXJyYXkgcGF0dGVyblxuICAgICAqL1xuICAgIGRyYXdEYXNoZWRMaW5lOiBmdW5jdGlvbihjdHgsIHgsIHksIHgyLCB5MiwgZGEpIHtcbiAgICAgIHZhciBkeCA9IHgyIC0geCxcbiAgICAgICAgICBkeSA9IHkyIC0geSxcbiAgICAgICAgICBsZW4gPSBzcXJ0KGR4ICogZHggKyBkeSAqIGR5KSxcbiAgICAgICAgICByb3QgPSBhdGFuMihkeSwgZHgpLFxuICAgICAgICAgIGRjID0gZGEubGVuZ3RoLFxuICAgICAgICAgIGRpID0gMCxcbiAgICAgICAgICBkcmF3ID0gdHJ1ZTtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBjdHgubW92ZVRvKDAsIDApO1xuICAgICAgY3R4LnJvdGF0ZShyb3QpO1xuXG4gICAgICB4ID0gMDtcbiAgICAgIHdoaWxlIChsZW4gPiB4KSB7XG4gICAgICAgIHggKz0gZGFbZGkrKyAlIGRjXTtcbiAgICAgICAgaWYgKHggPiBsZW4pIHtcbiAgICAgICAgICB4ID0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIGN0eFtkcmF3ID8gJ2xpbmVUbycgOiAnbW92ZVRvJ10oeCwgMCk7XG4gICAgICAgIGRyYXcgPSAhZHJhdztcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBjYW52YXMgZWxlbWVudCBhbmQgaW5pdGlhbGl6ZXMgaXQgdmlhIGV4Y2FudmFzIGlmIG5lY2Vzc2FyeVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0NhbnZhc0VsZW1lbnR9IFtjYW52YXNFbF0gb3B0aW9uYWwgY2FudmFzIGVsZW1lbnQgdG8gaW5pdGlhbGl6ZTtcbiAgICAgKiB3aGVuIG5vdCBnaXZlbiwgZWxlbWVudCBpcyBjcmVhdGVkIGltcGxpY2l0bHlcbiAgICAgKiBAcmV0dXJuIHtDYW52YXNFbGVtZW50fSBpbml0aWFsaXplZCBjYW52YXMgZWxlbWVudFxuICAgICAqL1xuICAgIGNyZWF0ZUNhbnZhc0VsZW1lbnQ6IGZ1bmN0aW9uKGNhbnZhc0VsKSB7XG4gICAgICBjYW52YXNFbCB8fCAoY2FudmFzRWwgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykpO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gICAgICBpZiAoIWNhbnZhc0VsLmdldENvbnRleHQgJiYgdHlwZW9mIEdfdm1sQ2FudmFzTWFuYWdlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgR192bWxDYW52YXNNYW5hZ2VyLmluaXRFbGVtZW50KGNhbnZhc0VsKTtcbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG4gICAgICByZXR1cm4gY2FudmFzRWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgaW1hZ2UgZWxlbWVudCAod29ya3Mgb24gY2xpZW50IGFuZCBub2RlKVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBIVE1MIGltYWdlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBjcmVhdGVJbWFnZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFicmljLmlzTGlrZWx5Tm9kZVxuICAgICAgICA/IG5ldyAocmVxdWlyZSgnY2FudmFzJykuSW1hZ2UpKClcbiAgICAgICAgOiBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYWNjZXNzb3JzIChnZXRYWFgsIHNldFhYWCkgZm9yIGEgXCJjbGFzc1wiLCBiYXNlZCBvbiBcInN0YXRlUHJvcGVydGllc1wiIGFycmF5XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBrbGFzcyBcIkNsYXNzXCIgdG8gY3JlYXRlIGFjY2Vzc29ycyBmb3JcbiAgICAgKi9cbiAgICBjcmVhdGVBY2Nlc3NvcnM6IGZ1bmN0aW9uKGtsYXNzKSB7XG4gICAgICB2YXIgcHJvdG8gPSBrbGFzcy5wcm90b3R5cGUsIGksIHByb3BOYW1lLFxuICAgICAgICAgIGNhcGl0YWxpemVkUHJvcE5hbWUsIHNldHRlck5hbWUsIGdldHRlck5hbWU7XG5cbiAgICAgIGZvciAoaSA9IHByb3RvLnN0YXRlUHJvcGVydGllcy5sZW5ndGg7IGktLTsgKSB7XG5cbiAgICAgICAgcHJvcE5hbWUgPSBwcm90by5zdGF0ZVByb3BlcnRpZXNbaV07XG4gICAgICAgIGNhcGl0YWxpemVkUHJvcE5hbWUgPSBwcm9wTmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BOYW1lLnNsaWNlKDEpO1xuICAgICAgICBzZXR0ZXJOYW1lID0gJ3NldCcgKyBjYXBpdGFsaXplZFByb3BOYW1lO1xuICAgICAgICBnZXR0ZXJOYW1lID0gJ2dldCcgKyBjYXBpdGFsaXplZFByb3BOYW1lO1xuXG4gICAgICAgIC8vIHVzaW5nIGBuZXcgRnVuY3Rpb25gIGZvciBiZXR0ZXIgaW50cm9zcGVjdGlvblxuICAgICAgICBpZiAoIXByb3RvW2dldHRlck5hbWVdKSB7XG4gICAgICAgICAgcHJvdG9bZ2V0dGVyTmFtZV0gPSAoZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzLmdldChcIicgKyBwcm9wZXJ0eSArICdcIiknKTtcbiAgICAgICAgICB9KShwcm9wTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcm90b1tzZXR0ZXJOYW1lXSkge1xuICAgICAgICAgIHByb3RvW3NldHRlck5hbWVdID0gKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCd2YWx1ZScsICdyZXR1cm4gdGhpcy5zZXQoXCInICsgcHJvcGVydHkgKyAnXCIsIHZhbHVlKScpO1xuICAgICAgICAgIH0pKHByb3BOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSByZWNlaXZlciBPYmplY3QgaW1wbGVtZW50aW5nIGBjbGlwVG9gIG1ldGhvZFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBjbGlwXG4gICAgICovXG4gICAgY2xpcENvbnRleHQ6IGZ1bmN0aW9uKHJlY2VpdmVyLCBjdHgpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICByZWNlaXZlci5jbGlwVG8oY3R4KTtcbiAgICAgIGN0eC5jbGlwKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGx5IG1hdHJpeCBBIGJ5IG1hdHJpeCBCIHRvIG5lc3QgdHJhbnNmb3JtYXRpb25zXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhIEZpcnN0IHRyYW5zZm9ybU1hdHJpeFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBiIFNlY29uZCB0cmFuc2Zvcm1NYXRyaXhcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBpczJ4MiBmbGFnIHRvIG11bHRpcGx5IG1hdHJpY2VzIGFzIDJ4MiBtYXRyaWNlc1xuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgcHJvZHVjdCBvZiB0aGUgdHdvIHRyYW5zZm9ybSBtYXRyaWNlc1xuICAgICAqL1xuICAgIG11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXM6IGZ1bmN0aW9uKGEsIGIsIGlzMngyKSB7XG4gICAgICAvLyBNYXRyaXggbXVsdGlwbHkgYSAqIGJcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGFbMF0gKiBiWzBdICsgYVsyXSAqIGJbMV0sXG4gICAgICAgIGFbMV0gKiBiWzBdICsgYVszXSAqIGJbMV0sXG4gICAgICAgIGFbMF0gKiBiWzJdICsgYVsyXSAqIGJbM10sXG4gICAgICAgIGFbMV0gKiBiWzJdICsgYVszXSAqIGJbM10sXG4gICAgICAgIGlzMngyID8gMCA6IGFbMF0gKiBiWzRdICsgYVsyXSAqIGJbNV0gKyBhWzRdLFxuICAgICAgICBpczJ4MiA/IDAgOiBhWzFdICogYls0XSArIGFbM10gKiBiWzVdICsgYVs1XVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjb21wb3NlcyBzdGFuZGFyZCAyeDIgbWF0cml4IGludG8gdHJhbnNmb3JtIGNvbXBvbmVudGVzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhIHRyYW5zZm9ybU1hdHJpeFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ29tcG9uZW50cyBvZiB0cmFuc2Zvcm1cbiAgICAgKi9cbiAgICBxckRlY29tcG9zZTogZnVuY3Rpb24oYSkge1xuICAgICAgdmFyIGFuZ2xlID0gYXRhbjIoYVsxXSwgYVswXSksXG4gICAgICAgICAgZGVub20gPSBwb3coYVswXSwgMikgKyBwb3coYVsxXSwgMiksXG4gICAgICAgICAgc2NhbGVYID0gc3FydChkZW5vbSksXG4gICAgICAgICAgc2NhbGVZID0gKGFbMF0gKiBhWzNdIC0gYVsyXSAqIGEgWzFdKSAvIHNjYWxlWCxcbiAgICAgICAgICBza2V3WCA9IGF0YW4yKGFbMF0gKiBhWzJdICsgYVsxXSAqIGEgWzNdLCBkZW5vbSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhbmdsZTogYW5nbGUgIC8gUGlCeTE4MCxcbiAgICAgICAgc2NhbGVYOiBzY2FsZVgsXG4gICAgICAgIHNjYWxlWTogc2NhbGVZLFxuICAgICAgICBza2V3WDogc2tld1ggLyBQaUJ5MTgwLFxuICAgICAgICBza2V3WTogMCxcbiAgICAgICAgdHJhbnNsYXRlWDogYVs0XSxcbiAgICAgICAgdHJhbnNsYXRlWTogYVs1XVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgY3VzdG9tVHJhbnNmb3JtTWF0cml4OiBmdW5jdGlvbihzY2FsZVgsIHNjYWxlWSwgc2tld1gpIHtcbiAgICAgIHZhciBza2V3TWF0cml4WCA9IFsxLCAwLCBhYnMoTWF0aC50YW4oc2tld1ggKiBQaUJ5MTgwKSksIDFdLFxuICAgICAgICAgIHNjYWxlTWF0cml4ID0gW2FicyhzY2FsZVgpLCAwLCAwLCBhYnMoc2NhbGVZKV07XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyhzY2FsZU1hdHJpeCwgc2tld01hdHJpeFgsIHRydWUpO1xuICAgIH0sXG5cbiAgICByZXNldE9iamVjdFRyYW5zZm9ybTogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgdGFyZ2V0LnNjYWxlWCA9IDE7XG4gICAgICB0YXJnZXQuc2NhbGVZID0gMTtcbiAgICAgIHRhcmdldC5za2V3WCA9IDA7XG4gICAgICB0YXJnZXQuc2tld1kgPSAwO1xuICAgICAgdGFyZ2V0LmZsaXBYID0gZmFsc2U7XG4gICAgICB0YXJnZXQuZmxpcFkgPSBmYWxzZTtcbiAgICAgIHRhcmdldC5zZXRBbmdsZSgwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgZnVuY3Rpb24gYm9keVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGdldCBib2R5IG9mXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBGdW5jdGlvbiBib2R5XG4gICAgICovXG4gICAgZ2V0RnVuY3Rpb25Cb2R5OiBmdW5jdGlvbihmbikge1xuICAgICAgcmV0dXJuIChTdHJpbmcoZm4pLm1hdGNoKC9mdW5jdGlvbltee10qXFx7KFtcXHNcXFNdKilcXH0vKSB8fCB7fSlbMV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBjb250ZXh0IGhhcyB0cmFuc3BhcmVudCBwaXhlbFxuICAgICAqIGF0IHNwZWNpZmllZCBsb2NhdGlvbiAodGFraW5nIHRvbGVyYW5jZSBpbnRvIGFjY291bnQpXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgeSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvbGVyYW5jZSBUb2xlcmFuY2VcbiAgICAgKi9cbiAgICBpc1RyYW5zcGFyZW50OiBmdW5jdGlvbihjdHgsIHgsIHksIHRvbGVyYW5jZSkge1xuXG4gICAgICAvLyBJZiB0b2xlcmFuY2UgaXMgPiAwIGFkanVzdCBzdGFydCBjb29yZHMgdG8gdGFrZSBpbnRvIGFjY291bnQuXG4gICAgICAvLyBJZiBtb3ZlcyBvZmYgQ2FudmFzIGZpeCB0byAwXG4gICAgICBpZiAodG9sZXJhbmNlID4gMCkge1xuICAgICAgICBpZiAoeCA+IHRvbGVyYW5jZSkge1xuICAgICAgICAgIHggLT0gdG9sZXJhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5ID4gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgeSAtPSB0b2xlcmFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgeSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIF9pc1RyYW5zcGFyZW50ID0gdHJ1ZSwgaSwgdGVtcCxcbiAgICAgICAgICBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKHgsIHksICh0b2xlcmFuY2UgKiAyKSB8fCAxLCAodG9sZXJhbmNlICogMikgfHwgMSksXG4gICAgICAgICAgbCA9IGltYWdlRGF0YS5kYXRhLmxlbmd0aDtcblxuICAgICAgLy8gU3BsaXQgaW1hZ2UgZGF0YSAtIGZvciB0b2xlcmFuY2UgPiAxLCBwaXhlbERhdGFTaXplID0gNDtcbiAgICAgIGZvciAoaSA9IDM7IGkgPCBsOyBpICs9IDQpIHtcbiAgICAgICAgdGVtcCA9IGltYWdlRGF0YS5kYXRhW2ldO1xuICAgICAgICBfaXNUcmFuc3BhcmVudCA9IHRlbXAgPD0gMDtcbiAgICAgICAgaWYgKF9pc1RyYW5zcGFyZW50ID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrOyAvLyBTdG9wIGlmIGNvbG91ciBmb3VuZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGltYWdlRGF0YSA9IG51bGw7XG5cbiAgICAgIHJldHVybiBfaXNUcmFuc3BhcmVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgcHJlc2VydmVBc3BlY3RSYXRpbyBhdHRyaWJ1dGUgZnJvbSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSB0byBiZSBwYXJzZWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGFuIG9iamVjdCBjb250YWluaW5nIGFsaWduIGFuZCBtZWV0T3JTbGljZSBhdHRyaWJ1dGVcbiAgICAgKi9cbiAgICBwYXJzZVByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGU6IGZ1bmN0aW9uKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIG1lZXRPclNsaWNlID0gJ21lZXQnLCBhbGlnblggPSAnTWlkJywgYWxpZ25ZID0gJ01pZCcsXG4gICAgICAgICAgYXNwZWN0UmF0aW9BdHRycyA9IGF0dHJpYnV0ZS5zcGxpdCgnICcpLCBhbGlnbjtcblxuICAgICAgaWYgKGFzcGVjdFJhdGlvQXR0cnMgJiYgYXNwZWN0UmF0aW9BdHRycy5sZW5ndGgpIHtcbiAgICAgICAgbWVldE9yU2xpY2UgPSBhc3BlY3RSYXRpb0F0dHJzLnBvcCgpO1xuICAgICAgICBpZiAobWVldE9yU2xpY2UgIT09ICdtZWV0JyAmJiBtZWV0T3JTbGljZSAhPT0gJ3NsaWNlJykge1xuICAgICAgICAgIGFsaWduID0gbWVldE9yU2xpY2U7XG4gICAgICAgICAgbWVldE9yU2xpY2UgPSAnbWVldCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXNwZWN0UmF0aW9BdHRycy5sZW5ndGgpIHtcbiAgICAgICAgICBhbGlnbiA9IGFzcGVjdFJhdGlvQXR0cnMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vZGl2aWRlIGFsaWduIGluIGFsaWduWCBhbmQgYWxpZ25ZXG4gICAgICBhbGlnblggPSBhbGlnbiAhPT0gJ25vbmUnID8gYWxpZ24uc2xpY2UoMSwgNCkgOiAnbm9uZSc7XG4gICAgICBhbGlnblkgPSBhbGlnbiAhPT0gJ25vbmUnID8gYWxpZ24uc2xpY2UoNSwgOCkgOiAnbm9uZSc7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZWV0T3JTbGljZTogbWVldE9yU2xpY2UsXG4gICAgICAgIGFsaWduWDogYWxpZ25YLFxuICAgICAgICBhbGlnblk6IGFsaWduWVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgY2hhciB3aWR0aHMgY2FjaGUgZm9yIGEgZm9udCBmYW1pbHkuXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtmb250RmFtaWx5XSBmb250IGZhbWlseSB0byBjbGVhclxuICAgICAqL1xuICAgIGNsZWFyRmFicmljRm9udENhY2hlOiBmdW5jdGlvbihmb250RmFtaWx5KSB7XG4gICAgICBpZiAoIWZvbnRGYW1pbHkpIHtcbiAgICAgICAgZmFicmljLmNoYXJXaWR0aHNDYWNoZSA9IHsgfTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZhYnJpYy5jaGFyV2lkdGhzQ2FjaGVbZm9udEZhbWlseV0pIHtcbiAgICAgICAgZGVsZXRlIGZhYnJpYy5jaGFyV2lkdGhzQ2FjaGVbZm9udEZhbWlseV07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBhcmNUb1NlZ21lbnRzQ2FjaGUgPSB7IH0sXG4gICAgICBzZWdtZW50VG9CZXppZXJDYWNoZSA9IHsgfSxcbiAgICAgIGJvdW5kc09mQ3VydmVDYWNoZSA9IHsgfSxcbiAgICAgIF9qb2luID0gQXJyYXkucHJvdG90eXBlLmpvaW47XG5cbiAgLyogQWRhcHRlZCBmcm9tIGh0dHA6Ly9keHIubW96aWxsYS5vcmcvbW96aWxsYS1jZW50cmFsL3NvdXJjZS9jb250ZW50L3N2Zy9jb250ZW50L3NyYy9uc1NWR1BhdGhEYXRhUGFyc2VyLmNwcFxuICAgKiBieSBBbmRyZWEgQm9nYXp6aSBjb2RlIGlzIHVuZGVyIE1QTC4gaWYgeW91IGRvbid0IGhhdmUgYSBjb3B5IG9mIHRoZSBsaWNlbnNlIHlvdSBjYW4gdGFrZSBpdCBoZXJlXG4gICAqIGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wL1xuICAgKi9cbiAgZnVuY3Rpb24gYXJjVG9TZWdtZW50cyh0b1gsIHRvWSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdGF0ZVgpIHtcbiAgICB2YXIgYXJnc1N0cmluZyA9IF9qb2luLmNhbGwoYXJndW1lbnRzKTtcbiAgICBpZiAoYXJjVG9TZWdtZW50c0NhY2hlW2FyZ3NTdHJpbmddKSB7XG4gICAgICByZXR1cm4gYXJjVG9TZWdtZW50c0NhY2hlW2FyZ3NTdHJpbmddO1xuICAgIH1cblxuICAgIHZhciBQSSA9IE1hdGguUEksIHRoID0gcm90YXRlWCAqIFBJIC8gMTgwLFxuICAgICAgICBzaW5UaCA9IE1hdGguc2luKHRoKSxcbiAgICAgICAgY29zVGggPSBNYXRoLmNvcyh0aCksXG4gICAgICAgIGZyb21YID0gMCwgZnJvbVkgPSAwO1xuXG4gICAgcnggPSBNYXRoLmFicyhyeCk7XG4gICAgcnkgPSBNYXRoLmFicyhyeSk7XG5cbiAgICB2YXIgcHggPSAtY29zVGggKiB0b1ggKiAwLjUgLSBzaW5UaCAqIHRvWSAqIDAuNSxcbiAgICAgICAgcHkgPSAtY29zVGggKiB0b1kgKiAwLjUgKyBzaW5UaCAqIHRvWCAqIDAuNSxcbiAgICAgICAgcngyID0gcnggKiByeCwgcnkyID0gcnkgKiByeSwgcHkyID0gcHkgKiBweSwgcHgyID0gcHggKiBweCxcbiAgICAgICAgcGwgPSByeDIgKiByeTIgLSByeDIgKiBweTIgLSByeTIgKiBweDIsXG4gICAgICAgIHJvb3QgPSAwO1xuXG4gICAgaWYgKHBsIDwgMCkge1xuICAgICAgdmFyIHMgPSBNYXRoLnNxcnQoMSAtIHBsIC8gKHJ4MiAqIHJ5MikpO1xuICAgICAgcnggKj0gcztcbiAgICAgIHJ5ICo9IHM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcm9vdCA9IChsYXJnZSA9PT0gc3dlZXAgPyAtMS4wIDogMS4wKSAqXG4gICAgICAgICAgICAgIE1hdGguc3FydCggcGwgLyAocngyICogcHkyICsgcnkyICogcHgyKSk7XG4gICAgfVxuXG4gICAgdmFyIGN4ID0gcm9vdCAqIHJ4ICogcHkgLyByeSxcbiAgICAgICAgY3kgPSAtcm9vdCAqIHJ5ICogcHggLyByeCxcbiAgICAgICAgY3gxID0gY29zVGggKiBjeCAtIHNpblRoICogY3kgKyB0b1ggKiAwLjUsXG4gICAgICAgIGN5MSA9IHNpblRoICogY3ggKyBjb3NUaCAqIGN5ICsgdG9ZICogMC41LFxuICAgICAgICBtVGhldGEgPSBjYWxjVmVjdG9yQW5nbGUoMSwgMCwgKHB4IC0gY3gpIC8gcngsIChweSAtIGN5KSAvIHJ5KSxcbiAgICAgICAgZHRoZXRhID0gY2FsY1ZlY3RvckFuZ2xlKChweCAtIGN4KSAvIHJ4LCAocHkgLSBjeSkgLyByeSwgKC1weCAtIGN4KSAvIHJ4LCAoLXB5IC0gY3kpIC8gcnkpO1xuXG4gICAgaWYgKHN3ZWVwID09PSAwICYmIGR0aGV0YSA+IDApIHtcbiAgICAgIGR0aGV0YSAtPSAyICogUEk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN3ZWVwID09PSAxICYmIGR0aGV0YSA8IDApIHtcbiAgICAgIGR0aGV0YSArPSAyICogUEk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBpbnRvIGN1YmljIGJlemllciBzZWdtZW50cyA8PSA5MGRlZ1xuICAgIHZhciBzZWdtZW50cyA9IE1hdGguY2VpbChNYXRoLmFicyhkdGhldGEgLyBQSSAqIDIpKSxcbiAgICAgICAgcmVzdWx0ID0gW10sIG1EZWx0YSA9IGR0aGV0YSAvIHNlZ21lbnRzLFxuICAgICAgICBtVCA9IDggLyAzICogTWF0aC5zaW4obURlbHRhIC8gNCkgKiBNYXRoLnNpbihtRGVsdGEgLyA0KSAvIE1hdGguc2luKG1EZWx0YSAvIDIpLFxuICAgICAgICB0aDMgPSBtVGhldGEgKyBtRGVsdGE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzOyBpKyspIHtcbiAgICAgIHJlc3VsdFtpXSA9IHNlZ21lbnRUb0JlemllcihtVGhldGEsIHRoMywgY29zVGgsIHNpblRoLCByeCwgcnksIGN4MSwgY3kxLCBtVCwgZnJvbVgsIGZyb21ZKTtcbiAgICAgIGZyb21YID0gcmVzdWx0W2ldWzRdO1xuICAgICAgZnJvbVkgPSByZXN1bHRbaV1bNV07XG4gICAgICBtVGhldGEgPSB0aDM7XG4gICAgICB0aDMgKz0gbURlbHRhO1xuICAgIH1cbiAgICBhcmNUb1NlZ21lbnRzQ2FjaGVbYXJnc1N0cmluZ10gPSByZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlZ21lbnRUb0Jlemllcih0aDIsIHRoMywgY29zVGgsIHNpblRoLCByeCwgcnksIGN4MSwgY3kxLCBtVCwgZnJvbVgsIGZyb21ZKSB7XG4gICAgdmFyIGFyZ3NTdHJpbmcyID0gX2pvaW4uY2FsbChhcmd1bWVudHMpO1xuICAgIGlmIChzZWdtZW50VG9CZXppZXJDYWNoZVthcmdzU3RyaW5nMl0pIHtcbiAgICAgIHJldHVybiBzZWdtZW50VG9CZXppZXJDYWNoZVthcmdzU3RyaW5nMl07XG4gICAgfVxuXG4gICAgdmFyIGNvc3RoMiA9IE1hdGguY29zKHRoMiksXG4gICAgICAgIHNpbnRoMiA9IE1hdGguc2luKHRoMiksXG4gICAgICAgIGNvc3RoMyA9IE1hdGguY29zKHRoMyksXG4gICAgICAgIHNpbnRoMyA9IE1hdGguc2luKHRoMyksXG4gICAgICAgIHRvWCA9IGNvc1RoICogcnggKiBjb3N0aDMgLSBzaW5UaCAqIHJ5ICogc2ludGgzICsgY3gxLFxuICAgICAgICB0b1kgPSBzaW5UaCAqIHJ4ICogY29zdGgzICsgY29zVGggKiByeSAqIHNpbnRoMyArIGN5MSxcbiAgICAgICAgY3AxWCA9IGZyb21YICsgbVQgKiAoIC1jb3NUaCAqIHJ4ICogc2ludGgyIC0gc2luVGggKiByeSAqIGNvc3RoMiksXG4gICAgICAgIGNwMVkgPSBmcm9tWSArIG1UICogKCAtc2luVGggKiByeCAqIHNpbnRoMiArIGNvc1RoICogcnkgKiBjb3N0aDIpLFxuICAgICAgICBjcDJYID0gdG9YICsgbVQgKiAoIGNvc1RoICogcnggKiBzaW50aDMgKyBzaW5UaCAqIHJ5ICogY29zdGgzKSxcbiAgICAgICAgY3AyWSA9IHRvWSArIG1UICogKCBzaW5UaCAqIHJ4ICogc2ludGgzIC0gY29zVGggKiByeSAqIGNvc3RoMyk7XG5cbiAgICBzZWdtZW50VG9CZXppZXJDYWNoZVthcmdzU3RyaW5nMl0gPSBbXG4gICAgICBjcDFYLCBjcDFZLFxuICAgICAgY3AyWCwgY3AyWSxcbiAgICAgIHRvWCwgdG9ZXG4gICAgXTtcbiAgICByZXR1cm4gc2VnbWVudFRvQmV6aWVyQ2FjaGVbYXJnc1N0cmluZzJdO1xuICB9XG5cbiAgLypcbiAgICogUHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY2FsY1ZlY3RvckFuZ2xlKHV4LCB1eSwgdngsIHZ5KSB7XG4gICAgdmFyIHRhID0gTWF0aC5hdGFuMih1eSwgdXgpLFxuICAgICAgICB0YiA9IE1hdGguYXRhbjIodnksIHZ4KTtcbiAgICBpZiAodGIgPj0gdGEpIHtcbiAgICAgIHJldHVybiB0YiAtIHRhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiAyICogTWF0aC5QSSAtICh0YSAtIHRiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRHJhd3MgYXJjXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZ4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmeVxuICAgKiBAcGFyYW0ge0FycmF5fSBjb29yZHNcbiAgICovXG4gIGZhYnJpYy51dGlsLmRyYXdBcmMgPSBmdW5jdGlvbihjdHgsIGZ4LCBmeSwgY29vcmRzKSB7XG4gICAgdmFyIHJ4ID0gY29vcmRzWzBdLFxuICAgICAgICByeSA9IGNvb3Jkc1sxXSxcbiAgICAgICAgcm90ID0gY29vcmRzWzJdLFxuICAgICAgICBsYXJnZSA9IGNvb3Jkc1szXSxcbiAgICAgICAgc3dlZXAgPSBjb29yZHNbNF0sXG4gICAgICAgIHR4ID0gY29vcmRzWzVdLFxuICAgICAgICB0eSA9IGNvb3Jkc1s2XSxcbiAgICAgICAgc2VncyA9IFtbXSwgW10sIFtdLCBbXV0sXG4gICAgICAgIHNlZ3NOb3JtID0gYXJjVG9TZWdtZW50cyh0eCAtIGZ4LCB0eSAtIGZ5LCByeCwgcnksIGxhcmdlLCBzd2VlcCwgcm90KTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWdzTm9ybS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgc2Vnc1tpXVswXSA9IHNlZ3NOb3JtW2ldWzBdICsgZng7XG4gICAgICBzZWdzW2ldWzFdID0gc2Vnc05vcm1baV1bMV0gKyBmeTtcbiAgICAgIHNlZ3NbaV1bMl0gPSBzZWdzTm9ybVtpXVsyXSArIGZ4O1xuICAgICAgc2Vnc1tpXVszXSA9IHNlZ3NOb3JtW2ldWzNdICsgZnk7XG4gICAgICBzZWdzW2ldWzRdID0gc2Vnc05vcm1baV1bNF0gKyBmeDtcbiAgICAgIHNlZ3NbaV1bNV0gPSBzZWdzTm9ybVtpXVs1XSArIGZ5O1xuICAgICAgY3R4LmJlemllckN1cnZlVG8uYXBwbHkoY3R4LCBzZWdzW2ldKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBib3VuZGluZyBib3ggb2YgYSBlbGxpcHRpYy1hcmNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZ4IHN0YXJ0IHBvaW50IG9mIGFyY1xuICAgKiBAcGFyYW0ge051bWJlcn0gZnlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJ4IGhvcml6b250YWwgcmFkaXVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByeSB2ZXJ0aWNhbCByYWRpdXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJvdCBhbmdsZSBvZiBob3Jpem9udGFsIGF4ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gbGFyZ2UgMSBvciAwLCB3aGF0ZXZlciB0aGUgYXJjIGlzIHRoZSBiaWcgb3IgdGhlIHNtYWxsIG9uIHRoZSAyIHBvaW50c1xuICAgKiBAcGFyYW0ge051bWJlcn0gc3dlZXAgMSBvciAwLCAxIGNsb2Nrd2lzZSBvciBjb3VudGVyY2xvY2t3aXNlIGRpcmVjdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gdHggZW5kIHBvaW50IG9mIGFyY1xuICAgKiBAcGFyYW0ge051bWJlcn0gdHlcbiAgICovXG4gIGZhYnJpYy51dGlsLmdldEJvdW5kc09mQXJjID0gZnVuY3Rpb24oZngsIGZ5LCByeCwgcnksIHJvdCwgbGFyZ2UsIHN3ZWVwLCB0eCwgdHkpIHtcblxuICAgIHZhciBmcm9tWCA9IDAsIGZyb21ZID0gMCwgYm91bmQsIGJvdW5kcyA9IFtdLFxuICAgICAgICBzZWdzID0gYXJjVG9TZWdtZW50cyh0eCAtIGZ4LCB0eSAtIGZ5LCByeCwgcnksIGxhcmdlLCBzd2VlcCwgcm90KTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBib3VuZCA9IGdldEJvdW5kc09mQ3VydmUoZnJvbVgsIGZyb21ZLCBzZWdzW2ldWzBdLCBzZWdzW2ldWzFdLCBzZWdzW2ldWzJdLCBzZWdzW2ldWzNdLCBzZWdzW2ldWzRdLCBzZWdzW2ldWzVdKTtcbiAgICAgIGJvdW5kcy5wdXNoKHsgeDogYm91bmRbMF0ueCArIGZ4LCB5OiBib3VuZFswXS55ICsgZnkgfSk7XG4gICAgICBib3VuZHMucHVzaCh7IHg6IGJvdW5kWzFdLnggKyBmeCwgeTogYm91bmRbMV0ueSArIGZ5IH0pO1xuICAgICAgZnJvbVggPSBzZWdzW2ldWzRdO1xuICAgICAgZnJvbVkgPSBzZWdzW2ldWzVdO1xuICAgIH1cbiAgICByZXR1cm4gYm91bmRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgYm91bmRpbmcgYm94IG9mIGEgYmV6aWVyY3VydmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgwIHN0YXJ0aW5nIHBvaW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5MFxuICAgKiBAcGFyYW0ge051bWJlcn0geDEgZmlyc3QgY29udHJvbCBwb2ludFxuICAgKiBAcGFyYW0ge051bWJlcn0geTFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgyIHNlY29uZG8gY29udHJvbCBwb2ludFxuICAgKiBAcGFyYW0ge051bWJlcn0geTJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgzIGVuZCBvZiBiZWl6ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkzXG4gICAqL1xuICAvLyB0YWtlbiBmcm9tIGh0dHA6Ly9qc2Jpbi5jb20vaXZvbWlxLzU2L2VkaXQgIG5vIGNyZWRpdHMgYXZhaWxhYmxlIGZvciB0aGF0LlxuICBmdW5jdGlvbiBnZXRCb3VuZHNPZkN1cnZlKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIHZhciBhcmdzU3RyaW5nID0gX2pvaW4uY2FsbChhcmd1bWVudHMpO1xuICAgIGlmIChib3VuZHNPZkN1cnZlQ2FjaGVbYXJnc1N0cmluZ10pIHtcbiAgICAgIHJldHVybiBib3VuZHNPZkN1cnZlQ2FjaGVbYXJnc1N0cmluZ107XG4gICAgfVxuXG4gICAgdmFyIHNxcnQgPSBNYXRoLnNxcnQsXG4gICAgICAgIG1pbiA9IE1hdGgubWluLCBtYXggPSBNYXRoLm1heCxcbiAgICAgICAgYWJzID0gTWF0aC5hYnMsIHR2YWx1ZXMgPSBbXSxcbiAgICAgICAgYm91bmRzID0gW1tdLCBbXV0sXG4gICAgICAgIGEsIGIsIGMsIHQsIHQxLCB0MiwgYjJhYywgc3FydGIyYWM7XG5cbiAgICBiID0gNiAqIHgwIC0gMTIgKiB4MSArIDYgKiB4MjtcbiAgICBhID0gLTMgKiB4MCArIDkgKiB4MSAtIDkgKiB4MiArIDMgKiB4MztcbiAgICBjID0gMyAqIHgxIC0gMyAqIHgwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyArK2kpIHtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBiID0gNiAqIHkwIC0gMTIgKiB5MSArIDYgKiB5MjtcbiAgICAgICAgYSA9IC0zICogeTAgKyA5ICogeTEgLSA5ICogeTIgKyAzICogeTM7XG4gICAgICAgIGMgPSAzICogeTEgLSAzICogeTA7XG4gICAgICB9XG5cbiAgICAgIGlmIChhYnMoYSkgPCAxZS0xMikge1xuICAgICAgICBpZiAoYWJzKGIpIDwgMWUtMTIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0ID0gLWMgLyBiO1xuICAgICAgICBpZiAoMCA8IHQgJiYgdCA8IDEpIHtcbiAgICAgICAgICB0dmFsdWVzLnB1c2godCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBiMmFjID0gYiAqIGIgLSA0ICogYyAqIGE7XG4gICAgICBpZiAoYjJhYyA8IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzcXJ0YjJhYyA9IHNxcnQoYjJhYyk7XG4gICAgICB0MSA9ICgtYiArIHNxcnRiMmFjKSAvICgyICogYSk7XG4gICAgICBpZiAoMCA8IHQxICYmIHQxIDwgMSkge1xuICAgICAgICB0dmFsdWVzLnB1c2godDEpO1xuICAgICAgfVxuICAgICAgdDIgPSAoLWIgLSBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgICAgaWYgKDAgPCB0MiAmJiB0MiA8IDEpIHtcbiAgICAgICAgdHZhbHVlcy5wdXNoKHQyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgeCwgeSwgaiA9IHR2YWx1ZXMubGVuZ3RoLCBqbGVuID0gaiwgbXQ7XG4gICAgd2hpbGUgKGotLSkge1xuICAgICAgdCA9IHR2YWx1ZXNbal07XG4gICAgICBtdCA9IDEgLSB0O1xuICAgICAgeCA9IChtdCAqIG10ICogbXQgKiB4MCkgKyAoMyAqIG10ICogbXQgKiB0ICogeDEpICsgKDMgKiBtdCAqIHQgKiB0ICogeDIpICsgKHQgKiB0ICogdCAqIHgzKTtcbiAgICAgIGJvdW5kc1swXVtqXSA9IHg7XG5cbiAgICAgIHkgPSAobXQgKiBtdCAqIG10ICogeTApICsgKDMgKiBtdCAqIG10ICogdCAqIHkxKSArICgzICogbXQgKiB0ICogdCAqIHkyKSArICh0ICogdCAqIHQgKiB5Myk7XG4gICAgICBib3VuZHNbMV1bal0gPSB5O1xuICAgIH1cblxuICAgIGJvdW5kc1swXVtqbGVuXSA9IHgwO1xuICAgIGJvdW5kc1sxXVtqbGVuXSA9IHkwO1xuICAgIGJvdW5kc1swXVtqbGVuICsgMV0gPSB4MztcbiAgICBib3VuZHNbMV1bamxlbiArIDFdID0geTM7XG4gICAgdmFyIHJlc3VsdCA9IFtcbiAgICAgIHtcbiAgICAgICAgeDogbWluLmFwcGx5KG51bGwsIGJvdW5kc1swXSksXG4gICAgICAgIHk6IG1pbi5hcHBseShudWxsLCBib3VuZHNbMV0pXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB4OiBtYXguYXBwbHkobnVsbCwgYm91bmRzWzBdKSxcbiAgICAgICAgeTogbWF4LmFwcGx5KG51bGwsIGJvdW5kc1sxXSlcbiAgICAgIH1cbiAgICBdO1xuICAgIGJvdW5kc09mQ3VydmVDYWNoZVthcmdzU3RyaW5nXSA9IHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSA9IGdldEJvdW5kc09mQ3VydmU7XG5cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAvKiBfRVM1X0NPTVBBVF9TVEFSVF8gKi9cblxuICBpZiAoIUFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgLyoqXG4gICAgICogRmluZHMgaW5kZXggb2YgYW4gZWxlbWVudCBpbiBhbiBhcnJheVxuICAgICAqIEBwYXJhbSB7Kn0gc2VhcmNoRWxlbWVudFxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIChzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggKi8gKSB7XG4gICAgICBpZiAodGhpcyA9PT0gdm9pZCAwIHx8IHRoaXMgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgfVxuICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyksIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgbiA9IDA7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbiA9IE51bWJlcihhcmd1bWVudHNbMV0pO1xuICAgICAgICBpZiAobiAhPT0gbikgeyAvLyBzaG9ydGN1dCBmb3IgdmVyaWZ5aW5nIGlmIGl0J3MgTmFOXG4gICAgICAgICAgbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobiAhPT0gMCAmJiBuICE9PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgJiYgbiAhPT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSB7XG4gICAgICAgICAgbiA9IChuID4gMCB8fCAtMSkgKiBNYXRoLmZsb29yKE1hdGguYWJzKG4pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG4gPj0gbGVuKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBrID0gbiA+PSAwID8gbiA6IE1hdGgubWF4KGxlbiAtIE1hdGguYWJzKG4pLCAwKTtcbiAgICAgIGZvciAoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgaWYgKGsgaW4gdCAmJiB0W2tdID09PSBzZWFyY2hFbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFBcnJheS5wcm90b3R5cGUuZm9yRWFjaCkge1xuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIGFuIGFycmF5LCBpbnZva2luZyBjYWxsYmFjayBmb3IgZWFjaCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQ2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIENvbnRleHQgdG8gaW52b2tlIGNhbGxiYWNrIGluXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihmbiwgY29udGV4dCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMubGVuZ3RoID4+PiAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGkgaW4gdGhpcykge1xuICAgICAgICAgIGZuLmNhbGwoY29udGV4dCwgdGhpc1tpXSwgaSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaWYgKCFBcnJheS5wcm90b3R5cGUubWFwKSB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlc3VsdCBvZiBpdGVyYXRpbmcgb3ZlciBhbiBhcnJheSwgaW52b2tpbmcgY2FsbGJhY2sgZm9yIGVhY2ggZWxlbWVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIENhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0IHRvIGludm9rZSBjYWxsYmFjayBpblxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIEFycmF5LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbihmbiwgY29udGV4dCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMubGVuZ3RoID4+PiAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGkgaW4gdGhpcykge1xuICAgICAgICAgIHJlc3VsdFtpXSA9IGZuLmNhbGwoY29udGV4dCwgdGhpc1tpXSwgaSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxuXG4gIGlmICghQXJyYXkucHJvdG90eXBlLmV2ZXJ5KSB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGEgY2FsbGJhY2sgcmV0dXJucyB0cnV0aHkgdmFsdWUgZm9yIGFsbCBlbGVtZW50cyBpbiBhbiBhcnJheVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIENhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0IHRvIGludm9rZSBjYWxsYmFjayBpblxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgQXJyYXkucHJvdG90eXBlLmV2ZXJ5ID0gZnVuY3Rpb24oZm4sIGNvbnRleHQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmxlbmd0aCA+Pj4gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChpIGluIHRoaXMgJiYgIWZuLmNhbGwoY29udGV4dCwgdGhpc1tpXSwgaSwgdGhpcykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cblxuICBpZiAoIUFycmF5LnByb3RvdHlwZS5zb21lKSB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGEgY2FsbGJhY2sgcmV0dXJucyB0cnV0aHkgdmFsdWUgZm9yIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIGFuIGFycmF5XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQ2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIENvbnRleHQgdG8gaW52b2tlIGNhbGxiYWNrIGluXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBBcnJheS5wcm90b3R5cGUuc29tZSA9IGZ1bmN0aW9uKGZuLCBjb250ZXh0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5sZW5ndGggPj4+IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaSBpbiB0aGlzICYmIGZuLmNhbGwoY29udGV4dCwgdGhpc1tpXSwgaSwgdGhpcykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH1cblxuICBpZiAoIUFycmF5LnByb3RvdHlwZS5maWx0ZXIpIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgaXRlcmF0aW5nIG92ZXIgZWxlbWVudHMgaW4gYW4gYXJyYXlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBDYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gQ29udGV4dCB0byBpbnZva2UgY2FsbGJhY2sgaW5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBBcnJheS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24oZm4sIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSwgdmFsO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMubGVuZ3RoID4+PiAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGkgaW4gdGhpcykge1xuICAgICAgICAgIHZhbCA9IHRoaXNbaV07IC8vIGluIGNhc2UgZm4gbXV0YXRlcyB0aGlzXG4gICAgICAgICAgaWYgKGZuLmNhbGwoY29udGV4dCwgdmFsLCBpLCB0aGlzKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxuXG4gIGlmICghQXJyYXkucHJvdG90eXBlLnJlZHVjZSkge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgXCJmb2xkZWRcIiAocmVkdWNlZCkgcmVzdWx0IG9mIGl0ZXJhdGluZyBvdmVyIGVsZW1lbnRzIGluIGFuIGFycmF5XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQ2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqL1xuICAgIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbihmbiAvKiwgaW5pdGlhbCovKSB7XG4gICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGggPj4+IDAsXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgcnY7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBydiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgaWYgKGkgaW4gdGhpcykge1xuICAgICAgICAgICAgcnYgPSB0aGlzW2krK107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaWYgYXJyYXkgY29udGFpbnMgbm8gdmFsdWVzLCBubyBpbml0aWFsIHZhbHVlIHRvIHJldHVyblxuICAgICAgICAgIGlmICgrK2kgPj0gbGVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0cnVlKTtcbiAgICAgIH1cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGkgaW4gdGhpcykge1xuICAgICAgICAgIHJ2ID0gZm4uY2FsbChudWxsLCBydiwgdGhpc1tpXSwgaSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBydjtcbiAgICB9O1xuICB9XG5cbiAgLyogX0VTNV9DT01QQVRfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBJbnZva2VzIG1ldGhvZCBvbiBhbGwgaXRlbXMgaW4gYSBnaXZlbiBhcnJheVxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuYXJyYXlcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgQXJyYXkgdG8gaXRlcmF0ZSBvdmVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgTmFtZSBvZiBhIG1ldGhvZCB0byBpbnZva2VcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBmdW5jdGlvbiBpbnZva2UoYXJyYXksIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJlc3VsdFtpXSA9IGFyZ3MubGVuZ3RoID8gYXJyYXlbaV1bbWV0aG9kXS5hcHBseShhcnJheVtpXSwgYXJncykgOiBhcnJheVtpXVttZXRob2RdLmNhbGwoYXJyYXlbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIG1heGltdW0gdmFsdWUgaW4gYXJyYXkgKG5vdCBuZWNlc3NhcmlseSBcImZpcnN0XCIgb25lKVxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuYXJyYXlcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgQXJyYXkgdG8gaXRlcmF0ZSBvdmVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBieVByb3BlcnR5XG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBmdW5jdGlvbiBtYXgoYXJyYXksIGJ5UHJvcGVydHkpIHtcbiAgICByZXR1cm4gZmluZChhcnJheSwgYnlQcm9wZXJ0eSwgZnVuY3Rpb24odmFsdWUxLCB2YWx1ZTIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTEgPj0gdmFsdWUyO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIG1pbmltdW0gdmFsdWUgaW4gYXJyYXkgKG5vdCBuZWNlc3NhcmlseSBcImZpcnN0XCIgb25lKVxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuYXJyYXlcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgQXJyYXkgdG8gaXRlcmF0ZSBvdmVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBieVByb3BlcnR5XG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBmdW5jdGlvbiBtaW4oYXJyYXksIGJ5UHJvcGVydHkpIHtcbiAgICByZXR1cm4gZmluZChhcnJheSwgYnlQcm9wZXJ0eSwgZnVuY3Rpb24odmFsdWUxLCB2YWx1ZTIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTEgPCB2YWx1ZTI7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGZpbGwoYXJyYXksIHZhbHVlKSB7XG4gICAgdmFyIGsgPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGstLSkge1xuICAgICAgYXJyYXlba10gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaW5kKGFycmF5LCBieVByb3BlcnR5LCBjb25kaXRpb24pIHtcbiAgICBpZiAoIWFycmF5IHx8IGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpID0gYXJyYXkubGVuZ3RoIC0gMSxcbiAgICAgICAgcmVzdWx0ID0gYnlQcm9wZXJ0eSA/IGFycmF5W2ldW2J5UHJvcGVydHldIDogYXJyYXlbaV07XG4gICAgaWYgKGJ5UHJvcGVydHkpIHtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbihhcnJheVtpXVtieVByb3BlcnR5XSwgcmVzdWx0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGFycmF5W2ldW2J5UHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAoY29uZGl0aW9uKGFycmF5W2ldLCByZXN1bHQpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gYXJyYXlbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlIGZhYnJpYy51dGlsLmFycmF5XG4gICAqL1xuICBmYWJyaWMudXRpbC5hcnJheSA9IHtcbiAgICBmaWxsOiBmaWxsLFxuICAgIGludm9rZTogaW52b2tlLFxuICAgIG1pbjogbWluLFxuICAgIG1heDogbWF4XG4gIH07XG5cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICogQ29waWVzIGFsbCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygb25lIGpzIG9iamVjdCB0byBhbm90aGVyXG4gICAqIERvZXMgbm90IGNsb25lIG9yIGV4dGVuZCBmYWJyaWMuT2JqZWN0IHN1YmNsYXNzZXMuXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5vYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc3RpbmF0aW9uIFdoZXJlIHRvIGNvcHkgdG9cbiAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBXaGVyZSB0byBjb3B5IGZyb21cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cblxuICBmdW5jdGlvbiBleHRlbmQoZGVzdGluYXRpb24sIHNvdXJjZSwgZGVlcCkge1xuICAgIC8vIEpTY3JpcHQgRG9udEVudW0gYnVnIGlzIG5vdCB0YWtlbiBjYXJlIG9mXG4gICAgLy8gdGhlIGRlZXAgY2xvbmUgaXMgZm9yIGludGVybmFsIHVzZSwgaXMgbm90IG1lYW50IHRvIGF2b2lkXG4gICAgLy8gamF2YXNjcmlwdCB0cmFwcyBvciBjbG9uaW5nIGh0bWwgZWxlbWVudCBvciBzZWxmIHJlZmVyZW5jZWQgb2JqZWN0cy5cbiAgICBpZiAoZGVlcCkge1xuICAgICAgaWYgKCFmYWJyaWMuaXNMaWtlbHlOb2RlICYmIHNvdXJjZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgLy8gYXZvaWQgY2xvbmluZyBkZWVwIGltYWdlcywgY2FudmFzZXMsXG4gICAgICAgIGRlc3RpbmF0aW9uID0gc291cmNlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZGVzdGluYXRpb24gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGRlc3RpbmF0aW9uW2ldID0gZXh0ZW5kKHsgfSwgc291cmNlW2ldLCBkZWVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc291cmNlICYmIHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltwcm9wZXJ0eV0gPSBleHRlbmQoeyB9LCBzb3VyY2VbcHJvcGVydHldLCBkZWVwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyB0aGlzIHNvdW5kcyBvZGQgZm9yIGFuIGV4dGVuZCBidXQgaXMgb2sgZm9yIHJlY3Vyc2l2ZSB1c2VcbiAgICAgICAgZGVzdGluYXRpb24gPSBzb3VyY2U7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc291cmNlKSB7XG4gICAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnR5XSA9IHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGVtcHR5IG9iamVjdCBhbmQgY29waWVzIGFsbCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW5vdGhlciBvYmplY3QgdG8gaXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLm9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjbG9uZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBmdW5jdGlvbiBjbG9uZShvYmplY3QsIGRlZXApIHtcbiAgICByZXR1cm4gZXh0ZW5kKHsgfSwgb2JqZWN0LCBkZWVwKTtcbiAgfVxuXG4gIC8qKiBAbmFtZXNwYWNlIGZhYnJpYy51dGlsLm9iamVjdCAqL1xuICBmYWJyaWMudXRpbC5vYmplY3QgPSB7XG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgY2xvbmU6IGNsb25lXG4gIH07XG5cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8qIF9FUzVfQ09NUEFUX1NUQVJUXyAqL1xuICBpZiAoIVN0cmluZy5wcm90b3R5cGUudHJpbSkge1xuICAgIC8qKlxuICAgICAqIFRyaW1zIGEgc3RyaW5nIChyZW1vdmluZyB3aGl0ZXNwYWNlIGZyb20gdGhlIGJlZ2lubmluZyBhbmQgdGhlIGVuZClcbiAgICAgKiBAZnVuY3Rpb24gZXh0ZXJuYWw6U3RyaW5nI3RyaW1cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvVHJpbVwiPlN0cmluZyN0cmltIG9uIE1ETjwvYT5cbiAgICAgKi9cbiAgICBTdHJpbmcucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyB0aGlzIHRyaW0gaXMgbm90IGZ1bGx5IEVTMyBvciBFUzUgY29tcGxpYW50LCBidXQgaXQgc2hvdWxkIGNvdmVyIG1vc3QgY2FzZXMgZm9yIG5vd1xuICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZSgvXltcXHNcXHhBMF0rLywgJycpLnJlcGxhY2UoL1tcXHNcXHhBMF0rJC8sICcnKTtcbiAgICB9O1xuICB9XG4gIC8qIF9FUzVfQ09NUEFUX0VORF8gKi9cblxuICAvKipcbiAgICogQ2FtZWxpemVzIGEgc3RyaW5nXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5zdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gY2FtZWxpemVcbiAgICogQHJldHVybiB7U3RyaW5nfSBDYW1lbGl6ZWQgdmVyc2lvbiBvZiBhIHN0cmluZ1xuICAgKi9cbiAgZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8tKyguKT8vZywgZnVuY3Rpb24obWF0Y2gsIGNoYXJhY3Rlcikge1xuICAgICAgcmV0dXJuIGNoYXJhY3RlciA/IGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpIDogJyc7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FwaXRhbGl6ZXMgYSBzdHJpbmdcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLnN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFN0cmluZyB0byBjYXBpdGFsaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZpcnN0TGV0dGVyT25seV0gSWYgdHJ1ZSBvbmx5IGZpcnN0IGxldHRlciBpcyBjYXBpdGFsaXplZFxuICAgKiBhbmQgb3RoZXIgbGV0dGVycyBzdGF5IHVudG91Y2hlZCwgaWYgZmFsc2UgZmlyc3QgbGV0dGVyIGlzIGNhcGl0YWxpemVkXG4gICAqIGFuZCBvdGhlciBsZXR0ZXJzIGFyZSBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IENhcGl0YWxpemVkIHZlcnNpb24gb2YgYSBzdHJpbmdcbiAgICovXG4gIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nLCBmaXJzdExldHRlck9ubHkpIHtcbiAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICtcbiAgICAgIChmaXJzdExldHRlck9ubHkgPyBzdHJpbmcuc2xpY2UoMSkgOiBzdHJpbmcuc2xpY2UoMSkudG9Mb3dlckNhc2UoKSk7XG4gIH1cblxuICAvKipcbiAgICogRXNjYXBlcyBYTUwgaW4gYSBzdHJpbmdcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLnN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFN0cmluZyB0byBlc2NhcGVcbiAgICogQHJldHVybiB7U3RyaW5nfSBFc2NhcGVkIHZlcnNpb24gb2YgYSBzdHJpbmdcbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVhtbChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgICAgLnJlcGxhY2UoLycvZywgJyZhcG9zOycpXG4gICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG4gIH1cblxuICAvKipcbiAgICogU3RyaW5nIHV0aWxpdGllc1xuICAgKiBAbmFtZXNwYWNlIGZhYnJpYy51dGlsLnN0cmluZ1xuICAgKi9cbiAgZmFicmljLnV0aWwuc3RyaW5nID0ge1xuICAgIGNhbWVsaXplOiBjYW1lbGl6ZSxcbiAgICBjYXBpdGFsaXplOiBjYXBpdGFsaXplLFxuICAgIGVzY2FwZVhtbDogZXNjYXBlWG1sXG4gIH07XG59KSgpO1xuXG5cbi8qIF9FUzVfQ09NUEFUX1NUQVJUXyAqL1xuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSxcbiAgICAgIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LFxuICAgICAgRHVtbXkgPSBmdW5jdGlvbigpIHsgfTtcblxuICBpZiAoIUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSB7XG4gICAgLyoqXG4gICAgICogQ3Jvc3MtYnJvd3NlciBhcHByb3hpbWF0aW9uIG9mIEVTNSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAobm90IGZ1bGx5IHNwZWMgY29uZm9ybWluZylcbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kXCI+RnVuY3Rpb24jYmluZCBvbiBNRE48L2E+XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgT2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAgICAgKiBAcGFyYW0ge0FueVtdfSBWYWx1ZXMgdG8gcGFzcyB0byBhIGJvdW5kIGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICovXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbih0aGlzQXJnKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLCBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBib3VuZDtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhcHBseS5jYWxsKF90aGlzLCB0aGlzIGluc3RhbmNlb2YgRHVtbXkgPyB0aGlzIDogdGhpc0FyZywgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgICAgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYXBwbHkuY2FsbChfdGhpcywgdGhpcyBpbnN0YW5jZW9mIER1bW15ID8gdGhpcyA6IHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBEdW1teS5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcbiAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBEdW1teSgpO1xuXG4gICAgICByZXR1cm4gYm91bmQ7XG4gICAgfTtcbiAgfVxuXG59KSgpO1xuLyogX0VTNV9DT01QQVRfRU5EXyAqL1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbigpIHsgfSxcblxuICAgICAgSVNfRE9OVEVOVU1fQlVHR1kgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4geyB0b1N0cmluZzogMSB9KSB7XG4gICAgICAgICAgaWYgKHAgPT09ICd0b1N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KSgpLFxuXG4gICAgICAvKiogQGlnbm9yZSAqL1xuICAgICAgYWRkTWV0aG9kcyA9IGZ1bmN0aW9uKGtsYXNzLCBzb3VyY2UsIHBhcmVudCkge1xuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzb3VyY2UpIHtcblxuICAgICAgICAgIGlmIChwcm9wZXJ0eSBpbiBrbGFzcy5wcm90b3R5cGUgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIGtsYXNzLnByb3RvdHlwZVtwcm9wZXJ0eV0gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgKHNvdXJjZVtwcm9wZXJ0eV0gKyAnJykuaW5kZXhPZignY2FsbFN1cGVyJykgPiAtMSkge1xuXG4gICAgICAgICAgICBrbGFzcy5wcm90b3R5cGVbcHJvcGVydHldID0gKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIHZhciBzdXBlcmNsYXNzID0gdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3Iuc3VwZXJjbGFzcyA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBzb3VyY2VbcHJvcGVydHldLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzID0gc3VwZXJjbGFzcztcblxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eSAhPT0gJ2luaXRpYWxpemUnKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkocHJvcGVydHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZVtwcm9wZXJ0eV0gPSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChJU19ET05URU5VTV9CVUdHWSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykge1xuICAgICAgICAgICAgICBrbGFzcy5wcm90b3R5cGUudG9TdHJpbmcgPSBzb3VyY2UudG9TdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc291cmNlLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikge1xuICAgICAgICAgICAgICBrbGFzcy5wcm90b3R5cGUudmFsdWVPZiA9IHNvdXJjZS52YWx1ZU9mO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICBmdW5jdGlvbiBTdWJjbGFzcygpIHsgfVxuXG4gIGZ1bmN0aW9uIGNhbGxTdXBlcihtZXRob2ROYW1lKSB7XG4gICAgdmFyIGZuID0gdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzLnByb3RvdHlwZVttZXRob2ROYW1lXTtcbiAgICByZXR1cm4gKGFyZ3VtZW50cy5sZW5ndGggPiAxKVxuICAgICAgPyBmbi5hcHBseSh0aGlzLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpXG4gICAgICA6IGZuLmNhbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZvciBjcmVhdGlvbiBvZiBcImNsYXNzZXNcIi5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJlbnRdIG9wdGlvbmFsIFwiQ2xhc3NcIiB0byBpbmhlcml0IGZyb21cbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHNoYXJlZCBieSBhbGwgaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3NcbiAgICogICAgICAgICAgICAgICAgICAoYmUgY2FyZWZ1bCBtb2RpZnlpbmcgb2JqZWN0cyBkZWZpbmVkIGhlcmUgYXMgdGhpcyB3b3VsZCBhZmZlY3QgYWxsIGluc3RhbmNlcylcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUNsYXNzKCkge1xuICAgIHZhciBwYXJlbnQgPSBudWxsLFxuICAgICAgICBwcm9wZXJ0aWVzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0aWVzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwYXJlbnQgPSBwcm9wZXJ0aWVzLnNoaWZ0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGtsYXNzKCkge1xuICAgICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAga2xhc3Muc3VwZXJjbGFzcyA9IHBhcmVudDtcbiAgICBrbGFzcy5zdWJjbGFzc2VzID0gW107XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBTdWJjbGFzcy5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICAgICAga2xhc3MucHJvdG90eXBlID0gbmV3IFN1YmNsYXNzKCk7XG4gICAgICBwYXJlbnQuc3ViY2xhc3Nlcy5wdXNoKGtsYXNzKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGFkZE1ldGhvZHMoa2xhc3MsIHByb3BlcnRpZXNbaV0sIHBhcmVudCk7XG4gICAgfVxuICAgIGlmICgha2xhc3MucHJvdG90eXBlLmluaXRpYWxpemUpIHtcbiAgICAgIGtsYXNzLnByb3RvdHlwZS5pbml0aWFsaXplID0gZW1wdHlGdW5jdGlvbjtcbiAgICB9XG4gICAga2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0ga2xhc3M7XG4gICAga2xhc3MucHJvdG90eXBlLmNhbGxTdXBlciA9IGNhbGxTdXBlcjtcbiAgICByZXR1cm4ga2xhc3M7XG4gIH1cblxuICBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyA9IGNyZWF0ZUNsYXNzO1xufSkoKTtcblxuXG4oZnVuY3Rpb24gKCkge1xuXG4gIHZhciB1bmtub3duID0gJ3Vua25vd24nO1xuXG4gIC8qIEVWRU5UIEhBTkRMSU5HICovXG5cbiAgZnVuY3Rpb24gYXJlSG9zdE1ldGhvZHMob2JqZWN0KSB7XG4gICAgdmFyIG1ldGhvZE5hbWVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgdCwgaSwgbGVuID0gbWV0aG9kTmFtZXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdCA9IHR5cGVvZiBvYmplY3RbbWV0aG9kTmFtZXNbaV1dO1xuICAgICAgaWYgKCEoL14oPzpmdW5jdGlvbnxvYmplY3R8dW5rbm93bikkLykudGVzdCh0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqIEBpZ25vcmUgKi9cbiAgdmFyIGdldEVsZW1lbnQsXG4gICAgICBzZXRFbGVtZW50LFxuICAgICAgZ2V0VW5pcXVlSWQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdWlkID0gMDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQuX191bmlxdWVJRCB8fCAoZWxlbWVudC5fX3VuaXF1ZUlEID0gJ3VuaXF1ZUlEX18nICsgdWlkKyspO1xuICAgICAgICB9O1xuICAgICAgfSkoKTtcblxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGVtZW50cyA9IHsgfTtcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIGdldEVsZW1lbnQgPSBmdW5jdGlvbiAodWlkKSB7XG4gICAgICByZXR1cm4gZWxlbWVudHNbdWlkXTtcbiAgICB9O1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgc2V0RWxlbWVudCA9IGZ1bmN0aW9uICh1aWQsIGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnRzW3VpZF0gPSBlbGVtZW50O1xuICAgIH07XG4gIH0pKCk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXIodWlkLCBoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICB3cmFwcGVkSGFuZGxlcjogY3JlYXRlV3JhcHBlZEhhbmRsZXIodWlkLCBoYW5kbGVyKVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVXcmFwcGVkSGFuZGxlcih1aWQsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGhhbmRsZXIuY2FsbChnZXRFbGVtZW50KHVpZCksIGUgfHwgZmFicmljLndpbmRvdy5ldmVudCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZURpc3BhdGNoZXIodWlkLCBldmVudE5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChoYW5kbGVyc1t1aWRdICYmIGhhbmRsZXJzW3VpZF1bZXZlbnROYW1lXSkge1xuICAgICAgICB2YXIgaGFuZGxlcnNGb3JFdmVudCA9IGhhbmRsZXJzW3VpZF1bZXZlbnROYW1lXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGhhbmRsZXJzRm9yRXZlbnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBoYW5kbGVyc0ZvckV2ZW50W2ldLmNhbGwodGhpcywgZSB8fCBmYWJyaWMud2luZG93LmV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgc2hvdWxkVXNlQWRkTGlzdGVuZXJSZW1vdmVMaXN0ZW5lciA9IChcbiAgICAgICAgYXJlSG9zdE1ldGhvZHMoZmFicmljLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJ2FkZEV2ZW50TGlzdGVuZXInLCAncmVtb3ZlRXZlbnRMaXN0ZW5lcicpICYmXG4gICAgICAgIGFyZUhvc3RNZXRob2RzKGZhYnJpYy53aW5kb3csICdhZGRFdmVudExpc3RlbmVyJywgJ3JlbW92ZUV2ZW50TGlzdGVuZXInKSksXG5cbiAgICAgIHNob3VsZFVzZUF0dGFjaEV2ZW50RGV0YWNoRXZlbnQgPSAoXG4gICAgICAgIGFyZUhvc3RNZXRob2RzKGZhYnJpYy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICdhdHRhY2hFdmVudCcsICdkZXRhY2hFdmVudCcpICYmXG4gICAgICAgIGFyZUhvc3RNZXRob2RzKGZhYnJpYy53aW5kb3csICdhdHRhY2hFdmVudCcsICdkZXRhY2hFdmVudCcpKSxcblxuICAgICAgLy8gSUUgYnJhbmNoXG4gICAgICBsaXN0ZW5lcnMgPSB7IH0sXG5cbiAgICAgIC8vIERPTSBMMCBicmFuY2hcbiAgICAgIGhhbmRsZXJzID0geyB9LFxuXG4gICAgICBhZGRMaXN0ZW5lciwgcmVtb3ZlTGlzdGVuZXI7XG5cbiAgaWYgKHNob3VsZFVzZUFkZExpc3RlbmVyUmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIGFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgIH07XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICByZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9O1xuICB9XG5cbiAgZWxzZSBpZiAoc2hvdWxkVXNlQXR0YWNoRXZlbnREZXRhY2hFdmVudCkge1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICB2YXIgdWlkID0gZ2V0VW5pcXVlSWQoZWxlbWVudCk7XG4gICAgICBzZXRFbGVtZW50KHVpZCwgZWxlbWVudCk7XG4gICAgICBpZiAoIWxpc3RlbmVyc1t1aWRdKSB7XG4gICAgICAgIGxpc3RlbmVyc1t1aWRdID0geyB9O1xuICAgICAgfVxuICAgICAgaWYgKCFsaXN0ZW5lcnNbdWlkXVtldmVudE5hbWVdKSB7XG4gICAgICAgIGxpc3RlbmVyc1t1aWRdW2V2ZW50TmFtZV0gPSBbXTtcblxuICAgICAgfVxuICAgICAgdmFyIGxpc3RlbmVyID0gY3JlYXRlTGlzdGVuZXIodWlkLCBoYW5kbGVyKTtcbiAgICAgIGxpc3RlbmVyc1t1aWRdW2V2ZW50TmFtZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgICBlbGVtZW50LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudE5hbWUsIGxpc3RlbmVyLndyYXBwZWRIYW5kbGVyKTtcbiAgICB9O1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICB2YXIgdWlkID0gZ2V0VW5pcXVlSWQoZWxlbWVudCksIGxpc3RlbmVyO1xuICAgICAgaWYgKGxpc3RlbmVyc1t1aWRdICYmIGxpc3RlbmVyc1t1aWRdW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVyc1t1aWRdW2V2ZW50TmFtZV0ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyc1t1aWRdW2V2ZW50TmFtZV1baV07XG4gICAgICAgICAgaWYgKGxpc3RlbmVyICYmIGxpc3RlbmVyLmhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50TmFtZSwgbGlzdGVuZXIud3JhcHBlZEhhbmRsZXIpO1xuICAgICAgICAgICAgbGlzdGVuZXJzW3VpZF1bZXZlbnROYW1lXVtpXSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBlbHNlIHtcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIGFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgdmFyIHVpZCA9IGdldFVuaXF1ZUlkKGVsZW1lbnQpO1xuICAgICAgaWYgKCFoYW5kbGVyc1t1aWRdKSB7XG4gICAgICAgIGhhbmRsZXJzW3VpZF0gPSB7IH07XG4gICAgICB9XG4gICAgICBpZiAoIWhhbmRsZXJzW3VpZF1bZXZlbnROYW1lXSkge1xuICAgICAgICBoYW5kbGVyc1t1aWRdW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgICAgdmFyIGV4aXN0aW5nSGFuZGxlciA9IGVsZW1lbnRbJ29uJyArIGV2ZW50TmFtZV07XG4gICAgICAgIGlmIChleGlzdGluZ0hhbmRsZXIpIHtcbiAgICAgICAgICBoYW5kbGVyc1t1aWRdW2V2ZW50TmFtZV0ucHVzaChleGlzdGluZ0hhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRbJ29uJyArIGV2ZW50TmFtZV0gPSBjcmVhdGVEaXNwYXRjaGVyKHVpZCwgZXZlbnROYW1lKTtcbiAgICAgIH1cbiAgICAgIGhhbmRsZXJzW3VpZF1bZXZlbnROYW1lXS5wdXNoKGhhbmRsZXIpO1xuICAgIH07XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICByZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIHZhciB1aWQgPSBnZXRVbmlxdWVJZChlbGVtZW50KTtcbiAgICAgIGlmIChoYW5kbGVyc1t1aWRdICYmIGhhbmRsZXJzW3VpZF1bZXZlbnROYW1lXSkge1xuICAgICAgICB2YXIgaGFuZGxlcnNGb3JFdmVudCA9IGhhbmRsZXJzW3VpZF1bZXZlbnROYW1lXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGhhbmRsZXJzRm9yRXZlbnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAoaGFuZGxlcnNGb3JFdmVudFtpXSA9PT0gaGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlcnNGb3JFdmVudC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGFuIGVsZW1lbnRcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIgPSBhZGRMaXN0ZW5lcjtcblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lciBmcm9tIGFuIGVsZW1lbnRcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZmFicmljLnV0aWwucmVtb3ZlTGlzdGVuZXIgPSByZW1vdmVMaXN0ZW5lcjtcblxuICAvKipcbiAgICogQ3Jvc3MtYnJvd3NlciB3cmFwcGVyIGZvciBnZXR0aW5nIGV2ZW50J3MgY29vcmRpbmF0ZXNcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IEV2ZW50IG9iamVjdFxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UG9pbnRlcihldmVudCkge1xuICAgIGV2ZW50IHx8IChldmVudCA9IGZhYnJpYy53aW5kb3cuZXZlbnQpO1xuXG4gICAgdmFyIGVsZW1lbnQgPSBldmVudC50YXJnZXQgfHxcbiAgICAgICAgICAgICAgICAgICh0eXBlb2YgZXZlbnQuc3JjRWxlbWVudCAhPT0gdW5rbm93biA/IGV2ZW50LnNyY0VsZW1lbnQgOiBudWxsKSxcblxuICAgICAgICBzY3JvbGwgPSBmYWJyaWMudXRpbC5nZXRTY3JvbGxMZWZ0VG9wKGVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHBvaW50ZXJYKGV2ZW50KSArIHNjcm9sbC5sZWZ0LFxuICAgICAgeTogcG9pbnRlclkoZXZlbnQpICsgc2Nyb2xsLnRvcFxuICAgIH07XG4gIH1cblxuICB2YXIgcG9pbnRlclggPSBmdW5jdGlvbihldmVudCkge1xuICAgIC8vIGxvb2tzIGxpa2UgaW4gSUUgKDw5KSBjbGllbnRYIGF0IGNlcnRhaW4gcG9pbnQgKGFwcGFyZW50bHkgd2hlbiBtb3VzZXVwIGZpcmVzIG9uIFZNTCBlbGVtZW50KVxuICAgIC8vIGlzIHJlcHJlc2VudGVkIGFzIENPTSBvYmplY3QsIHdpdGggYWxsIHRoZSBjb25zZXF1ZW5jZXMsIGxpa2UgXCJ1bmtub3duXCIgdHlwZSBhbmQgZXJyb3Igb24gW1tHZXRdXVxuICAgIC8vIG5lZWQgdG8gaW52ZXN0aWdhdGUgbGF0ZXJcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgZXZlbnQuY2xpZW50WCAhPT0gdW5rbm93biA/IGV2ZW50LmNsaWVudFggOiAwKTtcbiAgICAgIH0sXG5cbiAgICAgIHBvaW50ZXJZID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgZXZlbnQuY2xpZW50WSAhPT0gdW5rbm93biA/IGV2ZW50LmNsaWVudFkgOiAwKTtcbiAgICAgIH07XG5cbiAgZnVuY3Rpb24gX2dldFBvaW50ZXIoZXZlbnQsIHBhZ2VQcm9wLCBjbGllbnRQcm9wKSB7XG4gICAgdmFyIHRvdWNoUHJvcCA9IGV2ZW50LnR5cGUgPT09ICd0b3VjaGVuZCcgPyAnY2hhbmdlZFRvdWNoZXMnIDogJ3RvdWNoZXMnO1xuXG4gICAgcmV0dXJuIChldmVudFt0b3VjaFByb3BdICYmIGV2ZW50W3RvdWNoUHJvcF1bMF1cbiAgICAgID8gKGV2ZW50W3RvdWNoUHJvcF1bMF1bcGFnZVByb3BdIC0gKGV2ZW50W3RvdWNoUHJvcF1bMF1bcGFnZVByb3BdIC0gZXZlbnRbdG91Y2hQcm9wXVswXVtjbGllbnRQcm9wXSkpXG4gICAgICAgIHx8IGV2ZW50W2NsaWVudFByb3BdXG4gICAgICA6IGV2ZW50W2NsaWVudFByb3BdKTtcbiAgfVxuXG4gIGlmIChmYWJyaWMuaXNUb3VjaFN1cHBvcnRlZCkge1xuICAgIHBvaW50ZXJYID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHJldHVybiBfZ2V0UG9pbnRlcihldmVudCwgJ3BhZ2VYJywgJ2NsaWVudFgnKTtcbiAgICB9O1xuICAgIHBvaW50ZXJZID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHJldHVybiBfZ2V0UG9pbnRlcihldmVudCwgJ3BhZ2VZJywgJ2NsaWVudFknKTtcbiAgICB9O1xuICB9XG5cbiAgZmFicmljLnV0aWwuZ2V0UG9pbnRlciA9IGdldFBvaW50ZXI7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMudXRpbCwgZmFicmljLk9ic2VydmFibGUpO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIENyb3NzLWJyb3dzZXIgd3JhcHBlciBmb3Igc2V0dGluZyBlbGVtZW50J3Mgc3R5bGVcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlc1xuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gRWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgYXMgYSBmaXJzdCBhcmd1bWVudFxuICAgKi9cbiAgZnVuY3Rpb24gc2V0U3R5bGUoZWxlbWVudCwgc3R5bGVzKSB7XG4gICAgdmFyIGVsZW1lbnRTdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG4gICAgaWYgKCFlbGVtZW50U3R5bGUpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHN0eWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCArPSAnOycgKyBzdHlsZXM7XG4gICAgICByZXR1cm4gc3R5bGVzLmluZGV4T2YoJ29wYWNpdHknKSA+IC0xXG4gICAgICAgID8gc2V0T3BhY2l0eShlbGVtZW50LCBzdHlsZXMubWF0Y2goL29wYWNpdHk6XFxzKihcXGQ/XFwuP1xcZCopLylbMV0pXG4gICAgICAgIDogZWxlbWVudDtcbiAgICB9XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAocHJvcGVydHkgPT09ICdvcGFjaXR5Jykge1xuICAgICAgICBzZXRPcGFjaXR5KGVsZW1lbnQsIHN0eWxlc1twcm9wZXJ0eV0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkUHJvcGVydHkgPSAocHJvcGVydHkgPT09ICdmbG9hdCcgfHwgcHJvcGVydHkgPT09ICdjc3NGbG9hdCcpXG4gICAgICAgICAgPyAodHlwZW9mIGVsZW1lbnRTdHlsZS5zdHlsZUZsb2F0ID09PSAndW5kZWZpbmVkJyA/ICdjc3NGbG9hdCcgOiAnc3R5bGVGbG9hdCcpXG4gICAgICAgICAgOiBwcm9wZXJ0eTtcbiAgICAgICAgZWxlbWVudFN0eWxlW25vcm1hbGl6ZWRQcm9wZXJ0eV0gPSBzdHlsZXNbcHJvcGVydHldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHZhciBwYXJzZUVsID0gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgc3VwcG9ydHNPcGFjaXR5ID0gdHlwZW9mIHBhcnNlRWwuc3R5bGUub3BhY2l0eSA9PT0gJ3N0cmluZycsXG4gICAgICBzdXBwb3J0c0ZpbHRlcnMgPSB0eXBlb2YgcGFyc2VFbC5zdHlsZS5maWx0ZXIgPT09ICdzdHJpbmcnLFxuICAgICAgcmVPcGFjaXR5ID0gL2FscGhhXFxzKlxcKFxccypvcGFjaXR5XFxzKj1cXHMqKFteXFwpXSspXFwpLyxcblxuICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgIHNldE9wYWNpdHkgPSBmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gZWxlbWVudDsgfTtcblxuICBpZiAoc3VwcG9ydHNPcGFjaXR5KSB7XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICBzZXRPcGFjaXR5ID0gZnVuY3Rpb24oZWxlbWVudCwgdmFsdWUpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTtcbiAgfVxuICBlbHNlIGlmIChzdXBwb3J0c0ZpbHRlcnMpIHtcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIHNldE9wYWNpdHkgPSBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZSkge1xuICAgICAgdmFyIGVzID0gZWxlbWVudC5zdHlsZTtcbiAgICAgIGlmIChlbGVtZW50LmN1cnJlbnRTdHlsZSAmJiAhZWxlbWVudC5jdXJyZW50U3R5bGUuaGFzTGF5b3V0KSB7XG4gICAgICAgIGVzLnpvb20gPSAxO1xuICAgICAgfVxuICAgICAgaWYgKHJlT3BhY2l0eS50ZXN0KGVzLmZpbHRlcikpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA+PSAwLjk5OTkgPyAnJyA6ICgnYWxwaGEob3BhY2l0eT0nICsgKHZhbHVlICogMTAwKSArICcpJyk7XG4gICAgICAgIGVzLmZpbHRlciA9IGVzLmZpbHRlci5yZXBsYWNlKHJlT3BhY2l0eSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGVzLmZpbHRlciArPSAnIGFscGhhKG9wYWNpdHk9JyArICh2YWx1ZSAqIDEwMCkgKyAnKSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9O1xuICB9XG5cbiAgZmFicmljLnV0aWwuc2V0U3R5bGUgPSBzZXRTdHlsZTtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIF9zbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAvKipcbiAgICogVGFrZXMgaWQgYW5kIHJldHVybnMgYW4gZWxlbWVudCB3aXRoIHRoYXQgaWQgKGlmIG9uZSBleGlzdHMgaW4gYSBkb2N1bWVudClcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7U3RyaW5nfEhUTUxFbGVtZW50fSBpZFxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudHxudWxsfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0QnlJZChpZCkge1xuICAgIHJldHVybiB0eXBlb2YgaWQgPT09ICdzdHJpbmcnID8gZmFicmljLmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IGlkO1xuICB9XG5cbiAgdmFyIHNsaWNlQ2FuQ29udmVydE5vZGVsaXN0cyxcbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydHMgYW4gYXJyYXktbGlrZSBvYmplY3QgKGUuZy4gYXJndW1lbnRzIG9yIE5vZGVMaXN0KSB0byBhbiBhcnJheVxuICAgICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJyYXlMaWtlXG4gICAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgICAqL1xuICAgICAgdG9BcnJheSA9IGZ1bmN0aW9uKGFycmF5TGlrZSkge1xuICAgICAgICByZXR1cm4gX3NsaWNlLmNhbGwoYXJyYXlMaWtlLCAwKTtcbiAgICAgIH07XG5cbiAgdHJ5IHtcbiAgICBzbGljZUNhbkNvbnZlcnROb2RlbGlzdHMgPSB0b0FycmF5KGZhYnJpYy5kb2N1bWVudC5jaGlsZE5vZGVzKSBpbnN0YW5jZW9mIEFycmF5O1xuICB9XG4gIGNhdGNoIChlcnIpIHsgfVxuXG4gIGlmICghc2xpY2VDYW5Db252ZXJ0Tm9kZWxpc3RzKSB7XG4gICAgdG9BcnJheSA9IGZ1bmN0aW9uKGFycmF5TGlrZSkge1xuICAgICAgdmFyIGFyciA9IG5ldyBBcnJheShhcnJheUxpa2UubGVuZ3RoKSwgaSA9IGFycmF5TGlrZS5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGFycltpXSA9IGFycmF5TGlrZVtpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHNwZWNpZmllZCBlbGVtZW50IHdpdGggc3BlY2lmaWVkIGF0dHJpYnV0ZXNcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0YWdOYW1lIFR5cGUgb2YgYW4gZWxlbWVudCB0byBjcmVhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzXSBBdHRyaWJ1dGVzIHRvIHNldCBvbiBhbiBlbGVtZW50XG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBOZXdseSBjcmVhdGVkIGVsZW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIG1ha2VFbGVtZW50KHRhZ05hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgZWwgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICBmb3IgKHZhciBwcm9wIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChwcm9wID09PSAnY2xhc3MnKSB7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IGF0dHJpYnV0ZXNbcHJvcF07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChwcm9wID09PSAnZm9yJykge1xuICAgICAgICBlbC5odG1sRm9yID0gYXR0cmlidXRlc1twcm9wXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUocHJvcCwgYXR0cmlidXRlc1twcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGNsYXNzIHRvIGFuIGVsZW1lbnRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBhZGQgY2xhc3MgdG9cbiAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZSBDbGFzcyB0byBhZGQgdG8gYW4gZWxlbWVudFxuICAgKi9cbiAgZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGVsZW1lbnQgJiYgKCcgJyArIGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnKS5pbmRleE9mKCcgJyArIGNsYXNzTmFtZSArICcgJykgPT09IC0xKSB7XG4gICAgICBlbGVtZW50LmNsYXNzTmFtZSArPSAoZWxlbWVudC5jbGFzc05hbWUgPyAnICcgOiAnJykgKyBjbGFzc05hbWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBzIGVsZW1lbnQgd2l0aCBhbm90aGVyIGVsZW1lbnRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byB3cmFwXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8U3RyaW5nfSB3cmFwcGVyIEVsZW1lbnQgdG8gd3JhcCB3aXRoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlc10gQXR0cmlidXRlcyB0byBzZXQgb24gYSB3cmFwcGVyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSB3cmFwcGVyXG4gICAqL1xuICBmdW5jdGlvbiB3cmFwRWxlbWVudChlbGVtZW50LCB3cmFwcGVyLCBhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKHR5cGVvZiB3cmFwcGVyID09PSAnc3RyaW5nJykge1xuICAgICAgd3JhcHBlciA9IG1ha2VFbGVtZW50KHdyYXBwZXIsIGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHdyYXBwZXIsIGVsZW1lbnQpO1xuICAgIH1cbiAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgIHJldHVybiB3cmFwcGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZWxlbWVudCBzY3JvbGwgb2Zmc2V0c1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIG9wZXJhdGUgb25cbiAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBsZWZ0L3RvcCB2YWx1ZXNcbiAgICovXG4gIGZ1bmN0aW9uIGdldFNjcm9sbExlZnRUb3AoZWxlbWVudCkge1xuXG4gICAgdmFyIGxlZnQgPSAwLFxuICAgICAgICB0b3AgPSAwLFxuICAgICAgICBkb2NFbGVtZW50ID0gZmFicmljLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgYm9keSA9IGZhYnJpYy5kb2N1bWVudC5ib2R5IHx8IHtcbiAgICAgICAgICBzY3JvbGxMZWZ0OiAwLCBzY3JvbGxUb3A6IDBcbiAgICAgICAgfTtcblxuICAgIC8vIFdoaWxlIGxvb3AgY2hlY2tzIChhbmQgdGhlbiBzZXRzIGVsZW1lbnQgdG8pIC5wYXJlbnROb2RlIE9SIC5ob3N0XG4gICAgLy8gIHRvIGFjY291bnQgZm9yIFNoYWRvd0RPTS4gV2Ugc3RpbGwgd2FudCB0byB0cmF2ZXJzZSB1cCBvdXQgb2YgU2hhZG93RE9NLFxuICAgIC8vICBidXQgdGhlIC5wYXJlbnROb2RlIG9mIGEgcm9vdCBTaGFkb3dET00gbm9kZSB3aWxsIGFsd2F5cyBiZSBudWxsLCBpbnN0ZWFkXG4gICAgLy8gIGl0IHNob3VsZCBiZSBhY2Nlc3NlZCB0aHJvdWdoIC5ob3N0LiBTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjQ3NjU1MjgvNDM4MzkzOFxuICAgIHdoaWxlIChlbGVtZW50ICYmIChlbGVtZW50LnBhcmVudE5vZGUgfHwgZWxlbWVudC5ob3N0KSkge1xuXG4gICAgICAvLyBTZXQgZWxlbWVudCB0byBlbGVtZW50IHBhcmVudCwgb3IgJ2hvc3QnIGluIGNhc2Ugb2YgU2hhZG93RE9NXG4gICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlIHx8IGVsZW1lbnQuaG9zdDtcblxuICAgICAgaWYgKGVsZW1lbnQgPT09IGZhYnJpYy5kb2N1bWVudCkge1xuICAgICAgICBsZWZ0ID0gYm9keS5zY3JvbGxMZWZ0IHx8IGRvY0VsZW1lbnQuc2Nyb2xsTGVmdCB8fCAwO1xuICAgICAgICB0b3AgPSBib2R5LnNjcm9sbFRvcCB8fCAgZG9jRWxlbWVudC5zY3JvbGxUb3AgfHwgMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsZWZ0ICs9IGVsZW1lbnQuc2Nyb2xsTGVmdCB8fCAwO1xuICAgICAgICB0b3AgKz0gZWxlbWVudC5zY3JvbGxUb3AgfHwgMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgPT09IDEgJiZcbiAgICAgICAgICBmYWJyaWMudXRpbC5nZXRFbGVtZW50U3R5bGUoZWxlbWVudCwgJ3Bvc2l0aW9uJykgPT09ICdmaXhlZCcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbGVmdDogbGVmdCwgdG9wOiB0b3AgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG9mZnNldCBmb3IgYSBnaXZlbiBlbGVtZW50XG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGdldCBvZmZzZXQgZm9yXG4gICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHdpdGggXCJsZWZ0XCIgYW5kIFwidG9wXCIgcHJvcGVydGllc1xuICAgKi9cbiAgZnVuY3Rpb24gZ2V0RWxlbWVudE9mZnNldChlbGVtZW50KSB7XG4gICAgdmFyIGRvY0VsZW0sXG4gICAgICAgIGRvYyA9IGVsZW1lbnQgJiYgZWxlbWVudC5vd25lckRvY3VtZW50LFxuICAgICAgICBib3ggPSB7IGxlZnQ6IDAsIHRvcDogMCB9LFxuICAgICAgICBvZmZzZXQgPSB7IGxlZnQ6IDAsIHRvcDogMCB9LFxuICAgICAgICBzY3JvbGxMZWZ0VG9wLFxuICAgICAgICBvZmZzZXRBdHRyaWJ1dGVzID0ge1xuICAgICAgICAgIGJvcmRlckxlZnRXaWR0aDogJ2xlZnQnLFxuICAgICAgICAgIGJvcmRlclRvcFdpZHRoOiAgJ3RvcCcsXG4gICAgICAgICAgcGFkZGluZ0xlZnQ6ICAgICAnbGVmdCcsXG4gICAgICAgICAgcGFkZGluZ1RvcDogICAgICAndG9wJ1xuICAgICAgICB9O1xuXG4gICAgaWYgKCFkb2MpIHtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgYXR0ciBpbiBvZmZzZXRBdHRyaWJ1dGVzKSB7XG4gICAgICBvZmZzZXRbb2Zmc2V0QXR0cmlidXRlc1thdHRyXV0gKz0gcGFyc2VJbnQoZ2V0RWxlbWVudFN0eWxlKGVsZW1lbnQsIGF0dHIpLCAxMCkgfHwgMDtcbiAgICB9XG5cbiAgICBkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICBpZiAoIHR5cGVvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICBib3ggPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH1cblxuICAgIHNjcm9sbExlZnRUb3AgPSBnZXRTY3JvbGxMZWZ0VG9wKGVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGJveC5sZWZ0ICsgc2Nyb2xsTGVmdFRvcC5sZWZ0IC0gKGRvY0VsZW0uY2xpZW50TGVmdCB8fCAwKSArIG9mZnNldC5sZWZ0LFxuICAgICAgdG9wOiBib3gudG9wICsgc2Nyb2xsTGVmdFRvcC50b3AgLSAoZG9jRWxlbS5jbGllbnRUb3AgfHwgMCkgICsgb2Zmc2V0LnRvcFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBzdHlsZSBhdHRyaWJ1dGUgdmFsdWUgb2YgYSBnaXZlbiBlbGVtZW50XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gZ2V0IHN0eWxlIGF0dHJpYnV0ZSBmb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgU3R5bGUgYXR0cmlidXRlIHRvIGdldCBmb3IgZWxlbWVudFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFN0eWxlIGF0dHJpYnV0ZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICovXG4gIHZhciBnZXRFbGVtZW50U3R5bGU7XG4gIGlmIChmYWJyaWMuZG9jdW1lbnQuZGVmYXVsdFZpZXcgJiYgZmFicmljLmRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICBnZXRFbGVtZW50U3R5bGUgPSBmdW5jdGlvbihlbGVtZW50LCBhdHRyKSB7XG4gICAgICB2YXIgc3R5bGUgPSBmYWJyaWMuZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgICAgIHJldHVybiBzdHlsZSA/IHN0eWxlW2F0dHJdIDogdW5kZWZpbmVkO1xuICAgIH07XG4gIH1cbiAgZWxzZSB7XG4gICAgZ2V0RWxlbWVudFN0eWxlID0gZnVuY3Rpb24oZWxlbWVudCwgYXR0cikge1xuICAgICAgdmFyIHZhbHVlID0gZWxlbWVudC5zdHlsZVthdHRyXTtcbiAgICAgIGlmICghdmFsdWUgJiYgZWxlbWVudC5jdXJyZW50U3R5bGUpIHtcbiAgICAgICAgdmFsdWUgPSBlbGVtZW50LmN1cnJlbnRTdHlsZVthdHRyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3R5bGUgPSBmYWJyaWMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLFxuICAgICAgICBzZWxlY3RQcm9wID0gJ3VzZXJTZWxlY3QnIGluIHN0eWxlXG4gICAgICAgICAgPyAndXNlclNlbGVjdCdcbiAgICAgICAgICA6ICdNb3pVc2VyU2VsZWN0JyBpbiBzdHlsZVxuICAgICAgICAgICAgPyAnTW96VXNlclNlbGVjdCdcbiAgICAgICAgICAgIDogJ1dlYmtpdFVzZXJTZWxlY3QnIGluIHN0eWxlXG4gICAgICAgICAgICAgID8gJ1dlYmtpdFVzZXJTZWxlY3QnXG4gICAgICAgICAgICAgIDogJ0todG1sVXNlclNlbGVjdCcgaW4gc3R5bGVcbiAgICAgICAgICAgICAgICA/ICdLaHRtbFVzZXJTZWxlY3QnXG4gICAgICAgICAgICAgICAgOiAnJztcblxuICAgIC8qKlxuICAgICAqIE1ha2VzIGVsZW1lbnQgdW5zZWxlY3RhYmxlXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIG1ha2UgdW5zZWxlY3RhYmxlXG4gICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IEVsZW1lbnQgdGhhdCB3YXMgcGFzc2VkIGluXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFrZUVsZW1lbnRVbnNlbGVjdGFibGUoZWxlbWVudCkge1xuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50Lm9uc2VsZWN0c3RhcnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGVsZW1lbnQub25zZWxlY3RzdGFydCA9IGZhYnJpYy51dGlsLmZhbHNlRnVuY3Rpb247XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0UHJvcCkge1xuICAgICAgICBlbGVtZW50LnN0eWxlW3NlbGVjdFByb3BdID0gJ25vbmUnO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQudW5zZWxlY3RhYmxlID09PSAnc3RyaW5nJykge1xuICAgICAgICBlbGVtZW50LnVuc2VsZWN0YWJsZSA9ICdvbic7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBlbGVtZW50IHNlbGVjdGFibGVcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gbWFrZSBzZWxlY3RhYmxlXG4gICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IEVsZW1lbnQgdGhhdCB3YXMgcGFzc2VkIGluXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFrZUVsZW1lbnRTZWxlY3RhYmxlKGVsZW1lbnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudC5vbnNlbGVjdHN0YXJ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbGVtZW50Lm9uc2VsZWN0c3RhcnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdFByb3ApIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZVtzZWxlY3RQcm9wXSA9ICcnO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQudW5zZWxlY3RhYmxlID09PSAnc3RyaW5nJykge1xuICAgICAgICBlbGVtZW50LnVuc2VsZWN0YWJsZSA9ICcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgZmFicmljLnV0aWwubWFrZUVsZW1lbnRVbnNlbGVjdGFibGUgPSBtYWtlRWxlbWVudFVuc2VsZWN0YWJsZTtcbiAgICBmYWJyaWMudXRpbC5tYWtlRWxlbWVudFNlbGVjdGFibGUgPSBtYWtlRWxlbWVudFNlbGVjdGFibGU7XG4gIH0pKCk7XG5cbiAgKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhIHNjcmlwdCBlbGVtZW50IHdpdGggYSBnaXZlbiB1cmwgaW50byBhIGRvY3VtZW50OyBpbnZva2VzIGNhbGxiYWNrLCB3aGVuIHRoYXQgc2NyaXB0IGlzIGZpbmlzaGVkIGxvYWRpbmdcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFVSTCBvZiBhIHNjcmlwdCB0byBsb2FkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHNjcmlwdCBpcyBmaW5pc2hlZCBsb2FkaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2NyaXB0KHVybCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBoZWFkRWwgPSBmYWJyaWMuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSxcbiAgICAgICAgICBzY3JpcHRFbCA9IGZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSxcbiAgICAgICAgICBsb2FkaW5nID0gdHJ1ZTtcblxuICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgIHNjcmlwdEVsLm9ubG9hZCA9IC8qKiBAaWdub3JlICovIHNjcmlwdEVsLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGxvYWRpbmcpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucmVhZHlTdGF0ZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXRlICE9PSAnbG9hZGVkJyAmJlxuICAgICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgIT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgIGNhbGxiYWNrKGUgfHwgZmFicmljLndpbmRvdy5ldmVudCk7XG4gICAgICAgICAgc2NyaXB0RWwgPSBzY3JpcHRFbC5vbmxvYWQgPSBzY3JpcHRFbC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2NyaXB0RWwuc3JjID0gdXJsO1xuICAgICAgaGVhZEVsLmFwcGVuZENoaWxkKHNjcmlwdEVsKTtcbiAgICAgIC8vIGNhdXNlcyBpc3N1ZSBpbiBPcGVyYVxuICAgICAgLy8gaGVhZEVsLnJlbW92ZUNoaWxkKHNjcmlwdEVsKTtcbiAgICB9XG5cbiAgICBmYWJyaWMudXRpbC5nZXRTY3JpcHQgPSBnZXRTY3JpcHQ7XG4gIH0pKCk7XG5cbiAgZmFicmljLnV0aWwuZ2V0QnlJZCA9IGdldEJ5SWQ7XG4gIGZhYnJpYy51dGlsLnRvQXJyYXkgPSB0b0FycmF5O1xuICBmYWJyaWMudXRpbC5tYWtlRWxlbWVudCA9IG1ha2VFbGVtZW50O1xuICBmYWJyaWMudXRpbC5hZGRDbGFzcyA9IGFkZENsYXNzO1xuICBmYWJyaWMudXRpbC53cmFwRWxlbWVudCA9IHdyYXBFbGVtZW50O1xuICBmYWJyaWMudXRpbC5nZXRTY3JvbGxMZWZ0VG9wID0gZ2V0U2Nyb2xsTGVmdFRvcDtcbiAgZmFicmljLnV0aWwuZ2V0RWxlbWVudE9mZnNldCA9IGdldEVsZW1lbnRPZmZzZXQ7XG4gIGZhYnJpYy51dGlsLmdldEVsZW1lbnRTdHlsZSA9IGdldEVsZW1lbnRTdHlsZTtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgZnVuY3Rpb24gYWRkUGFyYW1Ub1VybCh1cmwsIHBhcmFtKSB7XG4gICAgcmV0dXJuIHVybCArICgvXFw/Ly50ZXN0KHVybCkgPyAnJicgOiAnPycpICsgcGFyYW07XG4gIH1cblxuICB2YXIgbWFrZVhIUiA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgZmFjdG9yaWVzID0gW1xuICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTsgfSxcbiAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQJyk7IH0sXG4gICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC4zLjAnKTsgfSxcbiAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7IH1cbiAgICBdO1xuICAgIGZvciAodmFyIGkgPSBmYWN0b3JpZXMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlcSA9IGZhY3Rvcmllc1tpXSgpO1xuICAgICAgICBpZiAocmVxKSB7XG4gICAgICAgICAgcmV0dXJuIGZhY3Rvcmllc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2F0Y2ggKGVycikgeyB9XG4gICAgfVxuICB9KSgpO1xuXG4gIGZ1bmN0aW9uIGVtcHR5Rm4oKSB7IH1cblxuICAvKipcbiAgICogQ3Jvc3MtYnJvd3NlciBhYnN0cmFjdGlvbiBmb3Igc2VuZGluZyBYTUxIdHRwUmVxdWVzdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBVUkwgdG8gc2VuZCBYTUxIdHRwUmVxdWVzdCB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXRob2Q9XCJHRVRcIl1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhcmFtZXRlcnNdIHBhcmFtZXRlcnMgdG8gYXBwZW5kIHRvIHVybCBpbiBHRVQgb3IgaW4gYm9keVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYm9keV0gYm9keSB0byBzZW5kIHdpdGggUE9TVCBvciBQVVQgcmVxdWVzdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLm9uQ29tcGxldGUgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gcmVxdWVzdCBpcyBjb21wbGV0ZWRcbiAgICogQHJldHVybiB7WE1MSHR0cFJlcXVlc3R9IHJlcXVlc3RcbiAgICovXG4gIGZ1bmN0aW9uIHJlcXVlc3QodXJsLCBvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgIHZhciBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCA/IG9wdGlvbnMubWV0aG9kLnRvVXBwZXJDYXNlKCkgOiAnR0VUJyxcbiAgICAgICAgb25Db21wbGV0ZSA9IG9wdGlvbnMub25Db21wbGV0ZSB8fCBmdW5jdGlvbigpIHsgfSxcbiAgICAgICAgeGhyID0gbWFrZVhIUigpLFxuICAgICAgICBib2R5ID0gb3B0aW9ucy5ib2R5IHx8IG9wdGlvbnMucGFyYW1ldGVycztcblxuICAgIC8qKiBAaWdub3JlICovXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgIG9uQ29tcGxldGUoeGhyKTtcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5Rm47XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICBib2R5ID0gbnVsbDtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wYXJhbWV0ZXJzID09PSAnc3RyaW5nJykge1xuICAgICAgICB1cmwgPSBhZGRQYXJhbVRvVXJsKHVybCwgb3B0aW9ucy5wYXJhbWV0ZXJzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG5cbiAgICBpZiAobWV0aG9kID09PSAnUE9TVCcgfHwgbWV0aG9kID09PSAnUFVUJykge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKTtcbiAgICB9XG5cbiAgICB4aHIuc2VuZChib2R5KTtcbiAgICByZXR1cm4geGhyO1xuICB9XG5cbiAgZmFicmljLnV0aWwucmVxdWVzdCA9IHJlcXVlc3Q7XG59KSgpO1xuXG5cbi8qKlxuICogV3JhcHBlciBhcm91bmQgYGNvbnNvbGUubG9nYCAod2hlbiBhdmFpbGFibGUpXG4gKiBAcGFyYW0geyp9IFt2YWx1ZXNdIFZhbHVlcyB0byBsb2dcbiAqL1xuZmFicmljLmxvZyA9IGZ1bmN0aW9uKCkgeyB9O1xuXG4vKipcbiAqIFdyYXBwZXIgYXJvdW5kIGBjb25zb2xlLndhcm5gICh3aGVuIGF2YWlsYWJsZSlcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlc10gVmFsdWVzIHRvIGxvZyBhcyBhIHdhcm5pbmdcbiAqL1xuZmFicmljLndhcm4gPSBmdW5jdGlvbigpIHsgfTtcblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblxuICBbJ2xvZycsICd3YXJuJ10uZm9yRWFjaChmdW5jdGlvbihtZXRob2ROYW1lKSB7XG5cbiAgICBpZiAodHlwZW9mIGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHR5cGVvZiBjb25zb2xlW21ldGhvZE5hbWVdLmFwcGx5ID09PSAnZnVuY3Rpb24nKSB7XG5cbiAgICAgIGZhYnJpY1ttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY29uc29sZVttZXRob2ROYW1lXS5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuLyogZXNsaW50LWVuYWJsZSAqL1xuXG5cbihmdW5jdGlvbigpIHtcblxuICAvKipcbiAgICogQ2hhbmdlcyB2YWx1ZSBmcm9tIG9uZSB0byBhbm90aGVyIHdpdGhpbiBjZXJ0YWluIHBlcmlvZCBvZiB0aW1lLCBpbnZva2luZyBjYWxsYmFja3MgYXMgdmFsdWUgaXMgYmVpbmcgY2hhbmdlZC5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQW5pbWF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25DaGFuZ2VdIENhbGxiYWNrOyBpbnZva2VkIG9uIGV2ZXJ5IHZhbHVlIGNoYW5nZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkNvbXBsZXRlXSBDYWxsYmFjazsgaW52b2tlZCB3aGVuIHZhbHVlIGNoYW5nZSBpcyBjb21wbGV0ZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN0YXJ0VmFsdWU9MF0gU3RhcnRpbmcgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmVuZFZhbHVlPTEwMF0gRW5kaW5nIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5ieVZhbHVlPTEwMF0gVmFsdWUgdG8gbW9kaWZ5IHRoZSBwcm9wZXJ0eSBieVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5lYXNpbmddIEVhc2luZyBmdW5jdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZHVyYXRpb249NTAwXSBEdXJhdGlvbiBvZiBjaGFuZ2UgKGluIG1zKVxuICAgKi9cbiAgZnVuY3Rpb24gYW5pbWF0ZShvcHRpb25zKSB7XG5cbiAgICByZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uKHRpbWVzdGFtcCkge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHZhciBzdGFydCA9IHRpbWVzdGFtcCB8fCArbmV3IERhdGUoKSxcbiAgICAgICAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gfHwgNTAwLFxuICAgICAgICAgIGZpbmlzaCA9IHN0YXJ0ICsgZHVyYXRpb24sIHRpbWUsXG4gICAgICAgICAgb25DaGFuZ2UgPSBvcHRpb25zLm9uQ2hhbmdlIHx8IGZ1bmN0aW9uKCkgeyB9LFxuICAgICAgICAgIGFib3J0ID0gb3B0aW9ucy5hYm9ydCB8fCBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICAgIGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nIHx8IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtyZXR1cm4gLWMgKiBNYXRoLmNvcyh0IC8gZCAqIChNYXRoLlBJIC8gMikpICsgYyArIGI7fSxcbiAgICAgICAgICBzdGFydFZhbHVlID0gJ3N0YXJ0VmFsdWUnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXJ0VmFsdWUgOiAwLFxuICAgICAgICAgIGVuZFZhbHVlID0gJ2VuZFZhbHVlJyBpbiBvcHRpb25zID8gb3B0aW9ucy5lbmRWYWx1ZSA6IDEwMCxcbiAgICAgICAgICBieVZhbHVlID0gb3B0aW9ucy5ieVZhbHVlIHx8IGVuZFZhbHVlIC0gc3RhcnRWYWx1ZTtcblxuICAgICAgb3B0aW9ucy5vblN0YXJ0ICYmIG9wdGlvbnMub25TdGFydCgpO1xuXG4gICAgICAoZnVuY3Rpb24gdGljayh0aWNrdGltZSkge1xuICAgICAgICB0aW1lID0gdGlja3RpbWUgfHwgK25ldyBEYXRlKCk7XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IHRpbWUgPiBmaW5pc2ggPyBkdXJhdGlvbiA6ICh0aW1lIC0gc3RhcnQpO1xuICAgICAgICBpZiAoYWJvcnQoKSkge1xuICAgICAgICAgIG9wdGlvbnMub25Db21wbGV0ZSAmJiBvcHRpb25zLm9uQ29tcGxldGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb25DaGFuZ2UoZWFzaW5nKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBieVZhbHVlLCBkdXJhdGlvbikpO1xuICAgICAgICBpZiAodGltZSA+IGZpbmlzaCkge1xuICAgICAgICAgIG9wdGlvbnMub25Db21wbGV0ZSAmJiBvcHRpb25zLm9uQ29tcGxldGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEFuaW1GcmFtZSh0aWNrKTtcbiAgICAgIH0pKHN0YXJ0KTtcbiAgICB9KTtcblxuICB9XG5cbiAgdmFyIF9yZXF1ZXN0QW5pbUZyYW1lID0gZmFicmljLndpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFicmljLndpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFicmljLndpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFicmljLndpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFicmljLndpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgLyoqXG4gICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZSBwb2x5ZmlsbCBiYXNlZCBvbiBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xuICAgKiBJbiBvcmRlciB0byBnZXQgYSBwcmVjaXNlIHN0YXJ0IHRpbWUsIGByZXF1ZXN0QW5pbUZyYW1lYCBzaG91bGQgYmUgY2FsbGVkIGFzIGFuIGVudHJ5IGludG8gdGhlIG1ldGhvZFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCBvcHRpb25hbCBFbGVtZW50IHRvIGFzc29jaWF0ZSB3aXRoIGFuaW1hdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZSgpIHtcbiAgICByZXR1cm4gX3JlcXVlc3RBbmltRnJhbWUuYXBwbHkoZmFicmljLndpbmRvdywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLmFuaW1hdGUgPSBhbmltYXRlO1xuICBmYWJyaWMudXRpbC5yZXF1ZXN0QW5pbUZyYW1lID0gcmVxdWVzdEFuaW1GcmFtZTtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG4gIC8vIENhbGN1bGF0ZSBhbiBpbi1iZXR3ZWVuIGNvbG9yLiBSZXR1cm5zIGEgXCJyZ2JhKClcIiBzdHJpbmcuXG4gIC8vIENyZWRpdDogRWR3aW4gTWFydGluIDxlZHdpbkBiaXRzdG9ybS5vcmc+XG4gIC8vICAgICAgICAgaHR0cDovL3d3dy5iaXRzdG9ybS5vcmcvanF1ZXJ5L2NvbG9yLWFuaW1hdGlvbi9qcXVlcnkuYW5pbWF0ZS1jb2xvcnMuanNcbiAgZnVuY3Rpb24gY2FsY3VsYXRlQ29sb3IoYmVnaW4sIGVuZCwgcG9zKSB7XG4gICAgdmFyIGNvbG9yID0gJ3JnYmEoJ1xuICAgICAgICArIHBhcnNlSW50KChiZWdpblswXSArIHBvcyAqIChlbmRbMF0gLSBiZWdpblswXSkpLCAxMCkgKyAnLCdcbiAgICAgICAgKyBwYXJzZUludCgoYmVnaW5bMV0gKyBwb3MgKiAoZW5kWzFdIC0gYmVnaW5bMV0pKSwgMTApICsgJywnXG4gICAgICAgICsgcGFyc2VJbnQoKGJlZ2luWzJdICsgcG9zICogKGVuZFsyXSAtIGJlZ2luWzJdKSksIDEwKTtcblxuICAgIGNvbG9yICs9ICcsJyArIChiZWdpbiAmJiBlbmQgPyBwYXJzZUZsb2F0KGJlZ2luWzNdICsgcG9zICogKGVuZFszXSAtIGJlZ2luWzNdKSkgOiAxKTtcbiAgICBjb2xvciArPSAnKSc7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIGNvbG9yIGZyb20gb25lIHRvIGFub3RoZXIgd2l0aGluIGNlcnRhaW4gcGVyaW9kIG9mIHRpbWUsIGludm9raW5nIGNhbGxiYWNrcyBhcyB2YWx1ZSBpcyBiZWluZyBjaGFuZ2VkLlxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZyb21Db2xvciBUaGUgc3RhcnRpbmcgY29sb3IgaW4gaGV4IG9yIHJnYihhKSBmb3JtYXQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0b0NvbG9yIFRoZSBzdGFydGluZyBjb2xvciBpbiBoZXggb3IgcmdiKGEpIGZvcm1hdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkdXJhdGlvbl0gRHVyYXRpb24gb2YgY2hhbmdlIChpbiBtcykuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQW5pbWF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25DaGFuZ2VdIENhbGxiYWNrOyBpbnZva2VkIG9uIGV2ZXJ5IHZhbHVlIGNoYW5nZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkNvbXBsZXRlXSBDYWxsYmFjazsgaW52b2tlZCB3aGVuIHZhbHVlIGNoYW5nZSBpcyBjb21wbGV0ZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY29sb3JFYXNpbmddIEVhc2luZyBmdW5jdGlvbi4gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gb25seSB0YWtlIHR3byBhcmd1bWVudHMgKGN1cnJlbnRUaW1lLCBkdXJhdGlvbikuIFRodXMgdGhlIHJlZ3VsYXIgYW5pbWF0aW9uIGVhc2luZyBmdW5jdGlvbnMgY2Fubm90IGJlIHVzZWQuXG4gICAqL1xuICBmdW5jdGlvbiBhbmltYXRlQ29sb3IoZnJvbUNvbG9yLCB0b0NvbG9yLCBkdXJhdGlvbiwgb3B0aW9ucykge1xuICAgIHZhciBzdGFydENvbG9yID0gbmV3IGZhYnJpYy5Db2xvcihmcm9tQ29sb3IpLmdldFNvdXJjZSgpLFxuICAgICAgICBlbmRDb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IodG9Db2xvcikuZ2V0U291cmNlKCk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGZhYnJpYy51dGlsLmFuaW1hdGUoZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChvcHRpb25zLCB7XG4gICAgICBkdXJhdGlvbjogZHVyYXRpb24gfHwgNTAwLFxuICAgICAgc3RhcnRWYWx1ZTogc3RhcnRDb2xvcixcbiAgICAgIGVuZFZhbHVlOiBlbmRDb2xvcixcbiAgICAgIGJ5VmFsdWU6IGVuZENvbG9yLFxuICAgICAgZWFzaW5nOiBmdW5jdGlvbiAoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGJ5VmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBwb3NWYWx1ZSA9IG9wdGlvbnMuY29sb3JFYXNpbmdcbiAgICAgICAgICAgICAgPyBvcHRpb25zLmNvbG9yRWFzaW5nKGN1cnJlbnRUaW1lLCBkdXJhdGlvbilcbiAgICAgICAgICAgICAgOiAxIC0gTWF0aC5jb3MoY3VycmVudFRpbWUgLyBkdXJhdGlvbiAqIChNYXRoLlBJIC8gMikpO1xuICAgICAgICByZXR1cm4gY2FsY3VsYXRlQ29sb3Ioc3RhcnRWYWx1ZSwgYnlWYWx1ZSwgcG9zVmFsdWUpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLmFuaW1hdGVDb2xvciA9IGFuaW1hdGVDb2xvcjtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplKGEsIGMsIHAsIHMpIHtcbiAgICBpZiAoYSA8IE1hdGguYWJzKGMpKSB7XG4gICAgICBhID0gYztcbiAgICAgIHMgPSBwIC8gNDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvL2hhbmRsZSB0aGUgMC8wIGNhc2U6XG4gICAgICBpZiAoYyA9PT0gMCAmJiBhID09PSAwKSB7XG4gICAgICAgIHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbigxKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oYyAvIGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBhOiBhLCBjOiBjLCBwOiBwLCBzOiBzIH07XG4gIH1cblxuICBmdW5jdGlvbiBlbGFzdGljKG9wdHMsIHQsIGQpIHtcbiAgICByZXR1cm4gb3B0cy5hICpcbiAgICAgIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICpcbiAgICAgIE1hdGguc2luKCAodCAqIGQgLSBvcHRzLnMpICogKDIgKiBNYXRoLlBJKSAvIG9wdHMucCApO1xuICB9XG5cbiAgLyoqXG4gICAqIEN1YmljIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRDdWJpYyh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqIHQgKyAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQ3ViaWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dEN1YmljKHQsIGIsIGMsIGQpIHtcbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKiB0ICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIGMgLyAyICogKCh0IC09IDIpICogdCAqIHQgKyAyKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogUXVhcnRpYyBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJblF1YXJ0KHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqIHQgKiB0ICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWFydGljIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRRdWFydCh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIC1jICogKCh0ID0gdCAvIGQgLSAxKSAqIHQgKiB0ICogdCAtIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWFydGljIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRRdWFydCh0LCBiLCBjLCBkKSB7XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA8IDEpIHtcbiAgICAgIHJldHVybiBjIC8gMiAqIHQgKiB0ICogdCAqIHQgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gLWMgLyAyICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMikgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1aW50aWMgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5RdWludCh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiB0ICogdCAqIHQgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1aW50aWMgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dFF1aW50KHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1aW50aWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dFF1aW50KHQsIGIsIGMsIGQpIHtcbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKiB0ICogdCAqIHQgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMikgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbnVzb2lkYWwgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5TaW5lKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gLWMgKiBNYXRoLmNvcyh0IC8gZCAqIChNYXRoLlBJIC8gMikpICsgYyArIGI7XG4gIH1cblxuICAvKipcbiAgICogU2ludXNvaWRhbCBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0U2luZSh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiBNYXRoLnNpbih0IC8gZCAqIChNYXRoLlBJIC8gMikpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW51c29pZGFsIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRTaW5lKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gLWMgLyAyICogKE1hdGguY29zKE1hdGguUEkgKiB0IC8gZCkgLSAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogRXhwb25lbnRpYWwgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5FeHBvKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gKHQgPT09IDApID8gYiA6IGMgKiBNYXRoLnBvdygyLCAxMCAqICh0IC8gZCAtIDEpKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogRXhwb25lbnRpYWwgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dEV4cG8odCwgYiwgYywgZCkge1xuICAgIHJldHVybiAodCA9PT0gZCkgPyBiICsgYyA6IGMgKiAoLU1hdGgucG93KDIsIC0xMCAqIHQgLyBkKSArIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvbmVudGlhbCBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0RXhwbyh0LCBiLCBjLCBkKSB7XG4gICAgaWYgKHQgPT09IDApIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICBpZiAodCA9PT0gZCkge1xuICAgICAgcmV0dXJuIGIgKyBjO1xuICAgIH1cbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIGMgLyAyICogTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKSArIGI7XG4gICAgfVxuICAgIHJldHVybiBjIC8gMiAqICgtTWF0aC5wb3coMiwgLTEwICogLS10KSArIDIpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaXJjdWxhciBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbkNpcmModCwgYiwgYywgZCkge1xuICAgIHJldHVybiAtYyAqIChNYXRoLnNxcnQoMSAtICh0IC89IGQpICogdCkgLSAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQ2lyY3VsYXIgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dENpcmModCwgYiwgYywgZCkge1xuICAgIHJldHVybiBjICogTWF0aC5zcXJ0KDEgLSAodCA9IHQgLyBkIC0gMSkgKiB0KSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQ2lyY3VsYXIgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dENpcmModCwgYiwgYywgZCkge1xuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gLWMgLyAyICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSkgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gYyAvIDIgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsYXN0aWMgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5FbGFzdGljKHQsIGIsIGMsIGQpIHtcbiAgICB2YXIgcyA9IDEuNzAxNTgsIHAgPSAwLCBhID0gYztcbiAgICBpZiAodCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIHQgLz0gZDtcbiAgICBpZiAodCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGIgKyBjO1xuICAgIH1cbiAgICBpZiAoIXApIHtcbiAgICAgIHAgPSBkICogMC4zO1xuICAgIH1cbiAgICB2YXIgb3B0cyA9IG5vcm1hbGl6ZShhLCBjLCBwLCBzKTtcbiAgICByZXR1cm4gLWVsYXN0aWMob3B0cywgdCwgZCkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsYXN0aWMgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dEVsYXN0aWModCwgYiwgYywgZCkge1xuICAgIHZhciBzID0gMS43MDE1OCwgcCA9IDAsIGEgPSBjO1xuICAgIGlmICh0ID09PSAwKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgdCAvPSBkO1xuICAgIGlmICh0ID09PSAxKSB7XG4gICAgICByZXR1cm4gYiArIGM7XG4gICAgfVxuICAgIGlmICghcCkge1xuICAgICAgcCA9IGQgKiAwLjM7XG4gICAgfVxuICAgIHZhciBvcHRzID0gbm9ybWFsaXplKGEsIGMsIHAsIHMpO1xuICAgIHJldHVybiBvcHRzLmEgKiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0ICogZCAtIG9wdHMucykgKiAoMiAqIE1hdGguUEkpIC8gb3B0cy5wICkgKyBvcHRzLmMgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsYXN0aWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dEVsYXN0aWModCwgYiwgYywgZCkge1xuICAgIHZhciBzID0gMS43MDE1OCwgcCA9IDAsIGEgPSBjO1xuICAgIGlmICh0ID09PSAwKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA9PT0gMikge1xuICAgICAgcmV0dXJuIGIgKyBjO1xuICAgIH1cbiAgICBpZiAoIXApIHtcbiAgICAgIHAgPSBkICogKDAuMyAqIDEuNSk7XG4gICAgfVxuICAgIHZhciBvcHRzID0gbm9ybWFsaXplKGEsIGMsIHAsIHMpO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIC0wLjUgKiBlbGFzdGljKG9wdHMsIHQsIGQpICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIG9wdHMuYSAqIE1hdGgucG93KDIsIC0xMCAqICh0IC09IDEpKSAqXG4gICAgICBNYXRoLnNpbigodCAqIGQgLSBvcHRzLnMpICogKDIgKiBNYXRoLlBJKSAvIG9wdHMucCApICogMC41ICsgb3B0cy5jICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYWNrd2FyZHMgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5CYWNrKHQsIGIsIGMsIGQsIHMpIHtcbiAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzID0gMS43MDE1ODtcbiAgICB9XG4gICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQmFja3dhcmRzIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRCYWNrKHQsIGIsIGMsIGQsIHMpIHtcbiAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzID0gMS43MDE1ODtcbiAgICB9XG4gICAgcmV0dXJuIGMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhY2t3YXJkcyBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0QmFjayh0LCBiLCBjLCBkLCBzKSB7XG4gICAgaWYgKHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcyA9IDEuNzAxNTg7XG4gICAgfVxuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gYyAvIDIgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIGMgLyAyICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCb3VuY2luZyBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbkJvdW5jZSh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgLSBlYXNlT3V0Qm91bmNlIChkIC0gdCwgMCwgYywgZCkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEJvdW5jaW5nIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRCb3VuY2UodCwgYiwgYywgZCkge1xuICAgIGlmICgodCAvPSBkKSA8ICgxIC8gMi43NSkpIHtcbiAgICAgIHJldHVybiBjICogKDcuNTYyNSAqIHQgKiB0KSArIGI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHQgPCAoMiAvIDIuNzUpKSB7XG4gICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiAodCAtPSAoMS41IC8gMi43NSkpICogdCArIDAuNzUpICsgYjtcbiAgICB9XG4gICAgZWxzZSBpZiAodCA8ICgyLjUgLyAyLjc1KSkge1xuICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gKDIuMjUgLyAyLjc1KSkgKiB0ICsgMC45Mzc1KSArIGI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gKDIuNjI1IC8gMi43NSkpICogdCArIDAuOTg0Mzc1KSArIGI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJvdW5jaW5nIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRCb3VuY2UodCwgYiwgYywgZCkge1xuICAgIGlmICh0IDwgZCAvIDIpIHtcbiAgICAgIHJldHVybiBlYXNlSW5Cb3VuY2UgKHQgKiAyLCAwLCBjLCBkKSAqIDAuNSArIGI7XG4gICAgfVxuICAgIHJldHVybiBlYXNlT3V0Qm91bmNlKHQgKiAyIC0gZCwgMCwgYywgZCkgKiAwLjUgKyBjICogMC41ICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFYXNpbmcgZnVuY3Rpb25zXG4gICAqIFNlZSA8YSBocmVmPVwiaHR0cDovL2dpem1hLmNvbS9lYXNpbmcvXCI+RWFzaW5nIEVxdWF0aW9ucyBieSBSb2JlcnQgUGVubmVyPC9hPlxuICAgKiBAbmFtZXNwYWNlIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZhYnJpYy51dGlsLmVhc2UgPSB7XG5cbiAgICAvKipcbiAgICAgKiBRdWFkcmF0aWMgZWFzaW5nIGluXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICAgKi9cbiAgICBlYXNlSW5RdWFkOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFF1YWRyYXRpYyBlYXNpbmcgb3V0XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICAgKi9cbiAgICBlYXNlT3V0UXVhZDogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgcmV0dXJuIC1jICogKHQgLz0gZCkgKiAodCAtIDIpICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUXVhZHJhdGljIGVhc2luZyBpbiBhbmQgb3V0XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICAgKi9cbiAgICBlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICB0IC89IChkIC8gMik7XG4gICAgICBpZiAodCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKyBiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC1jIC8gMiAqICgoLS10KSAqICh0IC0gMikgLSAxKSArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEN1YmljIGVhc2luZyBpblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAgICovXG4gICAgZWFzZUluQ3ViaWM6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogdCArIGI7XG4gICAgfSxcblxuICAgIGVhc2VPdXRDdWJpYzogZWFzZU91dEN1YmljLFxuICAgIGVhc2VJbk91dEN1YmljOiBlYXNlSW5PdXRDdWJpYyxcbiAgICBlYXNlSW5RdWFydDogZWFzZUluUXVhcnQsXG4gICAgZWFzZU91dFF1YXJ0OiBlYXNlT3V0UXVhcnQsXG4gICAgZWFzZUluT3V0UXVhcnQ6IGVhc2VJbk91dFF1YXJ0LFxuICAgIGVhc2VJblF1aW50OiBlYXNlSW5RdWludCxcbiAgICBlYXNlT3V0UXVpbnQ6IGVhc2VPdXRRdWludCxcbiAgICBlYXNlSW5PdXRRdWludDogZWFzZUluT3V0UXVpbnQsXG4gICAgZWFzZUluU2luZTogZWFzZUluU2luZSxcbiAgICBlYXNlT3V0U2luZTogZWFzZU91dFNpbmUsXG4gICAgZWFzZUluT3V0U2luZTogZWFzZUluT3V0U2luZSxcbiAgICBlYXNlSW5FeHBvOiBlYXNlSW5FeHBvLFxuICAgIGVhc2VPdXRFeHBvOiBlYXNlT3V0RXhwbyxcbiAgICBlYXNlSW5PdXRFeHBvOiBlYXNlSW5PdXRFeHBvLFxuICAgIGVhc2VJbkNpcmM6IGVhc2VJbkNpcmMsXG4gICAgZWFzZU91dENpcmM6IGVhc2VPdXRDaXJjLFxuICAgIGVhc2VJbk91dENpcmM6IGVhc2VJbk91dENpcmMsXG4gICAgZWFzZUluRWxhc3RpYzogZWFzZUluRWxhc3RpYyxcbiAgICBlYXNlT3V0RWxhc3RpYzogZWFzZU91dEVsYXN0aWMsXG4gICAgZWFzZUluT3V0RWxhc3RpYzogZWFzZUluT3V0RWxhc3RpYyxcbiAgICBlYXNlSW5CYWNrOiBlYXNlSW5CYWNrLFxuICAgIGVhc2VPdXRCYWNrOiBlYXNlT3V0QmFjayxcbiAgICBlYXNlSW5PdXRCYWNrOiBlYXNlSW5PdXRCYWNrLFxuICAgIGVhc2VJbkJvdW5jZTogZWFzZUluQm91bmNlLFxuICAgIGVhc2VPdXRCb3VuY2U6IGVhc2VPdXRCb3VuY2UsXG4gICAgZWFzZUluT3V0Qm91bmNlOiBlYXNlSW5PdXRCb3VuY2VcbiAgfTtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBmYWJyaWNcbiAgICogQG5hbWVzcGFjZVxuICAgKi9cblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUsXG4gICAgICB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZCxcbiAgICAgIHBhcnNlVW5pdCA9IGZhYnJpYy51dGlsLnBhcnNlVW5pdCxcbiAgICAgIG11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMgPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzLFxuXG4gICAgICByZUFsbG93ZWRTVkdUYWdOYW1lcyA9IC9eKHBhdGh8Y2lyY2xlfHBvbHlnb258cG9seWxpbmV8ZWxsaXBzZXxyZWN0fGxpbmV8aW1hZ2V8dGV4dCkkL2ksXG4gICAgICByZVZpZXdCb3hUYWdOYW1lcyA9IC9eKHN5bWJvbHxpbWFnZXxtYXJrZXJ8cGF0dGVybnx2aWV3fHN2ZykkL2ksXG4gICAgICByZU5vdEFsbG93ZWRBbmNlc3RvcnMgPSAvXig/OnBhdHRlcm58ZGVmc3xzeW1ib2x8bWV0YWRhdGF8Y2xpcFBhdGh8bWFzaykkL2ksXG4gICAgICByZUFsbG93ZWRQYXJlbnRzID0gL14oc3ltYm9sfGd8YXxzdmcpJC9pLFxuXG4gICAgICBhdHRyaWJ1dGVzTWFwID0ge1xuICAgICAgICBjeDogICAgICAgICAgICAgICAgICAgJ2xlZnQnLFxuICAgICAgICB4OiAgICAgICAgICAgICAgICAgICAgJ2xlZnQnLFxuICAgICAgICByOiAgICAgICAgICAgICAgICAgICAgJ3JhZGl1cycsXG4gICAgICAgIGN5OiAgICAgICAgICAgICAgICAgICAndG9wJyxcbiAgICAgICAgeTogICAgICAgICAgICAgICAgICAgICd0b3AnLFxuICAgICAgICBkaXNwbGF5OiAgICAgICAgICAgICAgJ3Zpc2libGUnLFxuICAgICAgICB2aXNpYmlsaXR5OiAgICAgICAgICAgJ3Zpc2libGUnLFxuICAgICAgICB0cmFuc2Zvcm06ICAgICAgICAgICAgJ3RyYW5zZm9ybU1hdHJpeCcsXG4gICAgICAgICdmaWxsLW9wYWNpdHknOiAgICAgICAnZmlsbE9wYWNpdHknLFxuICAgICAgICAnZmlsbC1ydWxlJzogICAgICAgICAgJ2ZpbGxSdWxlJyxcbiAgICAgICAgJ2ZvbnQtZmFtaWx5JzogICAgICAgICdmb250RmFtaWx5JyxcbiAgICAgICAgJ2ZvbnQtc2l6ZSc6ICAgICAgICAgICdmb250U2l6ZScsXG4gICAgICAgICdmb250LXN0eWxlJzogICAgICAgICAnZm9udFN0eWxlJyxcbiAgICAgICAgJ2ZvbnQtd2VpZ2h0JzogICAgICAgICdmb250V2VpZ2h0JyxcbiAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiAgICdzdHJva2VEYXNoQXJyYXknLFxuICAgICAgICAnc3Ryb2tlLWxpbmVjYXAnOiAgICAgJ3N0cm9rZUxpbmVDYXAnLFxuICAgICAgICAnc3Ryb2tlLWxpbmVqb2luJzogICAgJ3N0cm9rZUxpbmVKb2luJyxcbiAgICAgICAgJ3N0cm9rZS1taXRlcmxpbWl0JzogICdzdHJva2VNaXRlckxpbWl0JyxcbiAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogICAgICdzdHJva2VPcGFjaXR5JyxcbiAgICAgICAgJ3N0cm9rZS13aWR0aCc6ICAgICAgICdzdHJva2VXaWR0aCcsXG4gICAgICAgICd0ZXh0LWRlY29yYXRpb24nOiAgICAndGV4dERlY29yYXRpb24nLFxuICAgICAgICAndGV4dC1hbmNob3InOiAgICAgICAgJ29yaWdpblgnXG4gICAgICB9LFxuXG4gICAgICBjb2xvckF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIHN0cm9rZTogJ3N0cm9rZU9wYWNpdHknLFxuICAgICAgICBmaWxsOiAgICdmaWxsT3BhY2l0eSdcbiAgICAgIH07XG5cbiAgZmFicmljLmNzc1J1bGVzID0geyB9O1xuICBmYWJyaWMuZ3JhZGllbnREZWZzID0geyB9O1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUF0dHIoYXR0cikge1xuICAgIC8vIHRyYW5zZm9ybSBhdHRyaWJ1dGUgbmFtZXNcbiAgICBpZiAoYXR0ciBpbiBhdHRyaWJ1dGVzTWFwKSB7XG4gICAgICByZXR1cm4gYXR0cmlidXRlc01hcFthdHRyXTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHI7XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZShhdHRyLCB2YWx1ZSwgcGFyZW50QXR0cmlidXRlcywgZm9udFNpemUpIHtcbiAgICB2YXIgaXNBcnJheSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICAgIHBhcnNlZDtcblxuICAgIGlmICgoYXR0ciA9PT0gJ2ZpbGwnIHx8IGF0dHIgPT09ICdzdHJva2UnKSAmJiB2YWx1ZSA9PT0gJ25vbmUnKSB7XG4gICAgICB2YWx1ZSA9ICcnO1xuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAnc3Ryb2tlRGFzaEFycmF5Jykge1xuICAgICAgaWYgKHZhbHVlID09PSAnbm9uZScpIHtcbiAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvLC9nLCAnICcpLnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChuKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICd0cmFuc2Zvcm1NYXRyaXgnKSB7XG4gICAgICBpZiAocGFyZW50QXR0cmlidXRlcyAmJiBwYXJlbnRBdHRyaWJ1dGVzLnRyYW5zZm9ybU1hdHJpeCkge1xuICAgICAgICB2YWx1ZSA9IG11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMoXG4gICAgICAgICAgcGFyZW50QXR0cmlidXRlcy50cmFuc2Zvcm1NYXRyaXgsIGZhYnJpYy5wYXJzZVRyYW5zZm9ybUF0dHJpYnV0ZSh2YWx1ZSkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhbHVlID0gZmFicmljLnBhcnNlVHJhbnNmb3JtQXR0cmlidXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICB2YWx1ZSA9ICh2YWx1ZSA9PT0gJ25vbmUnIHx8IHZhbHVlID09PSAnaGlkZGVuJykgPyBmYWxzZSA6IHRydWU7XG4gICAgICAvLyBkaXNwbGF5PW5vbmUgb24gcGFyZW50IGVsZW1lbnQgYWx3YXlzIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBjaGlsZCBlbGVtZW50XG4gICAgICBpZiAocGFyZW50QXR0cmlidXRlcyAmJiBwYXJlbnRBdHRyaWJ1dGVzLnZpc2libGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdvcmlnaW5YJyAvKiB0ZXh0LWFuY2hvciAqLykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gJ3N0YXJ0JyA/ICdsZWZ0JyA6IHZhbHVlID09PSAnZW5kJyA/ICdyaWdodCcgOiAnY2VudGVyJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBwYXJzZWQgPSBpc0FycmF5ID8gdmFsdWUubWFwKHBhcnNlVW5pdCkgOiBwYXJzZVVuaXQodmFsdWUsIGZvbnRTaXplKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKCFpc0FycmF5ICYmIGlzTmFOKHBhcnNlZCkgPyB2YWx1ZSA6IHBhcnNlZCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgQXJyYXkgb2YgYXR0cmlidXRlcyB0byBwYXJzZVxuICAgKi9cbiAgZnVuY3Rpb24gX3NldFN0cm9rZUZpbGxPcGFjaXR5KGF0dHJpYnV0ZXMpIHtcbiAgICBmb3IgKHZhciBhdHRyIGluIGNvbG9yQXR0cmlidXRlcykge1xuXG4gICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXNbY29sb3JBdHRyaWJ1dGVzW2F0dHJdXSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXR0cmlidXRlc1thdHRyXSA9PT0gJycpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlc1thdHRyXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKCFmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVthdHRyXSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGF0dHJpYnV0ZXNbYXR0cl0gPSBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVthdHRyXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJpYnV0ZXNbYXR0cl0uaW5kZXhPZigndXJsKCcpID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKGF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgYXR0cmlidXRlc1thdHRyXSA9IGNvbG9yLnNldEFscGhhKHRvRml4ZWQoY29sb3IuZ2V0QWxwaGEoKSAqIGF0dHJpYnV0ZXNbY29sb3JBdHRyaWJ1dGVzW2F0dHJdXSwgMikpLnRvUmdiYSgpO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2dldE11bHRpcGxlTm9kZXMoZG9jLCBub2RlTmFtZXMpIHtcbiAgICB2YXIgbm9kZU5hbWUsIG5vZGVBcnJheSA9IFtdLCBub2RlTGlzdDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZU5hbWUgPSBub2RlTmFtZXNbaV07XG4gICAgICBub2RlTGlzdCA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShub2RlTmFtZSk7XG4gICAgICBub2RlQXJyYXkgPSBub2RlQXJyYXkuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG5vZGVMaXN0KSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlQXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIFwidHJhbnNmb3JtXCIgYXR0cmlidXRlLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdmFsdWVzXG4gICAqIEBzdGF0aWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZVZhbHVlIFN0cmluZyBjb250YWluaW5nIGF0dHJpYnV0ZSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgNiBlbGVtZW50cyByZXByZXNlbnRpbmcgdHJhbnNmb3JtYXRpb24gbWF0cml4XG4gICAqL1xuICBmYWJyaWMucGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gcm90YXRlTWF0cml4KG1hdHJpeCwgYXJncykge1xuICAgICAgdmFyIGNvcyA9IE1hdGguY29zKGFyZ3NbMF0pLCBzaW4gPSBNYXRoLnNpbihhcmdzWzBdKSxcbiAgICAgICAgICB4ID0gMCwgeSA9IDA7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgeCA9IGFyZ3NbMV07XG4gICAgICAgIHkgPSBhcmdzWzJdO1xuICAgICAgfVxuXG4gICAgICBtYXRyaXhbMF0gPSBjb3M7XG4gICAgICBtYXRyaXhbMV0gPSBzaW47XG4gICAgICBtYXRyaXhbMl0gPSAtc2luO1xuICAgICAgbWF0cml4WzNdID0gY29zO1xuICAgICAgbWF0cml4WzRdID0geCAtIChjb3MgKiB4IC0gc2luICogeSk7XG4gICAgICBtYXRyaXhbNV0gPSB5IC0gKHNpbiAqIHggKyBjb3MgKiB5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FsZU1hdHJpeChtYXRyaXgsIGFyZ3MpIHtcbiAgICAgIHZhciBtdWx0aXBsaWVyWCA9IGFyZ3NbMF0sXG4gICAgICAgICAgbXVsdGlwbGllclkgPSAoYXJncy5sZW5ndGggPT09IDIpID8gYXJnc1sxXSA6IGFyZ3NbMF07XG5cbiAgICAgIG1hdHJpeFswXSA9IG11bHRpcGxpZXJYO1xuICAgICAgbWF0cml4WzNdID0gbXVsdGlwbGllclk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2tld01hdHJpeChtYXRyaXgsIGFyZ3MsIHBvcykge1xuICAgICAgbWF0cml4W3Bvc10gPSBNYXRoLnRhbihmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKGFyZ3NbMF0pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGVNYXRyaXgobWF0cml4LCBhcmdzKSB7XG4gICAgICBtYXRyaXhbNF0gPSBhcmdzWzBdO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIG1hdHJpeFs1XSA9IGFyZ3NbMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWRlbnRpdHkgbWF0cml4XG4gICAgdmFyIGlNYXRyaXggPSBbXG4gICAgICAgICAgMSwgLy8gYVxuICAgICAgICAgIDAsIC8vIGJcbiAgICAgICAgICAwLCAvLyBjXG4gICAgICAgICAgMSwgLy8gZFxuICAgICAgICAgIDAsIC8vIGVcbiAgICAgICAgICAwICAvLyBmXG4gICAgICAgIF0sXG5cbiAgICAgICAgLy8gPT0gYmVnaW4gdHJhbnNmb3JtIHJlZ2V4cFxuICAgICAgICBudW1iZXIgPSBmYWJyaWMucmVOdW0sXG5cbiAgICAgICAgY29tbWFXc3AgPSAnKD86XFxcXHMrLD9cXFxccyp8LFxcXFxzKiknLFxuXG4gICAgICAgIHNrZXdYID0gJyg/Oihza2V3WClcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccypcXFxcKSknLFxuXG4gICAgICAgIHNrZXdZID0gJyg/Oihza2V3WSlcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccypcXFxcKSknLFxuXG4gICAgICAgIHJvdGF0ZSA9ICcoPzoocm90YXRlKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKSg/OicgK1xuICAgICAgICAgICAgICAgICAgICBjb21tYVdzcCArICcoJyArIG51bWJlciArICcpJyArXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hV3NwICsgJygnICsgbnVtYmVyICsgJykpP1xcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgc2NhbGUgPSAnKD86KHNjYWxlKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKSg/OicgK1xuICAgICAgICAgICAgICAgICAgICBjb21tYVdzcCArICcoJyArIG51bWJlciArICcpKT9cXFxccypcXFxcKSknLFxuXG4gICAgICAgIHRyYW5zbGF0ZSA9ICcoPzoodHJhbnNsYXRlKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKSg/OicgK1xuICAgICAgICAgICAgICAgICAgICBjb21tYVdzcCArICcoJyArIG51bWJlciArICcpKT9cXFxccypcXFxcKSknLFxuXG4gICAgICAgIG1hdHJpeCA9ICcoPzoobWF0cml4KVxcXFxzKlxcXFwoXFxcXHMqJyArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgKyBjb21tYVdzcCArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgKyBjb21tYVdzcCArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgKyBjb21tYVdzcCArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgKyBjb21tYVdzcCArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgKyBjb21tYVdzcCArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgK1xuICAgICAgICAgICAgICAgICAgJ1xcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgdHJhbnNmb3JtID0gJyg/OicgK1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXggKyAnfCcgK1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGUgKyAnfCcgK1xuICAgICAgICAgICAgICAgICAgICBzY2FsZSArICd8JyArXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZSArICd8JyArXG4gICAgICAgICAgICAgICAgICAgIHNrZXdYICsgJ3wnICtcbiAgICAgICAgICAgICAgICAgICAgc2tld1kgK1xuICAgICAgICAgICAgICAgICAgICAnKScsXG5cbiAgICAgICAgdHJhbnNmb3JtcyA9ICcoPzonICsgdHJhbnNmb3JtICsgJyg/OicgKyBjb21tYVdzcCArICcqJyArIHRyYW5zZm9ybSArICcpKicgKyAnKScsXG5cbiAgICAgICAgdHJhbnNmb3JtTGlzdCA9ICdeXFxcXHMqKD86JyArIHRyYW5zZm9ybXMgKyAnPylcXFxccyokJyxcblxuICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvY29vcmRzLmh0bWwjVHJhbnNmb3JtQXR0cmlidXRlXG4gICAgICAgIHJlVHJhbnNmb3JtTGlzdCA9IG5ldyBSZWdFeHAodHJhbnNmb3JtTGlzdCksXG4gICAgICAgIC8vID09IGVuZCB0cmFuc2Zvcm0gcmVnZXhwXG5cbiAgICAgICAgcmVUcmFuc2Zvcm0gPSBuZXcgUmVnRXhwKHRyYW5zZm9ybSwgJ2cnKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhdHRyaWJ1dGVWYWx1ZSkge1xuXG4gICAgICAvLyBzdGFydCB3aXRoIGlkZW50aXR5IG1hdHJpeFxuICAgICAgdmFyIG1hdHJpeCA9IGlNYXRyaXguY29uY2F0KCksXG4gICAgICAgICAgbWF0cmljZXMgPSBbXTtcblxuICAgICAgLy8gcmV0dXJuIGlmIG5vIGFyZ3VtZW50IHdhcyBnaXZlbiBvclxuICAgICAgLy8gYW4gYXJndW1lbnQgZG9lcyBub3QgbWF0Y2ggdHJhbnNmb3JtIGF0dHJpYnV0ZSByZWdleHBcbiAgICAgIGlmICghYXR0cmlidXRlVmFsdWUgfHwgKGF0dHJpYnV0ZVZhbHVlICYmICFyZVRyYW5zZm9ybUxpc3QudGVzdChhdHRyaWJ1dGVWYWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICB9XG5cbiAgICAgIGF0dHJpYnV0ZVZhbHVlLnJlcGxhY2UocmVUcmFuc2Zvcm0sIGZ1bmN0aW9uKG1hdGNoKSB7XG5cbiAgICAgICAgdmFyIG0gPSBuZXcgUmVnRXhwKHRyYW5zZm9ybSkuZXhlYyhtYXRjaCkuZmlsdGVyKGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAvLyBtYXRjaCAhPT0gJycgJiYgbWF0Y2ggIT0gbnVsbFxuICAgICAgICAgICAgICByZXR1cm4gKCEhbWF0Y2gpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvcGVyYXRpb24gPSBtWzFdLFxuICAgICAgICAgICAgYXJncyA9IG0uc2xpY2UoMikubWFwKHBhcnNlRmxvYXQpO1xuXG4gICAgICAgIHN3aXRjaCAob3BlcmF0aW9uKSB7XG4gICAgICAgICAgY2FzZSAndHJhbnNsYXRlJzpcbiAgICAgICAgICAgIHRyYW5zbGF0ZU1hdHJpeChtYXRyaXgsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncm90YXRlJzpcbiAgICAgICAgICAgIGFyZ3NbMF0gPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKGFyZ3NbMF0pO1xuICAgICAgICAgICAgcm90YXRlTWF0cml4KG1hdHJpeCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzY2FsZSc6XG4gICAgICAgICAgICBzY2FsZU1hdHJpeChtYXRyaXgsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2tld1gnOlxuICAgICAgICAgICAgc2tld01hdHJpeChtYXRyaXgsIGFyZ3MsIDIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2tld1knOlxuICAgICAgICAgICAgc2tld01hdHJpeChtYXRyaXgsIGFyZ3MsIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbWF0cml4JzpcbiAgICAgICAgICAgIG1hdHJpeCA9IGFyZ3M7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNuYXBzaG90IGN1cnJlbnQgbWF0cml4IGludG8gbWF0cmljZXMgYXJyYXlcbiAgICAgICAgbWF0cmljZXMucHVzaChtYXRyaXguY29uY2F0KCkpO1xuICAgICAgICAvLyByZXNldFxuICAgICAgICBtYXRyaXggPSBpTWF0cml4LmNvbmNhdCgpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBjb21iaW5lZE1hdHJpeCA9IG1hdHJpY2VzWzBdO1xuICAgICAgd2hpbGUgKG1hdHJpY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbWF0cmljZXMuc2hpZnQoKTtcbiAgICAgICAgY29tYmluZWRNYXRyaXggPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKGNvbWJpbmVkTWF0cml4LCBtYXRyaWNlc1swXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tYmluZWRNYXRyaXg7XG4gICAgfTtcbiAgfSkoKTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlU3R5bGVTdHJpbmcoc3R5bGUsIG9TdHlsZSkge1xuICAgIHZhciBhdHRyLCB2YWx1ZTtcbiAgICBzdHlsZS5yZXBsYWNlKC87XFxzKiQvLCAnJykuc3BsaXQoJzsnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgdmFyIHBhaXIgPSBjaHVuay5zcGxpdCgnOicpO1xuXG4gICAgICBhdHRyID0gbm9ybWFsaXplQXR0cihwYWlyWzBdLnRyaW0oKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUoYXR0ciwgcGFpclsxXS50cmltKCkpO1xuXG4gICAgICBvU3R5bGVbYXR0cl0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VTdHlsZU9iamVjdChzdHlsZSwgb1N0eWxlKSB7XG4gICAgdmFyIGF0dHIsIHZhbHVlO1xuICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3R5bGVbcHJvcF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBhdHRyID0gbm9ybWFsaXplQXR0cihwcm9wLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZShhdHRyLCBzdHlsZVtwcm9wXSk7XG5cbiAgICAgIG9TdHlsZVthdHRyXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0R2xvYmFsU3R5bGVzRm9yRWxlbWVudChlbGVtZW50LCBzdmdVaWQpIHtcbiAgICB2YXIgc3R5bGVzID0geyB9O1xuICAgIGZvciAodmFyIHJ1bGUgaW4gZmFicmljLmNzc1J1bGVzW3N2Z1VpZF0pIHtcbiAgICAgIGlmIChlbGVtZW50TWF0Y2hlc1J1bGUoZWxlbWVudCwgcnVsZS5zcGxpdCgnICcpKSkge1xuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBmYWJyaWMuY3NzUnVsZXNbc3ZnVWlkXVtydWxlXSkge1xuICAgICAgICAgIHN0eWxlc1twcm9wZXJ0eV0gPSBmYWJyaWMuY3NzUnVsZXNbc3ZnVWlkXVtydWxlXVtwcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZWxlbWVudE1hdGNoZXNSdWxlKGVsZW1lbnQsIHNlbGVjdG9ycykge1xuICAgIHZhciBmaXJzdE1hdGNoaW5nLCBwYXJlbnRNYXRjaGluZyA9IHRydWU7XG4gICAgLy9zdGFydCBmcm9tIHJpZ2h0bW9zdCBzZWxlY3Rvci5cbiAgICBmaXJzdE1hdGNoaW5nID0gc2VsZWN0b3JNYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9ycy5wb3AoKSk7XG4gICAgaWYgKGZpcnN0TWF0Y2hpbmcgJiYgc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgcGFyZW50TWF0Y2hpbmcgPSBkb2VzU29tZVBhcmVudE1hdGNoKGVsZW1lbnQsIHNlbGVjdG9ycyk7XG4gICAgfVxuICAgIHJldHVybiBmaXJzdE1hdGNoaW5nICYmIHBhcmVudE1hdGNoaW5nICYmIChzZWxlY3RvcnMubGVuZ3RoID09PSAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvZXNTb21lUGFyZW50TWF0Y2goZWxlbWVudCwgc2VsZWN0b3JzKSB7XG4gICAgdmFyIHNlbGVjdG9yLCBwYXJlbnRNYXRjaGluZyA9IHRydWU7XG4gICAgd2hpbGUgKGVsZW1lbnQucGFyZW50Tm9kZSAmJiBlbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGUgPT09IDEgJiYgc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgaWYgKHBhcmVudE1hdGNoaW5nKSB7XG4gICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3JzLnBvcCgpO1xuICAgICAgfVxuICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE1hdGNoaW5nID0gc2VsZWN0b3JNYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdG9ycy5sZW5ndGggPT09IDA7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHNlbGVjdG9yTWF0Y2hlcyhlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUsXG4gICAgICAgIGNsYXNzTmFtZXMgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnY2xhc3MnKSxcbiAgICAgICAgaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKSwgbWF0Y2hlcjtcbiAgICAvLyBpIGNoZWNrIGlmIGEgc2VsZWN0b3IgbWF0Y2hlcyBzbGljaW5nIGF3YXkgcGFydCBmcm9tIGl0LlxuICAgIC8vIGlmIGkgZ2V0IGVtcHR5IHN0cmluZyBpIHNob3VsZCBtYXRjaFxuICAgIG1hdGNoZXIgPSBuZXcgUmVnRXhwKCdeJyArIG5vZGVOYW1lLCAnaScpO1xuICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShtYXRjaGVyLCAnJyk7XG4gICAgaWYgKGlkICYmIHNlbGVjdG9yLmxlbmd0aCkge1xuICAgICAgbWF0Y2hlciA9IG5ldyBSZWdFeHAoJyMnICsgaWQgKyAnKD8hW2EtekEtWlxcXFwtXSspJywgJ2knKTtcbiAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShtYXRjaGVyLCAnJyk7XG4gICAgfVxuICAgIGlmIChjbGFzc05hbWVzICYmIHNlbGVjdG9yLmxlbmd0aCkge1xuICAgICAgY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXMuc3BsaXQoJyAnKTtcbiAgICAgIGZvciAodmFyIGkgPSBjbGFzc05hbWVzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICBtYXRjaGVyID0gbmV3IFJlZ0V4cCgnXFxcXC4nICsgY2xhc3NOYW1lc1tpXSArICcoPyFbYS16QS1aXFxcXC1dKyknLCAnaScpO1xuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UobWF0Y2hlciwgJycpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0b3IubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHRvIHN1cHBvcnQgSUU4IG1pc3NpbmcgZ2V0RWxlbWVudEJ5SWQgb24gU1ZHZG9jdW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIGVsZW1lbnRCeUlkKGRvYywgaWQpIHtcbiAgICB2YXIgZWw7XG4gICAgZG9jLmdldEVsZW1lbnRCeUlkICYmIChlbCA9IGRvYy5nZXRFbGVtZW50QnlJZChpZCkpO1xuICAgIGlmIChlbCkge1xuICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbiAgICB2YXIgbm9kZSwgaSwgbm9kZWxpc3QgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZWxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGUgPSBub2RlbGlzdFtpXTtcbiAgICAgIGlmIChpZCA9PT0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2lkJykpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVVzZURpcmVjdGl2ZXMoZG9jKSB7XG4gICAgdmFyIG5vZGVsaXN0ID0gX2dldE11bHRpcGxlTm9kZXMoZG9jLCBbJ3VzZScsICdzdmc6dXNlJ10pLCBpID0gMDtcblxuICAgIHdoaWxlIChub2RlbGlzdC5sZW5ndGggJiYgaSA8IG5vZGVsaXN0Lmxlbmd0aCkge1xuICAgICAgdmFyIGVsID0gbm9kZWxpc3RbaV0sXG4gICAgICAgICAgeGxpbmsgPSBlbC5nZXRBdHRyaWJ1dGUoJ3hsaW5rOmhyZWYnKS5zdWJzdHIoMSksXG4gICAgICAgICAgeCA9IGVsLmdldEF0dHJpYnV0ZSgneCcpIHx8IDAsXG4gICAgICAgICAgeSA9IGVsLmdldEF0dHJpYnV0ZSgneScpIHx8IDAsXG4gICAgICAgICAgZWwyID0gZWxlbWVudEJ5SWQoZG9jLCB4bGluaykuY2xvbmVOb2RlKHRydWUpLFxuICAgICAgICAgIGN1cnJlbnRUcmFucyA9IChlbDIuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKSB8fCAnJykgKyAnIHRyYW5zbGF0ZSgnICsgeCArICcsICcgKyB5ICsgJyknLFxuICAgICAgICAgIHBhcmVudE5vZGUsIG9sZExlbmd0aCA9IG5vZGVsaXN0Lmxlbmd0aCwgYXR0ciwgaiwgYXR0cnMsIGw7XG5cbiAgICAgIGFwcGx5Vmlld2JveFRyYW5zZm9ybShlbDIpO1xuICAgICAgaWYgKC9ec3ZnJC9pLnRlc3QoZWwyLm5vZGVOYW1lKSkge1xuICAgICAgICB2YXIgZWwzID0gZWwyLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZycpO1xuICAgICAgICBmb3IgKGogPSAwLCBhdHRycyA9IGVsMi5hdHRyaWJ1dGVzLCBsID0gYXR0cnMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgYXR0ciA9IGF0dHJzLml0ZW0oaik7XG4gICAgICAgICAgZWwzLnNldEF0dHJpYnV0ZShhdHRyLm5vZGVOYW1lLCBhdHRyLm5vZGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWwyLmZpcnN0Q2hpbGQgIT0gbnVsbFxuICAgICAgICB3aGlsZSAoZWwyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBlbDMuYXBwZW5kQ2hpbGQoZWwyLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsMiA9IGVsMztcbiAgICAgIH1cblxuICAgICAgZm9yIChqID0gMCwgYXR0cnMgPSBlbC5hdHRyaWJ1dGVzLCBsID0gYXR0cnMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICAgIGF0dHIgPSBhdHRycy5pdGVtKGopO1xuICAgICAgICBpZiAoYXR0ci5ub2RlTmFtZSA9PT0gJ3gnIHx8IGF0dHIubm9kZU5hbWUgPT09ICd5JyB8fCBhdHRyLm5vZGVOYW1lID09PSAneGxpbms6aHJlZicpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdHRyLm5vZGVOYW1lID09PSAndHJhbnNmb3JtJykge1xuICAgICAgICAgIGN1cnJlbnRUcmFucyA9IGF0dHIubm9kZVZhbHVlICsgJyAnICsgY3VycmVudFRyYW5zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGVsMi5zZXRBdHRyaWJ1dGUoYXR0ci5ub2RlTmFtZSwgYXR0ci5ub2RlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVsMi5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIGN1cnJlbnRUcmFucyk7XG4gICAgICBlbDIuc2V0QXR0cmlidXRlKCdpbnN0YW50aWF0ZWRfYnlfdXNlJywgJzEnKTtcbiAgICAgIGVsMi5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICBwYXJlbnROb2RlID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGVsMiwgZWwpO1xuICAgICAgLy8gc29tZSBicm93c2VycyBkbyBub3Qgc2hvcnRlbiBub2RlbGlzdCBhZnRlciByZXBsYWNlQ2hpbGQgKElFOClcbiAgICAgIGlmIChub2RlbGlzdC5sZW5ndGggPT09IG9sZExlbmd0aCkge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2Nvb3Jkcy5odG1sI1ZpZXdCb3hBdHRyaWJ1dGVcbiAgLy8gbWF0Y2hlcywgZS5nLjogKzE0LjU2ZS0xMiwgZXRjLlxuICB2YXIgcmVWaWV3Qm94QXR0clZhbHVlID0gbmV3IFJlZ0V4cChcbiAgICAnXicgK1xuICAgICdcXFxccyooJyArIGZhYnJpYy5yZU51bSArICcrKVxcXFxzKiw/JyArXG4gICAgJ1xcXFxzKignICsgZmFicmljLnJlTnVtICsgJyspXFxcXHMqLD8nICtcbiAgICAnXFxcXHMqKCcgKyBmYWJyaWMucmVOdW0gKyAnKylcXFxccyosPycgK1xuICAgICdcXFxccyooJyArIGZhYnJpYy5yZU51bSArICcrKVxcXFxzKicgK1xuICAgICckJ1xuICApO1xuXG4gIC8qKlxuICAgKiBBZGQgYSA8Zz4gZWxlbWVudCB0aGF0IGVudmVsb3AgYWxsIGNoaWxkIGVsZW1lbnRzIGFuZCBtYWtlcyB0aGUgdmlld2JveCB0cmFuc2Zvcm1NYXRyaXggZGVzY2VuZCBvbiBhbGwgZWxlbWVudHNcbiAgICovXG4gIGZ1bmN0aW9uIGFwcGx5Vmlld2JveFRyYW5zZm9ybShlbGVtZW50KSB7XG5cbiAgICB2YXIgdmlld0JveEF0dHIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndmlld0JveCcpLFxuICAgICAgICBzY2FsZVggPSAxLFxuICAgICAgICBzY2FsZVkgPSAxLFxuICAgICAgICBtaW5YID0gMCxcbiAgICAgICAgbWluWSA9IDAsXG4gICAgICAgIHZpZXdCb3hXaWR0aCwgdmlld0JveEhlaWdodCwgbWF0cml4LCBlbCxcbiAgICAgICAgd2lkdGhBdHRyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksXG4gICAgICAgIGhlaWdodEF0dHIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaGVpZ2h0JyksXG4gICAgICAgIHggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgneCcpIHx8IDAsXG4gICAgICAgIHkgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgneScpIHx8IDAsXG4gICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW8gPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycpIHx8ICcnLFxuICAgICAgICBtaXNzaW5nVmlld0JveCA9ICghdmlld0JveEF0dHIgfHwgIXJlVmlld0JveFRhZ05hbWVzLnRlc3QoZWxlbWVudC5ub2RlTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8ICEodmlld0JveEF0dHIgPSB2aWV3Qm94QXR0ci5tYXRjaChyZVZpZXdCb3hBdHRyVmFsdWUpKSksXG4gICAgICAgIG1pc3NpbmdEaW1BdHRyID0gKCF3aWR0aEF0dHIgfHwgIWhlaWdodEF0dHIgfHwgd2lkdGhBdHRyID09PSAnMTAwJScgfHwgaGVpZ2h0QXR0ciA9PT0gJzEwMCUnKSxcbiAgICAgICAgdG9CZVBhcnNlZCA9IG1pc3NpbmdWaWV3Qm94ICYmIG1pc3NpbmdEaW1BdHRyLFxuICAgICAgICBwYXJzZWREaW0gPSB7IH0sIHRyYW5zbGF0ZU1hdHJpeCA9ICcnO1xuXG4gICAgcGFyc2VkRGltLndpZHRoID0gMDtcbiAgICBwYXJzZWREaW0uaGVpZ2h0ID0gMDtcbiAgICBwYXJzZWREaW0udG9CZVBhcnNlZCA9IHRvQmVQYXJzZWQ7XG5cbiAgICBpZiAodG9CZVBhcnNlZCkge1xuICAgICAgcmV0dXJuIHBhcnNlZERpbTtcbiAgICB9XG5cbiAgICBpZiAobWlzc2luZ1ZpZXdCb3gpIHtcbiAgICAgIHBhcnNlZERpbS53aWR0aCA9IHBhcnNlVW5pdCh3aWR0aEF0dHIpO1xuICAgICAgcGFyc2VkRGltLmhlaWdodCA9IHBhcnNlVW5pdChoZWlnaHRBdHRyKTtcbiAgICAgIHJldHVybiBwYXJzZWREaW07XG4gICAgfVxuXG4gICAgbWluWCA9IC1wYXJzZUZsb2F0KHZpZXdCb3hBdHRyWzFdKTtcbiAgICBtaW5ZID0gLXBhcnNlRmxvYXQodmlld0JveEF0dHJbMl0pO1xuICAgIHZpZXdCb3hXaWR0aCA9IHBhcnNlRmxvYXQodmlld0JveEF0dHJbM10pO1xuICAgIHZpZXdCb3hIZWlnaHQgPSBwYXJzZUZsb2F0KHZpZXdCb3hBdHRyWzRdKTtcblxuICAgIGlmICghbWlzc2luZ0RpbUF0dHIpIHtcbiAgICAgIHBhcnNlZERpbS53aWR0aCA9IHBhcnNlVW5pdCh3aWR0aEF0dHIpO1xuICAgICAgcGFyc2VkRGltLmhlaWdodCA9IHBhcnNlVW5pdChoZWlnaHRBdHRyKTtcbiAgICAgIHNjYWxlWCA9IHBhcnNlZERpbS53aWR0aCAvIHZpZXdCb3hXaWR0aDtcbiAgICAgIHNjYWxlWSA9IHBhcnNlZERpbS5oZWlnaHQgLyB2aWV3Qm94SGVpZ2h0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHBhcnNlZERpbS53aWR0aCA9IHZpZXdCb3hXaWR0aDtcbiAgICAgIHBhcnNlZERpbS5oZWlnaHQgPSB2aWV3Qm94SGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIGRlZmF1bHQgaXMgdG8gcHJlc2VydmUgYXNwZWN0IHJhdGlvXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbyA9IGZhYnJpYy51dGlsLnBhcnNlUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZShwcmVzZXJ2ZUFzcGVjdFJhdGlvKTtcbiAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5hbGlnblggIT09ICdub25lJykge1xuICAgICAgLy90cmFuc2xhdGUgYWxsIGNvbnRhaW5lciBmb3IgdGhlIGVmZmVjdCBvZiBNaWQsIE1pbiwgTWF4XG4gICAgICBzY2FsZVkgPSBzY2FsZVggPSAoc2NhbGVYID4gc2NhbGVZID8gc2NhbGVZIDogc2NhbGVYKTtcbiAgICB9XG5cbiAgICBpZiAoc2NhbGVYID09PSAxICYmIHNjYWxlWSA9PT0gMSAmJiBtaW5YID09PSAwICYmIG1pblkgPT09IDAgJiYgeCA9PT0gMCAmJiB5ID09PSAwKSB7XG4gICAgICByZXR1cm4gcGFyc2VkRGltO1xuICAgIH1cblxuICAgIGlmICh4IHx8IHkpIHtcbiAgICAgIHRyYW5zbGF0ZU1hdHJpeCA9ICcgdHJhbnNsYXRlKCcgKyBwYXJzZVVuaXQoeCkgKyAnICcgKyBwYXJzZVVuaXQoeSkgKyAnKSAnO1xuICAgIH1cblxuICAgIG1hdHJpeCA9IHRyYW5zbGF0ZU1hdHJpeCArICcgbWF0cml4KCcgKyBzY2FsZVggK1xuICAgICAgICAgICAgICAgICAgJyAwJyArXG4gICAgICAgICAgICAgICAgICAnIDAgJyArXG4gICAgICAgICAgICAgICAgICBzY2FsZVkgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgKG1pblggKiBzY2FsZVgpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgIChtaW5ZICogc2NhbGVZKSArICcpICc7XG5cbiAgICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ3N2ZycpIHtcbiAgICAgIGVsID0gZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2cnKTtcbiAgICAgIC8vIGVsZW1lbnQuZmlyc3RDaGlsZCAhPSBudWxsXG4gICAgICB3aGlsZSAoZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKGVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGVsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBlbCA9IGVsZW1lbnQ7XG4gICAgICBtYXRyaXggPSBlbC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpICsgbWF0cml4O1xuICAgIH1cblxuICAgIGVsLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgbWF0cml4KTtcbiAgICByZXR1cm4gcGFyc2VkRGltO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzQW5jZXN0b3JXaXRoTm9kZU5hbWUoZWxlbWVudCwgbm9kZU5hbWUpIHtcbiAgICB3aGlsZSAoZWxlbWVudCAmJiAoZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSkpIHtcbiAgICAgIGlmIChlbGVtZW50Lm5vZGVOYW1lICYmIG5vZGVOYW1lLnRlc3QoZWxlbWVudC5ub2RlTmFtZS5yZXBsYWNlKCdzdmc6JywgJycpKVxuICAgICAgICAmJiAhZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2luc3RhbnRpYXRlZF9ieV91c2UnKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBTVkcgZG9jdW1lbnQsIGNvbnZlcnRzIGl0IHRvIGFuIGFycmF5IG9mIGNvcnJlc3BvbmRpbmcgZmFicmljLiogaW5zdGFuY2VzIGFuZCBwYXNzZXMgdGhlbSB0byBhIGNhbGxiYWNrXG4gICAqIEBzdGF0aWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICogQHBhcmFtIHtTVkdEb2N1bWVudH0gZG9jIFNWRyBkb2N1bWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBjYWxsIHdoZW4gcGFyc2luZyBpcyBmaW5pc2hlZDtcbiAgICogSXQncyBiZWluZyBwYXNzZWQgYW4gYXJyYXkgb2YgZWxlbWVudHMgKHBhcnNlZCBmcm9tIGEgZG9jdW1lbnQpLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgU1ZHIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAqL1xuICBmYWJyaWMucGFyc2VTVkdEb2N1bWVudCA9IGZ1bmN0aW9uKGRvYywgY2FsbGJhY2ssIHJldml2ZXIpIHtcbiAgICBpZiAoIWRvYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBhcnNlVXNlRGlyZWN0aXZlcyhkb2MpO1xuXG4gICAgdmFyIHN2Z1VpZCA9ICBmYWJyaWMuT2JqZWN0Ll9fdWlkKyssXG4gICAgICAgIG9wdGlvbnMgPSBhcHBseVZpZXdib3hUcmFuc2Zvcm0oZG9jKSxcbiAgICAgICAgZGVzY2VuZGFudHMgPSBmYWJyaWMudXRpbC50b0FycmF5KGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpKTtcblxuICAgIG9wdGlvbnMuc3ZnVWlkID0gc3ZnVWlkO1xuXG4gICAgaWYgKGRlc2NlbmRhbnRzLmxlbmd0aCA9PT0gMCAmJiBmYWJyaWMuaXNMaWtlbHlOb2RlKSB7XG4gICAgICAvLyB3ZSdyZSBsaWtlbHkgaW4gbm9kZSwgd2hlcmUgXCJvMy14bWxcIiBsaWJyYXJ5IGZhaWxzIHRvIGdFQlROKFwiKlwiKVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FqYXhvcmcvbm9kZS1vMy14bWwvaXNzdWVzLzIxXG4gICAgICBkZXNjZW5kYW50cyA9IGRvYy5zZWxlY3ROb2RlcygnLy8qW25hbWUoLikhPVwic3ZnXCJdJyk7XG4gICAgICB2YXIgYXJyID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGVzY2VuZGFudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gZGVzY2VuZGFudHNbaV07XG4gICAgICB9XG4gICAgICBkZXNjZW5kYW50cyA9IGFycjtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudHMgPSBkZXNjZW5kYW50cy5maWx0ZXIoZnVuY3Rpb24oZWwpIHtcbiAgICAgIGFwcGx5Vmlld2JveFRyYW5zZm9ybShlbCk7XG4gICAgICByZXR1cm4gcmVBbGxvd2VkU1ZHVGFnTmFtZXMudGVzdChlbC5ub2RlTmFtZS5yZXBsYWNlKCdzdmc6JywgJycpKSAmJlxuICAgICAgICAgICAgIWhhc0FuY2VzdG9yV2l0aE5vZGVOYW1lKGVsLCByZU5vdEFsbG93ZWRBbmNlc3RvcnMpOyAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc3RydWN0Lmh0bWwjRGVmc0VsZW1lbnRcbiAgICB9KTtcblxuICAgIGlmICghZWxlbWVudHMgfHwgKGVsZW1lbnRzICYmICFlbGVtZW50cy5sZW5ndGgpKSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhbXSwge30pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZhYnJpYy5ncmFkaWVudERlZnNbc3ZnVWlkXSA9IGZhYnJpYy5nZXRHcmFkaWVudERlZnMoZG9jKTtcbiAgICBmYWJyaWMuY3NzUnVsZXNbc3ZnVWlkXSA9IGZhYnJpYy5nZXRDU1NSdWxlcyhkb2MpO1xuICAgIC8vIFByZWNlZGVuY2Ugb2YgcnVsZXM6ICAgc3R5bGUgPiBjbGFzcyA+IGF0dHJpYnV0ZVxuICAgIGZhYnJpYy5wYXJzZUVsZW1lbnRzKGVsZW1lbnRzLCBmdW5jdGlvbihpbnN0YW5jZXMpIHtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhpbnN0YW5jZXMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sIGNsb25lKG9wdGlvbnMpLCByZXZpdmVyKTtcbiAgfTtcblxuICB2YXIgcmVGb250RGVjbGFyYXRpb24gPSBuZXcgUmVnRXhwKFxuICAgICcobm9ybWFsfGl0YWxpYyk/XFxcXHMqKG5vcm1hbHxzbWFsbC1jYXBzKT9cXFxccyonICtcbiAgICAnKG5vcm1hbHxib2xkfGJvbGRlcnxsaWdodGVyfDEwMHwyMDB8MzAwfDQwMHw1MDB8NjAwfDcwMHw4MDB8OTAwKT9cXFxccyooJyArXG4gICAgICBmYWJyaWMucmVOdW0gK1xuICAgICcoPzpweHxjbXxtbXxlbXxwdHxwY3xpbikqKSg/OlxcXFwvKG5vcm1hbHwnICsgZmFicmljLnJlTnVtICsgJykpP1xcXFxzKyguKiknKTtcblxuICBleHRlbmQoZmFicmljLCB7XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgc2hvcnQgZm9udCBkZWNsYXJhdGlvbiwgYnVpbGRpbmcgYWRkaW5nIGl0cyBwcm9wZXJ0aWVzIHRvIGEgc3R5bGUgb2JqZWN0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgZm9udCBkZWNsYXJhdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvU3R5bGUgZGVmaW5pdGlvblxuICAgICAqL1xuICAgIHBhcnNlRm9udERlY2xhcmF0aW9uOiBmdW5jdGlvbih2YWx1ZSwgb1N0eWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaChyZUZvbnREZWNsYXJhdGlvbik7XG5cbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGZvbnRTdHlsZSA9IG1hdGNoWzFdLFxuICAgICAgICAgIC8vIGZvbnQgdmFyaWFudCBpcyBub3QgdXNlZFxuICAgICAgICAgIC8vIGZvbnRWYXJpYW50ID0gbWF0Y2hbMl0sXG4gICAgICAgICAgZm9udFdlaWdodCA9IG1hdGNoWzNdLFxuICAgICAgICAgIGZvbnRTaXplID0gbWF0Y2hbNF0sXG4gICAgICAgICAgbGluZUhlaWdodCA9IG1hdGNoWzVdLFxuICAgICAgICAgIGZvbnRGYW1pbHkgPSBtYXRjaFs2XTtcblxuICAgICAgaWYgKGZvbnRTdHlsZSkge1xuICAgICAgICBvU3R5bGUuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgICAgfVxuICAgICAgaWYgKGZvbnRXZWlnaHQpIHtcbiAgICAgICAgb1N0eWxlLmZvbnRXZWlnaHQgPSBpc05hTihwYXJzZUZsb2F0KGZvbnRXZWlnaHQpKSA/IGZvbnRXZWlnaHQgOiBwYXJzZUZsb2F0KGZvbnRXZWlnaHQpO1xuICAgICAgfVxuICAgICAgaWYgKGZvbnRTaXplKSB7XG4gICAgICAgIG9TdHlsZS5mb250U2l6ZSA9IHBhcnNlVW5pdChmb250U2l6ZSk7XG4gICAgICB9XG4gICAgICBpZiAoZm9udEZhbWlseSkge1xuICAgICAgICBvU3R5bGUuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICB9XG4gICAgICBpZiAobGluZUhlaWdodCkge1xuICAgICAgICBvU3R5bGUubGluZUhlaWdodCA9IGxpbmVIZWlnaHQgPT09ICdub3JtYWwnID8gMSA6IGxpbmVIZWlnaHQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhbiBTVkcgZG9jdW1lbnQsIHJldHVybmluZyBhbGwgb2YgdGhlIGdyYWRpZW50IGRlY2xhcmF0aW9ucyBmb3VuZCBpbiBpdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTVkdEb2N1bWVudH0gZG9jIFNWRyBkb2N1bWVudCB0byBwYXJzZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gR3JhZGllbnQgZGVmaW5pdGlvbnM7IGtleSBjb3JyZXNwb25kcyB0byBlbGVtZW50IGlkLCB2YWx1ZSAtLSB0byBncmFkaWVudCBkZWZpbml0aW9uIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXRHcmFkaWVudERlZnM6IGZ1bmN0aW9uKGRvYykge1xuICAgICAgdmFyIHRhZ0FycmF5ID0gW1xuICAgICAgICAgICAgJ2xpbmVhckdyYWRpZW50JyxcbiAgICAgICAgICAgICdyYWRpYWxHcmFkaWVudCcsXG4gICAgICAgICAgICAnc3ZnOmxpbmVhckdyYWRpZW50JyxcbiAgICAgICAgICAgICdzdmc6cmFkaWFsR3JhZGllbnQnXSxcbiAgICAgICAgICBlbExpc3QgPSBfZ2V0TXVsdGlwbGVOb2Rlcyhkb2MsIHRhZ0FycmF5KSxcbiAgICAgICAgICBlbCwgaiA9IDAsIGlkLCB4bGluayxcbiAgICAgICAgICBncmFkaWVudERlZnMgPSB7IH0sIGlkc1RvWGxpbmtNYXAgPSB7IH07XG5cbiAgICAgIGogPSBlbExpc3QubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgIGVsID0gZWxMaXN0W2pdO1xuICAgICAgICB4bGluayA9IGVsLmdldEF0dHJpYnV0ZSgneGxpbms6aHJlZicpO1xuICAgICAgICBpZCA9IGVsLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgaWYgKHhsaW5rKSB7XG4gICAgICAgICAgaWRzVG9YbGlua01hcFtpZF0gPSB4bGluay5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JhZGllbnREZWZzW2lkXSA9IGVsO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGlkIGluIGlkc1RvWGxpbmtNYXApIHtcbiAgICAgICAgdmFyIGVsMiA9IGdyYWRpZW50RGVmc1tpZHNUb1hsaW5rTWFwW2lkXV0uY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICBlbCA9IGdyYWRpZW50RGVmc1tpZF07XG4gICAgICAgIHdoaWxlIChlbDIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGVsMi5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGdyYWRpZW50RGVmcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYmplY3Qgb2YgYXR0cmlidXRlcycgbmFtZS92YWx1ZSwgZ2l2ZW4gZWxlbWVudCBhbmQgYW4gYXJyYXkgb2YgYXR0cmlidXRlIG5hbWVzO1xuICAgICAqIFBhcnNlcyBwYXJlbnQgXCJnXCIgbm9kZXMgcmVjdXJzaXZlbHkgdXB3YXJkcy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXR0cmlidXRlcyBBcnJheSBvZiBhdHRyaWJ1dGVzIHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyBwYXJzZWQgYXR0cmlidXRlcycgbmFtZXMvdmFsdWVzXG4gICAgICovXG4gICAgcGFyc2VBdHRyaWJ1dGVzOiBmdW5jdGlvbihlbGVtZW50LCBhdHRyaWJ1dGVzLCBzdmdVaWQpIHtcblxuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlLFxuICAgICAgICAgIHBhcmVudEF0dHJpYnV0ZXMgPSB7IH0sXG4gICAgICAgICAgZm9udFNpemU7XG5cbiAgICAgIGlmICh0eXBlb2Ygc3ZnVWlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzdmdVaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3ZnVWlkJyk7XG4gICAgICB9XG4gICAgICAvLyBpZiB0aGVyZSdzIGEgcGFyZW50IGNvbnRhaW5lciAoYGdgIG9yIGBhYCBvciBgc3ltYm9sYCBub2RlKSwgcGFyc2UgaXRzIGF0dHJpYnV0ZXMgcmVjdXJzaXZlbHkgdXB3YXJkc1xuICAgICAgaWYgKGVsZW1lbnQucGFyZW50Tm9kZSAmJiByZUFsbG93ZWRQYXJlbnRzLnRlc3QoZWxlbWVudC5wYXJlbnROb2RlLm5vZGVOYW1lKSkge1xuICAgICAgICBwYXJlbnRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LnBhcmVudE5vZGUsIGF0dHJpYnV0ZXMsIHN2Z1VpZCk7XG4gICAgICB9XG4gICAgICBmb250U2l6ZSA9IChwYXJlbnRBdHRyaWJ1dGVzICYmIHBhcmVudEF0dHJpYnV0ZXMuZm9udFNpemUgKSB8fFxuICAgICAgICAgICAgICAgICBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZm9udC1zaXplJykgfHwgZmFicmljLlRleHQuREVGQVVMVF9TVkdfRk9OVF9TSVpFO1xuXG4gICAgICB2YXIgb3duQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMucmVkdWNlKGZ1bmN0aW9uKG1lbW8sIGF0dHIpIHtcbiAgICAgICAgdmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgYXR0ciA9IG5vcm1hbGl6ZUF0dHIoYXR0cik7XG4gICAgICAgICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZShhdHRyLCB2YWx1ZSwgcGFyZW50QXR0cmlidXRlcywgZm9udFNpemUpO1xuXG4gICAgICAgICAgbWVtb1thdHRyXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgfSwgeyB9KTtcblxuICAgICAgLy8gYWRkIHZhbHVlcyBwYXJzZWQgZnJvbSBzdHlsZSwgd2hpY2ggdGFrZSBwcmVjZWRlbmNlIG92ZXIgYXR0cmlidXRlc1xuICAgICAgLy8gKHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3N0eWxpbmcuaHRtbCNVc2luZ1ByZXNlbnRhdGlvbkF0dHJpYnV0ZXMpXG4gICAgICBvd25BdHRyaWJ1dGVzID0gZXh0ZW5kKG93bkF0dHJpYnV0ZXMsXG4gICAgICAgIGV4dGVuZChnZXRHbG9iYWxTdHlsZXNGb3JFbGVtZW50KGVsZW1lbnQsIHN2Z1VpZCksIGZhYnJpYy5wYXJzZVN0eWxlQXR0cmlidXRlKGVsZW1lbnQpKSk7XG4gICAgICBpZiAob3duQXR0cmlidXRlcy5mb250KSB7XG4gICAgICAgIGZhYnJpYy5wYXJzZUZvbnREZWNsYXJhdGlvbihvd25BdHRyaWJ1dGVzLmZvbnQsIG93bkF0dHJpYnV0ZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9zZXRTdHJva2VGaWxsT3BhY2l0eShleHRlbmQocGFyZW50QXR0cmlidXRlcywgb3duQXR0cmlidXRlcykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGFuIGFycmF5IG9mIHN2ZyBlbGVtZW50cyB0byBjb3JyZXNwb25kaW5nIGZhYnJpYy4qIGluc3RhbmNlc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtBcnJheX0gZWxlbWVudHMgQXJyYXkgb2YgZWxlbWVudHMgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBCZWluZyBwYXNzZWQgYW4gYXJyYXkgb2YgZmFicmljIGluc3RhbmNlcyAodHJhbnNmb3JtZWQgZnJvbSBTVkcgZWxlbWVudHMpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBTVkcgZWxlbWVudHMsIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBwYXJzZUVsZW1lbnRzOiBmdW5jdGlvbihlbGVtZW50cywgY2FsbGJhY2ssIG9wdGlvbnMsIHJldml2ZXIpIHtcbiAgICAgIG5ldyBmYWJyaWMuRWxlbWVudHNQYXJzZXIoZWxlbWVudHMsIGNhbGxiYWNrLCBvcHRpb25zLCByZXZpdmVyKS5wYXJzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgXCJzdHlsZVwiIGF0dHJpYnV0ZSwgcmV0dW5pbmcgYW4gb2JqZWN0IHdpdGggdmFsdWVzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0cyB3aXRoIHZhbHVlcyBwYXJzZWQgZnJvbSBzdHlsZSBhdHRyaWJ1dGUgb2YgYW4gZWxlbWVudFxuICAgICAqL1xuICAgIHBhcnNlU3R5bGVBdHRyaWJ1dGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvU3R5bGUgPSB7IH0sXG4gICAgICAgICAgc3R5bGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcblxuICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICByZXR1cm4gb1N0eWxlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXJzZVN0eWxlU3RyaW5nKHN0eWxlLCBvU3R5bGUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHBhcnNlU3R5bGVPYmplY3Qoc3R5bGUsIG9TdHlsZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvU3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBcInBvaW50c1wiIGF0dHJpYnV0ZSwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHZhbHVlc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBvaW50cyBwb2ludHMgYXR0cmlidXRlIHN0cmluZ1xuICAgICAqIEByZXR1cm4ge0FycmF5fSBhcnJheSBvZiBwb2ludHNcbiAgICAgKi9cbiAgICBwYXJzZVBvaW50c0F0dHJpYnV0ZTogZnVuY3Rpb24ocG9pbnRzKSB7XG5cbiAgICAgIC8vIHBvaW50cyBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgYW5kIG11c3Qgbm90IGJlIGVtcHR5XG4gICAgICBpZiAoIXBvaW50cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gcmVwbGFjZSBjb21tYXMgd2l0aCB3aGl0ZXNwYWNlIGFuZCByZW1vdmUgYm9va2VuZGluZyB3aGl0ZXNwYWNlXG4gICAgICBwb2ludHMgPSBwb2ludHMucmVwbGFjZSgvLC9nLCAnICcpLnRyaW0oKTtcblxuICAgICAgcG9pbnRzID0gcG9pbnRzLnNwbGl0KC9cXHMrLyk7XG4gICAgICB2YXIgcGFyc2VkUG9pbnRzID0gW10sIGksIGxlbjtcblxuICAgICAgaSA9IDA7XG4gICAgICBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgZm9yICg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICBwYXJzZWRQb2ludHMucHVzaCh7XG4gICAgICAgICAgeDogcGFyc2VGbG9hdChwb2ludHNbaV0pLFxuICAgICAgICAgIHk6IHBhcnNlRmxvYXQocG9pbnRzW2kgKyAxXSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIG9kZCBudW1iZXIgb2YgcG9pbnRzIGlzIGFuIGVycm9yXG4gICAgICAvLyBpZiAocGFyc2VkUG9pbnRzLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgIC8vICAgcmV0dXJuIG51bGw7XG4gICAgICAvLyB9XG5cbiAgICAgIHJldHVybiBwYXJzZWRQb2ludHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgQ1NTIHJ1bGVzIGZvciBhIGdpdmVuIFNWRyBkb2N1bWVudFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTVkdEb2N1bWVudH0gZG9jIFNWRyBkb2N1bWVudCB0byBwYXJzZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ1NTIHJ1bGVzIG9mIHRoaXMgZG9jdW1lbnRcbiAgICAgKi9cbiAgICBnZXRDU1NSdWxlczogZnVuY3Rpb24oZG9jKSB7XG4gICAgICB2YXIgc3R5bGVzID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzdHlsZScpLFxuICAgICAgICAgIGFsbFJ1bGVzID0geyB9LCBydWxlcztcblxuICAgICAgLy8gdmVyeSBjcnVkZSBwYXJzaW5nIG9mIHN0eWxlIGNvbnRlbnRzXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3R5bGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIElFOSBkb2Vzbid0IHN1cHBvcnQgdGV4dENvbnRlbnQsIGJ1dCBwcm92aWRlcyB0ZXh0IGluc3RlYWQuXG4gICAgICAgIHZhciBzdHlsZUNvbnRlbnRzID0gc3R5bGVzW2ldLnRleHRDb250ZW50IHx8IHN0eWxlc1tpXS50ZXh0O1xuXG4gICAgICAgIC8vIHJlbW92ZSBjb21tZW50c1xuICAgICAgICBzdHlsZUNvbnRlbnRzID0gc3R5bGVDb250ZW50cy5yZXBsYWNlKC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvL2csICcnKTtcbiAgICAgICAgaWYgKHN0eWxlQ29udGVudHMudHJpbSgpID09PSAnJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJ1bGVzID0gc3R5bGVDb250ZW50cy5tYXRjaCgvW157XSpcXHtbXFxzXFxTXSo/XFx9L2cpO1xuICAgICAgICBydWxlcyA9IHJ1bGVzLm1hcChmdW5jdGlvbihydWxlKSB7IHJldHVybiBydWxlLnRyaW0oKTsgfSk7XG4gICAgICAgIHJ1bGVzLmZvckVhY2goZnVuY3Rpb24ocnVsZSkge1xuXG4gICAgICAgICAgdmFyIG1hdGNoID0gcnVsZS5tYXRjaCgvKFtcXHNcXFNdKj8pXFxzKlxceyhbXn1dKilcXH0vKSxcbiAgICAgICAgICAgICAgcnVsZU9iaiA9IHsgfSwgZGVjbGFyYXRpb24gPSBtYXRjaFsyXS50cmltKCksXG4gICAgICAgICAgICAgIHByb3BlcnR5VmFsdWVQYWlycyA9IGRlY2xhcmF0aW9uLnJlcGxhY2UoLzskLywgJycpLnNwbGl0KC9cXHMqO1xccyovKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm9wZXJ0eVZhbHVlUGFpcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYWlyID0gcHJvcGVydHlWYWx1ZVBhaXJzW2ldLnNwbGl0KC9cXHMqOlxccyovKSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IG5vcm1hbGl6ZUF0dHIocGFpclswXSksXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZShwcm9wZXJ0eSwgcGFpclsxXSwgcGFpclswXSk7XG4gICAgICAgICAgICBydWxlT2JqW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBydWxlID0gbWF0Y2hbMV07XG4gICAgICAgICAgcnVsZS5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24oX3J1bGUpIHtcbiAgICAgICAgICAgIF9ydWxlID0gX3J1bGUucmVwbGFjZSgvXnN2Zy9pLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgaWYgKF9ydWxlID09PSAnJykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxsUnVsZXNbX3J1bGVdKSB7XG4gICAgICAgICAgICAgIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoYWxsUnVsZXNbX3J1bGVdLCBydWxlT2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBhbGxSdWxlc1tfcnVsZV0gPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUocnVsZU9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFsbFJ1bGVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyB1cmwgY29ycmVzcG9uZGluZyB0byBhbiBTVkcgZG9jdW1lbnQsIGFuZCBwYXJzZXMgaXQgaW50byBhIHNldCBvZiBmYWJyaWMgb2JqZWN0cy5cbiAgICAgKiBOb3RlIHRoYXQgU1ZHIGlzIGZldGNoZWQgdmlhIFhNTEh0dHBSZXF1ZXN0LCBzbyBpdCBuZWVkcyB0byBjb25mb3JtIHRvIFNPUCAoU2FtZSBPcmlnaW4gUG9saWN5KVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgU1ZHIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAgICovXG4gICAgbG9hZFNWR0Zyb21VUkw6IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2ssIHJldml2ZXIpIHtcblxuICAgICAgdXJsID0gdXJsLnJlcGxhY2UoL15cXG5cXHMqLywgJycpLnRyaW0oKTtcbiAgICAgIG5ldyBmYWJyaWMudXRpbC5yZXF1ZXN0KHVybCwge1xuICAgICAgICBtZXRob2Q6ICdnZXQnLFxuICAgICAgICBvbkNvbXBsZXRlOiBvbkNvbXBsZXRlXG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gb25Db21wbGV0ZShyKSB7XG5cbiAgICAgICAgdmFyIHhtbCA9IHIucmVzcG9uc2VYTUw7XG4gICAgICAgIGlmICh4bWwgJiYgIXhtbC5kb2N1bWVudEVsZW1lbnQgJiYgZmFicmljLndpbmRvdy5BY3RpdmVYT2JqZWN0ICYmIHIucmVzcG9uc2VUZXh0KSB7XG4gICAgICAgICAgeG1sID0gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxET00nKTtcbiAgICAgICAgICB4bWwuYXN5bmMgPSAnZmFsc2UnO1xuICAgICAgICAgIC8vSUUgY2hva2VzIG9uIERPQ1RZUEVcbiAgICAgICAgICB4bWwubG9hZFhNTChyLnJlc3BvbnNlVGV4dC5yZXBsYWNlKC88IURPQ1RZUEVbXFxzXFxTXSo/KFxcW1tcXHNcXFNdKlxcXSkqPz4vaSwgJycpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXhtbCB8fCAheG1sLmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmFicmljLnBhcnNlU1ZHRG9jdW1lbnQoeG1sLmRvY3VtZW50RWxlbWVudCwgZnVuY3Rpb24gKHJlc3VsdHMsIG9wdGlvbnMpIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZXN1bHRzLCBvcHRpb25zKTtcbiAgICAgICAgfSwgcmV2aXZlcik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRha2VzIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIGFuIFNWRyBkb2N1bWVudCwgYW5kIHBhcnNlcyBpdCBpbnRvIGEgc2V0IG9mIGZhYnJpYyBvYmplY3RzXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBTVkcgZWxlbWVudHMsIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBsb2FkU1ZHRnJvbVN0cmluZzogZnVuY3Rpb24oc3RyaW5nLCBjYWxsYmFjaywgcmV2aXZlcikge1xuICAgICAgc3RyaW5nID0gc3RyaW5nLnRyaW0oKTtcbiAgICAgIHZhciBkb2M7XG4gICAgICBpZiAodHlwZW9mIERPTVBhcnNlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgaWYgKHBhcnNlciAmJiBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKSB7XG4gICAgICAgICAgZG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhzdHJpbmcsICd0ZXh0L3htbCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmYWJyaWMud2luZG93LkFjdGl2ZVhPYmplY3QpIHtcbiAgICAgICAgZG9jID0gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxET00nKTtcbiAgICAgICAgZG9jLmFzeW5jID0gJ2ZhbHNlJztcbiAgICAgICAgLy8gSUUgY2hva2VzIG9uIERPQ1RZUEVcbiAgICAgICAgZG9jLmxvYWRYTUwoc3RyaW5nLnJlcGxhY2UoLzwhRE9DVFlQRVtcXHNcXFNdKj8oXFxbW1xcc1xcU10qXFxdKSo/Pi9pLCAnJykpO1xuICAgICAgfVxuXG4gICAgICBmYWJyaWMucGFyc2VTVkdEb2N1bWVudChkb2MuZG9jdW1lbnRFbGVtZW50LCBmdW5jdGlvbiAocmVzdWx0cywgb3B0aW9ucykge1xuICAgICAgICBjYWxsYmFjayhyZXN1bHRzLCBvcHRpb25zKTtcbiAgICAgIH0sIHJldml2ZXIpO1xuICAgIH1cbiAgfSk7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG5mYWJyaWMuRWxlbWVudHNQYXJzZXIgPSBmdW5jdGlvbihlbGVtZW50cywgY2FsbGJhY2ssIG9wdGlvbnMsIHJldml2ZXIpIHtcbiAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMucmV2aXZlciA9IHJldml2ZXI7XG4gIHRoaXMuc3ZnVWlkID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5zdmdVaWQpIHx8IDA7XG59O1xuXG5mYWJyaWMuRWxlbWVudHNQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaW5zdGFuY2VzID0gbmV3IEFycmF5KHRoaXMuZWxlbWVudHMubGVuZ3RoKTtcbiAgdGhpcy5udW1FbGVtZW50cyA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuXG4gIHRoaXMuY3JlYXRlT2JqZWN0cygpO1xufTtcblxuZmFicmljLkVsZW1lbnRzUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVPYmplY3RzID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdGhpcy5lbGVtZW50c1tpXS5zZXRBdHRyaWJ1dGUoJ3N2Z1VpZCcsIHRoaXMuc3ZnVWlkKTtcbiAgICAoZnVuY3Rpb24oX29iaiwgaSkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgX29iai5jcmVhdGVPYmplY3QoX29iai5lbGVtZW50c1tpXSwgaSk7XG4gICAgICB9LCAwKTtcbiAgICB9KSh0aGlzLCBpKTtcbiAgfVxufTtcblxuZmFicmljLkVsZW1lbnRzUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVPYmplY3QgPSBmdW5jdGlvbihlbCwgaW5kZXgpIHtcbiAgdmFyIGtsYXNzID0gZmFicmljW2ZhYnJpYy51dGlsLnN0cmluZy5jYXBpdGFsaXplKGVsLnRhZ05hbWUucmVwbGFjZSgnc3ZnOicsICcnKSldO1xuICBpZiAoa2xhc3MgJiYga2xhc3MuZnJvbUVsZW1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5fY3JlYXRlT2JqZWN0KGtsYXNzLCBlbCwgaW5kZXgpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICBmYWJyaWMubG9nKGVycik7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuY2hlY2tJZkRvbmUoKTtcbiAgfVxufTtcblxuZmFicmljLkVsZW1lbnRzUGFyc2VyLnByb3RvdHlwZS5fY3JlYXRlT2JqZWN0ID0gZnVuY3Rpb24oa2xhc3MsIGVsLCBpbmRleCkge1xuICBpZiAoa2xhc3MuYXN5bmMpIHtcbiAgICBrbGFzcy5mcm9tRWxlbWVudChlbCwgdGhpcy5jcmVhdGVDYWxsYmFjayhpbmRleCwgZWwpLCB0aGlzLm9wdGlvbnMpO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBvYmogPSBrbGFzcy5mcm9tRWxlbWVudChlbCwgdGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLnJlc29sdmVHcmFkaWVudChvYmosICdmaWxsJyk7XG4gICAgdGhpcy5yZXNvbHZlR3JhZGllbnQob2JqLCAnc3Ryb2tlJyk7XG4gICAgdGhpcy5yZXZpdmVyICYmIHRoaXMucmV2aXZlcihlbCwgb2JqKTtcbiAgICB0aGlzLmluc3RhbmNlc1tpbmRleF0gPSBvYmo7XG4gICAgdGhpcy5jaGVja0lmRG9uZSgpO1xuICB9XG59O1xuXG5mYWJyaWMuRWxlbWVudHNQYXJzZXIucHJvdG90eXBlLmNyZWF0ZUNhbGxiYWNrID0gZnVuY3Rpb24oaW5kZXgsIGVsKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICBfdGhpcy5yZXNvbHZlR3JhZGllbnQob2JqLCAnZmlsbCcpO1xuICAgIF90aGlzLnJlc29sdmVHcmFkaWVudChvYmosICdzdHJva2UnKTtcbiAgICBfdGhpcy5yZXZpdmVyICYmIF90aGlzLnJldml2ZXIoZWwsIG9iaik7XG4gICAgX3RoaXMuaW5zdGFuY2VzW2luZGV4XSA9IG9iajtcbiAgICBfdGhpcy5jaGVja0lmRG9uZSgpO1xuICB9O1xufTtcblxuZmFicmljLkVsZW1lbnRzUGFyc2VyLnByb3RvdHlwZS5yZXNvbHZlR3JhZGllbnQgPSBmdW5jdGlvbihvYmosIHByb3BlcnR5KSB7XG5cbiAgdmFyIGluc3RhbmNlRmlsbFZhbHVlID0gb2JqLmdldChwcm9wZXJ0eSk7XG4gIGlmICghKC9edXJsXFwoLykudGVzdChpbnN0YW5jZUZpbGxWYWx1ZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGdyYWRpZW50SWQgPSBpbnN0YW5jZUZpbGxWYWx1ZS5zbGljZSg1LCBpbnN0YW5jZUZpbGxWYWx1ZS5sZW5ndGggLSAxKTtcbiAgaWYgKGZhYnJpYy5ncmFkaWVudERlZnNbdGhpcy5zdmdVaWRdW2dyYWRpZW50SWRdKSB7XG4gICAgb2JqLnNldChwcm9wZXJ0eSxcbiAgICAgIGZhYnJpYy5HcmFkaWVudC5mcm9tRWxlbWVudChmYWJyaWMuZ3JhZGllbnREZWZzW3RoaXMuc3ZnVWlkXVtncmFkaWVudElkXSwgb2JqKSk7XG4gIH1cbn07XG5cbmZhYnJpYy5FbGVtZW50c1BhcnNlci5wcm90b3R5cGUuY2hlY2tJZkRvbmUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKC0tdGhpcy5udW1FbGVtZW50cyA9PT0gMCkge1xuICAgIHRoaXMuaW5zdGFuY2VzID0gdGhpcy5pbnN0YW5jZXMuZmlsdGVyKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCwgZXFlcWVxXG4gICAgICByZXR1cm4gZWwgIT0gbnVsbDtcbiAgICB9KTtcbiAgICB0aGlzLmNhbGxiYWNrKHRoaXMuaW5zdGFuY2VzKTtcbiAgfVxufTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qIEFkYXB0YXRpb24gb2Ygd29yayBvZiBLZXZpbiBMaW5kc2V5IChrZXZpbkBrZXZsaW5kZXYuY29tKSAqL1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KTtcblxuICBpZiAoZmFicmljLlBvaW50KSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5Qb2ludCBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBmYWJyaWMuUG9pbnQgPSBQb2ludDtcblxuICAvKipcbiAgICogUG9pbnQgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5Qb2ludFxuICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICovXG4gIGZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cblxuICBQb2ludC5wcm90b3R5cGUgPSAvKiogQGxlbmRzIGZhYnJpYy5Qb2ludC5wcm90b3R5cGUgKi8ge1xuXG4gICAgdHlwZTogJ3BvaW50JyxcblxuICAgIGNvbnN0cnVjdG9yOiBQb2ludCxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW5vdGhlciBwb2ludCB0byB0aGlzIG9uZSBhbmQgcmV0dXJucyBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSBuZXcgUG9pbnQgaW5zdGFuY2Ugd2l0aCBhZGRlZCB2YWx1ZXNcbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCArIHRoYXQueCwgdGhpcy55ICsgdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbm90aGVyIHBvaW50IHRvIHRoaXMgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYWRkRXF1YWxzOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgdGhpcy54ICs9IHRoYXQueDtcbiAgICAgIHRoaXMueSArPSB0aGF0Lnk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyB2YWx1ZSB0byB0aGlzIHBvaW50IGFuZCByZXR1cm5zIGEgbmV3IG9uZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IG5ldyBQb2ludCB3aXRoIGFkZGVkIHZhbHVlXG4gICAgICovXG4gICAgc2NhbGFyQWRkOiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCArIHNjYWxhciwgdGhpcy55ICsgc2NhbGFyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyB2YWx1ZSB0byB0aGlzIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzY2FsYXJBZGRFcXVhbHM6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHRoaXMueCArPSBzY2FsYXI7XG4gICAgICB0aGlzLnkgKz0gc2NhbGFyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyBhbm90aGVyIHBvaW50IGZyb20gdGhpcyBwb2ludCBhbmQgcmV0dXJucyBhIG5ldyBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gbmV3IFBvaW50IG9iamVjdCB3aXRoIHN1YnRyYWN0ZWQgdmFsdWVzXG4gICAgICovXG4gICAgc3VidHJhY3Q6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAtIHRoYXQueCwgdGhpcy55IC0gdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIGFub3RoZXIgcG9pbnQgZnJvbSB0aGlzIHBvaW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc3VidHJhY3RFcXVhbHM6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICB0aGlzLnggLT0gdGhhdC54O1xuICAgICAgdGhpcy55IC09IHRoYXQueTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdmFsdWUgZnJvbSB0aGlzIHBvaW50IGFuZCByZXR1cm5zIGEgbmV3IG9uZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgc2NhbGFyU3VidHJhY3Q6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54IC0gc2NhbGFyLCB0aGlzLnkgLSBzY2FsYXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdmFsdWUgZnJvbSB0aGlzIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzY2FsYXJTdWJ0cmFjdEVxdWFsczogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgdGhpcy54IC09IHNjYWxhcjtcbiAgICAgIHRoaXMueSAtPSBzY2FsYXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWlsdGlwbGllcyB0aGlzIHBvaW50IGJ5IGEgdmFsdWUgYW5kIHJldHVybnMgYSBuZXcgb25lXG4gICAgICogVE9ETzogcmVuYW1lIGluIHNjYWxhck11bHRpcGx5IGluIDIuMFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgbXVsdGlwbHk6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICogc2NhbGFyLCB0aGlzLnkgKiBzY2FsYXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNaWx0aXBsaWVzIHRoaXMgcG9pbnQgYnkgYSB2YWx1ZVxuICAgICAqIFRPRE86IHJlbmFtZSBpbiBzY2FsYXJNdWx0aXBseUVxdWFscyBpbiAyLjBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIG11bHRpcGx5RXF1YWxzOiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICB0aGlzLnggKj0gc2NhbGFyO1xuICAgICAgdGhpcy55ICo9IHNjYWxhcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIHRoaXMgcG9pbnQgYnkgYSB2YWx1ZSBhbmQgcmV0dXJucyBhIG5ldyBvbmVcbiAgICAgKiBUT0RPOiByZW5hbWUgaW4gc2NhbGFyRGl2aWRlIGluIDIuMFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgZGl2aWRlOiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAvIHNjYWxhciwgdGhpcy55IC8gc2NhbGFyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyB0aGlzIHBvaW50IGJ5IGEgdmFsdWVcbiAgICAgKiBUT0RPOiByZW5hbWUgaW4gc2NhbGFyRGl2aWRlRXF1YWxzIGluIDIuMFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZGl2aWRlRXF1YWxzOiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICB0aGlzLnggLz0gc2NhbGFyO1xuICAgICAgdGhpcy55IC89IHNjYWxhcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBwb2ludCBpcyBlcXVhbCB0byBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBlcTogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiAodGhpcy54ID09PSB0aGF0LnggJiYgdGhpcy55ID09PSB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBwb2ludCBpcyBsZXNzIHRoYW4gYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgbHQ6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gKHRoaXMueCA8IHRoYXQueCAmJiB0aGlzLnkgPCB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBwb2ludCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgbHRlOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuICh0aGlzLnggPD0gdGhhdC54ICYmIHRoaXMueSA8PSB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcblxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHBvaW50IGlzIGdyZWF0ZXIgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ3Q6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gKHRoaXMueCA+IHRoYXQueCAmJiB0aGlzLnkgPiB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBwb2ludCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ3RlOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuICh0aGlzLnggPj0gdGhhdC54ICYmIHRoaXMueSA+PSB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG5ldyBwb2ludCB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIGxpbmVhciBpbnRlcnBvbGF0aW9uIHdpdGggdGhpcyBvbmUgYW5kIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdCAsIHBvc2l0aW9uIG9mIGludGVycG9sYXRpb24sIGJldHdlZW4gMCBhbmQgMSBkZWZhdWx0IDAuNVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBsZXJwOiBmdW5jdGlvbiAodGhhdCwgdCkge1xuICAgICAgaWYgKHR5cGVvZiB0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0ID0gMC41O1xuICAgICAgfVxuICAgICAgdCA9IE1hdGgubWF4KE1hdGgubWluKDEsIHQpLCAwKTtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICsgKHRoYXQueCAtIHRoaXMueCkgKiB0LCB0aGlzLnkgKyAodGhhdC55IC0gdGhpcy55KSAqIHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGRpc3RhbmNlIGZyb20gdGhpcyBwb2ludCBhbmQgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBkaXN0YW5jZUZyb206IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICB2YXIgZHggPSB0aGlzLnggLSB0aGF0LngsXG4gICAgICAgICAgZHkgPSB0aGlzLnkgLSB0aGF0Lnk7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9pbnQgYmV0d2VlbiB0aGlzIHBvaW50IGFuZCBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIG1pZFBvaW50RnJvbTogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlcnAodGhhdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgcG9pbnQgd2hpY2ggaXMgdGhlIG1pbiBvZiB0aGlzIGFuZCBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIG1pbjogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQoTWF0aC5taW4odGhpcy54LCB0aGF0LngpLCBNYXRoLm1pbih0aGlzLnksIHRoYXQueSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHBvaW50IHdoaWNoIGlzIHRoZSBtYXggb2YgdGhpcyBhbmQgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBtYXg6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KE1hdGgubWF4KHRoaXMueCwgdGhhdC54KSwgTWF0aC5tYXgodGhpcy55LCB0aGF0LnkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBwb2ludFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMueCArICcsJyArIHRoaXMueTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB4L3kgb2YgdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0WFk6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgdGhpcy55ID0geTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHggb2YgdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFg6IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgeSBvZiB0aGlzIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0WTogZnVuY3Rpb24gKHkpIHtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB4L3kgb2YgdGhpcyBwb2ludCBmcm9tIGFub3RoZXIgcG9pbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRGcm9tUG9pbnQ6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICB0aGlzLnggPSB0aGF0Lng7XG4gICAgICB0aGlzLnkgPSB0aGF0Lnk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3dhcHMgeC95IG9mIHRoaXMgcG9pbnQgYW5kIGFub3RoZXIgcG9pbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqL1xuICAgIHN3YXA6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICB2YXIgeCA9IHRoaXMueCxcbiAgICAgICAgICB5ID0gdGhpcy55O1xuICAgICAgdGhpcy54ID0gdGhhdC54O1xuICAgICAgdGhpcy55ID0gdGhhdC55O1xuICAgICAgdGhhdC54ID0geDtcbiAgICAgIHRoYXQueSA9IHk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBhIGNsb25lZCBpbnN0YW5jZSBvZiB0aGUgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyogQWRhcHRhdGlvbiBvZiB3b3JrIG9mIEtldmluIExpbmRzZXkgKGtldmluQGtldmxpbmRldi5jb20pICovXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KTtcblxuICBpZiAoZmFicmljLkludGVyc2VjdGlvbikge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuSW50ZXJzZWN0aW9uIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcnNlY3Rpb24gY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbnRlcnNlY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIEludGVyc2VjdGlvbihzdGF0dXMpIHtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLnBvaW50cyA9IFtdO1xuICB9XG5cbiAgZmFicmljLkludGVyc2VjdGlvbiA9IEludGVyc2VjdGlvbjtcblxuICBmYWJyaWMuSW50ZXJzZWN0aW9uLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgZmFicmljLkludGVyc2VjdGlvbi5wcm90b3R5cGUgKi8ge1xuXG4gICAgY29uc3RydWN0b3I6IEludGVyc2VjdGlvbixcblxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgYSBwb2ludCB0byBpbnRlcnNlY3Rpb25cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFwcGVuZFBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHRoaXMucG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgcG9pbnRzIHRvIGludGVyc2VjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50c1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JbnRlcnNlY3Rpb259IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYXBwZW5kUG9pbnRzOiBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgICB0aGlzLnBvaW50cyA9IHRoaXMucG9pbnRzLmNvbmNhdChwb2ludHMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgb25lIGxpbmUgaW50ZXJzZWN0cyBhbm90aGVyXG4gICAqIFRPRE86IHJlbmFtZSBpbiBpbnRlcnNlY3RTZWdtZW50U2VnbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBhMVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gYTJcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGIxXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBiMlxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufVxuICAgKi9cbiAgZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lTGluZSA9IGZ1bmN0aW9uIChhMSwgYTIsIGIxLCBiMikge1xuICAgIHZhciByZXN1bHQsXG4gICAgICAgIHVhVCA9IChiMi54IC0gYjEueCkgKiAoYTEueSAtIGIxLnkpIC0gKGIyLnkgLSBiMS55KSAqIChhMS54IC0gYjEueCksXG4gICAgICAgIHViVCA9IChhMi54IC0gYTEueCkgKiAoYTEueSAtIGIxLnkpIC0gKGEyLnkgLSBhMS55KSAqIChhMS54IC0gYjEueCksXG4gICAgICAgIHVCID0gKGIyLnkgLSBiMS55KSAqIChhMi54IC0gYTEueCkgLSAoYjIueCAtIGIxLngpICogKGEyLnkgLSBhMS55KTtcbiAgICBpZiAodUIgIT09IDApIHtcbiAgICAgIHZhciB1YSA9IHVhVCAvIHVCLFxuICAgICAgICAgIHViID0gdWJUIC8gdUI7XG4gICAgICBpZiAoMCA8PSB1YSAmJiB1YSA8PSAxICYmIDAgPD0gdWIgJiYgdWIgPD0gMSkge1xuICAgICAgICByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCdJbnRlcnNlY3Rpb24nKTtcbiAgICAgICAgcmVzdWx0LmFwcGVuZFBvaW50KG5ldyBmYWJyaWMuUG9pbnQoYTEueCArIHVhICogKGEyLnggLSBhMS54KSwgYTEueSArIHVhICogKGEyLnkgLSBhMS55KSkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAodWFUID09PSAwIHx8IHViVCA9PT0gMCkge1xuICAgICAgICByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCdDb2luY2lkZW50Jyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbignUGFyYWxsZWwnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGxpbmUgaW50ZXJzZWN0cyBwb2x5Z29uXG4gICAqIFRPRE86IHJlbmFtZSBpbiBpbnRlcnNlY3RTZWdtZW50UG9seWdvblxuICAgKiBmaXggZGV0ZWN0aW9uIG9mIGNvaW5jaWRlbnRcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gYTFcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGEyXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50c1xuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufVxuICAgKi9cbiAgZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lUG9seWdvbiA9IGZ1bmN0aW9uKGExLCBhMiwgcG9pbnRzKSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oKSxcbiAgICAgICAgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgYjEsIGIyLCBpbnRlcjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGIxID0gcG9pbnRzW2ldO1xuICAgICAgYjIgPSBwb2ludHNbKGkgKyAxKSAlIGxlbmd0aF07XG4gICAgICBpbnRlciA9IEludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lTGluZShhMSwgYTIsIGIxLCBiMik7XG5cbiAgICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXIucG9pbnRzKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5wb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnN0YXR1cyA9ICdJbnRlcnNlY3Rpb24nO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgcG9seWdvbiBpbnRlcnNlY3RzIGFub3RoZXIgcG9seWdvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50czFcbiAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzMlxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufVxuICAgKi9cbiAgZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RQb2x5Z29uUG9seWdvbiA9IGZ1bmN0aW9uIChwb2ludHMxLCBwb2ludHMyKSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oKSxcbiAgICAgICAgbGVuZ3RoID0gcG9pbnRzMS5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYTEgPSBwb2ludHMxW2ldLFxuICAgICAgICAgIGEyID0gcG9pbnRzMVsoaSArIDEpICUgbGVuZ3RoXSxcbiAgICAgICAgICBpbnRlciA9IEludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lUG9seWdvbihhMSwgYTIsIHBvaW50czIpO1xuXG4gICAgICByZXN1bHQuYXBwZW5kUG9pbnRzKGludGVyLnBvaW50cyk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQucG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlc3VsdC5zdGF0dXMgPSAnSW50ZXJzZWN0aW9uJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHBvbHlnb24gaW50ZXJzZWN0cyByZWN0YW5nbGVcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHNcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHIxXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSByMlxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufVxuICAgKi9cbiAgZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RQb2x5Z29uUmVjdGFuZ2xlID0gZnVuY3Rpb24gKHBvaW50cywgcjEsIHIyKSB7XG4gICAgdmFyIG1pbiA9IHIxLm1pbihyMiksXG4gICAgICAgIG1heCA9IHIxLm1heChyMiksXG4gICAgICAgIHRvcFJpZ2h0ID0gbmV3IGZhYnJpYy5Qb2ludChtYXgueCwgbWluLnkpLFxuICAgICAgICBib3R0b21MZWZ0ID0gbmV3IGZhYnJpYy5Qb2ludChtaW4ueCwgbWF4LnkpLFxuICAgICAgICBpbnRlcjEgPSBJbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZVBvbHlnb24obWluLCB0b3BSaWdodCwgcG9pbnRzKSxcbiAgICAgICAgaW50ZXIyID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uKHRvcFJpZ2h0LCBtYXgsIHBvaW50cyksXG4gICAgICAgIGludGVyMyA9IEludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lUG9seWdvbihtYXgsIGJvdHRvbUxlZnQsIHBvaW50cyksXG4gICAgICAgIGludGVyNCA9IEludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lUG9seWdvbihib3R0b21MZWZ0LCBtaW4sIHBvaW50cyksXG4gICAgICAgIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oKTtcblxuICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXIxLnBvaW50cyk7XG4gICAgcmVzdWx0LmFwcGVuZFBvaW50cyhpbnRlcjIucG9pbnRzKTtcbiAgICByZXN1bHQuYXBwZW5kUG9pbnRzKGludGVyMy5wb2ludHMpO1xuICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXI0LnBvaW50cyk7XG5cbiAgICBpZiAocmVzdWx0LnBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQuc3RhdHVzID0gJ0ludGVyc2VjdGlvbic7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KTtcblxuICBpZiAoZmFicmljLkNvbG9yKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5Db2xvciBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbG9yIGNsYXNzXG4gICAqIFRoZSBwdXJwb3NlIG9mIHtAbGluayBmYWJyaWMuQ29sb3J9IGlzIHRvIGFic3RyYWN0IGFuZCBlbmNhcHN1bGF0ZSBjb21tb24gY29sb3Igb3BlcmF0aW9ucztcbiAgICoge0BsaW5rIGZhYnJpYy5Db2xvcn0gaXMgYSBjb25zdHJ1Y3RvciBhbmQgY3JlYXRlcyBpbnN0YW5jZXMgb2Yge0BsaW5rIGZhYnJpYy5Db2xvcn0gb2JqZWN0cy5cbiAgICpcbiAgICogQGNsYXNzIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3Igb3B0aW9uYWwgaW4gaGV4IG9yIHJnYihhKSBvciBoc2wgZm9ybWF0IG9yIGZyb20ga25vd24gY29sb3IgbGlzdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9IHRoaXNBcmdcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTIvI2NvbG9yc31cbiAgICovXG4gIGZ1bmN0aW9uIENvbG9yKGNvbG9yKSB7XG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgdGhpcy5zZXRTb3VyY2UoWzAsIDAsIDAsIDFdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl90cnlQYXJzaW5nQ29sb3IoY29sb3IpO1xuICAgIH1cbiAgfVxuXG4gIGZhYnJpYy5Db2xvciA9IENvbG9yO1xuXG4gIGZhYnJpYy5Db2xvci5wcm90b3R5cGUgPSAvKiogQGxlbmRzIGZhYnJpYy5Db2xvci5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gY29sb3IgQ29sb3IgdmFsdWUgdG8gcGFyc2VcbiAgICAgKi9cbiAgICBfdHJ5UGFyc2luZ0NvbG9yOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgdmFyIHNvdXJjZTtcblxuICAgICAgaWYgKGNvbG9yIGluIENvbG9yLmNvbG9yTmFtZU1hcCkge1xuICAgICAgICBjb2xvciA9IENvbG9yLmNvbG9yTmFtZU1hcFtjb2xvcl07XG4gICAgICB9XG5cbiAgICAgIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgICBzb3VyY2UgPSBbMjU1LCAyNTUsIDI1NSwgMF07XG4gICAgICB9XG5cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHNvdXJjZSA9IENvbG9yLnNvdXJjZUZyb21IZXgoY29sb3IpO1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgc291cmNlID0gQ29sb3Iuc291cmNlRnJvbVJnYihjb2xvcik7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBzb3VyY2UgPSBDb2xvci5zb3VyY2VGcm9tSHNsKGNvbG9yKTtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIC8vaWYgY29sb3IgaXMgbm90IHJlY29nbml6ZSBsZXQncyBtYWtlIGJsYWNrIGFzIGNhbnZhcyBkb2VzXG4gICAgICAgIHNvdXJjZSA9IFswLCAwLCAwLCAxXTtcbiAgICAgIH1cbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRhcHRlZCBmcm9tIDxhIGhyZWY9XCJodHRwczovL3Jhd2dpdGh1Yi5jb20vbWppamFja3Nvbi9tamlqYWNrc29uLmdpdGh1Yi5jb20vbWFzdGVyLzIwMDgvMDIvcmdiLXRvLWhzbC1hbmQtcmdiLXRvLWhzdi1jb2xvci1tb2RlbC1jb252ZXJzaW9uLWFsZ29yaXRobXMtaW4tamF2YXNjcmlwdC5odG1sXCI+aHR0cHM6Ly9naXRodWIuY29tL21qaWphY2tzb248L2E+XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gciBSZWQgY29sb3IgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZyBHcmVlbiBjb2xvciB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIEJsdWUgY29sb3IgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gSHNsIGNvbG9yXG4gICAgICovXG4gICAgX3JnYlRvSHNsOiBmdW5jdGlvbihyLCBnLCBiKSB7XG4gICAgICByIC89IDI1NTsgZyAvPSAyNTU7IGIgLz0gMjU1O1xuXG4gICAgICB2YXIgaCwgcywgbCxcbiAgICAgICAgICBtYXggPSBmYWJyaWMudXRpbC5hcnJheS5tYXgoW3IsIGcsIGJdKSxcbiAgICAgICAgICBtaW4gPSBmYWJyaWMudXRpbC5hcnJheS5taW4oW3IsIGcsIGJdKTtcblxuICAgICAgbCA9IChtYXggKyBtaW4pIC8gMjtcblxuICAgICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICAgIGggPSBzID0gMDsgLy8gYWNocm9tYXRpY1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBkID0gbWF4IC0gbWluO1xuICAgICAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG4gICAgICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICAgICAgY2FzZSByOlxuICAgICAgICAgICAgaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBnOlxuICAgICAgICAgICAgaCA9IChiIC0gcikgLyBkICsgMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgYjpcbiAgICAgICAgICAgIGggPSAociAtIGcpIC8gZCArIDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBoIC89IDY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIE1hdGgucm91bmQoaCAqIDM2MCksXG4gICAgICAgIE1hdGgucm91bmQocyAqIDEwMCksXG4gICAgICAgIE1hdGgucm91bmQobCAqIDEwMClcbiAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc291cmNlIG9mIHRoaXMgY29sb3IgKHdoZXJlIHNvdXJjZSBpcyBhbiBhcnJheSByZXByZXNlbnRhdGlvbjsgZXg6IFsyMDAsIDIwMCwgMTAwLCAxXSlcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRTb3VyY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzb3VyY2Ugb2YgdGhpcyBjb2xvciAod2hlcmUgc291cmNlIGlzIGFuIGFycmF5IHJlcHJlc2VudGF0aW9uOyBleDogWzIwMCwgMjAwLCAxMDAsIDFdKVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZVxuICAgICAqL1xuICAgIHNldFNvdXJjZTogZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29sb3IgcmVwcmVzZW5hdGlvbiBpbiBSR0IgZm9ybWF0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBleDogcmdiKDAtMjU1LDAtMjU1LDAtMjU1KVxuICAgICAqL1xuICAgIHRvUmdiOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpO1xuICAgICAgcmV0dXJuICdyZ2IoJyArIHNvdXJjZVswXSArICcsJyArIHNvdXJjZVsxXSArICcsJyArIHNvdXJjZVsyXSArICcpJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xvciByZXByZXNlbmF0aW9uIGluIFJHQkEgZm9ybWF0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBleDogcmdiYSgwLTI1NSwwLTI1NSwwLTI1NSwwLTEpXG4gICAgICovXG4gICAgdG9SZ2JhOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpO1xuICAgICAgcmV0dXJuICdyZ2JhKCcgKyBzb3VyY2VbMF0gKyAnLCcgKyBzb3VyY2VbMV0gKyAnLCcgKyBzb3VyY2VbMl0gKyAnLCcgKyBzb3VyY2VbM10gKyAnKSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29sb3IgcmVwcmVzZW5hdGlvbiBpbiBIU0wgZm9ybWF0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBleDogaHNsKDAtMzYwLDAlLTEwMCUsMCUtMTAwJSlcbiAgICAgKi9cbiAgICB0b0hzbDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKSxcbiAgICAgICAgICBoc2wgPSB0aGlzLl9yZ2JUb0hzbChzb3VyY2VbMF0sIHNvdXJjZVsxXSwgc291cmNlWzJdKTtcblxuICAgICAgcmV0dXJuICdoc2woJyArIGhzbFswXSArICcsJyArIGhzbFsxXSArICclLCcgKyBoc2xbMl0gKyAnJSknO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbG9yIHJlcHJlc2VuYXRpb24gaW4gSFNMQSBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiBoc2xhKDAtMzYwLDAlLTEwMCUsMCUtMTAwJSwwLTEpXG4gICAgICovXG4gICAgdG9Ic2xhOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGhzbCA9IHRoaXMuX3JnYlRvSHNsKHNvdXJjZVswXSwgc291cmNlWzFdLCBzb3VyY2VbMl0pO1xuXG4gICAgICByZXR1cm4gJ2hzbGEoJyArIGhzbFswXSArICcsJyArIGhzbFsxXSArICclLCcgKyBoc2xbMl0gKyAnJSwnICsgc291cmNlWzNdICsgJyknO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbG9yIHJlcHJlc2VuYXRpb24gaW4gSEVYIGZvcm1hdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZXg6IEZGNTU1NVxuICAgICAqL1xuICAgIHRvSGV4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLCByLCBnLCBiO1xuXG4gICAgICByID0gc291cmNlWzBdLnRvU3RyaW5nKDE2KTtcbiAgICAgIHIgPSAoci5sZW5ndGggPT09IDEpID8gKCcwJyArIHIpIDogcjtcblxuICAgICAgZyA9IHNvdXJjZVsxXS50b1N0cmluZygxNik7XG4gICAgICBnID0gKGcubGVuZ3RoID09PSAxKSA/ICgnMCcgKyBnKSA6IGc7XG5cbiAgICAgIGIgPSBzb3VyY2VbMl0udG9TdHJpbmcoMTYpO1xuICAgICAgYiA9IChiLmxlbmd0aCA9PT0gMSkgPyAoJzAnICsgYikgOiBiO1xuXG4gICAgICByZXR1cm4gci50b1VwcGVyQ2FzZSgpICsgZy50b1VwcGVyQ2FzZSgpICsgYi50b1VwcGVyQ2FzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHZhbHVlIG9mIGFscGhhIGNoYW5uZWwgZm9yIHRoaXMgY29sb3JcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IDAtMVxuICAgICAqL1xuICAgIGdldEFscGhhOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFNvdXJjZSgpWzNdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHZhbHVlIG9mIGFscGhhIGNoYW5uZWwgZm9yIHRoaXMgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYWxwaGEgQWxwaGEgdmFsdWUgMC0xXG4gICAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfSB0aGlzQXJnXG4gICAgICovXG4gICAgc2V0QWxwaGE6IGZ1bmN0aW9uKGFscGhhKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKTtcbiAgICAgIHNvdXJjZVszXSA9IGFscGhhO1xuICAgICAgdGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGNvbG9yIHRvIGl0cyBncmF5c2NhbGUgcmVwcmVzZW50YXRpb25cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9IHRoaXNBcmdcbiAgICAgKi9cbiAgICB0b0dyYXlzY2FsZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKSxcbiAgICAgICAgICBhdmVyYWdlID0gcGFyc2VJbnQoKHNvdXJjZVswXSAqIDAuMyArIHNvdXJjZVsxXSAqIDAuNTkgKyBzb3VyY2VbMl0gKiAwLjExKS50b0ZpeGVkKDApLCAxMCksXG4gICAgICAgICAgY3VycmVudEFscGhhID0gc291cmNlWzNdO1xuICAgICAgdGhpcy5zZXRTb3VyY2UoW2F2ZXJhZ2UsIGF2ZXJhZ2UsIGF2ZXJhZ2UsIGN1cnJlbnRBbHBoYV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgY29sb3IgdG8gaXRzIGJsYWNrIGFuZCB3aGl0ZSByZXByZXNlbnRhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aHJlc2hvbGRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9IHRoaXNBcmdcbiAgICAgKi9cbiAgICB0b0JsYWNrV2hpdGU6IGZ1bmN0aW9uKHRocmVzaG9sZCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCksXG4gICAgICAgICAgYXZlcmFnZSA9IChzb3VyY2VbMF0gKiAwLjMgKyBzb3VyY2VbMV0gKiAwLjU5ICsgc291cmNlWzJdICogMC4xMSkudG9GaXhlZCgwKSxcbiAgICAgICAgICBjdXJyZW50QWxwaGEgPSBzb3VyY2VbM107XG5cbiAgICAgIHRocmVzaG9sZCA9IHRocmVzaG9sZCB8fCAxMjc7XG5cbiAgICAgIGF2ZXJhZ2UgPSAoTnVtYmVyKGF2ZXJhZ2UpIDwgTnVtYmVyKHRocmVzaG9sZCkpID8gMCA6IDI1NTtcbiAgICAgIHRoaXMuc2V0U291cmNlKFthdmVyYWdlLCBhdmVyYWdlLCBhdmVyYWdlLCBjdXJyZW50QWxwaGFdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPdmVybGF5cyBjb2xvciB3aXRoIGFub3RoZXIgY29sb3JcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xmYWJyaWMuQ29sb3J9IG90aGVyQ29sb3JcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBvdmVybGF5V2l0aDogZnVuY3Rpb24ob3RoZXJDb2xvcikge1xuICAgICAgaWYgKCEob3RoZXJDb2xvciBpbnN0YW5jZW9mIENvbG9yKSkge1xuICAgICAgICBvdGhlckNvbG9yID0gbmV3IENvbG9yKG90aGVyQ29sb3IpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgYWxwaGEgPSB0aGlzLmdldEFscGhhKCksXG4gICAgICAgICAgb3RoZXJBbHBoYSA9IDAuNSxcbiAgICAgICAgICBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLFxuICAgICAgICAgIG90aGVyU291cmNlID0gb3RoZXJDb2xvci5nZXRTb3VyY2UoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2goTWF0aC5yb3VuZCgoc291cmNlW2ldICogKDEgLSBvdGhlckFscGhhKSkgKyAob3RoZXJTb3VyY2VbaV0gKiBvdGhlckFscGhhKSkpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRbM10gPSBhbHBoYTtcbiAgICAgIHRoaXMuc2V0U291cmNlKHJlc3VsdCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ2V4IG1hdGNoaW5nIGNvbG9yIGluIFJHQiBvciBSR0JBIGZvcm1hdHMgKGV4OiByZ2IoMCwgMCwgMCksIHJnYmEoMjU1LCAxMDAsIDEwLCAwLjUpLCByZ2JhKCAyNTUgLCAxMDAgLCAxMCAsIDAuNSApLCByZ2IoMSwxLDEpLCByZ2JhKDEwMCUsIDYwJSwgMTAlLCAwLjUpKVxuICAgKiBAc3RhdGljXG4gICAqIEBmaWVsZFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqL1xuICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgZmFicmljLkNvbG9yLnJlUkdCYSA9IC9ecmdiYT9cXChcXHMqKFxcZHsxLDN9KD86XFwuXFxkKyk/XFwlPylcXHMqLFxccyooXFxkezEsM30oPzpcXC5cXGQrKT9cXCU/KVxccyosXFxzKihcXGR7MSwzfSg/OlxcLlxcZCspP1xcJT8pXFxzKig/OlxccyosXFxzKihcXGQrKD86XFwuXFxkKyk/KVxccyopP1xcKSQvO1xuXG4gIC8qKlxuICAgKiBSZWdleCBtYXRjaGluZyBjb2xvciBpbiBIU0wgb3IgSFNMQSBmb3JtYXRzIChleDogaHNsKDIwMCwgODAlLCAxMCUpLCBoc2xhKDMwMCwgNTAlLCA4MCUsIDAuNSksIGhzbGEoIDMwMCAsIDUwJSAsIDgwJSAsIDAuNSApKVxuICAgKiBAc3RhdGljXG4gICAqIEBmaWVsZFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqL1xuICBmYWJyaWMuQ29sb3IucmVIU0xhID0gL15oc2xhP1xcKFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9XFwlKVxccyosXFxzKihcXGR7MSwzfVxcJSlcXHMqKD86XFxzKixcXHMqKFxcZCsoPzpcXC5cXGQrKT8pXFxzKik/XFwpJC87XG5cbiAgLyoqXG4gICAqIFJlZ2V4IG1hdGNoaW5nIGNvbG9yIGluIEhFWCBmb3JtYXQgKGV4OiAjRkY1NTQ0Q0MsICNGRjU1NTUsIDAxMDE1NSwgYWZmKVxuICAgKiBAc3RhdGljXG4gICAqIEBmaWVsZFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqL1xuICBmYWJyaWMuQ29sb3IucmVIZXggPSAvXiM/KFswLTlhLWZdezh9fFswLTlhLWZdezZ9fFswLTlhLWZdezR9fFswLTlhLWZdezN9KSQvaTtcblxuICAvKipcbiAgICogTWFwIG9mIHRoZSAxNyBiYXNpYyBjb2xvciBuYW1lcyB3aXRoIEhFWCBjb2RlXG4gICAqIEBzdGF0aWNcbiAgICogQGZpZWxkXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMi9zeW5kYXRhLmh0bWwjY29sb3ItdW5pdHNcbiAgICovXG4gIGZhYnJpYy5Db2xvci5jb2xvck5hbWVNYXAgPSB7XG4gICAgYXF1YTogICAgJyMwMEZGRkYnLFxuICAgIGJsYWNrOiAgICcjMDAwMDAwJyxcbiAgICBibHVlOiAgICAnIzAwMDBGRicsXG4gICAgZnVjaHNpYTogJyNGRjAwRkYnLFxuICAgIGdyYXk6ICAgICcjODA4MDgwJyxcbiAgICBncmV5OiAgICAnIzgwODA4MCcsXG4gICAgZ3JlZW46ICAgJyMwMDgwMDAnLFxuICAgIGxpbWU6ICAgICcjMDBGRjAwJyxcbiAgICBtYXJvb246ICAnIzgwMDAwMCcsXG4gICAgbmF2eTogICAgJyMwMDAwODAnLFxuICAgIG9saXZlOiAgICcjODA4MDAwJyxcbiAgICBvcmFuZ2U6ICAnI0ZGQTUwMCcsXG4gICAgcHVycGxlOiAgJyM4MDAwODAnLFxuICAgIHJlZDogICAgICcjRkYwMDAwJyxcbiAgICBzaWx2ZXI6ICAnI0MwQzBDMCcsXG4gICAgdGVhbDogICAgJyMwMDgwODAnLFxuICAgIHdoaXRlOiAgICcjRkZGRkZGJyxcbiAgICB5ZWxsb3c6ICAnI0ZGRkYwMCdcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG4gICAgaWYgKHQgPCAwKSB7XG4gICAgICB0ICs9IDE7XG4gICAgfVxuICAgIGlmICh0ID4gMSkge1xuICAgICAgdCAtPSAxO1xuICAgIH1cbiAgICBpZiAodCA8IDEgLyA2KSB7XG4gICAgICByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgICB9XG4gICAgaWYgKHQgPCAxIC8gMikge1xuICAgICAgcmV0dXJuIHE7XG4gICAgfVxuICAgIGlmICh0IDwgMiAvIDMpIHtcbiAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGEgY29sb3IgaW4gUkdCIGZvcm1hdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciB2YWx1ZSBleDogcmdiKDAtMjU1LDAtMjU1LDAtMjU1KVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbVJnYiA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIENvbG9yLmZyb21Tb3VyY2UoQ29sb3Iuc291cmNlRnJvbVJnYihjb2xvcikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFycmF5IHJlcHJlc2VudGF0aW9uIChleDogWzEwMCwgMTAwLCAyMDAsIDFdKSBvZiBhIGNvbG9yIHRoYXQncyBpbiBSR0Igb3IgUkdCQSBmb3JtYXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IHJnYigwLTI1NSwwLTI1NSwwLTI1NSksIHJnYigwJS0xMDAlLDAlLTEwMCUsMCUtMTAwJSlcbiAgICogQHJldHVybiB7QXJyYXl9IHNvdXJjZVxuICAgKi9cbiAgZmFicmljLkNvbG9yLnNvdXJjZUZyb21SZ2IgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHZhciBtYXRjaCA9IGNvbG9yLm1hdGNoKENvbG9yLnJlUkdCYSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCkgLyAoLyUkLy50ZXN0KG1hdGNoWzFdKSA/IDEwMCA6IDEpICogKC8lJC8udGVzdChtYXRjaFsxXSkgPyAyNTUgOiAxKSxcbiAgICAgICAgICBnID0gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKSAvICgvJSQvLnRlc3QobWF0Y2hbMl0pID8gMTAwIDogMSkgKiAoLyUkLy50ZXN0KG1hdGNoWzJdKSA/IDI1NSA6IDEpLFxuICAgICAgICAgIGIgPSBwYXJzZUludChtYXRjaFszXSwgMTApIC8gKC8lJC8udGVzdChtYXRjaFszXSkgPyAxMDAgOiAxKSAqICgvJSQvLnRlc3QobWF0Y2hbM10pID8gMjU1IDogMSk7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHBhcnNlSW50KHIsIDEwKSxcbiAgICAgICAgcGFyc2VJbnQoZywgMTApLFxuICAgICAgICBwYXJzZUludChiLCAxMCksXG4gICAgICAgIG1hdGNoWzRdID8gcGFyc2VGbG9hdChtYXRjaFs0XSkgOiAxXG4gICAgICBdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGEgY29sb3IgaW4gUkdCQSBmb3JtYXRcbiAgICogQHN0YXRpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3JcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfVxuICAgKi9cbiAgZmFicmljLkNvbG9yLmZyb21SZ2JhID0gQ29sb3IuZnJvbVJnYjtcblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGEgY29sb3IgaW4gSFNMIGZvcm1hdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IGhzbCgwLTI2MCwwJS0xMDAlLDAlLTEwMCUpXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfVxuICAgKi9cbiAgZmFicmljLkNvbG9yLmZyb21Ic2wgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHJldHVybiBDb2xvci5mcm9tU291cmNlKENvbG9yLnNvdXJjZUZyb21Ic2woY29sb3IpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhcnJheSByZXByZXNlbnRhdGlvbiAoZXg6IFsxMDAsIDEwMCwgMjAwLCAxXSkgb2YgYSBjb2xvciB0aGF0J3MgaW4gSFNMIG9yIEhTTEEgZm9ybWF0LlxuICAgKiBBZGFwdGVkIGZyb20gPGEgaHJlZj1cImh0dHBzOi8vcmF3Z2l0aHViLmNvbS9tamlqYWNrc29uL21qaWphY2tzb24uZ2l0aHViLmNvbS9tYXN0ZXIvMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0Lmh0bWxcIj5odHRwczovL2dpdGh1Yi5jb20vbWppamFja3NvbjwvYT5cbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IGhzbCgwLTM2MCwwJS0xMDAlLDAlLTEwMCUpIG9yIGhzbGEoMC0zNjAsMCUtMTAwJSwwJS0xMDAlLCAwLTEpXG4gICAqIEByZXR1cm4ge0FycmF5fSBzb3VyY2VcbiAgICogQHNlZSBodHRwOi8vaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8jaHNsLWNvbG9yXG4gICAqL1xuICBmYWJyaWMuQ29sb3Iuc291cmNlRnJvbUhzbCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgdmFyIG1hdGNoID0gY29sb3IubWF0Y2goQ29sb3IucmVIU0xhKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGggPSAoKChwYXJzZUZsb2F0KG1hdGNoWzFdKSAlIDM2MCkgKyAzNjApICUgMzYwKSAvIDM2MCxcbiAgICAgICAgcyA9IHBhcnNlRmxvYXQobWF0Y2hbMl0pIC8gKC8lJC8udGVzdChtYXRjaFsyXSkgPyAxMDAgOiAxKSxcbiAgICAgICAgbCA9IHBhcnNlRmxvYXQobWF0Y2hbM10pIC8gKC8lJC8udGVzdChtYXRjaFszXSkgPyAxMDAgOiAxKSxcbiAgICAgICAgciwgZywgYjtcblxuICAgIGlmIChzID09PSAwKSB7XG4gICAgICByID0gZyA9IGIgPSBsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBxID0gbCA8PSAwLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHMsXG4gICAgICAgICAgcCA9IGwgKiAyIC0gcTtcblxuICAgICAgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEgLyAzKTtcbiAgICAgIGcgPSBodWUycmdiKHAsIHEsIGgpO1xuICAgICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgTWF0aC5yb3VuZChyICogMjU1KSxcbiAgICAgIE1hdGgucm91bmQoZyAqIDI1NSksXG4gICAgICBNYXRoLnJvdW5kKGIgKiAyNTUpLFxuICAgICAgbWF0Y2hbNF0gPyBwYXJzZUZsb2F0KG1hdGNoWzRdKSA6IDFcbiAgICBdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gYSBjb2xvciBpbiBIU0xBIGZvcm1hdFxuICAgKiBAc3RhdGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvclxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbUhzbGEgPSBDb2xvci5mcm9tSHNsO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gYSBjb2xvciBpbiBIRVggZm9ybWF0XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IEZGNTU1NVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbUhleCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIENvbG9yLmZyb21Tb3VyY2UoQ29sb3Iuc291cmNlRnJvbUhleChjb2xvcikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFycmF5IHJlcHJlc2VudGF0aW9uIChleDogWzEwMCwgMTAwLCAyMDAsIDFdKSBvZiBhIGNvbG9yIHRoYXQncyBpbiBIRVggZm9ybWF0XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgZXg6IEZGNTU1NSBvciBGRjU1NDRDQyAoUkdCYSlcbiAgICogQHJldHVybiB7QXJyYXl9IHNvdXJjZVxuICAgKi9cbiAgZmFicmljLkNvbG9yLnNvdXJjZUZyb21IZXggPSBmdW5jdGlvbihjb2xvcikge1xuICAgIGlmIChjb2xvci5tYXRjaChDb2xvci5yZUhleCkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGNvbG9yLnNsaWNlKGNvbG9yLmluZGV4T2YoJyMnKSArIDEpLFxuICAgICAgICAgIGlzU2hvcnROb3RhdGlvbiA9ICh2YWx1ZS5sZW5ndGggPT09IDMgfHwgdmFsdWUubGVuZ3RoID09PSA0KSxcbiAgICAgICAgICBpc1JHQmEgPSAodmFsdWUubGVuZ3RoID09PSA4IHx8IHZhbHVlLmxlbmd0aCA9PT0gNCksXG4gICAgICAgICAgciA9IGlzU2hvcnROb3RhdGlvbiA/ICh2YWx1ZS5jaGFyQXQoMCkgKyB2YWx1ZS5jaGFyQXQoMCkpIDogdmFsdWUuc3Vic3RyaW5nKDAsIDIpLFxuICAgICAgICAgIGcgPSBpc1Nob3J0Tm90YXRpb24gPyAodmFsdWUuY2hhckF0KDEpICsgdmFsdWUuY2hhckF0KDEpKSA6IHZhbHVlLnN1YnN0cmluZygyLCA0KSxcbiAgICAgICAgICBiID0gaXNTaG9ydE5vdGF0aW9uID8gKHZhbHVlLmNoYXJBdCgyKSArIHZhbHVlLmNoYXJBdCgyKSkgOiB2YWx1ZS5zdWJzdHJpbmcoNCwgNiksXG4gICAgICAgICAgYSA9IGlzUkdCYSA/IChpc1Nob3J0Tm90YXRpb24gPyAodmFsdWUuY2hhckF0KDMpICsgdmFsdWUuY2hhckF0KDMpKSA6IHZhbHVlLnN1YnN0cmluZyg2LCA4KSkgOiAnRkYnO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBwYXJzZUludChyLCAxNiksXG4gICAgICAgIHBhcnNlSW50KGcsIDE2KSxcbiAgICAgICAgcGFyc2VJbnQoYiwgMTYpLFxuICAgICAgICBwYXJzZUZsb2F0KChwYXJzZUludChhLCAxNikgLyAyNTUpLnRvRml4ZWQoMikpXG4gICAgICBdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGNvbG9yIGluIGFycmF5IHJlcHJlc2VudGF0aW9uIChleDogWzIwMCwgMTAwLCAxMDAsIDAuNV0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2VcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfVxuICAgKi9cbiAgZmFicmljLkNvbG9yLmZyb21Tb3VyY2UgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICB2YXIgb0NvbG9yID0gbmV3IENvbG9yKCk7XG4gICAgb0NvbG9yLnNldFNvdXJjZShzb3VyY2UpO1xuICAgIHJldHVybiBvQ29sb3I7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICBmdW5jdGlvbiBnZXRDb2xvclN0b3AoZWwpIHtcbiAgICB2YXIgc3R5bGUgPSBlbC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyksXG4gICAgICAgIG9mZnNldCA9IGVsLmdldEF0dHJpYnV0ZSgnb2Zmc2V0JykgfHwgMCxcbiAgICAgICAgY29sb3IsIGNvbG9yQWxwaGEsIG9wYWNpdHk7XG5cbiAgICAvLyBjb252ZXJ0IHBlcmNlbnRzIHRvIGFic29sdXRlIHZhbHVlc1xuICAgIG9mZnNldCA9IHBhcnNlRmxvYXQob2Zmc2V0KSAvICgvJSQvLnRlc3Qob2Zmc2V0KSA/IDEwMCA6IDEpO1xuICAgIG9mZnNldCA9IG9mZnNldCA8IDAgPyAwIDogb2Zmc2V0ID4gMSA/IDEgOiBvZmZzZXQ7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICB2YXIga2V5VmFsdWVQYWlycyA9IHN0eWxlLnNwbGl0KC9cXHMqO1xccyovKTtcblxuICAgICAgaWYgKGtleVZhbHVlUGFpcnNba2V5VmFsdWVQYWlycy5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICAgICAga2V5VmFsdWVQYWlycy5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IGtleVZhbHVlUGFpcnMubGVuZ3RoOyBpLS07ICkge1xuXG4gICAgICAgIHZhciBzcGxpdCA9IGtleVZhbHVlUGFpcnNbaV0uc3BsaXQoL1xccyo6XFxzKi8pLFxuICAgICAgICAgICAga2V5ID0gc3BsaXRbMF0udHJpbSgpLFxuICAgICAgICAgICAgdmFsdWUgPSBzcGxpdFsxXS50cmltKCk7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ3N0b3AtY29sb3InKSB7XG4gICAgICAgICAgY29sb3IgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdzdG9wLW9wYWNpdHknKSB7XG4gICAgICAgICAgb3BhY2l0eSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgY29sb3IgPSBlbC5nZXRBdHRyaWJ1dGUoJ3N0b3AtY29sb3InKSB8fCAncmdiKDAsMCwwKSc7XG4gICAgfVxuICAgIGlmICghb3BhY2l0eSkge1xuICAgICAgb3BhY2l0eSA9IGVsLmdldEF0dHJpYnV0ZSgnc3RvcC1vcGFjaXR5Jyk7XG4gICAgfVxuXG4gICAgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKGNvbG9yKTtcbiAgICBjb2xvckFscGhhID0gY29sb3IuZ2V0QWxwaGEoKTtcbiAgICBvcGFjaXR5ID0gaXNOYU4ocGFyc2VGbG9hdChvcGFjaXR5KSkgPyAxIDogcGFyc2VGbG9hdChvcGFjaXR5KTtcbiAgICBvcGFjaXR5ICo9IGNvbG9yQWxwaGE7XG5cbiAgICByZXR1cm4ge1xuICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICBjb2xvcjogY29sb3IudG9SZ2IoKSxcbiAgICAgIG9wYWNpdHk6IG9wYWNpdHlcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGluZWFyQ29vcmRzKGVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiBlbC5nZXRBdHRyaWJ1dGUoJ3gxJykgfHwgMCxcbiAgICAgIHkxOiBlbC5nZXRBdHRyaWJ1dGUoJ3kxJykgfHwgMCxcbiAgICAgIHgyOiBlbC5nZXRBdHRyaWJ1dGUoJ3gyJykgfHwgJzEwMCUnLFxuICAgICAgeTI6IGVsLmdldEF0dHJpYnV0ZSgneTInKSB8fCAwXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJhZGlhbENvb3JkcyhlbCkge1xuICAgIHJldHVybiB7XG4gICAgICB4MTogZWwuZ2V0QXR0cmlidXRlKCdmeCcpIHx8IGVsLmdldEF0dHJpYnV0ZSgnY3gnKSB8fCAnNTAlJyxcbiAgICAgIHkxOiBlbC5nZXRBdHRyaWJ1dGUoJ2Z5JykgfHwgZWwuZ2V0QXR0cmlidXRlKCdjeScpIHx8ICc1MCUnLFxuICAgICAgcjE6IDAsXG4gICAgICB4MjogZWwuZ2V0QXR0cmlidXRlKCdjeCcpIHx8ICc1MCUnLFxuICAgICAgeTI6IGVsLmdldEF0dHJpYnV0ZSgnY3knKSB8fCAnNTAlJyxcbiAgICAgIHIyOiBlbC5nZXRBdHRyaWJ1dGUoJ3InKSB8fCAnNTAlJ1xuICAgIH07XG4gIH1cbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogR3JhZGllbnQgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5HcmFkaWVudFxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMiNncmFkaWVudHN9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5HcmFkaWVudCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLkdyYWRpZW50ID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoLyoqIEBsZW5kcyBmYWJyaWMuR3JhZGllbnQucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWwgb2Zmc2V0IGZvciBhbGlnbmluZyBncmFkaWVudHMgY29taW5nIGZyb20gU1ZHIHdoZW4gb3V0c2lkZSBwYXRoZ3JvdXBzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIG9mZnNldFg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbCBvZmZzZXQgZm9yIGFsaWduaW5nIGdyYWRpZW50cyBjb21pbmcgZnJvbSBTVkcgd2hlbiBvdXRzaWRlIHBhdGhncm91cHNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgb2Zmc2V0WTogMCxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdCB3aXRoIHR5cGUsIGNvb3JkcywgZ3JhZGllbnRVbml0cyBhbmQgY29sb3JTdG9wc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5HcmFkaWVudH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICB2YXIgY29vcmRzID0geyB9O1xuXG4gICAgICB0aGlzLmlkID0gZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlIHx8ICdsaW5lYXInO1xuXG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHgxOiBvcHRpb25zLmNvb3Jkcy54MSB8fCAwLFxuICAgICAgICB5MTogb3B0aW9ucy5jb29yZHMueTEgfHwgMCxcbiAgICAgICAgeDI6IG9wdGlvbnMuY29vcmRzLngyIHx8IDAsXG4gICAgICAgIHkyOiBvcHRpb25zLmNvb3Jkcy55MiB8fCAwXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy50eXBlID09PSAncmFkaWFsJykge1xuICAgICAgICBjb29yZHMucjEgPSBvcHRpb25zLmNvb3Jkcy5yMSB8fCAwO1xuICAgICAgICBjb29yZHMucjIgPSBvcHRpb25zLmNvb3Jkcy5yMiB8fCAwO1xuICAgICAgfVxuICAgICAgdGhpcy5jb29yZHMgPSBjb29yZHM7XG4gICAgICB0aGlzLmNvbG9yU3RvcHMgPSBvcHRpb25zLmNvbG9yU3RvcHMuc2xpY2UoKTtcbiAgICAgIGlmIChvcHRpb25zLmdyYWRpZW50VHJhbnNmb3JtKSB7XG4gICAgICAgIHRoaXMuZ3JhZGllbnRUcmFuc2Zvcm0gPSBvcHRpb25zLmdyYWRpZW50VHJhbnNmb3JtO1xuICAgICAgfVxuICAgICAgdGhpcy5vZmZzZXRYID0gb3B0aW9ucy5vZmZzZXRYIHx8IHRoaXMub2Zmc2V0WDtcbiAgICAgIHRoaXMub2Zmc2V0WSA9IG9wdGlvbnMub2Zmc2V0WSB8fCB0aGlzLm9mZnNldFk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW5vdGhlciBjb2xvclN0b3BcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29sb3JTdG9wIE9iamVjdCB3aXRoIG9mZnNldCBhbmQgY29sb3JcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JhZGllbnR9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBhZGRDb2xvclN0b3A6IGZ1bmN0aW9uKGNvbG9yU3RvcHMpIHtcbiAgICAgIGZvciAodmFyIHBvc2l0aW9uIGluIGNvbG9yU3RvcHMpIHtcbiAgICAgICAgdmFyIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcihjb2xvclN0b3BzW3Bvc2l0aW9uXSk7XG4gICAgICAgIHRoaXMuY29sb3JTdG9wcy5wdXNoKHtcbiAgICAgICAgICBvZmZzZXQ6IHBvc2l0aW9uLFxuICAgICAgICAgIGNvbG9yOiBjb2xvci50b1JnYigpLFxuICAgICAgICAgIG9wYWNpdHk6IGNvbG9yLmdldEFscGhhKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYSBncmFkaWVudFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBvYmplY3QgPSB7XG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgY29vcmRzOiB0aGlzLmNvb3JkcyxcbiAgICAgICAgY29sb3JTdG9wczogdGhpcy5jb2xvclN0b3BzLFxuICAgICAgICBvZmZzZXRYOiB0aGlzLm9mZnNldFgsXG4gICAgICAgIG9mZnNldFk6IHRoaXMub2Zmc2V0WSxcbiAgICAgICAgZ3JhZGllbnRUcmFuc2Zvcm06IHRoaXMuZ3JhZGllbnRUcmFuc2Zvcm0gPyB0aGlzLmdyYWRpZW50VHJhbnNmb3JtLmNvbmNhdCgpIDogdGhpcy5ncmFkaWVudFRyYW5zZm9ybVxuICAgICAgfTtcbiAgICAgIGZhYnJpYy51dGlsLnBvcHVsYXRlV2l0aFByb3BlcnRpZXModGhpcywgb2JqZWN0LCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhbiBncmFkaWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhIGdyYWRpZW50IGZvclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGFuIGdyYWRpZW50IChsaW5lYXIvcmFkaWFsKVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBjb29yZHMgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUodGhpcy5jb29yZHMpLFxuICAgICAgICAgIG1hcmt1cCwgY29tbW9uQXR0cmlidXRlcztcblxuICAgICAgLy8gY29sb3JTdG9wcyBtdXN0IGJlIHNvcnRlZCBhc2NlbmRpbmdcbiAgICAgIHRoaXMuY29sb3JTdG9wcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEub2Zmc2V0IC0gYi5vZmZzZXQ7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCEob2JqZWN0Lmdyb3VwICYmIG9iamVjdC5ncm91cC50eXBlID09PSAncGF0aC1ncm91cCcpKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gY29vcmRzKSB7XG4gICAgICAgICAgaWYgKHByb3AgPT09ICd4MScgfHwgcHJvcCA9PT0gJ3gyJyB8fCBwcm9wID09PSAncjInKSB7XG4gICAgICAgICAgICBjb29yZHNbcHJvcF0gKz0gdGhpcy5vZmZzZXRYIC0gb2JqZWN0LndpZHRoIC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAocHJvcCA9PT0gJ3kxJyB8fCBwcm9wID09PSAneTInKSB7XG4gICAgICAgICAgICBjb29yZHNbcHJvcF0gKz0gdGhpcy5vZmZzZXRZIC0gb2JqZWN0LmhlaWdodCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbW1vbkF0dHJpYnV0ZXMgPSAnaWQ9XCJTVkdJRF8nICsgdGhpcy5pZCArXG4gICAgICAgICAgICAgICAgICAgICAnXCIgZ3JhZGllbnRVbml0cz1cInVzZXJTcGFjZU9uVXNlXCInO1xuICAgICAgaWYgKHRoaXMuZ3JhZGllbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgY29tbW9uQXR0cmlidXRlcyArPSAnIGdyYWRpZW50VHJhbnNmb3JtPVwibWF0cml4KCcgKyB0aGlzLmdyYWRpZW50VHJhbnNmb3JtLmpvaW4oJyAnKSArICcpXCIgJztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgIG1hcmt1cCA9IFtcbiAgICAgICAgICAnPGxpbmVhckdyYWRpZW50ICcsXG4gICAgICAgICAgY29tbW9uQXR0cmlidXRlcyxcbiAgICAgICAgICAnIHgxPVwiJywgY29vcmRzLngxLFxuICAgICAgICAgICdcIiB5MT1cIicsIGNvb3Jkcy55MSxcbiAgICAgICAgICAnXCIgeDI9XCInLCBjb29yZHMueDIsXG4gICAgICAgICAgJ1wiIHkyPVwiJywgY29vcmRzLnkyLFxuICAgICAgICAgICdcIj5cXG4nXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdyYWRpYWwnKSB7XG4gICAgICAgIG1hcmt1cCA9IFtcbiAgICAgICAgICAnPHJhZGlhbEdyYWRpZW50ICcsXG4gICAgICAgICAgY29tbW9uQXR0cmlidXRlcyxcbiAgICAgICAgICAnIGN4PVwiJywgY29vcmRzLngyLFxuICAgICAgICAgICdcIiBjeT1cIicsIGNvb3Jkcy55MixcbiAgICAgICAgICAnXCIgcj1cIicsIGNvb3Jkcy5yMixcbiAgICAgICAgICAnXCIgZng9XCInLCBjb29yZHMueDEsXG4gICAgICAgICAgJ1wiIGZ5PVwiJywgY29vcmRzLnkxLFxuICAgICAgICAgICdcIj5cXG4nXG4gICAgICAgIF07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb2xvclN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAgICc8c3RvcCAnLFxuICAgICAgICAgICAgJ29mZnNldD1cIicsICh0aGlzLmNvbG9yU3RvcHNbaV0ub2Zmc2V0ICogMTAwKSArICclJyxcbiAgICAgICAgICAgICdcIiBzdHlsZT1cInN0b3AtY29sb3I6JywgdGhpcy5jb2xvclN0b3BzW2ldLmNvbG9yLFxuICAgICAgICAgICAgKHRoaXMuY29sb3JTdG9wc1tpXS5vcGFjaXR5ICE9PSBudWxsID8gJztzdG9wLW9wYWNpdHk6ICcgKyB0aGlzLmNvbG9yU3RvcHNbaV0ub3BhY2l0eSA6ICc7JyksXG4gICAgICAgICAgJ1wiLz5cXG4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIG1hcmt1cC5wdXNoKCh0aGlzLnR5cGUgPT09ICdsaW5lYXInID8gJzwvbGluZWFyR3JhZGllbnQ+XFxuJyA6ICc8L3JhZGlhbEdyYWRpZW50PlxcbicpKTtcblxuICAgICAgcmV0dXJuIG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBDYW52YXNHcmFkaWVudFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7Q2FudmFzR3JhZGllbnR9XG4gICAgICovXG4gICAgdG9MaXZlOiBmdW5jdGlvbihjdHgsIG9iamVjdCkge1xuICAgICAgdmFyIGdyYWRpZW50LCBwcm9wLCBjb29yZHMgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUodGhpcy5jb29yZHMpO1xuXG4gICAgICBpZiAoIXRoaXMudHlwZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmplY3QuZ3JvdXAgJiYgb2JqZWN0Lmdyb3VwLnR5cGUgPT09ICdwYXRoLWdyb3VwJykge1xuICAgICAgICBmb3IgKHByb3AgaW4gY29vcmRzKSB7XG4gICAgICAgICAgaWYgKHByb3AgPT09ICd4MScgfHwgcHJvcCA9PT0gJ3gyJykge1xuICAgICAgICAgICAgY29vcmRzW3Byb3BdICs9IC10aGlzLm9mZnNldFggKyBvYmplY3Qud2lkdGggLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChwcm9wID09PSAneTEnIHx8IHByb3AgPT09ICd5MicpIHtcbiAgICAgICAgICAgIGNvb3Jkc1twcm9wXSArPSAtdGhpcy5vZmZzZXRZICsgb2JqZWN0LmhlaWdodCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgIGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KFxuICAgICAgICAgIGNvb3Jkcy54MSwgY29vcmRzLnkxLCBjb29yZHMueDIsIGNvb3Jkcy55Mik7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdyYWRpYWwnKSB7XG4gICAgICAgIGdyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KFxuICAgICAgICAgIGNvb3Jkcy54MSwgY29vcmRzLnkxLCBjb29yZHMucjEsIGNvb3Jkcy54MiwgY29vcmRzLnkyLCBjb29yZHMucjIpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb2xvclN0b3BzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjb2xvciA9IHRoaXMuY29sb3JTdG9wc1tpXS5jb2xvcixcbiAgICAgICAgICAgIG9wYWNpdHkgPSB0aGlzLmNvbG9yU3RvcHNbaV0ub3BhY2l0eSxcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuY29sb3JTdG9wc1tpXS5vZmZzZXQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcGFjaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcihjb2xvcikuc2V0QWxwaGEob3BhY2l0eSkudG9SZ2JhKCk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKHBhcnNlRmxvYXQob2Zmc2V0KSwgY29sb3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ3JhZGllbnQ7XG4gICAgfVxuICB9KTtcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5HcmFkaWVudCwge1xuXG4gICAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5HcmFkaWVudH0gaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkdyYWRpZW50XG4gICAgICogQHBhcmFtIHtTVkdHcmFkaWVudEVsZW1lbnR9IGVsIFNWRyBncmFkaWVudCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5HcmFkaWVudH0gR3JhZGllbnQgaW5zdGFuY2VcbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wc2VydmVycy5odG1sI0xpbmVhckdyYWRpZW50RWxlbWVudFxuICAgICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BzZXJ2ZXJzLmh0bWwjUmFkaWFsR3JhZGllbnRFbGVtZW50XG4gICAgICovXG4gICAgZnJvbUVsZW1lbnQ6IGZ1bmN0aW9uKGVsLCBpbnN0YW5jZSkge1xuXG4gICAgICAvKipcbiAgICAgICAqICBAZXhhbXBsZTpcbiAgICAgICAqXG4gICAgICAgKiAgPGxpbmVhckdyYWRpZW50IGlkPVwibGluZWFyR3JhZDFcIj5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjAlXCIgc3RvcC1jb2xvcj1cIndoaXRlXCIvPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMTAwJVwiIHN0b3AtY29sb3I9XCJibGFja1wiLz5cbiAgICAgICAqICA8L2xpbmVhckdyYWRpZW50PlxuICAgICAgICpcbiAgICAgICAqICBPUlxuICAgICAgICpcbiAgICAgICAqICA8bGluZWFyR3JhZGllbnQgaWQ9XCJsaW5lYXJHcmFkMlwiPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMFwiIHN0eWxlPVwic3RvcC1jb2xvcjpyZ2IoMjU1LDI1NSwyNTUpXCIvPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMVwiIHN0eWxlPVwic3RvcC1jb2xvcjpyZ2IoMCwwLDApXCIvPlxuICAgICAgICogIDwvbGluZWFyR3JhZGllbnQ+XG4gICAgICAgKlxuICAgICAgICogIE9SXG4gICAgICAgKlxuICAgICAgICogIDxyYWRpYWxHcmFkaWVudCBpZD1cInJhZGlhbEdyYWQxXCI+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIwJVwiIHN0b3AtY29sb3I9XCJ3aGl0ZVwiIHN0b3Atb3BhY2l0eT1cIjFcIiAvPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiNTAlXCIgc3RvcC1jb2xvcj1cImJsYWNrXCIgc3RvcC1vcGFjaXR5PVwiMC41XCIgLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjEwMCVcIiBzdG9wLWNvbG9yPVwid2hpdGVcIiBzdG9wLW9wYWNpdHk9XCIxXCIgLz5cbiAgICAgICAqICA8L3JhZGlhbEdyYWRpZW50PlxuICAgICAgICpcbiAgICAgICAqICBPUlxuICAgICAgICpcbiAgICAgICAqICA8cmFkaWFsR3JhZGllbnQgaWQ9XCJyYWRpYWxHcmFkMlwiPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMFwiIHN0b3AtY29sb3I9XCJyZ2IoMjU1LDI1NSwyNTUpXCIgLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjAuNVwiIHN0b3AtY29sb3I9XCJyZ2IoMCwwLDApXCIgLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjFcIiBzdG9wLWNvbG9yPVwicmdiKDI1NSwyNTUsMjU1KVwiIC8+XG4gICAgICAgKiAgPC9yYWRpYWxHcmFkaWVudD5cbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgICAgdmFyIGNvbG9yU3RvcEVscyA9IGVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzdG9wJyksXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBncmFkaWVudFVuaXRzID0gZWwuZ2V0QXR0cmlidXRlKCdncmFkaWVudFVuaXRzJykgfHwgJ29iamVjdEJvdW5kaW5nQm94JyxcbiAgICAgICAgICBncmFkaWVudFRyYW5zZm9ybSA9IGVsLmdldEF0dHJpYnV0ZSgnZ3JhZGllbnRUcmFuc2Zvcm0nKSxcbiAgICAgICAgICBjb2xvclN0b3BzID0gW10sXG4gICAgICAgICAgY29vcmRzLCBlbGxpcHNlTWF0cml4O1xuXG4gICAgICBpZiAoZWwubm9kZU5hbWUgPT09ICdsaW5lYXJHcmFkaWVudCcgfHwgZWwubm9kZU5hbWUgPT09ICdMSU5FQVJHUkFESUVOVCcpIHtcbiAgICAgICAgdHlwZSA9ICdsaW5lYXInO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHR5cGUgPSAncmFkaWFsJztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgIGNvb3JkcyA9IGdldExpbmVhckNvb3JkcyhlbCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlID09PSAncmFkaWFsJykge1xuICAgICAgICBjb29yZHMgPSBnZXRSYWRpYWxDb29yZHMoZWwpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gY29sb3JTdG9wRWxzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgY29sb3JTdG9wcy5wdXNoKGdldENvbG9yU3RvcChjb2xvclN0b3BFbHNbaV0pKTtcbiAgICAgIH1cblxuICAgICAgZWxsaXBzZU1hdHJpeCA9IF9jb252ZXJ0UGVyY2VudFVuaXRzVG9WYWx1ZXMoaW5zdGFuY2UsIGNvb3JkcywgZ3JhZGllbnRVbml0cyk7XG5cbiAgICAgIHZhciBncmFkaWVudCA9IG5ldyBmYWJyaWMuR3JhZGllbnQoe1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBjb29yZHM6IGNvb3JkcyxcbiAgICAgICAgY29sb3JTdG9wczogY29sb3JTdG9wcyxcbiAgICAgICAgb2Zmc2V0WDogLWluc3RhbmNlLmxlZnQsXG4gICAgICAgIG9mZnNldFk6IC1pbnN0YW5jZS50b3BcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZ3JhZGllbnRUcmFuc2Zvcm0gfHwgZWxsaXBzZU1hdHJpeCAhPT0gJycpIHtcbiAgICAgICAgZ3JhZGllbnQuZ3JhZGllbnRUcmFuc2Zvcm0gPSBmYWJyaWMucGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUoKGdyYWRpZW50VHJhbnNmb3JtIHx8ICcnKSArIGVsbGlwc2VNYXRyaXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyYWRpZW50O1xuICAgIH0sXG4gICAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5HcmFkaWVudH0gaW5zdGFuY2UgZnJvbSBpdHMgb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuR3JhZGllbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGZvck9iamVjdDogZnVuY3Rpb24ob2JqLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIF9jb252ZXJ0UGVyY2VudFVuaXRzVG9WYWx1ZXMob2JqLCBvcHRpb25zLmNvb3JkcywgJ3VzZXJTcGFjZU9uVXNlJyk7XG4gICAgICByZXR1cm4gbmV3IGZhYnJpYy5HcmFkaWVudChvcHRpb25zKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2NvbnZlcnRQZXJjZW50VW5pdHNUb1ZhbHVlcyhvYmplY3QsIG9wdGlvbnMsIGdyYWRpZW50VW5pdHMpIHtcbiAgICB2YXIgcHJvcFZhbHVlLCBhZGRGYWN0b3IgPSAwLCBtdWx0RmFjdG9yID0gMSwgZWxsaXBzZU1hdHJpeCA9ICcnO1xuICAgIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnNbcHJvcF0gPT09ICdJbmZpbml0eScpIHtcbiAgICAgICAgb3B0aW9uc1twcm9wXSA9IDE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcHRpb25zW3Byb3BdID09PSAnLUluZmluaXR5Jykge1xuICAgICAgICBvcHRpb25zW3Byb3BdID0gMDtcbiAgICAgIH1cbiAgICAgIHByb3BWYWx1ZSA9IHBhcnNlRmxvYXQob3B0aW9uc1twcm9wXSwgMTApO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zW3Byb3BdID09PSAnc3RyaW5nJyAmJiAvXlxcZCslJC8udGVzdChvcHRpb25zW3Byb3BdKSkge1xuICAgICAgICBtdWx0RmFjdG9yID0gMC4wMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtdWx0RmFjdG9yID0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wID09PSAneDEnIHx8IHByb3AgPT09ICd4MicgfHwgcHJvcCA9PT0gJ3IyJykge1xuICAgICAgICBtdWx0RmFjdG9yICo9IGdyYWRpZW50VW5pdHMgPT09ICdvYmplY3RCb3VuZGluZ0JveCcgPyBvYmplY3Qud2lkdGggOiAxO1xuICAgICAgICBhZGRGYWN0b3IgPSBncmFkaWVudFVuaXRzID09PSAnb2JqZWN0Qm91bmRpbmdCb3gnID8gb2JqZWN0LmxlZnQgfHwgMCA6IDA7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChwcm9wID09PSAneTEnIHx8IHByb3AgPT09ICd5MicpIHtcbiAgICAgICAgbXVsdEZhY3RvciAqPSBncmFkaWVudFVuaXRzID09PSAnb2JqZWN0Qm91bmRpbmdCb3gnID8gb2JqZWN0LmhlaWdodCA6IDE7XG4gICAgICAgIGFkZEZhY3RvciA9IGdyYWRpZW50VW5pdHMgPT09ICdvYmplY3RCb3VuZGluZ0JveCcgPyBvYmplY3QudG9wIHx8IDAgOiAwO1xuICAgICAgfVxuICAgICAgb3B0aW9uc1twcm9wXSA9IHByb3BWYWx1ZSAqIG11bHRGYWN0b3IgKyBhZGRGYWN0b3I7XG4gICAgfVxuICAgIGlmIChvYmplY3QudHlwZSA9PT0gJ2VsbGlwc2UnICYmXG4gICAgICAgIG9wdGlvbnMucjIgIT09IG51bGwgJiZcbiAgICAgICAgZ3JhZGllbnRVbml0cyA9PT0gJ29iamVjdEJvdW5kaW5nQm94JyAmJlxuICAgICAgICBvYmplY3QucnggIT09IG9iamVjdC5yeSkge1xuXG4gICAgICB2YXIgc2NhbGVGYWN0b3IgPSBvYmplY3QucnkgLyBvYmplY3Qucng7XG4gICAgICBlbGxpcHNlTWF0cml4ID0gJyBzY2FsZSgxLCAnICsgc2NhbGVGYWN0b3IgKyAnKSc7XG4gICAgICBpZiAob3B0aW9ucy55MSkge1xuICAgICAgICBvcHRpb25zLnkxIC89IHNjYWxlRmFjdG9yO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMueTIpIHtcbiAgICAgICAgb3B0aW9ucy55MiAvPSBzY2FsZUZhY3RvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsbGlwc2VNYXRyaXg7XG4gIH1cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQ7XG5cbiAgLyoqXG4gICAqIFBhdHRlcm4gY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5QYXR0ZXJuXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vcGF0dGVybnN8UGF0dGVybiBkZW1vfVxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2R5bmFtaWMtcGF0dGVybnN8RHluYW1pY1BhdHRlcm4gZGVtb31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlBhdHRlcm4jaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG5cblxuICBmYWJyaWMuUGF0dGVybiA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKC8qKiBAbGVuZHMgZmFicmljLlBhdHRlcm4ucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFJlcGVhdCBwcm9wZXJ0eSBvZiBhIHBhdHRlcm4gKG9uZSBvZiByZXBlYXQsIHJlcGVhdC14LCByZXBlYXQteSBvciBuby1yZXBlYXQpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByZXBlYXQ6ICdyZXBlYXQnLFxuXG4gICAgLyoqXG4gICAgICogUGF0dGVybiBob3Jpem9udGFsIG9mZnNldCBmcm9tIG9iamVjdCdzIGxlZnQvdG9wIGNvcm5lclxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb2Zmc2V0WDogMCxcblxuICAgIC8qKlxuICAgICAqIFBhdHRlcm4gdmVydGljYWwgb2Zmc2V0IGZyb20gb2JqZWN0J3MgbGVmdC90b3AgY29ybmVyXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvZmZzZXRZOiAwLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBmdW5jdGlvbiB0byBpbnZva2UgYWZ0ZXIgY2FsbGJhY2sgaW5pdC5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUGF0dGVybn0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdGhpcy5pZCA9IGZhYnJpYy5PYmplY3QuX191aWQrKztcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIGlmICghb3B0aW9ucy5zb3VyY2UgfHwgKG9wdGlvbnMuc291cmNlICYmIHR5cGVvZiBvcHRpb25zLnNvdXJjZSAhPT0gJ3N0cmluZycpKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHRoaXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBmdW5jdGlvbiBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgZmFicmljLnV0aWwuZ2V0RnVuY3Rpb25Cb2R5KG9wdGlvbnMuc291cmNlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBuZXcgRnVuY3Rpb24oZmFicmljLnV0aWwuZ2V0RnVuY3Rpb25Cb2R5KG9wdGlvbnMuc291cmNlKSk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHRoaXMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGltZyBzcmMgc3RyaW5nXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc291cmNlID0gZmFicmljLnV0aWwuY3JlYXRlSW1hZ2UoKTtcbiAgICAgICAgZmFicmljLnV0aWwubG9hZEltYWdlKG9wdGlvbnMuc291cmNlLCBmdW5jdGlvbihpbWcpIHtcbiAgICAgICAgICBfdGhpcy5zb3VyY2UgPSBpbWc7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soX3RoaXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYSBwYXR0ZXJuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgcGF0dGVybiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUyxcbiAgICAgICAgICBzb3VyY2UsIG9iamVjdDtcblxuICAgICAgLy8gY2FsbGJhY2tcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5zb3VyY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc291cmNlID0gU3RyaW5nKHRoaXMuc291cmNlKTtcbiAgICAgIH1cbiAgICAgIC8vIDxpbWc+IGVsZW1lbnRcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZS5zcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNvdXJjZSA9IHRoaXMuc291cmNlLnNyYztcbiAgICAgIH1cbiAgICAgIC8vIDxjYW52YXM+IGVsZW1lbnRcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZSA9PT0gJ29iamVjdCcgJiYgdGhpcy5zb3VyY2UudG9EYXRhVVJMKSB7XG4gICAgICAgIHNvdXJjZSA9IHRoaXMuc291cmNlLnRvRGF0YVVSTCgpO1xuICAgICAgfVxuXG4gICAgICBvYmplY3QgPSB7XG4gICAgICAgIHR5cGU6ICdwYXR0ZXJuJyxcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIHJlcGVhdDogdGhpcy5yZXBlYXQsXG4gICAgICAgIG9mZnNldFg6IHRvRml4ZWQodGhpcy5vZmZzZXRYLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgb2Zmc2V0WTogdG9GaXhlZCh0aGlzLm9mZnNldFksIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgfTtcbiAgICAgIGZhYnJpYy51dGlsLnBvcHVsYXRlV2l0aFByb3BlcnRpZXModGhpcywgb2JqZWN0LCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhIHBhdHRlcm5cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGEgcGF0dGVyblxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBwYXR0ZXJuU291cmNlID0gdHlwZW9mIHRoaXMuc291cmNlID09PSAnZnVuY3Rpb24nID8gdGhpcy5zb3VyY2UoKSA6IHRoaXMuc291cmNlLFxuICAgICAgICAgIHBhdHRlcm5XaWR0aCA9IHBhdHRlcm5Tb3VyY2Uud2lkdGggLyBvYmplY3Qud2lkdGgsXG4gICAgICAgICAgcGF0dGVybkhlaWdodCA9IHBhdHRlcm5Tb3VyY2UuaGVpZ2h0IC8gb2JqZWN0LmhlaWdodCxcbiAgICAgICAgICBwYXR0ZXJuT2Zmc2V0WCA9IHRoaXMub2Zmc2V0WCAvIG9iamVjdC53aWR0aCxcbiAgICAgICAgICBwYXR0ZXJuT2Zmc2V0WSA9IHRoaXMub2Zmc2V0WSAvIG9iamVjdC5oZWlnaHQsXG4gICAgICAgICAgcGF0dGVybkltZ1NyYyA9ICcnO1xuICAgICAgaWYgKHRoaXMucmVwZWF0ID09PSAncmVwZWF0LXgnIHx8IHRoaXMucmVwZWF0ID09PSAnbm8tcmVwZWF0Jykge1xuICAgICAgICBwYXR0ZXJuSGVpZ2h0ID0gMTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJlcGVhdCA9PT0gJ3JlcGVhdC15JyB8fCB0aGlzLnJlcGVhdCA9PT0gJ25vLXJlcGVhdCcpIHtcbiAgICAgICAgcGF0dGVybldpZHRoID0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXR0ZXJuU291cmNlLnNyYykge1xuICAgICAgICBwYXR0ZXJuSW1nU3JjID0gcGF0dGVyblNvdXJjZS5zcmM7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChwYXR0ZXJuU291cmNlLnRvRGF0YVVSTCkge1xuICAgICAgICBwYXR0ZXJuSW1nU3JjID0gcGF0dGVyblNvdXJjZS50b0RhdGFVUkwoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICc8cGF0dGVybiBpZD1cIlNWR0lEXycgKyB0aGlzLmlkICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiIHg9XCInICsgcGF0dGVybk9mZnNldFggK1xuICAgICAgICAgICAgICAgICAgICAnXCIgeT1cIicgKyBwYXR0ZXJuT2Zmc2V0WSArXG4gICAgICAgICAgICAgICAgICAgICdcIiB3aWR0aD1cIicgKyBwYXR0ZXJuV2lkdGggK1xuICAgICAgICAgICAgICAgICAgICAnXCIgaGVpZ2h0PVwiJyArIHBhdHRlcm5IZWlnaHQgKyAnXCI+XFxuJyArXG4gICAgICAgICAgICAgICAnPGltYWdlIHg9XCIwXCIgeT1cIjBcIicgK1xuICAgICAgICAgICAgICAgICAgICAgICcgd2lkdGg9XCInICsgcGF0dGVyblNvdXJjZS53aWR0aCArXG4gICAgICAgICAgICAgICAgICAgICAgJ1wiIGhlaWdodD1cIicgKyBwYXR0ZXJuU291cmNlLmhlaWdodCArXG4gICAgICAgICAgICAgICAgICAgICAgJ1wiIHhsaW5rOmhyZWY9XCInICsgcGF0dGVybkltZ1NyYyArXG4gICAgICAgICAgICAgICAnXCI+PC9pbWFnZT5cXG4nICtcbiAgICAgICAgICAgICAnPC9wYXR0ZXJuPlxcbic7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzW3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBDYW52YXNQYXR0ZXJuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIGNyZWF0ZSBwYXR0ZXJuXG4gICAgICogQHJldHVybiB7Q2FudmFzUGF0dGVybn1cbiAgICAgKi9cbiAgICB0b0xpdmU6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHR5cGVvZiB0aGlzLnNvdXJjZSA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuc291cmNlKCkgOiB0aGlzLnNvdXJjZTtcblxuICAgICAgLy8gaWYgdGhlIGltYWdlIGZhaWxlZCB0byBsb2FkLCByZXR1cm4sIGFuZCBhbGxvdyByZXN0IHRvIGNvbnRpbnVlIGxvYWRpbmdcbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgLy8gaWYgYW4gaW1hZ2VcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlLnNyYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKCFzb3VyY2UuY29tcGxldGUpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZS5uYXR1cmFsV2lkdGggPT09IDAgfHwgc291cmNlLm5hdHVyYWxIZWlnaHQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjdHguY3JlYXRlUGF0dGVybihzb3VyY2UsIHRoaXMucmVwZWF0KTtcbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkO1xuXG4gIGlmIChmYWJyaWMuU2hhZG93KSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5TaGFkb3cgaXMgYWxyZWFkeSBkZWZpbmVkLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaGFkb3cgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5TaGFkb3dcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9zaGFkb3dzfFNoYWRvdyBkZW1vfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuU2hhZG93I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuU2hhZG93ID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoLyoqIEBsZW5kcyBmYWJyaWMuU2hhZG93LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBTaGFkb3cgY29sb3JcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNvbG9yOiAncmdiKDAsMCwwKScsXG5cbiAgICAvKipcbiAgICAgKiBTaGFkb3cgYmx1clxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIGJsdXI6IDAsXG5cbiAgICAvKipcbiAgICAgKiBTaGFkb3cgaG9yaXpvbnRhbCBvZmZzZXRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG9mZnNldFg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBTaGFkb3cgdmVydGljYWwgb2Zmc2V0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvZmZzZXRZOiAwLFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgc2hhZG93IHNob3VsZCBhZmZlY3Qgc3Ryb2tlIG9wZXJhdGlvbnNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBhZmZlY3RTdHJva2U6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdG9PYmplY3Qgc2hvdWxkIGluY2x1ZGUgZGVmYXVsdCB2YWx1ZXNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbmNsdWRlRGVmYXVsdFZhbHVlczogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3Qgd2l0aCBhbnkgb2YgY29sb3IsIGJsdXIsIG9mZnNldFgsIG9mZnNldFggcHJvcGVydGllcyBvciBzdHJpbmcgKGUuZy4gXCJyZ2JhKDAsMCwwLDAuMikgMnB4IDJweCAxMHB4LCBcIjJweCAycHggMTBweCByZ2JhKDAsMCwwLDAuMilcIilcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuU2hhZG93fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLl9wYXJzZVNoYWRvdyhvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXNbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlkID0gZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaGFkb3cgU2hhZG93IHZhbHVlIHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBTaGFkb3cgb2JqZWN0IHdpdGggY29sb3IsIG9mZnNldFgsIG9mZnNldFkgYW5kIGJsdXJcbiAgICAgKi9cbiAgICBfcGFyc2VTaGFkb3c6IGZ1bmN0aW9uKHNoYWRvdykge1xuICAgICAgdmFyIHNoYWRvd1N0ciA9IHNoYWRvdy50cmltKCksXG4gICAgICAgICAgb2Zmc2V0c0FuZEJsdXIgPSBmYWJyaWMuU2hhZG93LnJlT2Zmc2V0c0FuZEJsdXIuZXhlYyhzaGFkb3dTdHIpIHx8IFtdLFxuICAgICAgICAgIGNvbG9yID0gc2hhZG93U3RyLnJlcGxhY2UoZmFicmljLlNoYWRvdy5yZU9mZnNldHNBbmRCbHVyLCAnJykgfHwgJ3JnYigwLDAsMCknO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2xvcjogY29sb3IudHJpbSgpLFxuICAgICAgICBvZmZzZXRYOiBwYXJzZUludChvZmZzZXRzQW5kQmx1clsxXSwgMTApIHx8IDAsXG4gICAgICAgIG9mZnNldFk6IHBhcnNlSW50KG9mZnNldHNBbmRCbHVyWzJdLCAxMCkgfHwgMCxcbiAgICAgICAgYmx1cjogcGFyc2VJbnQob2Zmc2V0c0FuZEJsdXJbM10sIDEwKSB8fCAwXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MtdGV4dC1kZWNvci0zLyN0ZXh0LXNoYWRvd1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyBDU1MzIHRleHQtc2hhZG93IGRlY2xhcmF0aW9uXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLm9mZnNldFgsIHRoaXMub2Zmc2V0WSwgdGhpcy5ibHVyLCB0aGlzLmNvbG9yXS5qb2luKCdweCAnKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhIHNoYWRvd1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTVkcgcmVwcmVzZW50YXRpb24gb2YgYSBzaGFkb3dcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgZkJveFggPSA0MCwgZkJveFkgPSA0MCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUyxcbiAgICAgICAgICBvZmZzZXQgPSBmYWJyaWMudXRpbC5yb3RhdGVWZWN0b3IoXG4gICAgICAgICAgICB7IHg6IHRoaXMub2Zmc2V0WCwgeTogdGhpcy5vZmZzZXRZIH0sXG4gICAgICAgICAgICBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKC1vYmplY3QuYW5nbGUpKSxcbiAgICAgICAgICBCTFVSX0JPWCA9IDIwO1xuXG4gICAgICBpZiAob2JqZWN0LndpZHRoICYmIG9iamVjdC5oZWlnaHQpIHtcbiAgICAgICAgLy9odHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvZmlsdGVycy5odG1sI0ZpbHRlckVmZmVjdHNSZWdpb25cbiAgICAgICAgLy8gd2UgYWRkIHNvbWUgZXh0cmEgc3BhY2UgdG8gZmlsdGVyIGJveCB0byBjb250YWluIHRoZSBibHVyICggMjAgKVxuICAgICAgICBmQm94WCA9IHRvRml4ZWQoKE1hdGguYWJzKG9mZnNldC54KSArIHRoaXMuYmx1cikgLyBvYmplY3Qud2lkdGgsIE5VTV9GUkFDVElPTl9ESUdJVFMpICogMTAwICsgQkxVUl9CT1g7XG4gICAgICAgIGZCb3hZID0gdG9GaXhlZCgoTWF0aC5hYnMob2Zmc2V0LnkpICsgdGhpcy5ibHVyKSAvIG9iamVjdC5oZWlnaHQsIE5VTV9GUkFDVElPTl9ESUdJVFMpICogMTAwICsgQkxVUl9CT1g7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmZsaXBYKSB7XG4gICAgICAgIG9mZnNldC54ICo9IC0xO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5mbGlwWSkge1xuICAgICAgICBvZmZzZXQueSAqPSAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXG4gICAgICAgICc8ZmlsdGVyIGlkPVwiU1ZHSURfJyArIHRoaXMuaWQgKyAnXCIgeT1cIi0nICsgZkJveFkgKyAnJVwiIGhlaWdodD1cIicgKyAoMTAwICsgMiAqIGZCb3hZKSArICclXCIgJyArXG4gICAgICAgICAgJ3g9XCItJyArIGZCb3hYICsgJyVcIiB3aWR0aD1cIicgKyAoMTAwICsgMiAqIGZCb3hYKSArICclXCIgJyArICc+XFxuJyArXG4gICAgICAgICAgJ1xcdDxmZUdhdXNzaWFuQmx1ciBpbj1cIlNvdXJjZUFscGhhXCIgc3RkRGV2aWF0aW9uPVwiJyArXG4gICAgICAgICAgICB0b0ZpeGVkKHRoaXMuYmx1ciA/IHRoaXMuYmx1ciAvIDIgOiAwLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICdcIj48L2ZlR2F1c3NpYW5CbHVyPlxcbicgK1xuICAgICAgICAgICdcXHQ8ZmVPZmZzZXQgZHg9XCInICsgdG9GaXhlZChvZmZzZXQueCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgK1xuICAgICAgICAgICdcIiBkeT1cIicgKyB0b0ZpeGVkKG9mZnNldC55LCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICdcIiByZXN1bHQ9XCJvQmx1clwiID48L2ZlT2Zmc2V0PlxcbicgK1xuICAgICAgICAgICdcXHQ8ZmVGbG9vZCBmbG9vZC1jb2xvcj1cIicgKyB0aGlzLmNvbG9yICsgJ1wiLz5cXG4nICtcbiAgICAgICAgICAnXFx0PGZlQ29tcG9zaXRlIGluMj1cIm9CbHVyXCIgb3BlcmF0b3I9XCJpblwiIC8+XFxuJyArXG4gICAgICAgICAgJ1xcdDxmZU1lcmdlPlxcbicgK1xuICAgICAgICAgICAgJ1xcdFxcdDxmZU1lcmdlTm9kZT48L2ZlTWVyZ2VOb2RlPlxcbicgK1xuICAgICAgICAgICAgJ1xcdFxcdDxmZU1lcmdlTm9kZSBpbj1cIlNvdXJjZUdyYXBoaWNcIj48L2ZlTWVyZ2VOb2RlPlxcbicgK1xuICAgICAgICAgICdcXHQ8L2ZlTWVyZ2U+XFxuJyArXG4gICAgICAgICc8L2ZpbHRlcj5cXG4nKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYSBzaGFkb3dcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIHNoYWRvdyBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmluY2x1ZGVEZWZhdWx0VmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICAgICAgYmx1cjogdGhpcy5ibHVyLFxuICAgICAgICAgIG9mZnNldFg6IHRoaXMub2Zmc2V0WCxcbiAgICAgICAgICBvZmZzZXRZOiB0aGlzLm9mZnNldFksXG4gICAgICAgICAgYWZmZWN0U3Ryb2tlOiB0aGlzLmFmZmVjdFN0cm9rZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IHsgfSwgcHJvdG8gPSBmYWJyaWMuU2hhZG93LnByb3RvdHlwZTtcblxuICAgICAgWydjb2xvcicsICdibHVyJywgJ29mZnNldFgnLCAnb2Zmc2V0WScsICdhZmZlY3RTdHJva2UnXS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgaWYgKHRoaXNbcHJvcF0gIT09IHByb3RvW3Byb3BdKSB7XG4gICAgICAgICAgb2JqW3Byb3BdID0gdGhpc1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmVnZXggbWF0Y2hpbmcgc2hhZG93IG9mZnNldFgsIG9mZnNldFkgYW5kIGJsdXIgKGV4OiBcIjJweCAycHggMTBweCByZ2JhKDAsMCwwLDAuMilcIiwgXCJyZ2IoMCwyNTUsMCkgMnB4IDJweFwiKVxuICAgKiBAc3RhdGljXG4gICAqIEBmaWVsZFxuICAgKiBAbWVtYmVyT2YgZmFicmljLlNoYWRvd1xuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgZmFicmljLlNoYWRvdy5yZU9mZnNldHNBbmRCbHVyID0gLyg/Olxcc3xeKSgtP1xcZCsoPzpweCk/KD86XFxzP3wkKSk/KC0/XFxkKyg/OnB4KT8oPzpcXHM/fCQpKT8oXFxkKyg/OnB4KT8pPyg/Olxccz98JCkoPzokfFxccykvO1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uICgpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKGZhYnJpYy5TdGF0aWNDYW52YXMpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlN0YXRpY0NhbnZhcyBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gYWxpYXNlcyBmb3IgZmFzdGVyIHJlc29sdXRpb25cbiAgdmFyIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBnZXRFbGVtZW50T2Zmc2V0ID0gZmFicmljLnV0aWwuZ2V0RWxlbWVudE9mZnNldCxcbiAgICAgIHJlbW92ZUZyb21BcnJheSA9IGZhYnJpYy51dGlsLnJlbW92ZUZyb21BcnJheSxcbiAgICAgIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkLFxuXG4gICAgICBDQU5WQVNfSU5JVF9FUlJPUiA9IG5ldyBFcnJvcignQ291bGQgbm90IGluaXRpYWxpemUgYGNhbnZhc2AgZWxlbWVudCcpO1xuXG4gIC8qKlxuICAgKiBTdGF0aWMgY2FudmFzIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuU3RhdGljQ2FudmFzXG4gICAqIEBtaXhlcyBmYWJyaWMuQ29sbGVjdGlvblxuICAgKiBAbWl4ZXMgZmFicmljLk9ic2VydmFibGVcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9zdGF0aWNfY2FudmFzfFN0YXRpY0NhbnZhcyBkZW1vfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBmaXJlcyBiZWZvcmU6cmVuZGVyXG4gICAqIEBmaXJlcyBhZnRlcjpyZW5kZXJcbiAgICogQGZpcmVzIGNhbnZhczpjbGVhcmVkXG4gICAqIEBmaXJlcyBvYmplY3Q6YWRkZWRcbiAgICogQGZpcmVzIG9iamVjdDpyZW1vdmVkXG4gICAqL1xuICBmYWJyaWMuU3RhdGljQ2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLkNvbW1vbk1ldGhvZHMsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgU3RyaW5nfSBlbCAmbHQ7Y2FudmFzPiBlbGVtZW50IHRvIGluaXRpYWxpemUgaW5zdGFuY2Ugb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICB0aGlzLl9pbml0U3RhdGljKGVsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBjb2xvciBvZiBjYW52YXMgaW5zdGFuY2UuXG4gICAgICogU2hvdWxkIGJlIHNldCB2aWEge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjc2V0QmFja2dyb3VuZENvbG9yfS5cbiAgICAgKiBAdHlwZSB7KFN0cmluZ3xmYWJyaWMuUGF0dGVybil9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBpbWFnZSBvZiBjYW52YXMgaW5zdGFuY2UuXG4gICAgICogU2hvdWxkIGJlIHNldCB2aWEge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjc2V0QmFja2dyb3VuZEltYWdlfS5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGUgXCJiYWNrZ3JvdW5kSW1hZ2VPcGFjaXR5XCJcbiAgICAgKiBhbmQgXCJiYWNrZ3JvdW5kSW1hZ2VTdHJldGNoXCIgcHJvcGVydGllcyBhcmUgZGVwcmVjYXRlZCBzaW5jZSAxLjMuOS5cbiAgICAgKiBVc2Uge0BsaW5rIGZhYnJpYy5JbWFnZSNvcGFjaXR5fSwge0BsaW5rIGZhYnJpYy5JbWFnZSN3aWR0aH0gYW5kIHtAbGluayBmYWJyaWMuSW1hZ2UjaGVpZ2h0fS5cbiAgICAgKiBAdHlwZSBmYWJyaWMuSW1hZ2VcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJhY2tncm91bmRJbWFnZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIE92ZXJsYXkgY29sb3Igb2YgY2FudmFzIGluc3RhbmNlLlxuICAgICAqIFNob3VsZCBiZSBzZXQgdmlhIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI3NldE92ZXJsYXlDb2xvcn1cbiAgICAgKiBAc2luY2UgMS4zLjlcbiAgICAgKiBAdHlwZSB7KFN0cmluZ3xmYWJyaWMuUGF0dGVybil9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvdmVybGF5Q29sb3I6ICcnLFxuXG4gICAgLyoqXG4gICAgICogT3ZlcmxheSBpbWFnZSBvZiBjYW52YXMgaW5zdGFuY2UuXG4gICAgICogU2hvdWxkIGJlIHNldCB2aWEge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjc2V0T3ZlcmxheUltYWdlfS5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGUgXCJvdmVybGF5SW1hZ2VMZWZ0XCJcbiAgICAgKiBhbmQgXCJvdmVybGF5SW1hZ2VUb3BcIiBwcm9wZXJ0aWVzIGFyZSBkZXByZWNhdGVkIHNpbmNlIDEuMy45LlxuICAgICAqIFVzZSB7QGxpbmsgZmFicmljLkltYWdlI2xlZnR9IGFuZCB7QGxpbmsgZmFicmljLkltYWdlI3RvcH0uXG4gICAgICogQHR5cGUgZmFicmljLkltYWdlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvdmVybGF5SW1hZ2U6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0b09iamVjdC90b0RhdGFsZXNzT2JqZWN0IHNob3VsZCBpbmNsdWRlIGRlZmF1bHQgdmFsdWVzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaW5jbHVkZURlZmF1bHRWYWx1ZXM6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvYmplY3RzJyBzdGF0ZSBzaG91bGQgYmUgc2F2ZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdGF0ZWZ1bDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB7QGxpbmsgZmFicmljLkNvbGxlY3Rpb24uYWRkfSwge0BsaW5rIGZhYnJpYy5Db2xsZWN0aW9uLmluc2VydEF0fSBhbmQge0BsaW5rIGZhYnJpYy5Db2xsZWN0aW9uLnJlbW92ZX0gc2hvdWxkIGFsc28gcmUtcmVuZGVyIGNhbnZhcy5cbiAgICAgKiBEaXNhYmxpbmcgdGhpcyBvcHRpb24gY291bGQgZ2l2ZSBhIGdyZWF0IHBlcmZvcm1hbmNlIGJvb3N0IHdoZW4gYWRkaW5nL3JlbW92aW5nIGEgbG90IG9mIG9iamVjdHMgdG8vZnJvbSBjYW52YXMgYXQgb25jZVxuICAgICAqIChmb2xsb3dlZCBieSBhIG1hbnVhbCByZW5kZXJpbmcgYWZ0ZXIgYWRkaXRpb24vZGVsZXRpb24pXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcmVuZGVyT25BZGRSZW1vdmU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IGRldGVybWluZXMgY2xpcHBpbmcgb2YgZW50aXJlIGNhbnZhcyBhcmVhXG4gICAgICogQmVpbmcgcGFzc2VkIGNvbnRleHQgYXMgZmlyc3QgYXJndW1lbnQuIFNlZSBjbGlwcGluZyBjYW52YXMgYXJlYSBpbiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2thbmdheC9mYWJyaWMuanMvd2lraS9GQVF9XG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNsaXBUbzogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIG9iamVjdCBjb250cm9scyAoYm9yZGVycy9jb250cm9scykgYXJlIHJlbmRlcmVkIGFib3ZlIG92ZXJsYXkgaW1hZ2VcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb250cm9sc0Fib3ZlT3ZlcmxheTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYnJvd3NlciBjYW4gYmUgc2Nyb2xsZWQgd2hlbiB1c2luZyBhIHRvdWNoc2NyZWVuIGFuZCBkcmFnZ2luZyBvbiB0aGUgY2FudmFzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYWxsb3dUb3VjaFNjcm9sbGluZzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGNhbnZhcyB3aWxsIHVzZSBpbWFnZSBzbW9vdGhpbmcsIHRoaXMgaXMgb24gYnkgZGVmYXVsdCBpbiBicm93c2Vyc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGltYWdlU21vb3RoaW5nRW5hYmxlZDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0cmFuc2Zvcm1hdGlvbiAoaW4gdGhlIGZvcm1hdCBvZiBDYW52YXMgdHJhbnNmb3JtKSB3aGljaCBmb2N1c2VzIHRoZSB2aWV3cG9ydFxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB2aWV3cG9ydFRyYW5zZm9ybTogWzEsIDAsIDAsIDEsIDAsIDBdLFxuXG4gICAgLyoqXG4gICAgICogaWYgc2V0IHRvIGZhbHNlIGJhY2tncm91bmQgaW1hZ2UgaXMgbm90IGFmZmVjdGVkIGJ5IHZpZXdwb3J0IHRyYW5zZm9ybVxuICAgICAqIEBzaW5jZSAxLjYuM1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJhY2tncm91bmRWcHQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBpZiBzZXQgdG8gZmFsc2Ugb3Zlcmx5YSBpbWFnZSBpcyBub3QgYWZmZWN0ZWQgYnkgdmlld3BvcnQgdHJhbnNmb3JtXG4gICAgICogQHNpbmNlIDEuNi4zXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3ZlcmxheVZwdDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrOyBpbnZva2VkIHJpZ2h0IGJlZm9yZSBvYmplY3QgaXMgYWJvdXQgdG8gYmUgc2NhbGVkL3JvdGF0ZWRcbiAgICAgKi9cbiAgICBvbkJlZm9yZVNjYWxlUm90YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvKiBOT09QICovXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgY2FudmFzIGlzIHNjYWxlZCBieSBkZXZpY2VQaXhlbFJhdGlvIGZvciBiZXR0ZXIgcmVuZGVyaW5nIG9uIHJldGluYSBzY3JlZW5zXG4gICAgICovXG4gICAgZW5hYmxlUmV0aW5hU2NhbGluZzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IFN0cmluZ30gZWwgJmx0O2NhbnZhcz4gZWxlbWVudCB0byBpbml0aWFsaXplIGluc3RhbmNlIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIF9pbml0U3RhdGljOiBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xuICAgICAgdmFyIGNiID0gZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUucmVuZGVyQWxsLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vYmplY3RzID0gW107XG4gICAgICB0aGlzLl9jcmVhdGVMb3dlckNhbnZhcyhlbCk7XG4gICAgICB0aGlzLl9pbml0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHRoaXMuX3NldEltYWdlU21vb3RoaW5nKCk7XG4gICAgICAvLyBvbmx5IGluaXRpYWxpemUgcmV0aW5hIHNjYWxpbmcgb25jZVxuICAgICAgaWYgKCF0aGlzLmludGVyYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuX2luaXRSZXRpbmFTY2FsaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLm92ZXJsYXlJbWFnZSkge1xuICAgICAgICB0aGlzLnNldE92ZXJsYXlJbWFnZShvcHRpb25zLm92ZXJsYXlJbWFnZSwgY2IpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuYmFja2dyb3VuZEltYWdlKSB7XG4gICAgICAgIHRoaXMuc2V0QmFja2dyb3VuZEltYWdlKG9wdGlvbnMuYmFja2dyb3VuZEltYWdlLCBjYik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgdGhpcy5zZXRCYWNrZ3JvdW5kQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsIGNiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLm92ZXJsYXlDb2xvcikge1xuICAgICAgICB0aGlzLnNldE92ZXJsYXlDb2xvcihvcHRpb25zLm92ZXJsYXlDb2xvciwgY2IpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWxjT2Zmc2V0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzUmV0aW5hU2NhbGluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvICE9PSAxICYmIHRoaXMuZW5hYmxlUmV0aW5hU2NhbGluZyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSByZXRpbmFTY2FsaW5nIGlmIGFwcGxpZWQsIG90aGVyd2lzZSAxO1xuICAgICAqL1xuICAgIGdldFJldGluYVNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzUmV0aW5hU2NhbGluZygpID8gZmFicmljLmRldmljZVBpeGVsUmF0aW8gOiAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0UmV0aW5hU2NhbGluZzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuX2lzUmV0aW5hU2NhbGluZygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG93ZXJDYW52YXNFbC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy53aWR0aCAqIGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAgIHRoaXMubG93ZXJDYW52YXNFbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuaGVpZ2h0ICogZmFicmljLmRldmljZVBpeGVsUmF0aW8pO1xuXG4gICAgICB0aGlzLmNvbnRleHRDb250YWluZXIuc2NhbGUoZmFicmljLmRldmljZVBpeGVsUmF0aW8sIGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBjYW52YXMgZWxlbWVudCBvZmZzZXQgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50XG4gICAgICogVGhpcyBtZXRob2QgaXMgYWxzbyBhdHRhY2hlZCBhcyBcInJlc2l6ZVwiIGV2ZW50IGhhbmRsZXIgb2Ygd2luZG93XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2FsY09mZnNldDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fb2Zmc2V0ID0gZ2V0RWxlbWVudE9mZnNldCh0aGlzLmxvd2VyQ2FudmFzRWwpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjb3ZlcmxheUltYWdlfG92ZXJsYXkgaW1hZ2V9IGZvciB0aGlzIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7KGZhYnJpYy5JbWFnZXxTdHJpbmcpfSBpbWFnZSBmYWJyaWMuSW1hZ2UgaW5zdGFuY2Ugb3IgVVJMIG9mIGFuIGltYWdlIHRvIHNldCBvdmVybGF5IHRvXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gaW1hZ2UgaXMgbG9hZGVkIGFuZCBzZXQgYXMgYW4gb3ZlcmxheVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uYWwgb3B0aW9ucyB0byBzZXQgZm9yIHRoZSB7QGxpbmsgZmFicmljLkltYWdlfG92ZXJsYXkgaW1hZ2V9LlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9NbnpIVC98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Ob3JtYWwgb3ZlcmxheUltYWdlIHdpdGggbGVmdC90b3AgPSAwPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRPdmVybGF5SW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2phaWxfY2VsbF9iYXJzLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICAvLyBOZWVkZWQgdG8gcG9zaXRpb24gb3ZlcmxheUltYWdlIGF0IDAvMFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCdcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5vdmVybGF5SW1hZ2Ugd2l0aCBkaWZmZXJlbnQgcHJvcGVydGllczwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9qYWlsX2NlbGxfYmFycy5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgb3BhY2l0eTogMC41LFxuICAgICAqICAgYW5nbGU6IDQ1LFxuICAgICAqICAgbGVmdDogNDAwLFxuICAgICAqICAgdG9wOiA0MDAsXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlN0cmV0Y2hlZCBvdmVybGF5SW1hZ2UgIzEgLSB3aWR0aC9oZWlnaHQgY29ycmVzcG9uZCB0byBjYW52YXMgd2lkdGgvaGVpZ2h0PC9jYXB0aW9uPlxuICAgICAqIGZhYnJpYy5JbWFnZS5mcm9tVVJMKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9qYWlsX2NlbGxfYmFycy5wbmcnLCBmdW5jdGlvbihpbWcpIHtcbiAgICAgKiAgICBpbWcuc2V0KHt3aWR0aDogY2FudmFzLndpZHRoLCBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsIG9yaWdpblg6ICdsZWZ0Jywgb3JpZ2luWTogJ3RvcCd9KTtcbiAgICAgKiAgICBjYW52YXMuc2V0T3ZlcmxheUltYWdlKGltZywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlN0cmV0Y2hlZCBvdmVybGF5SW1hZ2UgIzIgLSB3aWR0aC9oZWlnaHQgY29ycmVzcG9uZCB0byBjYW52YXMgd2lkdGgvaGVpZ2h0PC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRPdmVybGF5SW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2phaWxfY2VsbF9iYXJzLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAqICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LFxuICAgICAqICAgLy8gTmVlZGVkIHRvIHBvc2l0aW9uIG92ZXJsYXlJbWFnZSBhdCAwLzBcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+b3ZlcmxheUltYWdlIGxvYWRlZCBmcm9tIGNyb3NzLW9yaWdpbjwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9qYWlsX2NlbGxfYmFycy5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgb3BhY2l0eTogMC41LFxuICAgICAqICAgYW5nbGU6IDQ1LFxuICAgICAqICAgbGVmdDogNDAwLFxuICAgICAqICAgdG9wOiA0MDAsXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJyxcbiAgICAgKiAgIGNyb3NzT3JpZ2luOiAnYW5vbnltb3VzJ1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHNldE92ZXJsYXlJbWFnZTogZnVuY3Rpb24gKGltYWdlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuX19zZXRCZ092ZXJsYXlJbWFnZSgnb3ZlcmxheUltYWdlJywgaW1hZ2UsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNiYWNrZ3JvdW5kSW1hZ2V8YmFja2dyb3VuZCBpbWFnZX0gZm9yIHRoaXMgY2FudmFzXG4gICAgICogQHBhcmFtIHsoZmFicmljLkltYWdlfFN0cmluZyl9IGltYWdlIGZhYnJpYy5JbWFnZSBpbnN0YW5jZSBvciBVUkwgb2YgYW4gaW1hZ2UgdG8gc2V0IGJhY2tncm91bmQgdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBpbWFnZSBpcyBsb2FkZWQgYW5kIHNldCBhcyBiYWNrZ3JvdW5kXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25hbCBvcHRpb25zIHRvIHNldCBmb3IgdGhlIHtAbGluayBmYWJyaWMuSW1hZ2V8YmFja2dyb3VuZCBpbWFnZX0uXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL1lIOXlEL3xqc0ZpZGRsZSBkZW1vfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk5vcm1hbCBiYWNrZ3JvdW5kSW1hZ2Ugd2l0aCBsZWZ0L3RvcCA9IDA8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvaG9uZXlfaW1fc3VidGxlLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICAvLyBOZWVkZWQgdG8gcG9zaXRpb24gYmFja2dyb3VuZEltYWdlIGF0IDAvMFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCdcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5iYWNrZ3JvdW5kSW1hZ2Ugd2l0aCBkaWZmZXJlbnQgcHJvcGVydGllczwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0QmFja2dyb3VuZEltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9ob25leV9pbV9zdWJ0bGUucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIG9wYWNpdHk6IDAuNSxcbiAgICAgKiAgIGFuZ2xlOiA0NSxcbiAgICAgKiAgIGxlZnQ6IDQwMCxcbiAgICAgKiAgIHRvcDogNDAwLFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCdcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdHJldGNoZWQgYmFja2dyb3VuZEltYWdlICMxIC0gd2lkdGgvaGVpZ2h0IGNvcnJlc3BvbmQgdG8gY2FudmFzIHdpZHRoL2hlaWdodDwvY2FwdGlvbj5cbiAgICAgKiBmYWJyaWMuSW1hZ2UuZnJvbVVSTCgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvaG9uZXlfaW1fc3VidGxlLnBuZycsIGZ1bmN0aW9uKGltZykge1xuICAgICAqICAgIGltZy5zZXQoe3dpZHRoOiBjYW52YXMud2lkdGgsIGhlaWdodDogY2FudmFzLmhlaWdodCwgb3JpZ2luWDogJ2xlZnQnLCBvcmlnaW5ZOiAndG9wJ30pO1xuICAgICAqICAgIGNhbnZhcy5zZXRCYWNrZ3JvdW5kSW1hZ2UoaW1nLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U3RyZXRjaGVkIGJhY2tncm91bmRJbWFnZSAjMiAtIHdpZHRoL2hlaWdodCBjb3JyZXNwb25kIHRvIGNhbnZhcyB3aWR0aC9oZWlnaHQ8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvaG9uZXlfaW1fc3VidGxlLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAqICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LFxuICAgICAqICAgLy8gTmVlZGVkIHRvIHBvc2l0aW9uIGJhY2tncm91bmRJbWFnZSBhdCAwLzBcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+YmFja2dyb3VuZEltYWdlIGxvYWRlZCBmcm9tIGNyb3NzLW9yaWdpbjwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0QmFja2dyb3VuZEltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9ob25leV9pbV9zdWJ0bGUucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIG9wYWNpdHk6IDAuNSxcbiAgICAgKiAgIGFuZ2xlOiA0NSxcbiAgICAgKiAgIGxlZnQ6IDQwMCxcbiAgICAgKiAgIHRvcDogNDAwLFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCcsXG4gICAgICogICBjcm9zc09yaWdpbjogJ2Fub255bW91cydcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBzZXRCYWNrZ3JvdW5kSW1hZ2U6IGZ1bmN0aW9uIChpbWFnZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc2V0QmdPdmVybGF5SW1hZ2UoJ2JhY2tncm91bmRJbWFnZScsIGltYWdlLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjb3ZlcmxheUNvbG9yfGJhY2tncm91bmQgY29sb3J9IGZvciB0aGlzIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7KFN0cmluZ3xmYWJyaWMuUGF0dGVybil9IG92ZXJsYXlDb2xvciBDb2xvciBvciBwYXR0ZXJuIHRvIHNldCBiYWNrZ3JvdW5kIGNvbG9yIHRvXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYmFja2dyb3VuZCBjb2xvciBpcyBzZXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvcEI1NWgvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Tm9ybWFsIG92ZXJsYXlDb2xvciAtIGNvbG9yIHZhbHVlPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRPdmVybGF5Q29sb3IoJ3JnYmEoMjU1LCA3MywgNjQsIDAuNiknLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+ZmFicmljLlBhdHRlcm4gdXNlZCBhcyBvdmVybGF5Q29sb3I8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlDb2xvcih7XG4gICAgICogICBzb3VyY2U6ICdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9lc2NoZXJlc3F1ZV9zdGUucG5nJ1xuICAgICAqIH0sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5mYWJyaWMuUGF0dGVybiB1c2VkIGFzIG92ZXJsYXlDb2xvciB3aXRoIHJlcGVhdCBhbmQgb2Zmc2V0PC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRPdmVybGF5Q29sb3Ioe1xuICAgICAqICAgc291cmNlOiAnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvZXNjaGVyZXNxdWVfc3RlLnBuZycsXG4gICAgICogICByZXBlYXQ6ICdyZXBlYXQnLFxuICAgICAqICAgb2Zmc2V0WDogMjAwLFxuICAgICAqICAgb2Zmc2V0WTogMTAwXG4gICAgICogfSwgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqL1xuICAgIHNldE92ZXJsYXlDb2xvcjogZnVuY3Rpb24ob3ZlcmxheUNvbG9yLCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMuX19zZXRCZ092ZXJsYXlDb2xvcignb3ZlcmxheUNvbG9yJywgb3ZlcmxheUNvbG9yLCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjYmFja2dyb3VuZENvbG9yfGJhY2tncm91bmQgY29sb3J9IGZvciB0aGlzIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7KFN0cmluZ3xmYWJyaWMuUGF0dGVybil9IGJhY2tncm91bmRDb2xvciBDb2xvciBvciBwYXR0ZXJuIHRvIHNldCBiYWNrZ3JvdW5kIGNvbG9yIHRvXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYmFja2dyb3VuZCBjb2xvciBpcyBzZXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvaFh6dmsvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Tm9ybWFsIGJhY2tncm91bmRDb2xvciAtIGNvbG9yIHZhbHVlPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kQ29sb3IoJ3JnYmEoMjU1LCA3MywgNjQsIDAuNiknLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+ZmFicmljLlBhdHRlcm4gdXNlZCBhcyBiYWNrZ3JvdW5kQ29sb3I8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRDb2xvcih7XG4gICAgICogICBzb3VyY2U6ICdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9lc2NoZXJlc3F1ZV9zdGUucG5nJ1xuICAgICAqIH0sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5mYWJyaWMuUGF0dGVybiB1c2VkIGFzIGJhY2tncm91bmRDb2xvciB3aXRoIHJlcGVhdCBhbmQgb2Zmc2V0PC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kQ29sb3Ioe1xuICAgICAqICAgc291cmNlOiAnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvZXNjaGVyZXNxdWVfc3RlLnBuZycsXG4gICAgICogICByZXBlYXQ6ICdyZXBlYXQnLFxuICAgICAqICAgb2Zmc2V0WDogMjAwLFxuICAgICAqICAgb2Zmc2V0WTogMTAwXG4gICAgICogfSwgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqL1xuICAgIHNldEJhY2tncm91bmRDb2xvcjogZnVuY3Rpb24oYmFja2dyb3VuZENvbG9yLCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMuX19zZXRCZ092ZXJsYXlDb2xvcignYmFja2dyb3VuZENvbG9yJywgYmFja2dyb3VuZENvbG9yLCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjZG9tLWNvbnRleHQtMmQtaW1hZ2VzbW9vdGhpbmdlbmFibGVkfFdoYXRXRyBDYW52YXMgU3RhbmRhcmR9XG4gICAgICovXG4gICAgX3NldEltYWdlU21vb3RoaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmdldENvbnRleHQoKTtcblxuICAgICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgfHwgY3R4LndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZFxuICAgICAgICB8fCBjdHgubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IGN0eC5tc0ltYWdlU21vb3RoaW5nRW5hYmxlZCB8fCBjdHgub0ltYWdlU21vb3RoaW5nRW5hYmxlZDtcbiAgICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSB0aGlzLmltYWdlU21vb3RoaW5nRW5hYmxlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdG8gc2V0ICh7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNiYWNrZ3JvdW5kSW1hZ2V8YmFja2dyb3VuZEltYWdlfVxuICAgICAqIG9yIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI292ZXJsYXlJbWFnZXxvdmVybGF5SW1hZ2V9KVxuICAgICAqIEBwYXJhbSB7KGZhYnJpYy5JbWFnZXxTdHJpbmd8bnVsbCl9IGltYWdlIGZhYnJpYy5JbWFnZSBpbnN0YW5jZSwgVVJMIG9mIGFuIGltYWdlIG9yIG51bGwgdG8gc2V0IGJhY2tncm91bmQgb3Igb3ZlcmxheSB0b1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGltYWdlIGlzIGxvYWRlZCBhbmQgc2V0IGFzIGJhY2tncm91bmQgb3Igb3ZlcmxheVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uYWwgb3B0aW9ucyB0byBzZXQgZm9yIHRoZSB7QGxpbmsgZmFicmljLkltYWdlfGltYWdlfS5cbiAgICAgKi9cbiAgICBfX3NldEJnT3ZlcmxheUltYWdlOiBmdW5jdGlvbihwcm9wZXJ0eSwgaW1hZ2UsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIGltYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICBmYWJyaWMudXRpbC5sb2FkSW1hZ2UoaW1hZ2UsIGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgIGltZyAmJiAodGhpc1twcm9wZXJ0eV0gPSBuZXcgZmFicmljLkltYWdlKGltZywgb3B0aW9ucykpO1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGltZyk7XG4gICAgICAgIH0sIHRoaXMsIG9wdGlvbnMgJiYgb3B0aW9ucy5jcm9zc09yaWdpbik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyAmJiBpbWFnZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IGltYWdlO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhpbWFnZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBzZXQgKHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI2JhY2tncm91bmRDb2xvcnxiYWNrZ3JvdW5kQ29sb3J9XG4gICAgICogb3Ige0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjb3ZlcmxheUNvbG9yfG92ZXJsYXlDb2xvcn0pXG4gICAgICogQHBhcmFtIHsoT2JqZWN0fFN0cmluZ3xudWxsKX0gY29sb3IgT2JqZWN0IHdpdGggcGF0dGVybiBpbmZvcm1hdGlvbiwgY29sb3IgdmFsdWUgb3IgbnVsbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgaXMgaW52b2tlZCB3aGVuIGNvbG9yIGlzIHNldFxuICAgICAqL1xuICAgIF9fc2V0QmdPdmVybGF5Q29sb3I6IGZ1bmN0aW9uKHByb3BlcnR5LCBjb2xvciwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXNbcHJvcGVydHldID0gY29sb3I7XG4gICAgICB0aGlzLl9pbml0R3JhZGllbnQoY29sb3IsIHByb3BlcnR5KTtcbiAgICAgIHRoaXMuX2luaXRQYXR0ZXJuKGNvbG9yLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZUNhbnZhc0VsZW1lbnQ6IGZ1bmN0aW9uKGNhbnZhc0VsKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoY2FudmFzRWwpO1xuICAgICAgaWYgKCFlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUgPSB7IH07XG4gICAgICB9XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgdGhyb3cgQ0FOVkFTX0lOSVRfRVJST1I7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQuZ2V0Q29udGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgQ0FOVkFTX0lOSVRfRVJST1I7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgX2luaXRPcHRpb25zOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdGhpcy5fc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgICAgdGhpcy53aWR0aCA9IHRoaXMud2lkdGggfHwgcGFyc2VJbnQodGhpcy5sb3dlckNhbnZhc0VsLndpZHRoLCAxMCkgfHwgMDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgfHwgcGFyc2VJbnQodGhpcy5sb3dlckNhbnZhc0VsLmhlaWdodCwgMTApIHx8IDA7XG5cbiAgICAgIGlmICghdGhpcy5sb3dlckNhbnZhc0VsLnN0eWxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb3dlckNhbnZhc0VsLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgIHRoaXMubG93ZXJDYW52YXNFbC5oZWlnaHQgPSB0aGlzLmhlaWdodDtcblxuICAgICAgdGhpcy5sb3dlckNhbnZhc0VsLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArICdweCc7XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyAncHgnO1xuXG4gICAgICB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybS5zbGljZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYm90dG9tIGNhbnZhc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2NhbnZhc0VsXVxuICAgICAqL1xuICAgIF9jcmVhdGVMb3dlckNhbnZhczogZnVuY3Rpb24gKGNhbnZhc0VsKSB7XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwgPSBmYWJyaWMudXRpbC5nZXRCeUlkKGNhbnZhc0VsKSB8fCB0aGlzLl9jcmVhdGVDYW52YXNFbGVtZW50KGNhbnZhc0VsKTtcblxuICAgICAgZmFicmljLnV0aWwuYWRkQ2xhc3ModGhpcy5sb3dlckNhbnZhc0VsLCAnbG93ZXItY2FudmFzJyk7XG5cbiAgICAgIGlmICh0aGlzLmludGVyYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuX2FwcGx5Q2FudmFzU3R5bGUodGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250ZXh0Q29udGFpbmVyID0gdGhpcy5sb3dlckNhbnZhc0VsLmdldENvbnRleHQoJzJkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY2FudmFzIHdpZHRoIChpbiBweClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNhbnZhcyBoZWlnaHQgKGluIHB4KVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB3aWR0aCBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWUgICAgICAgICAgICAgICAgICAgICAgICAgVmFsdWUgdG8gc2V0IHdpZHRoIHRvXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICBbb3B0aW9uc10gICAgICAgICAgICAgICAgICAgICBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuYmFja3N0b3JlT25seT1mYWxzZV0gU2V0IHRoZSBnaXZlbiBkaW1lbnNpb25zIG9ubHkgYXMgY2FudmFzIGJhY2tzdG9yZSBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5jc3NPbmx5PWZhbHNlXSAgICAgICBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjc3MgZGltZW5zaW9uc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgc2V0V2lkdGg6IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0RGltZW5zaW9ucyh7IHdpZHRoOiB2YWx1ZSB9LCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBoZWlnaHQgb2YgdGhpcyBjYW52YXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHZhbHVlICAgICAgICAgICAgICAgICAgICAgICAgIFZhbHVlIHRvIHNldCBoZWlnaHQgdG9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIFtvcHRpb25zXSAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5iYWNrc3RvcmVPbmx5PWZhbHNlXSBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjYW52YXMgYmFja3N0b3JlIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgIFtvcHRpb25zLmNzc09ubHk9ZmFsc2VdICAgICAgIFNldCB0aGUgZ2l2ZW4gZGltZW5zaW9ucyBvbmx5IGFzIGNzcyBkaW1lbnNpb25zXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0RGltZW5zaW9ucyh7IGhlaWdodDogdmFsdWUgfSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgZGltZW5zaW9ucyAod2lkdGgsIGhlaWdodCkgb2YgdGhpcyBjYW52YXMgaW5zdGFuY2UuIHdoZW4gb3B0aW9ucy5jc3NPbmx5IGZsYWcgYWN0aXZlIHlvdSBzaG91bGQgYWxzbyBzdXBwbHkgdGhlIHVuaXQgb2YgbWVhc3VyZSAocHgvJS9lbSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIGRpbWVuc2lvbnMgICAgICAgICAgICAgICAgICAgIE9iamVjdCB3aXRoIHdpZHRoL2hlaWdodCBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbZGltZW5zaW9ucy53aWR0aF0gICAgICAgICAgICBXaWR0aCBvZiBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW2RpbWVuc2lvbnMuaGVpZ2h0XSAgICAgICAgICAgSGVpZ2h0IG9mIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICBbb3B0aW9uc10gICAgICAgICAgICAgICAgICAgICBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuYmFja3N0b3JlT25seT1mYWxzZV0gU2V0IHRoZSBnaXZlbiBkaW1lbnNpb25zIG9ubHkgYXMgY2FudmFzIGJhY2tzdG9yZSBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5jc3NPbmx5PWZhbHNlXSAgICAgICBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjc3MgZGltZW5zaW9uc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0RGltZW5zaW9uczogZnVuY3Rpb24gKGRpbWVuc2lvbnMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjc3NWYWx1ZTtcblxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gZGltZW5zaW9ucykge1xuICAgICAgICBjc3NWYWx1ZSA9IGRpbWVuc2lvbnNbcHJvcF07XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmNzc09ubHkpIHtcbiAgICAgICAgICB0aGlzLl9zZXRCYWNrc3RvcmVEaW1lbnNpb24ocHJvcCwgZGltZW5zaW9uc1twcm9wXSk7XG4gICAgICAgICAgY3NzVmFsdWUgKz0gJ3B4JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy5iYWNrc3RvcmVPbmx5KSB7XG4gICAgICAgICAgdGhpcy5fc2V0Q3NzRGltZW5zaW9uKHByb3AsIGNzc1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5faW5pdFJldGluYVNjYWxpbmcoKTtcbiAgICAgIHRoaXMuX3NldEltYWdlU21vb3RoaW5nKCk7XG4gICAgICB0aGlzLmNhbGNPZmZzZXQoKTtcblxuICAgICAgaWYgKCFvcHRpb25zLmNzc09ubHkpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJBbGwoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmb3Igc2V0dGluZyB3aWR0aC9oZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIHByb3BlcnR5ICh3aWR0aHxoZWlnaHQpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIHZhbHVlIHRvIHNldCBwcm9wZXJ0eSB0b1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgX3NldEJhY2tzdG9yZURpbWVuc2lvbjogZnVuY3Rpb24gKHByb3AsIHZhbHVlKSB7XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWxbcHJvcF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHRoaXMudXBwZXJDYW52YXNFbCkge1xuICAgICAgICB0aGlzLnVwcGVyQ2FudmFzRWxbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2FjaGVDYW52YXNFbCkge1xuICAgICAgICB0aGlzLmNhY2hlQ2FudmFzRWxbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpc1twcm9wXSA9IHZhbHVlO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZvciBzZXR0aW5nIGNzcyB3aWR0aC9oZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIHByb3BlcnR5ICh3aWR0aHxoZWlnaHQpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIHZhbHVlIHRvIHNldCBwcm9wZXJ0eSB0b1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgX3NldENzc0RpbWVuc2lvbjogZnVuY3Rpb24gKHByb3AsIHZhbHVlKSB7XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHRoaXMudXBwZXJDYW52YXNFbCkge1xuICAgICAgICB0aGlzLnVwcGVyQ2FudmFzRWwuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMud3JhcHBlckVsKSB7XG4gICAgICAgIHRoaXMud3JhcHBlckVsLnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNhbnZhcyB6b29tIGxldmVsXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFpvb206IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtWzBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHZpZXdwb3J0IHRyYW5zZm9ybSBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZwdCB0aGUgdHJhbnNmb3JtIGluIHRoZSBmb3JtIG9mIGNvbnRleHQudHJhbnNmb3JtXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBzZXRWaWV3cG9ydFRyYW5zZm9ybTogZnVuY3Rpb24gKHZwdCkge1xuICAgICAgdmFyIGFjdGl2ZUdyb3VwID0gdGhpcy5fYWN0aXZlR3JvdXAsIG9iamVjdCwgaW5nb3JlVnB0ID0gZmFsc2UsIHNraXBBYnNvbHV0ZSA9IHRydWU7XG4gICAgICB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtID0gdnB0O1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5fb2JqZWN0c1tpXTtcbiAgICAgICAgb2JqZWN0Lmdyb3VwIHx8IG9iamVjdC5zZXRDb29yZHMoaW5nb3JlVnB0LCBza2lwQWJzb2x1dGUpO1xuICAgICAgfVxuICAgICAgaWYgKGFjdGl2ZUdyb3VwKSB7XG4gICAgICAgIGFjdGl2ZUdyb3VwLnNldENvb3JkcyhpbmdvcmVWcHQsIHNraXBBYnNvbHV0ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgem9vbSBsZXZlbCBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZSwgem9vbSBjZW50ZXJlZCBhcm91bmQgcG9pbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgdG8gem9vbSB3aXRoIHJlc3BlY3QgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgdG8gc2V0IHpvb20gdG8sIGxlc3MgdGhhbiAxIHpvb21zIG91dFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgem9vbVRvUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCwgdmFsdWUpIHtcbiAgICAgIC8vIFRPRE86IGp1c3QgY2hhbmdlIHRoZSBzY2FsZSwgcHJlc2VydmUgb3RoZXIgdHJhbnNmb3JtYXRpb25zXG4gICAgICB2YXIgYmVmb3JlID0gcG9pbnQsIHZwdCA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0uc2xpY2UoMCk7XG4gICAgICBwb2ludCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHBvaW50LCBmYWJyaWMudXRpbC5pbnZlcnRUcmFuc2Zvcm0odGhpcy52aWV3cG9ydFRyYW5zZm9ybSkpO1xuICAgICAgdnB0WzBdID0gdmFsdWU7XG4gICAgICB2cHRbM10gPSB2YWx1ZTtcbiAgICAgIHZhciBhZnRlciA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHBvaW50LCB2cHQpO1xuICAgICAgdnB0WzRdICs9IGJlZm9yZS54IC0gYWZ0ZXIueDtcbiAgICAgIHZwdFs1XSArPSBiZWZvcmUueSAtIGFmdGVyLnk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRWaWV3cG9ydFRyYW5zZm9ybSh2cHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHpvb20gbGV2ZWwgb2YgdGhpcyBjYW52YXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgdG8gc2V0IHpvb20gdG8sIGxlc3MgdGhhbiAxIHpvb21zIG91dFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgc2V0Wm9vbTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB0aGlzLnpvb21Ub1BvaW50KG5ldyBmYWJyaWMuUG9pbnQoMCwgMCksIHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYW4gdmlld3BvcnQgc28gYXMgdG8gcGxhY2UgcG9pbnQgYXQgdG9wIGxlZnQgY29ybmVyIG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCB0byBtb3ZlIHRvXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBhYnNvbHV0ZVBhbjogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICB2YXIgdnB0ID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybS5zbGljZSgwKTtcbiAgICAgIHZwdFs0XSA9IC1wb2ludC54O1xuICAgICAgdnB0WzVdID0gLXBvaW50Lnk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRWaWV3cG9ydFRyYW5zZm9ybSh2cHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYW5zIHZpZXdwb2ludCByZWxhdGl2ZWx5XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IChwb3NpdGlvbiB2ZWN0b3IpIHRvIG1vdmUgYnlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIHJlbGF0aXZlUGFuOiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFic29sdXRlUGFuKG5ldyBmYWJyaWMuUG9pbnQoXG4gICAgICAgIC1wb2ludC54IC0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybVs0XSxcbiAgICAgICAgLXBvaW50LnkgLSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtWzVdXG4gICAgICApKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyAmbHQ7Y2FudmFzPiBlbGVtZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvd2VyQ2FudmFzRWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgd2FzIGFkZGVkXG4gICAgICovXG4gICAgX29uT2JqZWN0QWRkZWQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgdGhpcy5zdGF0ZWZ1bCAmJiBvYmouc2V0dXBTdGF0ZSgpO1xuICAgICAgb2JqLl9zZXQoJ2NhbnZhcycsIHRoaXMpO1xuICAgICAgb2JqLnNldENvb3JkcygpO1xuICAgICAgdGhpcy5maXJlKCdvYmplY3Q6YWRkZWQnLCB7IHRhcmdldDogb2JqIH0pO1xuICAgICAgb2JqLmZpcmUoJ2FkZGVkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgd2FzIHJlbW92ZWRcbiAgICAgKi9cbiAgICBfb25PYmplY3RSZW1vdmVkOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHRoaXMuZmlyZSgnb2JqZWN0OnJlbW92ZWQnLCB7IHRhcmdldDogb2JqIH0pO1xuICAgICAgb2JqLmZpcmUoJ3JlbW92ZWQnKTtcbiAgICAgIGRlbGV0ZSBvYmouY2FudmFzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgc3BlY2lmaWVkIGNvbnRleHQgb2YgY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gY2xlYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNsZWFyQ29udGV4dDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRleHQgb2YgY2FudmFzIHdoZXJlIG9iamVjdHMgYXJlIGRyYXduXG4gICAgICogQHJldHVybiB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIGdldENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHRDb250YWluZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgY29udGV4dHMgKGJhY2tncm91bmQsIG1haW4sIHRvcCkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vYmplY3RzLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLmJhY2tncm91bmRJbWFnZSA9IG51bGw7XG4gICAgICB0aGlzLm92ZXJsYXlJbWFnZSA9IG51bGw7XG4gICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9ICcnO1xuICAgICAgdGhpcy5vdmVybGF5Q29sb3IgPSAnJztcbiAgICAgIGlmICh0aGlzLl9oYXNJVGV4dEhhbmRsZXJzKSB7XG4gICAgICAgIHRoaXMub2ZmKCdzZWxlY3Rpb246Y2xlYXJlZCcsIHRoaXMuX2NhbnZhc0lUZXh0U2VsZWN0aW9uQ2xlYXJlZEhhbmxkZXIpO1xuICAgICAgICB0aGlzLm9mZignb2JqZWN0OnNlbGVjdGVkJywgdGhpcy5fY2FudmFzSVRleHRTZWxlY3Rpb25DbGVhcmVkSGFubGRlcik7XG4gICAgICAgIHRoaXMub2ZmKCdtb3VzZTp1cCcsIHRoaXMuX21vdXNlVXBJVGV4dEhhbmRsZXIpO1xuICAgICAgICB0aGlzLl9pVGV4dEluc3RhbmNlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2hhc0lUZXh0SGFuZGxlcnMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0KHRoaXMuY29udGV4dENvbnRhaW5lcik7XG4gICAgICB0aGlzLmZpcmUoJ2NhbnZhczpjbGVhcmVkJyk7XG4gICAgICB0aGlzLnJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYm90aCB0aGUgY2FudmFzLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlbmRlckFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNhbnZhc1RvRHJhd09uID0gdGhpcy5jb250ZXh0Q29udGFpbmVyO1xuICAgICAgdGhpcy5yZW5kZXJDYW52YXMoY2FudmFzVG9EcmF3T24sIHRoaXMuX29iamVjdHMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYmFja2dyb3VuZCwgb2JqZWN0cywgb3ZlcmxheSBhbmQgY29udHJvbHMuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9iamVjdHMgdG8gcmVuZGVyXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVuZGVyQ2FudmFzOiBmdW5jdGlvbihjdHgsIG9iamVjdHMpIHtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0KGN0eCk7XG4gICAgICB0aGlzLmZpcmUoJ2JlZm9yZTpyZW5kZXInKTtcbiAgICAgIGlmICh0aGlzLmNsaXBUbykge1xuICAgICAgICBmYWJyaWMudXRpbC5jbGlwQ29udGV4dCh0aGlzLCBjdHgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyQmFja2dyb3VuZChjdHgpO1xuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgLy9hcHBseSB2aWV3cG9ydCB0cmFuc2Zvcm0gb25jZSBmb3IgYWxsIHJlbmRlcmluZyBwcm9jZXNzXG4gICAgICBjdHgudHJhbnNmb3JtLmFwcGx5KGN0eCwgdGhpcy52aWV3cG9ydFRyYW5zZm9ybSk7XG4gICAgICB0aGlzLl9yZW5kZXJPYmplY3RzKGN0eCwgb2JqZWN0cyk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgaWYgKCF0aGlzLmNvbnRyb2xzQWJvdmVPdmVybGF5ICYmIHRoaXMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5kcmF3Q29udHJvbHMoY3R4KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNsaXBUbykge1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyT3ZlcmxheShjdHgpO1xuICAgICAgaWYgKHRoaXMuY29udHJvbHNBYm92ZU92ZXJsYXkgJiYgdGhpcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICB0aGlzLmRyYXdDb250cm9scyhjdHgpO1xuICAgICAgfVxuICAgICAgdGhpcy5maXJlKCdhZnRlcjpyZW5kZXInKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqZWN0cyB0byByZW5kZXJcbiAgICAgKi9cbiAgICBfcmVuZGVyT2JqZWN0czogZnVuY3Rpb24oY3R4LCBvYmplY3RzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBvYmplY3RzW2ldICYmIG9iamVjdHNbaV0ucmVuZGVyKGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAnYmFja2dyb3VuZCcgb3IgJ292ZXJsYXknXG4gICAgICovXG4gICAgX3JlbmRlckJhY2tncm91bmRPck92ZXJsYXk6IGZ1bmN0aW9uKGN0eCwgcHJvcGVydHkpIHtcbiAgICAgIHZhciBvYmplY3QgPSB0aGlzW3Byb3BlcnR5ICsgJ0NvbG9yJ107XG4gICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvYmplY3QudG9MaXZlXG4gICAgICAgICAgPyBvYmplY3QudG9MaXZlKGN0eCwgdGhpcylcbiAgICAgICAgICA6IG9iamVjdDtcblxuICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgb2JqZWN0Lm9mZnNldFggfHwgMCxcbiAgICAgICAgICBvYmplY3Qub2Zmc2V0WSB8fCAwLFxuICAgICAgICAgIHRoaXMud2lkdGgsXG4gICAgICAgICAgdGhpcy5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gdGhpc1twcm9wZXJ0eSArICdJbWFnZSddO1xuICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICBpZiAodGhpc1twcm9wZXJ0eSArICdWcHQnXSkge1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgY3R4LnRyYW5zZm9ybS5hcHBseShjdHgsIHRoaXMudmlld3BvcnRUcmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdC5yZW5kZXIoY3R4KTtcbiAgICAgICAgdGhpc1twcm9wZXJ0eSArICdWcHQnXSAmJiBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyQmFja2dyb3VuZDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLl9yZW5kZXJCYWNrZ3JvdW5kT3JPdmVybGF5KGN0eCwgJ2JhY2tncm91bmQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlck92ZXJsYXk6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5fcmVuZGVyQmFja2dyb3VuZE9yT3ZlcmxheShjdHgsICdvdmVybGF5Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29vcmRpbmF0ZXMgb2YgYSBjZW50ZXIgb2YgY2FudmFzLlxuICAgICAqIFJldHVybmVkIHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIHRvcCBhbmQgbGVmdCBwcm9wZXJ0aWVzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBcInRvcFwiIGFuZCBcImxlZnRcIiBudW1iZXIgdmFsdWVzXG4gICAgICovXG4gICAgZ2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHRoaXMuZ2V0SGVpZ2h0KCkgLyAyLFxuICAgICAgICBsZWZ0OiB0aGlzLmdldFdpZHRoKCkgLyAyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBob3Jpem9udGFsbHkgaW4gdGhlIGNhbnZhc1xuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciBob3Jpem9udGFsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICovXG4gICAgY2VudGVyT2JqZWN0SDogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIG5ldyBmYWJyaWMuUG9pbnQodGhpcy5nZXRDZW50ZXIoKS5sZWZ0LCBvYmplY3QuZ2V0Q2VudGVyUG9pbnQoKS55KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgaW4gdGhlIGNhbnZhc1xuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciB2ZXJ0aWNhbGx5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjZW50ZXJPYmplY3RWOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2VudGVyT2JqZWN0KG9iamVjdCwgbmV3IGZhYnJpYy5Qb2ludChvYmplY3QuZ2V0Q2VudGVyUG9pbnQoKS54LCB0aGlzLmdldENlbnRlcigpLnRvcCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHkgaW4gdGhlIGNhbnZhc1xuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNlbnRlck9iamVjdDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIG5ldyBmYWJyaWMuUG9pbnQoY2VudGVyLmxlZnQsIGNlbnRlci50b3ApKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5IGluIHRoZSB2aWV3cG9ydFxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVyT2JqZWN0OiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciB2cENlbnRlciA9IHRoaXMuZ2V0VnBDZW50ZXIoKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIHZwQ2VudGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgaG9yaXpvbnRhbGx5IGluIHRoZSB2aWV3cG9ydCwgb2JqZWN0LnRvcCBpcyB1bmNoYW5nZWRcbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXIgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB2aWV3cG9ydENlbnRlck9iamVjdEg6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHZwQ2VudGVyID0gdGhpcy5nZXRWcENlbnRlcigpO1xuICAgICAgdGhpcy5fY2VudGVyT2JqZWN0KG9iamVjdCwgbmV3IGZhYnJpYy5Qb2ludCh2cENlbnRlci54LCBvYmplY3QuZ2V0Q2VudGVyUG9pbnQoKS55KSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgVmVydGljYWxseSBpbiB0aGUgdmlld3BvcnQsIG9iamVjdC50b3AgaXMgdW5jaGFuZ2VkXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyIHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdmlld3BvcnRDZW50ZXJPYmplY3RWOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciB2cENlbnRlciA9IHRoaXMuZ2V0VnBDZW50ZXIoKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIG5ldyBmYWJyaWMuUG9pbnQob2JqZWN0LmdldENlbnRlclBvaW50KCkueCwgdnBDZW50ZXIueSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvaW50IGluIGNhbnZhcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIGNlbnRlciBvZiBhY3R1YWwgdmlld3BvcnQuXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB2cENlbnRlciwgdmlld3BvcnQgY2VudGVyXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGdldFZwQ2VudGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpLFxuICAgICAgICAgIGlWcHQgPSBmYWJyaWMudXRpbC5pbnZlcnRUcmFuc2Zvcm0odGhpcy52aWV3cG9ydFRyYW5zZm9ybSk7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQoeyB4OiBjZW50ZXIubGVmdCwgeTogY2VudGVyLnRvcCB9LCBpVnB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGNlbnRlciBDZW50ZXIgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIF9jZW50ZXJPYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCwgY2VudGVyKSB7XG4gICAgICBvYmplY3Quc2V0UG9zaXRpb25CeU9yaWdpbihjZW50ZXIsICdjZW50ZXInLCAnY2VudGVyJyk7XG4gICAgICB0aGlzLnJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVycyBkYXRhbGVzcyBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGpzb24gc3RyaW5nXG4gICAgICovXG4gICAgdG9EYXRhbGVzc0pTT046IGZ1bmN0aW9uIChwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0RhdGFsZXNzT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24gKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b09iamVjdE1ldGhvZCgndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBkYXRhbGVzcyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgY2FudmFzXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9EYXRhbGVzc09iamVjdDogZnVuY3Rpb24gKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b09iamVjdE1ldGhvZCgndG9EYXRhbGVzc09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90b09iamVjdE1ldGhvZDogZnVuY3Rpb24gKG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcblxuICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgIG9iamVjdHM6IHRoaXMuX3RvT2JqZWN0cyhtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKVxuICAgICAgfTtcblxuICAgICAgZXh0ZW5kKGRhdGEsIHRoaXMuX19zZXJpYWxpemVCZ092ZXJsYXkobWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSkpO1xuXG4gICAgICBmYWJyaWMudXRpbC5wb3B1bGF0ZVdpdGhQcm9wZXJ0aWVzKHRoaXMsIGRhdGEsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdG9PYmplY3RzOiBmdW5jdGlvbihtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RzKCkuZmlsdGVyKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gIW9iamVjdC5leGNsdWRlRnJvbUV4cG9ydDtcbiAgICAgIH0pLm1hcChmdW5jdGlvbihpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9PYmplY3QoaW5zdGFuY2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RvT2JqZWN0OiBmdW5jdGlvbihpbnN0YW5jZSwgbWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG9yaWdpbmFsVmFsdWU7XG5cbiAgICAgIGlmICghdGhpcy5pbmNsdWRlRGVmYXVsdFZhbHVlcykge1xuICAgICAgICBvcmlnaW5hbFZhbHVlID0gaW5zdGFuY2UuaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICAgIGluc3RhbmNlLmluY2x1ZGVEZWZhdWx0VmFsdWVzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBvYmplY3QgPSBpbnN0YW5jZVttZXRob2ROYW1lXShwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIGlmICghdGhpcy5pbmNsdWRlRGVmYXVsdFZhbHVlcykge1xuICAgICAgICBpbnN0YW5jZS5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IG9yaWdpbmFsVmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9fc2VyaWFsaXplQmdPdmVybGF5OiBmdW5jdGlvbihtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgZGF0YSA9IHsgfTtcblxuICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIGRhdGEuYmFja2dyb3VuZCA9IHRoaXMuYmFja2dyb3VuZENvbG9yLnRvT2JqZWN0XG4gICAgICAgICAgPyB0aGlzLmJhY2tncm91bmRDb2xvci50b09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKVxuICAgICAgICAgIDogdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm92ZXJsYXlDb2xvcikge1xuICAgICAgICBkYXRhLm92ZXJsYXkgPSB0aGlzLm92ZXJsYXlDb2xvci50b09iamVjdFxuICAgICAgICAgID8gdGhpcy5vdmVybGF5Q29sb3IudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSlcbiAgICAgICAgICA6IHRoaXMub3ZlcmxheUNvbG9yO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZEltYWdlKSB7XG4gICAgICAgIGRhdGEuYmFja2dyb3VuZEltYWdlID0gdGhpcy5fdG9PYmplY3QodGhpcy5iYWNrZ3JvdW5kSW1hZ2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3ZlcmxheUltYWdlKSB7XG4gICAgICAgIGRhdGEub3ZlcmxheUltYWdlID0gdGhpcy5fdG9PYmplY3QodGhpcy5vdmVybGF5SW1hZ2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIGdldFN2Z1RyYW5zZm9ybSgpIHdpbGwgYXBwbHkgdGhlIFN0YXRpY0NhbnZhcy52aWV3cG9ydFRyYW5zZm9ybSB0byB0aGUgU1ZHIHRyYW5zZm9ybWF0aW9uLiBXaGVuIHRydWUsXG4gICAgICogYSB6b29tZWQgY2FudmFzIHdpbGwgdGhlbiBwcm9kdWNlIHpvb21lZCBTVkcgb3V0cHV0LlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN2Z1ZpZXdwb3J0VHJhbnNmb3JtYXRpb246IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBjYW52YXNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0IGZvciBTVkcgb3V0cHV0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zdXBwcmVzc1ByZWFtYmxlPWZhbHNlXSBJZiB0cnVlIHhtbCB0YWcgaXMgbm90IGluY2x1ZGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnZpZXdCb3hdIFNWRyB2aWV3Ym94IG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52aWV3Qm94LnhdIHgtY29vcmlkbmF0ZSBvZiB2aWV3Ym94XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnZpZXdCb3gueV0geS1jb29yZGluYXRlIG9mIHZpZXdib3hcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmlld0JveC53aWR0aF0gV2lkdGggb2Ygdmlld2JveFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52aWV3Qm94LmhlaWdodF0gSGVpZ2h0IG9mIHZpZXdib3hcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9VVRGLThdIEVuY29kaW5nIG9mIFNWRyBvdXRwdXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMud2lkdGhdIGRlc2lyZWQgd2lkdGggb2Ygc3ZnIHdpdGggb3Igd2l0aG91dCB1bml0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5oZWlnaHRdIGRlc2lyZWQgaGVpZ2h0IG9mIHN2ZyB3aXRoIG9yIHdpdGhvdXQgdW5pdHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNvbnZlcnRlZCBpbnRvIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFNWRyBzdHJpbmdcbiAgICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMyNzZXJpYWxpemF0aW9ufVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvalEzWlovfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Tm9ybWFsIFNWRyBvdXRwdXQ8L2NhcHRpb24+XG4gICAgICogdmFyIHN2ZyA9IGNhbnZhcy50b1NWRygpO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlNWRyBvdXRwdXQgd2l0aG91dCBwcmVhbWJsZSAod2l0aG91dCAmbHQ7P3htbCAuLi8+KTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgc3ZnID0gY2FudmFzLnRvU1ZHKHtzdXBwcmVzc1ByZWFtYmxlOiB0cnVlfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U1ZHIG91dHB1dCB3aXRoIHZpZXdCb3ggYXR0cmlidXRlPC9jYXB0aW9uPlxuICAgICAqIHZhciBzdmcgPSBjYW52YXMudG9TVkcoe1xuICAgICAqICAgdmlld0JveDoge1xuICAgICAqICAgICB4OiAxMDAsXG4gICAgICogICAgIHk6IDEwMCxcbiAgICAgKiAgICAgd2lkdGg6IDIwMCxcbiAgICAgKiAgICAgaGVpZ2h0OiAzMDBcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TVkcgb3V0cHV0IHdpdGggZGlmZmVyZW50IGVuY29kaW5nIChkZWZhdWx0OiBVVEYtOCk8L2NhcHRpb24+XG4gICAgICogdmFyIHN2ZyA9IGNhbnZhcy50b1NWRyh7ZW5jb2Rpbmc6ICdJU08tODg1OS0xJ30pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk1vZGlmeSBTVkcgb3V0cHV0IHdpdGggcmV2aXZlciBmdW5jdGlvbjwvY2FwdGlvbj5cbiAgICAgKiB2YXIgc3ZnID0gY2FudmFzLnRvU1ZHKG51bGwsIGZ1bmN0aW9uKHN2Zykge1xuICAgICAqICAgcmV0dXJuIHN2Zy5yZXBsYWNlKCdzdHJva2UtZGFzaGFycmF5OiA7IHN0cm9rZS1saW5lY2FwOiBidXR0OyBzdHJva2UtbGluZWpvaW46IG1pdGVyOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7ICcsICcnKTtcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ob3B0aW9ucywgcmV2aXZlcikge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHZhciBtYXJrdXAgPSBbXTtcblxuICAgICAgdGhpcy5fc2V0U1ZHUHJlYW1ibGUobWFya3VwLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX3NldFNWR0hlYWRlcihtYXJrdXAsIG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLl9zZXRTVkdCZ092ZXJsYXlDb2xvcihtYXJrdXAsICdiYWNrZ3JvdW5kQ29sb3InKTtcbiAgICAgIHRoaXMuX3NldFNWR0JnT3ZlcmxheUltYWdlKG1hcmt1cCwgJ2JhY2tncm91bmRJbWFnZScsIHJldml2ZXIpO1xuXG4gICAgICB0aGlzLl9zZXRTVkdPYmplY3RzKG1hcmt1cCwgcmV2aXZlcik7XG5cbiAgICAgIHRoaXMuX3NldFNWR0JnT3ZlcmxheUNvbG9yKG1hcmt1cCwgJ292ZXJsYXlDb2xvcicpO1xuICAgICAgdGhpcy5fc2V0U1ZHQmdPdmVybGF5SW1hZ2UobWFya3VwLCAnb3ZlcmxheUltYWdlJywgcmV2aXZlcik7XG5cbiAgICAgIG1hcmt1cC5wdXNoKCc8L3N2Zz4nKTtcblxuICAgICAgcmV0dXJuIG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHUHJlYW1ibGU6IGZ1bmN0aW9uKG1hcmt1cCwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMuc3VwcHJlc3NQcmVhbWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIicsIChvcHRpb25zLmVuY29kaW5nIHx8ICdVVEYtOCcpLCAnXCIgc3RhbmRhbG9uZT1cIm5vXCIgPz5cXG4nLFxuICAgICAgICAgICc8IURPQ1RZUEUgc3ZnIFBVQkxJQyBcIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOXCIgJyxcbiAgICAgICAgICAgICdcImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZFwiPlxcbidcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR0hlYWRlcjogZnVuY3Rpb24obWFya3VwLCBvcHRpb25zKSB7XG4gICAgICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoIHx8IHRoaXMud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgfHwgdGhpcy5oZWlnaHQsXG4gICAgICAgICAgdnB0LCB2aWV3Qm94ID0gJ3ZpZXdCb3g9XCIwIDAgJyArIHRoaXMud2lkdGggKyAnICcgKyB0aGlzLmhlaWdodCArICdcIiAnLFxuICAgICAgICAgIE5VTV9GUkFDVElPTl9ESUdJVFMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFM7XG5cbiAgICAgIGlmIChvcHRpb25zLnZpZXdCb3gpIHtcbiAgICAgICAgdmlld0JveCA9ICd2aWV3Qm94PVwiJyArXG4gICAgICAgICAgICAgICAgb3B0aW9ucy52aWV3Qm94LnggKyAnICcgK1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudmlld0JveC55ICsgJyAnICtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnZpZXdCb3gud2lkdGggKyAnICcgK1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudmlld0JveC5oZWlnaHQgKyAnXCIgJztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5zdmdWaWV3cG9ydFRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICAgICAgdnB0ID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybTtcbiAgICAgICAgICB2aWV3Qm94ID0gJ3ZpZXdCb3g9XCInICtcbiAgICAgICAgICAgICAgICAgIHRvRml4ZWQoLXZwdFs0XSAvIHZwdFswXSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgdG9GaXhlZCgtdnB0WzVdIC8gdnB0WzNdLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICcgJyArXG4gICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMud2lkdGggLyB2cHRbMF0sIE5VTV9GUkFDVElPTl9ESUdJVFMpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5oZWlnaHQgLyB2cHRbM10sIE5VTV9GUkFDVElPTl9ESUdJVFMpICsgJ1wiICc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICc8c3ZnICcsXG4gICAgICAgICAgJ3htbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiAnLFxuICAgICAgICAgICd4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiAnLFxuICAgICAgICAgICd2ZXJzaW9uPVwiMS4xXCIgJyxcbiAgICAgICAgICAnd2lkdGg9XCInLCB3aWR0aCwgJ1wiICcsXG4gICAgICAgICAgJ2hlaWdodD1cIicsIGhlaWdodCwgJ1wiICcsXG4gICAgICAgICAgdmlld0JveCxcbiAgICAgICAgICAneG1sOnNwYWNlPVwicHJlc2VydmVcIj5cXG4nLFxuICAgICAgICAnPGRlc2M+Q3JlYXRlZCB3aXRoIEZhYnJpYy5qcyAnLCBmYWJyaWMudmVyc2lvbiwgJzwvZGVzYz5cXG4nLFxuICAgICAgICAnPGRlZnM+XFxuJyxcbiAgICAgICAgICB0aGlzLmNyZWF0ZVNWR0ZvbnRGYWNlc01hcmt1cCgpLFxuICAgICAgICAgIHRoaXMuY3JlYXRlU1ZHUmVmRWxlbWVudHNNYXJrdXAoKSxcbiAgICAgICAgJzwvZGVmcz5cXG4nXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG1hcmt1cCBjb250YWluaW5nIFNWRyByZWZlcmVuY2VkIGVsZW1lbnRzIGxpa2UgcGF0dGVybnMsIGdyYWRpZW50cyBldGMuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNyZWF0ZVNWR1JlZkVsZW1lbnRzTWFya3VwOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgbWFya3VwID0gWydiYWNrZ3JvdW5kQ29sb3InLCAnb3ZlcmxheUNvbG9yJ10ubWFwKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgICAgIHZhciBmaWxsID0gX3RoaXNbcHJvcF07XG4gICAgICAgICAgICBpZiAoZmlsbCAmJiBmaWxsLnRvTGl2ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmlsbC50b1NWRyhfdGhpcywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBtYXJrdXAgY29udGFpbmluZyBTVkcgZm9udCBmYWNlcyxcbiAgICAgKiBmb250IFVSTHMgZm9yIGZvbnQgZmFjZXMgbXVzdCBiZSBjb2xsZWN0ZWQgYnkgZGV2ZWxvcGVyc1xuICAgICAqIGFuZCBhcmUgbm90IGV4dHJhY3RlZCBmcm9tIHRoZSBET00gYnkgZmFicmljanNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzIEFycmF5IG9mIGZhYnJpYyBvYmplY3RzXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNyZWF0ZVNWR0ZvbnRGYWNlc01hcmt1cDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWFya3VwID0gJycsIGZvbnRMaXN0ID0geyB9LCBvYmosIGZvbnRGYW1pbHksXG4gICAgICAgICAgc3R5bGUsIHJvdywgcm93SW5kZXgsIF9jaGFyLCBjaGFySW5kZXgsXG4gICAgICAgICAgZm9udFBhdGhzID0gZmFicmljLmZvbnRQYXRocywgb2JqZWN0cyA9IHRoaXMuZ2V0T2JqZWN0cygpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBvYmogPSBvYmplY3RzW2ldO1xuICAgICAgICBmb250RmFtaWx5ID0gb2JqLmZvbnRGYW1pbHk7XG4gICAgICAgIGlmIChvYmoudHlwZS5pbmRleE9mKCd0ZXh0JykgPT09IC0xIHx8IGZvbnRMaXN0W2ZvbnRGYW1pbHldIHx8ICFmb250UGF0aHNbZm9udEZhbWlseV0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb250TGlzdFtmb250RmFtaWx5XSA9IHRydWU7XG4gICAgICAgIGlmICghb2JqLnN0eWxlcykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlID0gb2JqLnN0eWxlcztcbiAgICAgICAgZm9yIChyb3dJbmRleCBpbiBzdHlsZSkge1xuICAgICAgICAgIHJvdyA9IHN0eWxlW3Jvd0luZGV4XTtcbiAgICAgICAgICBmb3IgKGNoYXJJbmRleCBpbiByb3cpIHtcbiAgICAgICAgICAgIF9jaGFyID0gcm93W2NoYXJJbmRleF07XG4gICAgICAgICAgICBmb250RmFtaWx5ID0gX2NoYXIuZm9udEZhbWlseTtcbiAgICAgICAgICAgIGlmICghZm9udExpc3RbZm9udEZhbWlseV0gJiYgZm9udFBhdGhzW2ZvbnRGYW1pbHldKSB7XG4gICAgICAgICAgICAgIGZvbnRMaXN0W2ZvbnRGYW1pbHldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiBpbiBmb250TGlzdCkge1xuICAgICAgICBtYXJrdXAgKz0gW1xuICAgICAgICAgICdcXHRcXHRAZm9udC1mYWNlIHtcXG4nLFxuICAgICAgICAgICdcXHRcXHRcXHRmb250LWZhbWlseTogXFwnJywgaiwgJ1xcJztcXG4nLFxuICAgICAgICAgICdcXHRcXHRcXHRzcmM6IHVybChcXCcnLCBmb250UGF0aHNbal0sICdcXCcpO1xcbicsXG4gICAgICAgICAgJ1xcdFxcdH1cXG4nXG4gICAgICAgIF0uam9pbignJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXJrdXApIHtcbiAgICAgICAgbWFya3VwID0gW1xuICAgICAgICAgICdcXHQ8c3R5bGUgdHlwZT1cInRleHQvY3NzXCI+JyxcbiAgICAgICAgICAnPCFbQ0RBVEFbXFxuJyxcbiAgICAgICAgICBtYXJrdXAsXG4gICAgICAgICAgJ11dPicsXG4gICAgICAgICAgJzwvc3R5bGU+XFxuJ1xuICAgICAgICBdLmpvaW4oJycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFya3VwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdPYmplY3RzOiBmdW5jdGlvbihtYXJrdXAsIHJldml2ZXIpIHtcbiAgICAgIHZhciBpbnN0YW5jZTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBvYmplY3RzID0gdGhpcy5nZXRPYmplY3RzKCksIGxlbiA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaW5zdGFuY2UgPSBvYmplY3RzW2ldO1xuICAgICAgICBpZiAoaW5zdGFuY2UuZXhjbHVkZUZyb21FeHBvcnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRTVkdPYmplY3QobWFya3VwLCBpbnN0YW5jZSwgcmV2aXZlcik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHB1c2ggc2luZ2xlIG9iamVjdCBzdmcgcmVwcmVzZW50YXRpb24gaW4gdGhlIG1hcmt1cFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR09iamVjdDogZnVuY3Rpb24obWFya3VwLCBpbnN0YW5jZSwgcmV2aXZlcikge1xuICAgICAgbWFya3VwLnB1c2goaW5zdGFuY2UudG9TVkcocmV2aXZlcikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdCZ092ZXJsYXlJbWFnZTogZnVuY3Rpb24obWFya3VwLCBwcm9wZXJ0eSwgcmV2aXZlcikge1xuICAgICAgaWYgKHRoaXNbcHJvcGVydHldICYmIHRoaXNbcHJvcGVydHldLnRvU1ZHKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKHRoaXNbcHJvcGVydHldLnRvU1ZHKHJldml2ZXIpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHQmdPdmVybGF5Q29sb3I6IGZ1bmN0aW9uKG1hcmt1cCwgcHJvcGVydHkpIHtcbiAgICAgIHZhciBmaWxsZXIgPSB0aGlzW3Byb3BlcnR5XTtcbiAgICAgIGlmICghZmlsbGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxsZXIudG9MaXZlKSB7XG4gICAgICAgIHZhciByZXBlYXQgPSBmaWxsZXIucmVwZWF0O1xuICAgICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgICAnPHJlY3QgdHJhbnNmb3JtPVwidHJhbnNsYXRlKCcsIHRoaXMud2lkdGggLyAyLCAnLCcsIHRoaXMuaGVpZ2h0IC8gMiwgJylcIicsXG4gICAgICAgICAgICAnIHg9XCInLCBmaWxsZXIub2Zmc2V0WCAtIHRoaXMud2lkdGggLyAyLCAnXCIgeT1cIicsIGZpbGxlci5vZmZzZXRZIC0gdGhpcy5oZWlnaHQgLyAyLCAnXCIgJyxcbiAgICAgICAgICAgICd3aWR0aD1cIicsXG4gICAgICAgICAgICAgIChyZXBlYXQgPT09ICdyZXBlYXQteScgfHwgcmVwZWF0ID09PSAnbm8tcmVwZWF0J1xuICAgICAgICAgICAgICAgID8gZmlsbGVyLnNvdXJjZS53aWR0aFxuICAgICAgICAgICAgICAgIDogdGhpcy53aWR0aCksXG4gICAgICAgICAgICAnXCIgaGVpZ2h0PVwiJyxcbiAgICAgICAgICAgICAgKHJlcGVhdCA9PT0gJ3JlcGVhdC14JyB8fCByZXBlYXQgPT09ICduby1yZXBlYXQnXG4gICAgICAgICAgICAgICAgPyBmaWxsZXIuc291cmNlLmhlaWdodFxuICAgICAgICAgICAgICAgIDogdGhpcy5oZWlnaHQpLFxuICAgICAgICAgICAgJ1wiIGZpbGw9XCJ1cmwoI1NWR0lEXycgKyBmaWxsZXIuaWQgKyAnKVwiJyxcbiAgICAgICAgICAnPjwvcmVjdD5cXG4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICAgJzxyZWN0IHg9XCIwXCIgeT1cIjBcIiAnLFxuICAgICAgICAgICAgJ3dpZHRoPVwiJywgdGhpcy53aWR0aCxcbiAgICAgICAgICAgICdcIiBoZWlnaHQ9XCInLCB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgICdcIiBmaWxsPVwiJywgdGhpc1twcm9wZXJ0eV0sICdcIicsXG4gICAgICAgICAgJz48L3JlY3Q+XFxuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBvYmplY3Qgb3IgdGhlIG9iamVjdHMgb2YgYSBtdWx0aXBsZSBzZWxlY3Rpb25cbiAgICAgKiB0byB0aGUgYm90dG9tIG9mIHRoZSBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmQgdG8gYmFja1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2VuZFRvQmFjazogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgYWN0aXZlR3JvdXAgPSB0aGlzLl9hY3RpdmVHcm91cCxcbiAgICAgICAgICBpLCBvYmosIG9ianM7XG4gICAgICBpZiAob2JqZWN0ID09PSBhY3RpdmVHcm91cCkge1xuICAgICAgICBvYmpzID0gYWN0aXZlR3JvdXAuX29iamVjdHM7XG4gICAgICAgIGZvciAoaSA9IG9ianMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgb2JqID0gb2Jqc1tpXTtcbiAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqKTtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzLnVuc2hpZnQob2JqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgICB0aGlzLl9vYmplY3RzLnVuc2hpZnQob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlckFsbCAmJiB0aGlzLnJlbmRlckFsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBvYmplY3Qgb3IgdGhlIG9iamVjdHMgb2YgYSBtdWx0aXBsZSBzZWxlY3Rpb25cbiAgICAgKiB0byB0aGUgdG9wIG9mIHRoZSBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgYWN0aXZlR3JvdXAgPSB0aGlzLl9hY3RpdmVHcm91cCxcbiAgICAgICAgICBpLCBvYmosIG9ianM7XG4gICAgICBpZiAob2JqZWN0ID09PSBhY3RpdmVHcm91cCkge1xuICAgICAgICBvYmpzID0gYWN0aXZlR3JvdXAuX29iamVjdHM7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmpzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgb2JqID0gb2Jqc1tpXTtcbiAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqKTtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzLnB1c2gob2JqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgICB0aGlzLl9vYmplY3RzLnB1c2gob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlckFsbCAmJiB0aGlzLnJlbmRlckFsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBvYmplY3Qgb3IgYSBzZWxlY3Rpb24gZG93biBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnRlcnNlY3RpbmddIElmIGB0cnVlYCwgc2VuZCBvYmplY3QgYmVoaW5kIG5leHQgbG93ZXIgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2VuZEJhY2t3YXJkczogZnVuY3Rpb24gKG9iamVjdCwgaW50ZXJzZWN0aW5nKSB7XG4gICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBhY3RpdmVHcm91cCA9IHRoaXMuX2FjdGl2ZUdyb3VwLFxuICAgICAgICAgIGksIG9iaiwgaWR4LCBuZXdJZHgsIG9ianM7XG5cbiAgICAgIGlmIChvYmplY3QgPT09IGFjdGl2ZUdyb3VwKSB7XG4gICAgICAgIG9ianMgPSBhY3RpdmVHcm91cC5fb2JqZWN0cztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9ianMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvYmogPSBvYmpzW2ldO1xuICAgICAgICAgIGlkeCA9IHRoaXMuX29iamVjdHMuaW5kZXhPZihvYmopO1xuICAgICAgICAgIGlmIChpZHggIT09IDApIHtcbiAgICAgICAgICAgIG5ld0lkeCA9IGlkeCAtIDE7XG4gICAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqKTtcbiAgICAgICAgICAgIHRoaXMuX29iamVjdHMuc3BsaWNlKG5ld0lkeCwgMCwgb2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZHggPSB0aGlzLl9vYmplY3RzLmluZGV4T2Yob2JqZWN0KTtcbiAgICAgICAgaWYgKGlkeCAhPT0gMCkge1xuICAgICAgICAgIC8vIGlmIG9iamVjdCBpcyBub3Qgb24gdGhlIGJvdHRvbSBvZiBzdGFja1xuICAgICAgICAgIG5ld0lkeCA9IHRoaXMuX2ZpbmROZXdMb3dlckluZGV4KG9iamVjdCwgaWR4LCBpbnRlcnNlY3RpbmcpO1xuICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgICAgIHRoaXMuX29iamVjdHMuc3BsaWNlKG5ld0lkeCwgMCwgb2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJBbGwgJiYgdGhpcy5yZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maW5kTmV3TG93ZXJJbmRleDogZnVuY3Rpb24ob2JqZWN0LCBpZHgsIGludGVyc2VjdGluZykge1xuICAgICAgdmFyIG5ld0lkeDtcblxuICAgICAgaWYgKGludGVyc2VjdGluZykge1xuICAgICAgICBuZXdJZHggPSBpZHg7XG5cbiAgICAgICAgLy8gdHJhdmVyc2UgZG93biB0aGUgc3RhY2sgbG9va2luZyBmb3IgdGhlIG5lYXJlc3QgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgICAgICBmb3IgKHZhciBpID0gaWR4IC0gMTsgaSA+PSAwOyAtLWkpIHtcblxuICAgICAgICAgIHZhciBpc0ludGVyc2VjdGluZyA9IG9iamVjdC5pbnRlcnNlY3RzV2l0aE9iamVjdCh0aGlzLl9vYmplY3RzW2ldKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdCh0aGlzLl9vYmplY3RzW2ldKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29iamVjdHNbaV0uaXNDb250YWluZWRXaXRoaW5PYmplY3Qob2JqZWN0KTtcblxuICAgICAgICAgIGlmIChpc0ludGVyc2VjdGluZykge1xuICAgICAgICAgICAgbmV3SWR4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld0lkeCA9IGlkeCAtIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdJZHg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIG9iamVjdCBvciBhIHNlbGVjdGlvbiB1cCBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnRlcnNlY3RpbmddIElmIGB0cnVlYCwgc2VuZCBvYmplY3QgaW4gZnJvbnQgb2YgbmV4dCB1cHBlciBpbnRlcnNlY3Rpbmcgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBicmluZ0ZvcndhcmQ6IGZ1bmN0aW9uIChvYmplY3QsIGludGVyc2VjdGluZykge1xuICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgYWN0aXZlR3JvdXAgPSB0aGlzLl9hY3RpdmVHcm91cCxcbiAgICAgICAgICBpLCBvYmosIGlkeCwgbmV3SWR4LCBvYmpzO1xuXG4gICAgICBpZiAob2JqZWN0ID09PSBhY3RpdmVHcm91cCkge1xuICAgICAgICBvYmpzID0gYWN0aXZlR3JvdXAuX29iamVjdHM7XG4gICAgICAgIGZvciAoaSA9IG9ianMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgb2JqID0gb2Jqc1tpXTtcbiAgICAgICAgICBpZHggPSB0aGlzLl9vYmplY3RzLmluZGV4T2Yob2JqKTtcbiAgICAgICAgICBpZiAoaWR4ICE9PSB0aGlzLl9vYmplY3RzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIG5ld0lkeCA9IGlkeCArIDE7XG4gICAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqKTtcbiAgICAgICAgICAgIHRoaXMuX29iamVjdHMuc3BsaWNlKG5ld0lkeCwgMCwgb2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZHggPSB0aGlzLl9vYmplY3RzLmluZGV4T2Yob2JqZWN0KTtcbiAgICAgICAgaWYgKGlkeCAhPT0gdGhpcy5fb2JqZWN0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgLy8gaWYgb2JqZWN0IGlzIG5vdCBvbiB0b3Agb2Ygc3RhY2sgKGxhc3QgaXRlbSBpbiBhbiBhcnJheSlcbiAgICAgICAgICBuZXdJZHggPSB0aGlzLl9maW5kTmV3VXBwZXJJbmRleChvYmplY3QsIGlkeCwgaW50ZXJzZWN0aW5nKTtcbiAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqZWN0KTtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzLnNwbGljZShuZXdJZHgsIDAsIG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyQWxsICYmIHRoaXMucmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZE5ld1VwcGVySW5kZXg6IGZ1bmN0aW9uKG9iamVjdCwgaWR4LCBpbnRlcnNlY3RpbmcpIHtcbiAgICAgIHZhciBuZXdJZHg7XG5cbiAgICAgIGlmIChpbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgbmV3SWR4ID0gaWR4O1xuXG4gICAgICAgIC8vIHRyYXZlcnNlIHVwIHRoZSBzdGFjayBsb29raW5nIGZvciB0aGUgbmVhcmVzdCBpbnRlcnNlY3Rpbmcgb2JqZWN0XG4gICAgICAgIGZvciAodmFyIGkgPSBpZHggKyAxOyBpIDwgdGhpcy5fb2JqZWN0cy5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgICAgdmFyIGlzSW50ZXJzZWN0aW5nID0gb2JqZWN0LmludGVyc2VjdHNXaXRoT2JqZWN0KHRoaXMuX29iamVjdHNbaV0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmlzQ29udGFpbmVkV2l0aGluT2JqZWN0KHRoaXMuX29iamVjdHNbaV0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdChvYmplY3QpO1xuXG4gICAgICAgICAgaWYgKGlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICBuZXdJZHggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3SWR4ID0gaWR4ICsgMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld0lkeDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYW4gb2JqZWN0IHRvIHNwZWNpZmllZCBsZXZlbCBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggUG9zaXRpb24gdG8gbW92ZSB0b1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgbW92ZVRvOiBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCkge1xuICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iamVjdCk7XG4gICAgICB0aGlzLl9vYmplY3RzLnNwbGljZShpbmRleCwgMCwgb2JqZWN0KTtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlckFsbCAmJiB0aGlzLnJlbmRlckFsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYSBjYW52YXMgZWxlbWVudCBhbmQgcmVtb3ZlcyBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuQ2FudmFzICgnICsgdGhpcy5jb21wbGV4aXR5KCkgKyAnKTogJyArXG4gICAgICAgICAgICAgICAneyBvYmplY3RzOiAnICsgdGhpcy5nZXRPYmplY3RzKCkubGVuZ3RoICsgJyB9Pic7XG4gICAgfVxuICB9KTtcblxuICBleHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIGZhYnJpYy5PYnNlcnZhYmxlKTtcbiAgZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCBmYWJyaWMuQ29sbGVjdGlvbik7XG4gIGV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSwgZmFicmljLkRhdGFVUkxFeHBvcnRlcik7XG5cbiAgZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcyAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBFTVBUWV9KU09OOiAne1wib2JqZWN0c1wiOiBbXSwgXCJiYWNrZ3JvdW5kXCI6IFwid2hpdGVcIn0nLFxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSB3YXkgdG8gY2hlY2sgc3VwcG9ydCBvZiBzb21lIG9mIHRoZSBjYW52YXMgbWV0aG9kc1xuICAgICAqIChlaXRoZXIgdGhvc2Ugb2YgSFRNTENhbnZhc0VsZW1lbnQgaXRzZWxmLCBvciByZW5kZXJpbmcgY29udGV4dClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2ROYW1lIE1ldGhvZCB0byBjaGVjayBzdXBwb3J0IGZvcjtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb3VsZCBiZSBvbmUgb2YgXCJnZXRJbWFnZURhdGFcIiwgXCJ0b0RhdGFVUkxcIiwgXCJ0b0RhdGFVUkxXaXRoUXVhbGl0eVwiIG9yIFwic2V0TGluZURhc2hcIlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW4gfCBudWxsfSBgdHJ1ZWAgaWYgbWV0aG9kIGlzIHN1cHBvcnRlZCAob3IgYXQgbGVhc3QgZXhpc3RzKSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYG51bGxgIGlmIGNhbnZhcyBlbGVtZW50IG9yIGNvbnRleHQgY2FuIG5vdCBiZSBpbml0aWFsaXplZFxuICAgICAqL1xuICAgIHN1cHBvcnRzOiBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGVsID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuXG4gICAgICBpZiAoIWVsIHx8ICFlbC5nZXRDb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gZWwuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGlmICghY3R4KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKG1ldGhvZE5hbWUpIHtcblxuICAgICAgICBjYXNlICdnZXRJbWFnZURhdGEnOlxuICAgICAgICAgIHJldHVybiB0eXBlb2YgY3R4LmdldEltYWdlRGF0YSAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAgICAgY2FzZSAnc2V0TGluZURhc2gnOlxuICAgICAgICAgIHJldHVybiB0eXBlb2YgY3R4LnNldExpbmVEYXNoICE9PSAndW5kZWZpbmVkJztcblxuICAgICAgICBjYXNlICd0b0RhdGFVUkwnOlxuICAgICAgICAgIHJldHVybiB0eXBlb2YgZWwudG9EYXRhVVJMICE9PSAndW5kZWZpbmVkJztcblxuICAgICAgICBjYXNlICd0b0RhdGFVUkxXaXRoUXVhbGl0eSc6XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVsLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycsIDApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIEpTT04gcmVwcmVzZW50YXRpb24gb2YgY2FudmFzXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAqIEByZXR1cm4ge1N0cmluZ30gSlNPTiBzdHJpbmdcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTMjc2VyaWFsaXphdGlvbn1cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9wZWM4Ni98anNGaWRkbGUgZGVtb31cbiAgICogQGV4YW1wbGUgPGNhcHRpb24+SlNPTiB3aXRob3V0IGFkZGl0aW9uYWwgcHJvcGVydGllczwvY2FwdGlvbj5cbiAgICogdmFyIGpzb24gPSBjYW52YXMudG9KU09OKCk7XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkpTT04gd2l0aCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgaW5jbHVkZWQ8L2NhcHRpb24+XG4gICAqIHZhciBqc29uID0gY2FudmFzLnRvSlNPTihbJ2xvY2tNb3ZlbWVudFgnLCAnbG9ja01vdmVtZW50WScsICdsb2NrUm90YXRpb24nLCAnbG9ja1NjYWxpbmdYJywgJ2xvY2tTY2FsaW5nWScsICdsb2NrVW5pU2NhbGluZyddKTtcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+SlNPTiB3aXRob3V0IGRlZmF1bHQgdmFsdWVzPC9jYXB0aW9uPlxuICAgKiBjYW52YXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBmYWxzZTtcbiAgICogdmFyIGpzb24gPSBjYW52YXMudG9KU09OKCk7XG4gICAqL1xuICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS50b0pTT04gPSBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS50b09iamVjdDtcblxufSkoKTtcblxuXG4vKipcbiAqIEJhc2VCcnVzaCBjbGFzc1xuICogQGNsYXNzIGZhYnJpYy5CYXNlQnJ1c2hcbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZnJlZWRyYXdpbmd8RnJlZWRyYXdpbmcgZGVtb31cbiAqL1xuZmFicmljLkJhc2VCcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKC8qKiBAbGVuZHMgZmFicmljLkJhc2VCcnVzaC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBDb2xvciBvZiBhIGJydXNoXG4gICAqIEB0eXBlIFN0cmluZ1xuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgY29sb3I6ICdyZ2IoMCwgMCwgMCknLFxuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiBhIGJydXNoXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgd2lkdGg6IDEsXG5cbiAgLyoqXG4gICAqIFNoYWRvdyBvYmplY3QgcmVwcmVzZW50aW5nIHNoYWRvdyBvZiB0aGlzIHNoYXBlLlxuICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHJlcGxhY2VzIFwic2hhZG93Q29sb3JcIiAoU3RyaW5nKSwgXCJzaGFkb3dPZmZzZXRYXCIgKE51bWJlciksXG4gICAqIFwic2hhZG93T2Zmc2V0WVwiIChOdW1iZXIpIGFuZCBcInNoYWRvd0JsdXJcIiAoTnVtYmVyKSBzaW5jZSB2MS4yLjEyXG4gICAqIEB0eXBlIGZhYnJpYy5TaGFkb3dcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHNoYWRvdzogbnVsbCxcblxuICAvKipcbiAgICogTGluZSBlbmRpbmdzIHN0eWxlIG9mIGEgYnJ1c2ggKG9uZSBvZiBcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiKVxuICAgKiBAdHlwZSBTdHJpbmdcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHN0cm9rZUxpbmVDYXA6ICdyb3VuZCcsXG5cbiAgLyoqXG4gICAqIENvcm5lciBzdHlsZSBvZiBhIGJydXNoIChvbmUgb2YgXCJiZXZpbFwiLCBcInJvdW5kXCIsIFwibWl0ZXJcIilcbiAgICogQHR5cGUgU3RyaW5nXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBzdHJva2VMaW5lSm9pbjogJ3JvdW5kJyxcblxuICAvKipcbiAgICogU3Ryb2tlIERhc2ggQXJyYXkuXG4gICAqIEB0eXBlIEFycmF5XG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBzdHJva2VEYXNoQXJyYXk6IG51bGwsXG5cbiAgLyoqXG4gICAqIFNldHMgc2hhZG93IG9mIGFuIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdCBvciBzdHJpbmcgKGUuZy4gXCIycHggMnB4IDEwcHggcmdiYSgwLDAsMCwwLjIpXCIpXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgc2V0U2hhZG93OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5zaGFkb3cgPSBuZXcgZmFicmljLlNoYWRvdyhvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBicnVzaCBzdHlsZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRCcnVzaFN0eWxlczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG5cbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGN0eC5saW5lQ2FwID0gdGhpcy5zdHJva2VMaW5lQ2FwO1xuICAgIGN0eC5saW5lSm9pbiA9IHRoaXMuc3Ryb2tlTGluZUpvaW47XG4gICAgaWYgKHRoaXMuc3Ryb2tlRGFzaEFycmF5ICYmIGZhYnJpYy5TdGF0aWNDYW52YXMuc3VwcG9ydHMoJ3NldExpbmVEYXNoJykpIHtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaCh0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGJydXNoIHNoYWRvdyBzdHlsZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRTaGFkb3c6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5zaGFkb3cpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcCxcbiAgICAgICAgem9vbSA9IHRoaXMuY2FudmFzLmdldFpvb20oKTtcblxuICAgIGN0eC5zaGFkb3dDb2xvciA9IHRoaXMuc2hhZG93LmNvbG9yO1xuICAgIGN0eC5zaGFkb3dCbHVyID0gdGhpcy5zaGFkb3cuYmx1ciAqIHpvb207XG4gICAgY3R4LnNoYWRvd09mZnNldFggPSB0aGlzLnNoYWRvdy5vZmZzZXRYICogem9vbTtcbiAgICBjdHguc2hhZG93T2Zmc2V0WSA9IHRoaXMuc2hhZG93Lm9mZnNldFkgKiB6b29tO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGJydXNoIHNoYWRvdyBzdHlsZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXNldFNoYWRvdzogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG5cbiAgICBjdHguc2hhZG93Q29sb3IgPSAnJztcbiAgICBjdHguc2hhZG93Qmx1ciA9IGN0eC5zaGFkb3dPZmZzZXRYID0gY3R4LnNoYWRvd09mZnNldFkgPSAwO1xuICB9XG59KTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIFBlbmNpbEJydXNoIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUGVuY2lsQnJ1c2hcbiAgICogQGV4dGVuZHMgZmFicmljLkJhc2VCcnVzaFxuICAgKi9cbiAgZmFicmljLlBlbmNpbEJydXNoID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLkJhc2VCcnVzaCwgLyoqIEBsZW5kcyBmYWJyaWMuUGVuY2lsQnJ1c2gucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtmYWJyaWMuQ2FudmFzfSBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUGVuY2lsQnJ1c2h9IEluc3RhbmNlIG9mIGEgcGVuY2lsIGJydXNoXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIHRoaXMuX3BvaW50cyA9IFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbm92b2tlZCBvbiBtb3VzZSBkb3duXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bjogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgICAgdGhpcy5fcHJlcGFyZUZvckRyYXdpbmcocG9pbnRlcik7XG4gICAgICAvLyBjYXB0dXJlIGNvb3JkaW5hdGVzIGltbWVkaWF0ZWx5XG4gICAgICAvLyB0aGlzIGFsbG93cyB0byBkcmF3IGRvdHMgKHdoZW4gbW92ZW1lbnQgbmV2ZXIgb2NjdXJzKVxuICAgICAgdGhpcy5fY2FwdHVyZURyYXdpbmdQYXRoKHBvaW50ZXIpO1xuICAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElub3Zva2VkIG9uIG1vdXNlIG1vdmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgICAqL1xuICAgIG9uTW91c2VNb3ZlOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgICB0aGlzLl9jYXB0dXJlRHJhd2luZ1BhdGgocG9pbnRlcik7XG4gICAgICAvLyByZWRyYXcgY3VydmVcbiAgICAgIC8vIGNsZWFyIHRvcCBjYW52YXNcbiAgICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICAgIHRoaXMuX3JlbmRlcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIG9uIG1vdXNlIHVwXG4gICAgICovXG4gICAgb25Nb3VzZVVwOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2ZpbmFsaXplQW5kQWRkUGF0aCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyIEFjdHVhbCBtb3VzZSBwb3NpdGlvbiByZWxhdGVkIHRvIHRoZSBjYW52YXMuXG4gICAgICovXG4gICAgX3ByZXBhcmVGb3JEcmF3aW5nOiBmdW5jdGlvbihwb2ludGVyKSB7XG5cbiAgICAgIHZhciBwID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSk7XG5cbiAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICB0aGlzLl9hZGRQb2ludChwKTtcblxuICAgICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5tb3ZlVG8ocC54LCBwLnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBQb2ludCB0byBiZSBhZGRlZCB0byBwb2ludHMgYXJyYXlcbiAgICAgKi9cbiAgICBfYWRkUG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICB0aGlzLl9wb2ludHMucHVzaChwb2ludCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFyIHBvaW50cyBhcnJheSBhbmQgc2V0IGNvbnRleHRUb3AgY2FudmFzIHN0eWxlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3BvaW50cy5sZW5ndGggPSAwO1xuXG4gICAgICB0aGlzLl9zZXRCcnVzaFN0eWxlcygpO1xuICAgICAgdGhpcy5fc2V0U2hhZG93KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXIgQWN0dWFsIG1vdXNlIHBvc2l0aW9uIHJlbGF0ZWQgdG8gdGhlIGNhbnZhcy5cbiAgICAgKi9cbiAgICBfY2FwdHVyZURyYXdpbmdQYXRoOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgICB2YXIgcG9pbnRlclBvaW50ID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSk7XG4gICAgICB0aGlzLl9hZGRQb2ludChwb2ludGVyUG9pbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgc21vb3RoIHBhdGggb24gdGhlIHRvcENhbnZhcyB1c2luZyBxdWFkcmF0aWNDdXJ2ZVRvXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdHggID0gdGhpcy5jYW52YXMuY29udGV4dFRvcCxcbiAgICAgICAgICB2ID0gdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm0sXG4gICAgICAgICAgcDEgPSB0aGlzLl9wb2ludHNbMF0sXG4gICAgICAgICAgcDIgPSB0aGlzLl9wb2ludHNbMV07XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNmb3JtKHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAvL2lmIHdlIG9ubHkgaGF2ZSAyIHBvaW50cyBpbiB0aGUgcGF0aCBhbmQgdGhleSBhcmUgdGhlIHNhbWVcbiAgICAgIC8vaXQgbWVhbnMgdGhhdCB0aGUgdXNlciBvbmx5IGNsaWNrZWQgdGhlIGNhbnZhcyB3aXRob3V0IG1vdmluZyB0aGUgbW91c2VcbiAgICAgIC8vdGhlbiB3ZSBzaG91bGQgYmUgZHJhd2luZyBhIGRvdC4gQSBwYXRoIGlzbid0IGRyYXduIGJldHdlZW4gdHdvIGlkZW50aWNhbCBkb3RzXG4gICAgICAvL3RoYXQncyB3aHkgd2Ugc2V0IHRoZW0gYXBhcnQgYSBiaXRcbiAgICAgIGlmICh0aGlzLl9wb2ludHMubGVuZ3RoID09PSAyICYmIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueSkge1xuICAgICAgICBwMS54IC09IDAuNTtcbiAgICAgICAgcDIueCArPSAwLjU7XG4gICAgICB9XG4gICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gdGhpcy5fcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIHdlIHBpY2sgdGhlIHBvaW50IGJldHdlZW4gcGkgKyAxICYgcGkgKyAyIGFzIHRoZVxuICAgICAgICAvLyBlbmQgcG9pbnQgYW5kIHAxIGFzIG91ciBjb250cm9sIHBvaW50LlxuICAgICAgICB2YXIgbWlkUG9pbnQgPSBwMS5taWRQb2ludEZyb20ocDIpO1xuICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhwMS54LCBwMS55LCBtaWRQb2ludC54LCBtaWRQb2ludC55KTtcblxuICAgICAgICBwMSA9IHRoaXMuX3BvaW50c1tpXTtcbiAgICAgICAgcDIgPSB0aGlzLl9wb2ludHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gRHJhdyBsYXN0IGxpbmUgYXMgYSBzdHJhaWdodCBsaW5lIHdoaWxlXG4gICAgICAvLyB3ZSB3YWl0IGZvciB0aGUgbmV4dCBwb2ludCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZVxuICAgICAgLy8gdGhlIGJlemllciBjb250cm9sIHBvaW50XG4gICAgICBjdHgubGluZVRvKHAxLngsIHAxLnkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgcG9pbnRzIHRvIFNWRyBwYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIEFycmF5IG9mIHBvaW50c1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU1ZHIHBhdGhcbiAgICAgKi9cbiAgICBjb252ZXJ0UG9pbnRzVG9TVkdQYXRoOiBmdW5jdGlvbihwb2ludHMpIHtcbiAgICAgIHZhciBwYXRoID0gW10sXG4gICAgICAgICAgcDEgPSBuZXcgZmFicmljLlBvaW50KHBvaW50c1swXS54LCBwb2ludHNbMF0ueSksXG4gICAgICAgICAgcDIgPSBuZXcgZmFicmljLlBvaW50KHBvaW50c1sxXS54LCBwb2ludHNbMV0ueSk7XG5cbiAgICAgIHBhdGgucHVzaCgnTSAnLCBwb2ludHNbMF0ueCwgJyAnLCBwb2ludHNbMF0ueSwgJyAnKTtcbiAgICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIG1pZFBvaW50ID0gcDEubWlkUG9pbnRGcm9tKHAyKTtcbiAgICAgICAgLy8gcDEgaXMgb3VyIGJlemllciBjb250cm9sIHBvaW50XG4gICAgICAgIC8vIG1pZHBvaW50IGlzIG91ciBlbmRwb2ludFxuICAgICAgICAvLyBzdGFydCBwb2ludCBpcyBwKGktMSkgdmFsdWUuXG4gICAgICAgIHBhdGgucHVzaCgnUSAnLCBwMS54LCAnICcsIHAxLnksICcgJywgbWlkUG9pbnQueCwgJyAnLCBtaWRQb2ludC55LCAnICcpO1xuICAgICAgICBwMSA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRzW2ldLngsIHBvaW50c1tpXS55KTtcbiAgICAgICAgaWYgKChpICsgMSkgPCBwb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgcDIgPSBuZXcgZmFicmljLlBvaW50KHBvaW50c1tpICsgMV0ueCwgcG9pbnRzW2kgKyAxXS55KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGF0aC5wdXNoKCdMICcsIHAxLngsICcgJywgcDEueSwgJyAnKTtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGZhYnJpYy5QYXRoIG9iamVjdCB0byBhZGQgb24gY2FudmFzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhEYXRhIFBhdGggZGF0YVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5QYXRofSBQYXRoIHRvIGFkZCBvbiBjYW52YXNcbiAgICAgKi9cbiAgICBjcmVhdGVQYXRoOiBmdW5jdGlvbihwYXRoRGF0YSkge1xuICAgICAgdmFyIHBhdGggPSBuZXcgZmFicmljLlBhdGgocGF0aERhdGEsIHtcbiAgICAgICAgZmlsbDogbnVsbCxcbiAgICAgICAgc3Ryb2tlOiB0aGlzLmNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgc3Ryb2tlTGluZUNhcDogdGhpcy5zdHJva2VMaW5lQ2FwLFxuICAgICAgICBzdHJva2VMaW5lSm9pbjogdGhpcy5zdHJva2VMaW5lSm9pbixcbiAgICAgICAgc3Ryb2tlRGFzaEFycmF5OiB0aGlzLnN0cm9rZURhc2hBcnJheSxcbiAgICAgICAgb3JpZ2luWDogJ2NlbnRlcicsXG4gICAgICAgIG9yaWdpblk6ICdjZW50ZXInXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuc2hhZG93KSB7XG4gICAgICAgIHRoaXMuc2hhZG93LmFmZmVjdFN0cm9rZSA9IHRydWU7XG4gICAgICAgIHBhdGguc2V0U2hhZG93KHRoaXMuc2hhZG93KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNldXAgYWZ0ZXIgZHJhd2luZyB0aGUgcGF0aCBvbiBjb250ZXh0VG9wIGNhbnZhc1xuICAgICAqIHdlIHVzZSB0aGUgcG9pbnRzIGNhcHR1cmVkIHRvIGNyZWF0ZSBhbiBuZXcgZmFicmljIHBhdGggb2JqZWN0XG4gICAgICogYW5kIGFkZCBpdCB0byB0aGUgZmFicmljIGNhbnZhcy5cbiAgICAgKi9cbiAgICBfZmluYWxpemVBbmRBZGRQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICB2YXIgcGF0aERhdGEgPSB0aGlzLmNvbnZlcnRQb2ludHNUb1NWR1BhdGgodGhpcy5fcG9pbnRzKS5qb2luKCcnKTtcbiAgICAgIGlmIChwYXRoRGF0YSA9PT0gJ00gMCAwIFEgMCAwIDAgMCBMIDAgMCcpIHtcbiAgICAgICAgLy8gZG8gbm90IGNyZWF0ZSAwIHdpZHRoL2hlaWdodCBwYXRocywgYXMgdGhleSBhcmVcbiAgICAgICAgLy8gcmVuZGVyZWQgaW5jb25zaXN0ZW50bHkgYWNyb3NzIGJyb3dzZXJzXG4gICAgICAgIC8vIEZpcmVmb3ggNCwgZm9yIGV4YW1wbGUsIHJlbmRlcnMgYSBkb3QsXG4gICAgICAgIC8vIHdoZXJlYXMgQ2hyb21lIDEwIHJlbmRlcnMgbm90aGluZ1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGF0aCA9IHRoaXMuY3JlYXRlUGF0aChwYXRoRGF0YSk7XG5cbiAgICAgIHRoaXMuY2FudmFzLmFkZChwYXRoKTtcbiAgICAgIHBhdGguc2V0Q29vcmRzKCk7XG5cbiAgICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICAgIHRoaXMuX3Jlc2V0U2hhZG93KCk7XG4gICAgICB0aGlzLmNhbnZhcy5yZW5kZXJBbGwoKTtcblxuICAgICAgLy8gZmlyZSBldmVudCAncGF0aCcgY3JlYXRlZFxuICAgICAgdGhpcy5jYW52YXMuZmlyZSgncGF0aDpjcmVhdGVkJywgeyBwYXRoOiBwYXRoIH0pO1xuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbi8qKlxuICogQ2lyY2xlQnJ1c2ggY2xhc3NcbiAqIEBjbGFzcyBmYWJyaWMuQ2lyY2xlQnJ1c2hcbiAqL1xuZmFicmljLkNpcmNsZUJydXNoID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLkJhc2VCcnVzaCwgLyoqIEBsZW5kcyBmYWJyaWMuQ2lyY2xlQnJ1c2gucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogV2lkdGggb2YgYSBicnVzaFxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHdpZHRoOiAxMCxcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtmYWJyaWMuQ2FudmFzfSBjYW52YXNcbiAgICogQHJldHVybiB7ZmFicmljLkNpcmNsZUJydXNofSBJbnN0YW5jZSBvZiBhIGNpcmNsZSBicnVzaFxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBpbnNpZGUgb24gbW91c2UgZG93biBhbmQgbW91c2UgbW92ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKi9cbiAgZHJhd0RvdDogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHZhciBwb2ludCA9IHRoaXMuYWRkUG9pbnQocG9pbnRlciksXG4gICAgICAgIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3AsXG4gICAgICAgIHYgPSB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG5cbiAgICBjdHguZmlsbFN0eWxlID0gcG9pbnQuZmlsbDtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyhwb2ludC54LCBwb2ludC55LCBwb2ludC5yYWRpdXMsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsKCk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIGRvd25cbiAgICovXG4gIG9uTW91c2VEb3duOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdGhpcy5wb2ludHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgdGhpcy5fc2V0U2hhZG93KCk7XG4gICAgdGhpcy5kcmF3RG90KHBvaW50ZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIG1vdmVcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICovXG4gIG9uTW91c2VNb3ZlOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdGhpcy5kcmF3RG90KHBvaW50ZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIHVwXG4gICAqL1xuICBvbk1vdXNlVXA6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcmlnaW5hbFJlbmRlck9uQWRkUmVtb3ZlID0gdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmU7XG4gICAgdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmUgPSBmYWxzZTtcblxuICAgIHZhciBjaXJjbGVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBwb2ludCA9IHRoaXMucG9pbnRzW2ldLFxuICAgICAgICAgIGNpcmNsZSA9IG5ldyBmYWJyaWMuQ2lyY2xlKHtcbiAgICAgICAgICAgIHJhZGl1czogcG9pbnQucmFkaXVzLFxuICAgICAgICAgICAgbGVmdDogcG9pbnQueCxcbiAgICAgICAgICAgIHRvcDogcG9pbnQueSxcbiAgICAgICAgICAgIG9yaWdpblg6ICdjZW50ZXInLFxuICAgICAgICAgICAgb3JpZ2luWTogJ2NlbnRlcicsXG4gICAgICAgICAgICBmaWxsOiBwb2ludC5maWxsXG4gICAgICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc2hhZG93ICYmIGNpcmNsZS5zZXRTaGFkb3codGhpcy5zaGFkb3cpO1xuXG4gICAgICBjaXJjbGVzLnB1c2goY2lyY2xlKTtcbiAgICB9XG4gICAgdmFyIGdyb3VwID0gbmV3IGZhYnJpYy5Hcm91cChjaXJjbGVzLCB7IG9yaWdpblg6ICdjZW50ZXInLCBvcmlnaW5ZOiAnY2VudGVyJyB9KTtcbiAgICBncm91cC5jYW52YXMgPSB0aGlzLmNhbnZhcztcblxuICAgIHRoaXMuY2FudmFzLmFkZChncm91cCk7XG4gICAgdGhpcy5jYW52YXMuZmlyZSgncGF0aDpjcmVhdGVkJywgeyBwYXRoOiBncm91cCB9KTtcblxuICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICB0aGlzLl9yZXNldFNoYWRvdygpO1xuICAgIHRoaXMuY2FudmFzLnJlbmRlck9uQWRkUmVtb3ZlID0gb3JpZ2luYWxSZW5kZXJPbkFkZFJlbW92ZTtcbiAgICB0aGlzLmNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSBKdXN0IGFkZGVkIHBvaW50ZXIgcG9pbnRcbiAgICovXG4gIGFkZFBvaW50OiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdmFyIHBvaW50ZXJQb2ludCA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRlci54LCBwb2ludGVyLnkpLFxuXG4gICAgICAgIGNpcmNsZVJhZGl1cyA9IGZhYnJpYy51dGlsLmdldFJhbmRvbUludChcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KDAsIHRoaXMud2lkdGggLSAyMCksIHRoaXMud2lkdGggKyAyMCkgLyAyLFxuXG4gICAgICAgIGNpcmNsZUNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldEFscGhhKGZhYnJpYy51dGlsLmdldFJhbmRvbUludCgwLCAxMDApIC8gMTAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvUmdiYSgpO1xuXG4gICAgcG9pbnRlclBvaW50LnJhZGl1cyA9IGNpcmNsZVJhZGl1cztcbiAgICBwb2ludGVyUG9pbnQuZmlsbCA9IGNpcmNsZUNvbG9yO1xuXG4gICAgdGhpcy5wb2ludHMucHVzaChwb2ludGVyUG9pbnQpO1xuXG4gICAgcmV0dXJuIHBvaW50ZXJQb2ludDtcbiAgfVxufSk7XG5cblxuLyoqXG4gKiBTcHJheUJydXNoIGNsYXNzXG4gKiBAY2xhc3MgZmFicmljLlNwcmF5QnJ1c2hcbiAqL1xuZmFicmljLlNwcmF5QnJ1c2ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyggZmFicmljLkJhc2VCcnVzaCwgLyoqIEBsZW5kcyBmYWJyaWMuU3ByYXlCcnVzaC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiBhIHNwcmF5XG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgd2lkdGg6ICAgICAgICAgICAgICAxMCxcblxuICAvKipcbiAgICogRGVuc2l0eSBvZiBhIHNwcmF5IChudW1iZXIgb2YgZG90cyBwZXIgY2h1bmspXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgZGVuc2l0eTogICAgICAgICAgICAyMCxcblxuICAvKipcbiAgICogV2lkdGggb2Ygc3ByYXkgZG90c1xuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIGRvdFdpZHRoOiAgICAgICAgICAgMSxcblxuICAvKipcbiAgICogV2lkdGggdmFyaWFuY2Ugb2Ygc3ByYXkgZG90c1xuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIGRvdFdpZHRoVmFyaWFuY2U6ICAgMSxcblxuICAvKipcbiAgICogV2hldGhlciBvcGFjaXR5IG9mIGEgZG90IHNob3VsZCBiZSByYW5kb21cbiAgICogQHR5cGUgQm9vbGVhblxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgcmFuZG9tT3BhY2l0eTogICAgICAgIGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG92ZXJsYXBwaW5nIGRvdHMgKHJlY3RhbmdsZXMpIHNob3VsZCBiZSByZW1vdmVkIChmb3IgcGVyZm9ybWFuY2UgcmVhc29ucylcbiAgICogQHR5cGUgQm9vbGVhblxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgb3B0aW1pemVPdmVybGFwcGluZzogIHRydWUsXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7ZmFicmljLkNhbnZhc30gY2FudmFzXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5TcHJheUJydXNofSBJbnN0YW5jZSBvZiBhIHNwcmF5IGJydXNoXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLnNwcmF5Q2h1bmtzID0gW107XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb24gbW91c2UgZG93blxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKi9cbiAgb25Nb3VzZURvd246IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB0aGlzLnNwcmF5Q2h1bmtzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jYW52YXMuY2xlYXJDb250ZXh0KHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgIHRoaXMuX3NldFNoYWRvdygpO1xuXG4gICAgdGhpcy5hZGRTcHJheUNodW5rKHBvaW50ZXIpO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb24gbW91c2UgbW92ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKi9cbiAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB0aGlzLmFkZFNwcmF5Q2h1bmsocG9pbnRlcik7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBvbiBtb3VzZSB1cFxuICAgKi9cbiAgb25Nb3VzZVVwOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3JpZ2luYWxSZW5kZXJPbkFkZFJlbW92ZSA9IHRoaXMuY2FudmFzLnJlbmRlck9uQWRkUmVtb3ZlO1xuICAgIHRoaXMuY2FudmFzLnJlbmRlck9uQWRkUmVtb3ZlID0gZmFsc2U7XG5cbiAgICB2YXIgcmVjdHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBpbGVuID0gdGhpcy5zcHJheUNodW5rcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHZhciBzcHJheUNodW5rID0gdGhpcy5zcHJheUNodW5rc1tpXTtcblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBzcHJheUNodW5rLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuXG4gICAgICAgIHZhciByZWN0ID0gbmV3IGZhYnJpYy5SZWN0KHtcbiAgICAgICAgICB3aWR0aDogc3ByYXlDaHVua1tqXS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHNwcmF5Q2h1bmtbal0ud2lkdGgsXG4gICAgICAgICAgbGVmdDogc3ByYXlDaHVua1tqXS54ICsgMSxcbiAgICAgICAgICB0b3A6IHNwcmF5Q2h1bmtbal0ueSArIDEsXG4gICAgICAgICAgb3JpZ2luWDogJ2NlbnRlcicsXG4gICAgICAgICAgb3JpZ2luWTogJ2NlbnRlcicsXG4gICAgICAgICAgZmlsbDogdGhpcy5jb2xvclxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnNoYWRvdyAmJiByZWN0LnNldFNoYWRvdyh0aGlzLnNoYWRvdyk7XG4gICAgICAgIHJlY3RzLnB1c2gocmVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW1pemVPdmVybGFwcGluZykge1xuICAgICAgcmVjdHMgPSB0aGlzLl9nZXRPcHRpbWl6ZWRSZWN0cyhyZWN0cyk7XG4gICAgfVxuXG4gICAgdmFyIGdyb3VwID0gbmV3IGZhYnJpYy5Hcm91cChyZWN0cywgeyBvcmlnaW5YOiAnY2VudGVyJywgb3JpZ2luWTogJ2NlbnRlcicgfSk7XG4gICAgZ3JvdXAuY2FudmFzID0gdGhpcy5jYW52YXM7XG5cbiAgICB0aGlzLmNhbnZhcy5hZGQoZ3JvdXApO1xuICAgIHRoaXMuY2FudmFzLmZpcmUoJ3BhdGg6Y3JlYXRlZCcsIHsgcGF0aDogZ3JvdXAgfSk7XG5cbiAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgdGhpcy5fcmVzZXRTaGFkb3coKTtcbiAgICB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZSA9IG9yaWdpbmFsUmVuZGVyT25BZGRSZW1vdmU7XG4gICAgdGhpcy5jYW52YXMucmVuZGVyQWxsKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJlY3RzXG4gICAqL1xuICBfZ2V0T3B0aW1pemVkUmVjdHM6IGZ1bmN0aW9uKHJlY3RzKSB7XG5cbiAgICAvLyBhdm9pZCBjcmVhdGluZyBkdXBsaWNhdGUgcmVjdHMgYXQgdGhlIHNhbWUgY29vcmRpbmF0ZXNcbiAgICB2YXIgdW5pcXVlUmVjdHMgPSB7IH0sIGtleTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAga2V5ID0gcmVjdHNbaV0ubGVmdCArICcnICsgcmVjdHNbaV0udG9wO1xuICAgICAgaWYgKCF1bmlxdWVSZWN0c1trZXldKSB7XG4gICAgICAgIHVuaXF1ZVJlY3RzW2tleV0gPSByZWN0c1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHVuaXF1ZVJlY3RzQXJyYXkgPSBbXTtcbiAgICBmb3IgKGtleSBpbiB1bmlxdWVSZWN0cykge1xuICAgICAgdW5pcXVlUmVjdHNBcnJheS5wdXNoKHVuaXF1ZVJlY3RzW2tleV0pO1xuICAgIH1cblxuICAgIHJldHVybiB1bmlxdWVSZWN0c0FycmF5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGJydXNoXG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yO1xuXG4gICAgdmFyIHYgPSB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5zcHJheUNodW5rUG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcG9pbnQgPSB0aGlzLnNwcmF5Q2h1bmtQb2ludHNbaV07XG4gICAgICBpZiAodHlwZW9mIHBvaW50Lm9wYWNpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHBvaW50Lm9wYWNpdHk7XG4gICAgICB9XG4gICAgICBjdHguZmlsbFJlY3QocG9pbnQueCwgcG9pbnQueSwgcG9pbnQud2lkdGgsIHBvaW50LndpZHRoKTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICovXG4gIGFkZFNwcmF5Q2h1bms6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB0aGlzLnNwcmF5Q2h1bmtQb2ludHMgPSBbXTtcblxuICAgIHZhciB4LCB5LCB3aWR0aCwgcmFkaXVzID0gdGhpcy53aWR0aCAvIDI7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGVuc2l0eTsgaSsrKSB7XG5cbiAgICAgIHggPSBmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQocG9pbnRlci54IC0gcmFkaXVzLCBwb2ludGVyLnggKyByYWRpdXMpO1xuICAgICAgeSA9IGZhYnJpYy51dGlsLmdldFJhbmRvbUludChwb2ludGVyLnkgLSByYWRpdXMsIHBvaW50ZXIueSArIHJhZGl1cyk7XG5cbiAgICAgIGlmICh0aGlzLmRvdFdpZHRoVmFyaWFuY2UpIHtcbiAgICAgICAgd2lkdGggPSBmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQoXG4gICAgICAgICAgLy8gYm90dG9tIGNsYW1wIHdpZHRoIHRvIDFcbiAgICAgICAgICBNYXRoLm1heCgxLCB0aGlzLmRvdFdpZHRoIC0gdGhpcy5kb3RXaWR0aFZhcmlhbmNlKSxcbiAgICAgICAgICB0aGlzLmRvdFdpZHRoICsgdGhpcy5kb3RXaWR0aFZhcmlhbmNlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB3aWR0aCA9IHRoaXMuZG90V2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludCA9IG5ldyBmYWJyaWMuUG9pbnQoeCwgeSk7XG4gICAgICBwb2ludC53aWR0aCA9IHdpZHRoO1xuXG4gICAgICBpZiAodGhpcy5yYW5kb21PcGFjaXR5KSB7XG4gICAgICAgIHBvaW50Lm9wYWNpdHkgPSBmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQoMCwgMTAwKSAvIDEwMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zcHJheUNodW5rUG9pbnRzLnB1c2gocG9pbnQpO1xuICAgIH1cblxuICAgIHRoaXMuc3ByYXlDaHVua3MucHVzaCh0aGlzLnNwcmF5Q2h1bmtQb2ludHMpO1xuICB9XG59KTtcblxuXG4vKipcbiAqIFBhdHRlcm5CcnVzaCBjbGFzc1xuICogQGNsYXNzIGZhYnJpYy5QYXR0ZXJuQnJ1c2hcbiAqIEBleHRlbmRzIGZhYnJpYy5CYXNlQnJ1c2hcbiAqL1xuZmFicmljLlBhdHRlcm5CcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5QZW5jaWxCcnVzaCwgLyoqIEBsZW5kcyBmYWJyaWMuUGF0dGVybkJydXNoLnByb3RvdHlwZSAqLyB7XG5cbiAgZ2V0UGF0dGVyblNyYzogZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZG90V2lkdGggPSAyMCxcbiAgICAgICAgZG90RGlzdGFuY2UgPSA1LFxuICAgICAgICBwYXR0ZXJuQ2FudmFzID0gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLFxuICAgICAgICBwYXR0ZXJuQ3R4ID0gcGF0dGVybkNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgcGF0dGVybkNhbnZhcy53aWR0aCA9IHBhdHRlcm5DYW52YXMuaGVpZ2h0ID0gZG90V2lkdGggKyBkb3REaXN0YW5jZTtcblxuICAgIHBhdHRlcm5DdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICBwYXR0ZXJuQ3R4LmJlZ2luUGF0aCgpO1xuICAgIHBhdHRlcm5DdHguYXJjKGRvdFdpZHRoIC8gMiwgZG90V2lkdGggLyAyLCBkb3RXaWR0aCAvIDIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgcGF0dGVybkN0eC5jbG9zZVBhdGgoKTtcbiAgICBwYXR0ZXJuQ3R4LmZpbGwoKTtcblxuICAgIHJldHVybiBwYXR0ZXJuQ2FudmFzO1xuICB9LFxuXG4gIGdldFBhdHRlcm5TcmNGdW5jdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFN0cmluZyh0aGlzLmdldFBhdHRlcm5TcmMpLnJlcGxhY2UoJ3RoaXMuY29sb3InLCAnXCInICsgdGhpcy5jb2xvciArICdcIicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFwicGF0dGVyblwiIGluc3RhbmNlIHByb3BlcnR5XG4gICAqL1xuICBnZXRQYXR0ZXJuOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXMuY29udGV4dFRvcC5jcmVhdGVQYXR0ZXJuKHRoaXMuc291cmNlIHx8IHRoaXMuZ2V0UGF0dGVyblNyYygpLCAncmVwZWF0Jyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYnJ1c2ggc3R5bGVzXG4gICAqL1xuICBfc2V0QnJ1c2hTdHlsZXM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0QnJ1c2hTdHlsZXMnKTtcbiAgICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLnN0cm9rZVN0eWxlID0gdGhpcy5nZXRQYXR0ZXJuKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgcGF0aFxuICAgKi9cbiAgY3JlYXRlUGF0aDogZnVuY3Rpb24ocGF0aERhdGEpIHtcbiAgICB2YXIgcGF0aCA9IHRoaXMuY2FsbFN1cGVyKCdjcmVhdGVQYXRoJywgcGF0aERhdGEpLFxuICAgICAgICB0b3BMZWZ0ID0gcGF0aC5fZ2V0TGVmdFRvcENvb3JkcygpLnNjYWxhckFkZChwYXRoLnN0cm9rZVdpZHRoIC8gMik7XG5cbiAgICBwYXRoLnN0cm9rZSA9IG5ldyBmYWJyaWMuUGF0dGVybih7XG4gICAgICBzb3VyY2U6IHRoaXMuc291cmNlIHx8IHRoaXMuZ2V0UGF0dGVyblNyY0Z1bmN0aW9uKCksXG4gICAgICBvZmZzZXRYOiAtdG9wTGVmdC54LFxuICAgICAgb2Zmc2V0WTogLXRvcExlZnQueVxuICAgIH0pO1xuICAgIHJldHVybiBwYXRoO1xuICB9XG59KTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGdldFBvaW50ZXIgPSBmYWJyaWMudXRpbC5nZXRQb2ludGVyLFxuICAgICAgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgICByYWRpYW5zVG9EZWdyZWVzID0gZmFicmljLnV0aWwucmFkaWFuc1RvRGVncmVlcyxcbiAgICAgIGF0YW4yID0gTWF0aC5hdGFuMixcbiAgICAgIGFicyA9IE1hdGguYWJzLFxuICAgICAgc3VwcG9ydExpbmVEYXNoID0gZmFicmljLlN0YXRpY0NhbnZhcy5zdXBwb3J0cygnc2V0TGluZURhc2gnKSxcblxuICAgICAgU1RST0tFX09GRlNFVCA9IDAuNTtcblxuICAvKipcbiAgICogQ2FudmFzIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuQ2FudmFzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXNcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTEjY2FudmFzfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuQ2FudmFzI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqXG4gICAqIEBmaXJlcyBvYmplY3Q6YWRkZWRcbiAgICogQGZpcmVzIG9iamVjdDptb2RpZmllZFxuICAgKiBAZmlyZXMgb2JqZWN0OnJvdGF0aW5nXG4gICAqIEBmaXJlcyBvYmplY3Q6c2NhbGluZ1xuICAgKiBAZmlyZXMgb2JqZWN0Om1vdmluZ1xuICAgKiBAZmlyZXMgb2JqZWN0OnNlbGVjdGVkXG4gICAqXG4gICAqIEBmaXJlcyBiZWZvcmU6c2VsZWN0aW9uOmNsZWFyZWRcbiAgICogQGZpcmVzIHNlbGVjdGlvbjpjbGVhcmVkXG4gICAqIEBmaXJlcyBzZWxlY3Rpb246Y3JlYXRlZFxuICAgKlxuICAgKiBAZmlyZXMgcGF0aDpjcmVhdGVkXG4gICAqIEBmaXJlcyBtb3VzZTpkb3duXG4gICAqIEBmaXJlcyBtb3VzZTptb3ZlXG4gICAqIEBmaXJlcyBtb3VzZTp1cFxuICAgKiBAZmlyZXMgbW91c2U6b3ZlclxuICAgKiBAZmlyZXMgbW91c2U6b3V0XG4gICAqXG4gICAqL1xuICBmYWJyaWMuQ2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLlN0YXRpY0NhbnZhcywgLyoqIEBsZW5kcyBmYWJyaWMuQ2FudmFzLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBTdHJpbmd9IGVsICZsdDtjYW52YXM+IGVsZW1lbnQgdG8gaW5pdGlhbGl6ZSBpbnN0YW5jZSBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHRoaXMuX2luaXRTdGF0aWMoZWwsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5faW5pdEludGVyYWN0aXZlKCk7XG4gICAgICB0aGlzLl9jcmVhdGVDYWNoZUNhbnZhcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdHMgY2FuIGJlIHRyYW5zZm9ybWVkIGJ5IG9uZSBzaWRlICh1bnByb3BvcnRpb25hbGx5KVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHVuaVNjYWxlVHJhbnNmb3JtOiAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoaWNoIGtleSBlbmFibGUgdW5wcm9wb3J0aW9uYWwgc2NhbGluZ1xuICAgICAqIHZhbHVlczogJ2FsdEtleScsICdzaGlmdEtleScsICdjdHJsS2V5Jy5cbiAgICAgKiBJZiBgbnVsbGAgb3IgJ25vbmUnIG9yIGFueSBvdGhlciBzdHJpbmcgdGhhdCBpcyBub3QgYSBtb2RpZmllciBrZXlcbiAgICAgKiBmZWF0dXJlIGlzIGRpc2FibGVkIGZlYXR1cmUgZGlzYWJsZWQuXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB1bmlTY2FsZUtleTogICAgICAgICAgICdzaGlmdEtleScsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdHMgdXNlIGNlbnRlciBwb2ludCBhcyB0aGUgb3JpZ2luIG9mIHNjYWxlIHRyYW5zZm9ybWF0aW9uLlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgcmVwbGFjZXMgXCJjZW50ZXJUcmFuc2Zvcm1cIiAoQm9vbGVhbikuXG4gICAgICogQHNpbmNlIDEuMy40XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2VudGVyZWRTY2FsaW5nOiAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdHMgdXNlIGNlbnRlciBwb2ludCBhcyB0aGUgb3JpZ2luIG9mIHJvdGF0ZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHJlcGxhY2VzIFwiY2VudGVyVHJhbnNmb3JtXCIgKEJvb2xlYW4pLlxuICAgICAqIEBzaW5jZSAxLjMuNFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNlbnRlcmVkUm90YXRpb246ICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoaWNoIGtleSBlbmFibGUgY2VudGVyZWQgVHJhbnNmcm9tXG4gICAgICogdmFsdWVzOiAnYWx0S2V5JywgJ3NoaWZ0S2V5JywgJ2N0cmxLZXknLlxuICAgICAqIElmIGBudWxsYCBvciAnbm9uZScgb3IgYW55IG90aGVyIHN0cmluZyB0aGF0IGlzIG5vdCBhIG1vZGlmaWVyIGtleVxuICAgICAqIGZlYXR1cmUgaXMgZGlzYWJsZWQgZmVhdHVyZSBkaXNhYmxlZC5cbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNlbnRlcmVkS2V5OiAgICAgICAgICAgJ2FsdEtleScsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hpY2gga2V5IGVuYWJsZSBhbHRlcm5hdGUgYWN0aW9uIG9uIGNvcm5lclxuICAgICAqIHZhbHVlczogJ2FsdEtleScsICdzaGlmdEtleScsICdjdHJsS2V5Jy5cbiAgICAgKiBJZiBgbnVsbGAgb3IgJ25vbmUnIG9yIGFueSBvdGhlciBzdHJpbmcgdGhhdCBpcyBub3QgYSBtb2RpZmllciBrZXlcbiAgICAgKiBmZWF0dXJlIGlzIGRpc2FibGVkIGZlYXR1cmUgZGlzYWJsZWQuXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBhbHRBY3Rpb25LZXk6ICAgICAgICAgICAnc2hpZnRLZXknLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgY2FudmFzIGlzIGludGVyYWN0aXZlLiBUaGlzIHByb3BlcnR5IHNob3VsZCBub3QgYmUgY2hhbmdlZC5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbnRlcmFjdGl2ZTogICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgZ3JvdXAgc2VsZWN0aW9uIHNob3VsZCBiZSBlbmFibGVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uOiAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGljaCBrZXkgZW5hYmxlIG11bHRpcGxlIGNsaWNrIHNlbGVjdGlvblxuICAgICAqIHZhbHVlczogJ2FsdEtleScsICdzaGlmdEtleScsICdjdHJsS2V5Jy5cbiAgICAgKiBJZiBgbnVsbGAgb3IgJ25vbmUnIG9yIGFueSBvdGhlciBzdHJpbmcgdGhhdCBpcyBub3QgYSBtb2RpZmllciBrZXlcbiAgICAgKiBmZWF0dXJlIGlzIGRpc2FibGVkIGZlYXR1cmUgZGlzYWJsZWQuXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25LZXk6ICAgICAgICAgICAnc2hpZnRLZXknLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoaWNoIGtleSBlbmFibGUgYWx0ZXJuYXRpdmUgc2VsZWN0aW9uXG4gICAgICogaW4gY2FzZSBvZiB0YXJnZXQgb3ZlcmxhcHBpbmcgd2l0aCBhY3RpdmUgb2JqZWN0XG4gICAgICogdmFsdWVzOiAnYWx0S2V5JywgJ3NoaWZ0S2V5JywgJ2N0cmxLZXknLlxuICAgICAqIElmIGBudWxsYCBvciAnbm9uZScgb3IgYW55IG90aGVyIHN0cmluZyB0aGF0IGlzIG5vdCBhIG1vZGlmaWVyIGtleVxuICAgICAqIGZlYXR1cmUgaXMgZGlzYWJsZWQgZmVhdHVyZSBkaXNhYmxlZC5cbiAgICAgKiBAc2luY2UgMS42LjVcbiAgICAgKiBAdHlwZSBudWxsfFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYWx0U2VsZWN0aW9uS2V5OiAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIHNlbGVjdGlvblxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uQ29sb3I6ICAgICAgICAgJ3JnYmEoMTAwLCAxMDAsIDI1NSwgMC4zKScsIC8vIGJsdWVcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgZGFzaCBhcnJheSBwYXR0ZXJuXG4gICAgICogSWYgbm90IGVtcHR5IHRoZSBzZWxlY3Rpb24gYm9yZGVyIGlzIGRhc2hlZFxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc2VsZWN0aW9uRGFzaEFycmF5OiAgICAgW10sXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiB0aGUgYm9yZGVyIG9mIHNlbGVjdGlvbiAodXN1YWxseSBzbGlnaHRseSBkYXJrZXIgdGhhbiBjb2xvciBvZiBzZWxlY3Rpb24gaXRzZWxmKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uQm9yZGVyQ29sb3I6ICAgJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKScsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBhIGxpbmUgdXNlZCBpbiBvYmplY3QvZ3JvdXAgc2VsZWN0aW9uXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25MaW5lV2lkdGg6ICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCB3aGVuIGhvdmVyaW5nIG92ZXIgYW4gb2JqZWN0IG9uIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaG92ZXJDdXJzb3I6ICAgICAgICAgICAgJ21vdmUnLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCB3aGVuIG1vdmluZyBhbiBvYmplY3Qgb24gY2FudmFzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtb3ZlQ3Vyc29yOiAgICAgICAgICAgICAnbW92ZScsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGN1cnNvciB2YWx1ZSB1c2VkIGZvciB0aGUgZW50aXJlIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZGVmYXVsdEN1cnNvcjogICAgICAgICAgJ2RlZmF1bHQnLFxuXG4gICAgLyoqXG4gICAgICogQ3Vyc29yIHZhbHVlIHVzZWQgZHVyaW5nIGZyZWUgZHJhd2luZ1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZnJlZURyYXdpbmdDdXJzb3I6ICAgICAgJ2Nyb3NzaGFpcicsXG5cbiAgICAvKipcbiAgICAgKiBDdXJzb3IgdmFsdWUgdXNlZCBmb3Igcm90YXRpb24gcG9pbnRcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJvdGF0aW9uQ3Vyc29yOiAgICAgICAgICdjcm9zc2hhaXInLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBlbGVtZW50IGNsYXNzIHRoYXQncyBnaXZlbiB0byB3cmFwcGVyIChkaXYpIGVsZW1lbnQgb2YgY2FudmFzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb250YWluZXJDbGFzczogICAgICAgICAnY2FudmFzLWNvbnRhaW5lcicsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdCBkZXRlY3Rpb24gaGFwcGVucyBvbiBwZXItcGl4ZWwgYmFzaXMgcmF0aGVyIHRoYW4gb24gcGVyLWJvdW5kaW5nLWJveFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBlclBpeGVsVGFyZ2V0RmluZDogICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIHBpeGVscyBhcm91bmQgdGFyZ2V0IHBpeGVsIHRvIHRvbGVyYXRlIChjb25zaWRlciBhY3RpdmUpIGR1cmluZyBvYmplY3QgZGV0ZWN0aW9uXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0YXJnZXRGaW5kVG9sZXJhbmNlOiAgICAwLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCB0YXJnZXQgZGV0ZWN0aW9uIGlzIHNraXBwZWQgd2hlbiBob3ZlcmluZyBvdmVyIGNhbnZhcy4gVGhpcyBjYW4gYmUgdXNlZCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNraXBUYXJnZXRGaW5kOiAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBtb3VzZSBldmVudHMgb24gY2FudmFzIChtb3VzZWRvd24vbW91c2Vtb3ZlL21vdXNldXApIHJlc3VsdCBpbiBmcmVlIGRyYXdpbmcuXG4gICAgICogQWZ0ZXIgbW91c2Vkb3duLCBtb3VzZW1vdmUgY3JlYXRlcyBhIHNoYXBlLFxuICAgICAqIGFuZCB0aGVuIG1vdXNldXAgZmluYWxpemVzIGl0IGFuZCBhZGRzIGFuIGluc3RhbmNlIG9mIGBmYWJyaWMuUGF0aGAgb250byBjYW52YXMuXG4gICAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTQjZnJlZV9kcmF3aW5nfVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGlzRHJhd2luZ01vZGU6ICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgb2JqZWN0cyBzaG91bGQgcmVtYWluIGluIGN1cnJlbnQgc3RhY2sgcG9zaXRpb24gd2hlbiBzZWxlY3RlZC5cbiAgICAgKiBXaGVuIGZhbHNlIG9iamVjdHMgYXJlIGJyb3VnaHQgdG8gdG9wIGFuZCByZW5kZXJlZCBhcyBwYXJ0IG9mIHRoZSBzZWxlY3Rpb24gZ3JvdXBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwcmVzZXJ2ZU9iamVjdFN0YWNraW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgYW5nbGUgdGhhdCBhbiBvYmplY3Qgd2lsbCBsb2NrIHRvIHdoaWxlIHJvdGF0aW5nLlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBzaW5jZSAxLjYuN1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc25hcEFuZ2xlOiAwLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBzbmFwQW5nbGUgdGhlIHJvdGF0aW9uIHdpbGwgbG9jayB0byB0aGUgc25hcEFuZ2xlLlxuICAgICAqIFdoZW4gYG51bGxgLCB0aGUgc25hcFRocmVzaG9sZCB3aWxsIGRlZmF1bHQgdG8gdGhlIHNuYXBBbmdsZS5cbiAgICAgKiBAdHlwZSBudWxsfE51bWJlclxuICAgICAqIEBzaW5jZSAxLjYuN1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc25hcFRocmVzaG9sZDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgcmlnaHQgY2xpY2sgb24gY2FudmFzIGNhbiBvdXRwdXQgdGhlIGNvbnRleHQgbWVudSBvciBub3RcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQHNpbmNlIDEuNi41XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdG9wQ29udGV4dE1lbnU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSBjYW52YXMgY2FuIGZpcmUgcmlnaHQgY2xpY2sgZXZlbnRzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBzaW5jZSAxLjYuNVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZmlyZVJpZ2h0Q2xpY2s6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdEludGVyYWN0aXZlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0gPSBudWxsO1xuICAgICAgdGhpcy5fZ3JvdXBTZWxlY3RvciA9IG51bGw7XG4gICAgICB0aGlzLl9pbml0V3JhcHBlckVsZW1lbnQoKTtcbiAgICAgIHRoaXMuX2NyZWF0ZVVwcGVyQ2FudmFzKCk7XG4gICAgICB0aGlzLl9pbml0RXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgICAgdGhpcy5faW5pdFJldGluYVNjYWxpbmcoKTtcblxuICAgICAgdGhpcy5mcmVlRHJhd2luZ0JydXNoID0gZmFicmljLlBlbmNpbEJydXNoICYmIG5ldyBmYWJyaWMuUGVuY2lsQnJ1c2godGhpcyk7XG5cbiAgICAgIHRoaXMuY2FsY09mZnNldCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIG9iamVjdHMgaW4gdHdvIGdyb3Vwcywgb25lIHRvIHJlbmRlciBpbW1lZGlhdGVseVxuICAgICAqIGFuZCBvbmUgdG8gcmVuZGVyIGFzIGFjdGl2ZUdyb3VwLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBvYmplY3RzIHRvIHJlbmRlciBpbW1lZGlhdGVseSBhbmQgcHVzaGVzIHRoZSBvdGhlciBpbiB0aGUgYWN0aXZlR3JvdXAuXG4gICAgICovXG4gICAgX2Nob29zZU9iamVjdHNUb1JlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYWN0aXZlR3JvdXAgPSB0aGlzLmdldEFjdGl2ZUdyb3VwKCksXG4gICAgICAgICAgYWN0aXZlT2JqZWN0ID0gdGhpcy5nZXRBY3RpdmVPYmplY3QoKSxcbiAgICAgICAgICBvYmplY3QsIG9ianNUb1JlbmRlciA9IFtdLCBhY3RpdmVHcm91cE9iamVjdHMgPSBbXTtcblxuICAgICAgaWYgKChhY3RpdmVHcm91cCB8fCBhY3RpdmVPYmplY3QpICYmICF0aGlzLnByZXNlcnZlT2JqZWN0U3RhY2tpbmcpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvYmplY3QgPSB0aGlzLl9vYmplY3RzW2ldO1xuICAgICAgICAgIGlmICgoIWFjdGl2ZUdyb3VwIHx8ICFhY3RpdmVHcm91cC5jb250YWlucyhvYmplY3QpKSAmJiBvYmplY3QgIT09IGFjdGl2ZU9iamVjdCkge1xuICAgICAgICAgICAgb2Jqc1RvUmVuZGVyLnB1c2gob2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY3RpdmVHcm91cE9iamVjdHMucHVzaChvYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aXZlR3JvdXApIHtcbiAgICAgICAgICBhY3RpdmVHcm91cC5fc2V0KCdfb2JqZWN0cycsIGFjdGl2ZUdyb3VwT2JqZWN0cyk7XG4gICAgICAgICAgb2Jqc1RvUmVuZGVyLnB1c2goYWN0aXZlR3JvdXApO1xuICAgICAgICB9XG4gICAgICAgIGFjdGl2ZU9iamVjdCAmJiBvYmpzVG9SZW5kZXIucHVzaChhY3RpdmVPYmplY3QpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9ianNUb1JlbmRlciA9IHRoaXMuX29iamVjdHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Jqc1RvUmVuZGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGJvdGggdGhlIHRvcCBjYW52YXMgYW5kIHRoZSBzZWNvbmRhcnkgY29udGFpbmVyIGNhbnZhcy5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZW5kZXJBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRleHRUb3BEaXJ0eSAmJiAhdGhpcy5fZ3JvdXBTZWxlY3RvciAmJiAhdGhpcy5pc0RyYXdpbmdNb2RlKSB7XG4gICAgICAgIHRoaXMuY2xlYXJDb250ZXh0KHRoaXMuY29udGV4dFRvcCk7XG4gICAgICAgIHRoaXMuY29udGV4dFRvcERpcnR5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgY2FudmFzVG9EcmF3T24gPSB0aGlzLmNvbnRleHRDb250YWluZXI7XG4gICAgICB0aGlzLnJlbmRlckNhbnZhcyhjYW52YXNUb0RyYXdPbiwgdGhpcy5fY2hvb3NlT2JqZWN0c1RvUmVuZGVyKCkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byByZW5kZXIgb25seSB0aGUgdG9wIGNhbnZhcy5cbiAgICAgKiBBbHNvIHVzZWQgdG8gcmVuZGVyIHRoZSBncm91cCBzZWxlY3Rpb24gYm94LlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVuZGVyVG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0VG9wO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHQoY3R4KTtcblxuICAgICAgLy8gd2UgcmVuZGVyIHRoZSB0b3AgY29udGV4dCAtIGxhc3Qgb2JqZWN0XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb24gJiYgdGhpcy5fZ3JvdXBTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLl9kcmF3U2VsZWN0aW9uKGN0eCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmlyZSgnYWZ0ZXI6cmVuZGVyJyk7XG4gICAgICB0aGlzLmNvbnRleHRUb3BEaXJ0eSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBjdXJyZW50IHRyYW5zZm9ybSB0byBpdHMgb3JpZ2luYWwgdmFsdWVzIGFuZCBjaG9vc2VzIHRoZSB0eXBlIG9mIHJlc2l6aW5nIGJhc2VkIG9uIHRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2V0Q3VycmVudFRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm07XG5cbiAgICAgIHQudGFyZ2V0LnNldCh7XG4gICAgICAgIHNjYWxlWDogdC5vcmlnaW5hbC5zY2FsZVgsXG4gICAgICAgIHNjYWxlWTogdC5vcmlnaW5hbC5zY2FsZVksXG4gICAgICAgIHNrZXdYOiB0Lm9yaWdpbmFsLnNrZXdYLFxuICAgICAgICBza2V3WTogdC5vcmlnaW5hbC5za2V3WSxcbiAgICAgICAgbGVmdDogdC5vcmlnaW5hbC5sZWZ0LFxuICAgICAgICB0b3A6IHQub3JpZ2luYWwudG9wXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuX3Nob3VsZENlbnRlclRyYW5zZm9ybSh0LnRhcmdldCkpIHtcbiAgICAgICAgaWYgKHQuYWN0aW9uID09PSAncm90YXRlJykge1xuICAgICAgICAgIHRoaXMuX3NldE9yaWdpblRvQ2VudGVyKHQudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodC5vcmlnaW5YICE9PSAnY2VudGVyJykge1xuICAgICAgICAgICAgaWYgKHQub3JpZ2luWCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICB0Lm1vdXNlWFNpZ24gPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0Lm1vdXNlWFNpZ24gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodC5vcmlnaW5ZICE9PSAnY2VudGVyJykge1xuICAgICAgICAgICAgaWYgKHQub3JpZ2luWSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgICAgdC5tb3VzZVlTaWduID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdC5tb3VzZVlTaWduID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0Lm9yaWdpblggPSAnY2VudGVyJztcbiAgICAgICAgICB0Lm9yaWdpblkgPSAnY2VudGVyJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHQub3JpZ2luWCA9IHQub3JpZ2luYWwub3JpZ2luWDtcbiAgICAgICAgdC5vcmlnaW5ZID0gdC5vcmlnaW5hbC5vcmlnaW5ZO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgcG9pbnQgaXMgY29udGFpbmVkIHdpdGhpbiBhbiBhcmVhIG9mIGdpdmVuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXQgT2JqZWN0IHRvIHRlc3QgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcG9pbnRdIHgseSBvYmplY3Qgb2YgcG9pbnQgY29vcmRpbmF0ZXMgd2Ugd2FudCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHBvaW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYW4gYXJlYSBvZiBnaXZlbiBvYmplY3RcbiAgICAgKi9cbiAgICBjb250YWluc1BvaW50OiBmdW5jdGlvbiAoZSwgdGFyZ2V0LCBwb2ludCkge1xuICAgICAgdmFyIGlnbm9yZVpvb20gPSB0cnVlLFxuICAgICAgICAgIHBvaW50ZXIgPSBwb2ludCB8fCB0aGlzLmdldFBvaW50ZXIoZSwgaWdub3JlWm9vbSksXG4gICAgICAgICAgeHk7XG5cbiAgICAgIGlmICh0YXJnZXQuZ3JvdXAgJiYgdGFyZ2V0Lmdyb3VwID09PSB0aGlzLmdldEFjdGl2ZUdyb3VwKCkpIHtcbiAgICAgICAgeHkgPSB0aGlzLl9ub3JtYWxpemVQb2ludGVyKHRhcmdldC5ncm91cCwgcG9pbnRlcik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgeHkgPSB7IHg6IHBvaW50ZXIueCwgeTogcG9pbnRlci55IH07XG4gICAgICB9XG4gICAgICAvLyBodHRwOi8vd3d3Lmdlb2cudWJjLmNhL2NvdXJzZXMva2xpbmsvZ2lzLm5vdGVzL25jZ2lhL3UzMi5odG1sXG4gICAgICAvLyBodHRwOi8vaWRhdi51Y2RhdmlzLmVkdS9+b2tyZXlsb3MvVEFzaGlwL1NwcmluZzIwMDAvUG9pbnRJblBvbHlnb24uaHRtbFxuICAgICAgcmV0dXJuICh0YXJnZXQuY29udGFpbnNQb2ludCh4eSkgfHwgdGFyZ2V0Ll9maW5kVGFyZ2V0Q29ybmVyKHBvaW50ZXIpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbm9ybWFsaXplUG9pbnRlcjogZnVuY3Rpb24gKG9iamVjdCwgcG9pbnRlcikge1xuICAgICAgdmFyIG0gPSBvYmplY3QuY2FsY1RyYW5zZm9ybU1hdHJpeCgpLFxuICAgICAgICAgIGludmVydGVkTSA9IGZhYnJpYy51dGlsLmludmVydFRyYW5zZm9ybShtKSxcbiAgICAgICAgICB2cHRQb2ludGVyID0gdGhpcy5yZXN0b3JlUG9pbnRlclZwdChwb2ludGVyKTtcbiAgICAgIHJldHVybiBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludCh2cHRQb2ludGVyLCBpbnZlcnRlZE0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIHRyYW5zcGFyZW50IGF0IGEgY2VydGFpbiBsb2NhdGlvblxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0IE9iamVjdCB0byBjaGVja1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IExlZnQgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRvcCBjb29yZGluYXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1RhcmdldFRyYW5zcGFyZW50OiBmdW5jdGlvbiAodGFyZ2V0LCB4LCB5KSB7XG4gICAgICB2YXIgaGFzQm9yZGVycyA9IHRhcmdldC5oYXNCb3JkZXJzLFxuICAgICAgICAgIHRyYW5zcGFyZW50Q29ybmVycyA9IHRhcmdldC50cmFuc3BhcmVudENvcm5lcnMsXG4gICAgICAgICAgY3R4ID0gdGhpcy5jb250ZXh0Q2FjaGUsXG4gICAgICAgICAgb3JpZ2luYWxDb2xvciA9IHRhcmdldC5zZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICAgIHRhcmdldC5oYXNCb3JkZXJzID0gdGFyZ2V0LnRyYW5zcGFyZW50Q29ybmVycyA9IGZhbHNlO1xuICAgICAgdGFyZ2V0LnNlbGVjdGlvbkJhY2tncm91bmRDb2xvciA9ICcnO1xuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybS5hcHBseShjdHgsIHRoaXMudmlld3BvcnRUcmFuc2Zvcm0pO1xuICAgICAgdGFyZ2V0LnJlbmRlcihjdHgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgdGFyZ2V0LmFjdGl2ZSAmJiB0YXJnZXQuX3JlbmRlckNvbnRyb2xzKGN0eCk7XG5cbiAgICAgIHRhcmdldC5oYXNCb3JkZXJzID0gaGFzQm9yZGVycztcbiAgICAgIHRhcmdldC50cmFuc3BhcmVudENvcm5lcnMgPSB0cmFuc3BhcmVudENvcm5lcnM7XG4gICAgICB0YXJnZXQuc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yID0gb3JpZ2luYWxDb2xvcjtcblxuICAgICAgdmFyIGlzVHJhbnNwYXJlbnQgPSBmYWJyaWMudXRpbC5pc1RyYW5zcGFyZW50KFxuICAgICAgICBjdHgsIHgsIHksIHRoaXMudGFyZ2V0RmluZFRvbGVyYW5jZSk7XG5cbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0KGN0eCk7XG5cbiAgICAgIHJldHVybiBpc1RyYW5zcGFyZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfc2hvdWxkQ2xlYXJTZWxlY3Rpb246IGZ1bmN0aW9uIChlLCB0YXJnZXQpIHtcbiAgICAgIHZhciBhY3RpdmVHcm91cCA9IHRoaXMuZ2V0QWN0aXZlR3JvdXAoKSxcbiAgICAgICAgICBhY3RpdmVPYmplY3QgPSB0aGlzLmdldEFjdGl2ZU9iamVjdCgpO1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICAhdGFyZ2V0XG4gICAgICAgIHx8XG4gICAgICAgICh0YXJnZXQgJiZcbiAgICAgICAgICBhY3RpdmVHcm91cCAmJlxuICAgICAgICAgICFhY3RpdmVHcm91cC5jb250YWlucyh0YXJnZXQpICYmXG4gICAgICAgICAgYWN0aXZlR3JvdXAgIT09IHRhcmdldCAmJlxuICAgICAgICAgICFlW3RoaXMuc2VsZWN0aW9uS2V5XSlcbiAgICAgICAgfHxcbiAgICAgICAgKHRhcmdldCAmJiAhdGFyZ2V0LmV2ZW50ZWQpXG4gICAgICAgIHx8XG4gICAgICAgICh0YXJnZXQgJiZcbiAgICAgICAgICAhdGFyZ2V0LnNlbGVjdGFibGUgJiZcbiAgICAgICAgICBhY3RpdmVPYmplY3QgJiZcbiAgICAgICAgICBhY3RpdmVPYmplY3QgIT09IHRhcmdldClcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfc2hvdWxkQ2VudGVyVHJhbnNmb3JtOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0ID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybSxcbiAgICAgICAgICBjZW50ZXJUcmFuc2Zvcm07XG5cbiAgICAgIGlmICh0LmFjdGlvbiA9PT0gJ3NjYWxlJyB8fCB0LmFjdGlvbiA9PT0gJ3NjYWxlWCcgfHwgdC5hY3Rpb24gPT09ICdzY2FsZVknKSB7XG4gICAgICAgIGNlbnRlclRyYW5zZm9ybSA9IHRoaXMuY2VudGVyZWRTY2FsaW5nIHx8IHRhcmdldC5jZW50ZXJlZFNjYWxpbmc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0LmFjdGlvbiA9PT0gJ3JvdGF0ZScpIHtcbiAgICAgICAgY2VudGVyVHJhbnNmb3JtID0gdGhpcy5jZW50ZXJlZFJvdGF0aW9uIHx8IHRhcmdldC5jZW50ZXJlZFJvdGF0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2VudGVyVHJhbnNmb3JtID8gIXQuYWx0S2V5IDogdC5hbHRLZXk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldE9yaWdpbkZyb21Db3JuZXI6IGZ1bmN0aW9uKHRhcmdldCwgY29ybmVyKSB7XG4gICAgICB2YXIgb3JpZ2luID0ge1xuICAgICAgICB4OiB0YXJnZXQub3JpZ2luWCxcbiAgICAgICAgeTogdGFyZ2V0Lm9yaWdpbllcbiAgICAgIH07XG5cbiAgICAgIGlmIChjb3JuZXIgPT09ICdtbCcgfHwgY29ybmVyID09PSAndGwnIHx8IGNvcm5lciA9PT0gJ2JsJykge1xuICAgICAgICBvcmlnaW4ueCA9ICdyaWdodCc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjb3JuZXIgPT09ICdtcicgfHwgY29ybmVyID09PSAndHInIHx8IGNvcm5lciA9PT0gJ2JyJykge1xuICAgICAgICBvcmlnaW4ueCA9ICdsZWZ0JztcbiAgICAgIH1cblxuICAgICAgaWYgKGNvcm5lciA9PT0gJ3RsJyB8fCBjb3JuZXIgPT09ICdtdCcgfHwgY29ybmVyID09PSAndHInKSB7XG4gICAgICAgIG9yaWdpbi55ID0gJ2JvdHRvbSc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjb3JuZXIgPT09ICdibCcgfHwgY29ybmVyID09PSAnbWInIHx8IGNvcm5lciA9PT0gJ2JyJykge1xuICAgICAgICBvcmlnaW4ueSA9ICd0b3AnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3JpZ2luO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRBY3Rpb25Gcm9tQ29ybmVyOiBmdW5jdGlvbih0YXJnZXQsIGNvcm5lciwgZSkge1xuICAgICAgaWYgKCFjb3JuZXIpIHtcbiAgICAgICAgcmV0dXJuICdkcmFnJztcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjb3JuZXIpIHtcbiAgICAgICAgY2FzZSAnbXRyJzpcbiAgICAgICAgICByZXR1cm4gJ3JvdGF0ZSc7XG4gICAgICAgIGNhc2UgJ21sJzpcbiAgICAgICAgY2FzZSAnbXInOlxuICAgICAgICAgIHJldHVybiBlW3RoaXMuYWx0QWN0aW9uS2V5XSA/ICdza2V3WScgOiAnc2NhbGVYJztcbiAgICAgICAgY2FzZSAnbXQnOlxuICAgICAgICBjYXNlICdtYic6XG4gICAgICAgICAgcmV0dXJuIGVbdGhpcy5hbHRBY3Rpb25LZXldID8gJ3NrZXdYJyA6ICdzY2FsZVknO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAnc2NhbGUnO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfc2V0dXBDdXJyZW50VHJhbnNmb3JtOiBmdW5jdGlvbiAoZSwgdGFyZ2V0KSB7XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUpLFxuICAgICAgICAgIGNvcm5lciA9IHRhcmdldC5fZmluZFRhcmdldENvcm5lcih0aGlzLmdldFBvaW50ZXIoZSwgdHJ1ZSkpLFxuICAgICAgICAgIGFjdGlvbiA9IHRoaXMuX2dldEFjdGlvbkZyb21Db3JuZXIodGFyZ2V0LCBjb3JuZXIsIGUpLFxuICAgICAgICAgIG9yaWdpbiA9IHRoaXMuX2dldE9yaWdpbkZyb21Db3JuZXIodGFyZ2V0LCBjb3JuZXIpO1xuXG4gICAgICB0aGlzLl9jdXJyZW50VHJhbnNmb3JtID0ge1xuICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGNvcm5lcjogY29ybmVyLFxuICAgICAgICBzY2FsZVg6IHRhcmdldC5zY2FsZVgsXG4gICAgICAgIHNjYWxlWTogdGFyZ2V0LnNjYWxlWSxcbiAgICAgICAgc2tld1g6IHRhcmdldC5za2V3WCxcbiAgICAgICAgc2tld1k6IHRhcmdldC5za2V3WSxcbiAgICAgICAgb2Zmc2V0WDogcG9pbnRlci54IC0gdGFyZ2V0LmxlZnQsXG4gICAgICAgIG9mZnNldFk6IHBvaW50ZXIueSAtIHRhcmdldC50b3AsXG4gICAgICAgIG9yaWdpblg6IG9yaWdpbi54LFxuICAgICAgICBvcmlnaW5ZOiBvcmlnaW4ueSxcbiAgICAgICAgZXg6IHBvaW50ZXIueCxcbiAgICAgICAgZXk6IHBvaW50ZXIueSxcbiAgICAgICAgbGFzdFg6IHBvaW50ZXIueCxcbiAgICAgICAgbGFzdFk6IHBvaW50ZXIueSxcbiAgICAgICAgbGVmdDogdGFyZ2V0LmxlZnQsXG4gICAgICAgIHRvcDogdGFyZ2V0LnRvcCxcbiAgICAgICAgdGhldGE6IGRlZ3JlZXNUb1JhZGlhbnModGFyZ2V0LmFuZ2xlKSxcbiAgICAgICAgd2lkdGg6IHRhcmdldC53aWR0aCAqIHRhcmdldC5zY2FsZVgsXG4gICAgICAgIG1vdXNlWFNpZ246IDEsXG4gICAgICAgIG1vdXNlWVNpZ246IDEsXG4gICAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5LFxuICAgICAgICBhbHRLZXk6IGVbdGhpcy5jZW50ZXJlZEtleV1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0ub3JpZ2luYWwgPSB7XG4gICAgICAgIGxlZnQ6IHRhcmdldC5sZWZ0LFxuICAgICAgICB0b3A6IHRhcmdldC50b3AsXG4gICAgICAgIHNjYWxlWDogdGFyZ2V0LnNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiB0YXJnZXQuc2NhbGVZLFxuICAgICAgICBza2V3WDogdGFyZ2V0LnNrZXdYLFxuICAgICAgICBza2V3WTogdGFyZ2V0LnNrZXdZLFxuICAgICAgICBvcmlnaW5YOiBvcmlnaW4ueCxcbiAgICAgICAgb3JpZ2luWTogb3JpZ2luLnlcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3Jlc2V0Q3VycmVudFRyYW5zZm9ybSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIG9iamVjdCBieSBcInNldHRpbmdcIiBpdHMgbGVmdC90b3BcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IHBvaW50ZXIncyB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBwb2ludGVyJ3MgeSBjb29yZGluYXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgdHJhbnNsYXRpb24gb2NjdXJyZWRcbiAgICAgKi9cbiAgICBfdHJhbnNsYXRlT2JqZWN0OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sXG4gICAgICAgICAgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCxcbiAgICAgICAgICBuZXdMZWZ0ID0geCAtIHRyYW5zZm9ybS5vZmZzZXRYLFxuICAgICAgICAgIG5ld1RvcCA9IHkgLSB0cmFuc2Zvcm0ub2Zmc2V0WSxcbiAgICAgICAgICBtb3ZlWCA9ICF0YXJnZXQuZ2V0KCdsb2NrTW92ZW1lbnRYJykgJiYgdGFyZ2V0LmxlZnQgIT09IG5ld0xlZnQsXG4gICAgICAgICAgbW92ZVkgPSAhdGFyZ2V0LmdldCgnbG9ja01vdmVtZW50WScpICYmIHRhcmdldC50b3AgIT09IG5ld1RvcDtcblxuICAgICAgbW92ZVggJiYgdGFyZ2V0LnNldCgnbGVmdCcsIG5ld0xlZnQpO1xuICAgICAgbW92ZVkgJiYgdGFyZ2V0LnNldCgndG9wJywgbmV3VG9wKTtcbiAgICAgIHJldHVybiBtb3ZlWCB8fCBtb3ZlWTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgd2UgYXJlIGluY3JlYXNpbmcgYSBwb3NpdGl2ZSBza2V3IG9yIGxvd2VyIGl0LFxuICAgICAqIGNoZWNraW5nIG1vdXNlIGRpcmVjdGlvbiBhbmQgcHJlc3NlZCBjb3JuZXIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2hhbmdlU2tld1RyYW5zZm9ybU9yaWdpbjogZnVuY3Rpb24obW91c2VNb3ZlLCB0LCBieSkge1xuICAgICAgdmFyIHByb3BlcnR5ID0gJ29yaWdpblgnLCBvcmlnaW5zID0geyAwOiAnY2VudGVyJyB9LFxuICAgICAgICAgIHNrZXcgPSB0LnRhcmdldC5za2V3WCwgb3JpZ2luQSA9ICdsZWZ0Jywgb3JpZ2luQiA9ICdyaWdodCcsXG4gICAgICAgICAgY29ybmVyID0gdC5jb3JuZXIgPT09ICdtdCcgfHwgdC5jb3JuZXIgPT09ICdtbCcgPyAxIDogLTEsXG4gICAgICAgICAgZmxpcFNpZ24gPSAxO1xuXG4gICAgICBtb3VzZU1vdmUgPSBtb3VzZU1vdmUgPiAwID8gMSA6IC0xO1xuICAgICAgaWYgKGJ5ID09PSAneScpIHtcbiAgICAgICAgc2tldyA9IHQudGFyZ2V0LnNrZXdZO1xuICAgICAgICBvcmlnaW5BID0gJ3RvcCc7XG4gICAgICAgIG9yaWdpbkIgPSAnYm90dG9tJztcbiAgICAgICAgcHJvcGVydHkgPSAnb3JpZ2luWSc7XG4gICAgICB9XG4gICAgICBvcmlnaW5zWy0xXSA9IG9yaWdpbkE7XG4gICAgICBvcmlnaW5zWzFdID0gb3JpZ2luQjtcblxuICAgICAgdC50YXJnZXQuZmxpcFggJiYgKGZsaXBTaWduICo9IC0xKTtcbiAgICAgIHQudGFyZ2V0LmZsaXBZICYmIChmbGlwU2lnbiAqPSAtMSk7XG5cbiAgICAgIGlmIChza2V3ID09PSAwKSB7XG4gICAgICAgIHQuc2tld1NpZ24gPSAtY29ybmVyICogbW91c2VNb3ZlICogZmxpcFNpZ247XG4gICAgICAgIHRbcHJvcGVydHldID0gb3JpZ2luc1stbW91c2VNb3ZlXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBza2V3ID0gc2tldyA+IDAgPyAxIDogLTE7XG4gICAgICAgIHQuc2tld1NpZ24gPSBza2V3O1xuICAgICAgICB0W3Byb3BlcnR5XSA9IG9yaWdpbnNbc2tldyAqIGNvcm5lciAqIGZsaXBTaWduXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2tldyBvYmplY3QgYnkgbW91c2UgZXZlbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBwb2ludGVyJ3MgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgcG9pbnRlcidzIHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBieSBFaXRoZXIgJ3gnIG9yICd5J1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNrZXdpbmcgb2NjdXJyZWRcbiAgICAgKi9cbiAgICBfc2tld09iamVjdDogZnVuY3Rpb24gKHgsIHksIGJ5KSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sXG4gICAgICAgICAgdGFyZ2V0ID0gdC50YXJnZXQsIHNrZXdlZCA9IGZhbHNlLFxuICAgICAgICAgIGxvY2tTa2V3aW5nWCA9IHRhcmdldC5nZXQoJ2xvY2tTa2V3aW5nWCcpLFxuICAgICAgICAgIGxvY2tTa2V3aW5nWSA9IHRhcmdldC5nZXQoJ2xvY2tTa2V3aW5nWScpO1xuXG4gICAgICBpZiAoKGxvY2tTa2V3aW5nWCAmJiBieSA9PT0gJ3gnKSB8fCAobG9ja1NrZXdpbmdZICYmIGJ5ID09PSAneScpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHRoZSBjb25zdHJhaW50IHBvaW50XG4gICAgICB2YXIgY2VudGVyID0gdGFyZ2V0LmdldENlbnRlclBvaW50KCksXG4gICAgICAgICAgYWN0dWFsTW91c2VCeUNlbnRlciA9IHRhcmdldC50b0xvY2FsUG9pbnQobmV3IGZhYnJpYy5Qb2ludCh4LCB5KSwgJ2NlbnRlcicsICdjZW50ZXInKVtieV0sXG4gICAgICAgICAgbGFzdE1vdXNlQnlDZW50ZXIgPSB0YXJnZXQudG9Mb2NhbFBvaW50KG5ldyBmYWJyaWMuUG9pbnQodC5sYXN0WCwgdC5sYXN0WSksICdjZW50ZXInLCAnY2VudGVyJylbYnldLFxuICAgICAgICAgIGFjdHVhbE1vdXNlQnlPcmlnaW4sIGNvbnN0cmFpbnRQb3NpdGlvbiwgZGltID0gdGFyZ2V0Ll9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKTtcblxuICAgICAgdGhpcy5fY2hhbmdlU2tld1RyYW5zZm9ybU9yaWdpbihhY3R1YWxNb3VzZUJ5Q2VudGVyIC0gbGFzdE1vdXNlQnlDZW50ZXIsIHQsIGJ5KTtcbiAgICAgIGFjdHVhbE1vdXNlQnlPcmlnaW4gPSB0YXJnZXQudG9Mb2NhbFBvaW50KG5ldyBmYWJyaWMuUG9pbnQoeCwgeSksIHQub3JpZ2luWCwgdC5vcmlnaW5ZKVtieV07XG4gICAgICBjb25zdHJhaW50UG9zaXRpb24gPSB0YXJnZXQudHJhbnNsYXRlVG9PcmlnaW5Qb2ludChjZW50ZXIsIHQub3JpZ2luWCwgdC5vcmlnaW5ZKTtcbiAgICAgIC8vIEFjdHVhbGx5IHNrZXcgdGhlIG9iamVjdFxuICAgICAgc2tld2VkID0gdGhpcy5fc2V0T2JqZWN0U2tldyhhY3R1YWxNb3VzZUJ5T3JpZ2luLCB0LCBieSwgZGltKTtcbiAgICAgIHQubGFzdFggPSB4O1xuICAgICAgdC5sYXN0WSA9IHk7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIGNvbnN0cmFpbnRzIGFwcGx5XG4gICAgICB0YXJnZXQuc2V0UG9zaXRpb25CeU9yaWdpbihjb25zdHJhaW50UG9zaXRpb24sIHQub3JpZ2luWCwgdC5vcmlnaW5ZKTtcbiAgICAgIHJldHVybiBza2V3ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBvYmplY3Qgc2tld1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2tld2luZyBvY2N1cnJlZFxuICAgICAqL1xuICAgIF9zZXRPYmplY3RTa2V3OiBmdW5jdGlvbihsb2NhbE1vdXNlLCB0cmFuc2Zvcm0sIGJ5LCBfZGltKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCwgbmV3VmFsdWUsIHNrZXdlZCA9IGZhbHNlLFxuICAgICAgICAgIHNrZXdTaWduID0gdHJhbnNmb3JtLnNrZXdTaWduLCBuZXdEaW0sIGRpbU5vU2tldyxcbiAgICAgICAgICBvdGhlckJ5LCBfb3RoZXJCeSwgX2J5LCBuZXdEaW1Nb3VzZSwgc2tld1gsIHNrZXdZO1xuXG4gICAgICBpZiAoYnkgPT09ICd4Jykge1xuICAgICAgICBvdGhlckJ5ID0gJ3knO1xuICAgICAgICBfb3RoZXJCeSA9ICdZJztcbiAgICAgICAgX2J5ID0gJ1gnO1xuICAgICAgICBza2V3WCA9IDA7XG4gICAgICAgIHNrZXdZID0gdGFyZ2V0LnNrZXdZO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG90aGVyQnkgPSAneCc7XG4gICAgICAgIF9vdGhlckJ5ID0gJ1gnO1xuICAgICAgICBfYnkgPSAnWSc7XG4gICAgICAgIHNrZXdYID0gdGFyZ2V0LnNrZXdYO1xuICAgICAgICBza2V3WSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGRpbU5vU2tldyA9IHRhcmdldC5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKHNrZXdYLCBza2V3WSk7XG4gICAgICBuZXdEaW1Nb3VzZSA9IDIgKiBNYXRoLmFicyhsb2NhbE1vdXNlKSAtIGRpbU5vU2tld1tieV07XG4gICAgICBpZiAobmV3RGltTW91c2UgPD0gMikge1xuICAgICAgICBuZXdWYWx1ZSA9IDA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBza2V3U2lnbiAqIE1hdGguYXRhbigobmV3RGltTW91c2UgLyB0YXJnZXRbJ3NjYWxlJyArIF9ieV0pIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGltTm9Ta2V3W290aGVyQnldIC8gdGFyZ2V0WydzY2FsZScgKyBfb3RoZXJCeV0pKTtcbiAgICAgICAgbmV3VmFsdWUgPSBmYWJyaWMudXRpbC5yYWRpYW5zVG9EZWdyZWVzKG5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHNrZXdlZCA9IHRhcmdldFsnc2tldycgKyBfYnldICE9PSBuZXdWYWx1ZTtcbiAgICAgIHRhcmdldC5zZXQoJ3NrZXcnICsgX2J5LCBuZXdWYWx1ZSk7XG4gICAgICBpZiAodGFyZ2V0Wydza2V3JyArIF9vdGhlckJ5XSAhPT0gMCkge1xuICAgICAgICBuZXdEaW0gPSB0YXJnZXQuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpO1xuICAgICAgICBuZXdWYWx1ZSA9IChfZGltW290aGVyQnldIC8gbmV3RGltW290aGVyQnldKSAqIHRhcmdldFsnc2NhbGUnICsgX290aGVyQnldO1xuICAgICAgICB0YXJnZXQuc2V0KCdzY2FsZScgKyBfb3RoZXJCeSwgbmV3VmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNrZXdlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2NhbGVzIG9iamVjdCBieSBpbnZva2luZyBpdHMgc2NhbGVYL3NjYWxlWSBtZXRob2RzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBwb2ludGVyJ3MgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgcG9pbnRlcidzIHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBieSBFaXRoZXIgJ3gnIG9yICd5JyAtIHNwZWNpZmllcyBkaW1lbnNpb24gY29uc3RyYWludCBieSB3aGljaCB0byBzY2FsZSBhbiBvYmplY3QuXG4gICAgICogICAgICAgICAgICAgICAgICAgIFdoZW4gbm90IHByb3ZpZGVkLCBhbiBvYmplY3QgaXMgc2NhbGVkIGJ5IGJvdGggZGltZW5zaW9ucyBlcXVhbGx5XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2NhbGluZyBvY2N1cnJlZFxuICAgICAqL1xuICAgIF9zY2FsZU9iamVjdDogZnVuY3Rpb24gKHgsIHksIGJ5KSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sXG4gICAgICAgICAgdGFyZ2V0ID0gdC50YXJnZXQsXG4gICAgICAgICAgbG9ja1NjYWxpbmdYID0gdGFyZ2V0LmdldCgnbG9ja1NjYWxpbmdYJyksXG4gICAgICAgICAgbG9ja1NjYWxpbmdZID0gdGFyZ2V0LmdldCgnbG9ja1NjYWxpbmdZJyksXG4gICAgICAgICAgbG9ja1NjYWxpbmdGbGlwID0gdGFyZ2V0LmdldCgnbG9ja1NjYWxpbmdGbGlwJyk7XG5cbiAgICAgIGlmIChsb2NrU2NhbGluZ1ggJiYgbG9ja1NjYWxpbmdZKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHRoZSBjb25zdHJhaW50IHBvaW50XG4gICAgICB2YXIgY29uc3RyYWludFBvc2l0aW9uID0gdGFyZ2V0LnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQodGFyZ2V0LmdldENlbnRlclBvaW50KCksIHQub3JpZ2luWCwgdC5vcmlnaW5ZKSxcbiAgICAgICAgICBsb2NhbE1vdXNlID0gdGFyZ2V0LnRvTG9jYWxQb2ludChuZXcgZmFicmljLlBvaW50KHgsIHkpLCB0Lm9yaWdpblgsIHQub3JpZ2luWSksXG4gICAgICAgICAgZGltID0gdGFyZ2V0Ll9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKSwgc2NhbGVkID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuX3NldExvY2FsTW91c2UobG9jYWxNb3VzZSwgdCk7XG5cbiAgICAgIC8vIEFjdHVhbGx5IHNjYWxlIHRoZSBvYmplY3RcbiAgICAgIHNjYWxlZCA9IHRoaXMuX3NldE9iamVjdFNjYWxlKGxvY2FsTW91c2UsIHQsIGxvY2tTY2FsaW5nWCwgbG9ja1NjYWxpbmdZLCBieSwgbG9ja1NjYWxpbmdGbGlwLCBkaW0pO1xuXG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIGNvbnN0cmFpbnRzIGFwcGx5XG4gICAgICB0YXJnZXQuc2V0UG9zaXRpb25CeU9yaWdpbihjb25zdHJhaW50UG9zaXRpb24sIHQub3JpZ2luWCwgdC5vcmlnaW5ZKTtcbiAgICAgIHJldHVybiBzY2FsZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2NhbGluZyBvY2N1cnJlZFxuICAgICAqL1xuICAgIF9zZXRPYmplY3RTY2FsZTogZnVuY3Rpb24obG9jYWxNb3VzZSwgdHJhbnNmb3JtLCBsb2NrU2NhbGluZ1gsIGxvY2tTY2FsaW5nWSwgYnksIGxvY2tTY2FsaW5nRmxpcCwgX2RpbSkge1xuICAgICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsIGZvcmJpZFNjYWxpbmdYID0gZmFsc2UsIGZvcmJpZFNjYWxpbmdZID0gZmFsc2UsIHNjYWxlZCA9IGZhbHNlLFxuICAgICAgICAgIGNoYW5nZVgsIGNoYW5nZVksIHNjYWxlWCwgc2NhbGVZO1xuXG4gICAgICBzY2FsZVggPSBsb2NhbE1vdXNlLnggKiB0YXJnZXQuc2NhbGVYIC8gX2RpbS54O1xuICAgICAgc2NhbGVZID0gbG9jYWxNb3VzZS55ICogdGFyZ2V0LnNjYWxlWSAvIF9kaW0ueTtcbiAgICAgIGNoYW5nZVggPSB0YXJnZXQuc2NhbGVYICE9PSBzY2FsZVg7XG4gICAgICBjaGFuZ2VZID0gdGFyZ2V0LnNjYWxlWSAhPT0gc2NhbGVZO1xuXG4gICAgICBpZiAobG9ja1NjYWxpbmdGbGlwICYmIHNjYWxlWCA8PSAwICYmIHNjYWxlWCA8IHRhcmdldC5zY2FsZVgpIHtcbiAgICAgICAgZm9yYmlkU2NhbGluZ1ggPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobG9ja1NjYWxpbmdGbGlwICYmIHNjYWxlWSA8PSAwICYmIHNjYWxlWSA8IHRhcmdldC5zY2FsZVkpIHtcbiAgICAgICAgZm9yYmlkU2NhbGluZ1kgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnkgPT09ICdlcXVhbGx5JyAmJiAhbG9ja1NjYWxpbmdYICYmICFsb2NrU2NhbGluZ1kpIHtcbiAgICAgICAgZm9yYmlkU2NhbGluZ1ggfHwgZm9yYmlkU2NhbGluZ1kgfHwgKHNjYWxlZCA9IHRoaXMuX3NjYWxlT2JqZWN0RXF1YWxseShsb2NhbE1vdXNlLCB0YXJnZXQsIHRyYW5zZm9ybSwgX2RpbSkpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIWJ5KSB7XG4gICAgICAgIGZvcmJpZFNjYWxpbmdYIHx8IGxvY2tTY2FsaW5nWCB8fCAodGFyZ2V0LnNldCgnc2NhbGVYJywgc2NhbGVYKSAmJiAoc2NhbGVkID0gc2NhbGVkIHx8IGNoYW5nZVgpKTtcbiAgICAgICAgZm9yYmlkU2NhbGluZ1kgfHwgbG9ja1NjYWxpbmdZIHx8ICh0YXJnZXQuc2V0KCdzY2FsZVknLCBzY2FsZVkpICYmIChzY2FsZWQgPSBzY2FsZWQgfHwgY2hhbmdlWSkpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYnkgPT09ICd4JyAmJiAhdGFyZ2V0LmdldCgnbG9ja1VuaVNjYWxpbmcnKSkge1xuICAgICAgICBmb3JiaWRTY2FsaW5nWCB8fCBsb2NrU2NhbGluZ1ggfHwgKHRhcmdldC5zZXQoJ3NjYWxlWCcsIHNjYWxlWCkgJiYgKHNjYWxlZCA9IHNjYWxlZCB8fCBjaGFuZ2VYKSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChieSA9PT0gJ3knICYmICF0YXJnZXQuZ2V0KCdsb2NrVW5pU2NhbGluZycpKSB7XG4gICAgICAgIGZvcmJpZFNjYWxpbmdZIHx8IGxvY2tTY2FsaW5nWSB8fCAodGFyZ2V0LnNldCgnc2NhbGVZJywgc2NhbGVZKSAmJiAoc2NhbGVkID0gc2NhbGVkIHx8IGNoYW5nZVkpKTtcbiAgICAgIH1cbiAgICAgIHRyYW5zZm9ybS5uZXdTY2FsZVggPSBzY2FsZVg7XG4gICAgICB0cmFuc2Zvcm0ubmV3U2NhbGVZID0gc2NhbGVZO1xuICAgICAgZm9yYmlkU2NhbGluZ1ggfHwgZm9yYmlkU2NhbGluZ1kgfHwgdGhpcy5fZmxpcE9iamVjdCh0cmFuc2Zvcm0sIGJ5KTtcbiAgICAgIHJldHVybiBzY2FsZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2NhbGluZyBvY2N1cnJlZFxuICAgICAqL1xuICAgIF9zY2FsZU9iamVjdEVxdWFsbHk6IGZ1bmN0aW9uKGxvY2FsTW91c2UsIHRhcmdldCwgdHJhbnNmb3JtLCBfZGltKSB7XG5cbiAgICAgIHZhciBkaXN0ID0gbG9jYWxNb3VzZS55ICsgbG9jYWxNb3VzZS54LFxuICAgICAgICAgIGxhc3REaXN0ID0gX2RpbS55ICogdHJhbnNmb3JtLm9yaWdpbmFsLnNjYWxlWSAvIHRhcmdldC5zY2FsZVkgK1xuICAgICAgICAgICAgICAgICAgICAgX2RpbS54ICogdHJhbnNmb3JtLm9yaWdpbmFsLnNjYWxlWCAvIHRhcmdldC5zY2FsZVgsXG4gICAgICAgICAgc2NhbGVkO1xuXG4gICAgICAvLyBXZSB1c2UgdHJhbnNmb3JtLnNjYWxlWC9ZIGluc3RlYWQgb2YgdGFyZ2V0LnNjYWxlWC9ZXG4gICAgICAvLyBiZWNhdXNlIHRoZSBvYmplY3QgbWF5IGhhdmUgYSBtaW4gc2NhbGUgYW5kIHdlJ2xsIGxvb3NlIHRoZSBwcm9wb3J0aW9uc1xuICAgICAgdHJhbnNmb3JtLm5ld1NjYWxlWCA9IHRyYW5zZm9ybS5vcmlnaW5hbC5zY2FsZVggKiBkaXN0IC8gbGFzdERpc3Q7XG4gICAgICB0cmFuc2Zvcm0ubmV3U2NhbGVZID0gdHJhbnNmb3JtLm9yaWdpbmFsLnNjYWxlWSAqIGRpc3QgLyBsYXN0RGlzdDtcbiAgICAgIHNjYWxlZCA9IHRyYW5zZm9ybS5uZXdTY2FsZVggIT09IHRhcmdldC5zY2FsZVggfHwgdHJhbnNmb3JtLm5ld1NjYWxlWSAhPT0gdGFyZ2V0LnNjYWxlWTtcbiAgICAgIHRhcmdldC5zZXQoJ3NjYWxlWCcsIHRyYW5zZm9ybS5uZXdTY2FsZVgpO1xuICAgICAgdGFyZ2V0LnNldCgnc2NhbGVZJywgdHJhbnNmb3JtLm5ld1NjYWxlWSk7XG4gICAgICByZXR1cm4gc2NhbGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9mbGlwT2JqZWN0OiBmdW5jdGlvbih0cmFuc2Zvcm0sIGJ5KSB7XG4gICAgICBpZiAodHJhbnNmb3JtLm5ld1NjYWxlWCA8IDAgJiYgYnkgIT09ICd5Jykge1xuICAgICAgICBpZiAodHJhbnNmb3JtLm9yaWdpblggPT09ICdsZWZ0Jykge1xuICAgICAgICAgIHRyYW5zZm9ybS5vcmlnaW5YID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0cmFuc2Zvcm0ub3JpZ2luWCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIHRyYW5zZm9ybS5vcmlnaW5YID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFuc2Zvcm0ubmV3U2NhbGVZIDwgMCAmJiBieSAhPT0gJ3gnKSB7XG4gICAgICAgIGlmICh0cmFuc2Zvcm0ub3JpZ2luWSA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICB0cmFuc2Zvcm0ub3JpZ2luWSA9ICdib3R0b20nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRyYW5zZm9ybS5vcmlnaW5ZID09PSAnYm90dG9tJykge1xuICAgICAgICAgIHRyYW5zZm9ybS5vcmlnaW5ZID0gJ3RvcCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0TG9jYWxNb3VzZTogZnVuY3Rpb24obG9jYWxNb3VzZSwgdCkge1xuICAgICAgdmFyIHRhcmdldCA9IHQudGFyZ2V0O1xuXG4gICAgICBpZiAodC5vcmlnaW5YID09PSAncmlnaHQnKSB7XG4gICAgICAgIGxvY2FsTW91c2UueCAqPSAtMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHQub3JpZ2luWCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgbG9jYWxNb3VzZS54ICo9IHQubW91c2VYU2lnbiAqIDI7XG4gICAgICAgIGlmIChsb2NhbE1vdXNlLnggPCAwKSB7XG4gICAgICAgICAgdC5tb3VzZVhTaWduID0gLXQubW91c2VYU2lnbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodC5vcmlnaW5ZID09PSAnYm90dG9tJykge1xuICAgICAgICBsb2NhbE1vdXNlLnkgKj0gLTE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0Lm9yaWdpblkgPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGxvY2FsTW91c2UueSAqPSB0Lm1vdXNlWVNpZ24gKiAyO1xuICAgICAgICBpZiAobG9jYWxNb3VzZS55IDwgMCkge1xuICAgICAgICAgIHQubW91c2VZU2lnbiA9IC10Lm1vdXNlWVNpZ247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gYWRqdXN0IHRoZSBtb3VzZSBjb29yZGluYXRlcyB3aGVuIGRlYWxpbmcgd2l0aCBwYWRkaW5nXG4gICAgICBpZiAoYWJzKGxvY2FsTW91c2UueCkgPiB0YXJnZXQucGFkZGluZykge1xuICAgICAgICBpZiAobG9jYWxNb3VzZS54IDwgMCkge1xuICAgICAgICAgIGxvY2FsTW91c2UueCArPSB0YXJnZXQucGFkZGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsb2NhbE1vdXNlLnggLT0gdGFyZ2V0LnBhZGRpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgeyAvLyBtb3VzZSBpcyB3aXRoaW4gdGhlIHBhZGRpbmcsIHNldCB0byAwXG4gICAgICAgIGxvY2FsTW91c2UueCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChhYnMobG9jYWxNb3VzZS55KSA+IHRhcmdldC5wYWRkaW5nKSB7XG4gICAgICAgIGlmIChsb2NhbE1vdXNlLnkgPCAwKSB7XG4gICAgICAgICAgbG9jYWxNb3VzZS55ICs9IHRhcmdldC5wYWRkaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGxvY2FsTW91c2UueSAtPSB0YXJnZXQucGFkZGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxvY2FsTW91c2UueSA9IDA7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgb2JqZWN0IGJ5IGludm9raW5nIGl0cyByb3RhdGUgbWV0aG9kXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBwb2ludGVyJ3MgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgcG9pbnRlcidzIHkgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHJvdGF0aW9uIG9jY3VycmVkXG4gICAgICovXG4gICAgX3JvdGF0ZU9iamVjdDogZnVuY3Rpb24gKHgsIHkpIHtcblxuICAgICAgdmFyIHQgPSB0aGlzLl9jdXJyZW50VHJhbnNmb3JtO1xuXG4gICAgICBpZiAodC50YXJnZXQuZ2V0KCdsb2NrUm90YXRpb24nKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBsYXN0QW5nbGUgPSBhdGFuMih0LmV5IC0gdC50b3AsIHQuZXggLSB0LmxlZnQpLFxuICAgICAgICAgIGN1ckFuZ2xlID0gYXRhbjIoeSAtIHQudG9wLCB4IC0gdC5sZWZ0KSxcbiAgICAgICAgICBhbmdsZSA9IHJhZGlhbnNUb0RlZ3JlZXMoY3VyQW5nbGUgLSBsYXN0QW5nbGUgKyB0LnRoZXRhKSxcbiAgICAgICAgICBoYXNSb2F0ZWQgPSB0cnVlO1xuXG4gICAgICAvLyBub3JtYWxpemUgYW5nbGUgdG8gcG9zaXRpdmUgdmFsdWVcbiAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgYW5nbGUgPSAzNjAgKyBhbmdsZTtcbiAgICAgIH1cblxuICAgICAgYW5nbGUgJT0gMzYwO1xuXG4gICAgICBpZiAodC50YXJnZXQuc25hcEFuZ2xlID4gMCkge1xuICAgICAgICB2YXIgc25hcEFuZ2xlICA9IHQudGFyZ2V0LnNuYXBBbmdsZSxcbiAgICAgICAgICAgIHNuYXBUaHJlc2hvbGQgID0gdC50YXJnZXQuc25hcFRocmVzaG9sZCB8fCBzbmFwQW5nbGUsXG4gICAgICAgICAgICByaWdodEFuZ2xlTG9ja2VkID0gTWF0aC5jZWlsKGFuZ2xlIC8gc25hcEFuZ2xlKSAqIHNuYXBBbmdsZSxcbiAgICAgICAgICAgIGxlZnRBbmdsZUxvY2tlZCA9IE1hdGguZmxvb3IoYW5nbGUgLyBzbmFwQW5nbGUpICogc25hcEFuZ2xlO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhhbmdsZSAtIGxlZnRBbmdsZUxvY2tlZCkgPCBzbmFwVGhyZXNob2xkKSB7XG4gICAgICAgICAgYW5nbGUgPSBsZWZ0QW5nbGVMb2NrZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoTWF0aC5hYnMoYW5nbGUgLSByaWdodEFuZ2xlTG9ja2VkKSA8IHNuYXBUaHJlc2hvbGQpIHtcbiAgICAgICAgICBhbmdsZSA9IHJpZ2h0QW5nbGVMb2NrZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodC50YXJnZXQuYW5nbGUgPT09IGFuZ2xlKSB7XG4gICAgICAgICAgaGFzUm9hdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdC50YXJnZXQuYW5nbGUgPSBhbmdsZTtcbiAgICAgIHJldHVybiBoYXNSb2F0ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY3Vyc29yIHR5cGUgb2YgdGhlIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIEN1cnNvciB0eXBlIG9mIHRoZSBjYW52YXMgZWxlbWVudC5cbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtdWkvI2N1cnNvclxuICAgICAqL1xuICAgIHNldEN1cnNvcjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB0aGlzLnVwcGVyQ2FudmFzRWwuc3R5bGUuY3Vyc29yID0gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0IHRvIHJlc2V0IHRyYW5zZm9ybVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2V0T2JqZWN0VHJhbnNmb3JtOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICB0YXJnZXQuc2NhbGVYID0gMTtcbiAgICAgIHRhcmdldC5zY2FsZVkgPSAxO1xuICAgICAgdGFyZ2V0LnNrZXdYID0gMDtcbiAgICAgIHRhcmdldC5za2V3WSA9IDA7XG4gICAgICB0YXJnZXQuc2V0QW5nbGUoMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCB0byBkcmF3IHRoZSBzZWxlY3Rpb24gb25cbiAgICAgKi9cbiAgICBfZHJhd1NlbGVjdGlvbjogZnVuY3Rpb24gKGN0eCkge1xuICAgICAgdmFyIGdyb3VwU2VsZWN0b3IgPSB0aGlzLl9ncm91cFNlbGVjdG9yLFxuICAgICAgICAgIGxlZnQgPSBncm91cFNlbGVjdG9yLmxlZnQsXG4gICAgICAgICAgdG9wID0gZ3JvdXBTZWxlY3Rvci50b3AsXG4gICAgICAgICAgYWxlZnQgPSBhYnMobGVmdCksXG4gICAgICAgICAgYXRvcCA9IGFicyh0b3ApO1xuXG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25Db2xvcikge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5zZWxlY3Rpb25Db2xvcjtcblxuICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgZ3JvdXBTZWxlY3Rvci5leCAtICgobGVmdCA+IDApID8gMCA6IC1sZWZ0KSxcbiAgICAgICAgICBncm91cFNlbGVjdG9yLmV5IC0gKCh0b3AgPiAwKSA/IDAgOiAtdG9wKSxcbiAgICAgICAgICBhbGVmdCxcbiAgICAgICAgICBhdG9wXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5zZWxlY3Rpb25MaW5lV2lkdGggfHwgIXRoaXMuc2VsZWN0aW9uQm9yZGVyQ29sb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuc2VsZWN0aW9uTGluZVdpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5zZWxlY3Rpb25Cb3JkZXJDb2xvcjtcblxuICAgICAgLy8gc2VsZWN0aW9uIGJvcmRlclxuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uRGFzaEFycmF5Lmxlbmd0aCA+IDEgJiYgIXN1cHBvcnRMaW5lRGFzaCkge1xuXG4gICAgICAgIHZhciBweCA9IGdyb3VwU2VsZWN0b3IuZXggKyBTVFJPS0VfT0ZGU0VUIC0gKChsZWZ0ID4gMCkgPyAwIDogYWxlZnQpLFxuICAgICAgICAgICAgcHkgPSBncm91cFNlbGVjdG9yLmV5ICsgU1RST0tFX09GRlNFVCAtICgodG9wID4gMCkgPyAwIDogYXRvcCk7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgcHgsIHB5LCBweCArIGFsZWZ0LCBweSwgdGhpcy5zZWxlY3Rpb25EYXNoQXJyYXkpO1xuICAgICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHB4LCBweSArIGF0b3AgLSAxLCBweCArIGFsZWZ0LCBweSArIGF0b3AgLSAxLCB0aGlzLnNlbGVjdGlvbkRhc2hBcnJheSk7XG4gICAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgcHgsIHB5LCBweCwgcHkgKyBhdG9wLCB0aGlzLnNlbGVjdGlvbkRhc2hBcnJheSk7XG4gICAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgcHggKyBhbGVmdCAtIDEsIHB5LCBweCArIGFsZWZ0IC0gMSwgcHkgKyBhdG9wLCB0aGlzLnNlbGVjdGlvbkRhc2hBcnJheSk7XG5cbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZmFicmljLk9iamVjdC5wcm90b3R5cGUuX3NldExpbmVEYXNoLmNhbGwodGhpcywgY3R4LCB0aGlzLnNlbGVjdGlvbkRhc2hBcnJheSk7XG4gICAgICAgIGN0eC5zdHJva2VSZWN0KFxuICAgICAgICAgIGdyb3VwU2VsZWN0b3IuZXggKyBTVFJPS0VfT0ZGU0VUIC0gKChsZWZ0ID4gMCkgPyAwIDogYWxlZnQpLFxuICAgICAgICAgIGdyb3VwU2VsZWN0b3IuZXkgKyBTVFJPS0VfT0ZGU0VUIC0gKCh0b3AgPiAwKSA/IDAgOiBhdG9wKSxcbiAgICAgICAgICBhbGVmdCxcbiAgICAgICAgICBhdG9wXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGRldGVybWluZXMgd2hhdCBvYmplY3Qgd2UgYXJlIGNsaWNraW5nIG9uXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBtb3VzZSBldmVudFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcEdyb3VwIHdoZW4gdHJ1ZSwgYWN0aXZlR3JvdXAgaXMgc2tpcHBlZCBhbmQgb25seSBvYmplY3RzIGFyZSB0cmF2ZXJzZWQgdGhyb3VnaFxuICAgICAqL1xuICAgIGZpbmRUYXJnZXQ6IGZ1bmN0aW9uIChlLCBza2lwR3JvdXApIHtcbiAgICAgIGlmICh0aGlzLnNraXBUYXJnZXRGaW5kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlnbm9yZVpvb20gPSB0cnVlLFxuICAgICAgICAgIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSwgaWdub3JlWm9vbSksXG4gICAgICAgICAgYWN0aXZlR3JvdXAgPSB0aGlzLmdldEFjdGl2ZUdyb3VwKCksXG4gICAgICAgICAgYWN0aXZlT2JqZWN0ID0gdGhpcy5nZXRBY3RpdmVPYmplY3QoKSxcbiAgICAgICAgICBhY3RpdmVUYXJnZXQ7XG4gICAgICAvLyBmaXJzdCBjaGVjayBjdXJyZW50IGdyb3VwIChpZiBvbmUgZXhpc3RzKVxuICAgICAgLy8gYWN0aXZlIGdyb3VwIGRvZXMgbm90IGNoZWNrIHN1YiB0YXJnZXRzIGxpa2Ugbm9ybWFsIGdyb3Vwcy5cbiAgICAgIC8vIGlmIGFjdGl2ZSBncm91cCBqdXN0IGV4aXRzLlxuICAgICAgaWYgKGFjdGl2ZUdyb3VwICYmICFza2lwR3JvdXAgJiYgdGhpcy5fY2hlY2tUYXJnZXQocG9pbnRlciwgYWN0aXZlR3JvdXApKSB7XG4gICAgICAgIHRoaXMuX2ZpcmVPdmVyT3V0RXZlbnRzKGFjdGl2ZUdyb3VwLCBlKTtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZUdyb3VwO1xuICAgICAgfVxuICAgICAgLy8gaWYgd2UgaGl0IHRoZSBjb3JuZXIgb2YgYW4gYWN0aXZlT2JqZWN0LCBsZXQncyByZXR1cm4gdGhhdC5cbiAgICAgIGlmIChhY3RpdmVPYmplY3QgJiYgYWN0aXZlT2JqZWN0Ll9maW5kVGFyZ2V0Q29ybmVyKHBvaW50ZXIpKSB7XG4gICAgICAgIHRoaXMuX2ZpcmVPdmVyT3V0RXZlbnRzKGFjdGl2ZU9iamVjdCwgZSk7XG4gICAgICAgIHJldHVybiBhY3RpdmVPYmplY3Q7XG4gICAgICB9XG4gICAgICBpZiAoYWN0aXZlT2JqZWN0ICYmIHRoaXMuX2NoZWNrVGFyZ2V0KHBvaW50ZXIsIGFjdGl2ZU9iamVjdCkpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByZXNlcnZlT2JqZWN0U3RhY2tpbmcpIHtcbiAgICAgICAgICB0aGlzLl9maXJlT3Zlck91dEV2ZW50cyhhY3RpdmVPYmplY3QsIGUpO1xuICAgICAgICAgIHJldHVybiBhY3RpdmVPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYWN0aXZlVGFyZ2V0ID0gYWN0aXZlT2JqZWN0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGFyZ2V0cyA9IFtdO1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX3NlYXJjaFBvc3NpYmxlVGFyZ2V0cyh0aGlzLl9vYmplY3RzLCBwb2ludGVyKTtcbiAgICAgIGlmIChlW3RoaXMuYWx0U2VsZWN0aW9uS2V5XSAmJiB0YXJnZXQgJiYgYWN0aXZlVGFyZ2V0ICYmIHRhcmdldCAhPT0gYWN0aXZlVGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldCA9IGFjdGl2ZVRhcmdldDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZpcmVPdmVyT3V0RXZlbnRzKHRhcmdldCwgZSk7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maXJlT3Zlck91dEV2ZW50czogZnVuY3Rpb24odGFyZ2V0LCBlKSB7XG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9ob3ZlcmVkVGFyZ2V0ICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICBpZiAodGhpcy5faG92ZXJlZFRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3VzZTpvdXQnLCB7IHRhcmdldDogdGhpcy5faG92ZXJlZFRhcmdldCwgZTogZSB9KTtcbiAgICAgICAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXQuZmlyZSgnbW91c2VvdXQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5maXJlKCdtb3VzZTpvdmVyJywgeyB0YXJnZXQ6IHRhcmdldCwgZTogZSB9KTtcbiAgICAgICAgICB0YXJnZXQuZmlyZSgnbW91c2VvdmVyJyk7XG4gICAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5faG92ZXJlZFRhcmdldCkge1xuICAgICAgICB0aGlzLmZpcmUoJ21vdXNlOm91dCcsIHsgdGFyZ2V0OiB0aGlzLl9ob3ZlcmVkVGFyZ2V0LCBlOiBlIH0pO1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0LmZpcmUoJ21vdXNlb3V0Jyk7XG4gICAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jaGVja1RhcmdldDogZnVuY3Rpb24ocG9pbnRlciwgb2JqKSB7XG4gICAgICBpZiAob2JqICYmXG4gICAgICAgICAgb2JqLnZpc2libGUgJiZcbiAgICAgICAgICBvYmouZXZlbnRlZCAmJlxuICAgICAgICAgIHRoaXMuY29udGFpbnNQb2ludChudWxsLCBvYmosIHBvaW50ZXIpKXtcbiAgICAgICAgaWYgKCh0aGlzLnBlclBpeGVsVGFyZ2V0RmluZCB8fCBvYmoucGVyUGl4ZWxUYXJnZXRGaW5kKSAmJiAhb2JqLmlzRWRpdGluZykge1xuICAgICAgICAgIHZhciBpc1RyYW5zcGFyZW50ID0gdGhpcy5pc1RhcmdldFRyYW5zcGFyZW50KG9iaiwgcG9pbnRlci54LCBwb2ludGVyLnkpO1xuICAgICAgICAgIGlmICghaXNUcmFuc3BhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NlYXJjaFBvc3NpYmxlVGFyZ2V0czogZnVuY3Rpb24ob2JqZWN0cywgcG9pbnRlcikge1xuXG4gICAgICAvLyBDYWNoZSBhbGwgdGFyZ2V0cyB3aGVyZSB0aGVpciBib3VuZGluZyBib3ggY29udGFpbnMgcG9pbnQuXG4gICAgICB2YXIgdGFyZ2V0LCBpID0gb2JqZWN0cy5sZW5ndGgsIG5vcm1hbGl6ZWRQb2ludGVyLCBzdWJUYXJnZXQ7XG4gICAgICAvLyBEbyBub3QgY2hlY2sgZm9yIGN1cnJlbnRseSBncm91cGVkIG9iamVjdHMsIHNpbmNlIHdlIGNoZWNrIHRoZSBwYXJlbnQgZ3JvdXAgaXRzZWxmLlxuICAgICAgLy8gdW50aWxsIHdlIGNhbGwgdGhpcyBmdW5jdGlvbiBzcGVjaWZpY2FsbHkgdG8gc2VhcmNoIGluc2lkZSB0aGUgYWN0aXZlR3JvdXBcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKHRoaXMuX2NoZWNrVGFyZ2V0KHBvaW50ZXIsIG9iamVjdHNbaV0pKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gb2JqZWN0c1tpXTtcbiAgICAgICAgICBpZiAodGFyZ2V0LnR5cGUgPT09ICdncm91cCcgJiYgdGFyZ2V0LnN1YlRhcmdldENoZWNrKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkUG9pbnRlciA9IHRoaXMuX25vcm1hbGl6ZVBvaW50ZXIodGFyZ2V0LCBwb2ludGVyKTtcbiAgICAgICAgICAgIHN1YlRhcmdldCA9IHRoaXMuX3NlYXJjaFBvc3NpYmxlVGFyZ2V0cyh0YXJnZXQuX29iamVjdHMsIG5vcm1hbGl6ZWRQb2ludGVyKTtcbiAgICAgICAgICAgIHN1YlRhcmdldCAmJiB0aGlzLnRhcmdldHMucHVzaChzdWJUYXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBwb2ludGVyIGNvb3JkaW5hdGVzIHdpdGhvdXQgdGhlIGVmZmVjdCBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlciB3aXRoIFwieFwiIGFuZCBcInlcIiBudW1iZXIgdmFsdWVzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBcInhcIiBhbmQgXCJ5XCIgbnVtYmVyIHZhbHVlc1xuICAgICAqL1xuICAgIHJlc3RvcmVQb2ludGVyVnB0OiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQoXG4gICAgICAgIHBvaW50ZXIsXG4gICAgICAgIGZhYnJpYy51dGlsLmludmVydFRyYW5zZm9ybSh0aGlzLnZpZXdwb3J0VHJhbnNmb3JtKVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBwb2ludGVyIGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIGNhbnZhcy5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVab29tXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBcInhcIiBhbmQgXCJ5XCIgbnVtYmVyIHZhbHVlc1xuICAgICAqL1xuICAgIGdldFBvaW50ZXI6IGZ1bmN0aW9uIChlLCBpZ25vcmVab29tLCB1cHBlckNhbnZhc0VsKSB7XG4gICAgICBpZiAoIXVwcGVyQ2FudmFzRWwpIHtcbiAgICAgICAgdXBwZXJDYW52YXNFbCA9IHRoaXMudXBwZXJDYW52YXNFbDtcbiAgICAgIH1cbiAgICAgIHZhciBwb2ludGVyID0gZ2V0UG9pbnRlcihlKSxcbiAgICAgICAgICBib3VuZHMgPSB1cHBlckNhbnZhc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgIGJvdW5kc1dpZHRoID0gYm91bmRzLndpZHRoIHx8IDAsXG4gICAgICAgICAgYm91bmRzSGVpZ2h0ID0gYm91bmRzLmhlaWdodCB8fCAwLFxuICAgICAgICAgIGNzc1NjYWxlO1xuXG4gICAgICBpZiAoIWJvdW5kc1dpZHRoIHx8ICFib3VuZHNIZWlnaHQgKSB7XG4gICAgICAgIGlmICgndG9wJyBpbiBib3VuZHMgJiYgJ2JvdHRvbScgaW4gYm91bmRzKSB7XG4gICAgICAgICAgYm91bmRzSGVpZ2h0ID0gTWF0aC5hYnMoIGJvdW5kcy50b3AgLSBib3VuZHMuYm90dG9tICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdyaWdodCcgaW4gYm91bmRzICYmICdsZWZ0JyBpbiBib3VuZHMpIHtcbiAgICAgICAgICBib3VuZHNXaWR0aCA9IE1hdGguYWJzKCBib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdCApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsY09mZnNldCgpO1xuXG4gICAgICBwb2ludGVyLnggPSBwb2ludGVyLnggLSB0aGlzLl9vZmZzZXQubGVmdDtcbiAgICAgIHBvaW50ZXIueSA9IHBvaW50ZXIueSAtIHRoaXMuX29mZnNldC50b3A7XG4gICAgICBpZiAoIWlnbm9yZVpvb20pIHtcbiAgICAgICAgcG9pbnRlciA9IHRoaXMucmVzdG9yZVBvaW50ZXJWcHQocG9pbnRlcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChib3VuZHNXaWR0aCA9PT0gMCB8fCBib3VuZHNIZWlnaHQgPT09IDApIHtcbiAgICAgICAgLy8gSWYgYm91bmRzIGFyZSBub3QgYXZhaWxhYmxlIChpLmUuIG5vdCB2aXNpYmxlKSwgZG8gbm90IGFwcGx5IHNjYWxlLlxuICAgICAgICBjc3NTY2FsZSA9IHsgd2lkdGg6IDEsIGhlaWdodDogMSB9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNzc1NjYWxlID0ge1xuICAgICAgICAgIHdpZHRoOiB1cHBlckNhbnZhc0VsLndpZHRoIC8gYm91bmRzV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB1cHBlckNhbnZhc0VsLmhlaWdodCAvIGJvdW5kc0hlaWdodFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBwb2ludGVyLnggKiBjc3NTY2FsZS53aWR0aCxcbiAgICAgICAgeTogcG9pbnRlci55ICogY3NzU2NhbGUuaGVpZ2h0XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0aHJvd3Mge0NBTlZBU19JTklUX0VSUk9SfSBJZiBjYW52YXMgY2FuIG5vdCBiZSBpbml0aWFsaXplZFxuICAgICAqL1xuICAgIF9jcmVhdGVVcHBlckNhbnZhczogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxvd2VyQ2FudmFzQ2xhc3MgPSB0aGlzLmxvd2VyQ2FudmFzRWwuY2xhc3NOYW1lLnJlcGxhY2UoL1xccypsb3dlci1jYW52YXNcXHMqLywgJycpO1xuXG4gICAgICB0aGlzLnVwcGVyQ2FudmFzRWwgPSB0aGlzLl9jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICBmYWJyaWMudXRpbC5hZGRDbGFzcyh0aGlzLnVwcGVyQ2FudmFzRWwsICd1cHBlci1jYW52YXMgJyArIGxvd2VyQ2FudmFzQ2xhc3MpO1xuXG4gICAgICB0aGlzLndyYXBwZXJFbC5hcHBlbmRDaGlsZCh0aGlzLnVwcGVyQ2FudmFzRWwpO1xuXG4gICAgICB0aGlzLl9jb3B5Q2FudmFzU3R5bGUodGhpcy5sb3dlckNhbnZhc0VsLCB0aGlzLnVwcGVyQ2FudmFzRWwpO1xuICAgICAgdGhpcy5fYXBwbHlDYW52YXNTdHlsZSh0aGlzLnVwcGVyQ2FudmFzRWwpO1xuICAgICAgdGhpcy5jb250ZXh0VG9wID0gdGhpcy51cHBlckNhbnZhc0VsLmdldENvbnRleHQoJzJkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZUNhY2hlQ2FudmFzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhY2hlQ2FudmFzRWwgPSB0aGlzLl9jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICB0aGlzLmNhY2hlQ2FudmFzRWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMud2lkdGgpO1xuICAgICAgdGhpcy5jYWNoZUNhbnZhc0VsLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5oZWlnaHQpO1xuICAgICAgdGhpcy5jb250ZXh0Q2FjaGUgPSB0aGlzLmNhY2hlQ2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdFdyYXBwZXJFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLndyYXBwZXJFbCA9IGZhYnJpYy51dGlsLndyYXBFbGVtZW50KHRoaXMubG93ZXJDYW52YXNFbCwgJ2RpdicsIHtcbiAgICAgICAgJ2NsYXNzJzogdGhpcy5jb250YWluZXJDbGFzc1xuICAgICAgfSk7XG4gICAgICBmYWJyaWMudXRpbC5zZXRTdHlsZSh0aGlzLndyYXBwZXJFbCwge1xuICAgICAgICB3aWR0aDogdGhpcy5nZXRXaWR0aCgpICsgJ3B4JyxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmdldEhlaWdodCgpICsgJ3B4JyxcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICAgIH0pO1xuICAgICAgZmFicmljLnV0aWwubWFrZUVsZW1lbnRVbnNlbGVjdGFibGUodGhpcy53cmFwcGVyRWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgY2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgc3R5bGVzIG9uXG4gICAgICovXG4gICAgX2FwcGx5Q2FudmFzU3R5bGU6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFdpZHRoKCkgfHwgZWxlbWVudC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpIHx8IGVsZW1lbnQuaGVpZ2h0O1xuXG4gICAgICBmYWJyaWMudXRpbC5zZXRTdHlsZShlbGVtZW50LCB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB3aWR0aDogd2lkdGggKyAncHgnLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCArICdweCcsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRvcDogMFxuICAgICAgfSk7XG4gICAgICBlbGVtZW50LndpZHRoID0gd2lkdGg7XG4gICAgICBlbGVtZW50LmhlaWdodCA9IGhlaWdodDtcbiAgICAgIGZhYnJpYy51dGlsLm1ha2VFbGVtZW50VW5zZWxlY3RhYmxlKGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb3B5cyB0aGUgdGhlIGVudGlyZSBpbmxpbmUgc3R5bGUgZnJvbSBvbmUgZWxlbWVudCAoZnJvbUVsKSB0byBhbm90aGVyICh0b0VsKVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBmcm9tRWwgRWxlbWVudCBzdHlsZSBpcyBjb3BpZWQgZnJvbVxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdG9FbCBFbGVtZW50IGNvcGllZCBzdHlsZSBpcyBhcHBsaWVkIHRvXG4gICAgICovXG4gICAgX2NvcHlDYW52YXNTdHlsZTogZnVuY3Rpb24gKGZyb21FbCwgdG9FbCkge1xuICAgICAgdG9FbC5zdHlsZS5jc3NUZXh0ID0gZnJvbUVsLnN0eWxlLmNzc1RleHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29udGV4dCBvZiBjYW52YXMgd2hlcmUgb2JqZWN0IHNlbGVjdGlvbiBpcyBkcmF3blxuICAgICAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cbiAgICBnZXRTZWxlY3Rpb25Db250ZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHRUb3A7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgJmx0O2NhbnZhcz4gZWxlbWVudCBvbiB3aGljaCBvYmplY3Qgc2VsZWN0aW9uIGlzIGRyYXduXG4gICAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICovXG4gICAgZ2V0U2VsZWN0aW9uRWxlbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudXBwZXJDYW52YXNFbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICovXG4gICAgX3NldEFjdGl2ZU9iamVjdDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICBpZiAodGhpcy5fYWN0aXZlT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdC5zZXQoJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdCA9IG9iamVjdDtcbiAgICAgIG9iamVjdC5zZXQoJ2FjdGl2ZScsIHRydWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGdpdmVuIG9iamVjdCBhcyB0aGUgb25seSBhY3RpdmUgb2JqZWN0IG9uIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzZXQgYXMgYW4gYWN0aXZlIG9uZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCAocGFzc2VkIGFsb25nIHdoZW4gZmlyaW5nIFwib2JqZWN0OnNlbGVjdGVkXCIpXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRBY3RpdmVPYmplY3Q6IGZ1bmN0aW9uIChvYmplY3QsIGUpIHtcbiAgICAgIHRoaXMuX3NldEFjdGl2ZU9iamVjdChvYmplY3QpO1xuICAgICAgdGhpcy5yZW5kZXJBbGwoKTtcbiAgICAgIHRoaXMuZmlyZSgnb2JqZWN0OnNlbGVjdGVkJywgeyB0YXJnZXQ6IG9iamVjdCwgZTogZSB9KTtcbiAgICAgIG9iamVjdC5maXJlKCdzZWxlY3RlZCcsIHsgZTogZSB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGN1cnJlbnRseSBhY3RpdmUgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gYWN0aXZlIG9iamVjdFxuICAgICAqL1xuICAgIGdldEFjdGl2ZU9iamVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iaiBPYmplY3QgdGhhdCB3YXMgcmVtb3ZlZFxuICAgICAqL1xuICAgIF9vbk9iamVjdFJlbW92ZWQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgLy8gcmVtb3ZpbmcgYWN0aXZlIG9iamVjdCBzaG91bGQgZmlyZSBcInNlbGVjdGlvbjpjbGVhcmVkXCIgZXZlbnRzXG4gICAgICBpZiAodGhpcy5nZXRBY3RpdmVPYmplY3QoKSA9PT0gb2JqKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnYmVmb3JlOnNlbGVjdGlvbjpjbGVhcmVkJywgeyB0YXJnZXQ6IG9iaiB9KTtcbiAgICAgICAgdGhpcy5fZGlzY2FyZEFjdGl2ZU9iamVjdCgpO1xuICAgICAgICB0aGlzLmZpcmUoJ3NlbGVjdGlvbjpjbGVhcmVkJywgeyB0YXJnZXQ6IG9iaiB9KTtcbiAgICAgICAgb2JqLmZpcmUoJ2Rlc2VsZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfb25PYmplY3RSZW1vdmVkJywgb2JqKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGlzY2FyZEFjdGl2ZU9iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fYWN0aXZlT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdC5zZXQoJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdCA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpc2NhcmRzIGN1cnJlbnRseSBhY3RpdmUgb2JqZWN0IGFuZCBmaXJlIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRpc2NhcmRBY3RpdmVPYmplY3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgYWN0aXZlT2JqZWN0ID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgdGhpcy5maXJlKCdiZWZvcmU6c2VsZWN0aW9uOmNsZWFyZWQnLCB7IHRhcmdldDogYWN0aXZlT2JqZWN0LCBlOiBlIH0pO1xuICAgICAgdGhpcy5fZGlzY2FyZEFjdGl2ZU9iamVjdCgpO1xuICAgICAgdGhpcy5maXJlKCdzZWxlY3Rpb246Y2xlYXJlZCcsIHsgZTogZSB9KTtcbiAgICAgIGFjdGl2ZU9iamVjdCAmJiBhY3RpdmVPYmplY3QuZmlyZSgnZGVzZWxlY3RlZCcsIHsgZTogZSB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLkdyb3VwfSBncm91cFxuICAgICAqL1xuICAgIF9zZXRBY3RpdmVHcm91cDogZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgIHRoaXMuX2FjdGl2ZUdyb3VwID0gZ3JvdXA7XG4gICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgZ3JvdXAuc2V0KCdhY3RpdmUnLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhY3RpdmUgZ3JvdXAgdG8gYSBzcGVjaWZpZWQgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuR3JvdXB9IGdyb3VwIEdyb3VwIHRvIHNldCBhcyBhIGN1cnJlbnQgb25lXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldEFjdGl2ZUdyb3VwOiBmdW5jdGlvbiAoZ3JvdXAsIGUpIHtcbiAgICAgIHRoaXMuX3NldEFjdGl2ZUdyb3VwKGdyb3VwKTtcbiAgICAgIGlmIChncm91cCkge1xuICAgICAgICB0aGlzLmZpcmUoJ29iamVjdDpzZWxlY3RlZCcsIHsgdGFyZ2V0OiBncm91cCwgZTogZSB9KTtcbiAgICAgICAgZ3JvdXAuZmlyZSgnc2VsZWN0ZWQnLCB7IGU6IGUgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjdXJyZW50bHkgYWN0aXZlIGdyb3VwXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSBDdXJyZW50IGdyb3VwXG4gICAgICovXG4gICAgZ2V0QWN0aXZlR3JvdXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVHcm91cDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGlzY2FyZEFjdGl2ZUdyb3VwOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBnID0gdGhpcy5nZXRBY3RpdmVHcm91cCgpO1xuICAgICAgaWYgKGcpIHtcbiAgICAgICAgZy5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEFjdGl2ZUdyb3VwKG51bGwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNjYXJkcyBjdXJyZW50bHkgYWN0aXZlIGdyb3VwIGFuZCBmaXJlIGV2ZW50c1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZGlzY2FyZEFjdGl2ZUdyb3VwOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGcgPSB0aGlzLmdldEFjdGl2ZUdyb3VwKCk7XG4gICAgICB0aGlzLmZpcmUoJ2JlZm9yZTpzZWxlY3Rpb246Y2xlYXJlZCcsIHsgZTogZSwgdGFyZ2V0OiBnIH0pO1xuICAgICAgdGhpcy5fZGlzY2FyZEFjdGl2ZUdyb3VwKCk7XG4gICAgICB0aGlzLmZpcmUoJ3NlbGVjdGlvbjpjbGVhcmVkJywgeyBlOiBlIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlYWN0aXZhdGVzIGFsbCBvYmplY3RzIG9uIGNhbnZhcywgcmVtb3ZpbmcgYW55IGFjdGl2ZSBncm91cCBvciBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRlYWN0aXZhdGVBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhbGxPYmplY3RzID0gdGhpcy5nZXRPYmplY3RzKCksXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgbGVuID0gYWxsT2JqZWN0cy5sZW5ndGgsXG4gICAgICAgICAgb2JqO1xuICAgICAgZm9yICggOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgb2JqID0gYWxsT2JqZWN0c1tpXTtcbiAgICAgICAgb2JqICYmIG9iai5zZXQoJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2Rpc2NhcmRBY3RpdmVHcm91cCgpO1xuICAgICAgdGhpcy5fZGlzY2FyZEFjdGl2ZU9iamVjdCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlYWN0aXZhdGVzIGFsbCBvYmplY3RzIGFuZCBkaXNwYXRjaGVzIGFwcHJvcHJpYXRlIGV2ZW50c1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZGVhY3RpdmF0ZUFsbFdpdGhEaXNwYXRjaDogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBhY3RpdmVHcm91cCA9IHRoaXMuZ2V0QWN0aXZlR3JvdXAoKSxcbiAgICAgICAgICBhY3RpdmVPYmplY3QgPSB0aGlzLmdldEFjdGl2ZU9iamVjdCgpO1xuICAgICAgaWYgKGFjdGl2ZU9iamVjdCB8fCBhY3RpdmVHcm91cCkge1xuICAgICAgICB0aGlzLmZpcmUoJ2JlZm9yZTpzZWxlY3Rpb246Y2xlYXJlZCcsIHsgdGFyZ2V0OiBhY3RpdmVPYmplY3QgfHwgYWN0aXZlR3JvdXAsIGU6IGUgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLmRlYWN0aXZhdGVBbGwoKTtcbiAgICAgIGlmIChhY3RpdmVPYmplY3QgfHwgYWN0aXZlR3JvdXApIHtcbiAgICAgICAgdGhpcy5maXJlKCdzZWxlY3Rpb246Y2xlYXJlZCcsIHsgZTogZSwgdGFyZ2V0OiBhY3RpdmVPYmplY3QgfSk7XG4gICAgICAgIGFjdGl2ZU9iamVjdCAmJiBhY3RpdmVPYmplY3QuZmlyZSgnZGVzZWxlY3RlZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhIGNhbnZhcyBlbGVtZW50IGFuZCByZW1vdmVzIGFsbCBldmVudCBsaXN0ZW5lcnNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdkaXNwb3NlJyk7XG4gICAgICB2YXIgd3JhcHBlciA9IHRoaXMud3JhcHBlckVsO1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIHdyYXBwZXIucmVtb3ZlQ2hpbGQodGhpcy51cHBlckNhbnZhc0VsKTtcbiAgICAgIHdyYXBwZXIucmVtb3ZlQ2hpbGQodGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIGRlbGV0ZSB0aGlzLnVwcGVyQ2FudmFzRWw7XG4gICAgICBpZiAod3JhcHBlci5wYXJlbnROb2RlKSB7XG4gICAgICAgIHdyYXBwZXIucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodGhpcy5sb3dlckNhbnZhc0VsLCB0aGlzLndyYXBwZXJFbCk7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy53cmFwcGVyRWw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCBjb250ZXh0cyAoYmFja2dyb3VuZCwgbWFpbiwgdG9wKSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZGlzY2FyZEFjdGl2ZUdyb3VwKCk7XG4gICAgICB0aGlzLmRpc2NhcmRBY3RpdmVPYmplY3QoKTtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0KHRoaXMuY29udGV4dFRvcCk7XG4gICAgICByZXR1cm4gdGhpcy5jYWxsU3VwZXIoJ2NsZWFyJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIG9iamVjdHMnIGNvbnRyb2xzIChib3JkZXJzL2NvbnRyb2xzKVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgY29udHJvbHMgb25cbiAgICAgKi9cbiAgICBkcmF3Q29udHJvbHM6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIGFjdGl2ZUdyb3VwID0gdGhpcy5nZXRBY3RpdmVHcm91cCgpO1xuXG4gICAgICBpZiAoYWN0aXZlR3JvdXApIHtcbiAgICAgICAgYWN0aXZlR3JvdXAuX3JlbmRlckNvbnRyb2xzKGN0eCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fZHJhd09iamVjdHNDb250cm9scyhjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kcmF3T2JqZWN0c0NvbnRyb2xzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGlmICghdGhpcy5fb2JqZWN0c1tpXSB8fCAhdGhpcy5fb2JqZWN0c1tpXS5hY3RpdmUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vYmplY3RzW2ldLl9yZW5kZXJDb250cm9scyhjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90b09iamVjdDogZnVuY3Rpb24oaW5zdGFuY2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIC8vSWYgdGhlIG9iamVjdCBpcyBwYXJ0IG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBncm91cCwgaXQgc2hvdWxkXG4gICAgICAvL2JlIHRyYW5zZm9ybWVkIGFwcHJvcHJpYXRlbHlcbiAgICAgIC8vaS5lLiBpdCBzaG91bGQgYmUgc2VyaWFsaXNlZCBhcyBpdCB3b3VsZCBhcHBlYXIgaWYgdGhlIHNlbGVjdGlvbiBncm91cFxuICAgICAgLy93ZXJlIHRvIGJlIGRlc3Ryb3llZC5cbiAgICAgIHZhciBvcmlnaW5hbFByb3BlcnRpZXMgPSB0aGlzLl9yZWFsaXplR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdChpbnN0YW5jZSksXG4gICAgICAgICAgb2JqZWN0ID0gdGhpcy5jYWxsU3VwZXIoJ190b09iamVjdCcsIGluc3RhbmNlLCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIC8vVW5kbyB0aGUgZGFtYWdlIHdlIGRpZCBieSBjaGFuZ2luZyBhbGwgb2YgaXRzIHByb3BlcnRpZXNcbiAgICAgIHRoaXMuX3Vud2luZEdyb3VwVHJhbnNmb3JtT25PYmplY3QoaW5zdGFuY2UsIG9yaWdpbmFsUHJvcGVydGllcyk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWFsaXNlcyBhbiBvYmplY3QncyBncm91cCB0cmFuc2Zvcm1hdGlvbiBvbiBpdFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBbaW5zdGFuY2VdIHRoZSBvYmplY3QgdG8gdHJhbnNmb3JtIChnZXRzIG11dGF0ZWQpXG4gICAgICogQHJldHVybnMgdGhlIG9yaWdpbmFsIHZhbHVlcyBvZiBpbnN0YW5jZSB3aGljaCB3ZXJlIGNoYW5nZWRcbiAgICAgKi9cbiAgICBfcmVhbGl6ZUdyb3VwVHJhbnNmb3JtT25PYmplY3Q6IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gICAgICB2YXIgbGF5b3V0UHJvcHMgPSBbJ2FuZ2xlJywgJ2ZsaXBYJywgJ2ZsaXBZJywgJ2hlaWdodCcsICdsZWZ0JywgJ3NjYWxlWCcsICdzY2FsZVknLCAndG9wJywgJ3dpZHRoJ107XG4gICAgICBpZiAoaW5zdGFuY2UuZ3JvdXAgJiYgaW5zdGFuY2UuZ3JvdXAgPT09IHRoaXMuZ2V0QWN0aXZlR3JvdXAoKSkge1xuICAgICAgICAvL0NvcHkgYWxsIHRoZSBwb3NpdGlvbmFsbHkgcmVsZXZhbnQgcHJvcGVydGllcyBhY3Jvc3Mgbm93XG4gICAgICAgIHZhciBvcmlnaW5hbFZhbHVlcyA9IHt9O1xuICAgICAgICBsYXlvdXRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgICBvcmlnaW5hbFZhbHVlc1twcm9wXSA9IGluc3RhbmNlW3Byb3BdO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5nZXRBY3RpdmVHcm91cCgpLnJlYWxpemVUcmFuc2Zvcm0oaW5zdGFuY2UpO1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxWYWx1ZXM7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmVzIHRoZSBjaGFuZ2VkIHByb3BlcnRpZXMgb2YgaW5zdGFuY2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gW2luc3RhbmNlXSB0aGUgb2JqZWN0IHRvIHVuLXRyYW5zZm9ybSAoZ2V0cyBtdXRhdGVkKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3JpZ2luYWxWYWx1ZXNdIHRoZSBvcmlnaW5hbCB2YWx1ZXMgb2YgaW5zdGFuY2UsIGFzIHJldHVybmVkIGJ5IF9yZWFsaXplR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdFxuICAgICAqL1xuICAgIF91bndpbmRHcm91cFRyYW5zZm9ybU9uT2JqZWN0OiBmdW5jdGlvbihpbnN0YW5jZSwgb3JpZ2luYWxWYWx1ZXMpIHtcbiAgICAgIGlmIChvcmlnaW5hbFZhbHVlcykge1xuICAgICAgICBpbnN0YW5jZS5zZXQob3JpZ2luYWxWYWx1ZXMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdPYmplY3Q6IGZ1bmN0aW9uKG1hcmt1cCwgaW5zdGFuY2UsIHJldml2ZXIpIHtcbiAgICAgIHZhciBvcmlnaW5hbFByb3BlcnRpZXM7XG4gICAgICAvL0lmIHRoZSBvYmplY3QgaXMgaW4gYSBzZWxlY3Rpb24gZ3JvdXAsIHNpbXVsYXRlIHdoYXQgd291bGQgaGFwcGVuIHRvIHRoYXRcbiAgICAgIC8vb2JqZWN0IHdoZW4gdGhlIGdyb3VwIGlzIGRlc2VsZWN0ZWRcbiAgICAgIG9yaWdpbmFsUHJvcGVydGllcyA9IHRoaXMuX3JlYWxpemVHcm91cFRyYW5zZm9ybU9uT2JqZWN0KGluc3RhbmNlKTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0U1ZHT2JqZWN0JywgbWFya3VwLCBpbnN0YW5jZSwgcmV2aXZlcik7XG4gICAgICB0aGlzLl91bndpbmRHcm91cFRyYW5zZm9ybU9uT2JqZWN0KGluc3RhbmNlLCBvcmlnaW5hbFByb3BlcnRpZXMpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8vIGNvcHlpbmcgc3RhdGljIHByb3BlcnRpZXMgbWFudWFsbHkgdG8gd29yayBhcm91bmQgT3BlcmEncyBidWcsXG4gIC8vIHdoZXJlIFwicHJvdG90eXBlXCIgcHJvcGVydHkgaXMgZW51bWVyYWJsZSBhbmQgb3ZlcnJpZGVzIGV4aXN0aW5nIHByb3RvdHlwZVxuICBmb3IgKHZhciBwcm9wIGluIGZhYnJpYy5TdGF0aWNDYW52YXMpIHtcbiAgICBpZiAocHJvcCAhPT0gJ3Byb3RvdHlwZScpIHtcbiAgICAgIGZhYnJpYy5DYW52YXNbcHJvcF0gPSBmYWJyaWMuU3RhdGljQ2FudmFzW3Byb3BdO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmYWJyaWMuaXNUb3VjaFN1cHBvcnRlZCkge1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgZmFicmljLkNhbnZhcy5wcm90b3R5cGUuX3NldEN1cnNvckZyb21FdmVudCA9IGZ1bmN0aW9uKCkgeyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICogQGNsYXNzIGZhYnJpYy5FbGVtZW50XG4gICAqIEBhbGlhcyBmYWJyaWMuQ2FudmFzXG4gICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgZmFicmljLkNhbnZhc30gaW5zdGVhZC5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmYWJyaWMuRWxlbWVudCA9IGZhYnJpYy5DYW52YXM7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgY3Vyc29yT2Zmc2V0ID0ge1xuICAgICAgICBtdDogMCwgLy8gblxuICAgICAgICB0cjogMSwgLy8gbmVcbiAgICAgICAgbXI6IDIsIC8vIGVcbiAgICAgICAgYnI6IDMsIC8vIHNlXG4gICAgICAgIG1iOiA0LCAvLyBzXG4gICAgICAgIGJsOiA1LCAvLyBzd1xuICAgICAgICBtbDogNiwgLy8gd1xuICAgICAgICB0bDogNyAvLyBud1xuICAgICAgfSxcbiAgICAgIGFkZExpc3RlbmVyID0gZmFicmljLnV0aWwuYWRkTGlzdGVuZXIsXG4gICAgICByZW1vdmVMaXN0ZW5lciA9IGZhYnJpYy51dGlsLnJlbW92ZUxpc3RlbmVyO1xuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLkNhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLkNhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogTWFwIG9mIGN1cnNvciBzdHlsZSB2YWx1ZXMgZm9yIGVhY2ggb2YgdGhlIG9iamVjdCBjb250cm9sc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY3Vyc29yTWFwOiBbXG4gICAgICAnbi1yZXNpemUnLFxuICAgICAgJ25lLXJlc2l6ZScsXG4gICAgICAnZS1yZXNpemUnLFxuICAgICAgJ3NlLXJlc2l6ZScsXG4gICAgICAncy1yZXNpemUnLFxuICAgICAgJ3N3LXJlc2l6ZScsXG4gICAgICAndy1yZXNpemUnLFxuICAgICAgJ253LXJlc2l6ZSdcbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBtb3VzZSBsaXN0ZW5lcnMgdG8gY2FudmFzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdEV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcblxuICAgICAgYWRkTGlzdGVuZXIoZmFicmljLndpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplKTtcblxuICAgICAgLy8gbW91c2UgZXZlbnRzXG4gICAgICBhZGRMaXN0ZW5lcih0aGlzLnVwcGVyQ2FudmFzRWwsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93bik7XG4gICAgICBhZGRMaXN0ZW5lcih0aGlzLnVwcGVyQ2FudmFzRWwsICdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG4gICAgICBhZGRMaXN0ZW5lcih0aGlzLnVwcGVyQ2FudmFzRWwsICdtb3VzZW91dCcsIHRoaXMuX29uTW91c2VPdXQpO1xuICAgICAgYWRkTGlzdGVuZXIodGhpcy51cHBlckNhbnZhc0VsLCAnbW91c2VlbnRlcicsIHRoaXMuX29uTW91c2VFbnRlcik7XG4gICAgICBhZGRMaXN0ZW5lcih0aGlzLnVwcGVyQ2FudmFzRWwsICd3aGVlbCcsIHRoaXMuX29uTW91c2VXaGVlbCk7XG4gICAgICBhZGRMaXN0ZW5lcih0aGlzLnVwcGVyQ2FudmFzRWwsICdjb250ZXh0bWVudScsIHRoaXMuX29uQ29udGV4dE1lbnUpO1xuXG4gICAgICAvLyB0b3VjaCBldmVudHNcbiAgICAgIGFkZExpc3RlbmVyKHRoaXMudXBwZXJDYW52YXNFbCwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbk1vdXNlRG93bik7XG4gICAgICBhZGRMaXN0ZW5lcih0aGlzLnVwcGVyQ2FudmFzRWwsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgZXZlbnRqcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2FkZCcgaW4gZXZlbnRqcykge1xuICAgICAgICBldmVudGpzLmFkZCh0aGlzLnVwcGVyQ2FudmFzRWwsICdnZXN0dXJlJywgdGhpcy5fb25HZXN0dXJlKTtcbiAgICAgICAgZXZlbnRqcy5hZGQodGhpcy51cHBlckNhbnZhc0VsLCAnZHJhZycsIHRoaXMuX29uRHJhZyk7XG4gICAgICAgIGV2ZW50anMuYWRkKHRoaXMudXBwZXJDYW52YXNFbCwgJ29yaWVudGF0aW9uJywgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSk7XG4gICAgICAgIGV2ZW50anMuYWRkKHRoaXMudXBwZXJDYW52YXNFbCwgJ3NoYWtlJywgdGhpcy5fb25TaGFrZSk7XG4gICAgICAgIGV2ZW50anMuYWRkKHRoaXMudXBwZXJDYW52YXNFbCwgJ2xvbmdwcmVzcycsIHRoaXMuX29uTG9uZ1ByZXNzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYmluZEV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9vbk1vdXNlRG93biA9IHRoaXMuX29uTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlTW92ZSA9IHRoaXMuX29uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlVXAgPSB0aGlzLl9vbk1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uUmVzaXplID0gdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uR2VzdHVyZSA9IHRoaXMuX29uR2VzdHVyZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25EcmFnID0gdGhpcy5fb25EcmFnLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vblNoYWtlID0gdGhpcy5fb25TaGFrZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Mb25nUHJlc3MgPSB0aGlzLl9vbkxvbmdQcmVzcy5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSA9IHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTW91c2VXaGVlbCA9IHRoaXMuX29uTW91c2VXaGVlbC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Nb3VzZU91dCA9IHRoaXMuX29uTW91c2VPdXQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTW91c2VFbnRlciA9IHRoaXMuX29uTW91c2VFbnRlci5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Db250ZXh0TWVudSA9IHRoaXMuX29uQ29udGV4dE1lbnUuYmluZCh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgICovXG4gICAgcmVtb3ZlTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy53aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSk7XG5cbiAgICAgIHJlbW92ZUxpc3RlbmVyKHRoaXMudXBwZXJDYW52YXNFbCwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKHRoaXMudXBwZXJDYW52YXNFbCwgJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKHRoaXMudXBwZXJDYW52YXNFbCwgJ21vdXNlb3V0JywgdGhpcy5fb25Nb3VzZU91dCk7XG4gICAgICByZW1vdmVMaXN0ZW5lcih0aGlzLnVwcGVyQ2FudmFzRWwsICdtb3VzZWVudGVyJywgdGhpcy5fb25Nb3VzZUVudGVyKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKHRoaXMudXBwZXJDYW52YXNFbCwgJ3doZWVsJywgdGhpcy5fb25Nb3VzZVdoZWVsKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKHRoaXMudXBwZXJDYW52YXNFbCwgJ2NvbnRleHRtZW51JywgdGhpcy5fb25Db250ZXh0TWVudSk7XG5cbiAgICAgIHJlbW92ZUxpc3RlbmVyKHRoaXMudXBwZXJDYW52YXNFbCwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbk1vdXNlRG93bik7XG4gICAgICByZW1vdmVMaXN0ZW5lcih0aGlzLnVwcGVyQ2FudmFzRWwsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgZXZlbnRqcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ3JlbW92ZScgaW4gZXZlbnRqcykge1xuICAgICAgICBldmVudGpzLnJlbW92ZSh0aGlzLnVwcGVyQ2FudmFzRWwsICdnZXN0dXJlJywgdGhpcy5fb25HZXN0dXJlKTtcbiAgICAgICAgZXZlbnRqcy5yZW1vdmUodGhpcy51cHBlckNhbnZhc0VsLCAnZHJhZycsIHRoaXMuX29uRHJhZyk7XG4gICAgICAgIGV2ZW50anMucmVtb3ZlKHRoaXMudXBwZXJDYW52YXNFbCwgJ29yaWVudGF0aW9uJywgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSk7XG4gICAgICAgIGV2ZW50anMucmVtb3ZlKHRoaXMudXBwZXJDYW52YXNFbCwgJ3NoYWtlJywgdGhpcy5fb25TaGFrZSk7XG4gICAgICAgIGV2ZW50anMucmVtb3ZlKHRoaXMudXBwZXJDYW52YXNFbCwgJ2xvbmdwcmVzcycsIHRoaXMuX29uTG9uZ1ByZXNzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIGdlc3R1cmVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbc2VsZl0gSW5uZXIgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX29uR2VzdHVyZTogZnVuY3Rpb24oZSwgc2VsZikge1xuICAgICAgdGhpcy5fX29uVHJhbnNmb3JtR2VzdHVyZSAmJiB0aGlzLl9fb25UcmFuc2Zvcm1HZXN0dXJlKGUsIHNlbGYpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCBvYmplY3QgZmlyZWQgb24gRXZlbnQuanMgZHJhZ1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25EcmFnOiBmdW5jdGlvbihlLCBzZWxmKSB7XG4gICAgICB0aGlzLl9fb25EcmFnICYmIHRoaXMuX19vbkRyYWcoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiB3aGVlbCBldmVudFxuICAgICAqL1xuICAgIF9vbk1vdXNlV2hlZWw6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuX19vbk1vdXNlV2hlZWwoZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX29uTW91c2VPdXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9ob3ZlcmVkVGFyZ2V0O1xuICAgICAgdGhpcy5maXJlKCdtb3VzZTpvdXQnLCB7IHRhcmdldDogdGFyZ2V0LCBlOiBlIH0pO1xuICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IG51bGw7XG4gICAgICB0YXJnZXQgJiYgdGFyZ2V0LmZpcmUoJ21vdXNlb3V0JywgeyBlOiBlIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZW50ZXJcbiAgICAgKi9cbiAgICBfb25Nb3VzZUVudGVyOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoIXRoaXMuZmluZFRhcmdldChlKSkge1xuICAgICAgICB0aGlzLmZpcmUoJ21vdXNlOm92ZXInLCB7IHRhcmdldDogbnVsbCwgZTogZSB9KTtcbiAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBFdmVudC5qcyBvcmllbnRhdGlvbiBjaGFuZ2VcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbc2VsZl0gSW5uZXIgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX29uT3JpZW50YXRpb25DaGFuZ2U6IGZ1bmN0aW9uKGUsIHNlbGYpIHtcbiAgICAgIHRoaXMuX19vbk9yaWVudGF0aW9uQ2hhbmdlICYmIHRoaXMuX19vbk9yaWVudGF0aW9uQ2hhbmdlKGUsIHNlbGYpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCBvYmplY3QgZmlyZWQgb24gRXZlbnQuanMgc2hha2VcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbc2VsZl0gSW5uZXIgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX29uU2hha2U6IGZ1bmN0aW9uKGUsIHNlbGYpIHtcbiAgICAgIHRoaXMuX19vblNoYWtlICYmIHRoaXMuX19vblNoYWtlKGUsIHNlbGYpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCBvYmplY3QgZmlyZWQgb24gRXZlbnQuanMgc2hha2VcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbc2VsZl0gSW5uZXIgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX29uTG9uZ1ByZXNzOiBmdW5jdGlvbihlLCBzZWxmKSB7XG4gICAgICB0aGlzLl9fb25Mb25nUHJlc3MgJiYgdGhpcy5fX29uTG9uZ1ByZXNzKGUsIHNlbGYpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZG93blxuICAgICAqL1xuICAgIF9vbkNvbnRleHRNZW51OiBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHRoaXMuc3RvcENvbnRleHRNZW51KSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9fb25Nb3VzZURvd24oZSk7XG5cbiAgICAgIGFkZExpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Nb3VzZVVwKTtcbiAgICAgIGFkZExpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW91c2VNb3ZlKTtcblxuICAgICAgcmVtb3ZlTGlzdGVuZXIodGhpcy51cHBlckNhbnZhc0VsLCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIodGhpcy51cHBlckNhbnZhc0VsLCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUpO1xuXG4gICAgICBpZiAoZS50eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAgICAgLy8gVW5iaW5kIG1vdXNlZG93biB0byBwcmV2ZW50IGRvdWJsZSB0cmlnZ2VycyBmcm9tIHRvdWNoIGRldmljZXNcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIodGhpcy51cHBlckNhbnZhc0VsLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGFkZExpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXApO1xuICAgICAgICBhZGRMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2V1cFxuICAgICAqL1xuICAgIF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9fb25Nb3VzZVVwKGUpO1xuXG4gICAgICByZW1vdmVMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Nb3VzZVVwKTtcblxuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUpO1xuXG4gICAgICBhZGRMaXN0ZW5lcih0aGlzLnVwcGVyQ2FudmFzRWwsICdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG4gICAgICBhZGRMaXN0ZW5lcih0aGlzLnVwcGVyQ2FudmFzRWwsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG5cbiAgICAgIGlmIChlLnR5cGUgPT09ICd0b3VjaGVuZCcpIHtcbiAgICAgICAgLy8gV2FpdCA0MDBtcyBiZWZvcmUgcmViaW5kaW5nIG1vdXNlZG93biB0byBwcmV2ZW50IGRvdWJsZSB0cmlnZ2Vyc1xuICAgICAgICAvLyBmcm9tIHRvdWNoIGRldmljZXNcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBhZGRMaXN0ZW5lcihfdGhpcy51cHBlckNhbnZhc0VsLCAnbW91c2Vkb3duJywgX3RoaXMuX29uTW91c2VEb3duKTtcbiAgICAgICAgfSwgNDAwKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZW1vdmVcbiAgICAgKi9cbiAgICBfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAhdGhpcy5hbGxvd1RvdWNoU2Nyb2xsaW5nICYmIGUucHJldmVudERlZmF1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5fX29uTW91c2VNb3ZlKGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vblJlc2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYWxjT2Zmc2V0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY2lkZXMgd2hldGhlciB0aGUgY2FudmFzIHNob3VsZCBiZSByZWRyYXduIGluIG1vdXNldXAgYW5kIG1vdXNlZG93biBldmVudHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICAgKi9cbiAgICBfc2hvdWxkUmVuZGVyOiBmdW5jdGlvbih0YXJnZXQsIHBvaW50ZXIpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3QgPSB0aGlzLmdldEFjdGl2ZUdyb3VwKCkgfHwgdGhpcy5nZXRBY3RpdmVPYmplY3QoKTtcblxuICAgICAgaWYgKGFjdGl2ZU9iamVjdCAmJiBhY3RpdmVPYmplY3QuaXNFZGl0aW5nICYmIHRhcmdldCA9PT0gYWN0aXZlT2JqZWN0KSB7XG4gICAgICAgIC8vIGlmIHdlIG1vdXNlIHVwL2Rvd24gb3ZlciBhIGVkaXRpbmcgdGV4dGJveCBhIGN1cnNvciBjaGFuZ2UsXG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgdG8gcmUgcmVuZGVyXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhIShcbiAgICAgICAgKHRhcmdldCAmJiAoXG4gICAgICAgICAgdGFyZ2V0LmlzTW92aW5nIHx8XG4gICAgICAgICAgdGFyZ2V0ICE9PSBhY3RpdmVPYmplY3QpKVxuICAgICAgICB8fFxuICAgICAgICAoIXRhcmdldCAmJiAhIWFjdGl2ZU9iamVjdClcbiAgICAgICAgfHxcbiAgICAgICAgKCF0YXJnZXQgJiYgIWFjdGl2ZU9iamVjdCAmJiAhdGhpcy5fZ3JvdXBTZWxlY3RvcilcbiAgICAgICAgfHxcbiAgICAgICAgKHBvaW50ZXIgJiZcbiAgICAgICAgICB0aGlzLl9wcmV2aW91c1BvaW50ZXIgJiZcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbiAmJiAoXG4gICAgICAgICAgcG9pbnRlci54ICE9PSB0aGlzLl9wcmV2aW91c1BvaW50ZXIueCB8fFxuICAgICAgICAgIHBvaW50ZXIueSAhPT0gdGhpcy5fcHJldmlvdXNQb2ludGVyLnkpKVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZGVmaW5lcyB0aGUgYWN0aW9ucyB3aGVuIG1vdXNlIGlzIHJlbGVhc2VkIG9uIGNhbnZhcy5cbiAgICAgKiBUaGUgbWV0aG9kIHJlc2V0cyB0aGUgY3VycmVudFRyYW5zZm9ybSBwYXJhbWV0ZXJzLCBzdG9yZSB0aGUgaW1hZ2UgY29ybmVyXG4gICAgICogcG9zaXRpb24gaW4gdGhlIGltYWdlIG9iamVjdCBhbmQgcmVuZGVyIHRoZSBjYW52YXMgb24gdG9wLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2V1cFxuICAgICAqL1xuICAgIF9fb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIHRhcmdldCwgc2VhcmNoVGFyZ2V0ID0gdHJ1ZSwgdHJhbnNmb3JtID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybSxcbiAgICAgICAgICBncm91cFNlbGVjdG9yID0gdGhpcy5fZ3JvdXBTZWxlY3RvcixcbiAgICAgICAgICBpc0NsaWNrID0gKCFncm91cFNlbGVjdG9yIHx8IChncm91cFNlbGVjdG9yLmxlZnQgPT09IDAgJiYgZ3JvdXBTZWxlY3Rvci50b3AgPT09IDApKTtcblxuICAgICAgaWYgKHRoaXMuaXNEcmF3aW5nTW9kZSAmJiB0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcpIHtcbiAgICAgICAgdGhpcy5fb25Nb3VzZVVwSW5EcmF3aW5nTW9kZShlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIHRoaXMuX2ZpbmFsaXplQ3VycmVudFRyYW5zZm9ybSgpO1xuICAgICAgICBzZWFyY2hUYXJnZXQgPSAhdHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZDtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0ID0gc2VhcmNoVGFyZ2V0ID8gdGhpcy5maW5kVGFyZ2V0KGUsIHRydWUpIDogdHJhbnNmb3JtLnRhcmdldDtcblxuICAgICAgdmFyIHNob3VsZFJlbmRlciA9IHRoaXMuX3Nob3VsZFJlbmRlcih0YXJnZXQsIHRoaXMuZ2V0UG9pbnRlcihlKSk7XG5cbiAgICAgIGlmICh0YXJnZXQgfHwgIWlzQ2xpY2spIHtcbiAgICAgICAgdGhpcy5fbWF5YmVHcm91cE9iamVjdHMoZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gdGhvc2UgYXJlIGRvbmUgYnkgZGVmYXVsdCBvbiBtb3VzZSB1cFxuICAgICAgICAvLyBieSBfbWF5YmVHcm91cE9iamVjdHMsIHdlIGFyZSBza2lwcGluZyBpdCBpbiBjYXNlIG9mIG5vIHRhcmdldCBmaW5kXG4gICAgICAgIHRoaXMuX2dyb3VwU2VsZWN0b3IgPSBudWxsO1xuICAgICAgICB0aGlzLl9jdXJyZW50VHJhbnNmb3JtID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICB0YXJnZXQuaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faGFuZGxlQ3Vyc29yQW5kRXZlbnQoZSwgdGFyZ2V0LCAndXAnKTtcbiAgICAgIHRhcmdldCAmJiAodGFyZ2V0Ll9fY29ybmVyID0gMCk7XG4gICAgICBzaG91bGRSZW5kZXIgJiYgdGhpcy5yZW5kZXJBbGwoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2V0IGN1cnNvciBmb3IgbW91c2UgdXAgYW5kIGhhbmRsZSBtb3VzZVVwIGV2ZW50XG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBldmVudCBmcm9tIG1vdXNlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXQgcmVjZWl2aW5nIGV2ZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBldmVudCB0byBmaXJlICh1cCwgZG93biBvciBtb3ZlKVxuICAgICAqL1xuICAgIF9oYW5kbGVDdXJzb3JBbmRFdmVudDogZnVuY3Rpb24oZSwgdGFyZ2V0LCBldmVudFR5cGUpIHtcbiAgICAgIHRoaXMuX3NldEN1cnNvckZyb21FdmVudChlLCB0YXJnZXQpO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgZXZlbnRUeXBlLCB0YXJnZXQgPyB0YXJnZXQgOiBudWxsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGV2ZW50IGZpcmluZyBmb3IgdGFyZ2V0IGFuZCBzdWJ0YXJnZXRzXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBldmVudCBmcm9tIG1vdXNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBldmVudCB0byBmaXJlICh1cCwgZG93biBvciBtb3ZlKVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0T2JqIHJlY2VpdmluZyBldmVudFxuICAgICAqL1xuICAgIF9oYW5kbGVFdmVudDogZnVuY3Rpb24oZSwgZXZlbnRUeXBlLCB0YXJnZXRPYmopIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0eXBlb2YgdGFyZ2V0T2JqID09PSAndW5kZWZpbmVkJyA/IHRoaXMuZmluZFRhcmdldChlKSA6IHRhcmdldE9iaixcbiAgICAgICAgICB0YXJnZXRzID0gdGhpcy50YXJnZXRzIHx8IFtdLFxuICAgICAgICAgIG9wdGlvbnMgPSB7IGU6IGUsIHRhcmdldDogdGFyZ2V0LCBzdWJUYXJnZXRzOiB0YXJnZXRzIH07XG4gICAgICB0aGlzLmZpcmUoJ21vdXNlOicgKyBldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgdGFyZ2V0ICYmIHRhcmdldC5maXJlKCdtb3VzZScgKyBldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRhcmdldHNbaV0uZmlyZSgnbW91c2UnICsgZXZlbnRUeXBlLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluYWxpemVDdXJyZW50VHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sXG4gICAgICAgICAgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldDtcblxuICAgICAgaWYgKHRhcmdldC5fc2NhbGluZykge1xuICAgICAgICB0YXJnZXQuX3NjYWxpbmcgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0LnNldENvb3JkcygpO1xuICAgICAgdGhpcy5fcmVzdG9yZU9yaWdpblhZKHRhcmdldCk7XG5cbiAgICAgIGlmICh0cmFuc2Zvcm0uYWN0aW9uUGVyZm9ybWVkIHx8ICh0aGlzLnN0YXRlZnVsICYmIHRhcmdldC5oYXNTdGF0ZUNoYW5nZWQoKSkpIHtcbiAgICAgICAgdGhpcy5maXJlKCdvYmplY3Q6bW9kaWZpZWQnLCB7IHRhcmdldDogdGFyZ2V0IH0pO1xuICAgICAgICB0YXJnZXQuZmlyZSgnbW9kaWZpZWQnKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IE9iamVjdCB0byByZXN0b3JlXG4gICAgICovXG4gICAgX3Jlc3RvcmVPcmlnaW5YWTogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICBpZiAodGhpcy5fcHJldmlvdXNPcmlnaW5YICYmIHRoaXMuX3ByZXZpb3VzT3JpZ2luWSkge1xuXG4gICAgICAgIHZhciBvcmlnaW5Qb2ludCA9IHRhcmdldC50cmFuc2xhdGVUb09yaWdpblBvaW50KFxuICAgICAgICAgIHRhcmdldC5nZXRDZW50ZXJQb2ludCgpLFxuICAgICAgICAgIHRoaXMuX3ByZXZpb3VzT3JpZ2luWCxcbiAgICAgICAgICB0aGlzLl9wcmV2aW91c09yaWdpblkpO1xuXG4gICAgICAgIHRhcmdldC5vcmlnaW5YID0gdGhpcy5fcHJldmlvdXNPcmlnaW5YO1xuICAgICAgICB0YXJnZXQub3JpZ2luWSA9IHRoaXMuX3ByZXZpb3VzT3JpZ2luWTtcblxuICAgICAgICB0YXJnZXQubGVmdCA9IG9yaWdpblBvaW50Lng7XG4gICAgICAgIHRhcmdldC50b3AgPSBvcmlnaW5Qb2ludC55O1xuXG4gICAgICAgIHRoaXMuX3ByZXZpb3VzT3JpZ2luWCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzT3JpZ2luWSA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX29uTW91c2VEb3duSW5EcmF3aW5nTW9kZTogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5faXNDdXJyZW50bHlEcmF3aW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuZGlzY2FyZEFjdGl2ZU9iamVjdChlKS5yZW5kZXJBbGwoKTtcbiAgICAgIGlmICh0aGlzLmNsaXBUbykge1xuICAgICAgICBmYWJyaWMudXRpbC5jbGlwQ29udGV4dCh0aGlzLCB0aGlzLmNvbnRleHRUb3ApO1xuICAgICAgfVxuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSk7XG4gICAgICB0aGlzLmZyZWVEcmF3aW5nQnJ1c2gub25Nb3VzZURvd24ocG9pbnRlcik7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnZG93bicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlbW92ZVxuICAgICAqL1xuICAgIF9vbk1vdXNlTW92ZUluRHJhd2luZ01vZGU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICh0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcpIHtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSk7XG4gICAgICAgIHRoaXMuZnJlZURyYXdpbmdCcnVzaC5vbk1vdXNlTW92ZShwb2ludGVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMuZnJlZURyYXdpbmdDdXJzb3IpO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ21vdmUnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZXVwXG4gICAgICovXG4gICAgX29uTW91c2VVcEluRHJhd2luZ01vZGU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuX2lzQ3VycmVudGx5RHJhd2luZyA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuY2xpcFRvKSB7XG4gICAgICAgIHRoaXMuY29udGV4dFRvcC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZyZWVEcmF3aW5nQnJ1c2gub25Nb3VzZVVwKCk7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAndXAnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZGVmaW5lcyB0aGUgYWN0aW9ucyB3aGVuIG1vdXNlIGlzIGNsaWNrZWQgb24gY2FudmFzLlxuICAgICAqIFRoZSBtZXRob2QgaW5pdHMgdGhlIGN1cnJlbnRUcmFuc2Zvcm0gcGFyYW1ldGVycyBhbmQgcmVuZGVycyBhbGwgdGhlXG4gICAgICogY2FudmFzIHNvIHRoZSBjdXJyZW50IGltYWdlIGNhbiBiZSBwbGFjZWQgb24gdGhlIHRvcCBjYW52YXMgYW5kIHRoZSByZXN0XG4gICAgICogaW4gb24gdGhlIGNvbnRhaW5lciBvbmUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfX29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuXG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5maW5kVGFyZ2V0KGUpO1xuXG4gICAgICAvLyBpZiByaWdodCBjbGljayBqdXN0IGZpcmUgZXZlbnRzXG4gICAgICB2YXIgaXNSaWdodENsaWNrICA9ICd3aGljaCcgaW4gZSA/IGUud2hpY2ggPT09IDMgOiBlLmJ1dHRvbiA9PT0gMjtcbiAgICAgIGlmIChpc1JpZ2h0Q2xpY2spIHtcbiAgICAgICAgaWYgKHRoaXMuZmlyZVJpZ2h0Q2xpY2spIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnZG93bicsIHRhcmdldCA/IHRhcmdldCA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNEcmF3aW5nTW9kZSkge1xuICAgICAgICB0aGlzLl9vbk1vdXNlRG93bkluRHJhd2luZ01vZGUoZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gaWdub3JlIGlmIHNvbWUgb2JqZWN0IGlzIGJlaW5nIHRyYW5zZm9ybWVkIGF0IHRoaXMgbW9tZW50XG4gICAgICBpZiAodGhpcy5fY3VycmVudFRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHNhdmUgcG9pbnRlciBmb3IgY2hlY2sgaW4gX19vbk1vdXNlVXAgZXZlbnRcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUsIHRydWUpO1xuICAgICAgdGhpcy5fcHJldmlvdXNQb2ludGVyID0gcG9pbnRlcjtcblxuICAgICAgdmFyIHNob3VsZFJlbmRlciA9IHRoaXMuX3Nob3VsZFJlbmRlcih0YXJnZXQsIHBvaW50ZXIpLFxuICAgICAgICAgIHNob3VsZEdyb3VwID0gdGhpcy5fc2hvdWxkR3JvdXAoZSwgdGFyZ2V0KTtcblxuICAgICAgaWYgKHRoaXMuX3Nob3VsZENsZWFyU2VsZWN0aW9uKGUsIHRhcmdldCkpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJTZWxlY3Rpb24oZSwgdGFyZ2V0LCBwb2ludGVyKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNob3VsZEdyb3VwKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUdyb3VwaW5nKGUsIHRhcmdldCk7XG4gICAgICAgIHRhcmdldCA9IHRoaXMuZ2V0QWN0aXZlR3JvdXAoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICBpZiAodGFyZ2V0LnNlbGVjdGFibGUgJiYgKHRhcmdldC5fX2Nvcm5lciB8fCAhc2hvdWxkR3JvdXApKSB7XG4gICAgICAgICAgdGhpcy5fYmVmb3JlVHJhbnNmb3JtKGUsIHRhcmdldCk7XG4gICAgICAgICAgdGhpcy5fc2V0dXBDdXJyZW50VHJhbnNmb3JtKGUsIHRhcmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0ICE9PSB0aGlzLmdldEFjdGl2ZUdyb3VwKCkgJiYgdGFyZ2V0ICE9PSB0aGlzLmdldEFjdGl2ZU9iamVjdCgpKSB7XG4gICAgICAgICAgdGhpcy5kZWFjdGl2YXRlQWxsKCk7XG4gICAgICAgICAgdGFyZ2V0LnNlbGVjdGFibGUgJiYgdGhpcy5zZXRBY3RpdmVPYmplY3QodGFyZ2V0LCBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2Rvd24nLCB0YXJnZXQgPyB0YXJnZXQgOiBudWxsKTtcbiAgICAgIC8vIHdlIG11c3QgcmVuZGVyQWxsIHNvIHRoYXQgd2UgdXBkYXRlIHRoZSB2aXN1YWxzXG4gICAgICBzaG91bGRSZW5kZXIgJiYgdGhpcy5yZW5kZXJBbGwoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYmVmb3JlVHJhbnNmb3JtOiBmdW5jdGlvbihlLCB0YXJnZXQpIHtcbiAgICAgIHRoaXMuc3RhdGVmdWwgJiYgdGFyZ2V0LnNhdmVTdGF0ZSgpO1xuXG4gICAgICAvLyBkZXRlcm1pbmUgaWYgaXQncyBhIGRyYWcgb3Igcm90YXRlIGNhc2VcbiAgICAgIGlmICh0YXJnZXQuX2ZpbmRUYXJnZXRDb3JuZXIodGhpcy5nZXRQb2ludGVyKGUpKSkge1xuICAgICAgICB0aGlzLm9uQmVmb3JlU2NhbGVSb3RhdGUodGFyZ2V0KTtcbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jbGVhclNlbGVjdGlvbjogZnVuY3Rpb24oZSwgdGFyZ2V0LCBwb2ludGVyKSB7XG4gICAgICB0aGlzLmRlYWN0aXZhdGVBbGxXaXRoRGlzcGF0Y2goZSk7XG5cbiAgICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0LnNlbGVjdGFibGUpIHtcbiAgICAgICAgdGhpcy5zZXRBY3RpdmVPYmplY3QodGFyZ2V0LCBlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2dyb3VwU2VsZWN0b3IgPSB7XG4gICAgICAgICAgZXg6IHBvaW50ZXIueCxcbiAgICAgICAgICBleTogcG9pbnRlci55LFxuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBsZWZ0OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBPYmplY3QgZm9yIHRoYXQgb3JpZ2luIGlzIHNldCB0byBjZW50ZXJcbiAgICAgKi9cbiAgICBfc2V0T3JpZ2luVG9DZW50ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgdGhpcy5fcHJldmlvdXNPcmlnaW5YID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybS50YXJnZXQub3JpZ2luWDtcbiAgICAgIHRoaXMuX3ByZXZpb3VzT3JpZ2luWSA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0udGFyZ2V0Lm9yaWdpblk7XG5cbiAgICAgIHZhciBjZW50ZXIgPSB0YXJnZXQuZ2V0Q2VudGVyUG9pbnQoKTtcblxuICAgICAgdGFyZ2V0Lm9yaWdpblggPSAnY2VudGVyJztcbiAgICAgIHRhcmdldC5vcmlnaW5ZID0gJ2NlbnRlcic7XG5cbiAgICAgIHRhcmdldC5sZWZ0ID0gY2VudGVyLng7XG4gICAgICB0YXJnZXQudG9wID0gY2VudGVyLnk7XG5cbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0ubGVmdCA9IHRhcmdldC5sZWZ0O1xuICAgICAgdGhpcy5fY3VycmVudFRyYW5zZm9ybS50b3AgPSB0YXJnZXQudG9wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgT2JqZWN0IGZvciB0aGF0IGNlbnRlciBpcyBzZXQgdG8gb3JpZ2luXG4gICAgICovXG4gICAgX3NldENlbnRlclRvT3JpZ2luOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIHZhciBvcmlnaW5Qb2ludCA9IHRhcmdldC50cmFuc2xhdGVUb09yaWdpblBvaW50KFxuICAgICAgICB0YXJnZXQuZ2V0Q2VudGVyUG9pbnQoKSxcbiAgICAgICAgdGhpcy5fcHJldmlvdXNPcmlnaW5YLFxuICAgICAgICB0aGlzLl9wcmV2aW91c09yaWdpblkpO1xuXG4gICAgICB0YXJnZXQub3JpZ2luWCA9IHRoaXMuX3ByZXZpb3VzT3JpZ2luWDtcbiAgICAgIHRhcmdldC5vcmlnaW5ZID0gdGhpcy5fcHJldmlvdXNPcmlnaW5ZO1xuXG4gICAgICB0YXJnZXQubGVmdCA9IG9yaWdpblBvaW50Lng7XG4gICAgICB0YXJnZXQudG9wID0gb3JpZ2luUG9pbnQueTtcblxuICAgICAgdGhpcy5fcHJldmlvdXNPcmlnaW5YID0gbnVsbDtcbiAgICAgIHRoaXMuX3ByZXZpb3VzT3JpZ2luWSA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGRlZmluZXMgdGhlIGFjdGlvbnMgd2hlbiBtb3VzZSBpcyBob3ZlcmluZyB0aGUgY2FudmFzLlxuICAgICAqIFRoZSBjdXJyZW50VHJhbnNmb3JtIHBhcmFtZXRlciB3aWxsIGRlZmluZGUgd2hldGhlciB0aGUgdXNlciBpcyByb3RhdGluZy9zY2FsaW5nL3RyYW5zbGF0aW5nXG4gICAgICogYW4gaW1hZ2Ugb3IgbmVpdGhlciBvZiB0aGVtIChvbmx5IGhvdmVyaW5nKS4gQSBncm91cCBzZWxlY3Rpb24gaXMgYWxzbyBwb3NzaWJsZSBhbmQgd291bGQgY2FuY2VsXG4gICAgICogYWxsIGFueSBvdGhlciB0eXBlIG9mIGFjdGlvbi5cbiAgICAgKiBJbiBjYXNlIG9mIGFuIGltYWdlIHRyYW5zZm9ybWF0aW9uIG9ubHkgdGhlIHRvcCBjYW52YXMgd2lsbCBiZSByZW5kZXJlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlbW92ZVxuICAgICAqL1xuICAgIF9fb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cbiAgICAgIHZhciB0YXJnZXQsIHBvaW50ZXI7XG5cbiAgICAgIGlmICh0aGlzLmlzRHJhd2luZ01vZGUpIHtcbiAgICAgICAgdGhpcy5fb25Nb3VzZU1vdmVJbkRyYXdpbmdNb2RlKGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGUudG91Y2hlcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZ3JvdXBTZWxlY3RvciA9IHRoaXMuX2dyb3VwU2VsZWN0b3I7XG5cbiAgICAgIC8vIFdlIGluaXRpYWxseSBjbGlja2VkIGluIGFuIGVtcHR5IGFyZWEsIHNvIHdlIGRyYXcgYSBib3ggZm9yIG11bHRpcGxlIHNlbGVjdGlvblxuICAgICAgaWYgKGdyb3VwU2VsZWN0b3IpIHtcbiAgICAgICAgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlLCB0cnVlKTtcblxuICAgICAgICBncm91cFNlbGVjdG9yLmxlZnQgPSBwb2ludGVyLnggLSBncm91cFNlbGVjdG9yLmV4O1xuICAgICAgICBncm91cFNlbGVjdG9yLnRvcCA9IHBvaW50ZXIueSAtIGdyb3VwU2VsZWN0b3IuZXk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJUb3AoKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCF0aGlzLl9jdXJyZW50VHJhbnNmb3JtKSB7XG4gICAgICAgIHRhcmdldCA9IHRoaXMuZmluZFRhcmdldChlKTtcbiAgICAgICAgdGhpcy5fc2V0Q3Vyc29yRnJvbUV2ZW50KGUsIHRhcmdldCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtT2JqZWN0KGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ21vdmUnLCB0YXJnZXQgPyB0YXJnZXQgOiBudWxsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZGVmaW5lcyBhY3Rpb25zIHdoZW4gYW4gRXZlbnQgTW91c2UgV2hlZWxcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZXVwXG4gICAgICovXG4gICAgX19vbk1vdXNlV2hlZWw6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICd3aGVlbCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgZmlyZWQgb24gbW91c2Vtb3ZlXG4gICAgICovXG4gICAgX3RyYW5zZm9ybU9iamVjdDogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSksXG4gICAgICAgICAgdHJhbnNmb3JtID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybTtcblxuICAgICAgdHJhbnNmb3JtLnJlc2V0ID0gZmFsc2U7XG4gICAgICB0cmFuc2Zvcm0udGFyZ2V0LmlzTW92aW5nID0gdHJ1ZTtcbiAgICAgIHRyYW5zZm9ybS5zaGlmdEtleSA9IGUuc2hpZnRLZXk7XG4gICAgICB0cmFuc2Zvcm0uYWx0S2V5ID0gZVt0aGlzLmNlbnRlcmVkS2V5XTtcblxuICAgICAgdGhpcy5fYmVmb3JlU2NhbGVUcmFuc2Zvcm0oZSwgdHJhbnNmb3JtKTtcbiAgICAgIHRoaXMuX3BlcmZvcm1UcmFuc2Zvcm1BY3Rpb24oZSwgdHJhbnNmb3JtLCBwb2ludGVyKTtcblxuICAgICAgdHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZCAmJiB0aGlzLnJlbmRlckFsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wZXJmb3JtVHJhbnNmb3JtQWN0aW9uOiBmdW5jdGlvbihlLCB0cmFuc2Zvcm0sIHBvaW50ZXIpIHtcbiAgICAgIHZhciB4ID0gcG9pbnRlci54LFxuICAgICAgICAgIHkgPSBwb2ludGVyLnksXG4gICAgICAgICAgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCxcbiAgICAgICAgICBhY3Rpb24gPSB0cmFuc2Zvcm0uYWN0aW9uLFxuICAgICAgICAgIGFjdGlvblBlcmZvcm1lZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoYWN0aW9uID09PSAncm90YXRlJykge1xuICAgICAgICAoYWN0aW9uUGVyZm9ybWVkID0gdGhpcy5fcm90YXRlT2JqZWN0KHgsIHkpKSAmJiB0aGlzLl9maXJlKCdyb3RhdGluZycsIHRhcmdldCwgZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhY3Rpb24gPT09ICdzY2FsZScpIHtcbiAgICAgICAgKGFjdGlvblBlcmZvcm1lZCA9IHRoaXMuX29uU2NhbGUoZSwgdHJhbnNmb3JtLCB4LCB5KSkgJiYgdGhpcy5fZmlyZSgnc2NhbGluZycsIHRhcmdldCwgZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhY3Rpb24gPT09ICdzY2FsZVgnKSB7XG4gICAgICAgIChhY3Rpb25QZXJmb3JtZWQgPSB0aGlzLl9zY2FsZU9iamVjdCh4LCB5LCAneCcpKSAmJiB0aGlzLl9maXJlKCdzY2FsaW5nJywgdGFyZ2V0LCBlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ3NjYWxlWScpIHtcbiAgICAgICAgKGFjdGlvblBlcmZvcm1lZCA9IHRoaXMuX3NjYWxlT2JqZWN0KHgsIHksICd5JykpICYmIHRoaXMuX2ZpcmUoJ3NjYWxpbmcnLCB0YXJnZXQsIGUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnc2tld1gnKSB7XG4gICAgICAgIChhY3Rpb25QZXJmb3JtZWQgPSB0aGlzLl9za2V3T2JqZWN0KHgsIHksICd4JykpICYmIHRoaXMuX2ZpcmUoJ3NrZXdpbmcnLCB0YXJnZXQsIGUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnc2tld1knKSB7XG4gICAgICAgIChhY3Rpb25QZXJmb3JtZWQgPSB0aGlzLl9za2V3T2JqZWN0KHgsIHksICd5JykpICYmIHRoaXMuX2ZpcmUoJ3NrZXdpbmcnLCB0YXJnZXQsIGUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGFjdGlvblBlcmZvcm1lZCA9IHRoaXMuX3RyYW5zbGF0ZU9iamVjdCh4LCB5KTtcbiAgICAgICAgaWYgKGFjdGlvblBlcmZvcm1lZCkge1xuICAgICAgICAgIHRoaXMuX2ZpcmUoJ21vdmluZycsIHRhcmdldCwgZSk7XG4gICAgICAgICAgdGhpcy5zZXRDdXJzb3IodGFyZ2V0Lm1vdmVDdXJzb3IgfHwgdGhpcy5tb3ZlQ3Vyc29yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZCA9IHRyYW5zZm9ybS5hY3Rpb25QZXJmb3JtZWQgfHwgYWN0aW9uUGVyZm9ybWVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maXJlOiBmdW5jdGlvbihldmVudE5hbWUsIHRhcmdldCwgZSkge1xuICAgICAgdGhpcy5maXJlKCdvYmplY3Q6JyArIGV2ZW50TmFtZSwgeyB0YXJnZXQ6IHRhcmdldCwgZTogZSB9KTtcbiAgICAgIHRhcmdldC5maXJlKGV2ZW50TmFtZSwgeyBlOiBlIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9iZWZvcmVTY2FsZVRyYW5zZm9ybTogZnVuY3Rpb24oZSwgdHJhbnNmb3JtKSB7XG4gICAgICBpZiAodHJhbnNmb3JtLmFjdGlvbiA9PT0gJ3NjYWxlJyB8fCB0cmFuc2Zvcm0uYWN0aW9uID09PSAnc2NhbGVYJyB8fCB0cmFuc2Zvcm0uYWN0aW9uID09PSAnc2NhbGVZJykge1xuICAgICAgICB2YXIgY2VudGVyVHJhbnNmb3JtID0gdGhpcy5fc2hvdWxkQ2VudGVyVHJhbnNmb3JtKHRyYW5zZm9ybS50YXJnZXQpO1xuXG4gICAgICAgIC8vIFN3aXRjaCBmcm9tIGEgbm9ybWFsIHJlc2l6ZSB0byBjZW50ZXItYmFzZWRcbiAgICAgICAgaWYgKChjZW50ZXJUcmFuc2Zvcm0gJiYgKHRyYW5zZm9ybS5vcmlnaW5YICE9PSAnY2VudGVyJyB8fCB0cmFuc2Zvcm0ub3JpZ2luWSAhPT0gJ2NlbnRlcicpKSB8fFxuICAgICAgICAgICAvLyBTd2l0Y2ggZnJvbSBjZW50ZXItYmFzZWQgcmVzaXplIHRvIG5vcm1hbCBvbmVcbiAgICAgICAgICAgKCFjZW50ZXJUcmFuc2Zvcm0gJiYgdHJhbnNmb3JtLm9yaWdpblggPT09ICdjZW50ZXInICYmIHRyYW5zZm9ybS5vcmlnaW5ZID09PSAnY2VudGVyJylcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5fcmVzZXRDdXJyZW50VHJhbnNmb3JtKCk7XG4gICAgICAgICAgdHJhbnNmb3JtLnJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBjdXJyZW50IHRyYW5mb3JtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggbW91c2UgcG9zaXRpb24geCBmcm9tIG9yaWdpblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IG1vdXNlIHBvaXN0aW9uIHkgZnJvbSBvcmlnaW5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBzY2FsaW5nIG9jY3VycmVkXG4gICAgICovXG4gICAgX29uU2NhbGU6IGZ1bmN0aW9uKGUsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgICAgaWYgKChlW3RoaXMudW5pU2NhbGVLZXldIHx8IHRoaXMudW5pU2NhbGVUcmFuc2Zvcm0pICYmICF0cmFuc2Zvcm0udGFyZ2V0LmdldCgnbG9ja1VuaVNjYWxpbmcnKSkge1xuICAgICAgICB0cmFuc2Zvcm0uY3VycmVudEFjdGlvbiA9ICdzY2FsZSc7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY2FsZU9iamVjdCh4LCB5KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBTd2l0Y2ggZnJvbSBhIG5vcm1hbCByZXNpemUgdG8gcHJvcG9ydGlvbmFsXG4gICAgICAgIGlmICghdHJhbnNmb3JtLnJlc2V0ICYmIHRyYW5zZm9ybS5jdXJyZW50QWN0aW9uID09PSAnc2NhbGUnKSB7XG4gICAgICAgICAgdGhpcy5fcmVzZXRDdXJyZW50VHJhbnNmb3JtKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cmFuc2Zvcm0uY3VycmVudEFjdGlvbiA9ICdzY2FsZUVxdWFsbHknO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGVPYmplY3QoeCwgeSwgJ2VxdWFsbHknKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3Vyc29yIGRlcGVuZGluZyBvbiB3aGVyZSB0aGUgY2FudmFzIGlzIGJlaW5nIGhvdmVyZWQuXG4gICAgICogTm90ZTogdmVyeSBidWdneSBpbiBPcGVyYVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBPYmplY3QgdGhhdCB0aGUgbW91c2UgaXMgaG92ZXJpbmcsIGlmIHNvLlxuICAgICAqL1xuICAgIF9zZXRDdXJzb3JGcm9tRXZlbnQ6IGZ1bmN0aW9uIChlLCB0YXJnZXQpIHtcbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMuZGVmYXVsdEN1cnNvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhvdmVyQ3Vyc29yID0gdGFyZ2V0LmhvdmVyQ3Vyc29yIHx8IHRoaXMuaG92ZXJDdXJzb3I7XG4gICAgICBpZiAoIXRhcmdldC5zZWxlY3RhYmxlKSB7XG4gICAgICAgIC8vbGV0J3Mgc2tpcCBfZmluZFRhcmdldENvcm5lciBpZiBvYmplY3QgaXMgbm90IHNlbGVjdGFibGVcbiAgICAgICAgdGhpcy5zZXRDdXJzb3IoaG92ZXJDdXJzb3IpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBhY3RpdmVHcm91cCA9IHRoaXMuZ2V0QWN0aXZlR3JvdXAoKSxcbiAgICAgICAgICAgIC8vIG9ubHkgc2hvdyBwcm9wZXIgY29ybmVyIHdoZW4gZ3JvdXAgc2VsZWN0aW9uIGlzIG5vdCBhY3RpdmVcbiAgICAgICAgICAgIGNvcm5lciA9IHRhcmdldC5fZmluZFRhcmdldENvcm5lclxuICAgICAgICAgICAgICAgICAgICAgICYmICghYWN0aXZlR3JvdXAgfHwgIWFjdGl2ZUdyb3VwLmNvbnRhaW5zKHRhcmdldCkpXG4gICAgICAgICAgICAgICAgICAgICAgJiYgdGFyZ2V0Ll9maW5kVGFyZ2V0Q29ybmVyKHRoaXMuZ2V0UG9pbnRlcihlLCB0cnVlKSk7XG5cbiAgICAgICAgaWYgKCFjb3JuZXIpIHtcbiAgICAgICAgICB0aGlzLnNldEN1cnNvcihob3ZlckN1cnNvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2V0Q29ybmVyQ3Vyc29yKGNvcm5lciwgdGFyZ2V0LCBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9hY3R1YWxseSB1bmNsZWFyIHdoeSBpdCBzaG91bGQgcmV0dXJuIHNvbWV0aGluZ1xuICAgICAgLy9pcyBuZXZlciBldmFsdWF0ZWRcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRDb3JuZXJDdXJzb3I6IGZ1bmN0aW9uKGNvcm5lciwgdGFyZ2V0LCBlKSB7XG4gICAgICBpZiAoY29ybmVyIGluIGN1cnNvck9mZnNldCkge1xuICAgICAgICB0aGlzLnNldEN1cnNvcih0aGlzLl9nZXRSb3RhdGVkQ29ybmVyQ3Vyc29yKGNvcm5lciwgdGFyZ2V0LCBlKSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjb3JuZXIgPT09ICdtdHInICYmIHRhcmdldC5oYXNSb3RhdGluZ1BvaW50KSB7XG4gICAgICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMucm90YXRpb25DdXJzb3IpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMuZGVmYXVsdEN1cnNvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Um90YXRlZENvcm5lckN1cnNvcjogZnVuY3Rpb24oY29ybmVyLCB0YXJnZXQsIGUpIHtcbiAgICAgIHZhciBuID0gTWF0aC5yb3VuZCgodGFyZ2V0LmdldEFuZ2xlKCkgJSAzNjApIC8gNDUpO1xuXG4gICAgICBpZiAobiA8IDApIHtcbiAgICAgICAgbiArPSA4OyAvLyBmdWxsIGNpcmNsZSBhaGVhZFxuICAgICAgfVxuICAgICAgbiArPSBjdXJzb3JPZmZzZXRbY29ybmVyXTtcbiAgICAgIGlmIChlW3RoaXMuYWx0QWN0aW9uS2V5XSAmJiBjdXJzb3JPZmZzZXRbY29ybmVyXSAlIDIgPT09IDApIHtcbiAgICAgICAgLy9pZiB3ZSBhcmUgaG9sZGluZyBzaGlmdCBhbmQgd2UgYXJlIG9uIGEgbXggY29ybmVyLi4uXG4gICAgICAgIG4gKz0gMjtcbiAgICAgIH1cbiAgICAgIC8vIG5vcm1hbGl6ZSBuIHRvIGJlIGZyb20gMCB0byA3XG4gICAgICBuICU9IDg7XG5cbiAgICAgIHJldHVybiB0aGlzLmN1cnNvck1hcFtuXTtcbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIG1pbiA9IE1hdGgubWluLFxuICAgICAgbWF4ID0gTWF0aC5tYXg7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuQ2FudmFzLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuQ2FudmFzLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIF9zaG91bGRHcm91cDogZnVuY3Rpb24oZSwgdGFyZ2V0KSB7XG4gICAgICB2YXIgYWN0aXZlT2JqZWN0ID0gdGhpcy5nZXRBY3RpdmVPYmplY3QoKTtcbiAgICAgIHJldHVybiBlW3RoaXMuc2VsZWN0aW9uS2V5XSAmJiB0YXJnZXQgJiYgdGFyZ2V0LnNlbGVjdGFibGUgJiZcbiAgICAgICAgICAgICh0aGlzLmdldEFjdGl2ZUdyb3VwKCkgfHwgKGFjdGl2ZU9iamVjdCAmJiBhY3RpdmVPYmplY3QgIT09IHRhcmdldCkpXG4gICAgICAgICAgICAmJiB0aGlzLnNlbGVjdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgX2hhbmRsZUdyb3VwaW5nOiBmdW5jdGlvbiAoZSwgdGFyZ2V0KSB7XG4gICAgICB2YXIgYWN0aXZlR3JvdXAgPSB0aGlzLmdldEFjdGl2ZUdyb3VwKCk7XG5cbiAgICAgIGlmICh0YXJnZXQgPT09IGFjdGl2ZUdyb3VwKSB7XG4gICAgICAgIC8vIGlmIGl0J3MgYSBncm91cCwgZmluZCB0YXJnZXQgYWdhaW4sIHVzaW5nIGFjdGl2ZUdyb3VwIG9iamVjdHNcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy5maW5kVGFyZ2V0KGUsIHRydWUpO1xuICAgICAgICAvLyBpZiBldmVuIG9iamVjdCBpcyBub3QgZm91bmQsIGJhaWwgb3V0XG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWN0aXZlR3JvdXApIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQWN0aXZlR3JvdXAodGFyZ2V0LCBlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9jcmVhdGVBY3RpdmVHcm91cCh0YXJnZXQsIGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYWN0aXZlR3JvdXApIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlR3JvdXAuc2F2ZUNvb3JkcygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVBY3RpdmVHcm91cDogZnVuY3Rpb24odGFyZ2V0LCBlKSB7XG4gICAgICB2YXIgYWN0aXZlR3JvdXAgPSB0aGlzLmdldEFjdGl2ZUdyb3VwKCk7XG5cbiAgICAgIGlmIChhY3RpdmVHcm91cC5jb250YWlucyh0YXJnZXQpKSB7XG5cbiAgICAgICAgYWN0aXZlR3JvdXAucmVtb3ZlV2l0aFVwZGF0ZSh0YXJnZXQpO1xuICAgICAgICB0YXJnZXQuc2V0KCdhY3RpdmUnLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKGFjdGl2ZUdyb3VwLnNpemUoKSA9PT0gMSkge1xuICAgICAgICAgIC8vIHJlbW92ZSBncm91cCBhbGx0b2dldGhlciBpZiBhZnRlciByZW1vdmFsIGl0IG9ubHkgY29udGFpbnMgMSBvYmplY3RcbiAgICAgICAgICB0aGlzLmRpc2NhcmRBY3RpdmVHcm91cChlKTtcbiAgICAgICAgICAvLyBhY3RpdmF0ZSBsYXN0IHJlbWFpbmluZyBvYmplY3RcbiAgICAgICAgICB0aGlzLnNldEFjdGl2ZU9iamVjdChhY3RpdmVHcm91cC5pdGVtKDApKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBhY3RpdmVHcm91cC5hZGRXaXRoVXBkYXRlKHRhcmdldCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZpcmUoJ3NlbGVjdGlvbjpjcmVhdGVkJywgeyB0YXJnZXQ6IGFjdGl2ZUdyb3VwLCBlOiBlIH0pO1xuICAgICAgYWN0aXZlR3JvdXAuc2V0KCdhY3RpdmUnLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQWN0aXZlR3JvdXA6IGZ1bmN0aW9uKHRhcmdldCwgZSkge1xuXG4gICAgICBpZiAodGhpcy5fYWN0aXZlT2JqZWN0ICYmIHRhcmdldCAhPT0gdGhpcy5fYWN0aXZlT2JqZWN0KSB7XG5cbiAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5fY3JlYXRlR3JvdXAodGFyZ2V0KTtcbiAgICAgICAgZ3JvdXAuYWRkV2l0aFVwZGF0ZSgpO1xuXG4gICAgICAgIHRoaXMuc2V0QWN0aXZlR3JvdXAoZ3JvdXApO1xuICAgICAgICB0aGlzLl9hY3RpdmVPYmplY3QgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuZmlyZSgnc2VsZWN0aW9uOmNyZWF0ZWQnLCB7IHRhcmdldDogZ3JvdXAsIGU6IGUgfSk7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC5zZXQoJ2FjdGl2ZScsIHRydWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfY3JlYXRlR3JvdXA6IGZ1bmN0aW9uKHRhcmdldCkge1xuXG4gICAgICB2YXIgb2JqZWN0cyA9IHRoaXMuZ2V0T2JqZWN0cygpLFxuICAgICAgICAgIGlzQWN0aXZlTG93ZXIgPSBvYmplY3RzLmluZGV4T2YodGhpcy5fYWN0aXZlT2JqZWN0KSA8IG9iamVjdHMuaW5kZXhPZih0YXJnZXQpLFxuICAgICAgICAgIGdyb3VwT2JqZWN0cyA9IGlzQWN0aXZlTG93ZXJcbiAgICAgICAgICAgID8gW3RoaXMuX2FjdGl2ZU9iamVjdCwgdGFyZ2V0XVxuICAgICAgICAgICAgOiBbdGFyZ2V0LCB0aGlzLl9hY3RpdmVPYmplY3RdO1xuICAgICAgdGhpcy5fYWN0aXZlT2JqZWN0LmlzRWRpdGluZyAmJiB0aGlzLl9hY3RpdmVPYmplY3QuZXhpdEVkaXRpbmcoKTtcbiAgICAgIHJldHVybiBuZXcgZmFicmljLkdyb3VwKGdyb3VwT2JqZWN0cywge1xuICAgICAgICBjYW52YXM6IHRoaXNcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgbW91c2UgZXZlbnRcbiAgICAgKi9cbiAgICBfZ3JvdXBTZWxlY3RlZE9iamVjdHM6IGZ1bmN0aW9uIChlKSB7XG5cbiAgICAgIHZhciBncm91cCA9IHRoaXMuX2NvbGxlY3RPYmplY3RzKCk7XG5cbiAgICAgIC8vIGRvIG5vdCBjcmVhdGUgZ3JvdXAgZm9yIDEgZWxlbWVudCBvbmx5XG4gICAgICBpZiAoZ3JvdXAubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlT2JqZWN0KGdyb3VwWzBdLCBlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGdyb3VwLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZ3JvdXAgPSBuZXcgZmFicmljLkdyb3VwKGdyb3VwLnJldmVyc2UoKSwge1xuICAgICAgICAgIGNhbnZhczogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgZ3JvdXAuYWRkV2l0aFVwZGF0ZSgpO1xuICAgICAgICB0aGlzLnNldEFjdGl2ZUdyb3VwKGdyb3VwLCBlKTtcbiAgICAgICAgZ3JvdXAuc2F2ZUNvb3JkcygpO1xuICAgICAgICB0aGlzLmZpcmUoJ3NlbGVjdGlvbjpjcmVhdGVkJywgeyB0YXJnZXQ6IGdyb3VwIH0pO1xuICAgICAgICB0aGlzLnJlbmRlckFsbCgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jb2xsZWN0T2JqZWN0czogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZ3JvdXAgPSBbXSxcbiAgICAgICAgICBjdXJyZW50T2JqZWN0LFxuICAgICAgICAgIHgxID0gdGhpcy5fZ3JvdXBTZWxlY3Rvci5leCxcbiAgICAgICAgICB5MSA9IHRoaXMuX2dyb3VwU2VsZWN0b3IuZXksXG4gICAgICAgICAgeDIgPSB4MSArIHRoaXMuX2dyb3VwU2VsZWN0b3IubGVmdCxcbiAgICAgICAgICB5MiA9IHkxICsgdGhpcy5fZ3JvdXBTZWxlY3Rvci50b3AsXG4gICAgICAgICAgc2VsZWN0aW9uWDFZMSA9IG5ldyBmYWJyaWMuUG9pbnQobWluKHgxLCB4MiksIG1pbih5MSwgeTIpKSxcbiAgICAgICAgICBzZWxlY3Rpb25YMlkyID0gbmV3IGZhYnJpYy5Qb2ludChtYXgoeDEsIHgyKSwgbWF4KHkxLCB5MikpLFxuICAgICAgICAgIGlzQ2xpY2sgPSB4MSA9PT0geDIgJiYgeTEgPT09IHkyO1xuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgIGN1cnJlbnRPYmplY3QgPSB0aGlzLl9vYmplY3RzW2ldO1xuXG4gICAgICAgIGlmICghY3VycmVudE9iamVjdCB8fCAhY3VycmVudE9iamVjdC5zZWxlY3RhYmxlIHx8ICFjdXJyZW50T2JqZWN0LnZpc2libGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50T2JqZWN0LmludGVyc2VjdHNXaXRoUmVjdChzZWxlY3Rpb25YMVkxLCBzZWxlY3Rpb25YMlkyKSB8fFxuICAgICAgICAgICAgY3VycmVudE9iamVjdC5pc0NvbnRhaW5lZFdpdGhpblJlY3Qoc2VsZWN0aW9uWDFZMSwgc2VsZWN0aW9uWDJZMikgfHxcbiAgICAgICAgICAgIGN1cnJlbnRPYmplY3QuY29udGFpbnNQb2ludChzZWxlY3Rpb25YMVkxKSB8fFxuICAgICAgICAgICAgY3VycmVudE9iamVjdC5jb250YWluc1BvaW50KHNlbGVjdGlvblgyWTIpXG4gICAgICAgICkge1xuICAgICAgICAgIGN1cnJlbnRPYmplY3Quc2V0KCdhY3RpdmUnLCB0cnVlKTtcbiAgICAgICAgICBncm91cC5wdXNoKGN1cnJlbnRPYmplY3QpO1xuXG4gICAgICAgICAgLy8gb25seSBhZGQgb25lIG9iamVjdCBpZiBpdCdzIGEgY2xpY2tcbiAgICAgICAgICBpZiAoaXNDbGljaykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWF5YmVHcm91cE9iamVjdHM6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbiAmJiB0aGlzLl9ncm91cFNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuX2dyb3VwU2VsZWN0ZWRPYmplY3RzKGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWN0aXZlR3JvdXAgPSB0aGlzLmdldEFjdGl2ZUdyb3VwKCk7XG4gICAgICBpZiAoYWN0aXZlR3JvdXApIHtcbiAgICAgICAgYWN0aXZlR3JvdXAuc2V0T2JqZWN0c0Nvb3JkcygpLnNldENvb3JkcygpO1xuICAgICAgICBhY3RpdmVHcm91cC5pc01vdmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNldEN1cnNvcih0aGlzLmRlZmF1bHRDdXJzb3IpO1xuICAgICAgfVxuXG4gICAgICAvLyBjbGVhciBzZWxlY3Rpb24gYW5kIGN1cnJlbnQgdHJhbnNmb3JtYXRpb25cbiAgICAgIHRoaXMuX2dyb3VwU2VsZWN0b3IgPSBudWxsO1xuICAgICAgdGhpcy5fY3VycmVudFRyYW5zZm9ybSA9IG51bGw7XG4gICAgfVxuICB9KTtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24gKCkge1xuXG4gIHZhciBzdXBwb3J0UXVhbGl0eSA9IGZhYnJpYy5TdGF0aWNDYW52YXMuc3VwcG9ydHMoJ3RvRGF0YVVSTFdpdGhRdWFsaXR5Jyk7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBFeHBvcnRzIGNhbnZhcyBlbGVtZW50IHRvIGEgZGF0YXVybCBpbWFnZS4gTm90ZSB0aGF0IHdoZW4gbXVsdGlwbGllciBpcyB1c2VkLCBjcm9wcGluZyBpcyBzY2FsZWQgYXBwcm9wcmlhdGVseVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZm9ybWF0PXBuZ10gVGhlIGZvcm1hdCBvZiB0aGUgb3V0cHV0IGltYWdlLiBFaXRoZXIgXCJqcGVnXCIgb3IgXCJwbmdcIlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5xdWFsaXR5PTFdIFF1YWxpdHkgbGV2ZWwgKDAuLjEpLiBPbmx5IHVzZWQgZm9yIGpwZWcuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm11bHRpcGxpZXI9MV0gTXVsdGlwbGllciB0byBzY2FsZSBieVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sZWZ0XSBDcm9wcGluZyBsZWZ0IG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRvcF0gQ3JvcHBpbmcgdG9wIG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoXSBDcm9wcGluZyB3aWR0aC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gQ3JvcHBpbmcgaGVpZ2h0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFJldHVybnMgYSBkYXRhOiBVUkwgY29udGFpbmluZyBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QgaW4gdGhlIGZvcm1hdCBzcGVjaWZpZWQgYnkgb3B0aW9ucy5mb3JtYXRcbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL05mWlZiL3xqc0ZpZGRsZSBkZW1vfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkdlbmVyYXRlIGpwZWcgZGF0YVVSTCB3aXRoIGxvd2VyIHF1YWxpdHk8L2NhcHRpb24+XG4gICAgICogdmFyIGRhdGFVUkwgPSBjYW52YXMudG9EYXRhVVJMKHtcbiAgICAgKiAgIGZvcm1hdDogJ2pwZWcnLFxuICAgICAqICAgcXVhbGl0eTogMC44XG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+R2VuZXJhdGUgY3JvcHBlZCBwbmcgZGF0YVVSTCAoY2xpcHBpbmcgb2YgY2FudmFzKTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgZGF0YVVSTCA9IGNhbnZhcy50b0RhdGFVUkwoe1xuICAgICAqICAgZm9ybWF0OiAncG5nJyxcbiAgICAgKiAgIGxlZnQ6IDEwMCxcbiAgICAgKiAgIHRvcDogMTAwLFxuICAgICAqICAgd2lkdGg6IDIwMCxcbiAgICAgKiAgIGhlaWdodDogMjAwXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+R2VuZXJhdGUgZG91YmxlIHNjYWxlZCBwbmcgZGF0YVVSTDwvY2FwdGlvbj5cbiAgICAgKiB2YXIgZGF0YVVSTCA9IGNhbnZhcy50b0RhdGFVUkwoe1xuICAgICAqICAgZm9ybWF0OiAncG5nJyxcbiAgICAgKiAgIG11bHRpcGxpZXI6IDJcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICB0b0RhdGFVUkw6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdmFyIGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8ICdwbmcnLFxuICAgICAgICAgIHF1YWxpdHkgPSBvcHRpb25zLnF1YWxpdHkgfHwgMSxcbiAgICAgICAgICBtdWx0aXBsaWVyID0gb3B0aW9ucy5tdWx0aXBsaWVyIHx8IDEsXG4gICAgICAgICAgY3JvcHBpbmcgPSB7XG4gICAgICAgICAgICBsZWZ0OiBvcHRpb25zLmxlZnQgfHwgMCxcbiAgICAgICAgICAgIHRvcDogb3B0aW9ucy50b3AgfHwgMCxcbiAgICAgICAgICAgIHdpZHRoOiBvcHRpb25zLndpZHRoIHx8IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IG9wdGlvbnMuaGVpZ2h0IHx8IDAsXG4gICAgICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9EYXRhVVJMV2l0aE11bHRpcGxpZXIoZm9ybWF0LCBxdWFsaXR5LCBjcm9wcGluZywgbXVsdGlwbGllcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX190b0RhdGFVUkxXaXRoTXVsdGlwbGllcjogZnVuY3Rpb24oZm9ybWF0LCBxdWFsaXR5LCBjcm9wcGluZywgbXVsdGlwbGllcikge1xuXG4gICAgICB2YXIgb3JpZ1dpZHRoID0gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICAgIG9yaWdIZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpLFxuICAgICAgICAgIHNjYWxlZFdpZHRoID0gKGNyb3BwaW5nLndpZHRoIHx8IHRoaXMuZ2V0V2lkdGgoKSkgKiBtdWx0aXBsaWVyLFxuICAgICAgICAgIHNjYWxlZEhlaWdodCA9IChjcm9wcGluZy5oZWlnaHQgfHwgdGhpcy5nZXRIZWlnaHQoKSkgKiBtdWx0aXBsaWVyLFxuICAgICAgICAgIHpvb20gPSB0aGlzLmdldFpvb20oKSxcbiAgICAgICAgICBuZXdab29tID0gem9vbSAqIG11bHRpcGxpZXIsXG4gICAgICAgICAgdnAgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtLFxuICAgICAgICAgIHRyYW5zbGF0ZVggPSAodnBbNF0gLSBjcm9wcGluZy5sZWZ0KSAqIG11bHRpcGxpZXIsXG4gICAgICAgICAgdHJhbnNsYXRlWSA9ICh2cFs1XSAtIGNyb3BwaW5nLnRvcCkgKiBtdWx0aXBsaWVyLFxuICAgICAgICAgIG5ld1ZwID0gW25ld1pvb20sIDAsIDAsIG5ld1pvb20sIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVldLFxuICAgICAgICAgIG9yaWdpbmFsSW50ZXJhY3RpdmUgPSB0aGlzLmludGVyYWN0aXZlO1xuXG4gICAgICB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtID0gbmV3VnA7XG4gICAgICAvLyBzZXR0aW5nIGludGVyYWN0aXZlIHRvIGZhbHNlIGF2b2lkIGV4cG9ydGluZyBjb250cm9sc1xuICAgICAgdGhpcy5pbnRlcmFjdGl2ZSAmJiAodGhpcy5pbnRlcmFjdGl2ZSA9IGZhbHNlKTtcbiAgICAgIGlmIChvcmlnV2lkdGggIT09IHNjYWxlZFdpZHRoIHx8IG9yaWdIZWlnaHQgIT09IHNjYWxlZEhlaWdodCkge1xuICAgICAgICAvLyB0aGlzLnNldERpbWVuc2lvbnMgaXMgZ29pbmcgdG8gcmVuZGVyQWxsIGFsc287XG4gICAgICAgIHRoaXMuc2V0RGltZW5zaW9ucyh7IHdpZHRoOiBzY2FsZWRXaWR0aCwgaGVpZ2h0OiBzY2FsZWRIZWlnaHQgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW5kZXJBbGwoKTtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX3RvRGF0YVVSTChmb3JtYXQsIHF1YWxpdHksIGNyb3BwaW5nKTtcbiAgICAgIG9yaWdpbmFsSW50ZXJhY3RpdmUgJiYgKHRoaXMuaW50ZXJhY3RpdmUgPSBvcmlnaW5hbEludGVyYWN0aXZlKTtcbiAgICAgIHRoaXMudmlld3BvcnRUcmFuc2Zvcm0gPSB2cDtcbiAgICAgIC8vc2V0RGltZW5zaW9ucyB3aXRoIG5vIG9wdGlvbiBvYmplY3QgaXMgdGFraW5nIGNhcmUgb2Y6XG4gICAgICAvL3RoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLnJlbmRlckFsbCgpXG4gICAgICB0aGlzLnNldERpbWVuc2lvbnMoeyB3aWR0aDogb3JpZ1dpZHRoLCBoZWlnaHQ6IG9yaWdIZWlnaHQgfSk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfX3RvRGF0YVVSTDogZnVuY3Rpb24oZm9ybWF0LCBxdWFsaXR5KSB7XG5cbiAgICAgIHZhciBjYW52YXNFbCA9IHRoaXMuY29udGV4dENvbnRhaW5lci5jYW52YXM7XG4gICAgICAvLyB0byBhdm9pZCBjb21tb24gY29uZnVzaW9uIGh0dHBzOi8vZ2l0aHViLmNvbS9rYW5nYXgvZmFicmljLmpzL2lzc3Vlcy84MDZcbiAgICAgIGlmIChmb3JtYXQgPT09ICdqcGcnKSB7XG4gICAgICAgIGZvcm1hdCA9ICdqcGVnJztcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGEgPSBzdXBwb3J0UXVhbGl0eVxuICAgICAgICAgICAgICAgID8gY2FudmFzRWwudG9EYXRhVVJMKCdpbWFnZS8nICsgZm9ybWF0LCBxdWFsaXR5KVxuICAgICAgICAgICAgICAgIDogY2FudmFzRWwudG9EYXRhVVJMKCdpbWFnZS8nICsgZm9ybWF0KTtcblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgY2FudmFzIGVsZW1lbnQgdG8gYSBkYXRhdXJsIGltYWdlIChhbGxvd2luZyB0byBjaGFuZ2UgaW1hZ2Ugc2l6ZSB2aWEgbXVsdGlwbGllcikuXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgMS4wLjEzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdCAocG5nfGpwZWcpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG11bHRpcGxpZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcXVhbGl0eSAoMC4uMSlcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9EYXRhVVJMV2l0aE11bHRpcGxpZXI6IGZ1bmN0aW9uIChmb3JtYXQsIG11bHRpcGxpZXIsIHF1YWxpdHkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvRGF0YVVSTCh7XG4gICAgICAgIGZvcm1hdDogZm9ybWF0LFxuICAgICAgICBtdWx0aXBsaWVyOiBtdWx0aXBsaWVyLFxuICAgICAgICBxdWFsaXR5OiBxdWFsaXR5XG4gICAgICB9KTtcbiAgICB9LFxuICB9KTtcblxufSkoKTtcblxuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogUG9wdWxhdGVzIGNhbnZhcyB3aXRoIGRhdGEgZnJvbSB0aGUgc3BlY2lmaWVkIGRhdGFsZXNzIEpTT04uXG4gICAqIEpTT04gZm9ybWF0IG11c3QgY29uZm9ybSB0byB0aGUgb25lIG9mIHtAbGluayBmYWJyaWMuQ2FudmFzI3RvRGF0YWxlc3NKU09OfVxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSAxLjIuMlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGpzb24gSlNPTiBzdHJpbmcgb3Igb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrLCBpbnZva2VkIHdoZW4ganNvbiBpcyBwYXJzZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIGNvcnJlc3BvbmRpbmcgb2JqZWN0cyAoZS5nOiB7QGxpbmsgZmFicmljLkltYWdlfSlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIGluaXRpYWxpemVkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBKU09OIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAqIEBjaGFpbmFibGVcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTMjZGVzZXJpYWxpemF0aW9ufVxuICAgKi9cbiAgbG9hZEZyb21EYXRhbGVzc0pTT046IGZ1bmN0aW9uIChqc29uLCBjYWxsYmFjaywgcmV2aXZlcikge1xuICAgIHJldHVybiB0aGlzLmxvYWRGcm9tSlNPTihqc29uLCBjYWxsYmFjaywgcmV2aXZlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBvcHVsYXRlcyBjYW52YXMgd2l0aCBkYXRhIGZyb20gdGhlIHNwZWNpZmllZCBKU09OLlxuICAgKiBKU09OIGZvcm1hdCBtdXN0IGNvbmZvcm0gdG8gdGhlIG9uZSBvZiB7QGxpbmsgZmFicmljLkNhbnZhcyN0b0pTT059XG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0ganNvbiBKU09OIHN0cmluZyBvciBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2ssIGludm9rZWQgd2hlbiBqc29uIGlzIHBhcnNlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgY29ycmVzcG9uZGluZyBvYmplY3RzIChlLmc6IHtAbGluayBmYWJyaWMuSW1hZ2V9KVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgaW5pdGlhbGl6ZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIEpTT04gZWxlbWVudHMsIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICogQGNoYWluYWJsZVxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMyNkZXNlcmlhbGl6YXRpb259XG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvZm1nWHQvfGpzRmlkZGxlIGRlbW99XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPmxvYWRGcm9tSlNPTjwvY2FwdGlvbj5cbiAgICogY2FudmFzLmxvYWRGcm9tSlNPTihqc29uLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPmxvYWRGcm9tSlNPTiB3aXRoIHJldml2ZXI8L2NhcHRpb24+XG4gICAqIGNhbnZhcy5sb2FkRnJvbUpTT04oanNvbiwgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIGZ1bmN0aW9uKG8sIG9iamVjdCkge1xuICAgKiAgIC8vIGBvYCA9IGpzb24gb2JqZWN0XG4gICAqICAgLy8gYG9iamVjdGAgPSBmYWJyaWMuT2JqZWN0IGluc3RhbmNlXG4gICAqICAgLy8gLi4uIGRvIHNvbWUgc3R1ZmYgLi4uXG4gICAqIH0pO1xuICAgKi9cbiAgbG9hZEZyb21KU09OOiBmdW5jdGlvbiAoanNvbiwgY2FsbGJhY2ssIHJldml2ZXIpIHtcbiAgICBpZiAoIWpzb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzZXJpYWxpemUgaWYgaXQgd2Fzbid0IGFscmVhZHlcbiAgICB2YXIgc2VyaWFsaXplZCA9ICh0eXBlb2YganNvbiA9PT0gJ3N0cmluZycpXG4gICAgICA/IEpTT04ucGFyc2UoanNvbilcbiAgICAgIDogZmFicmljLnV0aWwub2JqZWN0LmNsb25lKGpzb24pO1xuXG4gICAgdGhpcy5jbGVhcigpO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLl9lbmxpdmVuT2JqZWN0cyhzZXJpYWxpemVkLm9iamVjdHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLl9zZXRCZ092ZXJsYXkoc2VyaWFsaXplZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyByZW1vdmUgcGFydHMgaSBjYW5ub3Qgc2V0IGFzIG9wdGlvbnNcbiAgICAgICAgZGVsZXRlIHNlcmlhbGl6ZWQub2JqZWN0cztcbiAgICAgICAgZGVsZXRlIHNlcmlhbGl6ZWQuYmFja2dyb3VuZEltYWdlO1xuICAgICAgICBkZWxldGUgc2VyaWFsaXplZC5vdmVybGF5SW1hZ2U7XG4gICAgICAgIGRlbGV0ZSBzZXJpYWxpemVkLmJhY2tncm91bmQ7XG4gICAgICAgIGRlbGV0ZSBzZXJpYWxpemVkLm92ZXJsYXk7XG4gICAgICAgIC8vIHRoaXMuX2luaXRPcHRpb25zIGRvZXMgdG9vIG1hbnkgdGhpbmdzIHRvIGp1c3RcbiAgICAgICAgLy8gY2FsbCBpdC4gTm9ybWFsbHkgbG9hZGluZyBhbiBPYmplY3QgZnJvbSBKU09OXG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgT2JqZWN0IGluc3RhbmNlLiBIZXJlIHRoZSBDYW52YXMgaXNcbiAgICAgICAgLy8gYWxyZWFkeSBhbiBpbnN0YW5jZSBhbmQgd2UgYXJlIGp1c3QgbG9hZGluZyB0aGluZ3Mgb3ZlciBpdFxuICAgICAgICBfdGhpcy5fc2V0T3B0aW9ucyhzZXJpYWxpemVkKTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgIH0sIHJldml2ZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2VyaWFsaXplZCBPYmplY3Qgd2l0aCBiYWNrZ3JvdW5kIGFuZCBvdmVybGF5IGluZm9ybWF0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEludm9rZWQgYWZ0ZXIgYWxsIGJhY2tncm91bmQgYW5kIG92ZXJsYXkgaW1hZ2VzL3BhdHRlcm5zIGxvYWRlZFxuICAgKi9cbiAgX3NldEJnT3ZlcmxheTogZnVuY3Rpb24oc2VyaWFsaXplZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICBsb2FkZWQgPSB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBmYWxzZSxcbiAgICAgICAgICBvdmVybGF5Q29sb3I6IGZhbHNlLFxuICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogZmFsc2UsXG4gICAgICAgICAgb3ZlcmxheUltYWdlOiBmYWxzZVxuICAgICAgICB9O1xuXG4gICAgaWYgKCFzZXJpYWxpemVkLmJhY2tncm91bmRJbWFnZSAmJiAhc2VyaWFsaXplZC5vdmVybGF5SW1hZ2UgJiYgIXNlcmlhbGl6ZWQuYmFja2dyb3VuZCAmJiAhc2VyaWFsaXplZC5vdmVybGF5KSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjYklmTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGxvYWRlZC5iYWNrZ3JvdW5kSW1hZ2UgJiYgbG9hZGVkLm92ZXJsYXlJbWFnZSAmJiBsb2FkZWQuYmFja2dyb3VuZENvbG9yICYmIGxvYWRlZC5vdmVybGF5Q29sb3IpIHtcbiAgICAgICAgX3RoaXMucmVuZGVyQWxsKCk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuX19zZXRCZ092ZXJsYXkoJ2JhY2tncm91bmRJbWFnZScsIHNlcmlhbGl6ZWQuYmFja2dyb3VuZEltYWdlLCBsb2FkZWQsIGNiSWZMb2FkZWQpO1xuICAgIHRoaXMuX19zZXRCZ092ZXJsYXkoJ292ZXJsYXlJbWFnZScsIHNlcmlhbGl6ZWQub3ZlcmxheUltYWdlLCBsb2FkZWQsIGNiSWZMb2FkZWQpO1xuICAgIHRoaXMuX19zZXRCZ092ZXJsYXkoJ2JhY2tncm91bmRDb2xvcicsIHNlcmlhbGl6ZWQuYmFja2dyb3VuZCwgbG9hZGVkLCBjYklmTG9hZGVkKTtcbiAgICB0aGlzLl9fc2V0QmdPdmVybGF5KCdvdmVybGF5Q29sb3InLCBzZXJpYWxpemVkLm92ZXJsYXksIGxvYWRlZCwgY2JJZkxvYWRlZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBzZXQgKGJhY2tncm91bmRJbWFnZSwgb3ZlcmxheUltYWdlLCBiYWNrZ3JvdW5kQ29sb3IsIG92ZXJsYXlDb2xvcilcbiAgICogQHBhcmFtIHsoT2JqZWN0fFN0cmluZyl9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgKiBAcGFyYW0ge09iamVjdH0gbG9hZGVkIFNldCBsb2FkZWQgcHJvcGVydHkgdG8gdHJ1ZSBpZiBwcm9wZXJ0eSBpcyBzZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGludm9rZSBhZnRlciBwcm9wZXJ0eSBpcyBzZXRcbiAgICovXG4gIF9fc2V0QmdPdmVybGF5OiBmdW5jdGlvbihwcm9wZXJ0eSwgdmFsdWUsIGxvYWRlZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgbG9hZGVkW3Byb3BlcnR5XSA9IHRydWU7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wZXJ0eSA9PT0gJ2JhY2tncm91bmRJbWFnZScgfHwgcHJvcGVydHkgPT09ICdvdmVybGF5SW1hZ2UnKSB7XG4gICAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhbdmFsdWVdLCBmdW5jdGlvbihlbmxpdmVkT2JqZWN0KXtcbiAgICAgICAgX3RoaXNbcHJvcGVydHldID0gZW5saXZlZE9iamVjdFswXTtcbiAgICAgICAgbG9hZGVkW3Byb3BlcnR5XSA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzWydzZXQnICsgZmFicmljLnV0aWwuc3RyaW5nLmNhcGl0YWxpemUocHJvcGVydHksIHRydWUpXSh2YWx1ZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGxvYWRlZFtwcm9wZXJ0eV0gPSB0cnVlO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXVxuICAgKi9cbiAgX2VubGl2ZW5PYmplY3RzOiBmdW5jdGlvbiAob2JqZWN0cywgY2FsbGJhY2ssIHJldml2ZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCFvYmplY3RzIHx8IG9iamVjdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZW5kZXJPbkFkZFJlbW92ZSA9IHRoaXMucmVuZGVyT25BZGRSZW1vdmU7XG4gICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSA9IGZhbHNlO1xuXG4gICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMob2JqZWN0cywgZnVuY3Rpb24oZW5saXZlbmVkT2JqZWN0cykge1xuICAgICAgZW5saXZlbmVkT2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iaiwgaW5kZXgpIHtcbiAgICAgICAgLy8gd2Ugc3BsaWNlIHRoZSBhcnJheSBqdXN0IGluIGNhc2Ugc29tZSBjdXN0b20gY2xhc3NlcyByZXN0b3JlZCBmcm9tIEpTT05cbiAgICAgICAgLy8gd2lsbCBhZGQgbW9yZSBvYmplY3QgdG8gY2FudmFzIGF0IGNhbnZhcyBpbml0LlxuICAgICAgICBfdGhpcy5pbnNlcnRBdChvYmosIGluZGV4KTtcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSA9IHJlbmRlck9uQWRkUmVtb3ZlO1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9LCBudWxsLCByZXZpdmVyKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgX3RvRGF0YVVSTDogZnVuY3Rpb24gKGZvcm1hdCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmNsb25lKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgY2FsbGJhY2soY2xvbmUudG9EYXRhVVJMKGZvcm1hdCkpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtdWx0aXBsaWVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBfdG9EYXRhVVJMV2l0aE11bHRpcGxpZXI6IGZ1bmN0aW9uIChmb3JtYXQsIG11bHRpcGxpZXIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jbG9uZShmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgIGNhbGxiYWNrKGNsb25lLnRvRGF0YVVSTFdpdGhNdWx0aXBsaWVyKGZvcm1hdCwgbXVsdGlwbGllcikpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9uZXMgY2FudmFzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY2FsbGJhY2tdIFJlY2VpdmVzIGNsb25lZCBpbnN0YW5jZSBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzXSBBcnJheSBvZiBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgaW4gdGhlIGNsb25lZCBjYW52YXMgYW5kIGNoaWxkcmVuXG4gICAqL1xuICBjbG9uZTogZnVuY3Rpb24gKGNhbGxiYWNrLCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIGRhdGEgPSBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTihwcm9wZXJ0aWVzKSk7XG4gICAgdGhpcy5jbG9uZVdpdGhvdXREYXRhKGZ1bmN0aW9uKGNsb25lKSB7XG4gICAgICBjbG9uZS5sb2FkRnJvbUpTT04oZGF0YSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGNsb25lKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9uZXMgY2FudmFzIGluc3RhbmNlIHdpdGhvdXQgY2xvbmluZyBleGlzdGluZyBkYXRhLlxuICAgKiBUaGlzIGVzc2VudGlhbGx5IGNvcGllcyBjYW52YXMgZGltZW5zaW9ucywgY2xpcHBpbmcgcHJvcGVydGllcywgZXRjLlxuICAgKiBidXQgbGVhdmVzIGRhdGEgZW1wdHkgKHNvIHRoYXQgeW91IGNhbiBwb3B1bGF0ZSBpdCB3aXRoIHlvdXIgb3duKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NhbGxiYWNrXSBSZWNlaXZlcyBjbG9uZWQgaW5zdGFuY2UgYXMgYSBmaXJzdCBhcmd1bWVudFxuICAgKi9cbiAgY2xvbmVXaXRob3V0RGF0YTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgZWwgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICBlbC53aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICBlbC5oZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xuXG4gICAgdmFyIGNsb25lID0gbmV3IGZhYnJpYy5DYW52YXMoZWwpO1xuICAgIGNsb25lLmNsaXBUbyA9IHRoaXMuY2xpcFRvO1xuICAgIGlmICh0aGlzLmJhY2tncm91bmRJbWFnZSkge1xuICAgICAgY2xvbmUuc2V0QmFja2dyb3VuZEltYWdlKHRoaXMuYmFja2dyb3VuZEltYWdlLnNyYywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsb25lLnJlbmRlckFsbCgpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhjbG9uZSk7XG4gICAgICB9KTtcbiAgICAgIGNsb25lLmJhY2tncm91bmRJbWFnZU9wYWNpdHkgPSB0aGlzLmJhY2tncm91bmRJbWFnZU9wYWNpdHk7XG4gICAgICBjbG9uZS5iYWNrZ3JvdW5kSW1hZ2VTdHJldGNoID0gdGhpcy5iYWNrZ3JvdW5kSW1hZ2VTdHJldGNoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGNsb25lKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGNsb25lID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lLFxuICAgICAgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQsXG4gICAgICBjYXBpdGFsaXplID0gZmFicmljLnV0aWwuc3RyaW5nLmNhcGl0YWxpemUsXG4gICAgICBkZWdyZWVzVG9SYWRpYW5zID0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyxcbiAgICAgIHN1cHBvcnRzTGluZURhc2ggPSBmYWJyaWMuU3RhdGljQ2FudmFzLnN1cHBvcnRzKCdzZXRMaW5lRGFzaCcpLFxuICAgICAgb2JqZWN0Q2FjaGluZyA9ICFmYWJyaWMuaXNMaWtlbHlOb2RlO1xuXG4gIGlmIChmYWJyaWMuT2JqZWN0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFJvb3Qgb2JqZWN0IGNsYXNzIGZyb20gd2hpY2ggYWxsIDJkIHNoYXBlIGNsYXNzZXMgaW5oZXJpdCBmcm9tXG4gICAqIEBjbGFzcyBmYWJyaWMuT2JqZWN0XG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0xI29iamVjdHN9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5PYmplY3QjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICpcbiAgICogQGZpcmVzIGFkZGVkXG4gICAqIEBmaXJlcyByZW1vdmVkXG4gICAqXG4gICAqIEBmaXJlcyBzZWxlY3RlZFxuICAgKiBAZmlyZXMgZGVzZWxlY3RlZFxuICAgKiBAZmlyZXMgbW9kaWZpZWRcbiAgICogQGZpcmVzIHJvdGF0aW5nXG4gICAqIEBmaXJlcyBzY2FsaW5nXG4gICAqIEBmaXJlcyBtb3ZpbmdcbiAgICogQGZpcmVzIHNrZXdpbmdcbiAgICpcbiAgICogQGZpcmVzIG1vdXNlZG93blxuICAgKiBAZmlyZXMgbW91c2V1cFxuICAgKiBAZmlyZXMgbW91c2VvdmVyXG4gICAqIEBmaXJlcyBtb3VzZW91dFxuICAgKiBAZmlyZXMgbW91c2V3aGVlbFxuICAgKi9cbiAgZmFicmljLk9iamVjdCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5Db21tb25NZXRob2RzLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCNjbGlwVG98Y2xpcHBpbmcgZnVuY3Rpb259XG4gICAgICogQG1ldGhvZCBnZXRDbGlwVG9cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFNldHMgb2JqZWN0J3Mge0BsaW5rIGZhYnJpYy5PYmplY3QjY2xpcFRvfGNsaXBwaW5nIGZ1bmN0aW9ufVxuICAgICAqIEBtZXRob2Qgc2V0Q2xpcFRvXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2xpcFRvIENsaXBwaW5nIGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCN0cmFuc2Zvcm1NYXRyaXh8dHJhbnNmb3JtTWF0cml4fVxuICAgICAqIEBtZXRob2QgZ2V0VHJhbnNmb3JtTWF0cml4XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7QXJyYXl9IHRyYW5zZm9ybU1hdHJpeFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCN0cmFuc2Zvcm1NYXRyaXh8dHJhbnNmb3JtTWF0cml4fVxuICAgICAqIEBtZXRob2Qgc2V0VHJhbnNmb3JtTWF0cml4XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtTWF0cml4XG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCN2aXNpYmxlfHZpc2libGV9IHN0YXRlXG4gICAgICogQG1ldGhvZCBnZXRWaXNpYmxlXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB2aXNpYmxlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9iamVjdCdzIHtAbGluayBmYWJyaWMuT2JqZWN0I3Zpc2libGV8dmlzaWJsZX0gc3RhdGVcbiAgICAgKiBAbWV0aG9kIHNldFZpc2libGVcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIHZpc2libGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG9iamVjdCdzIHtAbGluayBmYWJyaWMuT2JqZWN0I3NoYWRvd3xzaGFkb3d9XG4gICAgICogQG1ldGhvZCBnZXRTaGFkb3dcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFNoYWRvdyBpbnN0YW5jZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG9iamVjdCdzIHtAbGluayBmYWJyaWMuT2JqZWN0I3N0cm9rZXxzdHJva2V9XG4gICAgICogQG1ldGhvZCBnZXRTdHJva2VcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN0cm9rZSB2YWx1ZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCNzdHJva2V8c3Ryb2tlfVxuICAgICAqIEBtZXRob2Qgc2V0U3Ryb2tlXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIHN0cm9rZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgb2JqZWN0J3Mge0BsaW5rIGZhYnJpYy5PYmplY3Qjc3Ryb2tlV2lkdGh8c3Ryb2tlV2lkdGh9XG4gICAgICogQG1ldGhvZCBnZXRTdHJva2VXaWR0aFxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gc3Ryb2tlV2lkdGggdmFsdWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFNldHMgb2JqZWN0J3Mge0BsaW5rIGZhYnJpYy5PYmplY3Qjc3Ryb2tlV2lkdGh8c3Ryb2tlV2lkdGh9XG4gICAgICogQG1ldGhvZCBzZXRTdHJva2VXaWR0aFxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBzdHJva2VXaWR0aCB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgb2JqZWN0J3Mge0BsaW5rIGZhYnJpYy5PYmplY3Qjb3JpZ2luWHxvcmlnaW5YfVxuICAgICAqIEBtZXRob2QgZ2V0T3JpZ2luWFxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gb3JpZ2luWCB2YWx1ZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCNvcmlnaW5YfG9yaWdpblh9XG4gICAgICogQG1ldGhvZCBzZXRPcmlnaW5YXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIG9yaWdpblggdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG9iamVjdCdzIHtAbGluayBmYWJyaWMuT2JqZWN0I29yaWdpbll8b3JpZ2luWX1cbiAgICAgKiBAbWV0aG9kIGdldE9yaWdpbllcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IG9yaWdpblkgdmFsdWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFNldHMgb2JqZWN0J3Mge0BsaW5rIGZhYnJpYy5PYmplY3Qjb3JpZ2luWXxvcmlnaW5ZfVxuICAgICAqIEBtZXRob2Qgc2V0T3JpZ2luWVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBvcmlnaW5ZIHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCNmaWxsfGZpbGx9XG4gICAgICogQG1ldGhvZCBnZXRGaWxsXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBGaWxsIHZhbHVlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9iamVjdCdzIHtAbGluayBmYWJyaWMuT2JqZWN0I2ZpbGx8ZmlsbH1cbiAgICAgKiBAbWV0aG9kIHNldEZpbGxcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgRmlsbCB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgb2JqZWN0J3Mge0BsaW5rIGZhYnJpYy5PYmplY3Qjb3BhY2l0eXxvcGFjaXR5fVxuICAgICAqIEBtZXRob2QgZ2V0T3BhY2l0eVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gT3BhY2l0eSB2YWx1ZSAoMC0xKVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCNvcGFjaXR5fG9wYWNpdHl9XG4gICAgICogQG1ldGhvZCBzZXRPcGFjaXR5XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIE9wYWNpdHkgdmFsdWUgKDAtMSlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG9iamVjdCdzIHtAbGluayBmYWJyaWMuT2JqZWN0I2FuZ2xlfGFuZ2xlfSAoaW4gZGVncmVlcylcbiAgICAgKiBAbWV0aG9kIGdldEFuZ2xlXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG9iamVjdCdzIHtAbGluayBmYWJyaWMuT2JqZWN0I3RvcHx0b3AgcG9zaXRpb259XG4gICAgICogQG1ldGhvZCBnZXRUb3BcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRvcCB2YWx1ZSAoaW4gcGl4ZWxzKVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCN0b3B8dG9wIHBvc2l0aW9ufVxuICAgICAqIEBtZXRob2Qgc2V0VG9wXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRvcCB2YWx1ZSAoaW4gcGl4ZWxzKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgb2JqZWN0J3Mge0BsaW5rIGZhYnJpYy5PYmplY3QjbGVmdHxsZWZ0IHBvc2l0aW9ufVxuICAgICAqIEBtZXRob2QgZ2V0TGVmdFxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTGVmdCB2YWx1ZSAoaW4gcGl4ZWxzKVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCNsZWZ0fGxlZnQgcG9zaXRpb259XG4gICAgICogQG1ldGhvZCBzZXRMZWZ0XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIExlZnQgdmFsdWUgKGluIHBpeGVscylcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG9iamVjdCdzIHtAbGluayBmYWJyaWMuT2JqZWN0I3NjYWxlWHxzY2FsZVh9IHZhbHVlXG4gICAgICogQG1ldGhvZCBnZXRTY2FsZVhcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlWCB2YWx1ZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCNzY2FsZVh8c2NhbGVYfSB2YWx1ZVxuICAgICAqIEBtZXRob2Qgc2V0U2NhbGVYXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIHNjYWxlWCB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgb2JqZWN0J3Mge0BsaW5rIGZhYnJpYy5PYmplY3Qjc2NhbGVZfHNjYWxlWX0gdmFsdWVcbiAgICAgKiBAbWV0aG9kIGdldFNjYWxlWVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gc2NhbGVZIHZhbHVlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9iamVjdCdzIHtAbGluayBmYWJyaWMuT2JqZWN0I3NjYWxlWXxzY2FsZVl9IHZhbHVlXG4gICAgICogQG1ldGhvZCBzZXRTY2FsZVlcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgc2NhbGVZIHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCNmbGlwWHxmbGlwWH0gdmFsdWVcbiAgICAgKiBAbWV0aG9kIGdldEZsaXBYXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gZmxpcFggdmFsdWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFNldHMgb2JqZWN0J3Mge0BsaW5rIGZhYnJpYy5PYmplY3QjZmxpcFh8ZmxpcFh9IHZhbHVlXG4gICAgICogQG1ldGhvZCBzZXRGbGlwWFxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgZmxpcFggdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG9iamVjdCdzIHtAbGluayBmYWJyaWMuT2JqZWN0I2ZsaXBZfGZsaXBZfSB2YWx1ZVxuICAgICAqIEBtZXRob2QgZ2V0RmxpcFlcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBmbGlwWSB2YWx1ZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBvYmplY3QncyB7QGxpbmsgZmFicmljLk9iamVjdCNmbGlwWXxmbGlwWX0gdmFsdWVcbiAgICAgKiBAbWV0aG9kIHNldEZsaXBZXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBmbGlwWSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdCAocmVjdCwgY2lyY2xlLCBwYXRoLCBldGMuKS5cbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyBtZWFudCB0byBiZSByZWFkLW9ubHkgYW5kIG5vdCBtZWFudCB0byBiZSBtb2RpZmllZC5cbiAgICAgKiBJZiB5b3UgbW9kaWZ5LCBjZXJ0YWluIHBhcnRzIG9mIEZhYnJpYyAoc3VjaCBhcyBKU09OIGxvYWRpbmcpIHdvbid0IHdvcmsgY29ycmVjdGx5LlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogICAgICAgICAgICAgICAgICAgICAnb2JqZWN0JyxcblxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWwgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uIG9mIGFuIG9iamVjdCAob25lIG9mIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiY2VudGVyXCIpXG4gICAgICogU2VlIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvMW93MDJnZWEvNDAvIG9uIGhvdyBvcmlnaW5YL29yaWdpblkgYWZmZWN0IG9iamVjdHMgaW4gZ3JvdXBzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvcmlnaW5YOiAgICAgICAgICAgICAgICAgICdsZWZ0JyxcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2FsIG9yaWdpbiBvZiB0cmFuc2Zvcm1hdGlvbiBvZiBhbiBvYmplY3QgKG9uZSBvZiBcInRvcFwiLCBcImJvdHRvbVwiLCBcImNlbnRlclwiKVxuICAgICAqIFNlZSBodHRwOi8vanNmaWRkbGUubmV0LzFvdzAyZ2VhLzQwLyBvbiBob3cgb3JpZ2luWC9vcmlnaW5ZIGFmZmVjdCBvYmplY3RzIGluIGdyb3Vwc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3JpZ2luWTogICAgICAgICAgICAgICAgICAndG9wJyxcblxuICAgIC8qKlxuICAgICAqIFRvcCBwb3NpdGlvbiBvZiBhbiBvYmplY3QuIE5vdGUgdGhhdCBieSBkZWZhdWx0IGl0J3MgcmVsYXRpdmUgdG8gb2JqZWN0IHRvcC4gWW91IGNhbiBjaGFuZ2UgdGhpcyBieSBzZXR0aW5nIG9yaWdpblk9e3RvcC9jZW50ZXIvYm90dG9tfVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdG9wOiAgICAgICAgICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogTGVmdCBwb3NpdGlvbiBvZiBhbiBvYmplY3QuIE5vdGUgdGhhdCBieSBkZWZhdWx0IGl0J3MgcmVsYXRpdmUgdG8gb2JqZWN0IGxlZnQuIFlvdSBjYW4gY2hhbmdlIHRoaXMgYnkgc2V0dGluZyBvcmlnaW5YPXtsZWZ0L2NlbnRlci9yaWdodH1cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxlZnQ6ICAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIE9iamVjdCB3aWR0aFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgd2lkdGg6ICAgICAgICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IGhlaWdodFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaGVpZ2h0OiAgICAgICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IHNjYWxlIGZhY3RvciAoaG9yaXpvbnRhbClcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNjYWxlWDogICAgICAgICAgICAgICAgICAgMSxcblxuICAgIC8qKlxuICAgICAqIE9iamVjdCBzY2FsZSBmYWN0b3IgKHZlcnRpY2FsKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2NhbGVZOiAgICAgICAgICAgICAgICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBhbiBvYmplY3QgaXMgcmVuZGVyZWQgYXMgZmxpcHBlZCBob3Jpem9udGFsbHlcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmbGlwWDogICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBhbiBvYmplY3QgaXMgcmVuZGVyZWQgYXMgZmxpcHBlZCB2ZXJ0aWNhbGx5XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZmxpcFk6ICAgICAgICAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIE9wYWNpdHkgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvcGFjaXR5OiAgICAgICAgICAgICAgICAgIDEsXG5cbiAgICAvKipcbiAgICAgKiBBbmdsZSBvZiByb3RhdGlvbiBvZiBhbiBvYmplY3QgKGluIGRlZ3JlZXMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBhbmdsZTogICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBBbmdsZSBvZiBza2V3IG9uIHggYXhlcyBvZiBhbiBvYmplY3QgKGluIGRlZ3JlZXMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBza2V3WDogICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBBbmdsZSBvZiBza2V3IG9uIHkgYXhlcyBvZiBhbiBvYmplY3QgKGluIGRlZ3JlZXMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBza2V3WTogICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBTaXplIG9mIG9iamVjdCdzIGNvbnRyb2xsaW5nIGNvcm5lcnMgKGluIHBpeGVscylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNvcm5lclNpemU6ICAgICAgICAgICAgICAgMTMsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdCdzIGNvbnRyb2xsaW5nIGNvcm5lcnMgYXJlIHJlbmRlcmVkIGFzIHRyYW5zcGFyZW50IGluc2lkZSAoaS5lLiBzdHJva2UgaW5zdGVhZCBvZiBmaWxsKVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRyYW5zcGFyZW50Q29ybmVyczogICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgY3Vyc29yIHZhbHVlIHVzZWQgd2hlbiBob3ZlcmluZyBvdmVyIHRoaXMgb2JqZWN0IG9uIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaG92ZXJDdXJzb3I6ICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCB3aGVuIG1vdmluZyB0aGlzIG9iamVjdCBvbiBjYW52YXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1vdmVDdXJzb3I6ICAgICAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFBhZGRpbmcgYmV0d2VlbiBvYmplY3QgYW5kIGl0cyBjb250cm9sbGluZyBib3JkZXJzIChpbiBwaXhlbHMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwYWRkaW5nOiAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiBjb250cm9sbGluZyBib3JkZXJzIG9mIGFuIG9iamVjdCAod2hlbiBpdCdzIGFjdGl2ZSlcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJvcmRlckNvbG9yOiAgICAgICAgICAgICAgJ3JnYmEoMTAyLDE1MywyNTUsMC43NSknLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgc3BlY2lmeWluZyBkYXNoIHBhdHRlcm4gb2YgYW4gb2JqZWN0J3MgYm9yZGVycyAoaGFzQm9yZGVyIG11c3QgYmUgdHJ1ZSlcbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIGJvcmRlckRhc2hBcnJheTogICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIGNvbnRyb2xsaW5nIGNvcm5lcnMgb2YgYW4gb2JqZWN0ICh3aGVuIGl0J3MgYWN0aXZlKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29ybmVyQ29sb3I6ICAgICAgICAgICAgICAncmdiYSgxMDIsMTUzLDI1NSwwLjUpJyxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIGNvbnRyb2xsaW5nIGNvcm5lcnMgb2YgYW4gb2JqZWN0ICh3aGVuIGl0J3MgYWN0aXZlIGFuZCB0cmFuc3BhcmVudENvcm5lcnMgZmFsc2UpXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb3JuZXJTdHJva2VDb2xvcjogICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHN0eWxlIG9mIGNvbnRyb2wsICdyZWN0JyBvciAnY2lyY2xlJ1xuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIGNvcm5lclN0eWxlOiAgICAgICAgICAncmVjdCcsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBzcGVjaWZ5aW5nIGRhc2ggcGF0dGVybiBvZiBhbiBvYmplY3QncyBjb250cm9sIChoYXNCb3JkZXIgbXVzdCBiZSB0cnVlKVxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgY29ybmVyRGFzaEFycmF5OiAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCB0aGlzIG9iamVjdCB3aWxsIHVzZSBjZW50ZXIgcG9pbnQgYXMgdGhlIG9yaWdpbiBvZiB0cmFuc2Zvcm1hdGlvblxuICAgICAqIHdoZW4gYmVpbmcgc2NhbGVkIHZpYSB0aGUgY29udHJvbHMuXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSByZXBsYWNlcyBcImNlbnRlclRyYW5zZm9ybVwiIChCb29sZWFuKS5cbiAgICAgKiBAc2luY2UgMS4zLjRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjZW50ZXJlZFNjYWxpbmc6ICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCB0aGlzIG9iamVjdCB3aWxsIHVzZSBjZW50ZXIgcG9pbnQgYXMgdGhlIG9yaWdpbiBvZiB0cmFuc2Zvcm1hdGlvblxuICAgICAqIHdoZW4gYmVpbmcgcm90YXRlZCB2aWEgdGhlIGNvbnRyb2xzLlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgcmVwbGFjZXMgXCJjZW50ZXJUcmFuc2Zvcm1cIiAoQm9vbGVhbikuXG4gICAgICogQHNpbmNlIDEuMy40XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2VudGVyZWRSb3RhdGlvbjogICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2Ygb2JqZWN0J3MgZmlsbFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZmlsbDogICAgICAgICAgICAgICAgICAgICAncmdiKDAsMCwwKScsXG5cbiAgICAvKipcbiAgICAgKiBGaWxsIHJ1bGUgdXNlZCB0byBmaWxsIGFuIG9iamVjdFxuICAgICAqIGFjY2VwdGVkIHZhbHVlcyBhcmUgbm9uemVybywgZXZlbm9kZFxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgd2FzIHVzZWQgZm9yIHNldHRpbmcgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIHVudGlsIHYxLjQuMTIgKHVzZSBgZmFicmljLk9iamVjdCNnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25gIGluc3RlYWQpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmaWxsUnVsZTogICAgICAgICAgICAgICAgICdub256ZXJvJyxcblxuICAgIC8qKlxuICAgICAqIENvbXBvc2l0ZSBydWxlIHVzZWQgZm9yIGNhbnZhcyBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjogJ3NvdXJjZS1vdmVyJyxcblxuICAgIC8qKlxuICAgICAqIEJhY2tncm91bmQgY29sb3Igb2YgYW4gb2JqZWN0LlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYmFja2dyb3VuZENvbG9yOiAgICAgICAgICAnJyxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdGlvbiBCYWNrZ3JvdW5kIGNvbG9yIG9mIGFuIG9iamVjdC4gY29sb3JlZCBsYXllciBiZWhpbmQgdGhlIG9iamVjdCB3aGVuIGl0IGlzIGFjdGl2ZS5cbiAgICAgKiBkb2VzIG5vdCBtaXggZ29vZCB3aXRoIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiBtZXRob2RzLlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yOiAgICAgICAgICAnJyxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gZGVmaW5lZCwgYW4gb2JqZWN0IGlzIHJlbmRlcmVkIHZpYSBzdHJva2UgYW5kIHRoaXMgcHJvcGVydHkgc3BlY2lmaWVzIGl0cyBjb2xvclxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlOiAgICAgICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogV2lkdGggb2YgYSBzdHJva2UgdXNlZCB0byByZW5kZXIgdGhpcyBvYmplY3RcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZVdpZHRoOiAgICAgICAgICAgICAgMSxcblxuICAgIC8qKlxuICAgICAqIEFycmF5IHNwZWNpZnlpbmcgZGFzaCBwYXR0ZXJuIG9mIGFuIG9iamVjdCdzIHN0cm9rZSAoc3Ryb2tlIG11c3QgYmUgZGVmaW5lZClcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHN0cm9rZURhc2hBcnJheTogICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIExpbmUgZW5kaW5ncyBzdHlsZSBvZiBhbiBvYmplY3QncyBzdHJva2UgKG9uZSBvZiBcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlTGluZUNhcDogICAgICAgICAgICAnYnV0dCcsXG5cbiAgICAvKipcbiAgICAgKiBDb3JuZXIgc3R5bGUgb2YgYW4gb2JqZWN0J3Mgc3Ryb2tlIChvbmUgb2YgXCJiZXZpbFwiLCBcInJvdW5kXCIsIFwibWl0ZXJcIilcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZUxpbmVKb2luOiAgICAgICAgICAgJ21pdGVyJyxcblxuICAgIC8qKlxuICAgICAqIE1heGltdW0gbWl0ZXIgbGVuZ3RoICh1c2VkIGZvciBzdHJva2VMaW5lSm9pbiA9IFwibWl0ZXJcIikgb2YgYW4gb2JqZWN0J3Mgc3Ryb2tlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2VNaXRlckxpbWl0OiAgICAgICAgIDEwLFxuXG4gICAgLyoqXG4gICAgICogU2hhZG93IG9iamVjdCByZXByZXNlbnRpbmcgc2hhZG93IG9mIHRoaXMgc2hhcGVcbiAgICAgKiBAdHlwZSBmYWJyaWMuU2hhZG93XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzaGFkb3c6ICAgICAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBPcGFjaXR5IG9mIG9iamVjdCdzIGNvbnRyb2xsaW5nIGJvcmRlcnMgd2hlbiBvYmplY3QgaXMgYWN0aXZlIGFuZCBtb3ZpbmdcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJvcmRlck9wYWNpdHlXaGVuTW92aW5nOiAgMC40LFxuXG4gICAgLyoqXG4gICAgICogU2NhbGUgZmFjdG9yIG9mIG9iamVjdCdzIGNvbnRyb2xsaW5nIGJvcmRlcnNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJvcmRlclNjYWxlRmFjdG9yOiAgICAgICAgMSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBtYXRyaXggKHNpbWlsYXIgdG8gU1ZHJ3MgdHJhbnNmb3JtIG1hdHJpeClcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHRyYW5zZm9ybU1hdHJpeDogICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gYWxsb3dlZCBzY2FsZSB2YWx1ZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1pblNjYWxlTGltaXQ6ICAgICAgICAgICAgMC4wMSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIGFuIG9iamVjdCBjYW4gbm90IGJlIHNlbGVjdGVkIGZvciBtb2RpZmljYXRpb24gKHVzaW5nIGVpdGhlciBwb2ludC1jbGljay1iYXNlZCBvciBncm91cC1iYXNlZCBzZWxlY3Rpb24pLlxuICAgICAqIEJ1dCBldmVudHMgc3RpbGwgZmlyZSBvbiBpdC5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3RhYmxlOiAgICAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgZmFsc2VgLCBhbiBvYmplY3QgY2FuIG5vdCBiZSBhIHRhcmdldCBvZiBldmVudHMuIEFsbCBldmVudHMgcHJvcGFnYXRlIHRocm91Z2ggaXQuIEludHJvZHVjZWQgaW4gdjEuMy40XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZXZlbnRlZDogICAgICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgYW4gb2JqZWN0IGlzIG5vdCByZW5kZXJlZCBvbiBjYW52YXNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB2aXNpYmxlOiAgICAgICAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgZmFsc2VgLCBvYmplY3QncyBjb250cm9scyBhcmUgbm90IGRpc3BsYXllZCBhbmQgY2FuIG5vdCBiZSB1c2VkIHRvIG1hbmlwdWxhdGUgb2JqZWN0XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaGFzQ29udHJvbHM6ICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgb2JqZWN0J3MgY29udHJvbGxpbmcgYm9yZGVycyBhcmUgbm90IHJlbmRlcmVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaGFzQm9yZGVyczogICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgb2JqZWN0J3MgY29udHJvbGxpbmcgcm90YXRpbmcgcG9pbnQgd2lsbCBub3QgYmUgdmlzaWJsZSBvciBzZWxlY3RhYmxlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaGFzUm90YXRpbmdQb2ludDogICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogT2Zmc2V0IGZvciBvYmplY3QncyBjb250cm9sbGluZyByb3RhdGluZyBwb2ludCAod2hlbiBlbmFibGVkIHZpYSBgaGFzUm90YXRpbmdQb2ludGApXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByb3RhdGluZ1BvaW50T2Zmc2V0OiAgICAgIDQwLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYHRydWVgLCBvYmplY3RzIGFyZSBcImZvdW5kXCIgb24gY2FudmFzIG9uIHBlci1waXhlbCBiYXNpcyByYXRoZXIgdGhhbiBhY2NvcmRpbmcgdG8gYm91bmRpbmcgYm94XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGVyUGl4ZWxUYXJnZXRGaW5kOiAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYGZhbHNlYCwgZGVmYXVsdCBvYmplY3QncyB2YWx1ZXMgYXJlIG5vdCBpbmNsdWRlZCBpbiBpdHMgc2VyaWFsaXphdGlvblxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGluY2x1ZGVEZWZhdWx0VmFsdWVzOiAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyBjbGlwcGluZyBvZiBhbiBvYmplY3QgKGNvbnRleHQgaXMgcGFzc2VkIGFzIGEgZmlyc3QgYXJndW1lbnQpXG4gICAgICogTm90ZSB0aGF0IGNvbnRleHQgb3JpZ2luIGlzIGF0IHRoZSBvYmplY3QncyBjZW50ZXIgcG9pbnQgKG5vdCBsZWZ0L3RvcCBjb3JuZXIpXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKi9cbiAgICBjbGlwVG86ICAgICAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IGhvcml6b250YWwgbW92ZW1lbnQgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja01vdmVtZW50WDogICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgdmVydGljYWwgbW92ZW1lbnQgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja01vdmVtZW50WTogICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3Qgcm90YXRpb24gaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1JvdGF0aW9uOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgaG9yaXpvbnRhbCBzY2FsaW5nIGlzIGxvY2tlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxvY2tTY2FsaW5nWDogICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IHZlcnRpY2FsIHNjYWxpbmcgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NjYWxpbmdZOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3Qgbm9uLXVuaWZvcm0gc2NhbGluZyBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrVW5pU2NhbGluZzogICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBob3Jpem9udGFsIHNrZXdpbmcgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NrZXdpbmdYOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgdmVydGljYWwgc2tld2luZyBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrU2tld2luZ1k6ICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBjYW5ub3QgYmUgZmxpcHBlZCBieSBzY2FsaW5nIGludG8gbmVnYXRpdmUgdmFsdWVzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NjYWxpbmdGbGlwOiAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgaXMgbm90IGV4cG9ydGVkIGluIFNWRyBvciBPQkpFQ1QvSlNPTlxuICAgICAqIHNpbmNlIDEuNi4zXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZXhjbHVkZUZyb21FeHBvcnQ6ICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgaXMgY2FjaGVkIG9uIGFuIGFkZGl0aW9uYWwgY2FudmFzLlxuICAgICAqIGRlZmF1bHQgdG8gdHJ1ZVxuICAgICAqIHNpbmNlIDEuNy4wXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBvYmplY3RDYWNoaW5nOiAgICAgICAgICAgIG9iamVjdENhY2hpbmcsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IHByb3BlcnRpZXMgYXJlIGNoZWNrZWQgZm9yIGNhY2hlIGludmFsaWRhdGlvbi4gSW4gc29tZSBwYXJ0aWN1bGFyXG4gICAgICogc2l0dWF0aW9uIHlvdSBtYXkgd2FudCB0aGlzIHRvIGJlIGRpc2FibGVkICggc3ByYXkgYnJ1c2gsIHZlcnkgYmlnIHBhdGhncm91cHMsIGdyb3VwcylcbiAgICAgKiBvciBpZiB5b3VyIGFwcGxpY2F0aW9uIGRvZXMgbm90IGFsbG93IHlvdSB0byBtb2RpZnkgcHJvcGVydGllcyBmb3IgZ3JvdXBzIGNoaWxkIHlvdSB3YW50XG4gICAgICogdG8gZGlzYWJsZSBpdCBmb3IgZ3JvdXBzLlxuICAgICAqIGRlZmF1bHQgdG8gZmFsc2VcbiAgICAgKiBzaW5jZSAxLjcuMFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHN0YXRlZnVsbENhY2hlOiAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIGNhY2hlIGRvZXMgbm90IGdldCB1cGRhdGVkIGR1cmluZyBzY2FsaW5nLiBUaGUgcGljdHVyZSB3aWxsIGdldCBibG9ja3kgaWYgc2NhbGVkXG4gICAgICogdG9vIG11Y2ggYW5kIHdpbGwgYmUgcmVkcmF3biB3aXRoIGNvcnJlY3QgZGV0YWlscyBhdCB0aGUgZW5kIG9mIHNjYWxpbmcuXG4gICAgICogdGhpcyBzZXR0aW5nIGlzIHBlcmZvcm1hbmNlIGFuZCBhcHBsaWNhdGlvbiBkZXBlbmRhbnQuXG4gICAgICogZGVmYXVsdCB0byB0cnVlXG4gICAgICogc2luY2UgMS43LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIG5vU2NhbGVDYWNoZTogICAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgdHJ1ZWAsIG9iamVjdCdzIGNhY2hlIHdpbGwgYmUgcmVyZW5kZXJlZCBuZXh0IHJlbmRlciBjYWxsLlxuICAgICAqIHNpbmNlIDEuNy4wXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZGlydHk6ICAgICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbnNpZGVyIHdoZW4gY2hlY2tpbmcgaWYgc3RhdGVcbiAgICAgKiBvZiBhbiBvYmplY3QgaXMgY2hhbmdlZCAoZmFicmljLk9iamVjdCNoYXNTdGF0ZUNoYW5nZWQpXG4gICAgICogYXMgd2VsbCBhcyBmb3IgaGlzdG9yeSAodW5kby9yZWRvKSBwdXJwb3Nlc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc3RhdGVQcm9wZXJ0aWVzOiAoXG4gICAgICAndG9wIGxlZnQgd2lkdGggaGVpZ2h0IHNjYWxlWCBzY2FsZVkgZmxpcFggZmxpcFkgb3JpZ2luWCBvcmlnaW5ZIHRyYW5zZm9ybU1hdHJpeCAnICtcbiAgICAgICdzdHJva2Ugc3Ryb2tlV2lkdGggc3Ryb2tlRGFzaEFycmF5IHN0cm9rZUxpbmVDYXAgc3Ryb2tlTGluZUpvaW4gc3Ryb2tlTWl0ZXJMaW1pdCAnICtcbiAgICAgICdhbmdsZSBvcGFjaXR5IGZpbGwgZmlsbFJ1bGUgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIHNoYWRvdyBjbGlwVG8gdmlzaWJsZSBiYWNrZ3JvdW5kQ29sb3IgJyArXG4gICAgICAnc2tld1ggc2tld1knXG4gICAgKS5zcGxpdCgnICcpLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbnNpZGVyIHdoZW4gY2hlY2tpbmcgaWYgY2FjaGUgbmVlZHMgcmVmcmVzaFxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiAoXG4gICAgICAnZmlsbCBzdHJva2Ugc3Ryb2tlV2lkdGggc3Ryb2tlRGFzaEFycmF5IHdpZHRoIGhlaWdodCBzdHJva2Ugc3Ryb2tlV2lkdGggc3Ryb2tlRGFzaEFycmF5JyArXG4gICAgICAnIHN0cm9rZUxpbmVDYXAgc3Ryb2tlTGluZUpvaW4gc3Ryb2tlTWl0ZXJMaW1pdCBmaWxsUnVsZSBiYWNrZ3JvdW5kQ29sb3InXG4gICAgKS5zcGxpdCgnICcpLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub2JqZWN0Q2FjaGluZykge1xuICAgICAgICB0aGlzLl9jcmVhdGVDYWNoZUNhbnZhcygpO1xuICAgICAgICB0aGlzLnNldHVwU3RhdGUoeyBwcm9wZXJ0eVNldDogJ2NhY2hlUHJvcGVydGllcycgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHRoZSBjYW52YXMgdXNlZCB0byBrZWVwIHRoZSBjYWNoZWQgY29weSBvZiB0aGUgb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQ2FjaGVDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY2FjaGVDYW52YXMgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICB0aGlzLl9jYWNoZUNvbnRleHQgPSB0aGlzLl9jYWNoZUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgdGhpcy5fdXBkYXRlQ2FjaGVDYW52YXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBkaW1lbnNpb24gYW5kIHRoZSB6b29tIGxldmVsIG5lZWRlZCB0byBjcmVhdGUgYSBjYWNoZSBjYW52YXNcbiAgICAgKiBiaWcgZW5vdWdoIHRvIGhvc3QgdGhlIG9iamVjdCB0byBiZSBjYWNoZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9LndpZHRoIHdpZHRoIG9mIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0uaGVpZ2h0IGhlaWdodCBvZiBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9Lnpvb21YIHpvb21YIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICogQHJldHVybiB7T2JqZWN0fS56b29tWSB6b29tWSB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqL1xuICAgIF9nZXRDYWNoZUNhbnZhc0RpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHpvb20gPSB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5nZXRab29tKCkgfHwgMSxcbiAgICAgICAgICBvYmplY3RTY2FsZSA9IHRoaXMuZ2V0T2JqZWN0U2NhbGluZygpLFxuICAgICAgICAgIGRpbSA9IHRoaXMuX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9ucygpLFxuICAgICAgICAgIHJldGluYSA9IHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLl9pc1JldGluYVNjYWxpbmcoKSA/IGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvIDogMSxcbiAgICAgICAgICB6b29tWCA9IG9iamVjdFNjYWxlLnNjYWxlWCAqIHpvb20gKiByZXRpbmEsXG4gICAgICAgICAgem9vbVkgPSBvYmplY3RTY2FsZS5zY2FsZVkgKiB6b29tICogcmV0aW5hLFxuICAgICAgICAgIHdpZHRoID0gZGltLnggKiB6b29tWCxcbiAgICAgICAgICBoZWlnaHQgPSBkaW0ueSAqIHpvb21ZO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IE1hdGguY2VpbCh3aWR0aCkgKyAyLFxuICAgICAgICBoZWlnaHQ6IE1hdGguY2VpbChoZWlnaHQpICsgMixcbiAgICAgICAgem9vbVg6IHpvb21YLFxuICAgICAgICB6b29tWTogem9vbVlcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBjYW52YXMgZm9yIGNhY2hlXG4gICAgICogcmV0dXJucyB0cnVlIG9yIGZhbHNlIGlmIGNhbnZhcyBuZWVkZWQgcmVzaXplLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2FudmFzIGhhcyBiZWVuIHJlc2l6ZWRcbiAgICAgKi9cbiAgICBfdXBkYXRlQ2FjaGVDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMubm9TY2FsZUNhY2hlICYmIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLl9jdXJyZW50VHJhbnNmb3JtKSB7XG4gICAgICAgIHZhciBhY3Rpb24gPSB0aGlzLmNhbnZhcy5fY3VycmVudFRyYW5zZm9ybS5hY3Rpb247XG4gICAgICAgIGlmIChhY3Rpb24uc2xpY2UoMCwgNSkgPT09ICdzY2FsZScpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBkaW1zID0gdGhpcy5fZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zKCksXG4gICAgICAgICAgd2lkdGggPSBkaW1zLndpZHRoLCBoZWlnaHQgPSBkaW1zLmhlaWdodCxcbiAgICAgICAgICB6b29tWCA9IGRpbXMuem9vbVgsIHpvb21ZID0gZGltcy56b29tWTtcblxuICAgICAgaWYgKHdpZHRoICE9PSB0aGlzLmNhY2hlV2lkdGggfHwgaGVpZ2h0ICE9PSB0aGlzLmNhY2hlSGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuX2NhY2hlQ2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuX2NhY2hlQ2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5fY2FjaGVDb250ZXh0LnRyYW5zbGF0ZSh3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuc2NhbGUoem9vbVgsIHpvb21ZKTtcbiAgICAgICAgdGhpcy5jYWNoZVdpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuY2FjaGVIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuem9vbVggPSB6b29tWDtcbiAgICAgICAgdGhpcy56b29tWSA9IHpvb21ZO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBvYmplY3QncyBwcm9wZXJ0aWVzIGZyb20gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBzZXRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLl9zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdGhpcy5faW5pdEdyYWRpZW50KG9wdGlvbnMuZmlsbCwgJ2ZpbGwnKTtcbiAgICAgIHRoaXMuX2luaXRHcmFkaWVudChvcHRpb25zLnN0cm9rZSwgJ3N0cm9rZScpO1xuICAgICAgdGhpcy5faW5pdENsaXBwaW5nKG9wdGlvbnMpO1xuICAgICAgdGhpcy5faW5pdFBhdHRlcm4ob3B0aW9ucy5maWxsLCAnZmlsbCcpO1xuICAgICAgdGhpcy5faW5pdFBhdHRlcm4ob3B0aW9ucy5zdHJva2UsICdzdHJva2UnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBjb250ZXh0IHdoZW4gcmVuZGVyaW5nIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZnJvbUxlZnQgV2hlbiB0cnVlLCBjb250ZXh0IGlzIHRyYW5zZm9ybWVkIHRvIG9iamVjdCdzIHRvcC9sZWZ0IGNvcm5lci4gVGhpcyBpcyB1c2VkIHdoZW4gcmVuZGVyaW5nIHRleHQgb24gTm9kZVxuICAgICAqL1xuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24oY3R4LCBmcm9tTGVmdCkge1xuICAgICAgaWYgKHRoaXMuZ3JvdXAgJiYgIXRoaXMuZ3JvdXAuX3RyYW5zZm9ybURvbmUgJiYgdGhpcy5ncm91cCA9PT0gdGhpcy5jYW52YXMuX2FjdGl2ZUdyb3VwKSB7XG4gICAgICAgIHRoaXMuZ3JvdXAudHJhbnNmb3JtKGN0eCk7XG4gICAgICB9XG4gICAgICB2YXIgY2VudGVyID0gZnJvbUxlZnQgPyB0aGlzLl9nZXRMZWZ0VG9wQ29vcmRzKCkgOiB0aGlzLmdldENlbnRlclBvaW50KCk7XG4gICAgICBjdHgudHJhbnNsYXRlKGNlbnRlci54LCBjZW50ZXIueSk7XG4gICAgICBjdHgucm90YXRlKGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSkpO1xuICAgICAgY3R4LnNjYWxlKFxuICAgICAgICB0aGlzLnNjYWxlWCAqICh0aGlzLmZsaXBYID8gLTEgOiAxKSxcbiAgICAgICAgdGhpcy5zY2FsZVkgKiAodGhpcy5mbGlwWSA/IC0xIDogMSlcbiAgICAgICk7XG4gICAgICBjdHgudHJhbnNmb3JtKDEsIDAsIE1hdGgudGFuKGRlZ3JlZXNUb1JhZGlhbnModGhpcy5za2V3WCkpLCAxLCAwLCAwKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0oMSwgTWF0aC50YW4oZGVncmVlc1RvUmFkaWFucyh0aGlzLnNrZXdZKSksIDAsIDEsIDAsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUyxcblxuICAgICAgICAgIG9iamVjdCA9IHtcbiAgICAgICAgICAgIHR5cGU6ICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlLFxuICAgICAgICAgICAgb3JpZ2luWDogICAgICAgICAgICAgICAgICB0aGlzLm9yaWdpblgsXG4gICAgICAgICAgICBvcmlnaW5ZOiAgICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luWSxcbiAgICAgICAgICAgIGxlZnQ6ICAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmxlZnQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgdG9wOiAgICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMudG9wLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHdpZHRoOiAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLndpZHRoLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIGhlaWdodDogICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmhlaWdodCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBmaWxsOiAgICAgICAgICAgICAgICAgICAgICh0aGlzLmZpbGwgJiYgdGhpcy5maWxsLnRvT2JqZWN0KSA/IHRoaXMuZmlsbC50b09iamVjdCgpIDogdGhpcy5maWxsLFxuICAgICAgICAgICAgc3Ryb2tlOiAgICAgICAgICAgICAgICAgICAodGhpcy5zdHJva2UgJiYgdGhpcy5zdHJva2UudG9PYmplY3QpID8gdGhpcy5zdHJva2UudG9PYmplY3QoKSA6IHRoaXMuc3Ryb2tlLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6ICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc3Ryb2tlV2lkdGgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc3Ryb2tlRGFzaEFycmF5OiAgICAgICAgICB0aGlzLnN0cm9rZURhc2hBcnJheSA/IHRoaXMuc3Ryb2tlRGFzaEFycmF5LmNvbmNhdCgpIDogdGhpcy5zdHJva2VEYXNoQXJyYXksXG4gICAgICAgICAgICBzdHJva2VMaW5lQ2FwOiAgICAgICAgICAgIHRoaXMuc3Ryb2tlTGluZUNhcCxcbiAgICAgICAgICAgIHN0cm9rZUxpbmVKb2luOiAgICAgICAgICAgdGhpcy5zdHJva2VMaW5lSm9pbixcbiAgICAgICAgICAgIHN0cm9rZU1pdGVyTGltaXQ6ICAgICAgICAgdG9GaXhlZCh0aGlzLnN0cm9rZU1pdGVyTGltaXQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc2NhbGVYOiAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc2NhbGVYLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHNjYWxlWTogICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLnNjYWxlWSwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBhbmdsZTogICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5nZXRBbmdsZSgpLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIGZsaXBYOiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbGlwWCxcbiAgICAgICAgICAgIGZsaXBZOiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbGlwWSxcbiAgICAgICAgICAgIG9wYWNpdHk6ICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLm9wYWNpdHksIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc2hhZG93OiAgICAgICAgICAgICAgICAgICAodGhpcy5zaGFkb3cgJiYgdGhpcy5zaGFkb3cudG9PYmplY3QpID8gdGhpcy5zaGFkb3cudG9PYmplY3QoKSA6IHRoaXMuc2hhZG93LFxuICAgICAgICAgICAgdmlzaWJsZTogICAgICAgICAgICAgICAgICB0aGlzLnZpc2libGUsXG4gICAgICAgICAgICBjbGlwVG86ICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpcFRvICYmIFN0cmluZyh0aGlzLmNsaXBUbyksXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICAgICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgZmlsbFJ1bGU6ICAgICAgICAgICAgICAgICB0aGlzLmZpbGxSdWxlLFxuICAgICAgICAgICAgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uOiB0aGlzLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbixcbiAgICAgICAgICAgIHRyYW5zZm9ybU1hdHJpeDogICAgICAgICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPyB0aGlzLnRyYW5zZm9ybU1hdHJpeC5jb25jYXQoKSA6IG51bGwsXG4gICAgICAgICAgICBza2V3WDogICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5za2V3WCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBza2V3WTogICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5za2V3WSwgTlVNX0ZSQUNUSU9OX0RJR0lUUylcbiAgICAgICAgICB9O1xuXG4gICAgICBmYWJyaWMudXRpbC5wb3B1bGF0ZVdpdGhQcm9wZXJ0aWVzKHRoaXMsIG9iamVjdCwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG5cbiAgICAgIGlmICghdGhpcy5pbmNsdWRlRGVmYXVsdFZhbHVlcykge1xuICAgICAgICBvYmplY3QgPSB0aGlzLl9yZW1vdmVEZWZhdWx0VmFsdWVzKG9iamVjdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgKGRhdGFsZXNzKSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b0RhdGFsZXNzT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICAvLyB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHN1YmNsYXNzZXNcbiAgICAgIHJldHVybiB0aGlzLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgKi9cbiAgICBfcmVtb3ZlRGVmYXVsdFZhbHVlczogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgcHJvdG90eXBlID0gZmFicmljLnV0aWwuZ2V0S2xhc3Mob2JqZWN0LnR5cGUpLnByb3RvdHlwZSxcbiAgICAgICAgICBzdGF0ZVByb3BlcnRpZXMgPSBwcm90b3R5cGUuc3RhdGVQcm9wZXJ0aWVzO1xuICAgICAgc3RhdGVQcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICBpZiAob2JqZWN0W3Byb3BdID09PSBwcm90b3R5cGVbcHJvcF0pIHtcbiAgICAgICAgICBkZWxldGUgb2JqZWN0W3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc0FycmF5ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdFtwcm9wXSkgPT09ICdbb2JqZWN0IEFycmF5XScgJiZcbiAgICAgICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJvdG90eXBlW3Byb3BdKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcblxuICAgICAgICAvLyBiYXNpY2FsbHkgYSBjaGVjayBmb3IgW10gPT09IFtdXG4gICAgICAgIGlmIChpc0FycmF5ICYmIG9iamVjdFtwcm9wXS5sZW5ndGggPT09IDAgJiYgcHJvdG90eXBlW3Byb3BdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSBvYmplY3RbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuJyArIGNhcGl0YWxpemUodGhpcy50eXBlKSArICc+JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBvYmplY3Qgc2NhbGUgZmFjdG9yIGNvdW50aW5nIGFsc28gdGhlIGdyb3VwIHNjYWxpbmdcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCB3aXRoIHNjYWxlWCBhbmQgc2NhbGVZIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBnZXRPYmplY3RTY2FsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzY2FsZVggPSB0aGlzLnNjYWxlWCwgc2NhbGVZID0gdGhpcy5zY2FsZVk7XG4gICAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgICB2YXIgc2NhbGluZyA9IHRoaXMuZ3JvdXAuZ2V0T2JqZWN0U2NhbGluZygpO1xuICAgICAgICBzY2FsZVggKj0gc2NhbGluZy5zY2FsZVg7XG4gICAgICAgIHNjYWxlWSAqPSBzY2FsaW5nLnNjYWxlWTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHNjYWxlWDogc2NhbGVYLCBzY2FsZVk6IHNjYWxlWSB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBzaG91bGRDb25zdHJhaW5WYWx1ZSA9IChrZXkgPT09ICdzY2FsZVgnIHx8IGtleSA9PT0gJ3NjYWxlWScpO1xuXG4gICAgICBpZiAoc2hvdWxkQ29uc3RyYWluVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLl9jb25zdHJhaW5TY2FsZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSAnc2NhbGVYJyAmJiB2YWx1ZSA8IDApIHtcbiAgICAgICAgdGhpcy5mbGlwWCA9ICF0aGlzLmZsaXBYO1xuICAgICAgICB2YWx1ZSAqPSAtMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3NjYWxlWScgJiYgdmFsdWUgPCAwKSB7XG4gICAgICAgIHRoaXMuZmxpcFkgPSAhdGhpcy5mbGlwWTtcbiAgICAgICAgdmFsdWUgKj0gLTE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChrZXkgPT09ICdzaGFkb3cnICYmIHZhbHVlICYmICEodmFsdWUgaW5zdGFuY2VvZiBmYWJyaWMuU2hhZG93KSkge1xuICAgICAgICB2YWx1ZSA9IG5ldyBmYWJyaWMuU2hhZG93KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ2RpcnR5JyAmJiB0aGlzLmdyb3VwKSB7XG4gICAgICAgIHRoaXMuZ3JvdXAuc2V0KCdkaXJ0eScsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpc1trZXldID0gdmFsdWU7XG5cbiAgICAgIGlmICh0aGlzLmNhY2hlUHJvcGVydGllcy5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgICAgIHRoaXMuZ3JvdXAuc2V0KCdkaXJ0eScsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5ID09PSAnd2lkdGgnIHx8IGtleSA9PT0gJ2hlaWdodCcpIHtcbiAgICAgICAgdGhpcy5taW5TY2FsZUxpbWl0ID0gTWF0aC5taW4oMC4xLCAxIC8gTWF0aC5tYXgodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IHRoZSBwYXJlbnQgZ3JvdXAgb2YgYW4gb2JqZWN0IGV2ZXJ5XG4gICAgICogdGltZSBhIG5vbi1kZWxlZ2F0ZWQgcHJvcGVydHkgY2hhbmdlcyBvbiB0aGUgZ3JvdXAuIEl0IGlzIHBhc3NlZCB0aGUga2V5XG4gICAgICogYW5kIHZhbHVlIGFzIHBhcmFtZXRlcnMuIE5vdCBhZGRpbmcgaW4gdGhpcyBmdW5jdGlvbidzIHNpZ25hdHVyZSB0byBhdm9pZFxuICAgICAqIFRyYXZpcyBidWlsZCBlcnJvciBhYm91dCB1bnVzZWQgdmFyaWFibGVzLlxuICAgICAqL1xuICAgIHNldE9uR3JvdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gaW1wbGVtZW50ZWQgYnkgc3ViLWNsYXNzZXMsIGFzIG5lZWRlZC5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzb3VyY2VQYXRoIG9mIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byBzZXQgc291cmNlUGF0aCB0b1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0U291cmNlUGF0aDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHRoaXMuc291cmNlUGF0aCA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB2aWV3cG9ydFRyYW5zZm9ybSBmcm9tIE9iamVjdCdzIGNhbnZhcyBpZiBwb3NzaWJsZVxuICAgICAqIEBtZXRob2QgZ2V0Vmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBmbGlwWSB2YWx1ZSAvLyBUT0RPXG4gICAgICovXG4gICAgZ2V0Vmlld3BvcnRUcmFuc2Zvcm06IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYW4gb2JqZWN0IG9uIGEgc3BlY2lmaWVkIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbbm9UcmFuc2Zvcm1dIFdoZW4gdHJ1ZSwgY29udGV4dCBpcyBub3QgdHJhbnNmb3JtZWRcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCwgbm9UcmFuc2Zvcm0pIHtcbiAgICAgIC8vIGRvIG5vdCByZW5kZXIgaWYgd2lkdGgvaGVpZ2h0IGFyZSB6ZXJvcyBvciBvYmplY3QgaXMgbm90IHZpc2libGVcbiAgICAgIGlmICgodGhpcy53aWR0aCA9PT0gMCAmJiB0aGlzLmhlaWdodCA9PT0gMCkgfHwgIXRoaXMudmlzaWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgLy9zZXR1cCBmaWxsIHJ1bGUgZm9yIGN1cnJlbnQgb2JqZWN0XG4gICAgICB0aGlzLl9zZXR1cENvbXBvc2l0ZU9wZXJhdGlvbihjdHgpO1xuICAgICAgdGhpcy5kcmF3U2VsZWN0aW9uQmFja2dyb3VuZChjdHgpO1xuICAgICAgaWYgKCFub1RyYW5zZm9ybSkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybShjdHgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0T3BhY2l0eShjdHgpO1xuICAgICAgdGhpcy5fc2V0U2hhZG93KGN0eCk7XG4gICAgICBpZiAodGhpcy50cmFuc2Zvcm1NYXRyaXgpIHtcbiAgICAgICAgY3R4LnRyYW5zZm9ybS5hcHBseShjdHgsIHRoaXMudHJhbnNmb3JtTWF0cml4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xpcFRvICYmIGZhYnJpYy51dGlsLmNsaXBDb250ZXh0KHRoaXMsIGN0eCk7XG4gICAgICBpZiAodGhpcy5vYmplY3RDYWNoaW5nICYmICF0aGlzLmdyb3VwKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2FjaGVEaXJ0eShub1RyYW5zZm9ybSkpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlZnVsbENhY2hlICYmIHRoaXMuc2F2ZVN0YXRlKHsgcHJvcGVydHlTZXQ6ICdjYWNoZVByb3BlcnRpZXMnIH0pO1xuICAgICAgICAgIHRoaXMuZHJhd09iamVjdCh0aGlzLl9jYWNoZUNvbnRleHQsIG5vVHJhbnNmb3JtKTtcbiAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmF3Q2FjaGVPbkNhbnZhcyhjdHgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuZHJhd09iamVjdChjdHgsIG5vVHJhbnNmb3JtKTtcbiAgICAgICAgaWYgKG5vVHJhbnNmb3JtICYmIHRoaXMub2JqZWN0Q2FjaGluZyAmJiB0aGlzLnN0YXRlZnVsbENhY2hlKSB7XG4gICAgICAgICAgdGhpcy5zYXZlU3RhdGUoeyBwcm9wZXJ0eVNldDogJ2NhY2hlUHJvcGVydGllcycgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuY2xpcFRvICYmIGN0eC5yZXN0b3JlKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBkcmF3aW5nIG9wZXJhdGlvbiBmb3IgYW4gb2JqZWN0IG9uIGEgc3BlY2lmaWVkIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbbm9UcmFuc2Zvcm1dIFdoZW4gdHJ1ZSwgY29udGV4dCBpcyBub3QgdHJhbnNmb3JtZWRcbiAgICAgKi9cbiAgICBkcmF3T2JqZWN0OiBmdW5jdGlvbihjdHgsIG5vVHJhbnNmb3JtKSB7XG4gICAgICB0aGlzLl9yZW5kZXJCYWNrZ3JvdW5kKGN0eCk7XG4gICAgICB0aGlzLl9zZXRTdHJva2VTdHlsZXMoY3R4KTtcbiAgICAgIHRoaXMuX3NldEZpbGxTdHlsZXMoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlcihjdHgsIG5vVHJhbnNmb3JtKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFpbnQgdGhlIGNhY2hlZCBjb3B5IG9mIHRoZSBvYmplY3Qgb24gdGhlIHRhcmdldCBjb250ZXh0LlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBkcmF3Q2FjaGVPbkNhbnZhczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguc2NhbGUoMSAvIHRoaXMuem9vbVgsIDEgLyB0aGlzLnpvb21ZKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5fY2FjaGVDYW52YXMsIC10aGlzLmNhY2hlV2lkdGggLyAyLCAtdGhpcy5jYWNoZUhlaWdodCAvIDIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjYWNoZSBpcyBkaXJ0eVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcENhbnZhcyBza2lwIGNhbnZhcyBjaGVja3MgYmVjYXVzZSB0aGlzIG9iamVjdCBpcyBwYWludGVkXG4gICAgICogb24gcGFyZW50IGNhbnZhcy5cbiAgICAgKi9cbiAgICBpc0NhY2hlRGlydHk6IGZ1bmN0aW9uKHNraXBDYW52YXMpIHtcbiAgICAgIGlmICghc2tpcENhbnZhcyAmJiB0aGlzLl91cGRhdGVDYWNoZUNhbnZhcygpKSB7XG4gICAgICAgIC8vIGluIHRoaXMgY2FzZSB0aGUgY29udGV4dCBpcyBhbHJlYWR5IGNsZWFyZWQuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5IHx8ICh0aGlzLnN0YXRlZnVsbENhY2hlICYmIHRoaXMuaGFzU3RhdGVDaGFuZ2VkKCdjYWNoZVByb3BlcnRpZXMnKSkpIHtcbiAgICAgICAgICBpZiAoIXNraXBDYW52YXMpIHtcbiAgICAgICAgICAgIHZhciBkaW0gPSB0aGlzLl9nZXROb25UcmFuc2Zvcm1lZERpbWVuc2lvbnMoKTtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlQ29udGV4dC5jbGVhclJlY3QoLWRpbS54IC8gMiwgLWRpbS55IC8gMiwgZGltLngsIGRpbS55KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYSBiYWNrZ3JvdW5kIGZvciB0aGUgb2JqZWN0IGJpZyBhcyBpdHMgdW50cmFzZm9ybWVkIGRpbWVuc2lvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyQmFja2dyb3VuZDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBkaW0gPSB0aGlzLl9nZXROb25UcmFuc2Zvcm1lZERpbWVuc2lvbnMoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvcjtcblxuICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAtZGltLnggLyAyLFxuICAgICAgICAtZGltLnkgLyAyLFxuICAgICAgICBkaW0ueCxcbiAgICAgICAgZGltLnlcbiAgICAgICk7XG4gICAgICAvLyBpZiB0aGVyZSBpcyBiYWNrZ3JvdW5kIGNvbG9yIG5vIG90aGVyIHNoYWRvd3NcbiAgICAgIC8vIHNob3VsZCBiZSBjYXN0ZWRcbiAgICAgIHRoaXMuX3JlbW92ZVNoYWRvdyhjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfc2V0T3BhY2l0eTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgKj0gdGhpcy5vcGFjaXR5O1xuICAgIH0sXG5cbiAgICBfc2V0U3Ryb2tlU3R5bGVzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICh0aGlzLnN0cm9rZSkge1xuICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5zdHJva2VXaWR0aDtcbiAgICAgICAgY3R4LmxpbmVDYXAgPSB0aGlzLnN0cm9rZUxpbmVDYXA7XG4gICAgICAgIGN0eC5saW5lSm9pbiA9IHRoaXMuc3Ryb2tlTGluZUpvaW47XG4gICAgICAgIGN0eC5taXRlckxpbWl0ID0gdGhpcy5zdHJva2VNaXRlckxpbWl0O1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnN0cm9rZS50b0xpdmVcbiAgICAgICAgICA/IHRoaXMuc3Ryb2tlLnRvTGl2ZShjdHgsIHRoaXMpXG4gICAgICAgICAgOiB0aGlzLnN0cm9rZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NldEZpbGxTdHlsZXM6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKHRoaXMuZmlsbCkge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5maWxsLnRvTGl2ZVxuICAgICAgICAgID8gdGhpcy5maWxsLnRvTGl2ZShjdHgsIHRoaXMpXG4gICAgICAgICAgOiB0aGlzLmZpbGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogU2V0cyBsaW5lIGRhc2hcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gc2V0IHRoZSBkYXNoIGxpbmUgb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXNoQXJyYXkgYXJyYXkgcmVwcmVzZW50aW5nIGRhc2hlc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFsdGVybmF0aXZlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgYnJvd2FzZXIgZG9lcyBub3Qgc3VwcG9ydCBsaW5lRGFzaFxuICAgICAqL1xuICAgIF9zZXRMaW5lRGFzaDogZnVuY3Rpb24oY3R4LCBkYXNoQXJyYXksIGFsdGVybmF0aXZlKSB7XG4gICAgICBpZiAoIWRhc2hBcnJheSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBTcGVjIHJlcXVpcmVzIHRoZSBjb25jYXRlbmF0aW9uIG9mIHR3byBjb3BpZXMgdGhlIGRhc2ggbGlzdCB3aGVuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaXMgb2RkXG4gICAgICBpZiAoMSAmIGRhc2hBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgZGFzaEFycmF5LnB1c2guYXBwbHkoZGFzaEFycmF5LCBkYXNoQXJyYXkpO1xuICAgICAgfVxuICAgICAgaWYgKHN1cHBvcnRzTGluZURhc2gpIHtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hBcnJheSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYWx0ZXJuYXRpdmUgJiYgYWx0ZXJuYXRpdmUoY3R4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBjb250cm9scyBhbmQgYm9yZGVycyBmb3IgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtub1RyYW5zZm9ybV0gV2hlbiB0cnVlLCBjb250ZXh0IGlzIG5vdCB0cmFuc2Zvcm1lZFxuICAgICAqL1xuICAgIF9yZW5kZXJDb250cm9sczogZnVuY3Rpb24oY3R4LCBub1RyYW5zZm9ybSkge1xuICAgICAgaWYgKCF0aGlzLmFjdGl2ZSB8fCBub1RyYW5zZm9ybVxuICAgICAgICAgIHx8ICh0aGlzLmdyb3VwICYmIHRoaXMuZ3JvdXAgIT09IHRoaXMuY2FudmFzLmdldEFjdGl2ZUdyb3VwKCkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHZwdCA9IHRoaXMuZ2V0Vmlld3BvcnRUcmFuc2Zvcm0oKSxcbiAgICAgICAgICBtYXRyaXggPSB0aGlzLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSxcbiAgICAgICAgICBvcHRpb25zO1xuICAgICAgbWF0cml4ID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyh2cHQsIG1hdHJpeCk7XG4gICAgICBvcHRpb25zID0gZmFicmljLnV0aWwucXJEZWNvbXBvc2UobWF0cml4KTtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUob3B0aW9ucy50cmFuc2xhdGVYLCBvcHRpb25zLnRyYW5zbGF0ZVkpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IDEgKiB0aGlzLmJvcmRlclNjYWxlRmFjdG9yO1xuICAgICAgaWYgKCF0aGlzLmdyb3VwKSB7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuaXNNb3ZpbmcgPyB0aGlzLmJvcmRlck9wYWNpdHlXaGVuTW92aW5nIDogMTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmdyb3VwICYmIHRoaXMuZ3JvdXAgPT09IHRoaXMuY2FudmFzLmdldEFjdGl2ZUdyb3VwKCkpIHtcbiAgICAgICAgY3R4LnJvdGF0ZShkZWdyZWVzVG9SYWRpYW5zKG9wdGlvbnMuYW5nbGUpKTtcbiAgICAgICAgdGhpcy5kcmF3Qm9yZGVyc0luR3JvdXAoY3R4LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjdHgucm90YXRlKGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSkpO1xuICAgICAgICB0aGlzLmRyYXdCb3JkZXJzKGN0eCk7XG4gICAgICB9XG4gICAgICB0aGlzLmRyYXdDb250cm9scyhjdHgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3NldFNoYWRvdzogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuc2hhZG93KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG11bHRYID0gKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtWzBdKSB8fCAxLFxuICAgICAgICAgIG11bHRZID0gKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtWzNdKSB8fCAxLFxuICAgICAgICAgIHNjYWxpbmcgPSB0aGlzLmdldE9iamVjdFNjYWxpbmcoKTtcbiAgICAgIGlmICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5faXNSZXRpbmFTY2FsaW5nKCkpIHtcbiAgICAgICAgbXVsdFggKj0gZmFicmljLmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIG11bHRZICo9IGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgfVxuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gdGhpcy5zaGFkb3cuY29sb3I7XG4gICAgICBjdHguc2hhZG93Qmx1ciA9IHRoaXMuc2hhZG93LmJsdXIgKiAobXVsdFggKyBtdWx0WSkgKiAoc2NhbGluZy5zY2FsZVggKyBzY2FsaW5nLnNjYWxlWSkgLyA0O1xuICAgICAgY3R4LnNoYWRvd09mZnNldFggPSB0aGlzLnNoYWRvdy5vZmZzZXRYICogbXVsdFggKiBzY2FsaW5nLnNjYWxlWDtcbiAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gdGhpcy5zaGFkb3cub2Zmc2V0WSAqIG11bHRZICogc2NhbGluZy5zY2FsZVk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW1vdmVTaGFkb3c6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnNoYWRvdykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9ICcnO1xuICAgICAgY3R4LnNoYWRvd0JsdXIgPSBjdHguc2hhZG93T2Zmc2V0WCA9IGN0eC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZpbGxlciBmYWJyaWMuUGF0dGVybiBvciBmYWJyaWMuR3JhZGllbnRcbiAgICAgKi9cbiAgICBfYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm06IGZ1bmN0aW9uKGN0eCwgZmlsbGVyKSB7XG4gICAgICBpZiAoIWZpbGxlci50b0xpdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHRyYW5zZm9ybSA9IGZpbGxlci5ncmFkaWVudFRyYW5zZm9ybSB8fCBmaWxsZXIucGF0dGVyblRyYW5zZm9ybTtcbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgY3R4LnRyYW5zZm9ybS5hcHBseShjdHgsIHRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgICB2YXIgb2Zmc2V0WCA9IC10aGlzLndpZHRoIC8gMiArIGZpbGxlci5vZmZzZXRYIHx8IDAsXG4gICAgICAgICAgb2Zmc2V0WSA9IC10aGlzLmhlaWdodCAvIDIgKyBmaWxsZXIub2Zmc2V0WSB8fCAwO1xuICAgICAgY3R4LnRyYW5zbGF0ZShvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckZpbGw6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLmZpbGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdGhpcy5fYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm0oY3R4LCB0aGlzLmZpbGwpO1xuICAgICAgaWYgKHRoaXMuZmlsbFJ1bGUgPT09ICdldmVub2RkJykge1xuICAgICAgICBjdHguZmlsbCgnZXZlbm9kZCcpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyU3Ryb2tlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5zdHJva2UgfHwgdGhpcy5zdHJva2VXaWR0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNoYWRvdyAmJiAhdGhpcy5zaGFkb3cuYWZmZWN0U3Ryb2tlKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVNoYWRvdyhjdHgpO1xuICAgICAgfVxuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdGhpcy5fc2V0TGluZURhc2goY3R4LCB0aGlzLnN0cm9rZURhc2hBcnJheSwgdGhpcy5fcmVuZGVyRGFzaGVkU3Ryb2tlKTtcbiAgICAgIHRoaXMuX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtKGN0eCwgdGhpcy5zdHJva2UpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xvbmVzIGFuIGluc3RhbmNlLCBzb21lIG9iamVjdHMgYXJlIGFzeW5jLCBzbyB1c2luZyBjYWxsYmFjayBtZXRob2Qgd2lsbCB3b3JrIGZvciBldmVyeSBvYmplY3QuXG4gICAgICogVXNpbmcgdGhlIGRpcmVjdCByZXR1cm4gZG9lcyBub3Qgd29yayBmb3IgaW1hZ2VzIGFuZCBncm91cHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgaXMgaW52b2tlZCB3aXRoIGEgY2xvbmUgYXMgYSBmaXJzdCBhcmd1bWVudFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSBjbG9uZSBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbihjYWxsYmFjaywgcHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuZnJvbU9iamVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5mcm9tT2JqZWN0KHRoaXMudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSksIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgZmFicmljLk9iamVjdCh0aGlzLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2Ugb3V0IG9mIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrLCBpbnZva2VkIHdpdGggYW4gaW5zdGFuY2UgYXMgYSBmaXJzdCBhcmd1bWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gZm9yIGNsb25lIGFzIGltYWdlLCBwYXNzZWQgdG8gdG9EYXRhVVJMXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5lbmFibGVSZXRpbmFTY2FsaW5nXSBlbmFibGUgcmV0aW5hIHNjYWxpbmcgZm9yIHRoZSBjbG9uZWQgaW1hZ2VcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgY2xvbmVBc0ltYWdlOiBmdW5jdGlvbihjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgdmFyIGRhdGFVcmwgPSB0aGlzLnRvRGF0YVVSTChvcHRpb25zKTtcbiAgICAgIGZhYnJpYy51dGlsLmxvYWRJbWFnZShkYXRhVXJsLCBmdW5jdGlvbihpbWcpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2sobmV3IGZhYnJpYy5JbWFnZShpbWcpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gb2JqZWN0IGludG8gYSBkYXRhLXVybC1saWtlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmZvcm1hdD1wbmddIFRoZSBmb3JtYXQgb2YgdGhlIG91dHB1dCBpbWFnZS4gRWl0aGVyIFwianBlZ1wiIG9yIFwicG5nXCJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucXVhbGl0eT0xXSBRdWFsaXR5IGxldmVsICgwLi4xKS4gT25seSB1c2VkIGZvciBqcGVnLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tdWx0aXBsaWVyPTFdIE11bHRpcGxpZXIgdG8gc2NhbGUgYnlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubGVmdF0gQ3JvcHBpbmcgbGVmdCBvZmZzZXQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50b3BdIENyb3BwaW5nIHRvcCBvZmZzZXQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aF0gQ3JvcHBpbmcgd2lkdGguIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHRdIENyb3BwaW5nIGhlaWdodC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5lbmFibGVSZXRpbmFdIEVuYWJsZSByZXRpbmEgc2NhbGluZyBmb3IgY2xvbmUgaW1hZ2UuIEludHJvZHVjZSBpbiAxLjYuNFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyBhIGRhdGE6IFVSTCBjb250YWluaW5nIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdCBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZCBieSBvcHRpb25zLmZvcm1hdFxuICAgICAqL1xuICAgIHRvRGF0YVVSTDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHZhciBlbCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKSxcbiAgICAgICAgICBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuXG4gICAgICBlbC53aWR0aCA9IGJvdW5kaW5nUmVjdC53aWR0aDtcbiAgICAgIGVsLmhlaWdodCA9IGJvdW5kaW5nUmVjdC5oZWlnaHQ7XG4gICAgICBmYWJyaWMudXRpbC53cmFwRWxlbWVudChlbCwgJ2RpdicpO1xuICAgICAgdmFyIGNhbnZhcyA9IG5ldyBmYWJyaWMuU3RhdGljQ2FudmFzKGVsLCB7IGVuYWJsZVJldGluYVNjYWxpbmc6IG9wdGlvbnMuZW5hYmxlUmV0aW5hU2NhbGluZyB9KTtcbiAgICAgIC8vIHRvIGF2b2lkIGNvbW1vbiBjb25mdXNpb24gaHR0cHM6Ly9naXRodWIuY29tL2thbmdheC9mYWJyaWMuanMvaXNzdWVzLzgwNlxuICAgICAgaWYgKG9wdGlvbnMuZm9ybWF0ID09PSAnanBnJykge1xuICAgICAgICBvcHRpb25zLmZvcm1hdCA9ICdqcGVnJztcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZm9ybWF0ID09PSAnanBlZycpIHtcbiAgICAgICAgY2FudmFzLmJhY2tncm91bmRDb2xvciA9ICcjZmZmJztcbiAgICAgIH1cblxuICAgICAgdmFyIG9yaWdQYXJhbXMgPSB7XG4gICAgICAgIGFjdGl2ZTogdGhpcy5nZXQoJ2FjdGl2ZScpLFxuICAgICAgICBsZWZ0OiB0aGlzLmdldExlZnQoKSxcbiAgICAgICAgdG9wOiB0aGlzLmdldFRvcCgpXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnNldCgnYWN0aXZlJywgZmFsc2UpO1xuICAgICAgdGhpcy5zZXRQb3NpdGlvbkJ5T3JpZ2luKG5ldyBmYWJyaWMuUG9pbnQoY2FudmFzLmdldFdpZHRoKCkgLyAyLCBjYW52YXMuZ2V0SGVpZ2h0KCkgLyAyKSwgJ2NlbnRlcicsICdjZW50ZXInKTtcblxuICAgICAgdmFyIG9yaWdpbmFsQ2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICBjYW52YXMuYWRkKHRoaXMpO1xuICAgICAgdmFyIGRhdGEgPSBjYW52YXMudG9EYXRhVVJMKG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLnNldChvcmlnUGFyYW1zKS5zZXRDb29yZHMoKTtcbiAgICAgIHRoaXMuY2FudmFzID0gb3JpZ2luYWxDYW52YXM7XG5cbiAgICAgIGNhbnZhcy5kaXNwb3NlKCk7XG4gICAgICBjYW52YXMgPSBudWxsO1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHNwZWNpZmllZCB0eXBlIGlzIGlkZW50aWNhbCB0byB0aGUgdHlwZSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFR5cGUgdG8gY2hlY2sgYWdhaW5zdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNUeXBlOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbXBsZXhpdHkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHkgb2YgdGhpcyBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbXBsZXhpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gSlNPTlxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgLy8gZGVsZWdhdGUsIG5vdCBhbGlhc1xuICAgICAgcmV0dXJuIHRoaXMudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgZ3JhZGllbnQgKGZpbGwgb3Igc3Ryb2tlKSBvZiBhbiBvYmplY3RcbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIG1ldGhvZCB3YXMgbmFtZWQgXCJzZXRHcmFkaWVudEZpbGxcIiB1bnRpbCB2MS4xLjBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZSAnc3Ryb2tlJyBvciAnZmlsbCdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnR5cGVdIFR5cGUgb2YgZ3JhZGllbnQgJ3JhZGlhbCcgb3IgJ2xpbmVhcidcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMueDE9MF0geC1jb29yZGluYXRlIG9mIHN0YXJ0IHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnkxPTBdIHktY29vcmRpbmF0ZSBvZiBzdGFydCBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy54Mj0wXSB4LWNvb3JkaW5hdGUgb2YgZW5kIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnkyPTBdIHktY29vcmRpbmF0ZSBvZiBlbmQgcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucjE9MF0gUmFkaXVzIG9mIHN0YXJ0IHBvaW50IChvbmx5IGZvciByYWRpYWwgZ3JhZGllbnRzKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yMj0wXSBSYWRpdXMgb2YgZW5kIHBvaW50IChvbmx5IGZvciByYWRpYWwgZ3JhZGllbnRzKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5jb2xvclN0b3BzXSBDb2xvciBzdG9wcyBvYmplY3QgZWcuIHswOiAnZmYwMDAwJywgMTogJzAwMDAwMCd9XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmdyYWRpZW50VHJhbnNmb3JtXSB0cmFuc2Zvck1hdHJpeCBmb3IgZ3JhZGllbnRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvNTh5OGIvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U2V0IGxpbmVhciBncmFkaWVudDwvY2FwdGlvbj5cbiAgICAgKiBvYmplY3Quc2V0R3JhZGllbnQoJ2ZpbGwnLCB7XG4gICAgICogICB0eXBlOiAnbGluZWFyJyxcbiAgICAgKiAgIHgxOiAtb2JqZWN0LndpZHRoIC8gMixcbiAgICAgKiAgIHkxOiAwLFxuICAgICAqICAgeDI6IG9iamVjdC53aWR0aCAvIDIsXG4gICAgICogICB5MjogMCxcbiAgICAgKiAgIGNvbG9yU3RvcHM6IHtcbiAgICAgKiAgICAgMDogJ3JlZCcsXG4gICAgICogICAgIDAuNTogJyMwMDU1NTUnLFxuICAgICAqICAgICAxOiAncmdiYSgwLDAsMjU1LDAuNSknXG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlNldCByYWRpYWwgZ3JhZGllbnQ8L2NhcHRpb24+XG4gICAgICogb2JqZWN0LnNldEdyYWRpZW50KCdmaWxsJywge1xuICAgICAqICAgdHlwZTogJ3JhZGlhbCcsXG4gICAgICogICB4MTogMCxcbiAgICAgKiAgIHkxOiAwLFxuICAgICAqICAgeDI6IDAsXG4gICAgICogICB5MjogMCxcbiAgICAgKiAgIHIxOiBvYmplY3Qud2lkdGggLyAyLFxuICAgICAqICAgcjI6IDEwLFxuICAgICAqICAgY29sb3JTdG9wczoge1xuICAgICAqICAgICAwOiAncmVkJyxcbiAgICAgKiAgICAgMC41OiAnIzAwNTU1NScsXG4gICAgICogICAgIDE6ICdyZ2JhKDAsMCwyNTUsMC41KSdcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAgICovXG4gICAgc2V0R3JhZGllbnQ6IGZ1bmN0aW9uKHByb3BlcnR5LCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdmFyIGdyYWRpZW50ID0geyBjb2xvclN0b3BzOiBbXSB9O1xuXG4gICAgICBncmFkaWVudC50eXBlID0gb3B0aW9ucy50eXBlIHx8IChvcHRpb25zLnIxIHx8IG9wdGlvbnMucjIgPyAncmFkaWFsJyA6ICdsaW5lYXInKTtcbiAgICAgIGdyYWRpZW50LmNvb3JkcyA9IHtcbiAgICAgICAgeDE6IG9wdGlvbnMueDEsXG4gICAgICAgIHkxOiBvcHRpb25zLnkxLFxuICAgICAgICB4Mjogb3B0aW9ucy54MixcbiAgICAgICAgeTI6IG9wdGlvbnMueTJcbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRpb25zLnIxIHx8IG9wdGlvbnMucjIpIHtcbiAgICAgICAgZ3JhZGllbnQuY29vcmRzLnIxID0gb3B0aW9ucy5yMTtcbiAgICAgICAgZ3JhZGllbnQuY29vcmRzLnIyID0gb3B0aW9ucy5yMjtcbiAgICAgIH1cblxuICAgICAgZ3JhZGllbnQuZ3JhZGllbnRUcmFuc2Zvcm0gPSBvcHRpb25zLmdyYWRpZW50VHJhbnNmb3JtO1xuICAgICAgZmFicmljLkdyYWRpZW50LnByb3RvdHlwZS5hZGRDb2xvclN0b3AuY2FsbChncmFkaWVudCwgb3B0aW9ucy5jb2xvclN0b3BzKTtcblxuICAgICAgcmV0dXJuIHRoaXMuc2V0KHByb3BlcnR5LCBmYWJyaWMuR3JhZGllbnQuZm9yT2JqZWN0KHRoaXMsIGdyYWRpZW50KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgcGF0dGVybiBmaWxsIG9mIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHsoU3RyaW5nfEhUTUxJbWFnZUVsZW1lbnQpfSBvcHRpb25zLnNvdXJjZSBQYXR0ZXJuIHNvdXJjZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZXBlYXQ9cmVwZWF0XSBSZXBlYXQgcHJvcGVydHkgb2YgYSBwYXR0ZXJuIChvbmUgb2YgcmVwZWF0LCByZXBlYXQteCwgcmVwZWF0LXkgb3Igbm8tcmVwZWF0KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZzZXRYPTBdIFBhdHRlcm4gaG9yaXpvbnRhbCBvZmZzZXQgZnJvbSBvYmplY3QncyBsZWZ0L3RvcCBjb3JuZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0WT0wXSBQYXR0ZXJuIHZlcnRpY2FsIG9mZnNldCBmcm9tIG9iamVjdCdzIGxlZnQvdG9wIGNvcm5lclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9RVDNwYS98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TZXQgcGF0dGVybjwvY2FwdGlvbj5cbiAgICAgKiBmYWJyaWMudXRpbC5sb2FkSW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2VzY2hlcmVzcXVlX3N0ZS5wbmcnLCBmdW5jdGlvbihpbWcpIHtcbiAgICAgKiAgIG9iamVjdC5zZXRQYXR0ZXJuRmlsbCh7XG4gICAgICogICAgIHNvdXJjZTogaW1nLFxuICAgICAqICAgICByZXBlYXQ6ICdyZXBlYXQnXG4gICAgICogICB9KTtcbiAgICAgKiAgIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBzZXRQYXR0ZXJuRmlsbDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KCdmaWxsJywgbmV3IGZhYnJpYy5QYXR0ZXJuKG9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB7QGxpbmsgZmFicmljLk9iamVjdCNzaGFkb3d8c2hhZG93fSBvZiBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdCBvciBzdHJpbmcgKGUuZy4gXCIycHggMnB4IDEwcHggcmdiYSgwLDAsMCwwLjIpXCIpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNvbG9yPXJnYigwLDAsMCldIFNoYWRvdyBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5ibHVyPTBdIFNoYWRvdyBibHVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldFg9MF0gU2hhZG93IGhvcml6b250YWwgb2Zmc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldFk9MF0gU2hhZG93IHZlcnRpY2FsIG9mZnNldFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy83Z3ZKRy98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TZXQgc2hhZG93IHdpdGggc3RyaW5nIG5vdGF0aW9uPC9jYXB0aW9uPlxuICAgICAqIG9iamVjdC5zZXRTaGFkb3coJzJweCAycHggMTBweCByZ2JhKDAsMCwwLDAuMiknKTtcbiAgICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U2V0IHNoYWRvdyB3aXRoIG9iamVjdCBub3RhdGlvbjwvY2FwdGlvbj5cbiAgICAgKiBvYmplY3Quc2V0U2hhZG93KHtcbiAgICAgKiAgIGNvbG9yOiAncmVkJyxcbiAgICAgKiAgIGJsdXI6IDEwLFxuICAgICAqICAgb2Zmc2V0WDogMjAsXG4gICAgICogICBvZmZzZXRZOiAyMFxuICAgICAqIH0pO1xuICAgICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICAgKi9cbiAgICBzZXRTaGFkb3c6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldCgnc2hhZG93Jywgb3B0aW9ucyA/IG5ldyBmYWJyaWMuU2hhZG93KG9wdGlvbnMpIDogbnVsbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgXCJjb2xvclwiIG9mIGFuIGluc3RhbmNlIChhbGlhcyBvZiBgc2V0KCdmaWxsJywgJmhlbGxpcDspYClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldENvbG9yOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgdGhpcy5zZXQoJ2ZpbGwnLCBjb2xvcik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBcImFuZ2xlXCIgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgQW5nbGUgdmFsdWUgKGluIGRlZ3JlZXMpXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRBbmdsZTogZnVuY3Rpb24oYW5nbGUpIHtcbiAgICAgIHZhciBzaG91bGRDZW50ZXJPcmlnaW4gPSAodGhpcy5vcmlnaW5YICE9PSAnY2VudGVyJyB8fCB0aGlzLm9yaWdpblkgIT09ICdjZW50ZXInKSAmJiB0aGlzLmNlbnRlcmVkUm90YXRpb247XG5cbiAgICAgIGlmIChzaG91bGRDZW50ZXJPcmlnaW4pIHtcbiAgICAgICAgdGhpcy5fc2V0T3JpZ2luVG9DZW50ZXIoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXQoJ2FuZ2xlJywgYW5nbGUpO1xuXG4gICAgICBpZiAoc2hvdWxkQ2VudGVyT3JpZ2luKSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0T3JpZ2luKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBob3Jpem9udGFsbHkgb24gY2FudmFzIHRvIHdoaWNoIGl0IHdhcyBhZGRlZCBsYXN0LlxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjZW50ZXJIOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5jZW50ZXJPYmplY3RIKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IGhvcml6b250YWxseSBvbiBjdXJyZW50IHZpZXdwb3J0IG9mIGNhbnZhcyB0byB3aGljaCBpdCB3YXMgYWRkZWQgbGFzdC5cbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdmlld3BvcnRDZW50ZXJIOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy52aWV3cG9ydENlbnRlck9iamVjdEgodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSBvbiBjYW52YXMgdG8gd2hpY2ggaXQgd2FzIGFkZGVkIGxhc3QuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNlbnRlclY6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmNlbnRlck9iamVjdFYodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSBvbiBjdXJyZW50IHZpZXdwb3J0IG9mIGNhbnZhcyB0byB3aGljaCBpdCB3YXMgYWRkZWQgbGFzdC5cbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdmlld3BvcnRDZW50ZXJWOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy52aWV3cG9ydENlbnRlck9iamVjdFYodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5IG9uIGNhbnZhcyB0byB3aGljaCBpcyB3YXMgYWRkZWQgbGFzdFxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjZW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmNlbnRlck9iamVjdCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBvbiBjdXJyZW50IHZpZXdwb3J0IG9mIGNhbnZhcyB0byB3aGljaCBpdCB3YXMgYWRkZWQgbGFzdC5cbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdmlld3BvcnRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnZpZXdwb3J0Q2VudGVyT2JqZWN0KHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgb2JqZWN0IGZyb20gY2FudmFzIHRvIHdoaWNoIGl0IHdhcyBhZGRlZCBsYXN0XG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMucmVtb3ZlKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29vcmRpbmF0ZXMgb2YgYSBwb2ludGVyIHJlbGF0aXZlIHRvIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgdG8gb3BlcmF0ZSB1cG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwb2ludGVyXSBQb2ludGVyIHRvIG9wZXJhdGUgdXBvbiAoaW5zdGVhZCBvZiBldmVudClcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IENvb3JkaW5hdGVzIG9mIGEgcG9pbnRlciAoeCwgeSlcbiAgICAgKi9cbiAgICBnZXRMb2NhbFBvaW50ZXI6IGZ1bmN0aW9uKGUsIHBvaW50ZXIpIHtcbiAgICAgIHBvaW50ZXIgPSBwb2ludGVyIHx8IHRoaXMuY2FudmFzLmdldFBvaW50ZXIoZSk7XG4gICAgICB2YXIgcENsaWNrZWQgPSBuZXcgZmFicmljLlBvaW50KHBvaW50ZXIueCwgcG9pbnRlci55KSxcbiAgICAgICAgICBvYmplY3RMZWZ0VG9wID0gdGhpcy5fZ2V0TGVmdFRvcENvb3JkcygpO1xuICAgICAgaWYgKHRoaXMuYW5nbGUpIHtcbiAgICAgICAgcENsaWNrZWQgPSBmYWJyaWMudXRpbC5yb3RhdGVQb2ludChcbiAgICAgICAgICBwQ2xpY2tlZCwgb2JqZWN0TGVmdFRvcCwgZGVncmVlc1RvUmFkaWFucygtdGhpcy5hbmdsZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcENsaWNrZWQueCAtIG9iamVjdExlZnRUb3AueCxcbiAgICAgICAgeTogcENsaWNrZWQueSAtIG9iamVjdExlZnRUb3AueVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBjYW52YXMgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIGZvciBzcGVjaWZpYyBvYmplY3RcbiAgICAgKiBjdXN0b20gY29tcG9zaXRpb24gb3BlcmF0aW9uIGZvciB0aGUgcGFydGljdWxhciBvYmplY3QgY2FuIGJlIHNwZWNpZmVkIHVzaW5nIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggUmVuZGVyaW5nIGNhbnZhcyBjb250ZXh0XG4gICAgICovXG4gICAgX3NldHVwQ29tcG9zaXRlT3BlcmF0aW9uOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICBpZiAodGhpcy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24pIHtcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHRoaXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgZmFicmljLnV0aWwuY3JlYXRlQWNjZXNzb3JzKGZhYnJpYy5PYmplY3QpO1xuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3Ige0BsaW5rIGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnNldEFuZ2xlfVxuICAgKiBAYWxpYXMgcm90YXRlIC0+IHNldEFuZ2xlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0XG4gICAqL1xuICBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5yb3RhdGUgPSBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5zZXRBbmdsZTtcblxuICBleHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIGZhYnJpYy5PYnNlcnZhYmxlKTtcblxuICAvKipcbiAgICogRGVmaW5lcyB0aGUgbnVtYmVyIG9mIGZyYWN0aW9uIGRpZ2l0cyB0byB1c2Ugd2hlbiBzZXJpYWxpemluZyBvYmplY3QgdmFsdWVzLlxuICAgKiBZb3UgY2FuIHVzZSBpdCB0byBpbmNyZWFzZS9kZWNyZWFzZSBwcmVjaXNpb24gb2Ygc3VjaCB2YWx1ZXMgbGlrZSBsZWZ0LCB0b3AsIHNjYWxlWCwgc2NhbGVZLCBldGMuXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3RcbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIE51bWJlclxuICAgKi9cbiAgZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTID0gMjtcblxuICBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0ID0gZnVuY3Rpb24oY2xhc3NOYW1lLCBvYmplY3QsIGNhbGxiYWNrLCBmb3JjZUFzeW5jLCBleHRyYVBhcmFtKSB7XG4gICAgdmFyIGtsYXNzID0gZmFicmljW2NsYXNzTmFtZV07XG4gICAgb2JqZWN0ID0gY2xvbmUob2JqZWN0LCB0cnVlKTtcbiAgICBpZiAoZm9yY2VBc3luYykge1xuICAgICAgZmFicmljLnV0aWwuZW5saXZlblBhdHRlcm5zKFtvYmplY3QuZmlsbCwgb2JqZWN0LnN0cm9rZV0sIGZ1bmN0aW9uKHBhdHRlcm5zKSB7XG4gICAgICAgIG9iamVjdC5maWxsID0gcGF0dGVybnNbMF07XG4gICAgICAgIG9iamVjdC5zdHJva2UgPSBwYXR0ZXJuc1sxXTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZXh0cmFQYXJhbSA/IG5ldyBrbGFzcyhvYmplY3RbZXh0cmFQYXJhbV0sIG9iamVjdCkgOiBuZXcga2xhc3Mob2JqZWN0KTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soaW5zdGFuY2UpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIGluc3RhbmNlID0gZXh0cmFQYXJhbSA/IG5ldyBrbGFzcyhvYmplY3RbZXh0cmFQYXJhbV0sIG9iamVjdCkgOiBuZXcga2xhc3Mob2JqZWN0KTtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGluc3RhbmNlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVuaXF1ZSBpZCB1c2VkIGludGVybmFsbHkgd2hlbiBjcmVhdGluZyBTVkcgZWxlbWVudHNcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdFxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICovXG4gIGZhYnJpYy5PYmplY3QuX191aWQgPSAwO1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBkZWdyZWVzVG9SYWRpYW5zID0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyxcbiAgICAgIG9yaWdpblhPZmZzZXQgPSB7XG4gICAgICAgIGxlZnQ6IC0wLjUsXG4gICAgICAgIGNlbnRlcjogMCxcbiAgICAgICAgcmlnaHQ6IDAuNVxuICAgICAgfSxcbiAgICAgIG9yaWdpbllPZmZzZXQgPSB7XG4gICAgICAgIHRvcDogLTAuNSxcbiAgICAgICAgY2VudGVyOiAwLFxuICAgICAgICBib3R0b206IDAuNVxuICAgICAgfTtcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgdGhlIGNvb3JkaW5hdGVzIGZyb20gb3JpZ2luIHRvIGNlbnRlciBjb29yZGluYXRlcyAoYmFzZWQgb24gdGhlIG9iamVjdCdzIGRpbWVuc2lvbnMpXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFRoZSBwb2ludCB3aGljaCBjb3JyZXNwb25kcyB0byB0aGUgb3JpZ2luWCBhbmQgb3JpZ2luWSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZnJvbU9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmcm9tT3JpZ2luWSBWZXJ0aWNhbCBvcmlnaW46ICd0b3AnLCAnY2VudGVyJyBvciAnYm90dG9tJ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b09yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b09yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgdHJhbnNsYXRlVG9HaXZlbk9yaWdpbjogZnVuY3Rpb24ocG9pbnQsIGZyb21PcmlnaW5YLCBmcm9tT3JpZ2luWSwgdG9PcmlnaW5YLCB0b09yaWdpblkpIHtcbiAgICAgIHZhciB4ID0gcG9pbnQueCxcbiAgICAgICAgICB5ID0gcG9pbnQueSxcbiAgICAgICAgICBvZmZzZXRYLCBvZmZzZXRZLCBkaW07XG5cbiAgICAgIGlmICh0eXBlb2YgZnJvbU9yaWdpblggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZyb21PcmlnaW5YID0gb3JpZ2luWE9mZnNldFtmcm9tT3JpZ2luWF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZnJvbU9yaWdpblggLT0gMC41O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRvT3JpZ2luWCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdG9PcmlnaW5YID0gb3JpZ2luWE9mZnNldFt0b09yaWdpblhdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRvT3JpZ2luWCAtPSAwLjU7XG4gICAgICB9XG5cbiAgICAgIG9mZnNldFggPSB0b09yaWdpblggLSBmcm9tT3JpZ2luWDtcblxuICAgICAgaWYgKHR5cGVvZiBmcm9tT3JpZ2luWSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZnJvbU9yaWdpblkgPSBvcmlnaW5ZT2Zmc2V0W2Zyb21PcmlnaW5ZXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmcm9tT3JpZ2luWSAtPSAwLjU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdG9PcmlnaW5ZID09PSAnc3RyaW5nJykge1xuICAgICAgICB0b09yaWdpblkgPSBvcmlnaW5ZT2Zmc2V0W3RvT3JpZ2luWV07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdG9PcmlnaW5ZIC09IDAuNTtcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0WSA9IHRvT3JpZ2luWSAtIGZyb21PcmlnaW5ZO1xuXG4gICAgICBpZiAob2Zmc2V0WCB8fCBvZmZzZXRZKSB7XG4gICAgICAgIGRpbSA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpO1xuICAgICAgICB4ID0gcG9pbnQueCArIG9mZnNldFggKiBkaW0ueDtcbiAgICAgICAgeSA9IHBvaW50LnkgKyBvZmZzZXRZICogZGltLnk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgZmFicmljLlBvaW50KHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSBjb29yZGluYXRlcyBmcm9tIG9yaWdpbiB0byBjZW50ZXIgY29vcmRpbmF0ZXMgKGJhc2VkIG9uIHRoZSBvYmplY3QncyBkaW1lbnNpb25zKVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBUaGUgcG9pbnQgd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhlIG9yaWdpblggYW5kIG9yaWdpblkgcGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIHRyYW5zbGF0ZVRvQ2VudGVyUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBvcmlnaW5YLCBvcmlnaW5ZKSB7XG4gICAgICB2YXIgcCA9IHRoaXMudHJhbnNsYXRlVG9HaXZlbk9yaWdpbihwb2ludCwgb3JpZ2luWCwgb3JpZ2luWSwgJ2NlbnRlcicsICdjZW50ZXInKTtcbiAgICAgIGlmICh0aGlzLmFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBmYWJyaWMudXRpbC5yb3RhdGVQb2ludChwLCBwb2ludCwgZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyB0aGUgY29vcmRpbmF0ZXMgZnJvbSBjZW50ZXIgdG8gb3JpZ2luIGNvb3JkaW5hdGVzIChiYXNlZCBvbiB0aGUgb2JqZWN0J3MgZGltZW5zaW9ucylcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gY2VudGVyIFRoZSBwb2ludCB3aGljaCBjb3JyZXNwb25kcyB0byBjZW50ZXIgb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5YIEhvcml6b250YWwgb3JpZ2luOiAnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWSBWZXJ0aWNhbCBvcmlnaW46ICd0b3AnLCAnY2VudGVyJyBvciAnYm90dG9tJ1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICB0cmFuc2xhdGVUb09yaWdpblBvaW50OiBmdW5jdGlvbihjZW50ZXIsIG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICAgIHZhciBwID0gdGhpcy50cmFuc2xhdGVUb0dpdmVuT3JpZ2luKGNlbnRlciwgJ2NlbnRlcicsICdjZW50ZXInLCBvcmlnaW5YLCBvcmlnaW5ZKTtcbiAgICAgIGlmICh0aGlzLmFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBmYWJyaWMudXRpbC5yb3RhdGVQb2ludChwLCBjZW50ZXIsIGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlYWwgY2VudGVyIGNvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgZ2V0Q2VudGVyUG9pbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlZnRUb3AgPSBuZXcgZmFicmljLlBvaW50KHRoaXMubGVmdCwgdGhpcy50b3ApO1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlVG9DZW50ZXJQb2ludChsZWZ0VG9wLCB0aGlzLm9yaWdpblgsIHRoaXMub3JpZ2luWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3QgYmFzZWQgb24gY2VudGVyIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFRoZSBwb2ludCB3aGljaCBjb3JyZXNwb25kcyB0byB0aGUgb3JpZ2luWCBhbmQgb3JpZ2luWSBwYXJhbXNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgLy8gZ2V0T3JpZ2luUG9pbnQ6IGZ1bmN0aW9uKGNlbnRlcikge1xuICAgIC8vICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlVG9PcmlnaW5Qb2ludChjZW50ZXIsIHRoaXMub3JpZ2luWCwgdGhpcy5vcmlnaW5ZKTtcbiAgICAvLyB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBhcyBpZiBpdCBoYXMgYSBkaWZmZXJlbnQgb3JpZ2luXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIGdldFBvaW50QnlPcmlnaW46IGZ1bmN0aW9uKG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCk7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVUb09yaWdpblBvaW50KGNlbnRlciwgb3JpZ2luWCwgb3JpZ2luWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvaW50IGluIGxvY2FsIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFRoZSBwb2ludCByZWxhdGl2ZSB0byB0aGUgZ2xvYmFsIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIHRvTG9jYWxQb2ludDogZnVuY3Rpb24ocG9pbnQsIG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCksXG4gICAgICAgICAgcCwgcDI7XG5cbiAgICAgIGlmICh0eXBlb2Ygb3JpZ2luWCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG9yaWdpblkgIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICBwID0gdGhpcy50cmFuc2xhdGVUb0dpdmVuT3JpZ2luKGNlbnRlciwgJ2NlbnRlcicsICdjZW50ZXInLCBvcmlnaW5YLCBvcmlnaW5ZKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwID0gbmV3IGZhYnJpYy5Qb2ludCh0aGlzLmxlZnQsIHRoaXMudG9wKTtcbiAgICAgIH1cblxuICAgICAgcDIgPSBuZXcgZmFicmljLlBvaW50KHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgaWYgKHRoaXMuYW5nbGUpIHtcbiAgICAgICAgcDIgPSBmYWJyaWMudXRpbC5yb3RhdGVQb2ludChwMiwgY2VudGVyLCAtZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcDIuc3VidHJhY3RFcXVhbHMocCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvaW50IGluIGdsb2JhbCBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBUaGUgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIC8vIHRvR2xvYmFsUG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgLy8gICByZXR1cm4gZmFicmljLnV0aWwucm90YXRlUG9pbnQocG9pbnQsIHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSwgZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSkuYWRkRXF1YWxzKG5ldyBmYWJyaWMuUG9pbnQodGhpcy5sZWZ0LCB0aGlzLnRvcCkpO1xuICAgIC8vIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgb2JqZWN0IHRha2luZyBpbnRvIGNvbnNpZGVyYXRpb24gdGhlIG9iamVjdCdzIG9yaWdpblxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb3MgVGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBzZXRQb3NpdGlvbkJ5T3JpZ2luOiBmdW5jdGlvbihwb3MsIG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLnRyYW5zbGF0ZVRvQ2VudGVyUG9pbnQocG9zLCBvcmlnaW5YLCBvcmlnaW5ZKSxcbiAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMudHJhbnNsYXRlVG9PcmlnaW5Qb2ludChjZW50ZXIsIHRoaXMub3JpZ2luWCwgdGhpcy5vcmlnaW5ZKTtcblxuICAgICAgdGhpcy5zZXQoJ2xlZnQnLCBwb3NpdGlvbi54KTtcbiAgICAgIHRoaXMuc2V0KCd0b3AnLCBwb3NpdGlvbi55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRvIE9uZSBvZiAnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXG4gICAgICovXG4gICAgYWRqdXN0UG9zaXRpb246IGZ1bmN0aW9uKHRvKSB7XG4gICAgICB2YXIgYW5nbGUgPSBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpLFxuICAgICAgICAgIGh5cG90RnVsbCA9IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgICB4RnVsbCA9IE1hdGguY29zKGFuZ2xlKSAqIGh5cG90RnVsbCxcbiAgICAgICAgICB5RnVsbCA9IE1hdGguc2luKGFuZ2xlKSAqIGh5cG90RnVsbCxcbiAgICAgICAgICBvZmZzZXRGcm9tLCBvZmZzZXRUbztcblxuICAgICAgLy9UT0RPOiB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IGNvbnNpZGVyIG1peGVkIHNpdHVhdGlvbiBsaWtlIHRvcCwgY2VudGVyLlxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9yaWdpblggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9mZnNldEZyb20gPSBvcmlnaW5YT2Zmc2V0W3RoaXMub3JpZ2luWF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb2Zmc2V0RnJvbSA9IHRoaXMub3JpZ2luWCAtIDAuNTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9mZnNldFRvID0gb3JpZ2luWE9mZnNldFt0b107XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb2Zmc2V0VG8gPSB0byAtIDAuNTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGVmdCArPSB4RnVsbCAqIChvZmZzZXRUbyAtIG9mZnNldEZyb20pO1xuICAgICAgdGhpcy50b3AgKz0geUZ1bGwgKiAob2Zmc2V0VG8gLSBvZmZzZXRGcm9tKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLm9yaWdpblggPSB0bztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgb3JpZ2luL3Bvc2l0aW9uIG9mIHRoZSBvYmplY3QgdG8gaXQncyBjZW50ZXIgcG9pbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgX3NldE9yaWdpblRvQ2VudGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWCA9IHRoaXMub3JpZ2luWDtcbiAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWSA9IHRoaXMub3JpZ2luWTtcblxuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKTtcblxuICAgICAgdGhpcy5vcmlnaW5YID0gJ2NlbnRlcic7XG4gICAgICB0aGlzLm9yaWdpblkgPSAnY2VudGVyJztcblxuICAgICAgdGhpcy5sZWZ0ID0gY2VudGVyLng7XG4gICAgICB0aGlzLnRvcCA9IGNlbnRlci55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIG9yaWdpbi9wb3NpdGlvbiBvZiB0aGUgb2JqZWN0IHRvIGl0J3Mgb3JpZ2luYWwgb3JpZ2luXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIF9yZXNldE9yaWdpbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3JpZ2luUG9pbnQgPSB0aGlzLnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQoXG4gICAgICAgIHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSxcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxPcmlnaW5YLFxuICAgICAgICB0aGlzLl9vcmlnaW5hbE9yaWdpblkpO1xuXG4gICAgICB0aGlzLm9yaWdpblggPSB0aGlzLl9vcmlnaW5hbE9yaWdpblg7XG4gICAgICB0aGlzLm9yaWdpblkgPSB0aGlzLl9vcmlnaW5hbE9yaWdpblk7XG5cbiAgICAgIHRoaXMubGVmdCA9IG9yaWdpblBvaW50Lng7XG4gICAgICB0aGlzLnRvcCA9IG9yaWdpblBvaW50Lnk7XG5cbiAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWCA9IG51bGw7XG4gICAgICB0aGlzLl9vcmlnaW5hbE9yaWdpblkgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRMZWZ0VG9wQ29vcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQodGhpcy5nZXRDZW50ZXJQb2ludCgpLCAnbGVmdCcsICd0b3AnKTtcbiAgICB9XG4gIH0pO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICBmdW5jdGlvbiBnZXRDb29yZHMob0Nvb3Jkcykge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgZmFicmljLlBvaW50KG9Db29yZHMudGwueCwgb0Nvb3Jkcy50bC55KSxcbiAgICAgIG5ldyBmYWJyaWMuUG9pbnQob0Nvb3Jkcy50ci54LCBvQ29vcmRzLnRyLnkpLFxuICAgICAgbmV3IGZhYnJpYy5Qb2ludChvQ29vcmRzLmJyLngsIG9Db29yZHMuYnIueSksXG4gICAgICBuZXcgZmFicmljLlBvaW50KG9Db29yZHMuYmwueCwgb0Nvb3Jkcy5ibC55KVxuICAgIF07XG4gIH1cblxuICB2YXIgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgICBtdWx0aXBseU1hdHJpY2VzID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcztcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIE9iamVjdCBjb250YWluaW5nIGNvb3JkaW5hdGVzIG9mIG9iamVjdCdzIGNvbnRyb2xzXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvQ29vcmRzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIG9iamVjdCBpbnRlcnNlY3RzIHdpdGggYW4gYXJlYSBmb3JtZWQgYnkgMiBwb2ludHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRUTCB0b3AtbGVmdCBwb2ludCBvZiBhcmVhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50QlIgYm90dG9tLXJpZ2h0IHBvaW50IG9mIGFyZWFcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9iamVjdCBpbnRlcnNlY3RzIHdpdGggYW4gYXJlYSBmb3JtZWQgYnkgMiBwb2ludHNcbiAgICAgKi9cbiAgICBpbnRlcnNlY3RzV2l0aFJlY3Q6IGZ1bmN0aW9uKHBvaW50VEwsIHBvaW50QlIpIHtcbiAgICAgIHZhciBvQ29vcmRzID0gZ2V0Q29vcmRzKHRoaXMub0Nvb3JkcyksXG4gICAgICAgICAgaW50ZXJzZWN0aW9uID0gZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RQb2x5Z29uUmVjdGFuZ2xlKFxuICAgICAgICAgICAgb0Nvb3JkcyxcbiAgICAgICAgICAgIHBvaW50VEwsXG4gICAgICAgICAgICBwb2ludEJSXG4gICAgICAgICAgKTtcbiAgICAgIHJldHVybiBpbnRlcnNlY3Rpb24uc3RhdHVzID09PSAnSW50ZXJzZWN0aW9uJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIG9iamVjdCBpbnRlcnNlY3RzIHdpdGggYW5vdGhlciBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgT2JqZWN0IHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9iamVjdCBpbnRlcnNlY3RzIHdpdGggYW5vdGhlciBvYmplY3RcbiAgICAgKi9cbiAgICBpbnRlcnNlY3RzV2l0aE9iamVjdDogZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBmYWJyaWMuSW50ZXJzZWN0aW9uLmludGVyc2VjdFBvbHlnb25Qb2x5Z29uKFxuICAgICAgICAgICAgZ2V0Q29vcmRzKHRoaXMub0Nvb3JkcyksXG4gICAgICAgICAgICBnZXRDb29yZHMob3RoZXIub0Nvb3JkcylcbiAgICAgICAgICApO1xuXG4gICAgICByZXR1cm4gaW50ZXJzZWN0aW9uLnN0YXR1cyA9PT0gJ0ludGVyc2VjdGlvbidcbiAgICAgICAgfHwgb3RoZXIuaXNDb250YWluZWRXaXRoaW5PYmplY3QodGhpcylcbiAgICAgICAgfHwgdGhpcy5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdChvdGhlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBvYmplY3QgaXMgZnVsbHkgY29udGFpbmVkIHdpdGhpbiBhcmVhIG9mIGFub3RoZXIgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIE9iamVjdCB0byB0ZXN0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaXMgZnVsbHkgY29udGFpbmVkIHdpdGhpbiBhcmVhIG9mIGFub3RoZXIgb2JqZWN0XG4gICAgICovXG4gICAgaXNDb250YWluZWRXaXRoaW5PYmplY3Q6IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICB2YXIgcG9pbnRzID0gZ2V0Q29vcmRzKHRoaXMub0Nvb3JkcyksXG4gICAgICAgICAgaSA9IDA7XG4gICAgICBmb3IgKDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBpZiAoIW90aGVyLmNvbnRhaW5zUG9pbnQocG9pbnRzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBvYmplY3QgaXMgZnVsbHkgY29udGFpbmVkIHdpdGhpbiBhcmVhIGZvcm1lZCBieSAyIHBvaW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludFRMIHRvcC1sZWZ0IHBvaW50IG9mIGFyZWFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRCUiBib3R0b20tcmlnaHQgcG9pbnQgb2YgYXJlYVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgb2JqZWN0IGlzIGZ1bGx5IGNvbnRhaW5lZCB3aXRoaW4gYXJlYSBmb3JtZWQgYnkgMiBwb2ludHNcbiAgICAgKi9cbiAgICBpc0NvbnRhaW5lZFdpdGhpblJlY3Q6IGZ1bmN0aW9uKHBvaW50VEwsIHBvaW50QlIpIHtcbiAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICBib3VuZGluZ1JlY3QubGVmdCA+PSBwb2ludFRMLnggJiZcbiAgICAgICAgYm91bmRpbmdSZWN0LmxlZnQgKyBib3VuZGluZ1JlY3Qud2lkdGggPD0gcG9pbnRCUi54ICYmXG4gICAgICAgIGJvdW5kaW5nUmVjdC50b3AgPj0gcG9pbnRUTC55ICYmXG4gICAgICAgIGJvdW5kaW5nUmVjdC50b3AgKyBib3VuZGluZ1JlY3QuaGVpZ2h0IDw9IHBvaW50QlIueVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHBvaW50IGlzIGluc2lkZSB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFBvaW50IHRvIGNoZWNrIGFnYWluc3RcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHBvaW50IGlzIGluc2lkZSB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgY29udGFpbnNQb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgIGlmICghdGhpcy5vQ29vcmRzKSB7XG4gICAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB9XG4gICAgICB2YXIgbGluZXMgPSB0aGlzLl9nZXRJbWFnZUxpbmVzKHRoaXMub0Nvb3JkcyksXG4gICAgICAgICAgeFBvaW50cyA9IHRoaXMuX2ZpbmRDcm9zc1BvaW50cyhwb2ludCwgbGluZXMpO1xuXG4gICAgICAvLyBpZiB4UG9pbnRzIGlzIG9kZCB0aGVuIHBvaW50IGlzIGluc2lkZSB0aGUgb2JqZWN0XG4gICAgICByZXR1cm4gKHhQb2ludHMgIT09IDAgJiYgeFBvaW50cyAlIDIgPT09IDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBvYmplY3QgZWRnZXMgaW4gaXQsIGdpdmVuIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgY29ybmVyc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9Db29yZHMgQ29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBjb3JuZXJzXG4gICAgICovXG4gICAgX2dldEltYWdlTGluZXM6IGZ1bmN0aW9uKG9Db29yZHMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcGxpbmU6IHtcbiAgICAgICAgICBvOiBvQ29vcmRzLnRsLFxuICAgICAgICAgIGQ6IG9Db29yZHMudHJcbiAgICAgICAgfSxcbiAgICAgICAgcmlnaHRsaW5lOiB7XG4gICAgICAgICAgbzogb0Nvb3Jkcy50cixcbiAgICAgICAgICBkOiBvQ29vcmRzLmJyXG4gICAgICAgIH0sXG4gICAgICAgIGJvdHRvbWxpbmU6IHtcbiAgICAgICAgICBvOiBvQ29vcmRzLmJyLFxuICAgICAgICAgIGQ6IG9Db29yZHMuYmxcbiAgICAgICAgfSxcbiAgICAgICAgbGVmdGxpbmU6IHtcbiAgICAgICAgICBvOiBvQ29vcmRzLmJsLFxuICAgICAgICAgIGQ6IG9Db29yZHMudGxcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBkZXRlcm1pbmUgaG93IG1hbnkgY3Jvc3MgcG9pbnRzIGFyZSBiZXR3ZWVuIHRoZSA0IG9iamVjdCBlZGdlc1xuICAgICAqIGFuZCB0aGUgaG9yaXpvbnRhbCBsaW5lIGRldGVybWluZWQgYnkgYSBwb2ludCBvbiBjYW52YXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBQb2ludCB0byBjaGVja1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvQ29vcmRzIENvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3QgYmVpbmcgZXZhbHVhdGVkXG4gICAgICovXG4gICAgIC8vIHJlbW92ZSB5aSwgbm90IHVzZWQgYnV0IGxlZnQgY29kZSBoZXJlIGp1c3QgaW4gY2FzZS5cbiAgICBfZmluZENyb3NzUG9pbnRzOiBmdW5jdGlvbihwb2ludCwgb0Nvb3Jkcykge1xuICAgICAgdmFyIGIxLCBiMiwgYTEsIGEyLCB4aSwgLy8geWksXG4gICAgICAgICAgeGNvdW50ID0gMCxcbiAgICAgICAgICBpTGluZTtcblxuICAgICAgZm9yICh2YXIgbGluZUtleSBpbiBvQ29vcmRzKSB7XG4gICAgICAgIGlMaW5lID0gb0Nvb3Jkc1tsaW5lS2V5XTtcbiAgICAgICAgLy8gb3B0aW1pc2F0aW9uIDE6IGxpbmUgYmVsb3cgcG9pbnQuIG5vIGNyb3NzXG4gICAgICAgIGlmICgoaUxpbmUuby55IDwgcG9pbnQueSkgJiYgKGlMaW5lLmQueSA8IHBvaW50LnkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3B0aW1pc2F0aW9uIDI6IGxpbmUgYWJvdmUgcG9pbnQuIG5vIGNyb3NzXG4gICAgICAgIGlmICgoaUxpbmUuby55ID49IHBvaW50LnkpICYmIChpTGluZS5kLnkgPj0gcG9pbnQueSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvcHRpbWlzYXRpb24gMzogdmVydGljYWwgbGluZSBjYXNlXG4gICAgICAgIGlmICgoaUxpbmUuby54ID09PSBpTGluZS5kLngpICYmIChpTGluZS5vLnggPj0gcG9pbnQueCkpIHtcbiAgICAgICAgICB4aSA9IGlMaW5lLm8ueDtcbiAgICAgICAgICAvLyB5aSA9IHBvaW50Lnk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYjEgPSAwO1xuICAgICAgICAgIGIyID0gKGlMaW5lLmQueSAtIGlMaW5lLm8ueSkgLyAoaUxpbmUuZC54IC0gaUxpbmUuby54KTtcbiAgICAgICAgICBhMSA9IHBvaW50LnkgLSBiMSAqIHBvaW50Lng7XG4gICAgICAgICAgYTIgPSBpTGluZS5vLnkgLSBiMiAqIGlMaW5lLm8ueDtcblxuICAgICAgICAgIHhpID0gLShhMSAtIGEyKSAvIChiMSAtIGIyKTtcbiAgICAgICAgICAvLyB5aSA9IGExICsgYjEgKiB4aTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkb250IGNvdW50IHhpIDwgcG9pbnQueCBjYXNlc1xuICAgICAgICBpZiAoeGkgPj0gcG9pbnQueCkge1xuICAgICAgICAgIHhjb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9wdGltaXNhdGlvbiA0OiBzcGVjaWZpYyBmb3Igc3F1YXJlIGltYWdlc1xuICAgICAgICBpZiAoeGNvdW50ID09PSAyKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB4Y291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2lkdGggb2YgYW4gb2JqZWN0J3MgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgMS4wLjRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHdpZHRoIHZhbHVlXG4gICAgICovXG4gICAgZ2V0Qm91bmRpbmdSZWN0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaGVpZ2h0IG9mIGFuIG9iamVjdCdzIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIDEuMC40XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBoZWlnaHQgdmFsdWVcbiAgICAgKi9cbiAgICBnZXRCb3VuZGluZ1JlY3RIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvb3JkaW5hdGVzIG9mIG9iamVjdCdzIGJvdW5kaW5nIHJlY3RhbmdsZSAobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAqIHRoZSBib3ggaXMgaW50ZW50ZWQgYXMgYWxpZ25lZCB0byBheGlzIG9mIGNhbnZhcy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZVZwdCBib3VuZGluZyBib3ggd2lsbCBub3QgYmUgYWZmZWN0ZWQgYnkgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbihpZ25vcmVWcHQpIHtcbiAgICAgIHZhciBjb29yZHMgPSB0aGlzLmNhbGNDb29yZHMoaWdub3JlVnB0KTtcbiAgICAgIHJldHVybiBmYWJyaWMudXRpbC5tYWtlQm91bmRpbmdCb3hGcm9tUG9pbnRzKFtcbiAgICAgICAgY29vcmRzLnRsLFxuICAgICAgICBjb29yZHMudHIsXG4gICAgICAgIGNvb3Jkcy5icixcbiAgICAgICAgY29vcmRzLmJsXG4gICAgICBdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aWR0aCBvZiBhbiBvYmplY3QgYm91bmRpbmcgYm94IGNvdW50aW5nIHRyYW5zZm9ybWF0aW9uc1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gd2lkdGggdmFsdWVcbiAgICAgKi9cbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCkueDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBoZWlnaHQgb2YgYW4gb2JqZWN0IGJvdW5kaW5nIGJveCBjb3VudGluZyB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgKiB0byBiZSByZW5hbWVkIGluIDIuMFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gaGVpZ2h0IHZhbHVlXG4gICAgICovXG4gICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKS55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBzdXJlIHRoZSBzY2FsZSBpcyB2YWxpZCBhbmQgbW9kaWZpZXMgaXQgaWYgbmVjZXNzYXJ5XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgX2NvbnN0cmFpblNjYWxlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKE1hdGguYWJzKHZhbHVlKSA8IHRoaXMubWluU2NhbGVMaW1pdCkge1xuICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIC10aGlzLm1pblNjYWxlTGltaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWluU2NhbGVMaW1pdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgYW4gb2JqZWN0IChlcXVhbGx5IGJ5IHggYW5kIHkpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFNjYWxlIGZhY3RvclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2NhbGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuX2NvbnN0cmFpblNjYWxlKHZhbHVlKTtcblxuICAgICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICB0aGlzLmZsaXBYID0gIXRoaXMuZmxpcFg7XG4gICAgICAgIHRoaXMuZmxpcFkgPSAhdGhpcy5mbGlwWTtcbiAgICAgICAgdmFsdWUgKj0gLTE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2NhbGVYID0gdmFsdWU7XG4gICAgICB0aGlzLnNjYWxlWSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlcyBhbiBvYmplY3QgdG8gYSBnaXZlbiB3aWR0aCwgd2l0aCByZXNwZWN0IHRvIGJvdW5kaW5nIGJveCAoc2NhbGluZyBieSB4L3kgZXF1YWxseSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgTmV3IHdpZHRoIHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzY2FsZVRvV2lkdGg6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAvLyBhZGp1c3QgdG8gYm91bmRpbmcgcmVjdCBmYWN0b3Igc28gdGhhdCByb3RhdGVkIHNoYXBlcyB3b3VsZCBmaXQgYXMgd2VsbFxuICAgICAgdmFyIGJvdW5kaW5nUmVjdEZhY3RvciA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggLyB0aGlzLmdldFdpZHRoKCk7XG4gICAgICByZXR1cm4gdGhpcy5zY2FsZSh2YWx1ZSAvIHRoaXMud2lkdGggLyBib3VuZGluZ1JlY3RGYWN0b3IpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgYW4gb2JqZWN0IHRvIGEgZ2l2ZW4gaGVpZ2h0LCB3aXRoIHJlc3BlY3QgdG8gYm91bmRpbmcgYm94IChzY2FsaW5nIGJ5IHgveSBlcXVhbGx5KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBOZXcgaGVpZ2h0IHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzY2FsZVRvSGVpZ2h0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgLy8gYWRqdXN0IHRvIGJvdW5kaW5nIHJlY3QgZmFjdG9yIHNvIHRoYXQgcm90YXRlZCBzaGFwZXMgd291bGQgZml0IGFzIHdlbGxcbiAgICAgIHZhciBib3VuZGluZ1JlY3RGYWN0b3IgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCAvIHRoaXMuZ2V0SGVpZ2h0KCk7XG4gICAgICByZXR1cm4gdGhpcy5zY2FsZSh2YWx1ZSAvIHRoaXMuaGVpZ2h0IC8gYm91bmRpbmdSZWN0RmFjdG9yKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGFuZCByZXR1cm5zIHRoZSAuY29vcmRzIG9mIGFuIG9iamVjdC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIHRsLCB0ciwgYnIsIGJsIC4uLi5cbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2FsY0Nvb3JkczogZnVuY3Rpb24oaWdub3JlVnB0KSB7XG4gICAgICB2YXIgdGhldGEgPSBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpLFxuICAgICAgICAgIHZwdCA9IHRoaXMuZ2V0Vmlld3BvcnRUcmFuc2Zvcm0oKSxcbiAgICAgICAgICBkaW0gPSBpZ25vcmVWcHQgPyB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKSA6IHRoaXMuX2NhbGN1bGF0ZUN1cnJlbnREaW1lbnNpb25zKCksXG4gICAgICAgICAgY3VycmVudFdpZHRoID0gZGltLngsIGN1cnJlbnRIZWlnaHQgPSBkaW0ueSxcbiAgICAgICAgICBzaW5UaCA9IE1hdGguc2luKHRoZXRhKSxcbiAgICAgICAgICBjb3NUaCA9IE1hdGguY29zKHRoZXRhKSxcbiAgICAgICAgICBfYW5nbGUgPSBjdXJyZW50V2lkdGggPiAwID8gTWF0aC5hdGFuKGN1cnJlbnRIZWlnaHQgLyBjdXJyZW50V2lkdGgpIDogMCxcbiAgICAgICAgICBfaHlwb3RlbnVzZSA9IChjdXJyZW50V2lkdGggLyBNYXRoLmNvcyhfYW5nbGUpKSAvIDIsXG4gICAgICAgICAgb2Zmc2V0WCA9IE1hdGguY29zKF9hbmdsZSArIHRoZXRhKSAqIF9oeXBvdGVudXNlLFxuICAgICAgICAgIG9mZnNldFkgPSBNYXRoLnNpbihfYW5nbGUgKyB0aGV0YSkgKiBfaHlwb3RlbnVzZSxcbiAgICAgICAgICBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCksXG4gICAgICAgICAgLy8gb2Zmc2V0IGFkZGVkIGZvciByb3RhdGUgYW5kIHNjYWxlIGFjdGlvbnNcbiAgICAgICAgICBjb29yZHMgPSBpZ25vcmVWcHQgPyBjZW50ZXIgOiBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChjZW50ZXIsIHZwdCksXG4gICAgICAgICAgdGwgID0gbmV3IGZhYnJpYy5Qb2ludChjb29yZHMueCAtIG9mZnNldFgsIGNvb3Jkcy55IC0gb2Zmc2V0WSksXG4gICAgICAgICAgdHIgID0gbmV3IGZhYnJpYy5Qb2ludCh0bC54ICsgKGN1cnJlbnRXaWR0aCAqIGNvc1RoKSwgdGwueSArIChjdXJyZW50V2lkdGggKiBzaW5UaCkpLFxuICAgICAgICAgIGJsICA9IG5ldyBmYWJyaWMuUG9pbnQodGwueCAtIChjdXJyZW50SGVpZ2h0ICogc2luVGgpLCB0bC55ICsgKGN1cnJlbnRIZWlnaHQgKiBjb3NUaCkpLFxuICAgICAgICAgIGJyICA9IG5ldyBmYWJyaWMuUG9pbnQoY29vcmRzLnggKyBvZmZzZXRYLCBjb29yZHMueSArIG9mZnNldFkpO1xuICAgICAgaWYgKCFpZ25vcmVWcHQpIHtcbiAgICAgICAgdmFyIG1sICA9IG5ldyBmYWJyaWMuUG9pbnQoKHRsLnggKyBibC54KSAvIDIsICh0bC55ICsgYmwueSkgLyAyKSxcbiAgICAgICAgICAgIG10ICA9IG5ldyBmYWJyaWMuUG9pbnQoKHRyLnggKyB0bC54KSAvIDIsICh0ci55ICsgdGwueSkgLyAyKSxcbiAgICAgICAgICAgIG1yICA9IG5ldyBmYWJyaWMuUG9pbnQoKGJyLnggKyB0ci54KSAvIDIsIChici55ICsgdHIueSkgLyAyKSxcbiAgICAgICAgICAgIG1iICA9IG5ldyBmYWJyaWMuUG9pbnQoKGJyLnggKyBibC54KSAvIDIsIChici55ICsgYmwueSkgLyAyKSxcbiAgICAgICAgICAgIG10ciA9IG5ldyBmYWJyaWMuUG9pbnQobXQueCArIHNpblRoICogdGhpcy5yb3RhdGluZ1BvaW50T2Zmc2V0LCBtdC55IC0gY29zVGggKiB0aGlzLnJvdGF0aW5nUG9pbnRPZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICAvLyBkZWJ1Z2dpbmdcblxuICAgICAgLyogc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxTdHlsZSA9ICdncmVlbic7XG4gICAgICAgICBjYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChtYi54LCBtYi55LCAzLCAzKTtcbiAgICAgICAgIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGJsLngsIGJsLnksIDMsIDMpO1xuICAgICAgICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QoYnIueCwgYnIueSwgMywgMyk7XG4gICAgICAgICBjYW52YXMuY29udGV4dFRvcC5maWxsUmVjdCh0bC54LCB0bC55LCAzLCAzKTtcbiAgICAgICAgIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KHRyLngsIHRyLnksIDMsIDMpO1xuICAgICAgICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobWwueCwgbWwueSwgMywgMyk7XG4gICAgICAgICBjYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChtci54LCBtci55LCAzLCAzKTtcbiAgICAgICAgIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KG10LngsIG10LnksIDMsIDMpO1xuICAgICAgICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobXRyLngsIG10ci55LCAzLCAzKTtcbiAgICAgICB9LCA1MCk7ICovXG5cbiAgICAgIHZhciBjb29yZHMgPSB7XG4gICAgICAgIC8vIGNvcm5lcnNcbiAgICAgICAgdGw6IHRsLCB0cjogdHIsIGJyOiBiciwgYmw6IGJsLFxuICAgICAgfTtcbiAgICAgIGlmICghaWdub3JlVnB0KSB7XG4gICAgICAgIC8vIG1pZGRsZVxuICAgICAgICBjb29yZHMubWwgPSBtbDtcbiAgICAgICAgY29vcmRzLm10ID0gbXQ7XG4gICAgICAgIGNvb3Jkcy5tciA9IG1yO1xuICAgICAgICBjb29yZHMubWIgPSBtYjtcbiAgICAgICAgLy8gcm90YXRpbmcgcG9pbnRcbiAgICAgICAgY29vcmRzLm10ciA9IG10cjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb29yZHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgY29ybmVyIHBvc2l0aW9uIGNvb3JkaW5hdGVzIGJhc2VkIG9uIGN1cnJlbnQgYW5nbGUsIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2thbmdheC9mYWJyaWMuanMvd2lraS9XaGVuLXRvLWNhbGwtc2V0Q29vcmRzXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRDb29yZHM6IGZ1bmN0aW9uKGlnbm9yZVpvb20sIHNraXBBYnNvbHV0ZSkge1xuICAgICAgdGhpcy5vQ29vcmRzID0gdGhpcy5jYWxjQ29vcmRzKGlnbm9yZVpvb20pO1xuICAgICAgaWYgKCFza2lwQWJzb2x1dGUgJiYgIWlnbm9yZVpvb20pIHtcbiAgICAgICAgdGhpcy5hYnNvbHV0ZUNvb3JkcyA9IHRoaXMuY2FsY0Nvb3Jkcyh0cnVlKTtcbiAgICAgIH1cbiAgICAgIC8vIHNldCBjb29yZGluYXRlcyBvZiB0aGUgZHJhZ2dhYmxlIGJveGVzIGluIHRoZSBjb3JuZXJzIHVzZWQgdG8gc2NhbGUvcm90YXRlIHRoZSBpbWFnZVxuICAgICAgaWdub3JlWm9vbSB8fCB0aGlzLl9zZXRDb3JuZXJDb29yZHMgJiYgdGhpcy5fc2V0Q29ybmVyQ29vcmRzKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIGNhbGN1bGF0ZSByb3RhdGlvbiBtYXRyaXggb2YgYW4gb2JqZWN0XG4gICAgICogQHJldHVybiB7QXJyYXl9IHJvdGF0aW9uIG1hdHJpeCBmb3IgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIF9jYWxjUm90YXRlTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmFuZ2xlKSB7XG4gICAgICAgIHZhciB0aGV0YSA9IGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSksIGNvcyA9IE1hdGguY29zKHRoZXRhKSwgc2luID0gTWF0aC5zaW4odGhldGEpO1xuICAgICAgICByZXR1cm4gW2Nvcywgc2luLCAtc2luLCBjb3MsIDAsIDBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBjYWxjdWxhdGUgdHJhc2Zvcm0gTWF0cml4IHRoYXQgcmVwcmVzZW50IGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gZnJvbVxuICAgICAqIG9iamVjdCBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBtYXRyaXggVHJhbnNmb3JtIE1hdHJpeCBmb3IgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGNhbGNUcmFuc2Zvcm1NYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSxcbiAgICAgICAgICB0cmFuc2xhdGVNYXRyaXggPSBbMSwgMCwgMCwgMSwgY2VudGVyLngsIGNlbnRlci55XSxcbiAgICAgICAgICByb3RhdGVNYXRyaXggPSB0aGlzLl9jYWxjUm90YXRlTWF0cml4KCksXG4gICAgICAgICAgZGltZW5zaW9uTWF0cml4ID0gdGhpcy5fY2FsY0RpbWVuc2lvbnNUcmFuc2Zvcm1NYXRyaXgodGhpcy5za2V3WCwgdGhpcy5za2V3WSwgdHJ1ZSksXG4gICAgICAgICAgbWF0cml4ID0gdGhpcy5ncm91cCA/IHRoaXMuZ3JvdXAuY2FsY1RyYW5zZm9ybU1hdHJpeCgpIDogWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgICAgbWF0cml4ID0gbXVsdGlwbHlNYXRyaWNlcyhtYXRyaXgsIHRyYW5zbGF0ZU1hdHJpeCk7XG4gICAgICBtYXRyaXggPSBtdWx0aXBseU1hdHJpY2VzKG1hdHJpeCwgcm90YXRlTWF0cml4KTtcbiAgICAgIG1hdHJpeCA9IG11bHRpcGx5TWF0cmljZXMobWF0cml4LCBkaW1lbnNpb25NYXRyaXgpO1xuICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9LFxuXG4gICAgX2NhbGNEaW1lbnNpb25zVHJhbnNmb3JtTWF0cml4OiBmdW5jdGlvbihza2V3WCwgc2tld1ksIGZsaXBwaW5nKSB7XG4gICAgICB2YXIgc2tld01hdHJpeFggPSBbMSwgMCwgTWF0aC50YW4oZGVncmVlc1RvUmFkaWFucyhza2V3WCkpLCAxXSxcbiAgICAgICAgICBza2V3TWF0cml4WSA9IFsxLCBNYXRoLnRhbihkZWdyZWVzVG9SYWRpYW5zKHNrZXdZKSksIDAsIDFdLFxuICAgICAgICAgIHNjYWxlWCA9IHRoaXMuc2NhbGVYICogKGZsaXBwaW5nICYmIHRoaXMuZmxpcFggPyAtMSA6IDEpLFxuICAgICAgICAgIHNjYWxlWSA9IHRoaXMuc2NhbGVZICogKGZsaXBwaW5nICYmIHRoaXMuZmxpcFkgPyAtMSA6IDEpLFxuICAgICAgICAgIHNjYWxlTWF0cml4ID0gW3NjYWxlWCwgMCwgMCwgc2NhbGVZXSxcbiAgICAgICAgICBtID0gbXVsdGlwbHlNYXRyaWNlcyhzY2FsZU1hdHJpeCwgc2tld01hdHJpeFgsIHRydWUpO1xuICAgICAgcmV0dXJuIG11bHRpcGx5TWF0cmljZXMobSwgc2tld01hdHJpeFksIHRydWUpO1xuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBvYmplY3QgdG8gdGhlIGJvdHRvbSBvZiB0aGUgc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHNlbmRUb0JhY2s6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5zZW5kVG9CYWNrLmNhbGwodGhpcy5ncm91cCwgdGhpcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jYW52YXMuc2VuZFRvQmFjayh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGFuIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgYnJpbmdUb0Zyb250OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuYnJpbmdUb0Zyb250LmNhbGwodGhpcy5ncm91cCwgdGhpcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jYW52YXMuYnJpbmdUb0Zyb250KHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgYW4gb2JqZWN0IGRvd24gaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnRlcnNlY3RpbmddIElmIGB0cnVlYCwgc2VuZCBvYmplY3QgYmVoaW5kIG5leHQgbG93ZXIgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHNlbmRCYWNrd2FyZHM6IGZ1bmN0aW9uKGludGVyc2VjdGluZykge1xuICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5zZW5kQmFja3dhcmRzLmNhbGwodGhpcy5ncm91cCwgdGhpcywgaW50ZXJzZWN0aW5nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmNhbnZhcy5zZW5kQmFja3dhcmRzKHRoaXMsIGludGVyc2VjdGluZyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBvYmplY3QgdXAgaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnRlcnNlY3RpbmddIElmIGB0cnVlYCwgc2VuZCBvYmplY3QgaW4gZnJvbnQgb2YgbmV4dCB1cHBlciBpbnRlcnNlY3Rpbmcgb2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgYnJpbmdGb3J3YXJkOiBmdW5jdGlvbihpbnRlcnNlY3RpbmcpIHtcbiAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuYnJpbmdGb3J3YXJkLmNhbGwodGhpcy5ncm91cCwgdGhpcywgaW50ZXJzZWN0aW5nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmNhbnZhcy5icmluZ0ZvcndhcmQodGhpcywgaW50ZXJzZWN0aW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGFuIG9iamVjdCB0byBzcGVjaWZpZWQgbGV2ZWwgaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggTmV3IHBvc2l0aW9uIG9mIG9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIG1vdmVUbzogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUubW92ZVRvLmNhbGwodGhpcy5ncm91cCwgdGhpcywgaW5kZXgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuY2FudmFzLm1vdmVUbyh0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuXG4vKiBfVE9fU1ZHX1NUQVJUXyAqL1xuKGZ1bmN0aW9uKCkge1xuXG4gIGZ1bmN0aW9uIGdldFN2Z0NvbG9yU3RyaW5nKHByb3AsIHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIHByb3AgKyAnOiBub25lOyAnO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZS50b0xpdmUpIHtcbiAgICAgIHJldHVybiBwcm9wICsgJzogdXJsKCNTVkdJRF8nICsgdmFsdWUuaWQgKyAnKTsgJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKHZhbHVlKSxcbiAgICAgICAgICBzdHIgPSBwcm9wICsgJzogJyArIGNvbG9yLnRvUmdiKCkgKyAnOyAnLFxuICAgICAgICAgIG9wYWNpdHkgPSBjb2xvci5nZXRBbHBoYSgpO1xuICAgICAgaWYgKG9wYWNpdHkgIT09IDEpIHtcbiAgICAgICAgLy9jaGFuZ2UgdGhlIGNvbG9yIGluIHJnYiArIG9wYWNpdHlcbiAgICAgICAgc3RyICs9IHByb3AgKyAnLW9wYWNpdHk6ICcgKyBvcGFjaXR5LnRvU3RyaW5nKCkgKyAnOyAnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH1cblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0eWxlcy1zdHJpbmcgZm9yIHN2Zy1leHBvcnRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNraXBTaGFkb3cgYSBib29sZWFuIHRvIHNraXAgc2hhZG93IGZpbHRlciBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnU3R5bGVzOiBmdW5jdGlvbihza2lwU2hhZG93KSB7XG5cbiAgICAgIHZhciBmaWxsUnVsZSA9IHRoaXMuZmlsbFJ1bGUsXG4gICAgICAgICAgc3Ryb2tlV2lkdGggPSB0aGlzLnN0cm9rZVdpZHRoID8gdGhpcy5zdHJva2VXaWR0aCA6ICcwJyxcbiAgICAgICAgICBzdHJva2VEYXNoQXJyYXkgPSB0aGlzLnN0cm9rZURhc2hBcnJheSA/IHRoaXMuc3Ryb2tlRGFzaEFycmF5LmpvaW4oJyAnKSA6ICdub25lJyxcbiAgICAgICAgICBzdHJva2VMaW5lQ2FwID0gdGhpcy5zdHJva2VMaW5lQ2FwID8gdGhpcy5zdHJva2VMaW5lQ2FwIDogJ2J1dHQnLFxuICAgICAgICAgIHN0cm9rZUxpbmVKb2luID0gdGhpcy5zdHJva2VMaW5lSm9pbiA/IHRoaXMuc3Ryb2tlTGluZUpvaW4gOiAnbWl0ZXInLFxuICAgICAgICAgIHN0cm9rZU1pdGVyTGltaXQgPSB0aGlzLnN0cm9rZU1pdGVyTGltaXQgPyB0aGlzLnN0cm9rZU1pdGVyTGltaXQgOiAnNCcsXG4gICAgICAgICAgb3BhY2l0eSA9IHR5cGVvZiB0aGlzLm9wYWNpdHkgIT09ICd1bmRlZmluZWQnID8gdGhpcy5vcGFjaXR5IDogJzEnLFxuICAgICAgICAgIHZpc2liaWxpdHkgPSB0aGlzLnZpc2libGUgPyAnJyA6ICcgdmlzaWJpbGl0eTogaGlkZGVuOycsXG4gICAgICAgICAgZmlsdGVyID0gc2tpcFNoYWRvdyA/ICcnIDogdGhpcy5nZXRTdmdGaWx0ZXIoKSxcbiAgICAgICAgICBmaWxsID0gZ2V0U3ZnQ29sb3JTdHJpbmcoJ2ZpbGwnLCB0aGlzLmZpbGwpLFxuICAgICAgICAgIHN0cm9rZSA9IGdldFN2Z0NvbG9yU3RyaW5nKCdzdHJva2UnLCB0aGlzLnN0cm9rZSk7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHN0cm9rZSxcbiAgICAgICAgJ3N0cm9rZS13aWR0aDogJywgc3Ryb2tlV2lkdGgsICc7ICcsXG4gICAgICAgICdzdHJva2UtZGFzaGFycmF5OiAnLCBzdHJva2VEYXNoQXJyYXksICc7ICcsXG4gICAgICAgICdzdHJva2UtbGluZWNhcDogJywgc3Ryb2tlTGluZUNhcCwgJzsgJyxcbiAgICAgICAgJ3N0cm9rZS1saW5lam9pbjogJywgc3Ryb2tlTGluZUpvaW4sICc7ICcsXG4gICAgICAgICdzdHJva2UtbWl0ZXJsaW1pdDogJywgc3Ryb2tlTWl0ZXJMaW1pdCwgJzsgJyxcbiAgICAgICAgZmlsbCxcbiAgICAgICAgJ2ZpbGwtcnVsZTogJywgZmlsbFJ1bGUsICc7ICcsXG4gICAgICAgICdvcGFjaXR5OiAnLCBvcGFjaXR5LCAnOycsXG4gICAgICAgIGZpbHRlcixcbiAgICAgICAgdmlzaWJpbGl0eVxuICAgICAgXS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBmaWx0ZXIgZm9yIHN2ZyBzaGFkb3dcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnRmlsdGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNoYWRvdyA/ICdmaWx0ZXI6IHVybCgjU1ZHSURfJyArIHRoaXMuc2hhZG93LmlkICsgJyk7JyA6ICcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlkIGF0dHJpYnV0ZSBmb3Igc3ZnIG91dHB1dFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdJZDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5pZCA/ICdpZD1cIicgKyB0aGlzLmlkICsgJ1wiICcgOiAnJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cmFuc2Zvcm0tc3RyaW5nIGZvciBzdmctZXhwb3J0XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z1RyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLnR5cGUgPT09ICdwYXRoLWdyb3VwJykge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICB2YXIgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQsXG4gICAgICAgICAgYW5nbGUgPSB0aGlzLmdldEFuZ2xlKCksXG4gICAgICAgICAgc2tld1ggPSAodGhpcy5nZXRTa2V3WCgpICUgMzYwKSxcbiAgICAgICAgICBza2V3WSA9ICh0aGlzLmdldFNrZXdZKCkgJSAzNjApLFxuICAgICAgICAgIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSxcblxuICAgICAgICAgIE5VTV9GUkFDVElPTl9ESUdJVFMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFMsXG5cbiAgICAgICAgICB0cmFuc2xhdGVQYXJ0ID0gdGhpcy50eXBlID09PSAncGF0aC1ncm91cCcgPyAnJyA6ICd0cmFuc2xhdGUoJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9GaXhlZChjZW50ZXIueCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9GaXhlZChjZW50ZXIueSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnKScsXG5cbiAgICAgICAgICBhbmdsZVBhcnQgPSBhbmdsZSAhPT0gMFxuICAgICAgICAgICAgPyAoJyByb3RhdGUoJyArIHRvRml4ZWQoYW5nbGUsIE5VTV9GUkFDVElPTl9ESUdJVFMpICsgJyknKVxuICAgICAgICAgICAgOiAnJyxcblxuICAgICAgICAgIHNjYWxlUGFydCA9ICh0aGlzLnNjYWxlWCA9PT0gMSAmJiB0aGlzLnNjYWxlWSA9PT0gMSlcbiAgICAgICAgICAgID8gJycgOlxuICAgICAgICAgICAgKCcgc2NhbGUoJyArXG4gICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5zY2FsZVgsIE5VTV9GUkFDVElPTl9ESUdJVFMpICtcbiAgICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLnNjYWxlWSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgK1xuICAgICAgICAgICAgJyknKSxcblxuICAgICAgICAgIHNrZXdYUGFydCA9IHNrZXdYICE9PSAwID8gJyBza2V3WCgnICsgdG9GaXhlZChza2V3WCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnKScgOiAnJyxcblxuICAgICAgICAgIHNrZXdZUGFydCA9IHNrZXdZICE9PSAwID8gJyBza2V3WSgnICsgdG9GaXhlZChza2V3WSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnKScgOiAnJyxcblxuICAgICAgICAgIGFkZFRyYW5zbGF0ZVggPSB0aGlzLnR5cGUgPT09ICdwYXRoLWdyb3VwJyA/IHRoaXMud2lkdGggOiAwLFxuXG4gICAgICAgICAgZmxpcFhQYXJ0ID0gdGhpcy5mbGlwWCA/ICcgbWF0cml4KC0xIDAgMCAxICcgKyBhZGRUcmFuc2xhdGVYICsgJyAwKSAnIDogJycsXG5cbiAgICAgICAgICBhZGRUcmFuc2xhdGVZID0gdGhpcy50eXBlID09PSAncGF0aC1ncm91cCcgPyB0aGlzLmhlaWdodCA6IDAsXG5cbiAgICAgICAgICBmbGlwWVBhcnQgPSB0aGlzLmZsaXBZID8gJyBtYXRyaXgoMSAwIDAgLTEgMCAnICsgYWRkVHJhbnNsYXRlWSArICcpJyA6ICcnO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICB0cmFuc2xhdGVQYXJ0LCBhbmdsZVBhcnQsIHNjYWxlUGFydCwgZmxpcFhQYXJ0LCBmbGlwWVBhcnQsIHNrZXdYUGFydCwgc2tld1lQYXJ0XG4gICAgICBdLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRyYW5zZm9ybS1zdHJpbmcgZm9yIHN2Zy1leHBvcnQgZnJvbSB0aGUgdHJhbnNmb3JtIG1hdHJpeCBvZiBzaW5nbGUgZWxlbWVudHNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnVHJhbnNmb3JtTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybU1hdHJpeCA/ICcgbWF0cml4KCcgKyB0aGlzLnRyYW5zZm9ybU1hdHJpeC5qb2luKCcgJykgKyAnKSAnIDogJyc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZUJhc2VTVkdNYXJrdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1hcmt1cCA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5maWxsICYmIHRoaXMuZmlsbC50b0xpdmUpIHtcbiAgICAgICAgbWFya3VwLnB1c2godGhpcy5maWxsLnRvU1ZHKHRoaXMsIGZhbHNlKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdHJva2UgJiYgdGhpcy5zdHJva2UudG9MaXZlKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKHRoaXMuc3Ryb2tlLnRvU1ZHKHRoaXMsIGZhbHNlKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaGFkb3cpIHtcbiAgICAgICAgbWFya3VwLnB1c2godGhpcy5zaGFkb3cudG9TVkcodGhpcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcmt1cDtcbiAgICB9XG4gIH0pO1xufSkoKTtcbi8qIF9UT19TVkdfRU5EXyAqL1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIG9yaWdpbmFsU2V0ID0gJ3N0YXRlUHJvcGVydGllcyc7XG5cbiAgLypcbiAgICBEZXBlbmRzIG9uIGBzdGF0ZVByb3BlcnRpZXNgXG4gICovXG4gIGZ1bmN0aW9uIHNhdmVQcm9wcyhvcmlnaW4sIGRlc3RpbmF0aW9uLCBwcm9wcykge1xuICAgIHZhciB0bXBPYmogPSB7IH0sIGRlZXAgPSB0cnVlO1xuICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgdG1wT2JqW3Byb3BdID0gb3JpZ2luW3Byb3BdO1xuICAgIH0pO1xuICAgIGV4dGVuZChvcmlnaW5bZGVzdGluYXRpb25dLCB0bXBPYmosIGRlZXApO1xuICB9XG5cbiAgZnVuY3Rpb24gX2lzRXF1YWwob3JpZ1ZhbHVlLCBjdXJyZW50VmFsdWUsIGZpcnN0UGFzcykge1xuICAgIGlmICghZmFicmljLmlzTGlrZWx5Tm9kZSAmJiBvcmlnVmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAvLyBhdm9pZCBjaGVja2luZyBkZWVwIGh0bWwgZWxlbWVudHNcbiAgICAgIHJldHVybiBvcmlnVmFsdWUgPT09IGN1cnJlbnRWYWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3JpZ1ZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGlmIChvcmlnVmFsdWUubGVuZ3RoICE9PSBjdXJyZW50VmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvcmlnVmFsdWUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKG9yaWdWYWx1ZVtpXSAhPT0gY3VycmVudFZhbHVlW2ldKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3JpZ1ZhbHVlICYmIHR5cGVvZiBvcmlnVmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoIWZpcnN0UGFzcyAmJiBPYmplY3Qua2V5cyhvcmlnVmFsdWUpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoY3VycmVudFZhbHVlKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIG9yaWdWYWx1ZSkge1xuICAgICAgICBpZiAoIV9pc0VxdWFsKG9yaWdWYWx1ZVtrZXldLCBjdXJyZW50VmFsdWVba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBvcmlnVmFsdWUgPT09IGN1cnJlbnRWYWx1ZTtcbiAgICB9XG4gIH1cblxuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBzdGF0ZSAob25lIG9mIGl0cyBzdGF0ZSBwcm9wZXJ0aWVzKSB3YXMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHlTZXRdIG9wdGlvbmFsIG5hbWUgZm9yIHRoZSBzZXQgb2YgcHJvcGVydHkgd2Ugd2FudCB0byBzYXZlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBpbnN0YW5jZScgc3RhdGUgaGFzIGNoYW5nZWQgc2luY2UgYHtAbGluayBmYWJyaWMuT2JqZWN0I3NhdmVTdGF0ZX1gIHdhcyBjYWxsZWRcbiAgICAgKi9cbiAgICBoYXNTdGF0ZUNoYW5nZWQ6IGZ1bmN0aW9uKHByb3BlcnR5U2V0KSB7XG4gICAgICBwcm9wZXJ0eVNldCA9IHByb3BlcnR5U2V0IHx8IG9yaWdpbmFsU2V0O1xuICAgICAgcHJvcGVydHlTZXQgPSAnXycgKyBwcm9wZXJ0eVNldDtcbiAgICAgIHJldHVybiAhX2lzRXF1YWwodGhpc1twcm9wZXJ0eVNldF0sIHRoaXMsIHRydWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTYXZlcyBzdGF0ZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9iamVjdCB3aXRoIGFkZGl0aW9uYWwgYHN0YXRlUHJvcGVydGllc2AgYXJyYXkgdG8gaW5jbHVkZSB3aGVuIHNhdmluZyBzdGF0ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBzYXZlU3RhdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBwcm9wZXJ0eVNldCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wcm9wZXJ0eVNldCB8fCBvcmlnaW5hbFNldCxcbiAgICAgICAgICBkZXN0aW5hdGlvbiA9ICdfJyArIHByb3BlcnR5U2V0O1xuICAgICAgaWYgKCF0aGlzW2Rlc3RpbmF0aW9uXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR1cFN0YXRlKG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgc2F2ZVByb3BzKHRoaXMsIGRlc3RpbmF0aW9uLCB0aGlzW3Byb3BlcnR5U2V0XSk7XG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnN0YXRlUHJvcGVydGllcykge1xuICAgICAgICBzYXZlUHJvcHModGhpcywgZGVzdGluYXRpb24sIG9wdGlvbnMuc3RhdGVQcm9wZXJ0aWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXR1cHMgc3RhdGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPYmplY3Qgd2l0aCBhZGRpdGlvbmFsIGBzdGF0ZVByb3BlcnRpZXNgIGFycmF5IHRvIGluY2x1ZGUgd2hlbiBzYXZpbmcgc3RhdGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgc2V0dXBTdGF0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuICAgICAgdmFyIHByb3BlcnR5U2V0ID0gb3B0aW9ucy5wcm9wZXJ0eVNldCB8fCBvcmlnaW5hbFNldDtcbiAgICAgIG9wdGlvbnMucHJvcGVydHlTZXQgPSBwcm9wZXJ0eVNldDtcbiAgICAgIHRoaXNbJ18nICsgcHJvcGVydHlTZXRdID0geyB9O1xuICAgICAgdGhpcy5zYXZlU3RhdGUob3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGRlZ3JlZXNUb1JhZGlhbnMgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zLFxuICAgICAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gICAgICBpc1ZNTCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHlwZW9mIEdfdm1sQ2FudmFzTWFuYWdlciAhPT0gJ3VuZGVmaW5lZCc7IH07XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvYmplY3QgaW50ZXJhY3Rpdml0eSBjb250cm9scy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jb250cm9sc1Zpc2liaWxpdHk6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoaWNoIGNvcm5lciBoYXMgYmVlbiBjbGlja2VkXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlciBUaGUgcG9pbnRlciBpbmRpY2F0aW5nIHRoZSBtb3VzZSBwb3NpdGlvblxuICAgICAqIEByZXR1cm4ge1N0cmluZ3xCb29sZWFufSBjb3JuZXIgY29kZSAodGwsIHRyLCBibCwgYnIsIGV0Yy4pLCBvciBmYWxzZSBpZiBub3RoaW5nIGlzIGZvdW5kXG4gICAgICovXG4gICAgX2ZpbmRUYXJnZXRDb3JuZXI6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICAgIGlmICghdGhpcy5oYXNDb250cm9scyB8fCAhdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXggPSBwb2ludGVyLngsXG4gICAgICAgICAgZXkgPSBwb2ludGVyLnksXG4gICAgICAgICAgeFBvaW50cyxcbiAgICAgICAgICBsaW5lcztcbiAgICAgIHRoaXMuX19jb3JuZXIgPSAwO1xuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLm9Db29yZHMpIHtcblxuICAgICAgICBpZiAoIXRoaXMuaXNDb250cm9sVmlzaWJsZShpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPT09ICdtdHInICYmICF0aGlzLmhhc1JvdGF0aW5nUG9pbnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdldCgnbG9ja1VuaVNjYWxpbmcnKSAmJlxuICAgICAgICAgICAoaSA9PT0gJ210JyB8fCBpID09PSAnbXInIHx8IGkgPT09ICdtYicgfHwgaSA9PT0gJ21sJykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmVzID0gdGhpcy5fZ2V0SW1hZ2VMaW5lcyh0aGlzLm9Db29yZHNbaV0uY29ybmVyKTtcblxuICAgICAgICAvLyBkZWJ1Z2dpbmdcblxuICAgICAgICAvLyBjYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5ib3R0b21saW5lLmQueCwgbGluZXMuYm90dG9tbGluZS5kLnksIDIsIDIpO1xuICAgICAgICAvLyBjYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5ib3R0b21saW5lLm8ueCwgbGluZXMuYm90dG9tbGluZS5vLnksIDIsIDIpO1xuXG4gICAgICAgIC8vIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLmxlZnRsaW5lLmQueCwgbGluZXMubGVmdGxpbmUuZC55LCAyLCAyKTtcbiAgICAgICAgLy8gY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMubGVmdGxpbmUuby54LCBsaW5lcy5sZWZ0bGluZS5vLnksIDIsIDIpO1xuXG4gICAgICAgIC8vIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnRvcGxpbmUuZC54LCBsaW5lcy50b3BsaW5lLmQueSwgMiwgMik7XG4gICAgICAgIC8vIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnRvcGxpbmUuby54LCBsaW5lcy50b3BsaW5lLm8ueSwgMiwgMik7XG5cbiAgICAgICAgLy8gY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMucmlnaHRsaW5lLmQueCwgbGluZXMucmlnaHRsaW5lLmQueSwgMiwgMik7XG4gICAgICAgIC8vIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnJpZ2h0bGluZS5vLngsIGxpbmVzLnJpZ2h0bGluZS5vLnksIDIsIDIpO1xuXG4gICAgXG4gICAgICAgIHhQb2ludHMgPSB0aGlzLl9maW5kQ3Jvc3NQb2ludHMoeyB4OiBleCwgeTogZXkgfSwgbGluZXMpO1xuICAgICAgICBpZiAoeFBvaW50cyAhPT0gMCAmJiB4UG9pbnRzICUgMiA9PT0gMSkge1xuICAgICAgICAgIHRoaXMuX19jb3JuZXIgPSBpO1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBkcmFnZ2FibGUgYm94ZXMgaW4gdGhlIGNvcm5lcnMgb2ZcbiAgICAgKiB0aGUgaW1hZ2UgdXNlZCB0byBzY2FsZS9yb3RhdGUgaXQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0Q29ybmVyQ29vcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb29yZHMgPSB0aGlzLm9Db29yZHMsXG4gICAgICAgICAgbmV3VGhldGEgPSBkZWdyZWVzVG9SYWRpYW5zKDQ1IC0gdGhpcy5hbmdsZSksXG4gICAgICAgICAgLyogTWF0aC5zcXJ0KDIgKiBNYXRoLnBvdyh0aGlzLmNvcm5lclNpemUsIDIpKSAvIDIsICovXG4gICAgICAgICAgLyogMC43MDcxMDYgc3RhbmRzIGZvciBzcXJ0KDIpLzIgKi9cbiAgICAgICAgICBjb3JuZXJIeXBvdGVudXNlID0gdGhpcy5jb3JuZXJTaXplICogMC43MDcxMDYsXG4gICAgICAgICAgY29zSGFsZk9mZnNldCA9IGNvcm5lckh5cG90ZW51c2UgKiBNYXRoLmNvcyhuZXdUaGV0YSksXG4gICAgICAgICAgc2luSGFsZk9mZnNldCA9IGNvcm5lckh5cG90ZW51c2UgKiBNYXRoLnNpbihuZXdUaGV0YSksXG4gICAgICAgICAgeCwgeTtcblxuICAgICAgZm9yICh2YXIgcG9pbnQgaW4gY29vcmRzKSB7XG4gICAgICAgIHggPSBjb29yZHNbcG9pbnRdLng7XG4gICAgICAgIHkgPSBjb29yZHNbcG9pbnRdLnk7XG4gICAgICAgIGNvb3Jkc1twb2ludF0uY29ybmVyID0ge1xuICAgICAgICAgIHRsOiB7XG4gICAgICAgICAgICB4OiB4IC0gc2luSGFsZk9mZnNldCxcbiAgICAgICAgICAgIHk6IHkgLSBjb3NIYWxmT2Zmc2V0XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cjoge1xuICAgICAgICAgICAgeDogeCArIGNvc0hhbGZPZmZzZXQsXG4gICAgICAgICAgICB5OiB5IC0gc2luSGFsZk9mZnNldFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYmw6IHtcbiAgICAgICAgICAgIHg6IHggLSBjb3NIYWxmT2Zmc2V0LFxuICAgICAgICAgICAgeTogeSArIHNpbkhhbGZPZmZzZXRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJyOiB7XG4gICAgICAgICAgICB4OiB4ICsgc2luSGFsZk9mZnNldCxcbiAgICAgICAgICAgIHk6IHkgKyBjb3NIYWxmT2Zmc2V0XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIENhbGN1bGF0ZSBvYmplY3QgZGltZW5zaW9ucyBmcm9tIGl0cyBwcm9wZXJ0aWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdHJva2VXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgdyA9IHRoaXMud2lkdGggKyBzdHJva2VXaWR0aCxcbiAgICAgICAgICBoID0gdGhpcy5oZWlnaHQgKyBzdHJva2VXaWR0aDtcbiAgICAgIHJldHVybiB7IHg6IHcsIHk6IGggfTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnM6IGZ1bmN0aW9uKHNrZXdYLCBza2V3WSkge1xuICAgICAgaWYgKHR5cGVvZiBza2V3WCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2tld1ggPSB0aGlzLnNrZXdYO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBza2V3WSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2tld1kgPSB0aGlzLnNrZXdZO1xuICAgICAgfVxuICAgICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLl9nZXROb25UcmFuc2Zvcm1lZERpbWVuc2lvbnMoKSxcbiAgICAgICAgICBkaW1YID0gZGltZW5zaW9ucy54IC8gMiwgZGltWSA9IGRpbWVuc2lvbnMueSAvIDIsXG4gICAgICAgICAgcG9pbnRzID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiAtZGltWCxcbiAgICAgICAgICAgICAgeTogLWRpbVlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IGRpbVgsXG4gICAgICAgICAgICAgIHk6IC1kaW1ZXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiAtZGltWCxcbiAgICAgICAgICAgICAgeTogZGltWVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgeDogZGltWCxcbiAgICAgICAgICAgICAgeTogZGltWVxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgaSwgdHJhbnNmb3JtTWF0cml4ID0gdGhpcy5fY2FsY0RpbWVuc2lvbnNUcmFuc2Zvcm1NYXRyaXgoc2tld1gsIHNrZXdZLCBmYWxzZSksXG4gICAgICAgICAgYmJveDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcG9pbnRzW2ldID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQocG9pbnRzW2ldLCB0cmFuc2Zvcm1NYXRyaXgpO1xuICAgICAgfVxuICAgICAgYmJveCA9IGZhYnJpYy51dGlsLm1ha2VCb3VuZGluZ0JveEZyb21Qb2ludHMocG9pbnRzKTtcbiAgICAgIHJldHVybiB7IHg6IGJib3gud2lkdGgsIHk6IGJib3guaGVpZ2h0IH07XG4gICAgfSxcblxuICAgIC8qXG4gICAgICogcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVDdXJyZW50RGltZW5zaW9uczogZnVuY3Rpb24oKSAge1xuICAgICAgdmFyIHZwdCA9IHRoaXMuZ2V0Vmlld3BvcnRUcmFuc2Zvcm0oKSxcbiAgICAgICAgICBkaW0gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKSxcbiAgICAgICAgICBwID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQoZGltLCB2cHQsIHRydWUpO1xuXG4gICAgICByZXR1cm4gcC5zY2FsYXJBZGQoMiAqIHRoaXMucGFkZGluZyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGEgY29sb3JlZCBsYXllciBiZWhpbmQgdGhlIG9iamVjdCwgaW5zaWRlIGl0cyBzZWxlY3Rpb24gYm9yZGVycy5cbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgb3B0aW9uczogcGFkZGluZywgc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yXG4gICAgICogdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiB0aGUgY29udGV4dCBpcyB0cmFuc2Zvcm1lZFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBkcmF3IG9uXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkcmF3U2VsZWN0aW9uQmFja2dyb3VuZDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yIHx8IHRoaXMuZ3JvdXAgfHwgIXRoaXMuYWN0aXZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCksIHdoID0gdGhpcy5fY2FsY3VsYXRlQ3VycmVudERpbWVuc2lvbnMoKSxcbiAgICAgICAgICB2cHQgPSB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybTtcbiAgICAgIGN0eC50cmFuc2xhdGUoY2VudGVyLngsIGNlbnRlci55KTtcbiAgICAgIGN0eC5zY2FsZSgxIC8gdnB0WzBdLCAxIC8gdnB0WzNdKTtcbiAgICAgIGN0eC5yb3RhdGUoZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5zZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBjdHguZmlsbFJlY3QoLXdoLnggLyAyLCAtd2gueSAvIDIsIHdoLngsIHdoLnkpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBib3JkZXJzIG9mIGFuIG9iamVjdCdzIGJvdW5kaW5nIGJveC5cbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgcHJvcGVydGllczogd2lkdGgsIGhlaWdodFxuICAgICAqIFJlcXVpcmVzIHB1YmxpYyBvcHRpb25zOiBwYWRkaW5nLCBib3JkZXJDb2xvclxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBkcmF3IG9uXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkcmF3Qm9yZGVyczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuaGFzQm9yZGVycykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIHdoID0gdGhpcy5fY2FsY3VsYXRlQ3VycmVudERpbWVuc2lvbnMoKSxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IDEgLyB0aGlzLmJvcmRlclNjYWxlRmFjdG9yLFxuICAgICAgICAgIHdpZHRoID0gd2gueCArIHN0cm9rZVdpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IHdoLnkgKyBzdHJva2VXaWR0aDtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYm9yZGVyQ29sb3I7XG4gICAgICB0aGlzLl9zZXRMaW5lRGFzaChjdHgsIHRoaXMuYm9yZGVyRGFzaEFycmF5LCBudWxsKTtcblxuICAgICAgY3R4LnN0cm9rZVJlY3QoXG4gICAgICAgIC13aWR0aCAvIDIsXG4gICAgICAgIC1oZWlnaHQgLyAyLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICApO1xuXG4gICAgICBpZiAodGhpcy5oYXNSb3RhdGluZ1BvaW50ICYmIHRoaXMuaXNDb250cm9sVmlzaWJsZSgnbXRyJykgJiYgIXRoaXMuZ2V0KCdsb2NrUm90YXRpb24nKSAmJiB0aGlzLmhhc0NvbnRyb2xzKSB7XG5cbiAgICAgICAgdmFyIHJvdGF0ZUhlaWdodCA9IC1oZWlnaHQgLyAyO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbygwLCByb3RhdGVIZWlnaHQpO1xuICAgICAgICBjdHgubGluZVRvKDAsIHJvdGF0ZUhlaWdodCAtIHRoaXMucm90YXRpbmdQb2ludE9mZnNldCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGJvcmRlcnMgb2YgYW4gb2JqZWN0J3MgYm91bmRpbmcgYm94IHdoZW4gaXQgaXMgaW5zaWRlIGEgZ3JvdXAuXG4gICAgICogUmVxdWlyZXMgcHVibGljIHByb3BlcnRpZXM6IHdpZHRoLCBoZWlnaHRcbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgb3B0aW9uczogcGFkZGluZywgYm9yZGVyQ29sb3JcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gZHJhdyBvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIG9iamVjdCByZXByZXNlbnRpbmcgY3VycmVudCBvYmplY3QgcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZHJhd0JvcmRlcnNJbkdyb3VwOiBmdW5jdGlvbihjdHgsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5oYXNCb3JkZXJzKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgcCA9IHRoaXMuX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9ucygpLFxuICAgICAgICAgIG1hdHJpeCA9IGZhYnJpYy51dGlsLmN1c3RvbVRyYW5zZm9ybU1hdHJpeChvcHRpb25zLnNjYWxlWCwgb3B0aW9ucy5zY2FsZVksIG9wdGlvbnMuc2tld1gpLFxuICAgICAgICAgIHdoID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQocCwgbWF0cml4KSxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IDEgLyB0aGlzLmJvcmRlclNjYWxlRmFjdG9yLFxuICAgICAgICAgIHdpZHRoID0gd2gueCArIHN0cm9rZVdpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IHdoLnkgKyBzdHJva2VXaWR0aDtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuX3NldExpbmVEYXNoKGN0eCwgdGhpcy5ib3JkZXJEYXNoQXJyYXksIG51bGwpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5ib3JkZXJDb2xvcjtcblxuICAgICAgY3R4LnN0cm9rZVJlY3QoXG4gICAgICAgIC13aWR0aCAvIDIsXG4gICAgICAgIC1oZWlnaHQgLyAyLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICApO1xuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGNvcm5lcnMgb2YgYW4gb2JqZWN0J3MgYm91bmRpbmcgYm94LlxuICAgICAqIFJlcXVpcmVzIHB1YmxpYyBwcm9wZXJ0aWVzOiB3aWR0aCwgaGVpZ2h0XG4gICAgICogUmVxdWlyZXMgcHVibGljIG9wdGlvbnM6IGNvcm5lclNpemUsIHBhZGRpbmdcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gZHJhdyBvblxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZHJhd0NvbnRyb2xzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5oYXNDb250cm9scykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIHdoID0gdGhpcy5fY2FsY3VsYXRlQ3VycmVudERpbWVuc2lvbnMoKSxcbiAgICAgICAgICB3aWR0aCA9IHdoLngsXG4gICAgICAgICAgaGVpZ2h0ID0gd2gueSxcbiAgICAgICAgICBzY2FsZU9mZnNldCA9IHRoaXMuY29ybmVyU2l6ZSxcbiAgICAgICAgICBsZWZ0ID0gLSh3aWR0aCArIHNjYWxlT2Zmc2V0KSAvIDIsXG4gICAgICAgICAgdG9wID0gLShoZWlnaHQgKyBzY2FsZU9mZnNldCkgLyAyLFxuICAgICAgICAgIG1ldGhvZE5hbWUgPSB0aGlzLnRyYW5zcGFyZW50Q29ybmVycyA/ICdzdHJva2UnIDogJ2ZpbGwnO1xuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29ybmVyQ29sb3I7XG4gICAgICBpZiAoIXRoaXMudHJhbnNwYXJlbnRDb3JuZXJzKSB7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29ybmVyU3Ryb2tlQ29sb3I7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRMaW5lRGFzaChjdHgsIHRoaXMuY29ybmVyRGFzaEFycmF5LCBudWxsKTtcblxuICAgICAgLy8gdG9wLWxlZnRcbiAgICAgIHRoaXMuX2RyYXdDb250cm9sKCd0bCcsIGN0eCwgbWV0aG9kTmFtZSxcbiAgICAgICAgbGVmdCxcbiAgICAgICAgdG9wKTtcblxuICAgICAgLy8gdG9wLXJpZ2h0XG4gICAgICB0aGlzLl9kcmF3Q29udHJvbCgndHInLCBjdHgsIG1ldGhvZE5hbWUsXG4gICAgICAgIGxlZnQgKyB3aWR0aCxcbiAgICAgICAgdG9wKTtcblxuICAgICAgLy8gYm90dG9tLWxlZnRcbiAgICAgIHRoaXMuX2RyYXdDb250cm9sKCdibCcsIGN0eCwgbWV0aG9kTmFtZSxcbiAgICAgICAgbGVmdCxcbiAgICAgICAgdG9wICsgaGVpZ2h0KTtcblxuICAgICAgLy8gYm90dG9tLXJpZ2h0XG4gICAgICB0aGlzLl9kcmF3Q29udHJvbCgnYnInLCBjdHgsIG1ldGhvZE5hbWUsXG4gICAgICAgIGxlZnQgKyB3aWR0aCxcbiAgICAgICAgdG9wICsgaGVpZ2h0KTtcblxuICAgICAgaWYgKCF0aGlzLmdldCgnbG9ja1VuaVNjYWxpbmcnKSkge1xuXG4gICAgICAgIC8vIG1pZGRsZS10b3BcbiAgICAgICAgdGhpcy5fZHJhd0NvbnRyb2woJ210JywgY3R4LCBtZXRob2ROYW1lLFxuICAgICAgICAgIGxlZnQgKyB3aWR0aCAvIDIsXG4gICAgICAgICAgdG9wKTtcblxuICAgICAgICAvLyBtaWRkbGUtYm90dG9tXG4gICAgICAgIHRoaXMuX2RyYXdDb250cm9sKCdtYicsIGN0eCwgbWV0aG9kTmFtZSxcbiAgICAgICAgICBsZWZ0ICsgd2lkdGggLyAyLFxuICAgICAgICAgIHRvcCArIGhlaWdodCk7XG5cbiAgICAgICAgLy8gbWlkZGxlLXJpZ2h0XG4gICAgICAgIHRoaXMuX2RyYXdDb250cm9sKCdtcicsIGN0eCwgbWV0aG9kTmFtZSxcbiAgICAgICAgICBsZWZ0ICsgd2lkdGgsXG4gICAgICAgICAgdG9wICsgaGVpZ2h0IC8gMik7XG5cbiAgICAgICAgLy8gbWlkZGxlLWxlZnRcbiAgICAgICAgdGhpcy5fZHJhd0NvbnRyb2woJ21sJywgY3R4LCBtZXRob2ROYW1lLFxuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgdG9wICsgaGVpZ2h0IC8gMik7XG4gICAgICB9XG5cbiAgICAgIC8vIG1pZGRsZS10b3Atcm90YXRlXG4gICAgICBpZiAodGhpcy5oYXNSb3RhdGluZ1BvaW50KSB7XG4gICAgICAgIHRoaXMuX2RyYXdDb250cm9sKCdtdHInLCBjdHgsIG1ldGhvZE5hbWUsXG4gICAgICAgICAgbGVmdCArIHdpZHRoIC8gMixcbiAgICAgICAgICB0b3AgLSB0aGlzLnJvdGF0aW5nUG9pbnRPZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZHJhd0NvbnRyb2w6IGZ1bmN0aW9uKGNvbnRyb2wsIGN0eCwgbWV0aG9kTmFtZSwgbGVmdCwgdG9wKSB7XG4gICAgICBpZiAoIXRoaXMuaXNDb250cm9sVmlzaWJsZShjb250cm9sKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuY29ybmVyU2l6ZSwgc3Ryb2tlID0gIXRoaXMudHJhbnNwYXJlbnRDb3JuZXJzICYmIHRoaXMuY29ybmVyU3Ryb2tlQ29sb3I7XG4gICAgICBzd2l0Y2ggKHRoaXMuY29ybmVyU3R5bGUpIHtcbiAgICAgICAgY2FzZSAnY2lyY2xlJzpcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY3R4LmFyYyhsZWZ0ICsgc2l6ZSAvIDIsIHRvcCArIHNpemUgLyAyLCBzaXplIC8gMiwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgICBjdHhbbWV0aG9kTmFtZV0oKTtcbiAgICAgICAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlzVk1MKCkgfHwgdGhpcy50cmFuc3BhcmVudENvcm5lcnMgfHwgY3R4LmNsZWFyUmVjdChsZWZ0LCB0b3AsIHNpemUsIHNpemUpO1xuICAgICAgICAgIGN0eFttZXRob2ROYW1lICsgJ1JlY3QnXShsZWZ0LCB0b3AsIHNpemUsIHNpemUpO1xuICAgICAgICAgIGlmIChzdHJva2UpIHtcbiAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KGxlZnQsIHRvcCwgc2l6ZSwgc2l6ZSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBjb250cm9sIGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29udHJvbE5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvbnRyb2wuIFBvc3NpYmxlIHZhbHVlcyBhcmUgJ3RsJywgJ3RyJywgJ2JyJywgJ2JsJywgJ21sJywgJ210JywgJ21yJywgJ21iJywgJ210cicuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNwZWNpZmllZCBjb250cm9sIGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGlzQ29udHJvbFZpc2libGU6IGZ1bmN0aW9uKGNvbnRyb2xOYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0Q29udHJvbHNWaXNpYmlsaXR5KClbY29udHJvbE5hbWVdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBzcGVjaWZpZWQgY29udHJvbC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29udHJvbE5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvbnRyb2wuIFBvc3NpYmxlIHZhbHVlcyBhcmUgJ3RsJywgJ3RyJywgJ2JyJywgJ2JsJywgJ21sJywgJ210JywgJ21yJywgJ21iJywgJ210cicuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmxlIHRydWUgdG8gc2V0IHRoZSBzcGVjaWZpZWQgY29udHJvbCB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldENvbnRyb2xWaXNpYmxlOiBmdW5jdGlvbihjb250cm9sTmFtZSwgdmlzaWJsZSkge1xuICAgICAgdGhpcy5fZ2V0Q29udHJvbHNWaXNpYmlsaXR5KClbY29udHJvbE5hbWVdID0gdmlzaWJsZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2aXNpYmlsaXR5IHN0YXRlIG9mIG9iamVjdCBjb250cm9scy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ibF0gdHJ1ZSB0byBlbmFibGUgdGhlIGJvdHRvbS1sZWZ0IGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJyXSB0cnVlIHRvIGVuYWJsZSB0aGUgYm90dG9tLXJpZ2h0IGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1iXSB0cnVlIHRvIGVuYWJsZSB0aGUgbWlkZGxlLWJvdHRvbSBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tbF0gdHJ1ZSB0byBlbmFibGUgdGhlIG1pZGRsZS1sZWZ0IGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1yXSB0cnVlIHRvIGVuYWJsZSB0aGUgbWlkZGxlLXJpZ2h0IGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm10XSB0cnVlIHRvIGVuYWJsZSB0aGUgbWlkZGxlLXRvcCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50bF0gdHJ1ZSB0byBlbmFibGUgdGhlIHRvcC1sZWZ0IGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRyXSB0cnVlIHRvIGVuYWJsZSB0aGUgdG9wLXJpZ2h0IGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm10cl0gdHJ1ZSB0byBlbmFibGUgdGhlIG1pZGRsZS10b3Atcm90YXRlIGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldENvbnRyb2xzVmlzaWJpbGl0eTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIGZvciAodmFyIHAgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNldENvbnRyb2xWaXNpYmxlKHAsIG9wdGlvbnNbcF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIHRoZSBjb250cm9sIHZpc2liaWxpdHkgc2V0IGZvciB0aGlzIG9iamVjdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgX2dldENvbnRyb2xzVmlzaWJpbGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbnRyb2xzVmlzaWJpbGl0eSkge1xuICAgICAgICB0aGlzLl9jb250cm9sc1Zpc2liaWxpdHkgPSB7XG4gICAgICAgICAgdGw6IHRydWUsXG4gICAgICAgICAgdHI6IHRydWUsXG4gICAgICAgICAgYnI6IHRydWUsXG4gICAgICAgICAgYmw6IHRydWUsXG4gICAgICAgICAgbWw6IHRydWUsXG4gICAgICAgICAgbXQ6IHRydWUsXG4gICAgICAgICAgbXI6IHRydWUsXG4gICAgICAgICAgbWI6IHRydWUsXG4gICAgICAgICAgbXRyOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fY29udHJvbHNWaXNpYmlsaXR5O1xuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBBbmltYXRpb24gZHVyYXRpb24gKGluIG1zKSBmb3IgZngqIG1ldGhvZHNcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBGWF9EVVJBVElPTjogNTAwLFxuXG4gIC8qKlxuICAgKiBDZW50ZXJzIG9iamVjdCBob3Jpem9udGFsbHkgd2l0aCBhbmltYXRpb24uXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjYWxsYmFja3NdIENhbGxiYWNrcyBvYmplY3Qgd2l0aCBvcHRpb25hbCBcIm9uQ29tcGxldGVcIiBhbmQvb3IgXCJvbkNoYW5nZVwiIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNvbXBsZXRlXSBJbnZva2VkIG9uIGNvbXBsZXRpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNoYW5nZV0gSW52b2tlZCBvbiBldmVyeSBzdGVwIG9mIGFuaW1hdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGZ4Q2VudGVyT2JqZWN0SDogZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzIHx8IHsgfTtcblxuICAgIHZhciBlbXB0eSA9IGZ1bmN0aW9uKCkgeyB9LFxuICAgICAgICBvbkNvbXBsZXRlID0gY2FsbGJhY2tzLm9uQ29tcGxldGUgfHwgZW1wdHksXG4gICAgICAgIG9uQ2hhbmdlID0gY2FsbGJhY2tzLm9uQ2hhbmdlIHx8IGVtcHR5LFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICBmYWJyaWMudXRpbC5hbmltYXRlKHtcbiAgICAgIHN0YXJ0VmFsdWU6IG9iamVjdC5nZXQoJ2xlZnQnKSxcbiAgICAgIGVuZFZhbHVlOiB0aGlzLmdldENlbnRlcigpLmxlZnQsXG4gICAgICBkdXJhdGlvbjogdGhpcy5GWF9EVVJBVElPTixcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBvYmplY3Quc2V0KCdsZWZ0JywgdmFsdWUpO1xuICAgICAgICBfdGhpcy5yZW5kZXJBbGwoKTtcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgb2JqZWN0LnNldENvb3JkcygpO1xuICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSB3aXRoIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlclxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NhbGxiYWNrc10gQ2FsbGJhY2tzIG9iamVjdCB3aXRoIG9wdGlvbmFsIFwib25Db21wbGV0ZVwiIGFuZC9vciBcIm9uQ2hhbmdlXCIgcHJvcGVydGllc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ29tcGxldGVdIEludm9rZWQgb24gY29tcGxldGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ2hhbmdlXSBJbnZva2VkIG9uIGV2ZXJ5IHN0ZXAgb2YgYW5pbWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZnhDZW50ZXJPYmplY3RWOiBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3MgfHwgeyB9O1xuXG4gICAgdmFyIGVtcHR5ID0gZnVuY3Rpb24oKSB7IH0sXG4gICAgICAgIG9uQ29tcGxldGUgPSBjYWxsYmFja3Mub25Db21wbGV0ZSB8fCBlbXB0eSxcbiAgICAgICAgb25DaGFuZ2UgPSBjYWxsYmFja3Mub25DaGFuZ2UgfHwgZW1wdHksXG4gICAgICAgIF90aGlzID0gdGhpcztcblxuICAgIGZhYnJpYy51dGlsLmFuaW1hdGUoe1xuICAgICAgc3RhcnRWYWx1ZTogb2JqZWN0LmdldCgndG9wJyksXG4gICAgICBlbmRWYWx1ZTogdGhpcy5nZXRDZW50ZXIoKS50b3AsXG4gICAgICBkdXJhdGlvbjogdGhpcy5GWF9EVVJBVElPTixcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBvYmplY3Quc2V0KCd0b3AnLCB2YWx1ZSk7XG4gICAgICAgIF90aGlzLnJlbmRlckFsbCgpO1xuICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBvYmplY3Quc2V0Q29vcmRzKCk7XG4gICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIGBmYWJyaWMuQ2FudmFzI3JlbW92ZWAgYnV0IGFuaW1hdGVkXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byByZW1vdmVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjYWxsYmFja3NdIENhbGxiYWNrcyBvYmplY3Qgd2l0aCBvcHRpb25hbCBcIm9uQ29tcGxldGVcIiBhbmQvb3IgXCJvbkNoYW5nZVwiIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNvbXBsZXRlXSBJbnZva2VkIG9uIGNvbXBsZXRpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNoYW5nZV0gSW52b2tlZCBvbiBldmVyeSBzdGVwIG9mIGFuaW1hdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGZ4UmVtb3ZlOiBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3MgfHwgeyB9O1xuXG4gICAgdmFyIGVtcHR5ID0gZnVuY3Rpb24oKSB7IH0sXG4gICAgICAgIG9uQ29tcGxldGUgPSBjYWxsYmFja3Mub25Db21wbGV0ZSB8fCBlbXB0eSxcbiAgICAgICAgb25DaGFuZ2UgPSBjYWxsYmFja3Mub25DaGFuZ2UgfHwgZW1wdHksXG4gICAgICAgIF90aGlzID0gdGhpcztcblxuICAgIGZhYnJpYy51dGlsLmFuaW1hdGUoe1xuICAgICAgc3RhcnRWYWx1ZTogb2JqZWN0LmdldCgnb3BhY2l0eScpLFxuICAgICAgZW5kVmFsdWU6IDAsXG4gICAgICBkdXJhdGlvbjogdGhpcy5GWF9EVVJBVElPTixcbiAgICAgIG9uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBvYmplY3Quc2V0KCdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICB9LFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIG9iamVjdC5zZXQoJ29wYWNpdHknLCB2YWx1ZSk7XG4gICAgICAgIF90aGlzLnJlbmRlckFsbCgpO1xuICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMucmVtb3ZlKG9iamVjdCk7XG4gICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG4gIC8qKlxuICAgKiBBbmltYXRlcyBvYmplY3QncyBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gcHJvcGVydHkgUHJvcGVydHkgdG8gYW5pbWF0ZSAoaWYgc3RyaW5nKSBvciBwcm9wZXJ0aWVzIHRvIGFuaW1hdGUgKGlmIG9iamVjdClcbiAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSB2YWx1ZSBWYWx1ZSB0byBhbmltYXRlIHByb3BlcnR5IHRvIChpZiBzdHJpbmcgd2FzIGdpdmVuIGZpcnN0KSBvciBvcHRpb25zIG9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0yI2FuaW1hdGlvbn1cbiAgICogQGNoYWluYWJsZVxuICAgKlxuICAgKiBBcyBvYmplY3Qg4oCUIG11bHRpcGxlIHByb3BlcnRpZXNcbiAgICpcbiAgICogb2JqZWN0LmFuaW1hdGUoeyBsZWZ0OiAuLi4sIHRvcDogLi4uIH0pO1xuICAgKiBvYmplY3QuYW5pbWF0ZSh7IGxlZnQ6IC4uLiwgdG9wOiAuLi4gfSwgeyBkdXJhdGlvbjogLi4uIH0pO1xuICAgKlxuICAgKiBBcyBzdHJpbmcg4oCUIG9uZSBwcm9wZXJ0eVxuICAgKlxuICAgKiBvYmplY3QuYW5pbWF0ZSgnbGVmdCcsIC4uLik7XG4gICAqIG9iamVjdC5hbmltYXRlKCdsZWZ0JywgeyBkdXJhdGlvbjogLi4uIH0pO1xuICAgKlxuICAgKi9cbiAgYW5pbWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIHByb3BzVG9BbmltYXRlID0gW10sIHByb3AsIHNraXBDYWxsYmFja3M7XG4gICAgICBmb3IgKHByb3AgaW4gYXJndW1lbnRzWzBdKSB7XG4gICAgICAgIHByb3BzVG9BbmltYXRlLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcHJvcHNUb0FuaW1hdGUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcHJvcCA9IHByb3BzVG9BbmltYXRlW2ldO1xuICAgICAgICBza2lwQ2FsbGJhY2tzID0gaSAhPT0gbGVuIC0gMTtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZShwcm9wLCBhcmd1bWVudHNbMF1bcHJvcF0sIGFyZ3VtZW50c1sxXSwgc2tpcENhbGxiYWNrcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fYW5pbWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRvIGFuaW1hdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRvIFZhbHVlIHRvIGFuaW1hdGUgdG9cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwQ2FsbGJhY2tzXSBXaGVuIHRydWUsIGNhbGxiYWNrcyBsaWtlIG9uY2hhbmdlIGFuZCBvbmNvbXBsZXRlIGFyZSBub3QgaW52b2tlZFxuICAgKi9cbiAgX2FuaW1hdGU6IGZ1bmN0aW9uKHByb3BlcnR5LCB0bywgb3B0aW9ucywgc2tpcENhbGxiYWNrcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsIHByb3BQYWlyO1xuXG4gICAgdG8gPSB0by50b1N0cmluZygpO1xuXG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0geyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKH5wcm9wZXJ0eS5pbmRleE9mKCcuJykpIHtcbiAgICAgIHByb3BQYWlyID0gcHJvcGVydHkuc3BsaXQoJy4nKTtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudFZhbHVlID0gcHJvcFBhaXJcbiAgICAgID8gdGhpcy5nZXQocHJvcFBhaXJbMF0pW3Byb3BQYWlyWzFdXVxuICAgICAgOiB0aGlzLmdldChwcm9wZXJ0eSk7XG5cbiAgICBpZiAoISgnZnJvbScgaW4gb3B0aW9ucykpIHtcbiAgICAgIG9wdGlvbnMuZnJvbSA9IGN1cnJlbnRWYWx1ZTtcbiAgICB9XG5cbiAgICBpZiAofnRvLmluZGV4T2YoJz0nKSkge1xuICAgICAgdG8gPSBjdXJyZW50VmFsdWUgKyBwYXJzZUZsb2F0KHRvLnJlcGxhY2UoJz0nLCAnJykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRvID0gcGFyc2VGbG9hdCh0byk7XG4gICAgfVxuXG4gICAgZmFicmljLnV0aWwuYW5pbWF0ZSh7XG4gICAgICBzdGFydFZhbHVlOiBvcHRpb25zLmZyb20sXG4gICAgICBlbmRWYWx1ZTogdG8sXG4gICAgICBieVZhbHVlOiBvcHRpb25zLmJ5LFxuICAgICAgZWFzaW5nOiBvcHRpb25zLmVhc2luZyxcbiAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuICAgICAgYWJvcnQ6IG9wdGlvbnMuYWJvcnQgJiYgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmFib3J0LmNhbGwoX3RoaXMpO1xuICAgICAgfSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAocHJvcFBhaXIpIHtcbiAgICAgICAgICBfdGhpc1twcm9wUGFpclswXV1bcHJvcFBhaXJbMV1dID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgX3RoaXMuc2V0KHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXBDYWxsYmFja3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5vbkNoYW5nZSAmJiBvcHRpb25zLm9uQ2hhbmdlKCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChza2lwQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuc2V0Q29vcmRzKCk7XG4gICAgICAgIG9wdGlvbnMub25Db21wbGV0ZSAmJiBvcHRpb25zLm9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUsXG4gICAgICBjb29yZFByb3BzID0geyB4MTogMSwgeDI6IDEsIHkxOiAxLCB5MjogMSB9LFxuICAgICAgc3VwcG9ydHNMaW5lRGFzaCA9IGZhYnJpYy5TdGF0aWNDYW52YXMuc3VwcG9ydHMoJ3NldExpbmVEYXNoJyk7XG5cbiAgaWYgKGZhYnJpYy5MaW5lKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5MaW5lIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjYWNoZVByb3BlcnRpZXMgPSBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KCk7XG4gIGNhY2hlUHJvcGVydGllcy5wdXNoKFxuICAgICd4MScsXG4gICAgJ3gyJyxcbiAgICAneTEnLFxuICAgICd5MidcbiAgKTtcblxuICAvKipcbiAgICogTGluZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkxpbmVcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuTGluZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLkxpbmUgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5MaW5lLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2xpbmUnLFxuXG4gICAgLyoqXG4gICAgICogeCB2YWx1ZSBvciBmaXJzdCBsaW5lIGVkZ2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHgxOiAwLFxuXG4gICAgLyoqXG4gICAgICogeSB2YWx1ZSBvciBmaXJzdCBsaW5lIGVkZ2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHkxOiAwLFxuXG4gICAgLyoqXG4gICAgICogeCB2YWx1ZSBvciBzZWNvbmQgbGluZSBlZGdlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB4MjogMCxcblxuICAgIC8qKlxuICAgICAqIHkgdmFsdWUgb3Igc2Vjb25kIGxpbmUgZWRnZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgeTI6IDAsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGNhY2hlUHJvcGVydGllcyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BvaW50c10gQXJyYXkgb2YgcG9pbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5MaW5lfSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ocG9pbnRzLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIXBvaW50cykge1xuICAgICAgICBwb2ludHMgPSBbMCwgMCwgMCwgMF07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuc2V0KCd4MScsIHBvaW50c1swXSk7XG4gICAgICB0aGlzLnNldCgneTEnLCBwb2ludHNbMV0pO1xuICAgICAgdGhpcy5zZXQoJ3gyJywgcG9pbnRzWzJdKTtcbiAgICAgIHRoaXMuc2V0KCd5MicsIHBvaW50c1szXSk7XG5cbiAgICAgIHRoaXMuX3NldFdpZHRoSGVpZ2h0KG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uc1xuICAgICAqL1xuICAgIF9zZXRXaWR0aEhlaWdodDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHRoaXMud2lkdGggPSBNYXRoLmFicyh0aGlzLngyIC0gdGhpcy54MSk7XG4gICAgICB0aGlzLmhlaWdodCA9IE1hdGguYWJzKHRoaXMueTIgLSB0aGlzLnkxKTtcblxuICAgICAgdGhpcy5sZWZ0ID0gJ2xlZnQnIGluIG9wdGlvbnNcbiAgICAgICAgPyBvcHRpb25zLmxlZnRcbiAgICAgICAgOiB0aGlzLl9nZXRMZWZ0VG9PcmlnaW5YKCk7XG5cbiAgICAgIHRoaXMudG9wID0gJ3RvcCcgaW4gb3B0aW9uc1xuICAgICAgICA/IG9wdGlvbnMudG9wXG4gICAgICAgIDogdGhpcy5fZ2V0VG9wVG9PcmlnaW5ZKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICBfc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3NldCcsIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKHR5cGVvZiBjb29yZFByb3BzW2tleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuX3NldFdpZHRoSGVpZ2h0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGxlZnRUb09yaWdpblggRGlzdGFuY2UgZnJvbSBsZWZ0IGVkZ2Ugb2YgY2FudmFzIHRvIG9yaWdpblggb2YgTGluZS5cbiAgICAgKi9cbiAgICBfZ2V0TGVmdFRvT3JpZ2luWDogbWFrZUVkZ2VUb09yaWdpbkdldHRlcihcbiAgICAgIHsgLy8gcHJvcGVydHkgbmFtZXNcbiAgICAgICAgb3JpZ2luOiAnb3JpZ2luWCcsXG4gICAgICAgIGF4aXMxOiAneDEnLFxuICAgICAgICBheGlzMjogJ3gyJyxcbiAgICAgICAgZGltZW5zaW9uOiAnd2lkdGgnXG4gICAgICB9LFxuICAgICAgeyAvLyBwb3NzaWJsZSB2YWx1ZXMgb2Ygb3JpZ2luXG4gICAgICAgIG5lYXJlc3Q6ICdsZWZ0JyxcbiAgICAgICAgY2VudGVyOiAnY2VudGVyJyxcbiAgICAgICAgZmFydGhlc3Q6ICdyaWdodCdcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRvcFRvT3JpZ2luWSBEaXN0YW5jZSBmcm9tIHRvcCBlZGdlIG9mIGNhbnZhcyB0byBvcmlnaW5ZIG9mIExpbmUuXG4gICAgICovXG4gICAgX2dldFRvcFRvT3JpZ2luWTogbWFrZUVkZ2VUb09yaWdpbkdldHRlcihcbiAgICAgIHsgLy8gcHJvcGVydHkgbmFtZXNcbiAgICAgICAgb3JpZ2luOiAnb3JpZ2luWScsXG4gICAgICAgIGF4aXMxOiAneTEnLFxuICAgICAgICBheGlzMjogJ3kyJyxcbiAgICAgICAgZGltZW5zaW9uOiAnaGVpZ2h0J1xuICAgICAgfSxcbiAgICAgIHsgLy8gcG9zc2libGUgdmFsdWVzIG9mIG9yaWdpblxuICAgICAgICBuZWFyZXN0OiAndG9wJyxcbiAgICAgICAgY2VudGVyOiAnY2VudGVyJyxcbiAgICAgICAgZmFydGhlc3Q6ICdib3R0b20nXG4gICAgICB9XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbm9UcmFuc2Zvcm1cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgsIG5vVHJhbnNmb3JtKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgIGlmIChub1RyYW5zZm9ybSkge1xuICAgICAgICAvLyAgTGluZSBjb29yZHMgYXJlIGRpc3RhbmNlcyBmcm9tIGxlZnQtdG9wIG9mIGNhbnZhcyB0byBvcmlnaW4gb2YgbGluZS5cbiAgICAgICAgLy8gIFRvIHJlbmRlciBsaW5lIGluIGEgcGF0aC1ncm91cCwgd2UgbmVlZCB0byB0cmFuc2xhdGUgdGhlbSB0b1xuICAgICAgICAvLyAgZGlzdGFuY2VzIGZyb20gY2VudGVyIG9mIHBhdGgtZ3JvdXAgdG8gY2VudGVyIG9mIGxpbmUuXG4gICAgICAgIHZhciBjcCA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZShcbiAgICAgICAgICBjcC54IC0gdGhpcy5zdHJva2VXaWR0aCAvIDIsXG4gICAgICAgICAgY3AueSAtIHRoaXMuc3Ryb2tlV2lkdGggLyAyXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5zdHJva2VEYXNoQXJyYXkgfHwgdGhpcy5zdHJva2VEYXNoQXJyYXkgJiYgc3VwcG9ydHNMaW5lRGFzaCkge1xuICAgICAgICAvLyBtb3ZlIGZyb20gY2VudGVyIChvZiB2aXJ0dWFsIGJveCkgdG8gaXRzIGxlZnQvdG9wIGNvcm5lclxuICAgICAgICAvLyB3ZSBjYW4ndCBhc3N1bWUgeDEsIHkxIGlzIHRvcCBsZWZ0IGFuZCB4MiwgeTIgaXMgYm90dG9tIHJpZ2h0XG4gICAgICAgIHZhciBwID0gdGhpcy5jYWxjTGluZVBvaW50cygpO1xuICAgICAgICBjdHgubW92ZVRvKHAueDEsIHAueTEpO1xuICAgICAgICBjdHgubGluZVRvKHAueDIsIHAueTIpO1xuICAgICAgfVxuXG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5zdHJva2VXaWR0aDtcblxuICAgICAgLy8gVE9ETzogdGVzdCB0aGlzXG4gICAgICAvLyBtYWtlIHN1cmUgc2V0dGluZyBcImZpbGxcIiBjaGFuZ2VzIGNvbG9yIG9mIGEgbGluZVxuICAgICAgLy8gKGJ5IGNvcHlpbmcgZmlsbFN0eWxlIHRvIHN0cm9rZVN0eWxlLCBzaW5jZSBsaW5lIGlzIHN0cm9rZWQsIG5vdCBmaWxsZWQpXG4gICAgICB2YXIgb3JpZ1N0cm9rZVN0eWxlID0gY3R4LnN0cm9rZVN0eWxlO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5zdHJva2UgfHwgY3R4LmZpbGxTdHlsZTtcbiAgICAgIHRoaXMuc3Ryb2tlICYmIHRoaXMuX3JlbmRlclN0cm9rZShjdHgpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3JpZ1N0cm9rZVN0eWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyRGFzaGVkU3Ryb2tlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBwID0gdGhpcy5jYWxjTGluZVBvaW50cygpO1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHAueDEsIHAueTEsIHAueDIsIHAueTIsIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAbWV0aGQgdG9PYmplY3RcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSwgdGhpcy5jYWxjTGluZVBvaW50cygpKTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgb2JqZWN0IGRpbWVuc2lvbnMgZnJvbSBpdHMgcHJvcGVydGllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGltID0gdGhpcy5jYWxsU3VwZXIoJ19nZXROb25UcmFuc2Zvcm1lZERpbWVuc2lvbnMnKTtcbiAgICAgIGlmICh0aGlzLnN0cm9rZUxpbmVDYXAgPT09ICdidXR0Jykge1xuICAgICAgICBpZiAoZGltLnggPT09IDApIHtcbiAgICAgICAgICBkaW0ueSAtPSB0aGlzLnN0cm9rZVdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaW0ueSA9PT0gMCkge1xuICAgICAgICAgIGRpbS54IC09IHRoaXMuc3Ryb2tlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkaW07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlY2FsY3VsYXRlcyBsaW5lIHBvaW50cyBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjYWxjTGluZVBvaW50czogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgeE11bHQgPSB0aGlzLngxIDw9IHRoaXMueDIgPyAtMSA6IDEsXG4gICAgICAgICAgeU11bHQgPSB0aGlzLnkxIDw9IHRoaXMueTIgPyAtMSA6IDEsXG4gICAgICAgICAgeDEgPSAoeE11bHQgKiB0aGlzLndpZHRoICogMC41KSxcbiAgICAgICAgICB5MSA9ICh5TXVsdCAqIHRoaXMuaGVpZ2h0ICogMC41KSxcbiAgICAgICAgICB4MiA9ICh4TXVsdCAqIHRoaXMud2lkdGggKiAtMC41KSxcbiAgICAgICAgICB5MiA9ICh5TXVsdCAqIHRoaXMuaGVpZ2h0ICogLTAuNSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiB4MSxcbiAgICAgICAgeDI6IHgyLFxuICAgICAgICB5MTogeTEsXG4gICAgICAgIHkyOiB5MlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIG1hcmt1cCA9IHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAoKSxcbiAgICAgICAgICBwID0geyB4MTogdGhpcy54MSwgeDI6IHRoaXMueDIsIHkxOiB0aGlzLnkxLCB5MjogdGhpcy55MiB9O1xuXG4gICAgICBpZiAoISh0aGlzLmdyb3VwICYmIHRoaXMuZ3JvdXAudHlwZSA9PT0gJ3BhdGgtZ3JvdXAnKSkge1xuICAgICAgICBwID0gdGhpcy5jYWxjTGluZVBvaW50cygpO1xuICAgICAgfVxuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICc8bGluZSAnLCB0aGlzLmdldFN2Z0lkKCksXG4gICAgICAgICAgJ3gxPVwiJywgcC54MSxcbiAgICAgICAgICAnXCIgeTE9XCInLCBwLnkxLFxuICAgICAgICAgICdcIiB4Mj1cIicsIHAueDIsXG4gICAgICAgICAgJ1wiIHkyPVwiJywgcC55MixcbiAgICAgICAgICAnXCIgc3R5bGU9XCInLCB0aGlzLmdldFN2Z1N0eWxlcygpLFxuICAgICAgICAgICdcIiB0cmFuc2Zvcm09XCInLCB0aGlzLmdldFN2Z1RyYW5zZm9ybSgpLFxuICAgICAgICAgIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtTWF0cml4KCksXG4gICAgICAgICdcIi8+XFxuJ1xuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHJldml2ZXIgPyByZXZpdmVyKG1hcmt1cC5qb2luKCcnKSkgOiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29tcGxleGl0eSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gY29tcGxleGl0eVxuICAgICAqL1xuICAgIGNvbXBsZXhpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkge0BsaW5rIGZhYnJpYy5MaW5lLmZyb21FbGVtZW50fSlcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkxpbmVcbiAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc2hhcGVzLmh0bWwjTGluZUVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5MaW5lLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoJ3gxIHkxIHgyIHkyJy5zcGxpdCgnICcpKTtcblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuTGluZSBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5MaW5lXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLkxpbmV9IGluc3RhbmNlIG9mIGZhYnJpYy5MaW5lXG4gICAqL1xuICBmYWJyaWMuTGluZS5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5MaW5lLkFUVFJJQlVURV9OQU1FUyksXG4gICAgICAgIHBvaW50cyA9IFtcbiAgICAgICAgICBwYXJzZWRBdHRyaWJ1dGVzLngxIHx8IDAsXG4gICAgICAgICAgcGFyc2VkQXR0cmlidXRlcy55MSB8fCAwLFxuICAgICAgICAgIHBhcnNlZEF0dHJpYnV0ZXMueDIgfHwgMCxcbiAgICAgICAgICBwYXJzZWRBdHRyaWJ1dGVzLnkyIHx8IDBcbiAgICAgICAgXTtcbiAgICBvcHRpb25zLm9yaWdpblggPSAnbGVmdCc7XG4gICAgb3B0aW9ucy5vcmlnaW5ZID0gJ3RvcCc7XG4gICAgcmV0dXJuIG5ldyBmYWJyaWMuTGluZShwb2ludHMsIGV4dGVuZChwYXJzZWRBdHRyaWJ1dGVzLCBvcHRpb25zKSk7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLkxpbmUgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkxpbmVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBpbnZva2VkIHdpdGggbmV3IGluc3RhbmNlIGFzIGZpcnN0IGFyZ3VtZW50XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlQXN5bmNdIEZvcmNlIGFuIGFzeW5jIGJlaGF2aW91ciB0cnlpbmcgdG8gY3JlYXRlIHBhdHRlcm4gZmlyc3RcbiAgICogQHJldHVybiB7ZmFicmljLkxpbmV9IGluc3RhbmNlIG9mIGZhYnJpYy5MaW5lXG4gICAqL1xuICBmYWJyaWMuTGluZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaywgZm9yY2VBc3luYykge1xuICAgIGZ1bmN0aW9uIF9jYWxsYmFjayhpbnN0YW5jZSkge1xuICAgICAgZGVsZXRlIGluc3RhbmNlLnBvaW50cztcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGluc3RhbmNlKTtcbiAgICB9O1xuICAgIHZhciBvcHRpb25zID0gY2xvbmUob2JqZWN0LCB0cnVlKTtcbiAgICBvcHRpb25zLnBvaW50cyA9IFtvYmplY3QueDEsIG9iamVjdC55MSwgb2JqZWN0LngyLCBvYmplY3QueTJdO1xuICAgIHZhciBsaW5lID0gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnTGluZScsIG9wdGlvbnMsIF9jYWxsYmFjaywgZm9yY2VBc3luYywgJ3BvaW50cycpO1xuICAgIGlmIChsaW5lKSB7XG4gICAgICBkZWxldGUgbGluZS5wb2ludHM7XG4gICAgfVxuICAgIHJldHVybiBsaW5lO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm9kdWNlcyBhIGZ1bmN0aW9uIHRoYXQgY2FsY3VsYXRlcyBkaXN0YW5jZSBmcm9tIGNhbnZhcyBlZGdlIHRvIExpbmUgb3JpZ2luLlxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZUVkZ2VUb09yaWdpbkdldHRlcihwcm9wZXJ0eU5hbWVzLCBvcmlnaW5WYWx1ZXMpIHtcbiAgICB2YXIgb3JpZ2luID0gcHJvcGVydHlOYW1lcy5vcmlnaW4sXG4gICAgICAgIGF4aXMxID0gcHJvcGVydHlOYW1lcy5heGlzMSxcbiAgICAgICAgYXhpczIgPSBwcm9wZXJ0eU5hbWVzLmF4aXMyLFxuICAgICAgICBkaW1lbnNpb24gPSBwcm9wZXJ0eU5hbWVzLmRpbWVuc2lvbixcbiAgICAgICAgbmVhcmVzdCA9IG9yaWdpblZhbHVlcy5uZWFyZXN0LFxuICAgICAgICBjZW50ZXIgPSBvcmlnaW5WYWx1ZXMuY2VudGVyLFxuICAgICAgICBmYXJ0aGVzdCA9IG9yaWdpblZhbHVlcy5mYXJ0aGVzdDtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5nZXQob3JpZ2luKSkge1xuICAgICAgICBjYXNlIG5lYXJlc3Q6XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMuZ2V0KGF4aXMxKSwgdGhpcy5nZXQoYXhpczIpKTtcbiAgICAgICAgY2FzZSBjZW50ZXI6XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMuZ2V0KGF4aXMxKSwgdGhpcy5nZXQoYXhpczIpKSArICgwLjUgKiB0aGlzLmdldChkaW1lbnNpb24pKTtcbiAgICAgICAgY2FzZSBmYXJ0aGVzdDpcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5nZXQoYXhpczEpLCB0aGlzLmdldChheGlzMikpO1xuICAgICAgfVxuICAgIH07XG5cbiAgfVxuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBwaSA9IE1hdGguUEksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kO1xuXG4gIGlmIChmYWJyaWMuQ2lyY2xlKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5DaXJjbGUgaXMgYWxyZWFkeSBkZWZpbmVkLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjYWNoZVByb3BlcnRpZXMgPSBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KCk7XG4gIGNhY2hlUHJvcGVydGllcy5wdXNoKFxuICAgICdyYWRpdXMnXG4gICk7XG5cbiAgLyoqXG4gICAqIENpcmNsZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkNpcmNsZVxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5DaXJjbGUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5DaXJjbGUgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5DaXJjbGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnY2lyY2xlJyxcblxuICAgIC8qKlxuICAgICAqIFJhZGl1cyBvZiB0aGlzIGNpcmNsZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcmFkaXVzOiAwLFxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgYW5nbGUgb2YgdGhlIGNpcmNsZSwgbW92aW5nIGNsb2Nrd2lzZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBzdGFydEFuZ2xlOiAwLFxuXG4gICAgLyoqXG4gICAgICogRW5kIGFuZ2xlIG9mIHRoZSBjaXJjbGVcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAyUGlcbiAgICAgKi9cbiAgICBlbmRBbmdsZTogcGkgKiAyLFxuXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBjYWNoZVByb3BlcnRpZXMsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2lyY2xlfSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuc2V0KCdyYWRpdXMnLCBvcHRpb25zICYmIG9wdGlvbnMucmFkaXVzIHx8IDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLkNpcmNsZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0Jywga2V5LCB2YWx1ZSk7XG5cbiAgICAgIGlmIChrZXkgPT09ICdyYWRpdXMnKSB7XG4gICAgICAgIHRoaXMuc2V0UmFkaXVzKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBbJ3JhZGl1cycsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJ10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIG1hcmt1cCA9IHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAoKSwgeCA9IDAsIHkgPSAwLFxuICAgICAgICAgIGFuZ2xlID0gKHRoaXMuZW5kQW5nbGUgLSB0aGlzLnN0YXJ0QW5nbGUpICUgKCAyICogcGkpO1xuXG4gICAgICBpZiAoYW5nbGUgPT09IDApIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JvdXAgJiYgdGhpcy5ncm91cC50eXBlID09PSAncGF0aC1ncm91cCcpIHtcbiAgICAgICAgICB4ID0gdGhpcy5sZWZ0ICsgdGhpcy5yYWRpdXM7XG4gICAgICAgICAgeSA9IHRoaXMudG9wICsgdGhpcy5yYWRpdXM7XG4gICAgICAgIH1cbiAgICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICAgJzxjaXJjbGUgJywgdGhpcy5nZXRTdmdJZCgpLFxuICAgICAgICAgICAgJ2N4PVwiJyArIHggKyAnXCIgY3k9XCInICsgeSArICdcIiAnLFxuICAgICAgICAgICAgJ3I9XCInLCB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAgICdcIiBzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKCksXG4gICAgICAgICAgICAnXCIgdHJhbnNmb3JtPVwiJywgdGhpcy5nZXRTdmdUcmFuc2Zvcm0oKSxcbiAgICAgICAgICAgICcgJywgdGhpcy5nZXRTdmdUcmFuc2Zvcm1NYXRyaXgoKSxcbiAgICAgICAgICAnXCIvPlxcbidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgc3RhcnRYID0gTWF0aC5jb3ModGhpcy5zdGFydEFuZ2xlKSAqIHRoaXMucmFkaXVzLFxuICAgICAgICAgICAgc3RhcnRZID0gTWF0aC5zaW4odGhpcy5zdGFydEFuZ2xlKSAqIHRoaXMucmFkaXVzLFxuICAgICAgICAgICAgZW5kWCA9IE1hdGguY29zKHRoaXMuZW5kQW5nbGUpICogdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICBlbmRZID0gTWF0aC5zaW4odGhpcy5lbmRBbmdsZSkgKiB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAgIGxhcmdlRmxhZyA9IGFuZ2xlID4gcGkgPyAnMScgOiAnMCc7XG5cbiAgICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICAgJzxwYXRoIGQ9XCJNICcgKyBzdGFydFggKyAnICcgKyBzdGFydFksXG4gICAgICAgICAgJyBBICcgKyB0aGlzLnJhZGl1cyArICcgJyArIHRoaXMucmFkaXVzLFxuICAgICAgICAgICcgMCAnLCArbGFyZ2VGbGFnICsgJyAxJywgJyAnICsgZW5kWCArICcgJyArIGVuZFksXG4gICAgICAgICAgJ1wiIHN0eWxlPVwiJywgdGhpcy5nZXRTdmdTdHlsZXMoKSxcbiAgICAgICAgICAnXCIgdHJhbnNmb3JtPVwiJywgdGhpcy5nZXRTdmdUcmFuc2Zvcm0oKSxcbiAgICAgICAgICAnICcsIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtTWF0cml4KCksXG4gICAgICAgICAgJ1wiLz5cXG4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXZpdmVyID8gcmV2aXZlcihtYXJrdXAuam9pbignJykpIDogbWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggY29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtub1RyYW5zZm9ybV0gV2hlbiB0cnVlLCBjb250ZXh0IGlzIG5vdCB0cmFuc2Zvcm1lZFxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCwgbm9UcmFuc2Zvcm0pIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5hcmMobm9UcmFuc2Zvcm0gPyB0aGlzLmxlZnQgKyB0aGlzLnJhZGl1cyA6IDAsXG4gICAgICAgICAgICAgIG5vVHJhbnNmb3JtID8gdGhpcy50b3AgKyB0aGlzLnJhZGl1cyA6IDAsXG4gICAgICAgICAgICAgIHRoaXMucmFkaXVzLFxuICAgICAgICAgICAgICB0aGlzLnN0YXJ0QW5nbGUsXG4gICAgICAgICAgICAgIHRoaXMuZW5kQW5nbGUsIGZhbHNlKTtcbiAgICAgIHRoaXMuX3JlbmRlckZpbGwoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclN0cm9rZShjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGhvcml6b250YWwgcmFkaXVzIG9mIGFuIG9iamVjdCAoYWNjb3JkaW5nIHRvIGhvdyBhbiBvYmplY3QgaXMgc2NhbGVkKVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRSYWRpdXNYOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncmFkaXVzJykgKiB0aGlzLmdldCgnc2NhbGVYJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdmVydGljYWwgcmFkaXVzIG9mIGFuIG9iamVjdCAoYWNjb3JkaW5nIHRvIGhvdyBhbiBvYmplY3QgaXMgc2NhbGVkKVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRSYWRpdXNZOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncmFkaXVzJykgKiB0aGlzLmdldCgnc2NhbGVZJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgcmFkaXVzIG9mIGFuIG9iamVjdCAoYW5kIHVwZGF0ZXMgd2lkdGggYWNjb3JkaW5nbHkpXG4gICAgICogQHJldHVybiB7ZmFicmljLkNpcmNsZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHNldFJhZGl1czogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHRoaXMucmFkaXVzID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoJ3dpZHRoJywgdmFsdWUgKiAyKS5zZXQoJ2hlaWdodCcsIHZhbHVlICogMik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29tcGxleGl0eSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gY29tcGxleGl0eSBvZiB0aGlzIGluc3RhbmNlXG4gICAgICovXG4gICAgY29tcGxleGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLkNpcmNsZS5mcm9tRWxlbWVudH0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5DaXJjbGVcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI0NpcmNsZUVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5DaXJjbGUuQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdCgnY3ggY3kgcicuc3BsaXQoJyAnKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5DaXJjbGV9IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkNpcmNsZVxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB2YWx1ZSBvZiBgcmAgYXR0cmlidXRlIGlzIG1pc3Npbmcgb3IgaW52YWxpZFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2lyY2xlfSBJbnN0YW5jZSBvZiBmYWJyaWMuQ2lyY2xlXG4gICAqL1xuICBmYWJyaWMuQ2lyY2xlLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5DaXJjbGUuQVRUUklCVVRFX05BTUVTKTtcblxuICAgIGlmICghaXNWYWxpZFJhZGl1cyhwYXJzZWRBdHRyaWJ1dGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YWx1ZSBvZiBgcmAgYXR0cmlidXRlIGlzIHJlcXVpcmVkIGFuZCBjYW4gbm90IGJlIG5lZ2F0aXZlJyk7XG4gICAgfVxuXG4gICAgcGFyc2VkQXR0cmlidXRlcy5sZWZ0ID0gcGFyc2VkQXR0cmlidXRlcy5sZWZ0IHx8IDA7XG4gICAgcGFyc2VkQXR0cmlidXRlcy50b3AgPSBwYXJzZWRBdHRyaWJ1dGVzLnRvcCB8fCAwO1xuXG4gICAgdmFyIG9iaiA9IG5ldyBmYWJyaWMuQ2lyY2xlKGV4dGVuZChwYXJzZWRBdHRyaWJ1dGVzLCBvcHRpb25zKSk7XG5cbiAgICBvYmoubGVmdCAtPSBvYmoucmFkaXVzO1xuICAgIG9iai50b3AgLT0gb2JqLnJhZGl1cztcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNWYWxpZFJhZGl1cyhhdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuICgoJ3JhZGl1cycgaW4gYXR0cmlidXRlcykgJiYgKGF0dHJpYnV0ZXMucmFkaXVzID49IDApKTtcbiAgfVxuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuQ2lyY2xlfSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ2lyY2xlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gaW52b2tlZCB3aXRoIG5ldyBpbnN0YW5jZSBhcyBmaXJzdCBhcmd1bWVudFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZUFzeW5jXSBGb3JjZSBhbiBhc3luYyBiZWhhdmlvdXIgdHJ5aW5nIHRvIGNyZWF0ZSBwYXR0ZXJuIGZpcnN0XG4gICAqIEByZXR1cm4ge09iamVjdH0gSW5zdGFuY2Ugb2YgZmFicmljLkNpcmNsZVxuICAgKi9cbiAgZmFicmljLkNpcmNsZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaywgZm9yY2VBc3luYykge1xuICAgIHJldHVybiBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdDaXJjbGUnLCBvYmplY3QsIGNhbGxiYWNrLCBmb3JjZUFzeW5jKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGlmIChmYWJyaWMuVHJpYW5nbGUpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlRyaWFuZ2xlIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlhbmdsZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlRyaWFuZ2xlXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLlRyaWFuZ2xlfSB0aGlzQXJnXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5UcmlhbmdsZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlRyaWFuZ2xlID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuVHJpYW5nbGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAndHJpYW5nbGUnLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuc2V0KCd3aWR0aCcsIG9wdGlvbnMgJiYgb3B0aW9ucy53aWR0aCB8fCAxMDApXG4gICAgICAgICAgLnNldCgnaGVpZ2h0Jywgb3B0aW9ucyAmJiBvcHRpb25zLmhlaWdodCB8fCAxMDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciB3aWR0aEJ5MiA9IHRoaXMud2lkdGggLyAyLFxuICAgICAgICAgIGhlaWdodEJ5MiA9IHRoaXMuaGVpZ2h0IC8gMjtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbygtd2lkdGhCeTIsIGhlaWdodEJ5Mik7XG4gICAgICBjdHgubGluZVRvKDAsIC1oZWlnaHRCeTIpO1xuICAgICAgY3R4LmxpbmVUbyh3aWR0aEJ5MiwgaGVpZ2h0QnkyKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgICAgdGhpcy5fcmVuZGVyRmlsbChjdHgpO1xuICAgICAgdGhpcy5fcmVuZGVyU3Ryb2tlKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJEYXNoZWRTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHdpZHRoQnkyID0gdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgaGVpZ2h0QnkyID0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIC13aWR0aEJ5MiwgaGVpZ2h0QnkyLCAwLCAtaGVpZ2h0QnkyLCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIDAsIC1oZWlnaHRCeTIsIHdpZHRoQnkyLCBoZWlnaHRCeTIsIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgd2lkdGhCeTIsIGhlaWdodEJ5MiwgLXdpZHRoQnkyLCBoZWlnaHRCeTIsIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIG1hcmt1cCA9IHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAoKSxcbiAgICAgICAgICB3aWR0aEJ5MiA9IHRoaXMud2lkdGggLyAyLFxuICAgICAgICAgIGhlaWdodEJ5MiA9IHRoaXMuaGVpZ2h0IC8gMixcbiAgICAgICAgICBwb2ludHMgPSBbXG4gICAgICAgICAgICAtd2lkdGhCeTIgKyAnICcgKyBoZWlnaHRCeTIsXG4gICAgICAgICAgICAnMCAnICsgLWhlaWdodEJ5MixcbiAgICAgICAgICAgIHdpZHRoQnkyICsgJyAnICsgaGVpZ2h0QnkyXG4gICAgICAgICAgXVxuICAgICAgICAgIC5qb2luKCcsJyk7XG5cbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPHBvbHlnb24gJywgdGhpcy5nZXRTdmdJZCgpLFxuICAgICAgICAgICdwb2ludHM9XCInLCBwb2ludHMsXG4gICAgICAgICAgJ1wiIHN0eWxlPVwiJywgdGhpcy5nZXRTdmdTdHlsZXMoKSxcbiAgICAgICAgICAnXCIgdHJhbnNmb3JtPVwiJywgdGhpcy5nZXRTdmdUcmFuc2Zvcm0oKSxcbiAgICAgICAgJ1wiLz4nXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcmV2aXZlciA/IHJldml2ZXIobWFya3VwLmpvaW4oJycpKSA6IG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb21wbGV4aXR5IG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBjb21wbGV4aXR5IG9mIHRoaXMgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb21wbGV4aXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5UcmlhbmdsZX0gaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlRyaWFuZ2xlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gaW52b2tlZCB3aXRoIG5ldyBpbnN0YW5jZSBhcyBmaXJzdCBhcmd1bWVudFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZUFzeW5jXSBGb3JjZSBhbiBhc3luYyBiZWhhdmlvdXIgdHJ5aW5nIHRvIGNyZWF0ZSBwYXR0ZXJuIGZpcnN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5UcmlhbmdsZX1cbiAgICovXG4gIGZhYnJpYy5UcmlhbmdsZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaywgZm9yY2VBc3luYykge1xuICAgIHJldHVybiBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdUcmlhbmdsZScsIG9iamVjdCwgY2FsbGJhY2ssIGZvcmNlQXN5bmMpO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBwaUJ5MiAgID0gTWF0aC5QSSAqIDIsXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kO1xuXG4gIGlmIChmYWJyaWMuRWxsaXBzZSkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuRWxsaXBzZSBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNhY2hlUHJvcGVydGllcyA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoKTtcbiAgY2FjaGVQcm9wZXJ0aWVzLnB1c2goXG4gICAgJ3J4JyxcbiAgICAncnknXG4gICk7XG5cbiAgLyoqXG4gICAqIEVsbGlwc2UgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5FbGxpcHNlXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLkVsbGlwc2V9IHRoaXNBcmdcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkVsbGlwc2UjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5FbGxpcHNlID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuRWxsaXBzZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdlbGxpcHNlJyxcblxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWwgcmFkaXVzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByeDogICAwLFxuXG4gICAgLyoqXG4gICAgICogVmVydGljYWwgcmFkaXVzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByeTogICAwLFxuXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBjYWNoZVByb3BlcnRpZXMsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuRWxsaXBzZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnNldCgncngnLCBvcHRpb25zICYmIG9wdGlvbnMucnggfHwgMCk7XG4gICAgICB0aGlzLnNldCgncnknLCBvcHRpb25zICYmIG9wdGlvbnMucnkgfHwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuRWxsaXBzZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0Jywga2V5LCB2YWx1ZSk7XG4gICAgICBzd2l0Y2ggKGtleSkge1xuXG4gICAgICAgIGNhc2UgJ3J4JzpcbiAgICAgICAgICB0aGlzLnJ4ID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5zZXQoJ3dpZHRoJywgdmFsdWUgKiAyKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyeSc6XG4gICAgICAgICAgdGhpcy5yeSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuc2V0KCdoZWlnaHQnLCB2YWx1ZSAqIDIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBob3Jpem9udGFsIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFjY29yZGluZyB0byBob3cgYW4gb2JqZWN0IGlzIHNjYWxlZClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Ung6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdyeCcpICogdGhpcy5nZXQoJ3NjYWxlWCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFZlcnRpY2FsIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFjY29yZGluZyB0byBob3cgYW4gb2JqZWN0IGlzIHNjYWxlZClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Unk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdyeScpICogdGhpcy5nZXQoJ3NjYWxlWScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JywgWydyeCcsICdyeSddLmNvbmNhdChwcm9wZXJ0aWVzVG9JbmNsdWRlKSk7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHZhciBtYXJrdXAgPSB0aGlzLl9jcmVhdGVCYXNlU1ZHTWFya3VwKCksIHggPSAwLCB5ID0gMDtcbiAgICAgIGlmICh0aGlzLmdyb3VwICYmIHRoaXMuZ3JvdXAudHlwZSA9PT0gJ3BhdGgtZ3JvdXAnKSB7XG4gICAgICAgIHggPSB0aGlzLmxlZnQgKyB0aGlzLnJ4O1xuICAgICAgICB5ID0gdGhpcy50b3AgKyB0aGlzLnJ5O1xuICAgICAgfVxuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICc8ZWxsaXBzZSAnLCB0aGlzLmdldFN2Z0lkKCksXG4gICAgICAgICAgJ2N4PVwiJywgeCwgJ1wiIGN5PVwiJywgeSwgJ1wiICcsXG4gICAgICAgICAgJ3J4PVwiJywgdGhpcy5yeCxcbiAgICAgICAgICAnXCIgcnk9XCInLCB0aGlzLnJ5LFxuICAgICAgICAgICdcIiBzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKCksXG4gICAgICAgICAgJ1wiIHRyYW5zZm9ybT1cIicsIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtKCksXG4gICAgICAgICAgdGhpcy5nZXRTdmdUcmFuc2Zvcm1NYXRyaXgoKSxcbiAgICAgICAgJ1wiLz5cXG4nXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcmV2aXZlciA/IHJldml2ZXIobWFya3VwLmpvaW4oJycpKSA6IG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbbm9UcmFuc2Zvcm1dIFdoZW4gdHJ1ZSwgY29udGV4dCBpcyBub3QgdHJhbnNmb3JtZWRcbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgsIG5vVHJhbnNmb3JtKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSgxLCAwLCAwLCB0aGlzLnJ5IC8gdGhpcy5yeCwgMCwgMCk7XG4gICAgICBjdHguYXJjKFxuICAgICAgICBub1RyYW5zZm9ybSA/IHRoaXMubGVmdCArIHRoaXMucnggOiAwLFxuICAgICAgICBub1RyYW5zZm9ybSA/ICh0aGlzLnRvcCArIHRoaXMucnkpICogdGhpcy5yeCAvIHRoaXMucnkgOiAwLFxuICAgICAgICB0aGlzLnJ4LFxuICAgICAgICAwLFxuICAgICAgICBwaUJ5MixcbiAgICAgICAgZmFsc2UpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuX3JlbmRlckZpbGwoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclN0cm9rZShjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbXBsZXhpdHkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHlcbiAgICAgKi9cbiAgICBjb21wbGV4aXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuRWxsaXBzZS5mcm9tRWxlbWVudH0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5FbGxpcHNlXG4gICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI0VsbGlwc2VFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuRWxsaXBzZS5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCdjeCBjeSByeCByeScuc3BsaXQoJyAnKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5FbGxpcHNlfSBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5FbGxpcHNlXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLkVsbGlwc2V9XG4gICAqL1xuICBmYWJyaWMuRWxsaXBzZS5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuRWxsaXBzZS5BVFRSSUJVVEVfTkFNRVMpO1xuXG4gICAgcGFyc2VkQXR0cmlidXRlcy5sZWZ0ID0gcGFyc2VkQXR0cmlidXRlcy5sZWZ0IHx8IDA7XG4gICAgcGFyc2VkQXR0cmlidXRlcy50b3AgPSBwYXJzZWRBdHRyaWJ1dGVzLnRvcCB8fCAwO1xuXG4gICAgdmFyIGVsbGlwc2UgPSBuZXcgZmFicmljLkVsbGlwc2UoZXh0ZW5kKHBhcnNlZEF0dHJpYnV0ZXMsIG9wdGlvbnMpKTtcblxuICAgIGVsbGlwc2UudG9wIC09IGVsbGlwc2Uucnk7XG4gICAgZWxsaXBzZS5sZWZ0IC09IGVsbGlwc2Uucng7XG4gICAgcmV0dXJuIGVsbGlwc2U7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5FbGxpcHNlfSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuRWxsaXBzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGludm9rZWQgd2l0aCBuZXcgaW5zdGFuY2UgYXMgZmlyc3QgYXJndW1lbnRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VBc3luY10gRm9yY2UgYW4gYXN5bmMgYmVoYXZpb3VyIHRyeWluZyB0byBjcmVhdGUgcGF0dGVybiBmaXJzdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuRWxsaXBzZX1cbiAgICovXG4gIGZhYnJpYy5FbGxpcHNlLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrLCBmb3JjZUFzeW5jKSB7XG4gICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ0VsbGlwc2UnLCBvYmplY3QsIGNhbGxiYWNrLCBmb3JjZUFzeW5jKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZDtcblxuICBpZiAoZmFicmljLlJlY3QpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlJlY3QgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHN0YXRlUHJvcGVydGllcyA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnN0YXRlUHJvcGVydGllcy5jb25jYXQoKTtcbiAgc3RhdGVQcm9wZXJ0aWVzLnB1c2goJ3J4JywgJ3J5Jyk7XG5cbiAgLyoqXG4gICAqIFJlY3RhbmdsZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlJlY3RcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuUmVjdH0gdGhpc0FyZ1xuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuUmVjdCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlJlY3QgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5SZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZiBzdGF0ZSBvZiBhbiBvYmplY3QgaXMgY2hhbmdlZCAoe0BsaW5rIGZhYnJpYy5PYmplY3QjaGFzU3RhdGVDaGFuZ2VkfSlcbiAgICAgKiBhcyB3ZWxsIGFzIGZvciBoaXN0b3J5ICh1bmRvL3JlZG8pIHB1cnBvc2VzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBzdGF0ZVByb3BlcnRpZXM6IHN0YXRlUHJvcGVydGllcyxcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAncmVjdCcsXG5cbiAgICAvKipcbiAgICAgKiBIb3Jpem9udGFsIGJvcmRlciByYWRpdXNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJ4OiAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbCBib3JkZXIgcmFkaXVzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByeTogICAwLFxuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBzcGVjaWZ5IGRhc2ggcGF0dGVybiBmb3Igc3Ryb2tlIG9uIHRoaXMgb2JqZWN0XG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBzdHJva2VEYXNoQXJyYXk6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5faW5pdFJ4UnkoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgcngvcnkgYXR0cmlidXRlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRSeFJ5OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnJ4ICYmICF0aGlzLnJ5KSB7XG4gICAgICAgIHRoaXMucnkgPSB0aGlzLnJ4O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5yeSAmJiAhdGhpcy5yeCkge1xuICAgICAgICB0aGlzLnJ4ID0gdGhpcy5yeTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBub1RyYW5zZm9ybVxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCwgbm9UcmFuc2Zvcm0pIHtcblxuICAgICAgLy8gb3B0aW1pemUgMXgxIGNhc2UgKHVzZWQgaW4gc3ByYXkgYnJ1c2gpXG4gICAgICBpZiAodGhpcy53aWR0aCA9PT0gMSAmJiB0aGlzLmhlaWdodCA9PT0gMSkge1xuICAgICAgICBjdHguZmlsbFJlY3QoLTAuNSwgLTAuNSwgMSwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJ4ID0gdGhpcy5yeCA/IE1hdGgubWluKHRoaXMucngsIHRoaXMud2lkdGggLyAyKSA6IDAsXG4gICAgICAgICAgcnkgPSB0aGlzLnJ5ID8gTWF0aC5taW4odGhpcy5yeSwgdGhpcy5oZWlnaHQgLyAyKSA6IDAsXG4gICAgICAgICAgdyA9IHRoaXMud2lkdGgsXG4gICAgICAgICAgaCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgIHggPSBub1RyYW5zZm9ybSA/IHRoaXMubGVmdCA6IC10aGlzLndpZHRoIC8gMixcbiAgICAgICAgICB5ID0gbm9UcmFuc2Zvcm0gPyB0aGlzLnRvcCA6IC10aGlzLmhlaWdodCAvIDIsXG4gICAgICAgICAgaXNSb3VuZGVkID0gcnggIT09IDAgfHwgcnkgIT09IDAsXG4gICAgICAgICAgLyogXCJtYWdpYyBudW1iZXJcIiBmb3IgYmV6aWVyIGFwcHJveGltYXRpb25zIG9mIGFyY3MgKGh0dHA6Ly9pdGMua3R1Lmx0L2l0YzM1NC9SaXNrdXMzNTQucGRmKSAqL1xuICAgICAgICAgIGsgPSAxIC0gMC41NTIyODQ3NDk4O1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICBjdHgubW92ZVRvKHggKyByeCwgeSk7XG5cbiAgICAgIGN0eC5saW5lVG8oeCArIHcgLSByeCwgeSk7XG4gICAgICBpc1JvdW5kZWQgJiYgY3R4LmJlemllckN1cnZlVG8oeCArIHcgLSBrICogcngsIHksIHggKyB3LCB5ICsgayAqIHJ5LCB4ICsgdywgeSArIHJ5KTtcblxuICAgICAgY3R4LmxpbmVUbyh4ICsgdywgeSArIGggLSByeSk7XG4gICAgICBpc1JvdW5kZWQgJiYgY3R4LmJlemllckN1cnZlVG8oeCArIHcsIHkgKyBoIC0gayAqIHJ5LCB4ICsgdyAtIGsgKiByeCwgeSArIGgsIHggKyB3IC0gcngsIHkgKyBoKTtcblxuICAgICAgY3R4LmxpbmVUbyh4ICsgcngsIHkgKyBoKTtcbiAgICAgIGlzUm91bmRlZCAmJiBjdHguYmV6aWVyQ3VydmVUbyh4ICsgayAqIHJ4LCB5ICsgaCwgeCwgeSArIGggLSBrICogcnksIHgsIHkgKyBoIC0gcnkpO1xuXG4gICAgICBjdHgubGluZVRvKHgsIHkgKyByeSk7XG4gICAgICBpc1JvdW5kZWQgJiYgY3R4LmJlemllckN1cnZlVG8oeCwgeSArIGsgKiByeSwgeCArIGsgKiByeCwgeSwgeCArIHJ4LCB5KTtcblxuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICB0aGlzLl9yZW5kZXJGaWxsKGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJTdHJva2UoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckRhc2hlZFN0cm9rZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgeCA9IC10aGlzLndpZHRoIC8gMixcbiAgICAgICAgICB5ID0gLXRoaXMuaGVpZ2h0IC8gMixcbiAgICAgICAgICB3ID0gdGhpcy53aWR0aCxcbiAgICAgICAgICBoID0gdGhpcy5oZWlnaHQ7XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgeCwgeSwgeCArIHcsIHksIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgeCArIHcsIHksIHggKyB3LCB5ICsgaCwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCB4ICsgdywgeSArIGgsIHgsIHkgKyBoLCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHgsIHkgKyBoLCB4LCB5LCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBbJ3J4JywgJ3J5J10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIG1hcmt1cCA9IHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAoKSwgeCA9IHRoaXMubGVmdCwgeSA9IHRoaXMudG9wO1xuICAgICAgaWYgKCEodGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLnR5cGUgPT09ICdwYXRoLWdyb3VwJykpIHtcbiAgICAgICAgeCA9IC10aGlzLndpZHRoIC8gMjtcbiAgICAgICAgeSA9IC10aGlzLmhlaWdodCAvIDI7XG4gICAgICB9XG4gICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgJzxyZWN0ICcsIHRoaXMuZ2V0U3ZnSWQoKSxcbiAgICAgICAgICAneD1cIicsIHgsICdcIiB5PVwiJywgeSxcbiAgICAgICAgICAnXCIgcng9XCInLCB0aGlzLmdldCgncngnKSwgJ1wiIHJ5PVwiJywgdGhpcy5nZXQoJ3J5JyksXG4gICAgICAgICAgJ1wiIHdpZHRoPVwiJywgdGhpcy53aWR0aCwgJ1wiIGhlaWdodD1cIicsIHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICdcIiBzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKCksXG4gICAgICAgICAgJ1wiIHRyYW5zZm9ybT1cIicsIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtKCksXG4gICAgICAgICAgdGhpcy5nZXRTdmdUcmFuc2Zvcm1NYXRyaXgoKSxcbiAgICAgICAgJ1wiLz5cXG4nKTtcblxuICAgICAgcmV0dXJuIHJldml2ZXIgPyByZXZpdmVyKG1hcmt1cC5qb2luKCcnKSkgOiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29tcGxleGl0eSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gY29tcGxleGl0eVxuICAgICAqL1xuICAgIGNvbXBsZXhpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkgYGZhYnJpYy5SZWN0LmZyb21FbGVtZW50YClcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlJlY3RcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI1JlY3RFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuUmVjdC5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCd4IHkgcnggcnkgd2lkdGggaGVpZ2h0Jy5zcGxpdCgnICcpKTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLlJlY3R9IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlJlY3RcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuUmVjdH0gSW5zdGFuY2Ugb2YgZmFicmljLlJlY3RcbiAgICovXG4gIGZhYnJpYy5SZWN0LmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgfTtcblxuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuUmVjdC5BVFRSSUJVVEVfTkFNRVMpO1xuXG4gICAgcGFyc2VkQXR0cmlidXRlcy5sZWZ0ID0gcGFyc2VkQXR0cmlidXRlcy5sZWZ0IHx8IDA7XG4gICAgcGFyc2VkQXR0cmlidXRlcy50b3AgID0gcGFyc2VkQXR0cmlidXRlcy50b3AgIHx8IDA7XG4gICAgdmFyIHJlY3QgPSBuZXcgZmFicmljLlJlY3QoZXh0ZW5kKChvcHRpb25zID8gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKG9wdGlvbnMpIDogeyB9KSwgcGFyc2VkQXR0cmlidXRlcykpO1xuICAgIHJlY3QudmlzaWJsZSA9IHJlY3QudmlzaWJsZSAmJiByZWN0LndpZHRoID4gMCAmJiByZWN0LmhlaWdodCA+IDA7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5SZWN0fSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUmVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGZhYnJpYy5SZWN0IGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VBc3luY10gRm9yY2UgYW4gYXN5bmMgYmVoYXZpb3VyIHRyeWluZyB0byBjcmVhdGUgcGF0dGVybiBmaXJzdFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGluc3RhbmNlIG9mIGZhYnJpYy5SZWN0XG4gICAqL1xuICBmYWJyaWMuUmVjdC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaywgZm9yY2VBc3luYykge1xuICAgIHJldHVybiBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdSZWN0Jywgb2JqZWN0LCBjYWxsYmFjaywgZm9yY2VBc3luYyk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KTtcblxuICBpZiAoZmFicmljLlBvbHlsaW5lKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5Qb2x5bGluZSBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY2FjaGVQcm9wZXJ0aWVzID0gZmFicmljLk9iamVjdC5wcm90b3R5cGUuY2FjaGVQcm9wZXJ0aWVzLmNvbmNhdCgpO1xuICBjYWNoZVByb3BlcnRpZXMucHVzaCgncG9pbnRzJyk7XG5cbiAgLyoqXG4gICAqIFBvbHlsaW5lIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUG9seWxpbmVcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuUG9seWxpbmUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5Qb2x5bGluZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLlBvbHlsaW5lLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3BvbHlsaW5lJyxcblxuICAgIC8qKlxuICAgICAqIFBvaW50cyBhcnJheVxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwb2ludHM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIFggZnJvbSBwb2ludHMgdmFsdWVzLCBuZWNlc3NhcnkgdG8gb2Zmc2V0IHBvaW50c1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWluWDogMCxcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gWSBmcm9tIHBvaW50cyB2YWx1ZXMsIG5lY2Vzc2FyeSB0byBvZmZzZXQgcG9pbnRzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtaW5ZOiAwLFxuXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBjYWNoZVByb3BlcnRpZXMsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyBBcnJheSBvZiBwb2ludHMgKHdoZXJlIGVhY2ggcG9pbnQgaXMgYW4gb2JqZWN0IHdpdGggeCBhbmQgeSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvbHlsaW5lfSB0aGlzQXJnXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcG9seSA9IG5ldyBmYWJyaWMuUG9seWxpbmUoW1xuICAgICAqICAgICB7IHg6IDEwLCB5OiAxMCB9LFxuICAgICAqICAgICB7IHg6IDUwLCB5OiAzMCB9LFxuICAgICAqICAgICB7IHg6IDQwLCB5OiA3MCB9LFxuICAgICAqICAgICB7IHg6IDYwLCB5OiA1MCB9LFxuICAgICAqICAgICB7IHg6IDEwMCwgeTogMTUwIH0sXG4gICAgICogICAgIHsgeDogNDAsIHk6IDEwMCB9XG4gICAgICogICBdLCB7XG4gICAgICogICBzdHJva2U6ICdyZWQnLFxuICAgICAqICAgbGVmdDogMTAwLFxuICAgICAqICAgdG9wOiAxMDBcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihwb2ludHMsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBmYWJyaWMuUG9seWdvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHBvaW50cywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGNEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWJyaWMuUG9seWdvbi5wcm90b3R5cGUuX2NhbGNEaW1lbnNpb25zLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiBmYWJyaWMuUG9seWdvbi5wcm90b3R5cGUudG9PYmplY3QuY2FsbCh0aGlzLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgcmV0dXJuIGZhYnJpYy5Qb2x5Z29uLnByb3RvdHlwZS50b1NWRy5jYWxsKHRoaXMsIHJldml2ZXIpO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG5vVHJhbnNmb3JtXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4LCBub1RyYW5zZm9ybSkge1xuICAgICAgaWYgKCFmYWJyaWMuUG9seWdvbi5wcm90b3R5cGUuY29tbW9uUmVuZGVyLmNhbGwodGhpcywgY3R4LCBub1RyYW5zZm9ybSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyRmlsbChjdHgpO1xuICAgICAgdGhpcy5fcmVuZGVyU3Ryb2tlKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJEYXNoZWRTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHAxLCBwMjtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHAxID0gdGhpcy5wb2ludHNbaV07XG4gICAgICAgIHAyID0gdGhpcy5wb2ludHNbaSArIDFdIHx8IHAxO1xuICAgICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHAxLngsIHAxLnksIHAyLngsIHAyLnksIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb21wbGV4aXR5IG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBjb21wbGV4aXR5IG9mIHRoaXMgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb21wbGV4aXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncG9pbnRzJykubGVuZ3RoO1xuICAgIH1cbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuUG9seWxpbmUuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWxpbmVcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI1BvbHlsaW5lRWxlbWVudFxuICAgKi9cbiAgZmFicmljLlBvbHlsaW5lLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoKTtcblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuUG9seWxpbmUgaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWxpbmVcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9seWxpbmV9IEluc3RhbmNlIG9mIGZhYnJpYy5Qb2x5bGluZVxuICAgKi9cbiAgZmFicmljLlBvbHlsaW5lLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgdmFyIHBvaW50cyA9IGZhYnJpYy5wYXJzZVBvaW50c0F0dHJpYnV0ZShlbGVtZW50LmdldEF0dHJpYnV0ZSgncG9pbnRzJykpLFxuICAgICAgICBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuUG9seWxpbmUuQVRUUklCVVRFX05BTUVTKTtcblxuICAgIHJldHVybiBuZXcgZmFicmljLlBvbHlsaW5lKHBvaW50cywgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChwYXJzZWRBdHRyaWJ1dGVzLCBvcHRpb25zKSk7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLlBvbHlsaW5lIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Qb2x5bGluZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGZhYnJpYy5QYXRoIGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VBc3luY10gRm9yY2UgYW4gYXN5bmMgYmVoYXZpb3VyIHRyeWluZyB0byBjcmVhdGUgcGF0dGVybiBmaXJzdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9seWxpbmV9IEluc3RhbmNlIG9mIGZhYnJpYy5Qb2x5bGluZVxuICAgKi9cbiAgZmFicmljLlBvbHlsaW5lLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrLCBmb3JjZUFzeW5jKSB7XG4gICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1BvbHlsaW5lJywgb2JqZWN0LCBjYWxsYmFjaywgZm9yY2VBc3luYywgJ3BvaW50cycpO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgbWluID0gZmFicmljLnV0aWwuYXJyYXkubWluLFxuICAgICAgbWF4ID0gZmFicmljLnV0aWwuYXJyYXkubWF4LFxuICAgICAgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQ7XG5cbiAgaWYgKGZhYnJpYy5Qb2x5Z29uKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5Qb2x5Z29uIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjYWNoZVByb3BlcnRpZXMgPSBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KCk7XG4gIGNhY2hlUHJvcGVydGllcy5wdXNoKCdwb2ludHMnKTtcblxuICAvKipcbiAgICogUG9seWdvbiBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlBvbHlnb25cbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuUG9seWdvbiNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlBvbHlnb24gPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5Qb2x5Z29uLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3BvbHlnb24nLFxuXG4gICAgLyoqXG4gICAgICogUG9pbnRzIGFycmF5XG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBvaW50czogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gWCBmcm9tIHBvaW50cyB2YWx1ZXMsIG5lY2Vzc2FyeSB0byBvZmZzZXQgcG9pbnRzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtaW5YOiAwLFxuXG4gICAgLyoqXG4gICAgICogTWluaW11bSBZIGZyb20gcG9pbnRzIHZhbHVlcywgbmVjZXNzYXJ5IHRvIG9mZnNldCBwb2ludHNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1pblk6IDAsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGNhY2hlUHJvcGVydGllcyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIEFycmF5IG9mIHBvaW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9seWdvbn0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHBvaW50cywgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB0aGlzLnBvaW50cyA9IHBvaW50cyB8fCBbXTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9jYWxjRGltZW5zaW9ucygpO1xuICAgICAgaWYgKCEoJ3RvcCcgaW4gb3B0aW9ucykpIHtcbiAgICAgICAgdGhpcy50b3AgPSB0aGlzLm1pblk7XG4gICAgICB9XG4gICAgICBpZiAoISgnbGVmdCcgaW4gb3B0aW9ucykpIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0gdGhpcy5taW5YO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXRoT2Zmc2V0ID0ge1xuICAgICAgICB4OiB0aGlzLm1pblggKyB0aGlzLndpZHRoIC8gMixcbiAgICAgICAgeTogdGhpcy5taW5ZICsgdGhpcy5oZWlnaHQgLyAyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cyxcbiAgICAgICAgICBtaW5YID0gbWluKHBvaW50cywgJ3gnKSxcbiAgICAgICAgICBtaW5ZID0gbWluKHBvaW50cywgJ3knKSxcbiAgICAgICAgICBtYXhYID0gbWF4KHBvaW50cywgJ3gnKSxcbiAgICAgICAgICBtYXhZID0gbWF4KHBvaW50cywgJ3knKTtcblxuICAgICAgdGhpcy53aWR0aCA9IChtYXhYIC0gbWluWCkgfHwgMDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gKG1heFkgLSBtaW5ZKSB8fCAwO1xuICAgICAgdGhpcy5taW5YID0gbWluWCB8fCAwO1xuICAgICAgdGhpcy5taW5ZID0gbWluWSB8fCAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpLCB7XG4gICAgICAgIHBvaW50czogdGhpcy5wb2ludHMuY29uY2F0KClcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICB2YXIgcG9pbnRzID0gW10sIGFkZFRyYW5zZm9ybSxcbiAgICAgICAgICBtYXJrdXAgPSB0aGlzLl9jcmVhdGVCYXNlU1ZHTWFya3VwKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwb2ludHMucHVzaCh0b0ZpeGVkKHRoaXMucG9pbnRzW2ldLngsIDIpLCAnLCcsIHRvRml4ZWQodGhpcy5wb2ludHNbaV0ueSwgMiksICcgJyk7XG4gICAgICB9XG4gICAgICBpZiAoISh0aGlzLmdyb3VwICYmIHRoaXMuZ3JvdXAudHlwZSA9PT0gJ3BhdGgtZ3JvdXAnKSkge1xuICAgICAgICBhZGRUcmFuc2Zvcm0gPSAnIHRyYW5zbGF0ZSgnICsgKC10aGlzLnBhdGhPZmZzZXQueCkgKyAnLCAnICsgKC10aGlzLnBhdGhPZmZzZXQueSkgKyAnKSAnO1xuICAgICAgfVxuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICc8JywgdGhpcy50eXBlLCAnICcsIHRoaXMuZ2V0U3ZnSWQoKSxcbiAgICAgICAgICAncG9pbnRzPVwiJywgcG9pbnRzLmpvaW4oJycpLFxuICAgICAgICAgICdcIiBzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKCksXG4gICAgICAgICAgJ1wiIHRyYW5zZm9ybT1cIicsIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtKCksIGFkZFRyYW5zZm9ybSxcbiAgICAgICAgICAnICcsIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtTWF0cml4KCksXG4gICAgICAgICdcIi8+XFxuJ1xuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHJldml2ZXIgPyByZXZpdmVyKG1hcmt1cC5qb2luKCcnKSkgOiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbm9UcmFuc2Zvcm1cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgsIG5vVHJhbnNmb3JtKSB7XG4gICAgICBpZiAoIXRoaXMuY29tbW9uUmVuZGVyKGN0eCwgbm9UcmFuc2Zvcm0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlbmRlckZpbGwoY3R4KTtcbiAgICAgIGlmICh0aGlzLnN0cm9rZSB8fCB0aGlzLnN0cm9rZURhc2hBcnJheSkge1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIHRoaXMuX3JlbmRlclN0cm9rZShjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG5vVHJhbnNmb3JtXG4gICAgICovXG4gICAgY29tbW9uUmVuZGVyOiBmdW5jdGlvbihjdHgsIG5vVHJhbnNmb3JtKSB7XG4gICAgICB2YXIgcG9pbnQsIGxlbiA9IHRoaXMucG9pbnRzLmxlbmd0aCxcbiAgICAgICAgICB4ID0gbm9UcmFuc2Zvcm0gPyAwIDogdGhpcy5wYXRoT2Zmc2V0LngsXG4gICAgICAgICAgeSA9IG5vVHJhbnNmb3JtID8gMCA6IHRoaXMucGF0aE9mZnNldC55O1xuXG4gICAgICBpZiAoIWxlbiB8fCBpc05hTih0aGlzLnBvaW50c1tsZW4gLSAxXS55KSkge1xuICAgICAgICAvLyBkbyBub3QgZHJhdyBpZiBubyBwb2ludHMgb3Igb2RkIHBvaW50c1xuICAgICAgICAvLyBOYU4gY29tZXMgZnJvbSBwYXJzZUZsb2F0IG9mIGEgZW1wdHkgc3RyaW5nIGluIHBhcnNlclxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHRoaXMucG9pbnRzWzBdLnggLSB4LCB0aGlzLnBvaW50c1swXS55IC0geSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHBvaW50ID0gdGhpcy5wb2ludHNbaV07XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnQueCAtIHgsIHBvaW50LnkgLSB5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyRGFzaGVkU3Ryb2tlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGZhYnJpYy5Qb2x5bGluZS5wcm90b3R5cGUuX3JlbmRlckRhc2hlZFN0cm9rZS5jYWxsKHRoaXMsIGN0eCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29tcGxleGl0eSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gY29tcGxleGl0eSBvZiB0aGlzIGluc3RhbmNlXG4gICAgICovXG4gICAgY29tcGxleGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb2ludHMubGVuZ3RoO1xuICAgIH1cbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IGBmYWJyaWMuUG9seWdvbi5mcm9tRWxlbWVudGApXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Qb2x5Z29uXG4gICAqIEBzZWU6IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zaGFwZXMuaHRtbCNQb2x5Z29uRWxlbWVudFxuICAgKi9cbiAgZmFicmljLlBvbHlnb24uQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdCgpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuUG9seWdvbn0gaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWdvblxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2x5Z29ufSBJbnN0YW5jZSBvZiBmYWJyaWMuUG9seWdvblxuICAgKi9cbiAgZmFicmljLlBvbHlnb24uZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgIHZhciBwb2ludHMgPSBmYWJyaWMucGFyc2VQb2ludHNBdHRyaWJ1dGUoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3BvaW50cycpKSxcbiAgICAgICAgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLlBvbHlnb24uQVRUUklCVVRFX05BTUVTKTtcblxuICAgIHJldHVybiBuZXcgZmFicmljLlBvbHlnb24ocG9pbnRzLCBleHRlbmQocGFyc2VkQXR0cmlidXRlcywgb3B0aW9ucykpO1xuICB9O1xuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5Qb2x5Z29uIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Qb2x5Z29uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlBhdGggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZUFzeW5jXSBGb3JjZSBhbiBhc3luYyBiZWhhdmlvdXIgdHJ5aW5nIHRvIGNyZWF0ZSBwYXR0ZXJuIGZpcnN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2x5Z29ufSBJbnN0YW5jZSBvZiBmYWJyaWMuUG9seWdvblxuICAgKi9cbiAgZmFicmljLlBvbHlnb24uZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2ssIGZvcmNlQXN5bmMpIHtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnUG9seWdvbicsIG9iamVjdCwgY2FsbGJhY2ssIGZvcmNlQXN5bmMsICdwb2ludHMnKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgbWluID0gZmFicmljLnV0aWwuYXJyYXkubWluLFxuICAgICAgbWF4ID0gZmFicmljLnV0aWwuYXJyYXkubWF4LFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICBkcmF3QXJjID0gZmFicmljLnV0aWwuZHJhd0FyYyxcbiAgICAgIGNvbW1hbmRMZW5ndGhzID0ge1xuICAgICAgICBtOiAyLFxuICAgICAgICBsOiAyLFxuICAgICAgICBoOiAxLFxuICAgICAgICB2OiAxLFxuICAgICAgICBjOiA2LFxuICAgICAgICBzOiA0LFxuICAgICAgICBxOiA0LFxuICAgICAgICB0OiAyLFxuICAgICAgICBhOiA3XG4gICAgICB9LFxuICAgICAgcmVwZWF0ZWRDb21tYW5kcyA9IHtcbiAgICAgICAgbTogJ2wnLFxuICAgICAgICBNOiAnTCdcbiAgICAgIH07XG5cbiAgaWYgKGZhYnJpYy5QYXRoKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5QYXRoIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjYWNoZVByb3BlcnRpZXMgPSBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KCk7XG4gIGNhY2hlUHJvcGVydGllcy5wdXNoKCdwYXRoJyk7XG5cbiAgLyoqXG4gICAqIFBhdGggY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5QYXRoXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTEjcGF0aF9hbmRfcGF0aGdyb3VwfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuUGF0aCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlBhdGggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5QYXRoLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3BhdGgnLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgcGF0aCBwb2ludHNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGF0aDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gWCBmcm9tIHBvaW50cyB2YWx1ZXMsIG5lY2Vzc2FyeSB0byBvZmZzZXQgcG9pbnRzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtaW5YOiAwLFxuXG4gICAgLyoqXG4gICAgICogTWluaW11bSBZIGZyb20gcG9pbnRzIHZhbHVlcywgbmVjZXNzYXJ5IHRvIG9mZnNldCBwb2ludHNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1pblk6IDAsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGNhY2hlUHJvcGVydGllcyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IHBhdGggUGF0aCBkYXRhIChzZXF1ZW5jZSBvZiBjb29yZGluYXRlcyBhbmQgY29ycmVzcG9uZGluZyBcImNvbW1hbmRcIiB0b2tlbnMpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5QYXRofSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ocGF0aCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuXG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGF0aCkge1xuICAgICAgICBwYXRoID0gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBmcm9tQXJyYXkgPSBfdG9TdHJpbmcuY2FsbChwYXRoKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcblxuICAgICAgdGhpcy5wYXRoID0gZnJvbUFycmF5XG4gICAgICAgID8gcGF0aFxuICAgICAgICAvLyBvbmUgb2YgY29tbWFuZHMgKG0sTSxsLEwscSxRLGMsQyxldGMuKSBmb2xsb3dlZCBieSBub24tY29tbWFuZCBjaGFyYWN0ZXJzIChpLmUuIGNvbW1hbmQgdmFsdWVzKVxuICAgICAgICA6IHBhdGgubWF0Y2ggJiYgcGF0aC5tYXRjaCgvW216bGh2Y3NxdGFdW15temxodmNzcXRhXSovZ2kpO1xuXG4gICAgICBpZiAoIXRoaXMucGF0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghZnJvbUFycmF5KSB7XG4gICAgICAgIHRoaXMucGF0aCA9IHRoaXMuX3BhcnNlUGF0aCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXRQb3NpdGlvbkRpbWVuc2lvbnMob3B0aW9ucyk7XG5cbiAgICAgIGlmIChvcHRpb25zLnNvdXJjZVBhdGgpIHtcbiAgICAgICAgdGhpcy5zZXRTb3VyY2VQYXRoKG9wdGlvbnMuc291cmNlUGF0aCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vYmplY3RDYWNoaW5nKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUNhY2hlQ2FudmFzKCk7XG4gICAgICAgIHRoaXMuc2V0dXBTdGF0ZSh7IHByb3BlcnR5U2V0OiAnY2FjaGVQcm9wZXJ0aWVzJyB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIF9zZXRQb3NpdGlvbkRpbWVuc2lvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjYWxjRGltID0gdGhpcy5fcGFyc2VEaW1lbnNpb25zKCk7XG5cbiAgICAgIHRoaXMubWluWCA9IGNhbGNEaW0ubGVmdDtcbiAgICAgIHRoaXMubWluWSA9IGNhbGNEaW0udG9wO1xuICAgICAgdGhpcy53aWR0aCA9IGNhbGNEaW0ud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGNhbGNEaW0uaGVpZ2h0O1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMubGVmdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0gY2FsY0RpbS5sZWZ0ICsgKHRoaXMub3JpZ2luWCA9PT0gJ2NlbnRlcidcbiAgICAgICAgICA/IHRoaXMud2lkdGggLyAyXG4gICAgICAgICAgOiB0aGlzLm9yaWdpblggPT09ICdyaWdodCdcbiAgICAgICAgICAgID8gdGhpcy53aWR0aFxuICAgICAgICAgICAgOiAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRvcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy50b3AgPSBjYWxjRGltLnRvcCArICh0aGlzLm9yaWdpblkgPT09ICdjZW50ZXInXG4gICAgICAgICAgPyB0aGlzLmhlaWdodCAvIDJcbiAgICAgICAgICA6IHRoaXMub3JpZ2luWSA9PT0gJ2JvdHRvbSdcbiAgICAgICAgICAgID8gdGhpcy5oZWlnaHRcbiAgICAgICAgICAgIDogMCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGF0aE9mZnNldCA9IHRoaXMucGF0aE9mZnNldCB8fCB7XG4gICAgICAgIHg6IHRoaXMubWluWCArIHRoaXMud2lkdGggLyAyLFxuICAgICAgICB5OiB0aGlzLm1pblkgKyB0aGlzLmhlaWdodCAvIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBwYXRoIG9uXG4gICAgICovXG4gICAgX3JlbmRlclBhdGhDb21tYW5kczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgY3VycmVudCwgLy8gY3VycmVudCBpbnN0cnVjdGlvblxuICAgICAgICAgIHByZXZpb3VzID0gbnVsbCxcbiAgICAgICAgICBzdWJwYXRoU3RhcnRYID0gMCxcbiAgICAgICAgICBzdWJwYXRoU3RhcnRZID0gMCxcbiAgICAgICAgICB4ID0gMCwgLy8gY3VycmVudCB4XG4gICAgICAgICAgeSA9IDAsIC8vIGN1cnJlbnQgeVxuICAgICAgICAgIGNvbnRyb2xYID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHhcbiAgICAgICAgICBjb250cm9sWSA9IDAsIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB5XG4gICAgICAgICAgdGVtcFgsXG4gICAgICAgICAgdGVtcFksXG4gICAgICAgICAgbCA9IC10aGlzLnBhdGhPZmZzZXQueCxcbiAgICAgICAgICB0ID0gLXRoaXMucGF0aE9mZnNldC55O1xuXG4gICAgICBpZiAodGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLnR5cGUgPT09ICdwYXRoLWdyb3VwJykge1xuICAgICAgICBsID0gMDtcbiAgICAgICAgdCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMucGF0aC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXG4gICAgICAgIGN1cnJlbnQgPSB0aGlzLnBhdGhbaV07XG5cbiAgICAgICAgc3dpdGNoIChjdXJyZW50WzBdKSB7IC8vIGZpcnN0IGxldHRlclxuXG4gICAgICAgICAgY2FzZSAnbCc6IC8vIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgKz0gY3VycmVudFsyXTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnTCc6IC8vIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2gnOiAvLyBob3Jpem9udGFsIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnSCc6IC8vIGhvcml6b250YWwgbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3YnOiAvLyB2ZXJ0aWNhbCBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgICAgICB5ICs9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1YnOiAvLyB2ZXJpY2FsIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdtJzogLy8gbW92ZVRvLCByZWxhdGl2ZVxuICAgICAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgeSArPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgc3VicGF0aFN0YXJ0WCA9IHg7XG4gICAgICAgICAgICBzdWJwYXRoU3RhcnRZID0geTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnTSc6IC8vIG1vdmVUbywgYWJzb2x1dGVcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBzdWJwYXRoU3RhcnRYID0geDtcbiAgICAgICAgICAgIHN1YnBhdGhTdGFydFkgPSB5O1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdjJzogLy8gYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbNV07XG4gICAgICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzZdO1xuICAgICAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbNF07XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgeCArIGN1cnJlbnRbMV0gKyBsLCAvLyB4MVxuICAgICAgICAgICAgICB5ICsgY3VycmVudFsyXSArIHQsIC8vIHkxXG4gICAgICAgICAgICAgIGNvbnRyb2xYICsgbCwgLy8geDJcbiAgICAgICAgICAgICAgY29udHJvbFkgKyB0LCAvLyB5MlxuICAgICAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQyc6IC8vIGJlemllckN1cnZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFs1XTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzZdO1xuICAgICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzNdO1xuICAgICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzRdO1xuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0gKyBsLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdICsgdCxcbiAgICAgICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgICAgIHggKyBsLFxuICAgICAgICAgICAgICB5ICsgdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncyc6IC8vIHNob3J0aGFuZCBjdWJpYyBiZXppZXJDdXJ2ZVRvLCByZWxhdGl2ZVxuXG4gICAgICAgICAgICAvLyB0cmFuc2Zvcm0gdG8gYWJzb2x1dGUgeCx5XG4gICAgICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzNdO1xuICAgICAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs0XTtcblxuICAgICAgICAgICAgaWYgKHByZXZpb3VzWzBdLm1hdGNoKC9bQ2NTc10vKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBwcmV2aW91cyBjb21tYW5kIG9yIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIHdhcyBub3QgYSBDLCBjLCBTLCBvciBzLFxuICAgICAgICAgICAgICAvLyB0aGUgY29udHJvbCBwb2ludCBpcyBjb2luY2lkZW50IHdpdGggdGhlIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgICAgICAgY29udHJvbFggPSB4O1xuICAgICAgICAgICAgICBjb250cm9sWSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHNcbiAgICAgICAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgICAgIGNvbnRyb2xZICsgdCxcbiAgICAgICAgICAgICAgeCArIGN1cnJlbnRbMV0gKyBsLFxuICAgICAgICAgICAgICB5ICsgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy8gc2V0IGNvbnRyb2wgcG9pbnQgdG8gMm5kIG9uZSBvZiB0aGlzIGNvbW1hbmRcbiAgICAgICAgICAgIC8vIFwiLi4uIHRoZSBmaXJzdCBjb250cm9sIHBvaW50IGlzIGFzc3VtZWQgdG8gYmVcbiAgICAgICAgICAgIC8vIHRoZSByZWZsZWN0aW9uIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludCBvblxuICAgICAgICAgICAgLy8gdGhlIHByZXZpb3VzIGNvbW1hbmQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXCJcbiAgICAgICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzJdO1xuXG4gICAgICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1MnOiAvLyBzaG9ydGhhbmQgY3ViaWMgYmV6aWVyQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgICAgIHRlbXBYID0gY3VycmVudFszXTtcbiAgICAgICAgICAgIHRlbXBZID0gY3VycmVudFs0XTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c1swXS5tYXRjaCgvW0NjU3NdLykgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgY29tbWFuZCBvciBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCB3YXMgbm90IGEgQywgYywgUywgb3IgcyxcbiAgICAgICAgICAgICAgLy8gdGhlIGNvbnRyb2wgcG9pbnQgaXMgY29pbmNpZGVudCB3aXRoIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgICAgICAgIGNvbnRyb2xYID0geDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgICAgICBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICAgICAgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICAgICAgeSA9IHRlbXBZO1xuXG4gICAgICAgICAgICAvLyBzZXQgY29udHJvbCBwb2ludCB0byAybmQgb25lIG9mIHRoaXMgY29tbWFuZFxuICAgICAgICAgICAgLy8gXCIuLi4gdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgaXMgYXNzdW1lZCB0byBiZVxuICAgICAgICAgICAgLy8gdGhlIHJlZmxlY3Rpb24gb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50IG9uXG4gICAgICAgICAgICAvLyB0aGUgcHJldmlvdXMgY29tbWFuZCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb2ludC5cIlxuICAgICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNF07XG5cbiAgICAgICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzJdO1xuXG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdRJzogLy8gcXVhZHJhdGljQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgICAgIHRlbXBYID0gY3VycmVudFszXTtcbiAgICAgICAgICAgIHRlbXBZID0gY3VycmVudFs0XTtcblxuICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0gKyBsLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdICsgdCxcbiAgICAgICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3QnOiAvLyBzaG9ydGhhbmQgcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcblxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbMl07XG5cbiAgICAgICAgICAgIGlmIChwcmV2aW91c1swXS5tYXRjaCgvW1FxVHRdLykgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgY29tbWFuZCBvciBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCB3YXMgbm90IGEgUSwgcSwgVCBvciB0LFxuICAgICAgICAgICAgICAvLyBhc3N1bWUgdGhlIGNvbnRyb2wgcG9pbnQgaXMgY29pbmNpZGVudCB3aXRoIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgICAgICAgIGNvbnRyb2xYID0geDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRcbiAgICAgICAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgICAgIGNvbnRyb2xZICsgdCxcbiAgICAgICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgICAgICB5ID0gdGVtcFk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbMl07XG5cbiAgICAgICAgICAgIGlmIChwcmV2aW91c1swXS5tYXRjaCgvW1FxVHRdLykgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgY29tbWFuZCBvciBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCB3YXMgbm90IGEgUSwgcSwgVCBvciB0LFxuICAgICAgICAgICAgICAvLyBhc3N1bWUgdGhlIGNvbnRyb2wgcG9pbnQgaXMgY29pbmNpZGVudCB3aXRoIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgICAgICAgIGNvbnRyb2xYID0geDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRcbiAgICAgICAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgIC8vIFRPRE86IG9wdGltaXplIHRoaXNcbiAgICAgICAgICAgIGRyYXdBcmMoY3R4LCB4ICsgbCwgeSArIHQsIFtcbiAgICAgICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICAgICAgY3VycmVudFs0XSxcbiAgICAgICAgICAgICAgY3VycmVudFs1XSxcbiAgICAgICAgICAgICAgY3VycmVudFs2XSArIHggKyBsLFxuICAgICAgICAgICAgICBjdXJyZW50WzddICsgeSArIHRcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgeCArPSBjdXJyZW50WzZdO1xuICAgICAgICAgICAgeSArPSBjdXJyZW50WzddO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgIC8vIFRPRE86IG9wdGltaXplIHRoaXNcbiAgICAgICAgICAgIGRyYXdBcmMoY3R4LCB4ICsgbCwgeSArIHQsIFtcbiAgICAgICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICAgICAgY3VycmVudFs0XSxcbiAgICAgICAgICAgICAgY3VycmVudFs1XSxcbiAgICAgICAgICAgICAgY3VycmVudFs2XSArIGwsXG4gICAgICAgICAgICAgIGN1cnJlbnRbN10gKyB0XG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzZdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbN107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgeCA9IHN1YnBhdGhTdGFydFg7XG4gICAgICAgICAgICB5ID0gc3VicGF0aFN0YXJ0WTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIHBhdGggb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuX3JlbmRlclBhdGhDb21tYW5kcyhjdHgpO1xuICAgICAgdGhpcy5fcmVuZGVyRmlsbChjdHgpO1xuICAgICAgdGhpcy5fcmVuZGVyU3Ryb2tlKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJyM8ZmFicmljLlBhdGggKCcgKyB0aGlzLmNvbXBsZXhpdHkoKSArXG4gICAgICAgICcpOiB7IFwidG9wXCI6ICcgKyB0aGlzLnRvcCArICcsIFwibGVmdFwiOiAnICsgdGhpcy5sZWZ0ICsgJyB9Pic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBvID0gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIFsnc291cmNlUGF0aCcsICdwYXRoT2Zmc2V0J10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpKSwge1xuICAgICAgICBwYXRoOiB0aGlzLnBhdGgubWFwKGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uc2xpY2UoKTsgfSlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG87XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGF0YWxlc3Mgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9EYXRhbGVzc09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG8gPSB0aGlzLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgaWYgKHRoaXMuc291cmNlUGF0aCkge1xuICAgICAgICBvLnBhdGggPSB0aGlzLnNvdXJjZVBhdGg7XG4gICAgICB9XG4gICAgICBkZWxldGUgby5zb3VyY2VQYXRoO1xuICAgICAgcmV0dXJuIG87XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHZhciBjaHVua3MgPSBbXSxcbiAgICAgICAgICBtYXJrdXAgPSB0aGlzLl9jcmVhdGVCYXNlU1ZHTWFya3VwKCksIGFkZFRyYW5zZm9ybSA9ICcnO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5wYXRoLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNodW5rcy5wdXNoKHRoaXMucGF0aFtpXS5qb2luKCcgJykpO1xuICAgICAgfVxuICAgICAgdmFyIHBhdGggPSBjaHVua3Muam9pbignICcpO1xuICAgICAgaWYgKCEodGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLnR5cGUgPT09ICdwYXRoLWdyb3VwJykpIHtcbiAgICAgICAgYWRkVHJhbnNmb3JtID0gJyB0cmFuc2xhdGUoJyArICgtdGhpcy5wYXRoT2Zmc2V0LngpICsgJywgJyArICgtdGhpcy5wYXRoT2Zmc2V0LnkpICsgJykgJztcbiAgICAgIH1cbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPHBhdGggJywgdGhpcy5nZXRTdmdJZCgpLFxuICAgICAgICAgICdkPVwiJywgcGF0aCxcbiAgICAgICAgICAnXCIgc3R5bGU9XCInLCB0aGlzLmdldFN2Z1N0eWxlcygpLFxuICAgICAgICAgICdcIiB0cmFuc2Zvcm09XCInLCB0aGlzLmdldFN2Z1RyYW5zZm9ybSgpLCBhZGRUcmFuc2Zvcm0sXG4gICAgICAgICAgdGhpcy5nZXRTdmdUcmFuc2Zvcm1NYXRyaXgoKSwgJ1wiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiAnLFxuICAgICAgICAnLz5cXG4nXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcmV2aXZlciA/IHJldml2ZXIobWFya3VwLmpvaW4oJycpKSA6IG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBudW1iZXIgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2UgY29tcGxleGl0eVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gY29tcGxleGl0eSBvZiB0aGlzIGluc3RhbmNlXG4gICAgICovXG4gICAgY29tcGxleGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXRoLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcGFyc2VQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBjb29yZHMgPSBbXSxcbiAgICAgICAgICBjdXJyZW50UGF0aCxcbiAgICAgICAgICBwYXJzZWQsXG4gICAgICAgICAgcmUgPSAvKFstK10/KChcXGQrXFwuXFxkKyl8KChcXGQrKXwoXFwuXFxkKykpKSg/OmVbLStdP1xcZCspPykvaWcsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgY29vcmRzU3RyO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgY29vcmRzUGFyc2VkLCBsZW4gPSB0aGlzLnBhdGgubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY3VycmVudFBhdGggPSB0aGlzLnBhdGhbaV07XG5cbiAgICAgICAgY29vcmRzU3RyID0gY3VycmVudFBhdGguc2xpY2UoMSkudHJpbSgpO1xuICAgICAgICBjb29yZHMubGVuZ3RoID0gMDtcblxuICAgICAgICB3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhjb29yZHNTdHIpKSkge1xuICAgICAgICAgIGNvb3Jkcy5wdXNoKG1hdGNoWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvb3Jkc1BhcnNlZCA9IFtjdXJyZW50UGF0aC5jaGFyQXQoMCldO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gY29vcmRzLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgICAgIHBhcnNlZCA9IHBhcnNlRmxvYXQoY29vcmRzW2pdKTtcbiAgICAgICAgICBpZiAoIWlzTmFOKHBhcnNlZCkpIHtcbiAgICAgICAgICAgIGNvb3Jkc1BhcnNlZC5wdXNoKHBhcnNlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbW1hbmQgPSBjb29yZHNQYXJzZWRbMF0sXG4gICAgICAgICAgICBjb21tYW5kTGVuZ3RoID0gY29tbWFuZExlbmd0aHNbY29tbWFuZC50b0xvd2VyQ2FzZSgpXSxcbiAgICAgICAgICAgIHJlcGVhdGVkQ29tbWFuZCA9IHJlcGVhdGVkQ29tbWFuZHNbY29tbWFuZF0gfHwgY29tbWFuZDtcblxuICAgICAgICBpZiAoY29vcmRzUGFyc2VkLmxlbmd0aCAtIDEgPiBjb21tYW5kTGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgayA9IDEsIGtsZW4gPSBjb29yZHNQYXJzZWQubGVuZ3RoOyBrIDwga2xlbjsgayArPSBjb21tYW5kTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChbY29tbWFuZF0uY29uY2F0KGNvb3Jkc1BhcnNlZC5zbGljZShrLCBrICsgY29tbWFuZExlbmd0aCkpKTtcbiAgICAgICAgICAgIGNvbW1hbmQgPSByZXBlYXRlZENvbW1hbmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGNvb3Jkc1BhcnNlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcGFyc2VEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGFYID0gW10sXG4gICAgICAgICAgYVkgPSBbXSxcbiAgICAgICAgICBjdXJyZW50LCAvLyBjdXJyZW50IGluc3RydWN0aW9uXG4gICAgICAgICAgcHJldmlvdXMgPSBudWxsLFxuICAgICAgICAgIHN1YnBhdGhTdGFydFggPSAwLFxuICAgICAgICAgIHN1YnBhdGhTdGFydFkgPSAwLFxuICAgICAgICAgIHggPSAwLCAvLyBjdXJyZW50IHhcbiAgICAgICAgICB5ID0gMCwgLy8gY3VycmVudCB5XG4gICAgICAgICAgY29udHJvbFggPSAwLCAvLyBjdXJyZW50IGNvbnRyb2wgcG9pbnQgeFxuICAgICAgICAgIGNvbnRyb2xZID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHlcbiAgICAgICAgICB0ZW1wWCxcbiAgICAgICAgICB0ZW1wWSxcbiAgICAgICAgICBib3VuZHM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnBhdGgubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblxuICAgICAgICBjdXJyZW50ID0gdGhpcy5wYXRoW2ldO1xuXG4gICAgICAgIHN3aXRjaCAoY3VycmVudFswXSkgeyAvLyBmaXJzdCBsZXR0ZXJcblxuICAgICAgICAgIGNhc2UgJ2wnOiAvLyBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICB5ICs9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBib3VuZHMgPSBbXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnTCc6IC8vIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBib3VuZHMgPSBbXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaCc6IC8vIGhvcml6b250YWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0gnOiAvLyBob3Jpem9udGFsIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3YnOiAvLyB2ZXJ0aWNhbCBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgICAgICB5ICs9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICBib3VuZHMgPSBbXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnVic6IC8vIHZlcmljYWwgbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgeSA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICBib3VuZHMgPSBbXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbSc6IC8vIG1vdmVUbywgcmVsYXRpdmVcbiAgICAgICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgKz0gY3VycmVudFsyXTtcbiAgICAgICAgICAgIHN1YnBhdGhTdGFydFggPSB4O1xuICAgICAgICAgICAgc3VicGF0aFN0YXJ0WSA9IHk7XG4gICAgICAgICAgICBib3VuZHMgPSBbXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnTSc6IC8vIG1vdmVUbywgYWJzb2x1dGVcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBzdWJwYXRoU3RhcnRYID0geDtcbiAgICAgICAgICAgIHN1YnBhdGhTdGFydFkgPSB5O1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2MnOiAvLyBiZXppZXJDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFs1XTtcbiAgICAgICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNl07XG4gICAgICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzNdO1xuICAgICAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFs0XTtcbiAgICAgICAgICAgIGJvdW5kcyA9IGZhYnJpYy51dGlsLmdldEJvdW5kc09mQ3VydmUoeCwgeSxcbiAgICAgICAgICAgICAgeCArIGN1cnJlbnRbMV0sIC8vIHgxXG4gICAgICAgICAgICAgIHkgKyBjdXJyZW50WzJdLCAvLyB5MVxuICAgICAgICAgICAgICBjb250cm9sWCwgLy8geDJcbiAgICAgICAgICAgICAgY29udHJvbFksIC8vIHkyXG4gICAgICAgICAgICAgIHRlbXBYLFxuICAgICAgICAgICAgICB0ZW1wWVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQyc6IC8vIGJlemllckN1cnZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFs1XTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzZdO1xuICAgICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzNdO1xuICAgICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzRdO1xuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSh4LCB5LFxuICAgICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgICBjb250cm9sWCxcbiAgICAgICAgICAgICAgY29udHJvbFksXG4gICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgIHlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3MnOiAvLyBzaG9ydGhhbmQgY3ViaWMgYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcblxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNF07XG5cbiAgICAgICAgICAgIGlmIChwcmV2aW91c1swXS5tYXRjaCgvW0NjU3NdLykgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgY29tbWFuZCBvciBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCB3YXMgbm90IGEgQywgYywgUywgb3IgcyxcbiAgICAgICAgICAgICAgLy8gdGhlIGNvbnRyb2wgcG9pbnQgaXMgY29pbmNpZGVudCB3aXRoIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgICAgICAgIGNvbnRyb2xYID0geDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBib3VuZHMgPSBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkN1cnZlKHgsIHksXG4gICAgICAgICAgICAgIGNvbnRyb2xYLFxuICAgICAgICAgICAgICBjb250cm9sWSxcbiAgICAgICAgICAgICAgeCArIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICAgIHkgKyBjdXJyZW50WzJdLFxuICAgICAgICAgICAgICB0ZW1wWCxcbiAgICAgICAgICAgICAgdGVtcFlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvLyBzZXQgY29udHJvbCBwb2ludCB0byAybmQgb25lIG9mIHRoaXMgY29tbWFuZFxuICAgICAgICAgICAgLy8gXCIuLi4gdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgaXMgYXNzdW1lZCB0byBiZVxuICAgICAgICAgICAgLy8gdGhlIHJlZmxlY3Rpb24gb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50IG9uXG4gICAgICAgICAgICAvLyB0aGUgcHJldmlvdXMgY29tbWFuZCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb2ludC5cIlxuICAgICAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG4gICAgICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1MnOiAvLyBzaG9ydGhhbmQgY3ViaWMgYmV6aWVyQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgICAgIHRlbXBYID0gY3VycmVudFszXTtcbiAgICAgICAgICAgIHRlbXBZID0gY3VycmVudFs0XTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c1swXS5tYXRjaCgvW0NjU3NdLykgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgY29tbWFuZCBvciBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCB3YXMgbm90IGEgQywgYywgUywgb3IgcyxcbiAgICAgICAgICAgICAgLy8gdGhlIGNvbnRyb2wgcG9pbnQgaXMgY29pbmNpZGVudCB3aXRoIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgICAgICAgIGNvbnRyb2xYID0geDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSh4LCB5LFxuICAgICAgICAgICAgICBjb250cm9sWCxcbiAgICAgICAgICAgICAgY29udHJvbFksXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICAgIHRlbXBYLFxuICAgICAgICAgICAgICB0ZW1wWVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgICAgIC8vIHNldCBjb250cm9sIHBvaW50IHRvIDJuZCBvbmUgb2YgdGhpcyBjb21tYW5kXG4gICAgICAgICAgICAvLyBcIi4uLiB0aGUgZmlyc3QgY29udHJvbCBwb2ludCBpcyBhc3N1bWVkIHRvIGJlXG4gICAgICAgICAgICAvLyB0aGUgcmVmbGVjdGlvbiBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgb25cbiAgICAgICAgICAgIC8vIHRoZSBwcmV2aW91cyBjb21tYW5kIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvaW50LlwiXG4gICAgICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNF07XG4gICAgICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcbiAgICAgICAgICAgIGJvdW5kcyA9IGZhYnJpYy51dGlsLmdldEJvdW5kc09mQ3VydmUoeCwgeSxcbiAgICAgICAgICAgICAgY29udHJvbFgsXG4gICAgICAgICAgICAgIGNvbnRyb2xZLFxuICAgICAgICAgICAgICBjb250cm9sWCxcbiAgICAgICAgICAgICAgY29udHJvbFksXG4gICAgICAgICAgICAgIHRlbXBYLFxuICAgICAgICAgICAgICB0ZW1wWVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnUSc6IC8vIHF1YWRyYXRpY0N1cnZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBib3VuZHMgPSBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkN1cnZlKHgsIHksXG4gICAgICAgICAgICAgIGNvbnRyb2xYLFxuICAgICAgICAgICAgICBjb250cm9sWSxcbiAgICAgICAgICAgICAgY29udHJvbFgsXG4gICAgICAgICAgICAgIGNvbnRyb2xZLFxuICAgICAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgICAgICBjdXJyZW50WzRdXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgICB5ID0gY3VycmVudFs0XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndCc6IC8vIHNob3J0aGFuZCBxdWFkcmF0aWNDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbMl07XG4gICAgICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tRcVR0XS8pID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIFEsIHEsIFQgb3IgdCxcbiAgICAgICAgICAgICAgLy8gYXNzdW1lIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50XG4gICAgICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBib3VuZHMgPSBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkN1cnZlKHgsIHksXG4gICAgICAgICAgICAgIGNvbnRyb2xYLFxuICAgICAgICAgICAgICBjb250cm9sWSxcbiAgICAgICAgICAgICAgY29udHJvbFgsXG4gICAgICAgICAgICAgIGNvbnRyb2xZLFxuICAgICAgICAgICAgICB0ZW1wWCxcbiAgICAgICAgICAgICAgdGVtcFlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgICAgICB5ID0gdGVtcFk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbMl07XG5cbiAgICAgICAgICAgIGlmIChwcmV2aW91c1swXS5tYXRjaCgvW1FxVHRdLykgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgY29tbWFuZCBvciBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCB3YXMgbm90IGEgUSwgcSwgVCBvciB0LFxuICAgICAgICAgICAgICAvLyBhc3N1bWUgdGhlIGNvbnRyb2wgcG9pbnQgaXMgY29pbmNpZGVudCB3aXRoIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgICAgICAgIGNvbnRyb2xYID0geDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRcbiAgICAgICAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib3VuZHMgPSBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkN1cnZlKHgsIHksXG4gICAgICAgICAgICAgIGNvbnRyb2xYLFxuICAgICAgICAgICAgICBjb250cm9sWSxcbiAgICAgICAgICAgICAgY29udHJvbFgsXG4gICAgICAgICAgICAgIGNvbnRyb2xZLFxuICAgICAgICAgICAgICB0ZW1wWCxcbiAgICAgICAgICAgICAgdGVtcFlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgLy8gVE9ETzogb3B0aW1pemUgdGhpc1xuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZBcmMoeCwgeSxcbiAgICAgICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICAgICAgY3VycmVudFs0XSxcbiAgICAgICAgICAgICAgY3VycmVudFs1XSxcbiAgICAgICAgICAgICAgY3VycmVudFs2XSArIHgsXG4gICAgICAgICAgICAgIGN1cnJlbnRbN10gKyB5XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCArPSBjdXJyZW50WzZdO1xuICAgICAgICAgICAgeSArPSBjdXJyZW50WzddO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgIC8vIFRPRE86IG9wdGltaXplIHRoaXNcbiAgICAgICAgICAgIGJvdW5kcyA9IGZhYnJpYy51dGlsLmdldEJvdW5kc09mQXJjKHgsIHksXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNl0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbN11cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gY3VycmVudFs2XTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzddO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICAgIHggPSBzdWJwYXRoU3RhcnRYO1xuICAgICAgICAgICAgeSA9IHN1YnBhdGhTdGFydFk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gICAgICAgIGJvdW5kcy5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgIGFYLnB1c2gocG9pbnQueCk7XG4gICAgICAgICAgYVkucHVzaChwb2ludC55KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFYLnB1c2goeCk7XG4gICAgICAgIGFZLnB1c2goeSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtaW5YID0gbWluKGFYKSB8fCAwLFxuICAgICAgICAgIG1pblkgPSBtaW4oYVkpIHx8IDAsXG4gICAgICAgICAgbWF4WCA9IG1heChhWCkgfHwgMCxcbiAgICAgICAgICBtYXhZID0gbWF4KGFZKSB8fCAwLFxuICAgICAgICAgIGRlbHRhWCA9IG1heFggLSBtaW5YLFxuICAgICAgICAgIGRlbHRhWSA9IG1heFkgLSBtaW5ZLFxuXG4gICAgICAgICAgbyA9IHtcbiAgICAgICAgICAgIGxlZnQ6IG1pblgsXG4gICAgICAgICAgICB0b3A6IG1pblksXG4gICAgICAgICAgICB3aWR0aDogZGVsdGFYLFxuICAgICAgICAgICAgaGVpZ2h0OiBkZWx0YVlcbiAgICAgICAgICB9O1xuXG4gICAgICByZXR1cm4gbztcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZhYnJpYy5QYXRoIGZyb20gYW4gb2JqZWN0XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5QYXRoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBmYWJyaWMuUGF0aCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlQXN5bmNdIEZvcmNlIGFuIGFzeW5jIGJlaGF2aW91ciB0cnlpbmcgdG8gY3JlYXRlIHBhdHRlcm4gZmlyc3RcbiAgICovXG4gIGZhYnJpYy5QYXRoLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrLCBmb3JjZUFzeW5jKSB7XG4gICAgLy8gcmVtb3ZlIHRoaXMgcGF0dGVybiByb20gMi4wLCBhY2NlcHQganVzdCBvYmplY3QuXG4gICAgdmFyIHBhdGg7XG4gICAgaWYgKHR5cGVvZiBvYmplY3QucGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZhYnJpYy5sb2FkU1ZHRnJvbVVSTChvYmplY3QucGF0aCwgZnVuY3Rpb24gKGVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBwYXRoVXJsID0gb2JqZWN0LnBhdGg7XG4gICAgICAgIHBhdGggPSBlbGVtZW50c1swXTtcbiAgICAgICAgZGVsZXRlIG9iamVjdC5wYXRoO1xuXG4gICAgICAgIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQocGF0aCwgb2JqZWN0KTtcbiAgICAgICAgcGF0aC5zZXRTb3VyY2VQYXRoKHBhdGhVcmwpO1xuXG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHBhdGgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1BhdGgnLCBvYmplY3QsIGNhbGxiYWNrLCBmb3JjZUFzeW5jLCAncGF0aCcpO1xuICAgIH1cbiAgfTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkgYGZhYnJpYy5QYXRoLmZyb21FbGVtZW50YClcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBhdGhcbiAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNQYXRoRWxlbWVudFxuICAgKi9cbiAgZmFicmljLlBhdGguQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdChbJ2QnXSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgZmFicmljLlBhdGggZnJvbSBhbiBTVkcgPHBhdGg+IGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBhdGhcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGZhYnJpYy5QYXRoIGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgZmFicmljLlBhdGguZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuUGF0aC5BVFRSSUJVVEVfTkFNRVMpO1xuICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG5ldyBmYWJyaWMuUGF0aChwYXJzZWRBdHRyaWJ1dGVzLmQsIGV4dGVuZChwYXJzZWRBdHRyaWJ1dGVzLCBvcHRpb25zKSkpO1xuICB9O1xuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhhdCBpbnN0YW5jZXMgb2YgdGhpcyB0eXBlIGFyZSBhc3luY1xuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUGF0aFxuICAgKiBAdHlwZSBCb29sZWFuXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBmYWJyaWMuUGF0aC5hc3luYyA9IHRydWU7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQ7XG5cbiAgaWYgKGZhYnJpYy5QYXRoR3JvdXApIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlBhdGhHcm91cCBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogUGF0aCBncm91cCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlBhdGhHcm91cFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuUGF0aFxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMSNwYXRoX2FuZF9wYXRoZ3JvdXB9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5QYXRoR3JvdXAjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5QYXRoR3JvdXAgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5QYXRoR3JvdXAucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAncGF0aC1ncm91cCcsXG5cbiAgICAvKipcbiAgICAgKiBGaWxsIHZhbHVlXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmaWxsOiAnJyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBhdGhHcm91cH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHBhdGhzLCBvcHRpb25zKSB7XG5cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgfTtcbiAgICAgIHRoaXMucGF0aHMgPSBwYXRocyB8fCBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMucGF0aHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIHRoaXMucGF0aHNbaV0uZ3JvdXAgPSB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy50b0JlUGFyc2VkKSB7XG4gICAgICAgIHRoaXMucGFyc2VEaW1lbnNpb25zRnJvbVBhdGhzKG9wdGlvbnMpO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy50b0JlUGFyc2VkO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIGlmIChvcHRpb25zLnNvdXJjZVBhdGgpIHtcbiAgICAgICAgdGhpcy5zZXRTb3VyY2VQYXRoKG9wdGlvbnMuc291cmNlUGF0aCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vYmplY3RDYWNoaW5nKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUNhY2hlQ2FudmFzKCk7XG4gICAgICAgIHRoaXMuc2V0dXBTdGF0ZSh7IHByb3BlcnR5U2V0OiAnY2FjaGVQcm9wZXJ0aWVzJyB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHdpZHRoIGFuZCBoZWlnaHQgYmFzZWQgb24gcGF0aHMgY29udGFpbmVkXG4gICAgICovXG4gICAgcGFyc2VEaW1lbnNpb25zRnJvbVBhdGhzOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgcG9pbnRzLCBwLCB4QyA9IFtdLCB5QyA9IFtdLCBwYXRoLCBoZWlnaHQsIHdpZHRoLFxuICAgICAgICAgIG07XG4gICAgICBmb3IgKHZhciBqID0gdGhpcy5wYXRocy5sZW5ndGg7IGotLTspIHtcbiAgICAgICAgcGF0aCA9IHRoaXMucGF0aHNbal07XG4gICAgICAgIGhlaWdodCA9IHBhdGguaGVpZ2h0ICsgcGF0aC5zdHJva2VXaWR0aDtcbiAgICAgICAgd2lkdGggPSBwYXRoLndpZHRoICsgcGF0aC5zdHJva2VXaWR0aDtcbiAgICAgICAgcG9pbnRzID0gW1xuICAgICAgICAgIHsgeDogcGF0aC5sZWZ0LCB5OiBwYXRoLnRvcCB9LFxuICAgICAgICAgIHsgeDogcGF0aC5sZWZ0ICsgd2lkdGgsIHk6IHBhdGgudG9wIH0sXG4gICAgICAgICAgeyB4OiBwYXRoLmxlZnQsIHk6IHBhdGgudG9wICsgaGVpZ2h0IH0sXG4gICAgICAgICAgeyB4OiBwYXRoLmxlZnQgKyB3aWR0aCwgeTogcGF0aC50b3AgKyBoZWlnaHQgfVxuICAgICAgICBdO1xuICAgICAgICBtID0gdGhpcy5wYXRoc1tqXS50cmFuc2Zvcm1NYXRyaXg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcCA9IHBvaW50c1tpXTtcbiAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgcCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHAsIG0sIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgeEMucHVzaChwLngpO1xuICAgICAgICAgIHlDLnB1c2gocC55KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3B0aW9ucy53aWR0aCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHhDKTtcbiAgICAgIG9wdGlvbnMuaGVpZ2h0ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgeUMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBkcmF3aW5nIG9wZXJhdGlvbiBmb3IgYW4gb2JqZWN0IG9uIGEgc3BlY2lmaWVkIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbbm9UcmFuc2Zvcm1dIFdoZW4gdHJ1ZSwgY29udGV4dCBpcyBub3QgdHJhbnNmb3JtZWRcbiAgICAgKi9cbiAgICBkcmF3T2JqZWN0OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKC10aGlzLndpZHRoIC8gMiwgLXRoaXMuaGVpZ2h0IC8gMik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMucGF0aHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIHRoaXMucGF0aHNbaV0ucmVuZGVyKGN0eCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjYWNoZSBpcyBkaXJ0eVxuICAgICAqL1xuICAgIGlzQ2FjaGVEaXJ0eTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jYWxsU3VwZXIoJ2lzQ2FjaGVEaXJ0eScpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnN0YXRlZnVsbENhY2hlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnBhdGhzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLnBhdGhzW2ldLmlzQ2FjaGVEaXJ0eSh0cnVlKSkge1xuICAgICAgICAgIHZhciBkaW0gPSB0aGlzLl9nZXROb25UcmFuc2Zvcm1lZERpbWVuc2lvbnMoKTtcbiAgICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuY2xlYXJSZWN0KC1kaW0ueCAvIDIsIC1kaW0ueSAvIDIsIGRpbS54LCBkaW0ueSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBjZXJ0YWluIHByb3BlcnR5IHRvIGEgY2VydGFpbiB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5QYXRoR3JvdXB9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBfc2V0OiBmdW5jdGlvbihwcm9wLCB2YWx1ZSkge1xuXG4gICAgICBpZiAocHJvcCA9PT0gJ2ZpbGwnICYmIHZhbHVlICYmIHRoaXMuaXNTYW1lQ29sb3IoKSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMucGF0aHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgdGhpcy5wYXRoc1tpXS5fc2V0KHByb3AsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jYWxsU3VwZXIoJ19zZXQnLCBwcm9wLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcGF0aCBncm91cFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgcGF0aHNUb09iamVjdCA9IHRoaXMucGF0aHMubWFwKGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsRGVmYXVsdHMgPSBwYXRoLmluY2x1ZGVEZWZhdWx0VmFsdWVzO1xuICAgICAgICBwYXRoLmluY2x1ZGVEZWZhdWx0VmFsdWVzID0gcGF0aC5ncm91cC5pbmNsdWRlRGVmYXVsdFZhbHVlcztcbiAgICAgICAgdmFyIG9iaiA9IHBhdGgudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICAgIHBhdGguaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBvcmlnaW5hbERlZmF1bHRzO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfSk7XG4gICAgICB2YXIgbyA9IGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBbJ3NvdXJjZVBhdGgnXS5jb25jYXQocHJvcGVydGllc1RvSW5jbHVkZSkpLCB7XG4gICAgICAgIHBhdGhzOiBwYXRoc1RvT2JqZWN0XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGRhdGFsZXNzIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHBhdGggZ3JvdXBcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBkYXRhbGVzcyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b0RhdGFsZXNzT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgbyA9IHRoaXMudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICBpZiAodGhpcy5zb3VyY2VQYXRoKSB7XG4gICAgICAgIG8ucGF0aHMgPSB0aGlzLnNvdXJjZVBhdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLmdldE9iamVjdHMoKSxcbiAgICAgICAgICBwID0gdGhpcy5nZXRQb2ludEJ5T3JpZ2luKCdsZWZ0JywgJ3RvcCcpLFxuICAgICAgICAgIHRyYW5zbGF0ZVBhcnQgPSAndHJhbnNsYXRlKCcgKyBwLnggKyAnICcgKyBwLnkgKyAnKScsXG4gICAgICAgICAgbWFya3VwID0gdGhpcy5fY3JlYXRlQmFzZVNWR01hcmt1cCgpO1xuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICc8ZyAnLCB0aGlzLmdldFN2Z0lkKCksXG4gICAgICAgICdzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKCksICdcIiAnLFxuICAgICAgICAndHJhbnNmb3JtPVwiJywgdGhpcy5nZXRTdmdUcmFuc2Zvcm1NYXRyaXgoKSwgdHJhbnNsYXRlUGFydCwgdGhpcy5nZXRTdmdUcmFuc2Zvcm0oKSwgJ1wiICcsXG4gICAgICAgICc+XFxuJ1xuICAgICAgKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbWFya3VwLnB1c2goJ1xcdCcsIG9iamVjdHNbaV0udG9TVkcocmV2aXZlcikpO1xuICAgICAgfVxuICAgICAgbWFya3VwLnB1c2goJzwvZz5cXG4nKTtcblxuICAgICAgcmV0dXJuIHJldml2ZXIgPyByZXZpdmVyKG1hcmt1cC5qb2luKCcnKSkgOiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBwYXRoIGdyb3VwXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5QYXRoR3JvdXAgKCcgKyB0aGlzLmNvbXBsZXhpdHkoKSArXG4gICAgICAgICcpOiB7IHRvcDogJyArIHRoaXMudG9wICsgJywgbGVmdDogJyArIHRoaXMubGVmdCArICcgfT4nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYWxsIHBhdGhzIGluIHRoaXMgZ3JvdXAgYXJlIG9mIHNhbWUgY29sb3JcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGFsbCBwYXRocyBhcmUgb2YgdGhlIHNhbWUgY29sb3IgKGBmaWxsYClcbiAgICAgKi9cbiAgICBpc1NhbWVDb2xvcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZmlyc3RQYXRoRmlsbCA9IHRoaXMuZ2V0T2JqZWN0cygpWzBdLmdldCgnZmlsbCcpIHx8ICcnO1xuICAgICAgaWYgKHR5cGVvZiBmaXJzdFBhdGhGaWxsICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmaXJzdFBhdGhGaWxsID0gZmlyc3RQYXRoRmlsbC50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0cygpLmV2ZXJ5KGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgdmFyIHBhdGhGaWxsID0gcGF0aC5nZXQoJ2ZpbGwnKSB8fCAnJztcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwYXRoRmlsbCA9PT0gJ3N0cmluZycgJiYgKHBhdGhGaWxsKS50b0xvd2VyQ2FzZSgpID09PSBmaXJzdFBhdGhGaWxsO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbnVtYmVyIHJlcHJlc2VudGF0aW9uIG9mIG9iamVjdCdzIGNvbXBsZXhpdHlcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHlcbiAgICAgKi9cbiAgICBjb21wbGV4aXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhdGhzLnJlZHVjZShmdW5jdGlvbih0b3RhbCwgcGF0aCkge1xuICAgICAgICByZXR1cm4gdG90YWwgKyAoKHBhdGggJiYgcGF0aC5jb21wbGV4aXR5KSA/IHBhdGguY29tcGxleGl0eSgpIDogMCk7XG4gICAgICB9LCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgcGF0aHMgaW4gdGhpcyBwYXRoIGdyb3VwXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFycmF5IG9mIHBhdGggb2JqZWN0cyBpbmNsdWRlZCBpbiB0aGlzIHBhdGggZ3JvdXBcbiAgICAgKi9cbiAgICBnZXRPYmplY3RzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhdGhzO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgZmFicmljLlBhdGhHcm91cCBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUGF0aEdyb3VwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlBhdGhHcm91cCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuUGF0aEdyb3VwLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgLy8gcmVtb3ZlIHRoaXMgcGF0dGVybiBmcm9tIDIuMCBhY2NlcHRzIG9ubHkgb2JqZWN0XG4gICAgaWYgKHR5cGVvZiBvYmplY3QucGF0aHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBmYWJyaWMubG9hZFNWR0Zyb21VUkwob2JqZWN0LnBhdGhzLCBmdW5jdGlvbiAoZWxlbWVudHMpIHtcblxuICAgICAgICB2YXIgcGF0aFVybCA9IG9iamVjdC5wYXRocztcbiAgICAgICAgZGVsZXRlIG9iamVjdC5wYXRocztcblxuICAgICAgICB2YXIgcGF0aEdyb3VwID0gZmFicmljLnV0aWwuZ3JvdXBTVkdFbGVtZW50cyhlbGVtZW50cywgb2JqZWN0LCBwYXRoVXJsKTtcblxuICAgICAgICBjYWxsYmFjayhwYXRoR3JvdXApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMob2JqZWN0LnBhdGhzLCBmdW5jdGlvbihlbmxpdmVuZWRPYmplY3RzKSB7XG4gICAgICAgIGRlbGV0ZSBvYmplY3QucGF0aHM7XG4gICAgICAgIGNhbGxiYWNrKG5ldyBmYWJyaWMuUGF0aEdyb3VwKGVubGl2ZW5lZE9iamVjdHMsIG9iamVjdCkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhhdCBpbnN0YW5jZXMgb2YgdGhpcyB0eXBlIGFyZSBhc3luY1xuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUGF0aEdyb3VwXG4gICAqIEB0eXBlIEJvb2xlYW5cbiAgICogQGRlZmF1bHRcbiAgICovXG4gIGZhYnJpYy5QYXRoR3JvdXAuYXN5bmMgPSB0cnVlO1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgbWluID0gZmFicmljLnV0aWwuYXJyYXkubWluLFxuICAgICAgbWF4ID0gZmFicmljLnV0aWwuYXJyYXkubWF4O1xuXG4gIGlmIChmYWJyaWMuR3JvdXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBsb2NrLXJlbGF0ZWQgcHJvcGVydGllcywgZm9yIHVzZSBpbiBmYWJyaWMuR3JvdXAjZ2V0XG4gIC8vIHRvIGVuYWJsZSBsb2NraW5nIGJlaGF2aW9yIG9uIGdyb3VwXG4gIC8vIHdoZW4gb25lIG9mIGl0cyBvYmplY3RzIGhhcyBsb2NrLXJlbGF0ZWQgcHJvcGVydGllcyBzZXRcbiAgdmFyIF9sb2NrUHJvcGVydGllcyA9IHtcbiAgICBsb2NrTW92ZW1lbnRYOiAgdHJ1ZSxcbiAgICBsb2NrTW92ZW1lbnRZOiAgdHJ1ZSxcbiAgICBsb2NrUm90YXRpb246ICAgdHJ1ZSxcbiAgICBsb2NrU2NhbGluZ1g6ICAgdHJ1ZSxcbiAgICBsb2NrU2NhbGluZ1k6ICAgdHJ1ZSxcbiAgICBsb2NrVW5pU2NhbGluZzogdHJ1ZVxuICB9O1xuXG4gIC8qKlxuICAgKiBHcm91cCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkdyb3VwXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQG1peGVzIGZhYnJpYy5Db2xsZWN0aW9uXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0zI2dyb3Vwc31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkdyb3VwI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuR3JvdXAgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCBmYWJyaWMuQ29sbGVjdGlvbiwgLyoqIEBsZW5kcyBmYWJyaWMuR3JvdXAucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnZ3JvdXAnLFxuXG4gICAgLyoqXG4gICAgICogV2lkdGggb2Ygc3Ryb2tlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2VXaWR0aDogMCxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiBjbGljayBldmVudHMgc2hvdWxkIGFsc28gY2hlY2sgZm9yIHN1YnRhcmdldHNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdWJUYXJnZXRDaGVjazogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RzIEdyb3VwIG9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaXNBbHJlYWR5R3JvdXBlZF0gaWYgdHJ1ZSwgb2JqZWN0cyBoYXZlIGJlZW4gZ3JvdXBlZCBhbHJlYWR5LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9iamVjdHMsIG9wdGlvbnMsIGlzQWxyZWFkeUdyb3VwZWQpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgfTtcblxuICAgICAgdGhpcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgLy8gaWYgb2JqZWN0cyBlbmNsb3NlZCBpbiBhIGdyb3VwIGhhdmUgYmVlbiBncm91cGVkIGFscmVhZHksXG4gICAgICAvLyB3ZSBjYW5ub3QgY2hhbmdlIHByb3BlcnRpZXMgb2Ygb2JqZWN0cy5cbiAgICAgIC8vIFRodXMgd2UgbmVlZCB0byBzZXQgb3B0aW9ucyB0byBncm91cCB3aXRob3V0IG9iamVjdHMsXG4gICAgICAvLyBiZWNhdXNlIGRlbGVnYXRlZFByb3BlcnRpZXMgcHJvcGFnYXRlIHRvIG9iamVjdHMuXG4gICAgICBpc0FscmVhZHlHcm91cGVkICYmIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuX29iamVjdHMgPSBvYmplY3RzIHx8IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICB0aGlzLl9vYmplY3RzW2ldLmdyb3VwID0gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcmlnaW5hbFN0YXRlID0geyB9O1xuXG4gICAgICBpZiAob3B0aW9ucy5vcmlnaW5YKSB7XG4gICAgICAgIHRoaXMub3JpZ2luWCA9IG9wdGlvbnMub3JpZ2luWDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLm9yaWdpblkpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5ZID0gb3B0aW9ucy5vcmlnaW5ZO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNBbHJlYWR5R3JvdXBlZCkge1xuICAgICAgICAvLyBkbyBub3QgY2hhbmdlIGNvb3JkaW5hdGUgb2Ygb2JqZWN0cyBlbmNsb3NlZCBpbiBhIGdyb3VwLFxuICAgICAgICAvLyBiZWNhdXNlIG9iamVjdHMgY29vcmRpbmF0ZSBzeXN0ZW0gaGF2ZSBiZWVuIGdyb3VwIGNvb2RpbmF0ZSBzeXN0ZW0gYWxyZWFkeS5cbiAgICAgICAgdGhpcy5fdXBkYXRlT2JqZWN0c0Nvb3Jkcyh0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9jYWxjQm91bmRzKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZU9iamVjdHNDb29yZHMoKTtcbiAgICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIHRoaXMuc2F2ZUNvb3JkcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBDb29yZHNDaGFuZ2VdIGlmIHRydWUsIGNvb3JkaW5hdGVzIG9mIG9iamVjdHMgZW5jbG9zZWQgaW4gYSBncm91cCBkbyBub3QgY2hhbmdlXG4gICAgICovXG4gICAgX3VwZGF0ZU9iamVjdHNDb29yZHM6IGZ1bmN0aW9uKHNraXBDb29yZHNDaGFuZ2UpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCk7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGktLTsgKXtcbiAgICAgICAgdGhpcy5fdXBkYXRlT2JqZWN0Q29vcmRzKHRoaXMuX29iamVjdHNbaV0sIGNlbnRlciwgc2tpcENvb3Jkc0NoYW5nZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBjZW50ZXIsIGN1cnJlbnQgY2VudGVyIG9mIGdyb3VwLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBDb29yZHNDaGFuZ2VdIGlmIHRydWUsIGNvb3JkaW5hdGVzIG9mIG9iamVjdCBkb3NlIG5vdCBjaGFuZ2VcbiAgICAgKi9cbiAgICBfdXBkYXRlT2JqZWN0Q29vcmRzOiBmdW5jdGlvbihvYmplY3QsIGNlbnRlciwgc2tpcENvb3Jkc0NoYW5nZSkge1xuICAgICAgLy8gZG8gbm90IGRpc3BsYXkgY29ybmVycyBvZiBvYmplY3RzIGVuY2xvc2VkIGluIGEgZ3JvdXBcbiAgICAgIG9iamVjdC5fX29yaWdIYXNDb250cm9scyA9IG9iamVjdC5oYXNDb250cm9scztcbiAgICAgIG9iamVjdC5oYXNDb250cm9scyA9IGZhbHNlO1xuXG4gICAgICBpZiAoc2tpcENvb3Jkc0NoYW5nZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBvYmplY3RMZWZ0ID0gb2JqZWN0LmdldExlZnQoKSxcbiAgICAgICAgICBvYmplY3RUb3AgPSBvYmplY3QuZ2V0VG9wKCksXG4gICAgICAgICAgaWdub3JlWm9vbSA9IHRydWU7XG5cbiAgICAgIG9iamVjdC5zZXQoe1xuICAgICAgICBvcmlnaW5hbExlZnQ6IG9iamVjdExlZnQsXG4gICAgICAgIG9yaWdpbmFsVG9wOiBvYmplY3RUb3AsXG4gICAgICAgIGxlZnQ6IG9iamVjdExlZnQgLSBjZW50ZXIueCxcbiAgICAgICAgdG9wOiBvYmplY3RUb3AgLSBjZW50ZXIueVxuICAgICAgfSk7XG4gICAgICBvYmplY3Quc2V0Q29vcmRzKGlnbm9yZVpvb20pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbmF0aW9uIG9mIGEgZ3JvdXBcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5Hcm91cDogKCcgKyB0aGlzLmNvbXBsZXhpdHkoKSArICcpPic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gb2JqZWN0IHRvIGEgZ3JvdXA7IFRoZW4gcmVjYWxjdWxhdGVzIGdyb3VwJ3MgZGltZW5zaW9uLCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFkZFdpdGhVcGRhdGU6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdGhpcy5fcmVzdG9yZU9iamVjdHNTdGF0ZSgpO1xuICAgICAgZmFicmljLnV0aWwucmVzZXRPYmplY3RUcmFuc2Zvcm0odGhpcyk7XG4gICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgIHRoaXMuX29iamVjdHMucHVzaChvYmplY3QpO1xuICAgICAgICBvYmplY3QuZ3JvdXAgPSB0aGlzO1xuICAgICAgICBvYmplY3QuX3NldCgnY2FudmFzJywgdGhpcy5jYW52YXMpO1xuICAgICAgfVxuICAgICAgLy8gc2luY2UgX3Jlc3RvcmVPYmplY3RzU3RhdGUgc2V0IG9iamVjdHMgaW5hY3RpdmVcbiAgICAgIHRoaXMuZm9yRWFjaE9iamVjdCh0aGlzLl9zZXRPYmplY3RBY3RpdmUsIHRoaXMpO1xuICAgICAgdGhpcy5fY2FsY0JvdW5kcygpO1xuICAgICAgdGhpcy5fdXBkYXRlT2JqZWN0c0Nvb3JkcygpO1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0T2JqZWN0QWN0aXZlOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIG9iamVjdC5zZXQoJ2FjdGl2ZScsIHRydWUpO1xuICAgICAgb2JqZWN0Lmdyb3VwID0gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBvYmplY3QgZnJvbSBhIGdyb3VwOyBUaGVuIHJlY2FsY3VsYXRlcyBncm91cCdzIGRpbWVuc2lvbiwgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZW1vdmVXaXRoVXBkYXRlOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHRoaXMuX3Jlc3RvcmVPYmplY3RzU3RhdGUoKTtcbiAgICAgIGZhYnJpYy51dGlsLnJlc2V0T2JqZWN0VHJhbnNmb3JtKHRoaXMpO1xuICAgICAgLy8gc2luY2UgX3Jlc3RvcmVPYmplY3RzU3RhdGUgc2V0IG9iamVjdHMgaW5hY3RpdmVcbiAgICAgIHRoaXMuZm9yRWFjaE9iamVjdCh0aGlzLl9zZXRPYmplY3RBY3RpdmUsIHRoaXMpO1xuXG4gICAgICB0aGlzLnJlbW92ZShvYmplY3QpO1xuICAgICAgdGhpcy5fY2FsY0JvdW5kcygpO1xuICAgICAgdGhpcy5fdXBkYXRlT2JqZWN0c0Nvb3JkcygpO1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25PYmplY3RBZGRlZDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIG9iamVjdC5ncm91cCA9IHRoaXM7XG4gICAgICBvYmplY3QuX3NldCgnY2FudmFzJywgdGhpcy5jYW52YXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbk9iamVjdFJlbW92ZWQ6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICBkZWxldGUgb2JqZWN0Lmdyb3VwO1xuICAgICAgb2JqZWN0LnNldCgnYWN0aXZlJywgZmFsc2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIHRoYXQgYXJlIGRlbGVnYXRlZCB0byBncm91cCBvYmplY3RzIHdoZW4gcmVhZGluZy93cml0aW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlbGVnYXRlZFByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBkZWxlZ2F0ZWRQcm9wZXJ0aWVzOiB7XG4gICAgICBmaWxsOiAgICAgICAgICAgICB0cnVlLFxuICAgICAgc3Ryb2tlOiAgICAgICAgICAgdHJ1ZSxcbiAgICAgIHN0cm9rZVdpZHRoOiAgICAgIHRydWUsXG4gICAgICBmb250RmFtaWx5OiAgICAgICB0cnVlLFxuICAgICAgZm9udFdlaWdodDogICAgICAgdHJ1ZSxcbiAgICAgIGZvbnRTaXplOiAgICAgICAgIHRydWUsXG4gICAgICBmb250U3R5bGU6ICAgICAgICB0cnVlLFxuICAgICAgbGluZUhlaWdodDogICAgICAgdHJ1ZSxcbiAgICAgIHRleHREZWNvcmF0aW9uOiAgIHRydWUsXG4gICAgICB0ZXh0QWxpZ246ICAgICAgICB0cnVlLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAgdHJ1ZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7XG5cbiAgICAgIGlmICh0aGlzLmRlbGVnYXRlZFByb3BlcnRpZXNba2V5XSB8fCBrZXkgPT09ICdjYW52YXMnKSB7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzW2ldLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzW2ldLnNldE9uR3JvdXAoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19zZXQnLCBrZXksIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG9ianNUb09iamVjdCA9IHRoaXMuZ2V0T2JqZWN0cygpLm1hcChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsRGVmYXVsdHMgPSBvYmouaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICAgIG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IG9iai5ncm91cC5pbmNsdWRlRGVmYXVsdFZhbHVlcztcbiAgICAgICAgdmFyIF9vYmogPSBvYmoudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICAgIG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IG9yaWdpbmFsRGVmYXVsdHM7XG4gICAgICAgIHJldHVybiBfb2JqO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpLCB7XG4gICAgICAgIG9iamVjdHM6IG9ianNUb09iamVjdFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgaW5zdGFuY2Ugb24gYSBnaXZlbiBjb250ZXh0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBpbnN0YW5jZSBvblxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1Eb25lID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdyZW5kZXInLCBjdHgpO1xuICAgICAgdGhpcy5fdHJhbnNmb3JtRG9uZSA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBkcmF3aW5nIG9wZXJhdGlvbiBmb3IgYW4gb2JqZWN0IG9uIGEgc3BlY2lmaWVkIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbbm9UcmFuc2Zvcm1dIFdoZW4gdHJ1ZSwgY29udGV4dCBpcyBub3QgdHJhbnNmb3JtZWRcbiAgICAgKi9cbiAgICBkcmF3T2JqZWN0OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlck9iamVjdCh0aGlzLl9vYmplY3RzW2ldLCBjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjYWNoZSBpcyBkaXJ0eVxuICAgICAqL1xuICAgIGlzQ2FjaGVEaXJ0eTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jYWxsU3VwZXIoJ2lzQ2FjaGVEaXJ0eScpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnN0YXRlZnVsbENhY2hlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9vYmplY3RzW2ldLmlzQ2FjaGVEaXJ0eSh0cnVlKSkge1xuICAgICAgICAgIHZhciBkaW0gPSB0aGlzLl9nZXROb25UcmFuc2Zvcm1lZERpbWVuc2lvbnMoKTtcbiAgICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuY2xlYXJSZWN0KC1kaW0ueCAvIDIsIC1kaW0ueSAvIDIsIGRpbS54LCBkaW0ueSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBjb250cm9scyBhbmQgYm9yZGVycyBmb3IgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtub1RyYW5zZm9ybV0gV2hlbiB0cnVlLCBjb250ZXh0IGlzIG5vdCB0cmFuc2Zvcm1lZFxuICAgICAqL1xuICAgIF9yZW5kZXJDb250cm9sczogZnVuY3Rpb24oY3R4LCBub1RyYW5zZm9ybSkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuaXNNb3ZpbmcgPyB0aGlzLmJvcmRlck9wYWNpdHlXaGVuTW92aW5nIDogMTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfcmVuZGVyQ29udHJvbHMnLCBjdHgsIG5vVHJhbnNmb3JtKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuX29iamVjdHNbaV0uX3JlbmRlckNvbnRyb2xzKGN0eCk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJPYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCwgY3R4KSB7XG4gICAgICAvLyBkbyBub3QgcmVuZGVyIGlmIG9iamVjdCBpcyBub3QgdmlzaWJsZVxuICAgICAgaWYgKCFvYmplY3QudmlzaWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBvcmlnaW5hbEhhc1JvdGF0aW5nUG9pbnQgPSBvYmplY3QuaGFzUm90YXRpbmdQb2ludDtcbiAgICAgIG9iamVjdC5oYXNSb3RhdGluZ1BvaW50ID0gZmFsc2U7XG4gICAgICBvYmplY3QucmVuZGVyKGN0eCk7XG4gICAgICBvYmplY3QuaGFzUm90YXRpbmdQb2ludCA9IG9yaWdpbmFsSGFzUm90YXRpbmdQb2ludDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0b3JlcyBvcmlnaW5hbCBzdGF0ZSBvZiBlYWNoIG9mIGdyb3VwIG9iamVjdHMgKG9yaWdpbmFsIHN0YXRlIGlzIHRoYXQgd2hpY2ggd2FzIGJlZm9yZSBncm91cCB3YXMgY3JlYXRlZCkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgX3Jlc3RvcmVPYmplY3RzU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fb2JqZWN0cy5mb3JFYWNoKHRoaXMuX3Jlc3RvcmVPYmplY3RTdGF0ZSwgdGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVhbGlzZXMgdGhlIHRyYW5zZm9ybSBmcm9tIHRoaXMgZ3JvdXAgb250byB0aGUgc3VwcGxpZWQgb2JqZWN0XG4gICAgICogaS5lLiBpdCB0ZWxscyB5b3Ugd2hhdCB3b3VsZCBoYXBwZW4gaWYgdGhlIHN1cHBsaWVkIG9iamVjdCB3YXMgaW5cbiAgICAgKiB0aGUgZ3JvdXAsIGFuZCB0aGVuIHRoZSBncm91cCB3YXMgZGVzdHJveWVkLiBJdCBtdXRhdGVzIHRoZSBzdXBwbGllZFxuICAgICAqIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRyYW5zZm9ybWVkT2JqZWN0XG4gICAgICovXG4gICAgcmVhbGl6ZVRyYW5zZm9ybTogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgbWF0cml4ID0gb2JqZWN0LmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSxcbiAgICAgICAgICBvcHRpb25zID0gZmFicmljLnV0aWwucXJEZWNvbXBvc2UobWF0cml4KSxcbiAgICAgICAgICBjZW50ZXIgPSBuZXcgZmFicmljLlBvaW50KG9wdGlvbnMudHJhbnNsYXRlWCwgb3B0aW9ucy50cmFuc2xhdGVZKTtcbiAgICAgIG9iamVjdC5mbGlwWCA9IGZhbHNlO1xuICAgICAgb2JqZWN0LmZsaXBZID0gZmFsc2U7XG4gICAgICBvYmplY3Quc2V0KCdzY2FsZVgnLCBvcHRpb25zLnNjYWxlWCk7XG4gICAgICBvYmplY3Quc2V0KCdzY2FsZVknLCBvcHRpb25zLnNjYWxlWSk7XG4gICAgICBvYmplY3Quc2tld1ggPSBvcHRpb25zLnNrZXdYO1xuICAgICAgb2JqZWN0LnNrZXdZID0gb3B0aW9ucy5za2V3WTtcbiAgICAgIG9iamVjdC5hbmdsZSA9IG9wdGlvbnMuYW5nbGU7XG4gICAgICBvYmplY3Quc2V0UG9zaXRpb25CeU9yaWdpbihjZW50ZXIsICdjZW50ZXInLCAnY2VudGVyJyk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyBvcmlnaW5hbCBzdGF0ZSBvZiBhIHNwZWNpZmllZCBvYmplY3QgaW4gZ3JvdXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICovXG4gICAgX3Jlc3RvcmVPYmplY3RTdGF0ZTogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB0aGlzLnJlYWxpemVUcmFuc2Zvcm0ob2JqZWN0KTtcbiAgICAgIG9iamVjdC5zZXRDb29yZHMoKTtcbiAgICAgIG9iamVjdC5oYXNDb250cm9scyA9IG9iamVjdC5fX29yaWdIYXNDb250cm9scztcbiAgICAgIGRlbGV0ZSBvYmplY3QuX19vcmlnSGFzQ29udHJvbHM7XG4gICAgICBvYmplY3Quc2V0KCdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICBkZWxldGUgb2JqZWN0Lmdyb3VwO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYSBncm91cCAocmVzdG9yaW5nIHN0YXRlIG9mIGl0cyBvYmplY3RzKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXN0b3JlT2JqZWN0c1N0YXRlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNhdmVzIGNvb3JkaW5hdGVzIG9mIHRoaXMgaW5zdGFuY2UgKHRvIGJlIHVzZWQgdG9nZXRoZXIgd2l0aCBgaGFzTW92ZWRgKVxuICAgICAqIEBzYXZlQ29vcmRzXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNhdmVDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fb3JpZ2luYWxMZWZ0ID0gdGhpcy5nZXQoJ2xlZnQnKTtcbiAgICAgIHRoaXMuX29yaWdpbmFsVG9wID0gdGhpcy5nZXQoJ3RvcCcpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgZ3JvdXAgd2FzIG1vdmVkIChzaW5jZSBgc2F2ZUNvb3Jkc2Agd2FzIGNhbGxlZCBsYXN0KVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgYW4gb2JqZWN0IHdhcyBtb3ZlZCAoc2luY2UgZmFicmljLkdyb3VwI3NhdmVDb29yZHMgd2FzIGNhbGxlZClcbiAgICAgKi9cbiAgICBoYXNNb3ZlZDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb3JpZ2luYWxMZWZ0ICE9PSB0aGlzLmdldCgnbGVmdCcpIHx8XG4gICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxUb3AgIT09IHRoaXMuZ2V0KCd0b3AnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBjb29yZGluYXRlcyBvZiBhbGwgZ3JvdXAgb2JqZWN0c1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRPYmplY3RzQ29vcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpZ25vcmVab29tID0gdHJ1ZTtcbiAgICAgIHRoaXMuZm9yRWFjaE9iamVjdChmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgb2JqZWN0LnNldENvb3JkcyhpZ25vcmVab29tKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGNCb3VuZHM6IGZ1bmN0aW9uKG9ubHlXaWR0aEhlaWdodCkge1xuICAgICAgdmFyIGFYID0gW10sXG4gICAgICAgICAgYVkgPSBbXSxcbiAgICAgICAgICBvLCBwcm9wLFxuICAgICAgICAgIHByb3BzID0gWyd0cicsICdicicsICdibCcsICd0bCddLFxuICAgICAgICAgIGkgPSAwLCBpTGVuID0gdGhpcy5fb2JqZWN0cy5sZW5ndGgsXG4gICAgICAgICAgaiwgakxlbiA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICBpZ25vcmVab29tID0gdHJ1ZTtcblxuICAgICAgZm9yICggOyBpIDwgaUxlbjsgKytpKSB7XG4gICAgICAgIG8gPSB0aGlzLl9vYmplY3RzW2ldO1xuICAgICAgICBvLnNldENvb3JkcyhpZ25vcmVab29tKTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGorKykge1xuICAgICAgICAgIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgICAgICBhWC5wdXNoKG8ub0Nvb3Jkc1twcm9wXS54KTtcbiAgICAgICAgICBhWS5wdXNoKG8ub0Nvb3Jkc1twcm9wXS55KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnNldCh0aGlzLl9nZXRCb3VuZHMoYVgsIGFZLCBvbmx5V2lkdGhIZWlnaHQpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Qm91bmRzOiBmdW5jdGlvbihhWCwgYVksIG9ubHlXaWR0aEhlaWdodCkge1xuICAgICAgdmFyIG1pblhZID0gbmV3IGZhYnJpYy5Qb2ludChtaW4oYVgpLCBtaW4oYVkpKSxcbiAgICAgICAgICBtYXhYWSA9IG5ldyBmYWJyaWMuUG9pbnQobWF4KGFYKSwgbWF4KGFZKSksXG4gICAgICAgICAgb2JqID0ge1xuICAgICAgICAgICAgd2lkdGg6IChtYXhYWS54IC0gbWluWFkueCkgfHwgMCxcbiAgICAgICAgICAgIGhlaWdodDogKG1heFhZLnkgLSBtaW5YWS55KSB8fCAwXG4gICAgICAgICAgfTtcblxuICAgICAgaWYgKCFvbmx5V2lkdGhIZWlnaHQpIHtcbiAgICAgICAgb2JqLmxlZnQgPSBtaW5YWS54IHx8IDA7XG4gICAgICAgIG9iai50b3AgPSBtaW5YWS55IHx8IDA7XG4gICAgICAgIGlmICh0aGlzLm9yaWdpblggPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgb2JqLmxlZnQgKz0gb2JqLndpZHRoIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcmlnaW5YID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgb2JqLmxlZnQgKz0gb2JqLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9yaWdpblkgPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgb2JqLnRvcCArPSBvYmouaGVpZ2h0IC8gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcmlnaW5ZID09PSAnYm90dG9tJykge1xuICAgICAgICAgIG9iai50b3AgKz0gb2JqLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIG1hcmt1cCA9IHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAoKTtcbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPGcgJywgdGhpcy5nZXRTdmdJZCgpLCAndHJhbnNmb3JtPVwiJyxcbiAgICAgICAgLyogYXZvaWRpbmcgc3R5bGVzIGludGVudGlvbmFsbHkgKi9cbiAgICAgICAgdGhpcy5nZXRTdmdUcmFuc2Zvcm0oKSxcbiAgICAgICAgdGhpcy5nZXRTdmdUcmFuc2Zvcm1NYXRyaXgoKSxcbiAgICAgICAgJ1wiIHN0eWxlPVwiJyxcbiAgICAgICAgdGhpcy5nZXRTdmdGaWx0ZXIoKSxcbiAgICAgICAgJ1wiPlxcbidcbiAgICAgICk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKCdcXHQnLCB0aGlzLl9vYmplY3RzW2ldLnRvU1ZHKHJldml2ZXIpKTtcbiAgICAgIH1cblxuICAgICAgbWFya3VwLnB1c2goJzwvZz5cXG4nKTtcblxuICAgICAgcmV0dXJuIHJldml2ZXIgPyByZXZpdmVyKG1hcmt1cC5qb2luKCcnKSkgOiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmVxdWVzdGVkIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3AgUHJvcGVydHkgdG8gZ2V0XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgIGlmIChwcm9wIGluIF9sb2NrUHJvcGVydGllcykge1xuICAgICAgICBpZiAodGhpc1twcm9wXSkge1xuICAgICAgICAgIHJldHVybiB0aGlzW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb2JqZWN0c1tpXVtwcm9wXSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHByb3AgaW4gdGhpcy5kZWxlZ2F0ZWRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX29iamVjdHNbMF0gJiYgdGhpcy5fb2JqZWN0c1swXS5nZXQocHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkdyb3VwfSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuR3JvdXBcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGEgZ3JvdXAgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGdyb3VwIGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICovXG4gIGZhYnJpYy5Hcm91cC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKG9iamVjdC5vYmplY3RzLCBmdW5jdGlvbihlbmxpdmVuZWRPYmplY3RzKSB7XG4gICAgICBkZWxldGUgb2JqZWN0Lm9iamVjdHM7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhuZXcgZmFicmljLkdyb3VwKGVubGl2ZW5lZE9iamVjdHMsIG9iamVjdCwgdHJ1ZSkpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhhdCBpbnN0YW5jZXMgb2YgdGhpcyB0eXBlIGFyZSBhc3luY1xuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuR3JvdXBcbiAgICogQHR5cGUgQm9vbGVhblxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgZmFicmljLkdyb3VwLmFzeW5jID0gdHJ1ZTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQ7XG5cbiAgaWYgKCFnbG9iYWwuZmFicmljKSB7XG4gICAgZ2xvYmFsLmZhYnJpYyA9IHsgfTtcbiAgfVxuXG4gIGlmIChnbG9iYWwuZmFicmljLkltYWdlKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5JbWFnZSBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHN0YXRlUHJvcGVydGllcyA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnN0YXRlUHJvcGVydGllcy5jb25jYXQoKTtcbiAgc3RhdGVQcm9wZXJ0aWVzLnB1c2goXG4gICAgJ2FsaWduWCcsXG4gICAgJ2FsaWduWScsXG4gICAgJ21lZXRPclNsaWNlJ1xuICApO1xuXG4gIC8qKlxuICAgKiBJbWFnZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTEjaW1hZ2VzfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5JbWFnZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2ltYWdlJyxcblxuICAgIC8qKlxuICAgICAqIGNyb3NzT3JpZ2luIHZhbHVlIChvbmUgb2YgXCJcIiwgXCJhbm9ueW1vdXNcIiwgXCJ1c2UtY3JlZGVudGlhbHNcIilcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNyb3NzT3JpZ2luOiAnJyxcblxuICAgIC8qKlxuICAgICAqIEFsaWduWCB2YWx1ZSwgcGFydCBvZiBwcmVzZXJ2ZUFzcGVjdFJhdGlvIChvbmUgb2YgXCJub25lXCIsIFwibWlkXCIsIFwibWluXCIsIFwibWF4XCIpXG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvY29vcmRzLmh0bWwjUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZVxuICAgICAqIFRoaXMgcGFyYW1ldGVyIGRlZmluZXMgaG93IHRoZSBwaWN0dXJlIGlzIGFsaWduZWQgdG8gaXRzIHZpZXdwb3J0IHdoZW4gaW1hZ2UgZWxlbWVudCB3aWR0aCBkaWZmZXJzIGZyb20gaW1hZ2Ugd2lkdGguXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBhbGlnblg6ICdub25lJyxcblxuICAgIC8qKlxuICAgICAqIEFsaWduWSB2YWx1ZSwgcGFydCBvZiBwcmVzZXJ2ZUFzcGVjdFJhdGlvIChvbmUgb2YgXCJub25lXCIsIFwibWlkXCIsIFwibWluXCIsIFwibWF4XCIpXG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvY29vcmRzLmh0bWwjUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZVxuICAgICAqIFRoaXMgcGFyYW1ldGVyIGRlZmluZXMgaG93IHRoZSBwaWN0dXJlIGlzIGFsaWduZWQgdG8gaXRzIHZpZXdwb3J0IHdoZW4gaW1hZ2UgZWxlbWVudCBoZWlnaHQgZGlmZmVycyBmcm9tIGltYWdlIGhlaWdodC5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGFsaWduWTogJ25vbmUnLFxuXG4gICAgLyoqXG4gICAgICogbWVldE9yU2xpY2UgdmFsdWUsIHBhcnQgb2YgcHJlc2VydmVBc3BlY3RSYXRpbyAgKG9uZSBvZiBcIm1lZXRcIiwgXCJzbGljZVwiKS5cbiAgICAgKiBpZiBtZWV0IHRoZSBpbWFnZSBpcyBhbHdheXMgZnVsbHkgdmlzaWJpbGUsIGlmIHNsaWNlIHRoZSB2aWV3cG9ydCBpcyBhbHdheXMgZmlsbGVkIHdpdGggaW1hZ2UuXG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvY29vcmRzLmh0bWwjUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWVldE9yU2xpY2U6ICdtZWV0JyxcblxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIGEgc3Ryb2tlLlxuICAgICAqIEZvciBpbWFnZSBxdWFsaXR5IGEgc3Ryb2tlIG11bHRpcGxlIG9mIDIgZ2l2ZXMgYmV0dGVyIHJlc3VsdHMuXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2VXaWR0aDogMCxcblxuICAgIC8qKlxuICAgICAqIHByaXZhdGVcbiAgICAgKiBjb250YWlucyBsYXN0IHZhbHVlIG9mIHNjYWxlWCB0byBkZXRlY3RcbiAgICAgKiBpZiB0aGUgSW1hZ2UgZ290IHJlc2l6ZWQgYWZ0ZXIgdGhlIGxhc3QgUmVuZGVyXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgX2xhc3RTY2FsZVg6IDEsXG5cbiAgICAvKipcbiAgICAgKiBwcml2YXRlXG4gICAgICogY29udGFpbnMgbGFzdCB2YWx1ZSBvZiBzY2FsZVkgdG8gZGV0ZWN0XG4gICAgICogaWYgdGhlIEltYWdlIGdvdCByZXNpemVkIGFmdGVyIHRoZSBsYXN0IFJlbmRlclxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIF9sYXN0U2NhbGVZOiAxLFxuXG4gICAgLyoqXG4gICAgICogbWluaW11bSBzY2FsZSBmYWN0b3IgdW5kZXIgd2hpY2ggYW55IHJlc2l6ZUZpbHRlciBpcyB0cmlnZ2VyZWQgdG8gcmVzaXplIHRoZSBpbWFnZVxuICAgICAqIDAgd2lsbCBkaXNhYmxlIHRoZSBhdXRvbWF0aWMgcmVzaXplLiAxIHdpbGwgdHJpZ2dlciBhdXRvbWF0aWNhbGx5IGFsd2F5cy5cbiAgICAgKiBudW1iZXIgYmlnZ2VyIHRoYW4gMSBjYW4gYmUgdXNlZCBpbiBjYXNlIHdlIHdhbnQgdG8gc2NhbGUgd2l0aCBzb21lIGZpbHRlciBhYm92ZVxuICAgICAqIHRoZSBuYXR1cmFsIGltYWdlIGRpbWVuc2lvbnNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICBtaW5pbXVtU2NhbGVUcmlnZ2VyOiAwLjUsXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZlxuICAgICAqIHN0YXRlIG9mIGFuIG9iamVjdCBpcyBjaGFuZ2VkICh7QGxpbmsgZmFicmljLk9iamVjdCNoYXNTdGF0ZUNoYW5nZWR9KVxuICAgICAqIGFzIHdlbGwgYXMgZm9yIGhpc3RvcnkgKHVuZG8vcmVkbykgcHVycG9zZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHN0YXRlUHJvcGVydGllczogc3RhdGVQcm9wZXJ0aWVzLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBpcyBjYWNoZWQgb24gYW4gYWRkaXRpb25hbCBjYW52YXMuXG4gICAgICogZGVmYXVsdCB0byBmYWxzZSBmb3IgaW1hZ2VzXG4gICAgICogc2luY2UgMS43LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvYmplY3RDYWNoaW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50IHwgU3RyaW5nfSBlbGVtZW50IEltYWdlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIGFmdGVyIGV2ZW50dWFsIGZpbHRlcnMgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2V9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICB0aGlzLmZpbHRlcnMgPSBbXTtcbiAgICAgIHRoaXMucmVzaXplRmlsdGVycyA9IFtdO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX2luaXRFbGVtZW50KGVsZW1lbnQsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbWFnZSBlbGVtZW50IHdoaWNoIHRoaXMgaW5zdGFuY2UgaWYgYmFzZWQgb25cbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBJbWFnZSBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0RWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBpbWFnZSBlbGVtZW50IGZvciB0aGlzIGluc3RhbmNlIHRvIGEgc3BlY2lmaWVkIG9uZS5cbiAgICAgKiBJZiBmaWx0ZXJzIGRlZmluZWQgdGhleSBhcmUgYXBwbGllZCB0byBuZXcgaW1hZ2UuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgY2FudmFzLnJlbmRlckFsbGAgYW5kIGBvYmplY3Quc2V0Q29vcmRzYCBhZnRlciByZXBsYWNpbmcsIHRvIHJlbmRlciBuZXcgaW1hZ2UgYW5kIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgaXMgaW52b2tlZCB3aGVuIGFsbCBmaWx0ZXJzIGhhdmUgYmVlbiBhcHBsaWVkIGFuZCBuZXcgaW1hZ2UgaXMgZ2VuZXJhdGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZX0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRFbGVtZW50OiBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuXG4gICAgICB2YXIgX2NhbGxiYWNrLCBfdGhpcztcblxuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLl9vcmlnaW5hbEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5faW5pdENvbmZpZyhvcHRpb25zKTtcblxuICAgICAgaWYgKHRoaXMucmVzaXplRmlsdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgX2NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfY2FsbGJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBfdGhpcy5hcHBseUZpbHRlcnMoY2FsbGJhY2ssIF90aGlzLnJlc2l6ZUZpbHRlcnMsIF90aGlzLl9maWx0ZXJlZEVsIHx8IF90aGlzLl9vcmlnaW5hbEVsZW1lbnQsIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5maWx0ZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICB0aGlzLmFwcGx5RmlsdGVycyhfY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoX2NhbGxiYWNrKSB7XG4gICAgICAgIF9jYWxsYmFjayh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgY3Jvc3NPcmlnaW4gdmFsdWUgKG9uIGFuIGluc3RhbmNlIGFuZCBjb3JyZXNwb25kaW5nIGltYWdlIGVsZW1lbnQpXG4gICAgICogQHJldHVybiB7ZmFicmljLkltYWdlfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuICAgICAgdGhpcy5fZWxlbWVudC5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvcmlnaW5hbCBzaXplIG9mIGFuIGltYWdlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBcIndpZHRoXCIgYW5kIFwiaGVpZ2h0XCIgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdldE9yaWdpbmFsU2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IGVsZW1lbnQud2lkdGgsXG4gICAgICAgIGhlaWdodDogZWxlbWVudC5oZWlnaHRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9zdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnN0cm9rZSB8fCB0aGlzLnN0cm9rZVdpZHRoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB3ID0gdGhpcy53aWR0aCAvIDIsIGggPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKC13LCAtaCk7XG4gICAgICBjdHgubGluZVRvKHcsIC1oKTtcbiAgICAgIGN0eC5saW5lVG8odywgaCk7XG4gICAgICBjdHgubGluZVRvKC13LCBoKTtcbiAgICAgIGN0eC5saW5lVG8oLXcsIC1oKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckRhc2hlZFN0cm9rZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgeCA9IC10aGlzLndpZHRoIC8gMixcbiAgICAgICAgICB5ID0gLXRoaXMuaGVpZ2h0IC8gMixcbiAgICAgICAgICB3ID0gdGhpcy53aWR0aCxcbiAgICAgICAgICBoID0gdGhpcy5oZWlnaHQ7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLl9zZXRTdHJva2VTdHlsZXMoY3R4KTtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCB4LCB5LCB4ICsgdywgeSwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCB4ICsgdywgeSwgeCArIHcsIHkgKyBoLCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHggKyB3LCB5ICsgaCwgeCwgeSArIGgsIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgeCwgeSArIGgsIHgsIHksIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBmaWx0ZXJzID0gW10sIHJlc2l6ZUZpbHRlcnMgPSBbXSxcbiAgICAgICAgICBzY2FsZVggPSAxLCBzY2FsZVkgPSAxO1xuXG4gICAgICB0aGlzLmZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWx0ZXJPYmopIHtcbiAgICAgICAgaWYgKGZpbHRlck9iaikge1xuICAgICAgICAgIGlmIChmaWx0ZXJPYmoudHlwZSA9PT0gJ1Jlc2l6ZScpIHtcbiAgICAgICAgICAgIHNjYWxlWCAqPSBmaWx0ZXJPYmouc2NhbGVYO1xuICAgICAgICAgICAgc2NhbGVZICo9IGZpbHRlck9iai5zY2FsZVk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbHRlcnMucHVzaChmaWx0ZXJPYmoudG9PYmplY3QoKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnJlc2l6ZUZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWx0ZXJPYmopIHtcbiAgICAgICAgZmlsdGVyT2JqICYmIHJlc2l6ZUZpbHRlcnMucHVzaChmaWx0ZXJPYmoudG9PYmplY3QoKSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBvYmplY3QgPSBleHRlbmQoXG4gICAgICAgIHRoaXMuY2FsbFN1cGVyKFxuICAgICAgICAgICd0b09iamVjdCcsXG4gICAgICAgICAgWydjcm9zc09yaWdpbicsICdhbGlnblgnLCAnYWxpZ25ZJywgJ21lZXRPclNsaWNlJ10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpXG4gICAgICAgICksIHtcbiAgICAgICAgICBzcmM6IHRoaXMuZ2V0U3JjKCksXG4gICAgICAgICAgZmlsdGVyczogZmlsdGVycyxcbiAgICAgICAgICByZXNpemVGaWx0ZXJzOiByZXNpemVGaWx0ZXJzLFxuICAgICAgICB9KTtcblxuICAgICAgb2JqZWN0LndpZHRoIC89IHNjYWxlWDtcbiAgICAgIG9iamVjdC5oZWlnaHQgLz0gc2NhbGVZO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICB2YXIgbWFya3VwID0gdGhpcy5fY3JlYXRlQmFzZVNWR01hcmt1cCgpLCB4ID0gLXRoaXMud2lkdGggLyAyLCB5ID0gLXRoaXMuaGVpZ2h0IC8gMixcbiAgICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gJ25vbmUnLCBmaWx0ZXJlZCA9IHRydWU7XG4gICAgICBpZiAodGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLnR5cGUgPT09ICdwYXRoLWdyb3VwJykge1xuICAgICAgICB4ID0gdGhpcy5sZWZ0O1xuICAgICAgICB5ID0gdGhpcy50b3A7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5hbGlnblggIT09ICdub25lJyAmJiB0aGlzLmFsaWduWSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW8gPSAneCcgKyB0aGlzLmFsaWduWCArICdZJyArIHRoaXMuYWxpZ25ZICsgJyAnICsgdGhpcy5tZWV0T3JTbGljZTtcbiAgICAgIH1cbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPGcgdHJhbnNmb3JtPVwiJywgdGhpcy5nZXRTdmdUcmFuc2Zvcm0oKSwgdGhpcy5nZXRTdmdUcmFuc2Zvcm1NYXRyaXgoKSwgJ1wiPlxcbicsXG4gICAgICAgICAgJzxpbWFnZSAnLCB0aGlzLmdldFN2Z0lkKCksICd4bGluazpocmVmPVwiJywgdGhpcy5nZXRTdmdTcmMoZmlsdGVyZWQpLFxuICAgICAgICAgICAgJ1wiIHg9XCInLCB4LCAnXCIgeT1cIicsIHksXG4gICAgICAgICAgICAnXCIgc3R5bGU9XCInLCB0aGlzLmdldFN2Z1N0eWxlcygpLFxuICAgICAgICAgICAgLy8gd2UncmUgZXNzZW50aWFsbHkgbW92aW5nIG9yaWdpbiBvZiB0cmFuc2Zvcm1hdGlvbiBmcm9tIHRvcC9sZWZ0IGNvcm5lciB0byB0aGUgY2VudGVyIG9mIHRoZSBzaGFwZVxuICAgICAgICAgICAgLy8gYnkgd3JhcHBpbmcgaXQgaW4gY29udGFpbmVyIDxnPiBlbGVtZW50IHdpdGggYWN0dWFsIHRyYW5zZm9ybWF0aW9uLCB0aGVuIG9mZnNldHRpbmcgb2JqZWN0IHRvIHRoZSB0b3AvbGVmdFxuICAgICAgICAgICAgLy8gc28gdGhhdCBvYmplY3QncyBjZW50ZXIgYWxpZ25zIHdpdGggY29udGFpbmVyJ3MgbGVmdC90b3BcbiAgICAgICAgICAgICdcIiB3aWR0aD1cIicsIHRoaXMud2lkdGgsXG4gICAgICAgICAgICAnXCIgaGVpZ2h0PVwiJywgdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICAnXCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cIicsIHByZXNlcnZlQXNwZWN0UmF0aW8sICdcIicsXG4gICAgICAgICAgJz48L2ltYWdlPlxcbidcbiAgICAgICk7XG5cbiAgICAgIGlmICh0aGlzLnN0cm9rZSB8fCB0aGlzLnN0cm9rZURhc2hBcnJheSkge1xuICAgICAgICB2YXIgb3JpZ0ZpbGwgPSB0aGlzLmZpbGw7XG4gICAgICAgIHRoaXMuZmlsbCA9IG51bGw7XG4gICAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAgICc8cmVjdCAnLFxuICAgICAgICAgICAgJ3g9XCInLCB4LCAnXCIgeT1cIicsIHksXG4gICAgICAgICAgICAnXCIgd2lkdGg9XCInLCB0aGlzLndpZHRoLCAnXCIgaGVpZ2h0PVwiJywgdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICAnXCIgc3R5bGU9XCInLCB0aGlzLmdldFN2Z1N0eWxlcygpLFxuICAgICAgICAgICdcIi8+XFxuJ1xuICAgICAgICApO1xuICAgICAgICB0aGlzLmZpbGwgPSBvcmlnRmlsbDtcbiAgICAgIH1cblxuICAgICAgbWFya3VwLnB1c2goJzwvZz5cXG4nKTtcblxuICAgICAgcmV0dXJuIHJldml2ZXIgPyByZXZpdmVyKG1hcmt1cC5qb2luKCcnKSkgOiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc291cmNlIG9mIGFuIGltYWdlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBmaWx0ZXJlZCBpbmRpY2F0ZXMgaWYgdGhlIHNyYyBpcyBuZWVkZWQgZm9yIHN2Z1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU291cmNlIG9mIGFuIGltYWdlXG4gICAgICovXG4gICAgZ2V0U3JjOiBmdW5jdGlvbihmaWx0ZXJlZCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBmaWx0ZXJlZCA/IHRoaXMuX2VsZW1lbnQgOiB0aGlzLl9vcmlnaW5hbEVsZW1lbnQ7XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZmFicmljLmlzTGlrZWx5Tm9kZSA/IGVsZW1lbnQuX3NyYyA6IGVsZW1lbnQuc3JjO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNyYyB8fCAnJztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzb3VyY2Ugb2YgYW4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFNvdXJjZSBzdHJpbmcgKFVSTClcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIGlzIGludm9rZWQgd2hlbiBpbWFnZSBoYXMgYmVlbiBsb2FkZWQgKGFuZCBhbGwgZmlsdGVycyBoYXZlIGJlZW4gYXBwbGllZClcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkltYWdlfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFNyYzogZnVuY3Rpb24oc3JjLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgZmFicmljLnV0aWwubG9hZEltYWdlKHNyYywgZnVuY3Rpb24oaW1nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldEVsZW1lbnQoaW1nLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgICB9LCB0aGlzLCBvcHRpb25zICYmIG9wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5JbWFnZTogeyBzcmM6IFwiJyArIHRoaXMuZ2V0U3JjKCkgKyAnXCIgfT4nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlcnMgYXNzaWduZWQgdG8gdGhpcyBpbWFnZSAoZnJvbSBcImZpbHRlcnNcIiBhcnJheSlcbiAgICAgKiBAbWV0aG9kIGFwcGx5RmlsdGVyc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGlzIGludm9rZWQgd2hlbiBhbGwgZmlsdGVycyBoYXZlIGJlZW4gYXBwbGllZCBhbmQgbmV3IGltYWdlIGlzIGdlbmVyYXRlZFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcnMgdG8gYmUgYXBwbGllZFxuICAgICAqIEBwYXJhbSB7ZmFicmljLkltYWdlfSBpbWdFbGVtZW50IGltYWdlIHRvIGZpbHRlciAoIGRlZmF1bHQgdG8gdGhpcy5fZWxlbWVudCApXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBmb3JSZXNpemluZ1xuICAgICAqIEByZXR1cm4ge0NhbnZhc0VsZW1lbnR9IGNhbnZhc0VsIHRvIGJlIGRyYXduIGltbWVkaWF0ZWx5XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFwcGx5RmlsdGVyczogZnVuY3Rpb24oY2FsbGJhY2ssIGZpbHRlcnMsIGltZ0VsZW1lbnQsIGZvclJlc2l6aW5nKSB7XG5cbiAgICAgIGZpbHRlcnMgPSBmaWx0ZXJzIHx8IHRoaXMuZmlsdGVycztcbiAgICAgIGltZ0VsZW1lbnQgPSBpbWdFbGVtZW50IHx8IHRoaXMuX29yaWdpbmFsRWxlbWVudDtcblxuICAgICAgaWYgKCFpbWdFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlcGxhY2VtZW50ID0gZmFicmljLnV0aWwuY3JlYXRlSW1hZ2UoKSxcbiAgICAgICAgICByZXRpbmFTY2FsaW5nID0gdGhpcy5jYW52YXMgPyB0aGlzLmNhbnZhcy5nZXRSZXRpbmFTY2FsaW5nKCkgOiBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgICAgICBtaW5pbXVtU2NhbGUgPSB0aGlzLm1pbmltdW1TY2FsZVRyaWdnZXIgLyByZXRpbmFTY2FsaW5nLFxuICAgICAgICAgIF90aGlzID0gdGhpcywgc2NhbGVYLCBzY2FsZVk7XG5cbiAgICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gaW1nRWxlbWVudDtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sodGhpcyk7XG4gICAgICAgIHJldHVybiBpbWdFbGVtZW50O1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FudmFzRWwgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICBjYW52YXNFbC53aWR0aCA9IGltZ0VsZW1lbnQud2lkdGg7XG4gICAgICBjYW52YXNFbC5oZWlnaHQgPSBpbWdFbGVtZW50LmhlaWdodDtcbiAgICAgIGNhbnZhc0VsLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKGltZ0VsZW1lbnQsIDAsIDAsIGltZ0VsZW1lbnQud2lkdGgsIGltZ0VsZW1lbnQuaGVpZ2h0KTtcblxuICAgICAgZmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICBpZiAoIWZpbHRlcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9yUmVzaXppbmcpIHtcbiAgICAgICAgICBzY2FsZVggPSBfdGhpcy5zY2FsZVggPCBtaW5pbXVtU2NhbGUgPyBfdGhpcy5zY2FsZVggOiAxO1xuICAgICAgICAgIHNjYWxlWSA9IF90aGlzLnNjYWxlWSA8IG1pbmltdW1TY2FsZSA/IF90aGlzLnNjYWxlWSA6IDE7XG4gICAgICAgICAgaWYgKHNjYWxlWCAqIHJldGluYVNjYWxpbmcgPCAxKSB7XG4gICAgICAgICAgICBzY2FsZVggKj0gcmV0aW5hU2NhbGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNjYWxlWSAqIHJldGluYVNjYWxpbmcgPCAxKSB7XG4gICAgICAgICAgICBzY2FsZVkgKj0gcmV0aW5hU2NhbGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2NhbGVYID0gZmlsdGVyLnNjYWxlWDtcbiAgICAgICAgICBzY2FsZVkgPSBmaWx0ZXIuc2NhbGVZO1xuICAgICAgICB9XG4gICAgICAgIGZpbHRlci5hcHBseVRvKGNhbnZhc0VsLCBzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgIGlmICghZm9yUmVzaXppbmcgJiYgZmlsdGVyLnR5cGUgPT09ICdSZXNpemUnKSB7XG4gICAgICAgICAgX3RoaXMud2lkdGggKj0gZmlsdGVyLnNjYWxlWDtcbiAgICAgICAgICBfdGhpcy5oZWlnaHQgKj0gZmlsdGVyLnNjYWxlWTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8qKiBAaWdub3JlICovXG4gICAgICByZXBsYWNlbWVudC53aWR0aCA9IGNhbnZhc0VsLndpZHRoO1xuICAgICAgcmVwbGFjZW1lbnQuaGVpZ2h0ID0gY2FudmFzRWwuaGVpZ2h0O1xuICAgICAgaWYgKGZhYnJpYy5pc0xpa2VseU5vZGUpIHtcbiAgICAgICAgcmVwbGFjZW1lbnQuc3JjID0gY2FudmFzRWwudG9CdWZmZXIodW5kZWZpbmVkLCBmYWJyaWMuSW1hZ2UucG5nQ29tcHJlc3Npb24pO1xuICAgICAgICAvLyBvbmxvYWQgZG9lc24ndCBmaXJlIGluIHNvbWUgbm9kZSB2ZXJzaW9ucywgc28gd2UgaW52b2tlIGNhbGxiYWNrIG1hbnVhbGx5XG4gICAgICAgIF90aGlzLl9lbGVtZW50ID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICFmb3JSZXNpemluZyAmJiAoX3RoaXMuX2ZpbHRlcmVkRWwgPSByZXBsYWNlbWVudCk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKF90aGlzKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXBsYWNlbWVudC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBfdGhpcy5fZWxlbWVudCA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICFmb3JSZXNpemluZyAmJiAoX3RoaXMuX2ZpbHRlcmVkRWwgPSByZXBsYWNlbWVudCk7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soX3RoaXMpO1xuICAgICAgICAgIHJlcGxhY2VtZW50Lm9ubG9hZCA9IGNhbnZhc0VsID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgcmVwbGFjZW1lbnQuc3JjID0gY2FudmFzRWwudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYW52YXNFbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBub1RyYW5zZm9ybVxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCwgbm9UcmFuc2Zvcm0pIHtcbiAgICAgIHZhciB4LCB5LCBpbWFnZU1hcmdpbnMgPSB0aGlzLl9maW5kTWFyZ2lucygpLCBlbGVtZW50VG9EcmF3O1xuXG4gICAgICB4ID0gKG5vVHJhbnNmb3JtID8gdGhpcy5sZWZ0IDogLXRoaXMud2lkdGggLyAyKTtcbiAgICAgIHkgPSAobm9UcmFuc2Zvcm0gPyB0aGlzLnRvcCA6IC10aGlzLmhlaWdodCAvIDIpO1xuXG4gICAgICBpZiAodGhpcy5tZWV0T3JTbGljZSA9PT0gJ3NsaWNlJykge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5yZWN0KHgsIHksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNNb3ZpbmcgPT09IGZhbHNlICYmIHRoaXMucmVzaXplRmlsdGVycy5sZW5ndGggJiYgdGhpcy5fbmVlZHNSZXNpemUoKSkge1xuICAgICAgICB0aGlzLl9sYXN0U2NhbGVYID0gdGhpcy5zY2FsZVg7XG4gICAgICAgIHRoaXMuX2xhc3RTY2FsZVkgPSB0aGlzLnNjYWxlWTtcbiAgICAgICAgZWxlbWVudFRvRHJhdyA9IHRoaXMuYXBwbHlGaWx0ZXJzKG51bGwsIHRoaXMucmVzaXplRmlsdGVycywgdGhpcy5fZmlsdGVyZWRFbCB8fCB0aGlzLl9vcmlnaW5hbEVsZW1lbnQsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGVsZW1lbnRUb0RyYXcgPSB0aGlzLl9lbGVtZW50O1xuICAgICAgfVxuICAgICAgZWxlbWVudFRvRHJhdyAmJiBjdHguZHJhd0ltYWdlKGVsZW1lbnRUb0RyYXcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCArIGltYWdlTWFyZ2lucy5tYXJnaW5YLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKyBpbWFnZU1hcmdpbnMubWFyZ2luWSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU1hcmdpbnMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VNYXJnaW5zLmhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgdGhpcy5fc3Ryb2tlKGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJTdHJva2UoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGUsIG5lZWRlZCB0byBjaGVjayBpZiBpbWFnZSBuZWVkcyByZXNpemVcbiAgICAgKi9cbiAgICBfbmVlZHNSZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICh0aGlzLnNjYWxlWCAhPT0gdGhpcy5fbGFzdFNjYWxlWCB8fCB0aGlzLnNjYWxlWSAhPT0gdGhpcy5fbGFzdFNjYWxlWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbmRNYXJnaW5zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGgsIGhlaWdodCA9IHRoaXMuaGVpZ2h0LCBzY2FsZXMsXG4gICAgICAgICAgc2NhbGUsIG1hcmdpblggPSAwLCBtYXJnaW5ZID0gMDtcblxuICAgICAgaWYgKHRoaXMuYWxpZ25YICE9PSAnbm9uZScgfHwgdGhpcy5hbGlnblkgIT09ICdub25lJykge1xuICAgICAgICBzY2FsZXMgPSBbdGhpcy53aWR0aCAvIHRoaXMuX2VsZW1lbnQud2lkdGgsIHRoaXMuaGVpZ2h0IC8gdGhpcy5fZWxlbWVudC5oZWlnaHRdO1xuICAgICAgICBzY2FsZSA9IHRoaXMubWVldE9yU2xpY2UgPT09ICdtZWV0J1xuICAgICAgICAgICAgICAgID8gTWF0aC5taW4uYXBwbHkobnVsbCwgc2NhbGVzKSA6IE1hdGgubWF4LmFwcGx5KG51bGwsIHNjYWxlcyk7XG4gICAgICAgIHdpZHRoID0gdGhpcy5fZWxlbWVudC53aWR0aCAqIHNjYWxlO1xuICAgICAgICBoZWlnaHQgPSB0aGlzLl9lbGVtZW50LmhlaWdodCAqIHNjYWxlO1xuICAgICAgICBpZiAodGhpcy5hbGlnblggPT09ICdNaWQnKSB7XG4gICAgICAgICAgbWFyZ2luWCA9ICh0aGlzLndpZHRoIC0gd2lkdGgpIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbGlnblggPT09ICdNYXgnKSB7XG4gICAgICAgICAgbWFyZ2luWCA9IHRoaXMud2lkdGggLSB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbGlnblkgPT09ICdNaWQnKSB7XG4gICAgICAgICAgbWFyZ2luWSA9ICh0aGlzLmhlaWdodCAtIGhlaWdodCkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFsaWduWSA9PT0gJ01heCcpIHtcbiAgICAgICAgICBtYXJnaW5ZID0gdGhpcy5oZWlnaHQgLSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiAgd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICBtYXJnaW5YOiBtYXJnaW5YLFxuICAgICAgICBtYXJnaW5ZOiBtYXJnaW5ZXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNldFdpZHRoSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCk7XG5cbiAgICAgIHRoaXMuc2V0KCd3aWR0aCcsIGVsZW1lbnQud2lkdGgpO1xuICAgICAgdGhpcy5zZXQoJ2hlaWdodCcsIGVsZW1lbnQuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIEltYWdlIGNsYXNzJ3MgaW5pdGlhbGl6YXRpb24gbWV0aG9kLiBUaGlzIG1ldGhvZCBpcyBhdXRvbWF0aWNhbGx5XG4gICAgICogY2FsbGVkIGJ5IHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxTdHJpbmd9IGVsZW1lbnQgVGhlIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBpbWFnZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBfaW5pdEVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnNldEVsZW1lbnQoZmFicmljLnV0aWwuZ2V0QnlJZChlbGVtZW50KSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICAgICAgZmFicmljLnV0aWwuYWRkQ2xhc3ModGhpcy5nZXRFbGVtZW50KCksIGZhYnJpYy5JbWFnZS5DU1NfQ0FOVkFTKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgX2luaXRDb25maWc6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc2V0V2lkdGhIZWlnaHQob3B0aW9ucyk7XG4gICAgICBpZiAodGhpcy5fZWxlbWVudCAmJiB0aGlzLmNyb3NzT3JpZ2luKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcnMgdG8gYmUgaW5pdGlhbGl6ZWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbGwgZmFicmljLkltYWdlLmZpbHRlcnMgaW5zdGFuY2VzIGFyZSBjcmVhdGVkXG4gICAgICovXG4gICAgX2luaXRGaWx0ZXJzOiBmdW5jdGlvbihmaWx0ZXJzLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGZpbHRlcnMgJiYgZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMoZmlsdGVycywgZnVuY3Rpb24oZW5saXZlbmVkT2JqZWN0cykge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVubGl2ZW5lZE9iamVjdHMpO1xuICAgICAgICB9LCAnZmFicmljLkltYWdlLmZpbHRlcnMnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT2JqZWN0IHdpdGggd2lkdGgvaGVpZ2h0IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBfc2V0V2lkdGhIZWlnaHQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMud2lkdGggPSAnd2lkdGgnIGluIG9wdGlvbnNcbiAgICAgICAgPyBvcHRpb25zLndpZHRoXG4gICAgICAgIDogKHRoaXMuZ2V0RWxlbWVudCgpXG4gICAgICAgICAgICA/IHRoaXMuZ2V0RWxlbWVudCgpLndpZHRoIHx8IDBcbiAgICAgICAgICAgIDogMCk7XG5cbiAgICAgIHRoaXMuaGVpZ2h0ID0gJ2hlaWdodCcgaW4gb3B0aW9uc1xuICAgICAgICA/IG9wdGlvbnMuaGVpZ2h0XG4gICAgICAgIDogKHRoaXMuZ2V0RWxlbWVudCgpXG4gICAgICAgICAgICA/IHRoaXMuZ2V0RWxlbWVudCgpLmhlaWdodCB8fCAwXG4gICAgICAgICAgICA6IDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbXBsZXhpdHkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHkgb2YgdGhpcyBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbXBsZXhpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogRGVmYXVsdCBDU1MgY2xhc3MgbmFtZSBmb3IgY2FudmFzXG4gICAqIEBzdGF0aWNcbiAgICogQHR5cGUgU3RyaW5nXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuQ1NTX0NBTlZBUyA9ICdjYW52YXMtaW1nJztcblxuICAvKipcbiAgICogQWxpYXMgZm9yIGdldFNyY1xuICAgKiBAc3RhdGljXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UucHJvdG90eXBlLmdldFN2Z1NyYyA9IGZhYnJpYy5JbWFnZS5wcm90b3R5cGUuZ2V0U3JjO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZSBmcm9tIGl0cyBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBpbWFnZSBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICBmYWJyaWMudXRpbC5sb2FkSW1hZ2Uob2JqZWN0LnNyYywgZnVuY3Rpb24oaW1nLCBlcnJvcikge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG51bGwsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZmFicmljLkltYWdlLnByb3RvdHlwZS5faW5pdEZpbHRlcnMuY2FsbChvYmplY3QsIG9iamVjdC5maWx0ZXJzLCBmdW5jdGlvbihmaWx0ZXJzKSB7XG4gICAgICAgIG9iamVjdC5maWx0ZXJzID0gZmlsdGVycyB8fCBbXTtcbiAgICAgICAgZmFicmljLkltYWdlLnByb3RvdHlwZS5faW5pdEZpbHRlcnMuY2FsbChvYmplY3QsIG9iamVjdC5yZXNpemVGaWx0ZXJzLCBmdW5jdGlvbihyZXNpemVGaWx0ZXJzKSB7XG4gICAgICAgICAgb2JqZWN0LnJlc2l6ZUZpbHRlcnMgPSByZXNpemVGaWx0ZXJzIHx8IFtdO1xuICAgICAgICAgIHJldHVybiBuZXcgZmFicmljLkltYWdlKGltZywgb2JqZWN0LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSwgbnVsbCwgb2JqZWN0LmNyb3NzT3JpZ2luKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UgZnJvbSBhbiBVUkwgc3RyaW5nXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBVUkwgdG8gY3JlYXRlIGFuIGltYWdlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBpbWFnZSBpcyBjcmVhdGVkIChuZXdseSBjcmVhdGVkIGltYWdlIGlzIHBhc3NlZCBhcyBhIGZpcnN0IGFyZ3VtZW50KVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2ltZ09wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZnJvbVVSTCA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2ssIGltZ09wdGlvbnMpIHtcbiAgICBmYWJyaWMudXRpbC5sb2FkSW1hZ2UodXJsLCBmdW5jdGlvbihpbWcpIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG5ldyBmYWJyaWMuSW1hZ2UoaW1nLCBpbWdPcHRpb25zKSk7XG4gICAgfSwgbnVsbCwgaW1nT3B0aW9ucyAmJiBpbWdPcHRpb25zLmNyb3NzT3JpZ2luKTtcbiAgfTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkge0BsaW5rIGZhYnJpYy5JbWFnZS5mcm9tRWxlbWVudH0pXG4gICAqIEBzdGF0aWNcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3N0cnVjdC5odG1sI0ltYWdlRWxlbWVudH1cbiAgICovXG4gIGZhYnJpYy5JbWFnZS5BVFRSSUJVVEVfTkFNRVMgPVxuICAgIGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoJ3ggeSB3aWR0aCBoZWlnaHQgcHJlc2VydmVBc3BlY3RSYXRpbyB4bGluazpocmVmJy5zcGxpdCgnICcpKTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkltYWdlfSBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50XG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIGZhYnJpYy5JbWFnZSBvYmplY3QgaXMgY3JlYXRlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuSW1hZ2UuQVRUUklCVVRFX05BTUVTKSxcbiAgICAgICAgcHJlc2VydmVBUjtcblxuICAgIGlmIChwYXJzZWRBdHRyaWJ1dGVzLnByZXNlcnZlQXNwZWN0UmF0aW8pIHtcbiAgICAgIHByZXNlcnZlQVIgPSBmYWJyaWMudXRpbC5wYXJzZVByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGUocGFyc2VkQXR0cmlidXRlcy5wcmVzZXJ2ZUFzcGVjdFJhdGlvKTtcbiAgICAgIGV4dGVuZChwYXJzZWRBdHRyaWJ1dGVzLCBwcmVzZXJ2ZUFSKTtcbiAgICB9XG5cbiAgICBmYWJyaWMuSW1hZ2UuZnJvbVVSTChwYXJzZWRBdHRyaWJ1dGVzWyd4bGluazpocmVmJ10sIGNhbGxiYWNrLFxuICAgICAgZXh0ZW5kKChvcHRpb25zID8gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKG9wdGlvbnMpIDogeyB9KSwgcGFyc2VkQXR0cmlidXRlcykpO1xuICB9O1xuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhhdCBpbnN0YW5jZXMgb2YgdGhpcyB0eXBlIGFyZSBhc3luY1xuICAgKiBAc3RhdGljXG4gICAqIEB0eXBlIEJvb2xlYW5cbiAgICogQGRlZmF1bHRcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5hc3luYyA9IHRydWU7XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBjb21wcmVzc2lvbiBsZXZlbCB1c2VkIHdoZW4gZ2VuZXJhdGluZyBQTkcgdW5kZXIgTm9kZSAoaW4gYXBwbHlGaWx0ZXJzKS4gQW55IG9mIDAtOVxuICAgKiBAc3RhdGljXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgZmFicmljLkltYWdlLnBuZ0NvbXByZXNzaW9uID0gMTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGFuZ2xlIHZhbHVlXG4gICAqL1xuICBfZ2V0QW5nbGVWYWx1ZUZvclN0cmFpZ2h0ZW46IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhbmdsZSA9IHRoaXMuZ2V0QW5nbGUoKSAlIDM2MDtcbiAgICBpZiAoYW5nbGUgPiAwKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCgoYW5nbGUgLSAxKSAvIDkwKSAqIDkwO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5yb3VuZChhbmdsZSAvIDkwKSAqIDkwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTdHJhaWdodGVucyBhbiBvYmplY3QgKHJvdGF0aW5nIGl0IGZyb20gY3VycmVudCBhbmdsZSB0byBvbmUgb2YgMCwgOTAsIDE4MCwgMjcwLCBldGMuIGRlcGVuZGluZyBvbiB3aGljaCBpcyBjbG9zZXIpXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgc3RyYWlnaHRlbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRBbmdsZSh0aGlzLl9nZXRBbmdsZVZhbHVlRm9yU3RyYWlnaHRlbigpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyB7QGxpbmsgZmFicmljLk9iamVjdC5wcm90b3R5cGUuc3RyYWlnaHRlbn0gYnV0IHdpdGggYW5pbWF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFja3MgT2JqZWN0IHdpdGggY2FsbGJhY2sgZnVuY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25Db21wbGV0ZV0gSW52b2tlZCBvbiBjb21wbGV0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25DaGFuZ2VdIEludm9rZWQgb24gZXZlcnkgc3RlcCBvZiBhbmltYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmeFN0cmFpZ2h0ZW46IGZ1bmN0aW9uKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcyB8fCB7IH07XG5cbiAgICB2YXIgZW1wdHkgPSBmdW5jdGlvbigpIHsgfSxcbiAgICAgICAgb25Db21wbGV0ZSA9IGNhbGxiYWNrcy5vbkNvbXBsZXRlIHx8IGVtcHR5LFxuICAgICAgICBvbkNoYW5nZSA9IGNhbGxiYWNrcy5vbkNoYW5nZSB8fCBlbXB0eSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgZmFicmljLnV0aWwuYW5pbWF0ZSh7XG4gICAgICBzdGFydFZhbHVlOiB0aGlzLmdldCgnYW5nbGUnKSxcbiAgICAgIGVuZFZhbHVlOiB0aGlzLl9nZXRBbmdsZVZhbHVlRm9yU3RyYWlnaHRlbigpLFxuICAgICAgZHVyYXRpb246IHRoaXMuRlhfRFVSQVRJT04sXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgX3RoaXMuc2V0QW5nbGUodmFsdWUpO1xuICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfSxcbiAgICAgIG9uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5zZXQoJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIFN0cmFpZ2h0ZW5zIG9iamVjdCwgdGhlbiByZXJlbmRlcnMgY2FudmFzXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzdHJhaWdodGVuXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgc3RyYWlnaHRlbk9iamVjdDogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIG9iamVjdC5zdHJhaWdodGVuKCk7XG4gICAgdGhpcy5yZW5kZXJBbGwoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyB7QGxpbmsgZmFicmljLkNhbnZhcy5wcm90b3R5cGUuc3RyYWlnaHRlbk9iamVjdH0sIGJ1dCBhbmltYXRlZFxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc3RyYWlnaHRlblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGZ4U3RyYWlnaHRlbk9iamVjdDogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIG9iamVjdC5meFN0cmFpZ2h0ZW4oe1xuICAgICAgb25DaGFuZ2U6IHRoaXMucmVuZGVyQWxsLmJpbmQodGhpcylcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5cblxuLyoqXG4gKiBAbmFtZXNwYWNlIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gKiBAbWVtYmVyT2YgZmFicmljLkltYWdlXG4gKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMiNpbWFnZV9maWx0ZXJzfVxuICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICovXG5mYWJyaWMuSW1hZ2UuZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzIHx8IHsgfTtcblxuLyoqXG4gKiBSb290IGZpbHRlciBjbGFzcyBmcm9tIHdoaWNoIGFsbCBmaWx0ZXIgY2xhc3NlcyBpbmhlcml0IGZyb21cbiAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAqL1xuZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlciA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBGaWx0ZXIgdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgdHlwZTogJ0Jhc2VGaWx0ZXInLFxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgZmlsdGVyJ3MgcHJvcGVydGllcyBmcm9tIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgc2V0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykge1xuICAgICAgdGhpc1twcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgKi9cbiAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7IHR5cGU6IHRoaXMudHlwZSB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEpTT05cbiAgICovXG4gIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgLy8gZGVsZWdhdGUsIG5vdCBhbGlhc1xuICAgIHJldHVybiB0aGlzLnRvT2JqZWN0KCk7XG4gIH1cbn0pO1xuXG5mYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnNbb2JqZWN0LnR5cGVdKG9iamVjdCk7XG4gIGNhbGxiYWNrICYmIGNhbGxiYWNrKGZpbHRlcik7XG4gIHJldHVybiBmaWx0ZXI7XG59O1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBCcmlnaHRuZXNzIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzc1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzKHtcbiAgICogICBicmlnaHRuZXNzOiAyMDBcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycyhjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAqL1xuICBmaWx0ZXJzLkJyaWdodG5lc3MgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0JyaWdodG5lc3MnLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzcy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJyaWdodG5lc3M9MF0gVmFsdWUgdG8gYnJpZ2h0ZW4gdGhlIGltYWdlIHVwICgtMjU1Li4yNTUpXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuICAgICAgdGhpcy5icmlnaHRuZXNzID0gb3B0aW9ucy5icmlnaHRuZXNzIHx8IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZmlsdGVyIHRvIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqL1xuICAgIGFwcGx5VG86IGZ1bmN0aW9uKGNhbnZhc0VsKSB7XG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhc0VsLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzRWwud2lkdGgsIGNhbnZhc0VsLmhlaWdodCksXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgIGJyaWdodG5lc3MgPSB0aGlzLmJyaWdodG5lc3M7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGRhdGFbaV0gKz0gYnJpZ2h0bmVzcztcbiAgICAgICAgZGF0YVtpICsgMV0gKz0gYnJpZ2h0bmVzcztcbiAgICAgICAgZGF0YVtpICsgMl0gKz0gYnJpZ2h0bmVzcztcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JyksIHtcbiAgICAgICAgYnJpZ2h0bmVzczogdGhpcy5icmlnaHRuZXNzXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzc30gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzc1xuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzcy5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEFkYXB0ZWQgZnJvbSA8YSBocmVmPVwiaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvY2FudmFzL2ltYWdlZmlsdGVycy9cIj5odG1sNXJvY2tzIGFydGljbGU8L2E+XG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGVcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGUgPGNhcHRpb24+U2hhcnBlbiBmaWx0ZXI8L2NhcHRpb24+XG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlKHtcbiAgICogICBtYXRyaXg6IFsgMCwgLTEsICAwLFxuICAgKiAgICAgICAgICAgIC0xLCAgNSwgLTEsXG4gICAqICAgICAgICAgICAgIDAsIC0xLCAgMCBdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5CbHVyIGZpbHRlcjwvY2FwdGlvbj5cbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUoe1xuICAgKiAgIG1hdHJpeDogWyAxLzksIDEvOSwgMS85LFxuICAgKiAgICAgICAgICAgICAxLzksIDEvOSwgMS85LFxuICAgKiAgICAgICAgICAgICAxLzksIDEvOSwgMS85IF1cbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycyhjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtYm9zcyBmaWx0ZXI8L2NhcHRpb24+XG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlKHtcbiAgICogICBtYXRyaXg6IFsgMSwgICAxLCAgMSxcbiAgICogICAgICAgICAgICAgMSwgMC43LCAtMSxcbiAgICogICAgICAgICAgICAtMSwgIC0xLCAtMSBdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWJvc3MgZmlsdGVyIHdpdGggb3BhcXVlbmVzczwvY2FwdGlvbj5cbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUoe1xuICAgKiAgIG9wYXF1ZTogdHJ1ZSxcbiAgICogICBtYXRyaXg6IFsgMSwgICAxLCAgMSxcbiAgICogICAgICAgICAgICAgMSwgMC43LCAtMSxcbiAgICogICAgICAgICAgICAtMSwgIC0xLCAtMSBdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgKi9cbiAgZmlsdGVycy5Db252b2x1dGUgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnQ29udm9sdXRlJyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vcGFxdWU9ZmFsc2VdIE9wYXF1ZSB2YWx1ZSAodHJ1ZS9mYWxzZSlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5tYXRyaXhdIEZpbHRlciBtYXRyaXhcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG5cbiAgICAgIHRoaXMub3BhcXVlID0gb3B0aW9ucy5vcGFxdWU7XG4gICAgICB0aGlzLm1hdHJpeCA9IG9wdGlvbnMubWF0cml4IHx8IFtcbiAgICAgICAgMCwgMCwgMCxcbiAgICAgICAgMCwgMSwgMCxcbiAgICAgICAgMCwgMCwgMFxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBmaWx0ZXIgdG8gY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICovXG4gICAgYXBwbHlUbzogZnVuY3Rpb24oY2FudmFzRWwpIHtcblxuICAgICAgdmFyIHdlaWdodHMgPSB0aGlzLm1hdHJpeCxcbiAgICAgICAgICBjb250ZXh0ID0gY2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICBwaXhlbHMgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXNFbC53aWR0aCwgY2FudmFzRWwuaGVpZ2h0KSxcblxuICAgICAgICAgIHNpZGUgPSBNYXRoLnJvdW5kKE1hdGguc3FydCh3ZWlnaHRzLmxlbmd0aCkpLFxuICAgICAgICAgIGhhbGZTaWRlID0gTWF0aC5mbG9vcihzaWRlIC8gMiksXG4gICAgICAgICAgc3JjID0gcGl4ZWxzLmRhdGEsXG4gICAgICAgICAgc3cgPSBwaXhlbHMud2lkdGgsXG4gICAgICAgICAgc2ggPSBwaXhlbHMuaGVpZ2h0LFxuICAgICAgICAgIG91dHB1dCA9IGNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHN3LCBzaCksXG4gICAgICAgICAgZHN0ID0gb3V0cHV0LmRhdGEsXG4gICAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgZGVzdGluYXRpb24gaW1hZ2UgcGl4ZWxzXG4gICAgICAgICAgYWxwaGFGYWMgPSB0aGlzLm9wYXF1ZSA/IDEgOiAwLFxuICAgICAgICAgIHIsIGcsIGIsIGEsIGRzdE9mZixcbiAgICAgICAgICBzY3gsIHNjeSwgc3JjT2ZmLCB3dDtcblxuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBzaDsgeSsrKSB7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgc3c7IHgrKykge1xuICAgICAgICAgIGRzdE9mZiA9ICh5ICogc3cgKyB4KSAqIDQ7XG4gICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSB3ZWlnaGVkIHN1bSBvZiB0aGUgc291cmNlIGltYWdlIHBpeGVscyB0aGF0XG4gICAgICAgICAgLy8gZmFsbCB1bmRlciB0aGUgY29udm9sdXRpb24gbWF0cml4XG4gICAgICAgICAgciA9IDA7IGcgPSAwOyBiID0gMDsgYSA9IDA7XG5cbiAgICAgICAgICBmb3IgKHZhciBjeSA9IDA7IGN5IDwgc2lkZTsgY3krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgY3ggPSAwOyBjeCA8IHNpZGU7IGN4KyspIHtcbiAgICAgICAgICAgICAgc2N5ID0geSArIGN5IC0gaGFsZlNpZGU7XG4gICAgICAgICAgICAgIHNjeCA9IHggKyBjeCAtIGhhbGZTaWRlO1xuXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcbiAgICAgICAgICAgICAgaWYgKHNjeSA8IDAgfHwgc2N5ID4gc2ggfHwgc2N4IDwgMCB8fCBzY3ggPiBzdykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc3JjT2ZmID0gKHNjeSAqIHN3ICsgc2N4KSAqIDQ7XG4gICAgICAgICAgICAgIHd0ID0gd2VpZ2h0c1tjeSAqIHNpZGUgKyBjeF07XG5cbiAgICAgICAgICAgICAgciArPSBzcmNbc3JjT2ZmXSAqIHd0O1xuICAgICAgICAgICAgICBnICs9IHNyY1tzcmNPZmYgKyAxXSAqIHd0O1xuICAgICAgICAgICAgICBiICs9IHNyY1tzcmNPZmYgKyAyXSAqIHd0O1xuICAgICAgICAgICAgICBhICs9IHNyY1tzcmNPZmYgKyAzXSAqIHd0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBkc3RbZHN0T2ZmXSA9IHI7XG4gICAgICAgICAgZHN0W2RzdE9mZiArIDFdID0gZztcbiAgICAgICAgICBkc3RbZHN0T2ZmICsgMl0gPSBiO1xuICAgICAgICAgIGRzdFtkc3RPZmYgKyAzXSA9IGEgKyBhbHBoYUZhYyAqICgyNTUgLSBhKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb250ZXh0LnB1dEltYWdlRGF0YShvdXRwdXQsIDAsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnKSwge1xuICAgICAgICBvcGFxdWU6IHRoaXMub3BhcXVlLFxuICAgICAgICBtYXRyaXg6IHRoaXMubWF0cml4XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGVcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEdyYWRpZW50VHJhbnNwYXJlbmN5IGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuR3JhZGllbnRUcmFuc3BhcmVuY3lcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuR3JhZGllbnRUcmFuc3BhcmVuY3kjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYWRpZW50VHJhbnNwYXJlbmN5KHtcbiAgICogICB0aHJlc2hvbGQ6IDIwMFxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICovXG4gICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICBmaWx0ZXJzLkdyYWRpZW50VHJhbnNwYXJlbmN5ID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYWRpZW50VHJhbnNwYXJlbmN5LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnR3JhZGllbnRUcmFuc3BhcmVuY3knLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuR3JhZGllbnRUcmFuc3BhcmVuY3kucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50aHJlc2hvbGQ9MTAwXSBUaHJlc2hvbGQgdmFsdWVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG4gICAgICB0aGlzLnRocmVzaG9sZCA9IG9wdGlvbnMudGhyZXNob2xkIHx8IDEwMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBmaWx0ZXIgdG8gY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICovXG4gICAgYXBwbHlUbzogZnVuY3Rpb24oY2FudmFzRWwpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXNFbC53aWR0aCwgY2FudmFzRWwuaGVpZ2h0KSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgdGhyZXNob2xkID0gdGhpcy50aHJlc2hvbGQsXG4gICAgICAgICAgdG90YWwgPSBkYXRhLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgZGF0YVtpICsgM10gPSB0aHJlc2hvbGQgKyAyNTUgKiAodG90YWwgLSBpKSAvIHRvdGFsO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnKSwge1xuICAgICAgICB0aHJlc2hvbGQ6IHRoaXMudGhyZXNob2xkXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuR3JhZGllbnRUcmFuc3BhcmVuY3l9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYWRpZW50VHJhbnNwYXJlbmN5XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmFkaWVudFRyYW5zcGFyZW5jeS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogR3JheXNjYWxlIGltYWdlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuR3JheXNjYWxlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGUoKTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICovXG4gIGZpbHRlcnMuR3JheXNjYWxlID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYXlzY2FsZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0dyYXlzY2FsZScsXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlciB0byBjYW52YXMgZWxlbWVudFxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqL1xuICAgIGFwcGx5VG86IGZ1bmN0aW9uKGNhbnZhc0VsKSB7XG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhc0VsLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzRWwud2lkdGgsIGNhbnZhc0VsLmhlaWdodCksXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgIGxlbiA9IGltYWdlRGF0YS53aWR0aCAqIGltYWdlRGF0YS5oZWlnaHQgKiA0LFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBhdmVyYWdlO1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW4pIHtcbiAgICAgICAgYXZlcmFnZSA9IChkYXRhW2luZGV4XSArIGRhdGFbaW5kZXggKyAxXSArIGRhdGFbaW5kZXggKyAyXSkgLyAzO1xuICAgICAgICBkYXRhW2luZGV4XSAgICAgPSBhdmVyYWdlO1xuICAgICAgICBkYXRhW2luZGV4ICsgMV0gPSBhdmVyYWdlO1xuICAgICAgICBkYXRhW2luZGV4ICsgMl0gPSBhdmVyYWdlO1xuICAgICAgICBpbmRleCArPSA0O1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGV9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYXlzY2FsZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuR3JheXNjYWxlLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0IHx8IHsgfTtcbiAgICBvYmplY3QudHlwZSA9ICdHcmF5c2NhbGUnO1xuICAgIHJldHVybiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Qob2JqZWN0LCBjYWxsYmFjayk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBJbnZlcnQgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5JbnZlcnRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkludmVydCgpO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgKi9cbiAgZmlsdGVycy5JbnZlcnQgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuSW52ZXJ0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnSW52ZXJ0JyxcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZmlsdGVyIHRvIGNhbnZhcyBlbGVtZW50XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkludmVydC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICovXG4gICAgYXBwbHlUbzogZnVuY3Rpb24oY2FudmFzRWwpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXNFbC53aWR0aCwgY2FudmFzRWwuaGVpZ2h0KSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgaUxlbiA9IGRhdGEubGVuZ3RoLCBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaUxlbjsgaSArPSA0KSB7XG4gICAgICAgIGRhdGFbaV0gPSAyNTUgLSBkYXRhW2ldO1xuICAgICAgICBkYXRhW2kgKyAxXSA9IDI1NSAtIGRhdGFbaSArIDFdO1xuICAgICAgICBkYXRhW2kgKyAyXSA9IDI1NSAtIGRhdGFbaSArIDJdO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5JbnZlcnR9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkludmVydFxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuSW52ZXJ0LmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0IHx8IHsgfTtcbiAgICBvYmplY3QudHlwZSA9ICdJbnZlcnQnO1xuICAgIHJldHVybiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Qob2JqZWN0LCBjYWxsYmFjayk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogTWFzayBmaWx0ZXIgY2xhc3NcbiAgICogU2VlIGh0dHA6Ly9yZXNvdXJjZXMuYWxlcGgtMS5jb20vbWFzay9cbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk1hc2tcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuTWFzayNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmlsdGVycy5NYXNrID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk1hc2sucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdNYXNrJyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk1hc2sucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLkltYWdlfSBbb3B0aW9ucy5tYXNrXSBNYXNrIGltYWdlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jaGFubmVsPTBdIFJnYiBjaGFubmVsICgwLCAxLCAyIG9yIDMpXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuXG4gICAgICB0aGlzLm1hc2sgPSBvcHRpb25zLm1hc2s7XG4gICAgICB0aGlzLmNoYW5uZWwgPSBbMCwgMSwgMiwgM10uaW5kZXhPZihvcHRpb25zLmNoYW5uZWwpID4gLTEgPyBvcHRpb25zLmNoYW5uZWwgOiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlciB0byBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKi9cbiAgICBhcHBseVRvOiBmdW5jdGlvbihjYW52YXNFbCkge1xuICAgICAgaWYgKCF0aGlzLm1hc2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhc0VsLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzRWwud2lkdGgsIGNhbnZhc0VsLmhlaWdodCksXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgIG1hc2tFbCA9IHRoaXMubWFzay5nZXRFbGVtZW50KCksXG4gICAgICAgICAgbWFza0NhbnZhc0VsID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLFxuICAgICAgICAgIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWwsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBpTGVuID0gaW1hZ2VEYXRhLndpZHRoICogaW1hZ2VEYXRhLmhlaWdodCAqIDQ7XG5cbiAgICAgIG1hc2tDYW52YXNFbC53aWR0aCA9IGNhbnZhc0VsLndpZHRoO1xuICAgICAgbWFza0NhbnZhc0VsLmhlaWdodCA9IGNhbnZhc0VsLmhlaWdodDtcblxuICAgICAgbWFza0NhbnZhc0VsLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKG1hc2tFbCwgMCwgMCwgY2FudmFzRWwud2lkdGgsIGNhbnZhc0VsLmhlaWdodCk7XG5cbiAgICAgIHZhciBtYXNrSW1hZ2VEYXRhID0gbWFza0NhbnZhc0VsLmdldENvbnRleHQoJzJkJykuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhc0VsLndpZHRoLCBjYW52YXNFbC5oZWlnaHQpLFxuICAgICAgICAgIG1hc2tEYXRhID0gbWFza0ltYWdlRGF0YS5kYXRhO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaUxlbjsgaSArPSA0KSB7XG4gICAgICAgIGRhdGFbaSArIDNdID0gbWFza0RhdGFbaSArIGNoYW5uZWxdO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnKSwge1xuICAgICAgICBtYXNrOiB0aGlzLm1hc2sudG9PYmplY3QoKSxcbiAgICAgICAgY2hhbm5lbDogdGhpcy5jaGFubmVsXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYSBtYXNrIGZpbHRlciBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5NYXNrLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgZmFicmljLnV0aWwubG9hZEltYWdlKG9iamVjdC5tYXNrLnNyYywgZnVuY3Rpb24oaW1nKSB7XG4gICAgICBvYmplY3QubWFzayA9IG5ldyBmYWJyaWMuSW1hZ2UoaW1nLCBvYmplY3QubWFzayk7XG4gICAgICByZXR1cm4gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0KG9iamVjdCwgY2FsbGJhY2spO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhhdCBpbnN0YW5jZXMgb2YgdGhpcyB0eXBlIGFyZSBhc3luY1xuICAgKiBAc3RhdGljXG4gICAqIEB0eXBlIEJvb2xlYW5cbiAgICogQGRlZmF1bHRcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk1hc2suYXN5bmMgPSB0cnVlO1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIE5vaXNlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2VcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2UjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlKHtcbiAgICogICBub2lzZTogNzAwXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgKi9cbiAgZmlsdGVycy5Ob2lzZSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ05vaXNlJyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubm9pc2U9MF0gTm9pc2UgdmFsdWVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG4gICAgICB0aGlzLm5vaXNlID0gb3B0aW9ucy5ub2lzZSB8fCAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlciB0byBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKi9cbiAgICBhcHBseVRvOiBmdW5jdGlvbihjYW52YXNFbCkge1xuICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICAgIGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhc0VsLndpZHRoLCBjYW52YXNFbC5oZWlnaHQpLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBub2lzZSA9IHRoaXMubm9pc2UsIHJhbmQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSArPSA0KSB7XG5cbiAgICAgICAgcmFuZCA9ICgwLjUgLSBNYXRoLnJhbmRvbSgpKSAqIG5vaXNlO1xuXG4gICAgICAgIGRhdGFbaV0gKz0gcmFuZDtcbiAgICAgICAgZGF0YVtpICsgMV0gKz0gcmFuZDtcbiAgICAgICAgZGF0YVtpICsgMl0gKz0gcmFuZDtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JyksIHtcbiAgICAgICAgbm9pc2U6IHRoaXMubm9pc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2VcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogUGl4ZWxhdGUgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGUoe1xuICAgKiAgIGJsb2Nrc2l6ZTogOFxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICovXG4gIGZpbHRlcnMuUGl4ZWxhdGUgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdQaXhlbGF0ZScsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJsb2Nrc2l6ZT00XSBCbG9ja3NpemUgZm9yIHBpeGVsYXRlXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuICAgICAgdGhpcy5ibG9ja3NpemUgPSBvcHRpb25zLmJsb2Nrc2l6ZSB8fCA0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlciB0byBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKi9cbiAgICBhcHBseVRvOiBmdW5jdGlvbihjYW52YXNFbCkge1xuICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICAgIGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhc0VsLndpZHRoLCBjYW52YXNFbC5oZWlnaHQpLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBpTGVuID0gaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgICAgICBqTGVuID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgIGluZGV4LCBpLCBqLCByLCBnLCBiLCBhO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaUxlbjsgaSArPSB0aGlzLmJsb2Nrc2l6ZSkge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSB0aGlzLmJsb2Nrc2l6ZSkge1xuXG4gICAgICAgICAgaW5kZXggPSAoaSAqIDQpICogakxlbiArIChqICogNCk7XG5cbiAgICAgICAgICByID0gZGF0YVtpbmRleF07XG4gICAgICAgICAgZyA9IGRhdGFbaW5kZXggKyAxXTtcbiAgICAgICAgICBiID0gZGF0YVtpbmRleCArIDJdO1xuICAgICAgICAgIGEgPSBkYXRhW2luZGV4ICsgM107XG5cbiAgICAgICAgICAvKlxuICAgICAgICAgICBibG9ja3NpemU6IDRcblxuICAgICAgICAgICBbMSx4LHgseCwxXVxuICAgICAgICAgICBbeCx4LHgseCwxXVxuICAgICAgICAgICBbeCx4LHgseCwxXVxuICAgICAgICAgICBbeCx4LHgseCwxXVxuICAgICAgICAgICBbMSwxLDEsMSwxXVxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kgPSBpLCBfaWxlbiA9IGkgKyB0aGlzLmJsb2Nrc2l6ZTsgX2kgPCBfaWxlbjsgX2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgX2ogPSBqLCBfamxlbiA9IGogKyB0aGlzLmJsb2Nrc2l6ZTsgX2ogPCBfamxlbjsgX2orKykge1xuICAgICAgICAgICAgICBpbmRleCA9IChfaSAqIDQpICogakxlbiArIChfaiAqIDQpO1xuICAgICAgICAgICAgICBkYXRhW2luZGV4XSA9IHI7XG4gICAgICAgICAgICAgIGRhdGFbaW5kZXggKyAxXSA9IGc7XG4gICAgICAgICAgICAgIGRhdGFbaW5kZXggKyAyXSA9IGI7XG4gICAgICAgICAgICAgIGRhdGFbaW5kZXggKyAzXSA9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcpLCB7XG4gICAgICAgIGJsb2Nrc2l6ZTogdGhpcy5ibG9ja3NpemVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGVcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogUmVtb3ZlIHdoaXRlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlV2hpdGVcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlV2hpdGUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZVdoaXRlKHtcbiAgICogICB0aHJlc2hvbGQ6IDQwLFxuICAgKiAgIGRpc3RhbmNlOiAxNDBcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycyhjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAqL1xuICBmaWx0ZXJzLlJlbW92ZVdoaXRlID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZVdoaXRlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnUmVtb3ZlV2hpdGUnLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlV2hpdGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50aHJlc2hvbGQ9MzBdIFRocmVzaG9sZCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kaXN0YW5jZT0yMF0gRGlzdGFuY2UgdmFsdWVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG4gICAgICB0aGlzLnRocmVzaG9sZCA9IG9wdGlvbnMudGhyZXNob2xkIHx8IDMwO1xuICAgICAgdGhpcy5kaXN0YW5jZSA9IG9wdGlvbnMuZGlzdGFuY2UgfHwgMjA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZmlsdGVyIHRvIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqL1xuICAgIGFwcGx5VG86IGZ1bmN0aW9uKGNhbnZhc0VsKSB7XG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhc0VsLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzRWwud2lkdGgsIGNhbnZhc0VsLmhlaWdodCksXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgIHRocmVzaG9sZCA9IHRoaXMudGhyZXNob2xkLFxuICAgICAgICAgIGRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZSxcbiAgICAgICAgICBsaW1pdCA9IDI1NSAtIHRocmVzaG9sZCxcbiAgICAgICAgICBhYnMgPSBNYXRoLmFicyxcbiAgICAgICAgICByLCBnLCBiO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICByID0gZGF0YVtpXTtcbiAgICAgICAgZyA9IGRhdGFbaSArIDFdO1xuICAgICAgICBiID0gZGF0YVtpICsgMl07XG5cbiAgICAgICAgaWYgKHIgPiBsaW1pdCAmJlxuICAgICAgICAgICAgZyA+IGxpbWl0ICYmXG4gICAgICAgICAgICBiID4gbGltaXQgJiZcbiAgICAgICAgICAgIGFicyhyIC0gZykgPCBkaXN0YW5jZSAmJlxuICAgICAgICAgICAgYWJzKHIgLSBiKSA8IGRpc3RhbmNlICYmXG4gICAgICAgICAgICBhYnMoZyAtIGIpIDwgZGlzdGFuY2VcbiAgICAgICAgKSB7XG4gICAgICAgICAgZGF0YVtpICsgM10gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcpLCB7XG4gICAgICAgIHRocmVzaG9sZDogdGhpcy50aHJlc2hvbGQsXG4gICAgICAgIGRpc3RhbmNlOiB0aGlzLmRpc3RhbmNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlV2hpdGV9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZVdoaXRlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVXaGl0ZS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogU2VwaWEgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TZXBpYVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuU2VwaWEoKTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICovXG4gIGZpbHRlcnMuU2VwaWEgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuU2VwaWEucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdTZXBpYScsXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlciB0byBjYW52YXMgZWxlbWVudFxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TZXBpYS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICovXG4gICAgYXBwbHlUbzogZnVuY3Rpb24oY2FudmFzRWwpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXNFbC53aWR0aCwgY2FudmFzRWwuaGVpZ2h0KSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgaUxlbiA9IGRhdGEubGVuZ3RoLCBpLCBhdmc7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpTGVuOyBpICs9IDQpIHtcbiAgICAgICAgYXZnID0gMC4zICAqIGRhdGFbaV0gKyAwLjU5ICogZGF0YVtpICsgMV0gKyAwLjExICogZGF0YVtpICsgMl07XG4gICAgICAgIGRhdGFbaV0gPSBhdmcgKyAxMDA7XG4gICAgICAgIGRhdGFbaSArIDFdID0gYXZnICsgNTA7XG4gICAgICAgIGRhdGFbaSArIDJdID0gYXZnICsgMjU1O1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5TZXBpYX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuU2VwaWFcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNlcGlhLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0IHx8IHsgfTtcbiAgICBvYmplY3QudHlwZSA9ICdTZXBpYSc7XG4gICAgcmV0dXJuIG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Qob2JqZWN0LCBjYWxsYmFjayk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBTZXBpYTIgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TZXBpYTJcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNlcGlhMigpO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgKi9cbiAgZmlsdGVycy5TZXBpYTIgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuU2VwaWEyLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnU2VwaWEyJyxcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZmlsdGVyIHRvIGNhbnZhcyBlbGVtZW50XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNlcGlhLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKi9cbiAgICBhcHBseVRvOiBmdW5jdGlvbihjYW52YXNFbCkge1xuICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICAgIGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhc0VsLndpZHRoLCBjYW52YXNFbC5oZWlnaHQpLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBpTGVuID0gZGF0YS5sZW5ndGgsIGksIHIsIGcsIGI7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpTGVuOyBpICs9IDQpIHtcbiAgICAgICAgciA9IGRhdGFbaV07XG4gICAgICAgIGcgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgYiA9IGRhdGFbaSArIDJdO1xuXG4gICAgICAgIGRhdGFbaV0gPSAociAqIDAuMzkzICsgZyAqIDAuNzY5ICsgYiAqIDAuMTg5ICkgLyAxLjM1MTtcbiAgICAgICAgZGF0YVtpICsgMV0gPSAociAqIDAuMzQ5ICsgZyAqIDAuNjg2ICsgYiAqIDAuMTY4ICkgLyAxLjIwMztcbiAgICAgICAgZGF0YVtpICsgMl0gPSAociAqIDAuMjcyICsgZyAqIDAuNTM0ICsgYiAqIDAuMTMxICkgLyAyLjE0MDtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuU2VwaWEyfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TZXBpYTJcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNlcGlhMi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIG9iamVjdCA9IG9iamVjdCB8fCB7IH07XG4gICAgb2JqZWN0LnR5cGUgPSAnU2VwaWEyJztcbiAgICByZXR1cm4gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdChvYmplY3QsIGNhbGxiYWNrKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBUaW50IGZpbHRlciBjbGFzc1xuICAgKiBBZGFwdGVkIGZyb20gPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9tZXp6b2JsdWUvUGFpbnRicnVzaEpTXCI+aHR0cHM6Ly9naXRodWIuY29tL21lenpvYmx1ZS9QYWludGJydXNoSlM8L2E+XG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5UaW50XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlRpbnQjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5UaW50IGZpbHRlciB3aXRoIGhleCBjb2xvciBhbmQgb3BhY2l0eTwvY2FwdGlvbj5cbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5UaW50KHtcbiAgICogICBjb2xvcjogJyMzNTEzQjAnLFxuICAgKiAgIG9wYWNpdHk6IDAuNVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+VGludCBmaWx0ZXIgd2l0aCByZ2JhIGNvbG9yPC9jYXB0aW9uPlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLlRpbnQoe1xuICAgKiAgIGNvbG9yOiAncmdiYSg1MywgMjEsIDE3NiwgMC41KSdcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycyhjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAqL1xuICBmaWx0ZXJzLlRpbnQgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuVGludC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ1RpbnQnLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuVGludC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNvbG9yPSMwMDAwMDBdIENvbG9yIHRvIHRpbnQgdGhlIGltYWdlIHdpdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub3BhY2l0eV0gT3BhY2l0eSB2YWx1ZSB0aGF0IGNvbnRyb2xzIHRoZSB0aW50IGVmZmVjdCdzIHRyYW5zcGFyZW5jeSAoMC4uMSlcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG5cbiAgICAgIHRoaXMuY29sb3IgPSBvcHRpb25zLmNvbG9yIHx8ICcjMDAwMDAwJztcbiAgICAgIHRoaXMub3BhY2l0eSA9IHR5cGVvZiBvcHRpb25zLm9wYWNpdHkgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLm9wYWNpdHlcbiAgICAgICAgICAgICAgICAgICAgICA6IG5ldyBmYWJyaWMuQ29sb3IodGhpcy5jb2xvcikuZ2V0QWxwaGEoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBmaWx0ZXIgdG8gY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICovXG4gICAgYXBwbHlUbzogZnVuY3Rpb24oY2FudmFzRWwpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXNFbC53aWR0aCwgY2FudmFzRWwuaGVpZ2h0KSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgaUxlbiA9IGRhdGEubGVuZ3RoLCBpLFxuICAgICAgICAgIHRpbnRSLCB0aW50RywgdGludEIsXG4gICAgICAgICAgciwgZywgYiwgYWxwaGExLFxuICAgICAgICAgIHNvdXJjZTtcblxuICAgICAgc291cmNlID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKS5nZXRTb3VyY2UoKTtcblxuICAgICAgdGludFIgPSBzb3VyY2VbMF0gKiB0aGlzLm9wYWNpdHk7XG4gICAgICB0aW50RyA9IHNvdXJjZVsxXSAqIHRoaXMub3BhY2l0eTtcbiAgICAgIHRpbnRCID0gc291cmNlWzJdICogdGhpcy5vcGFjaXR5O1xuXG4gICAgICBhbHBoYTEgPSAxIC0gdGhpcy5vcGFjaXR5O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaUxlbjsgaSArPSA0KSB7XG4gICAgICAgIHIgPSBkYXRhW2ldO1xuICAgICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICAgIGIgPSBkYXRhW2kgKyAyXTtcblxuICAgICAgICAvLyBhbHBoYSBjb21wb3NpdGluZ1xuICAgICAgICBkYXRhW2ldID0gdGludFIgKyByICogYWxwaGExO1xuICAgICAgICBkYXRhW2kgKyAxXSA9IHRpbnRHICsgZyAqIGFscGhhMTtcbiAgICAgICAgZGF0YVtpICsgMl0gPSB0aW50QiArIGIgKiBhbHBoYTE7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcpLCB7XG4gICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICBvcGFjaXR5OiB0aGlzLm9wYWNpdHlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5UaW50fSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5UaW50XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5UaW50LmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogTXVsdGlwbHkgZmlsdGVyIGNsYXNzXG4gICAqIEFkYXB0ZWQgZnJvbSA8YSBocmVmPVwiaHR0cDovL3d3dy5sYXVyZW5zY29yaWpuLmNvbS9hcnRpY2xlcy9jb2xvcm1hdGgtYmFzaWNzXCI+aHR0cDovL3d3dy5sYXVyZW5zY29yaWpuLmNvbS9hcnRpY2xlcy9jb2xvcm1hdGgtYmFzaWNzPC9hPlxuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuTXVsdGlwbHlcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+TXVsdGlwbHkgZmlsdGVyIHdpdGggaGV4IGNvbG9yPC9jYXB0aW9uPlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLk11bHRpcGx5KHtcbiAgICogICBjb2xvcjogJyNGMEYnXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5NdWx0aXBseSBmaWx0ZXIgd2l0aCByZ2IgY29sb3I8L2NhcHRpb24+XG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuTXVsdGlwbHkoe1xuICAgKiAgIGNvbG9yOiAncmdiKDUzLCAyMSwgMTc2KSdcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycyhjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAqL1xuICBmaWx0ZXJzLk11bHRpcGx5ID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk11bHRpcGx5LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnTXVsdGlwbHknLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuTXVsdGlwbHkucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jb2xvcj0jMDAwMDAwXSBDb2xvciB0byBtdWx0aXBseSB0aGUgaW1hZ2UgcGl4ZWxzIHdpdGhcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG5cbiAgICAgIHRoaXMuY29sb3IgPSBvcHRpb25zLmNvbG9yIHx8ICcjMDAwMDAwJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBmaWx0ZXIgdG8gY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICovXG4gICAgYXBwbHlUbzogZnVuY3Rpb24oY2FudmFzRWwpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXNFbC53aWR0aCwgY2FudmFzRWwuaGVpZ2h0KSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgaUxlbiA9IGRhdGEubGVuZ3RoLCBpLFxuICAgICAgICAgIHNvdXJjZTtcblxuICAgICAgc291cmNlID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKS5nZXRTb3VyY2UoKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGlMZW47IGkgKz0gNCkge1xuICAgICAgICBkYXRhW2ldICo9IHNvdXJjZVswXSAvIDI1NTtcbiAgICAgICAgZGF0YVtpICsgMV0gKj0gc291cmNlWzFdIC8gMjU1O1xuICAgICAgICBkYXRhW2kgKyAyXSAqPSBzb3VyY2VbMl0gLyAyNTU7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcpLCB7XG4gICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuTXVsdGlwbHl9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk11bHRpcGx5XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5NdWx0aXBseS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBDb2xvciBCbGVuZCBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXIuQmxlbmRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZCh7XG4gICAqICBjb2xvcjogJyMwMDAnLFxuICAgKiAgbW9kZTogJ211bHRpcGx5J1xuICAgKiB9KTtcbiAgICpcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZCh7XG4gICAqICBpbWFnZTogZmFicmljSW1hZ2VPYmplY3QsXG4gICAqICBtb2RlOiAnbXVsdGlwbHknLFxuICAgKiAgYWxwaGE6IDAuNVxuICAgKiB9KTtcblxuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgKi9cblxuICBmaWx0ZXJzLkJsZW5kID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kLnByb3RvdHlwZSAqLyB7XG4gICAgdHlwZTogJ0JsZW5kJyxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdGhpcy5jb2xvciA9IG9wdGlvbnMuY29sb3IgfHwgJyMwMDAnO1xuICAgICAgdGhpcy5pbWFnZSA9IG9wdGlvbnMuaW1hZ2UgfHwgZmFsc2U7XG4gICAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgJ211bHRpcGx5JztcbiAgICAgIHRoaXMuYWxwaGEgPSBvcHRpb25zLmFscGhhIHx8IDE7XG4gICAgfSxcblxuICAgIGFwcGx5VG86IGZ1bmN0aW9uKGNhbnZhc0VsKSB7XG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhc0VsLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzRWwud2lkdGgsIGNhbnZhc0VsLmhlaWdodCksXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgIHRyLCB0ZywgdGIsXG4gICAgICAgICAgciwgZywgYixcbiAgICAgICAgICBfciwgX2csIF9iLFxuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICBpc0ltYWdlID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLmltYWdlKSB7XG4gICAgICAgIC8vIEJsZW5kIGltYWdlc1xuICAgICAgICBpc0ltYWdlID0gdHJ1ZTtcblxuICAgICAgICB2YXIgX2VsID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgICBfZWwud2lkdGggPSB0aGlzLmltYWdlLndpZHRoO1xuICAgICAgICBfZWwuaGVpZ2h0ID0gdGhpcy5pbWFnZS5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIHRtcENhbnZhcyA9IG5ldyBmYWJyaWMuU3RhdGljQ2FudmFzKF9lbCk7XG4gICAgICAgIHRtcENhbnZhcy5hZGQodGhpcy5pbWFnZSk7XG4gICAgICAgIHZhciBjb250ZXh0MiA9ICB0bXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgc291cmNlID0gY29udGV4dDIuZ2V0SW1hZ2VEYXRhKDAsIDAsIHRtcENhbnZhcy53aWR0aCwgdG1wQ2FudmFzLmhlaWdodCkuZGF0YTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBCbGVuZCBjb2xvclxuICAgICAgICBzb3VyY2UgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpLmdldFNvdXJjZSgpO1xuXG4gICAgICAgIHRyID0gc291cmNlWzBdICogdGhpcy5hbHBoYTtcbiAgICAgICAgdGcgPSBzb3VyY2VbMV0gKiB0aGlzLmFscGhhO1xuICAgICAgICB0YiA9IHNvdXJjZVsyXSAqIHRoaXMuYWxwaGE7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSArPSA0KSB7XG5cbiAgICAgICAgciA9IGRhdGFbaV07XG4gICAgICAgIGcgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgYiA9IGRhdGFbaSArIDJdO1xuXG4gICAgICAgIGlmIChpc0ltYWdlKSB7XG4gICAgICAgICAgdHIgPSBzb3VyY2VbaV0gKiB0aGlzLmFscGhhO1xuICAgICAgICAgIHRnID0gc291cmNlW2kgKyAxXSAqIHRoaXMuYWxwaGE7XG4gICAgICAgICAgdGIgPSBzb3VyY2VbaSArIDJdICogdGhpcy5hbHBoYTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgICAgICAgY2FzZSAnbXVsdGlwbHknOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHIgKiB0ciAvIDI1NTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZyAqIHRnIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBiICogdGIgLyAyNTU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzY3JlZW4nOlxuICAgICAgICAgICAgZGF0YVtpXSA9IDEgLSAoMSAtIHIpICogKDEgLSB0cik7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IDEgLSAoMSAtIGcpICogKDEgLSB0Zyk7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IDEgLSAoMSAtIGIpICogKDEgLSB0Yik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdhZGQnOlxuICAgICAgICAgICAgZGF0YVtpXSA9IE1hdGgubWluKDI1NSwgciArIHRyKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gTWF0aC5taW4oMjU1LCBnICsgdGcpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBNYXRoLm1pbigyNTUsIGIgKyB0Yik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdkaWZmJzpcbiAgICAgICAgICBjYXNlICdkaWZmZXJlbmNlJzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSBNYXRoLmFicyhyIC0gdHIpO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBNYXRoLmFicyhnIC0gdGcpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBNYXRoLmFicyhiIC0gdGIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc3VidHJhY3QnOlxuICAgICAgICAgICAgX3IgPSByIC0gdHI7XG4gICAgICAgICAgICBfZyA9IGcgLSB0ZztcbiAgICAgICAgICAgIF9iID0gYiAtIHRiO1xuXG4gICAgICAgICAgICBkYXRhW2ldID0gKF9yIDwgMCkgPyAwIDogX3I7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IChfZyA8IDApID8gMCA6IF9nO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSAoX2IgPCAwKSA/IDAgOiBfYjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Rhcmtlbic6XG4gICAgICAgICAgICBkYXRhW2ldID0gTWF0aC5taW4ociwgdHIpO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBNYXRoLm1pbihnLCB0Zyk7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IE1hdGgubWluKGIsIHRiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2xpZ2h0ZW4nOlxuICAgICAgICAgICAgZGF0YVtpXSA9IE1hdGgubWF4KHIsIHRyKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gTWF0aC5tYXgoZywgdGcpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBNYXRoLm1heChiLCB0Yik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICAgIGltYWdlOiB0aGlzLmltYWdlLFxuICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgIGFscGhhOiB0aGlzLmFscGhhXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZH0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksIHBvdyA9IE1hdGgucG93LCBmbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICBzcXJ0ID0gTWF0aC5zcXJ0LCBhYnMgPSBNYXRoLmFicywgbWF4ID0gTWF0aC5tYXgsIHJvdW5kID0gTWF0aC5yb3VuZCwgc2luID0gTWF0aC5zaW4sXG4gICAgICBjZWlsID0gTWF0aC5jZWlsLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogUmVzaXplIGltYWdlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemUoKTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICovXG4gIGZpbHRlcnMuUmVzaXplID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ1Jlc2l6ZScsXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXNpemVUeXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByZXNpemVUeXBlOiAnaGVybWl0ZScsXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZSBmYWN0b3IgZm9yIHJlc2l6aW5nLCB4IGF4aXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVYXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzY2FsZVg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZSBmYWN0b3IgZm9yIHJlc2l6aW5nLCB5IGF4aXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVZXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzY2FsZVk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBMYW5jem9zTG9iZXMgcGFyYW1ldGVyIGZvciBsYW5jem9zIGZpbHRlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsYW5jem9zTG9iZXNcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxhbmN6b3NMb2JlczogMyxcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZmlsdGVyIHRvIGNhbnZhcyBlbGVtZW50XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVlcbiAgICAgKi9cbiAgICBhcHBseVRvOiBmdW5jdGlvbihjYW52YXNFbCwgc2NhbGVYLCBzY2FsZVkpIHtcbiAgICAgIGlmIChzY2FsZVggPT09IDEgJiYgc2NhbGVZID09PSAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yY3BTY2FsZVggPSAxIC8gc2NhbGVYO1xuICAgICAgdGhpcy5yY3BTY2FsZVkgPSAxIC8gc2NhbGVZO1xuXG4gICAgICB2YXIgb1cgPSBjYW52YXNFbC53aWR0aCwgb0ggPSBjYW52YXNFbC5oZWlnaHQsXG4gICAgICAgICAgZFcgPSByb3VuZChvVyAqIHNjYWxlWCksIGRIID0gcm91bmQob0ggKiBzY2FsZVkpLFxuICAgICAgICAgIGltYWdlRGF0YTtcblxuICAgICAgaWYgKHRoaXMucmVzaXplVHlwZSA9PT0gJ3NsaWNlSGFjaycpIHtcbiAgICAgICAgaW1hZ2VEYXRhID0gdGhpcy5zbGljZUJ5VHdvKGNhbnZhc0VsLCBvVywgb0gsIGRXLCBkSCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZXNpemVUeXBlID09PSAnaGVybWl0ZScpIHtcbiAgICAgICAgaW1hZ2VEYXRhID0gdGhpcy5oZXJtaXRlRmFzdFJlc2l6ZShjYW52YXNFbCwgb1csIG9ILCBkVywgZEgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmVzaXplVHlwZSA9PT0gJ2JpbGluZWFyJykge1xuICAgICAgICBpbWFnZURhdGEgPSB0aGlzLmJpbGluZWFyRmlsdGVyaW5nKGNhbnZhc0VsLCBvVywgb0gsIGRXLCBkSCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZXNpemVUeXBlID09PSAnbGFuY3pvcycpIHtcbiAgICAgICAgaW1hZ2VEYXRhID0gdGhpcy5sYW5jem9zUmVzaXplKGNhbnZhc0VsLCBvVywgb0gsIGRXLCBkSCk7XG4gICAgICB9XG4gICAgICBjYW52YXNFbC53aWR0aCA9IGRXO1xuICAgICAgY2FudmFzRWwuaGVpZ2h0ID0gZEg7XG4gICAgICBjYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpLnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgc2xpY2VCeVR3b1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb1cgT3JpZ2luYWwgV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb0ggT3JpZ2luYWwgSGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRXIERlc3RpbmF0aW9uIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRIIERlc3RpbmF0aW9uIEhlaWdodFxuICAgICAqIEByZXR1cm5zIHtJbWFnZURhdGF9XG4gICAgICovXG4gICAgc2xpY2VCeVR3bzogZnVuY3Rpb24oY2FudmFzRWwsIG9XLCBvSCwgZFcsIGRIKSB7XG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhc0VsLmdldENvbnRleHQoJzJkJyksIGltYWdlRGF0YSxcbiAgICAgICAgICBtdWx0VyA9IDAuNSwgbXVsdEggPSAwLjUsIHNpZ25XID0gMSwgc2lnbkggPSAxLFxuICAgICAgICAgIGRvbmVXID0gZmFsc2UsIGRvbmVIID0gZmFsc2UsIHN0ZXBXID0gb1csIHN0ZXBIID0gb0gsXG4gICAgICAgICAgdG1wQ2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLFxuICAgICAgICAgIHRtcEN0eCA9IHRtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgZFcgPSBmbG9vcihkVyk7XG4gICAgICBkSCA9IGZsb29yKGRIKTtcbiAgICAgIHRtcENhbnZhcy53aWR0aCA9IG1heChkVywgb1cpO1xuICAgICAgdG1wQ2FudmFzLmhlaWdodCA9IG1heChkSCwgb0gpO1xuXG4gICAgICBpZiAoZFcgPiBvVykge1xuICAgICAgICBtdWx0VyA9IDI7XG4gICAgICAgIHNpZ25XID0gLTE7XG4gICAgICB9XG4gICAgICBpZiAoZEggPiBvSCkge1xuICAgICAgICBtdWx0SCA9IDI7XG4gICAgICAgIHNpZ25IID0gLTE7XG4gICAgICB9XG4gICAgICBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBvVywgb0gpO1xuICAgICAgY2FudmFzRWwud2lkdGggPSBtYXgoZFcsIG9XKTtcbiAgICAgIGNhbnZhc0VsLmhlaWdodCA9IG1heChkSCwgb0gpO1xuICAgICAgY29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcblxuICAgICAgd2hpbGUgKCFkb25lVyB8fCAhZG9uZUgpIHtcbiAgICAgICAgb1cgPSBzdGVwVztcbiAgICAgICAgb0ggPSBzdGVwSDtcbiAgICAgICAgaWYgKGRXICogc2lnblcgPCBmbG9vcihzdGVwVyAqIG11bHRXICogc2lnblcpKSB7XG4gICAgICAgICAgc3RlcFcgPSBmbG9vcihzdGVwVyAqIG11bHRXKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzdGVwVyA9IGRXO1xuICAgICAgICAgIGRvbmVXID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZEggKiBzaWduSCA8IGZsb29yKHN0ZXBIICogbXVsdEggKiBzaWduSCkpIHtcbiAgICAgICAgICBzdGVwSCA9IGZsb29yKHN0ZXBIICogbXVsdEgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHN0ZXBIID0gZEg7XG4gICAgICAgICAgZG9uZUggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIG9XLCBvSCk7XG4gICAgICAgIHRtcEN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgc3RlcFcsIHN0ZXBIKTtcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UodG1wQ2FudmFzLCAwLCAwLCBvVywgb0gsIDAsIDAsIHN0ZXBXLCBzdGVwSCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgZFcsIGRIKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIGxhbmN6b3NSZXNpemVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9XIE9yaWdpbmFsIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9IIE9yaWdpbmFsIEhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkVyBEZXN0aW5hdGlvbiBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkSCBEZXN0aW5hdGlvbiBIZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2VEYXRhfVxuICAgICAqL1xuICAgIGxhbmN6b3NSZXNpemU6IGZ1bmN0aW9uKGNhbnZhc0VsLCBvVywgb0gsIGRXLCBkSCkge1xuXG4gICAgICBmdW5jdGlvbiBsYW5jem9zQ3JlYXRlKGxvYmVzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgaWYgKHggPiBsb2Jlcykge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHggKj0gTWF0aC5QSTtcbiAgICAgICAgICBpZiAoYWJzKHgpIDwgMWUtMTYpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgeHggPSB4IC8gbG9iZXM7XG4gICAgICAgICAgcmV0dXJuIHNpbih4KSAqIHNpbih4eCkgLyB4IC8geHg7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHByb2Nlc3ModSkge1xuICAgICAgICB2YXIgdiwgaSwgd2VpZ2h0LCBpZHgsIGEsIHJlZCwgZ3JlZW4sXG4gICAgICAgICAgICBibHVlLCBhbHBoYSwgZlgsIGZZO1xuICAgICAgICBjZW50ZXIueCA9ICh1ICsgMC41KSAqIHJhdGlvWDtcbiAgICAgICAgaWNlbnRlci54ID0gZmxvb3IoY2VudGVyLngpO1xuICAgICAgICBmb3IgKHYgPSAwOyB2IDwgZEg7IHYrKykge1xuICAgICAgICAgIGNlbnRlci55ID0gKHYgKyAwLjUpICogcmF0aW9ZO1xuICAgICAgICAgIGljZW50ZXIueSA9IGZsb29yKGNlbnRlci55KTtcbiAgICAgICAgICBhID0gMDsgcmVkID0gMDsgZ3JlZW4gPSAwOyBibHVlID0gMDsgYWxwaGEgPSAwO1xuICAgICAgICAgIGZvciAoaSA9IGljZW50ZXIueCAtIHJhbmdlMlg7IGkgPD0gaWNlbnRlci54ICsgcmFuZ2UyWDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA8IDAgfHwgaSA+PSBvVykge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZYID0gZmxvb3IoMTAwMCAqIGFicyhpIC0gY2VudGVyLngpKTtcbiAgICAgICAgICAgIGlmICghY2FjaGVMYW5jW2ZYXSkge1xuICAgICAgICAgICAgICBjYWNoZUxhbmNbZlhdID0geyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGljZW50ZXIueSAtIHJhbmdlMlk7IGogPD0gaWNlbnRlci55ICsgcmFuZ2UyWTsgaisrKSB7XG4gICAgICAgICAgICAgIGlmIChqIDwgMCB8fCBqID49IG9IKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZlkgPSBmbG9vcigxMDAwICogYWJzKGogLSBjZW50ZXIueSkpO1xuICAgICAgICAgICAgICBpZiAoIWNhY2hlTGFuY1tmWF1bZlldKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVMYW5jW2ZYXVtmWV0gPSBsYW5jem9zKHNxcnQocG93KGZYICogcmNwUmF0aW9YLCAyKSArIHBvdyhmWSAqIHJjcFJhdGlvWSwgMikpIC8gMTAwMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd2VpZ2h0ID0gY2FjaGVMYW5jW2ZYXVtmWV07XG4gICAgICAgICAgICAgIGlmICh3ZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWR4ID0gKGogKiBvVyArIGkpICogNDtcbiAgICAgICAgICAgICAgICBhICs9IHdlaWdodDtcbiAgICAgICAgICAgICAgICByZWQgKz0gd2VpZ2h0ICogc3JjRGF0YVtpZHhdO1xuICAgICAgICAgICAgICAgIGdyZWVuICs9IHdlaWdodCAqIHNyY0RhdGFbaWR4ICsgMV07XG4gICAgICAgICAgICAgICAgYmx1ZSArPSB3ZWlnaHQgKiBzcmNEYXRhW2lkeCArIDJdO1xuICAgICAgICAgICAgICAgIGFscGhhICs9IHdlaWdodCAqIHNyY0RhdGFbaWR4ICsgM107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWR4ID0gKHYgKiBkVyArIHUpICogNDtcbiAgICAgICAgICBkZXN0RGF0YVtpZHhdID0gcmVkIC8gYTtcbiAgICAgICAgICBkZXN0RGF0YVtpZHggKyAxXSA9IGdyZWVuIC8gYTtcbiAgICAgICAgICBkZXN0RGF0YVtpZHggKyAyXSA9IGJsdWUgLyBhO1xuICAgICAgICAgIGRlc3REYXRhW2lkeCArIDNdID0gYWxwaGEgLyBhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCsrdSA8IGRXKSB7XG4gICAgICAgICAgcmV0dXJuIHByb2Nlc3ModSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlc3RJbWc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICAgIHNyY0ltZyA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIG9XLCBvSCksXG4gICAgICAgICAgZGVzdEltZyA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGRXLCBkSCksXG4gICAgICAgICAgc3JjRGF0YSA9IHNyY0ltZy5kYXRhLCBkZXN0RGF0YSA9IGRlc3RJbWcuZGF0YSxcbiAgICAgICAgICBsYW5jem9zID0gbGFuY3pvc0NyZWF0ZSh0aGlzLmxhbmN6b3NMb2JlcyksXG4gICAgICAgICAgcmF0aW9YID0gdGhpcy5yY3BTY2FsZVgsIHJhdGlvWSA9IHRoaXMucmNwU2NhbGVZLFxuICAgICAgICAgIHJjcFJhdGlvWCA9IDIgLyB0aGlzLnJjcFNjYWxlWCwgcmNwUmF0aW9ZID0gMiAvIHRoaXMucmNwU2NhbGVZLFxuICAgICAgICAgIHJhbmdlMlggPSBjZWlsKHJhdGlvWCAqIHRoaXMubGFuY3pvc0xvYmVzIC8gMiksXG4gICAgICAgICAgcmFuZ2UyWSA9IGNlaWwocmF0aW9ZICogdGhpcy5sYW5jem9zTG9iZXMgLyAyKSxcbiAgICAgICAgICBjYWNoZUxhbmMgPSB7IH0sIGNlbnRlciA9IHsgfSwgaWNlbnRlciA9IHsgfTtcblxuICAgICAgcmV0dXJuIHByb2Nlc3MoMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGJpbGluZWFyRmlsdGVyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvVyBPcmlnaW5hbCBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvSCBPcmlnaW5hbCBIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZFcgRGVzdGluYXRpb24gV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZEggRGVzdGluYXRpb24gSGVpZ2h0XG4gICAgICogQHJldHVybnMge0ltYWdlRGF0YX1cbiAgICAgKi9cbiAgICBiaWxpbmVhckZpbHRlcmluZzogZnVuY3Rpb24oY2FudmFzRWwsIG9XLCBvSCwgZFcsIGRIKSB7XG4gICAgICB2YXIgYSwgYiwgYywgZCwgeCwgeSwgaSwgaiwgeERpZmYsIHlEaWZmLCBjaG5sLFxuICAgICAgICAgIGNvbG9yLCBvZmZzZXQgPSAwLCBvcmlnUGl4LCByYXRpb1ggPSB0aGlzLnJjcFNjYWxlWCxcbiAgICAgICAgICByYXRpb1kgPSB0aGlzLnJjcFNjYWxlWSwgY29udGV4dCA9IGNhbnZhc0VsLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgdzQgPSA0ICogKG9XIC0gMSksIGltZyA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIG9XLCBvSCksXG4gICAgICAgICAgcGl4ZWxzID0gaW1nLmRhdGEsIGRlc3RJbWFnZSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGRXLCBkSCksXG4gICAgICAgICAgZGVzdFBpeGVscyA9IGRlc3RJbWFnZS5kYXRhO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGRIOyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGRXOyBqKyspIHtcbiAgICAgICAgICB4ID0gZmxvb3IocmF0aW9YICogaik7XG4gICAgICAgICAgeSA9IGZsb29yKHJhdGlvWSAqIGkpO1xuICAgICAgICAgIHhEaWZmID0gcmF0aW9YICogaiAtIHg7XG4gICAgICAgICAgeURpZmYgPSByYXRpb1kgKiBpIC0geTtcbiAgICAgICAgICBvcmlnUGl4ID0gNCAqICh5ICogb1cgKyB4KTtcblxuICAgICAgICAgIGZvciAoY2hubCA9IDA7IGNobmwgPCA0OyBjaG5sKyspIHtcbiAgICAgICAgICAgIGEgPSBwaXhlbHNbb3JpZ1BpeCArIGNobmxdO1xuICAgICAgICAgICAgYiA9IHBpeGVsc1tvcmlnUGl4ICsgNCArIGNobmxdO1xuICAgICAgICAgICAgYyA9IHBpeGVsc1tvcmlnUGl4ICsgdzQgKyBjaG5sXTtcbiAgICAgICAgICAgIGQgPSBwaXhlbHNbb3JpZ1BpeCArIHc0ICsgNCArIGNobmxdO1xuICAgICAgICAgICAgY29sb3IgPSBhICogKDEgLSB4RGlmZikgKiAoMSAtIHlEaWZmKSArIGIgKiB4RGlmZiAqICgxIC0geURpZmYpICtcbiAgICAgICAgICAgICAgICAgICAgYyAqIHlEaWZmICogKDEgLSB4RGlmZikgKyBkICogeERpZmYgKiB5RGlmZjtcbiAgICAgICAgICAgIGRlc3RQaXhlbHNbb2Zmc2V0KytdID0gY29sb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzdEltYWdlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBoZXJtaXRlRmFzdFJlc2l6ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb1cgT3JpZ2luYWwgV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb0ggT3JpZ2luYWwgSGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRXIERlc3RpbmF0aW9uIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRIIERlc3RpbmF0aW9uIEhlaWdodFxuICAgICAqIEByZXR1cm5zIHtJbWFnZURhdGF9XG4gICAgICovXG4gICAgaGVybWl0ZUZhc3RSZXNpemU6IGZ1bmN0aW9uKGNhbnZhc0VsLCBvVywgb0gsIGRXLCBkSCkge1xuICAgICAgdmFyIHJhdGlvVyA9IHRoaXMucmNwU2NhbGVYLCByYXRpb0ggPSB0aGlzLnJjcFNjYWxlWSxcbiAgICAgICAgICByYXRpb1dIYWxmID0gY2VpbChyYXRpb1cgLyAyKSxcbiAgICAgICAgICByYXRpb0hIYWxmID0gY2VpbChyYXRpb0ggLyAyKSxcbiAgICAgICAgICBjb250ZXh0ID0gY2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICBpbWcgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBvVywgb0gpLCBkYXRhID0gaW1nLmRhdGEsXG4gICAgICAgICAgaW1nMiA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGRXLCBkSCksIGRhdGEyID0gaW1nMi5kYXRhO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkSDsgaisrKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZFc7IGkrKykge1xuICAgICAgICAgIHZhciB4MiA9IChpICsgaiAqIGRXKSAqIDQsIHdlaWdodCA9IDAsIHdlaWdodHMgPSAwLCB3ZWlnaHRzQWxwaGEgPSAwLFxuICAgICAgICAgICAgICBneFIgPSAwLCBneEcgPSAwLCBneEIgPSAwLCBneEEgPSAwLCBjZW50ZXJZID0gKGogKyAwLjUpICogcmF0aW9IO1xuICAgICAgICAgIGZvciAodmFyIHl5ID0gZmxvb3IoaiAqIHJhdGlvSCk7IHl5IDwgKGogKyAxKSAqIHJhdGlvSDsgeXkrKykge1xuICAgICAgICAgICAgdmFyIGR5ID0gYWJzKGNlbnRlclkgLSAoeXkgKyAwLjUpKSAvIHJhdGlvSEhhbGYsXG4gICAgICAgICAgICAgICAgY2VudGVyWCA9IChpICsgMC41KSAqIHJhdGlvVywgdzAgPSBkeSAqIGR5O1xuICAgICAgICAgICAgZm9yICh2YXIgeHggPSBmbG9vcihpICogcmF0aW9XKTsgeHggPCAoaSArIDEpICogcmF0aW9XOyB4eCsrKSB7XG4gICAgICAgICAgICAgIHZhciBkeCA9IGFicyhjZW50ZXJYIC0gKHh4ICsgMC41KSkgLyByYXRpb1dIYWxmLFxuICAgICAgICAgICAgICAgICAgdyA9IHNxcnQodzAgKyBkeCAqIGR4KTtcbiAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWRlcHRoICovXG4gICAgICAgICAgICAgIGlmICh3ID4gMSAmJiB3IDwgLTEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvL2hlcm1pdGUgZmlsdGVyXG4gICAgICAgICAgICAgIHdlaWdodCA9IDIgKiB3ICogdyAqIHcgLSAzICogdyAqIHcgKyAxO1xuICAgICAgICAgICAgICBpZiAod2VpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgIGR4ID0gNCAqICh4eCArIHl5ICogb1cpO1xuICAgICAgICAgICAgICAgIC8vYWxwaGFcbiAgICAgICAgICAgICAgICBneEEgKz0gd2VpZ2h0ICogZGF0YVtkeCArIDNdO1xuICAgICAgICAgICAgICAgIHdlaWdodHNBbHBoYSArPSB3ZWlnaHQ7XG4gICAgICAgICAgICAgICAgLy9jb2xvcnNcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtkeCArIDNdIDwgMjU1KSB7XG4gICAgICAgICAgICAgICAgICB3ZWlnaHQgPSB3ZWlnaHQgKiBkYXRhW2R4ICsgM10gLyAyNTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGd4UiArPSB3ZWlnaHQgKiBkYXRhW2R4XTtcbiAgICAgICAgICAgICAgICBneEcgKz0gd2VpZ2h0ICogZGF0YVtkeCArIDFdO1xuICAgICAgICAgICAgICAgIGd4QiArPSB3ZWlnaHQgKiBkYXRhW2R4ICsgMl07XG4gICAgICAgICAgICAgICAgd2VpZ2h0cyArPSB3ZWlnaHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBtYXgtZGVwdGggKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YTJbeDJdID0gZ3hSIC8gd2VpZ2h0cztcbiAgICAgICAgICBkYXRhMlt4MiArIDFdID0gZ3hHIC8gd2VpZ2h0cztcbiAgICAgICAgICBkYXRhMlt4MiArIDJdID0gZ3hCIC8gd2VpZ2h0cztcbiAgICAgICAgICBkYXRhMlt4MiArIDNdID0gZ3hBIC8gd2VpZ2h0c0FscGhhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW1nMjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgc2NhbGVYOiB0aGlzLnNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiB0aGlzLnNjYWxlWSxcbiAgICAgICAgcmVzaXplVHlwZTogdGhpcy5yZXNpemVUeXBlLFxuICAgICAgICBsYW5jem9zTG9iZXM6IHRoaXMubGFuY3pvc0xvYmVzXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemV9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQ29sb3IgTWF0cml4IGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXhcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXgjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAc2VlIHtATGluayBodHRwOi8vd3d3LndlYndhc3AuY28udWsvdHV0b3JpYWxzLzIxOS9Db2xvcl9NYXRyaXhfRmlsdGVyLnBocH1cbiAgICogQHNlZSB7QExpbmsgaHR0cDovL3Bob2Jvc2xhYi5vcmcvbG9nLzIwMTMvMTEvZmFzdC1pbWFnZS1maWx0ZXJzLXdpdGgtd2ViZ2x9XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPktvZGFjaHJvbWUgZmlsdGVyPC9jYXB0aW9uPlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4KHtcbiAgICogIG1hdHJpeDogW1xuICAgICAgIDEuMTI4NTU4MjM5NjU5MzUyNSwgLTAuMzk2NzM4MjI4MzYwMTM0OCwgLTAuMDM5OTI1NTkxNzI5MjE3OTMsIDAsIDYzLjcyOTU4NzYyMTk2NTAyLFxuICAgICAgIC0wLjE2NDA0MzM5OTYyMjQ0NjE2LCAxLjA4MzUyNTE1NjYyOTEzMDQsIC0wLjA1NDk4ODA1MTE1NjMzMTMyLCAwLCAyNC43MzI0MDc4OTY3MDYyMDMsXG4gICAgICAgLTAuMTY3ODYwMTA3MDYxNTU3NjMsIC0wLjU2MDM0MTYyNzc2OTUyNDgsIDEuNjAxNDg1MDc2MTk2NDk0MywgMCwgMzUuNjI5ODI4MDc0NjA5NDYsXG4gICAgICAgMCwgMCwgMCwgMSwgMFxuICAgICAgXVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICovXG4gIGZpbHRlcnMuQ29sb3JNYXRyaXggPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXgucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdDb2xvck1hdHJpeCcsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubWF0cml4XSBDb2xvciBNYXRyaXggdG8gbW9kaWZ5IHRoZSBpbWFnZSBkYXRhIHdpdGhcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcbiAgICAgIG9wdGlvbnMgfHwgKCBvcHRpb25zID0ge30gKTtcbiAgICAgIHRoaXMubWF0cml4ID0gb3B0aW9ucy5tYXRyaXggfHwgW1xuICAgICAgICAxLCAwLCAwLCAwLCAwLFxuICAgICAgICAwLCAxLCAwLCAwLCAwLFxuICAgICAgICAwLCAwLCAxLCAwLCAwLFxuICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlciB0byBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKi9cbiAgICBhcHBseVRvOiBmdW5jdGlvbiggY2FudmFzRWwgKSB7XG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhc0VsLmdldENvbnRleHQoICcyZCcgKSxcbiAgICAgICAgICBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSggMCwgMCwgY2FudmFzRWwud2lkdGgsIGNhbnZhc0VsLmhlaWdodCApLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBpTGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgaSxcbiAgICAgICAgICByLFxuICAgICAgICAgIGcsXG4gICAgICAgICAgYixcbiAgICAgICAgICBhLFxuICAgICAgICAgIG0gPSB0aGlzLm1hdHJpeDtcblxuICAgICAgZm9yICggaSA9IDA7IGkgPCBpTGVuOyBpICs9IDQgKSB7XG4gICAgICAgIHIgPSBkYXRhWyBpIF07XG4gICAgICAgIGcgPSBkYXRhWyBpICsgMSBdO1xuICAgICAgICBiID0gZGF0YVsgaSArIDIgXTtcbiAgICAgICAgYSA9IGRhdGFbIGkgKyAzIF07XG5cbiAgICAgICAgZGF0YVsgaSBdID0gciAqIG1bIDAgXSArIGcgKiBtWyAxIF0gKyBiICogbVsgMiBdICsgYSAqIG1bIDMgXSArIG1bIDQgXTtcbiAgICAgICAgZGF0YVsgaSArIDEgXSA9IHIgKiBtWyA1IF0gKyBnICogbVsgNiBdICsgYiAqIG1bIDcgXSArIGEgKiBtWyA4IF0gKyBtWyA5IF07XG4gICAgICAgIGRhdGFbIGkgKyAyIF0gPSByICogbVsgMTAgXSArIGcgKiBtWyAxMSBdICsgYiAqIG1bIDEyIF0gKyBhICogbVsgMTMgXSArIG1bIDE0IF07XG4gICAgICAgIGRhdGFbIGkgKyAzIF0gPSByICogbVsgMTUgXSArIGcgKiBtWyAxNiBdICsgYiAqIG1bIDE3IF0gKyBhICogbVsgMTggXSArIG1bIDE5IF07XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKCBpbWFnZURhdGEsIDAsIDAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JyksIHtcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBtYXRyaXg6IHRoaXMubWF0cml4XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gZnVuY3Rpb24gdG8gaW52b2tlIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeH0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXhcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4LmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIENvbnRyYXN0IGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3RcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3QjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0KHtcbiAgICogICBjb250cmFzdDogNDBcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycyhjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAqL1xuICBmaWx0ZXJzLkNvbnRyYXN0ID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnQ29udHJhc3QnLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3QucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb250cmFzdD0wXSBWYWx1ZSB0byBjb250cmFzdCB0aGUgaW1hZ2UgdXAgKC0yNTUuLi4yNTUpXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuICAgICAgdGhpcy5jb250cmFzdCA9IG9wdGlvbnMuY29udHJhc3QgfHwgMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBmaWx0ZXIgdG8gY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICovXG4gICAgYXBwbHlUbzogZnVuY3Rpb24oY2FudmFzRWwpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXNFbC53aWR0aCwgY2FudmFzRWwuaGVpZ2h0KSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgY29udHJhc3RGID0gMjU5ICogKHRoaXMuY29udHJhc3QgKyAyNTUpIC8gKDI1NSAqICgyNTkgLSB0aGlzLmNvbnRyYXN0KSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGRhdGFbaV0gPSBjb250cmFzdEYgKiAoZGF0YVtpXSAtIDEyOCkgKyAxMjg7XG4gICAgICAgIGRhdGFbaSArIDFdID0gY29udHJhc3RGICogKGRhdGFbaSArIDFdIC0gMTI4KSArIDEyODtcbiAgICAgICAgZGF0YVtpICsgMl0gPSBjb250cmFzdEYgKiAoZGF0YVtpICsgMl0gLSAxMjgpICsgMTI4O1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnKSwge1xuICAgICAgICBjb250cmFzdDogdGhpcy5jb250cmFzdFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0fSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdFxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3QuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBTYXR1cmF0ZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0ZSh7XG4gICAqICAgc2F0dXJhdGU6IDEwMFxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICovXG4gIGZpbHRlcnMuU2F0dXJhdGUgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdTYXR1cmF0ZScsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNhdHVyYXRlPTBdIFZhbHVlIHRvIHNhdHVyYXRlIHRoZSBpbWFnZSAoLTEwMC4uLjEwMClcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG4gICAgICB0aGlzLnNhdHVyYXRlID0gb3B0aW9ucy5zYXR1cmF0ZSB8fCAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlciB0byBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKi9cbiAgICBhcHBseVRvOiBmdW5jdGlvbihjYW52YXNFbCkge1xuICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICAgIGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhc0VsLndpZHRoLCBjYW52YXNFbC5oZWlnaHQpLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBtYXgsIGFkanVzdCA9IC10aGlzLnNhdHVyYXRlICogMC4wMTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgoZGF0YVtpXSwgZGF0YVtpICsgMV0sIGRhdGFbaSArIDJdKTtcbiAgICAgICAgZGF0YVtpXSArPSBtYXggIT09IGRhdGFbaV0gPyAobWF4IC0gZGF0YVtpXSkgKiBhZGp1c3QgOiAwO1xuICAgICAgICBkYXRhW2kgKyAxXSArPSBtYXggIT09IGRhdGFbaSArIDFdID8gKG1heCAtIGRhdGFbaSArIDFdKSAqIGFkanVzdCA6IDA7XG4gICAgICAgIGRhdGFbaSArIDJdICs9IG1heCAhPT0gZGF0YVtpICsgMl0gPyAobWF4IC0gZGF0YVtpICsgMl0pICogYWRqdXN0IDogMDtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JyksIHtcbiAgICAgICAgc2F0dXJhdGU6IHRoaXMuc2F0dXJhdGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0ZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGVcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRlLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkLFxuICAgICAgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUyxcbiAgICAgIE1JTl9URVhUX1dJRFRIID0gMjtcblxuICBpZiAoZmFicmljLlRleHQpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlRleHQgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHN0YXRlUHJvcGVydGllcyA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnN0YXRlUHJvcGVydGllcy5jb25jYXQoKTtcbiAgc3RhdGVQcm9wZXJ0aWVzLnB1c2goXG4gICAgJ2ZvbnRGYW1pbHknLFxuICAgICdmb250V2VpZ2h0JyxcbiAgICAnZm9udFNpemUnLFxuICAgICd0ZXh0JyxcbiAgICAndGV4dERlY29yYXRpb24nLFxuICAgICd0ZXh0QWxpZ24nLFxuICAgICdmb250U3R5bGUnLFxuICAgICdsaW5lSGVpZ2h0JyxcbiAgICAndGV4dEJhY2tncm91bmRDb2xvcicsXG4gICAgJ2NoYXJTcGFjaW5nJ1xuICApO1xuXG4gIHZhciBjYWNoZVByb3BlcnRpZXMgPSBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KCk7XG4gIGNhY2hlUHJvcGVydGllcy5wdXNoKFxuICAgICdmb250RmFtaWx5JyxcbiAgICAnZm9udFdlaWdodCcsXG4gICAgJ2ZvbnRTaXplJyxcbiAgICAndGV4dCcsXG4gICAgJ3RleHREZWNvcmF0aW9uJyxcbiAgICAndGV4dEFsaWduJyxcbiAgICAnZm9udFN0eWxlJyxcbiAgICAnbGluZUhlaWdodCcsXG4gICAgJ3RleHRCYWNrZ3JvdW5kQ29sb3InLFxuICAgICdjaGFyU3BhY2luZycsXG4gICAgJ3N0eWxlcydcbiAgKTtcbiAgLyoqXG4gICAqIFRleHQgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5UZXh0XG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLlRleHR9IHRoaXNBcmdcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTIjdGV4dH1cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlRleHQjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5UZXh0ID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuVGV4dC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyB3aGljaCB3aGVuIHNldCBjYXVzZSBvYmplY3QgdG8gY2hhbmdlIGRpbWVuc2lvbnNcbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kaW1lbnNpb25BZmZlY3RpbmdQcm9wczogW1xuICAgICAgJ2ZvbnRTaXplJyxcbiAgICAgICdmb250V2VpZ2h0JyxcbiAgICAgICdmb250RmFtaWx5JyxcbiAgICAgICdmb250U3R5bGUnLFxuICAgICAgJ2xpbmVIZWlnaHQnLFxuICAgICAgJ3RleHQnLFxuICAgICAgJ2NoYXJTcGFjaW5nJyxcbiAgICAgICd0ZXh0QWxpZ24nXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlTmV3bGluZTogL1xccj9cXG4vLFxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgcmVndWxhciBleHByZXNzaW9uIHRvIGZpbHRlciBmb3Igd2hpdGVzcGFjZSB0aGF0IGlzIG5vdCBhIG5ldyBsaW5lLlxuICAgICAqIE1vc3RseSB1c2VkIHdoZW4gdGV4dCBpcyAnanVzdGlmeScgYWxpZ25lZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZVNwYWNlc0FuZFRhYnM6IC9bIFxcdFxccl0rL2csXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgb2JqZWN0J3MgZm9udFNpemVcbiAgICAgKiBAbWV0aG9kIGdldEZvbnRTaXplXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gRm9udCBzaXplIChpbiBwaXhlbHMpXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9iamVjdCdzIGZvbnRTaXplXG4gICAgICogRG9lcyBub3QgdXBkYXRlIHRoZSBvYmplY3QgLndpZHRoIGFuZCAuaGVpZ2h0LFxuICAgICAqIGNhbGwgLl9pbml0RGltZW5zaW9ucygpIHRvIHVwZGF0ZSB0aGUgdmFsdWVzLlxuICAgICAqIEBtZXRob2Qgc2V0Rm9udFNpemVcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZvbnRTaXplIEZvbnQgc2l6ZSAoaW4gcGl4ZWxzKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5UZXh0fVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBvYmplY3QncyBmb250V2VpZ2h0XG4gICAgICogQG1ldGhvZCBnZXRGb250V2VpZ2h0XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4geyhTdHJpbmd8TnVtYmVyKX0gRm9udCB3ZWlnaHRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFNldHMgb2JqZWN0J3MgZm9udFdlaWdodFxuICAgICAqIERvZXMgbm90IHVwZGF0ZSB0aGUgb2JqZWN0IC53aWR0aCBhbmQgLmhlaWdodCxcbiAgICAgKiBjYWxsIC5faW5pdERpbWVuc2lvbnMoKSB0byB1cGRhdGUgdGhlIHZhbHVlcy5cbiAgICAgKiBAbWV0aG9kIHNldEZvbnRXZWlnaHRcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHsoTnVtYmVyfFN0cmluZyl9IGZvbnRXZWlnaHQgRm9udCB3ZWlnaHRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dH1cbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgb2JqZWN0J3MgZm9udEZhbWlseVxuICAgICAqIEBtZXRob2QgZ2V0Rm9udEZhbWlseVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IEZvbnQgZmFtaWx5XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9iamVjdCdzIGZvbnRGYW1pbHlcbiAgICAgKiBEb2VzIG5vdCB1cGRhdGUgdGhlIG9iamVjdCAud2lkdGggYW5kIC5oZWlnaHQsXG4gICAgICogY2FsbCAuX2luaXREaW1lbnNpb25zKCkgdG8gdXBkYXRlIHRoZSB2YWx1ZXMuXG4gICAgICogQG1ldGhvZCBzZXRGb250RmFtaWx5XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb250RmFtaWx5IEZvbnQgZmFtaWx5XG4gICAgICogQHJldHVybiB7ZmFicmljLlRleHR9XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG9iamVjdCdzIHRleHRcbiAgICAgKiBAbWV0aG9kIGdldFRleHRcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHQucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0ZXh0XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9iamVjdCdzIHRleHRcbiAgICAgKiBEb2VzIG5vdCB1cGRhdGUgdGhlIG9iamVjdCAud2lkdGggYW5kIC5oZWlnaHQsXG4gICAgICogY2FsbCAuX2luaXREaW1lbnNpb25zKCkgdG8gdXBkYXRlIHRoZSB2YWx1ZXMuXG4gICAgICogQG1ldGhvZCBzZXRUZXh0XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRleHRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dH1cbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgb2JqZWN0J3MgdGV4dERlY29yYXRpb25cbiAgICAgKiBAbWV0aG9kIGdldFRleHREZWNvcmF0aW9uXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGV4dCBkZWNvcmF0aW9uXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9iamVjdCdzIHRleHREZWNvcmF0aW9uXG4gICAgICogQG1ldGhvZCBzZXRUZXh0RGVjb3JhdGlvblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dERlY29yYXRpb24gVGV4dCBkZWNvcmF0aW9uXG4gICAgICogQHJldHVybiB7ZmFicmljLlRleHR9XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG9iamVjdCdzIGZvbnRTdHlsZVxuICAgICAqIEBtZXRob2QgZ2V0Rm9udFN0eWxlXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gRm9udCBzdHlsZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBvYmplY3QncyBmb250U3R5bGVcbiAgICAgKiBEb2VzIG5vdCB1cGRhdGUgdGhlIG9iamVjdCAud2lkdGggYW5kIC5oZWlnaHQsXG4gICAgICogY2FsbCAuX2luaXREaW1lbnNpb25zKCkgdG8gdXBkYXRlIHRoZSB2YWx1ZXMuXG4gICAgICogQG1ldGhvZCBzZXRGb250U3R5bGVcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZvbnRTdHlsZSBGb250IHN0eWxlXG4gICAgICogQHJldHVybiB7ZmFicmljLlRleHR9XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG9iamVjdCdzIGxpbmVIZWlnaHRcbiAgICAgKiBAbWV0aG9kIGdldExpbmVIZWlnaHRcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHQucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBMaW5lIGhlaWdodFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBvYmplY3QncyBsaW5lSGVpZ2h0XG4gICAgICogQG1ldGhvZCBzZXRMaW5lSGVpZ2h0XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSGVpZ2h0IExpbmUgaGVpZ2h0XG4gICAgICogQHJldHVybiB7ZmFicmljLlRleHR9XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG9iamVjdCdzIHRleHRBbGlnblxuICAgICAqIEBtZXRob2QgZ2V0VGV4dEFsaWduXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGV4dCBhbGlnbm1lbnRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFNldHMgb2JqZWN0J3MgdGV4dEFsaWduXG4gICAgICogQG1ldGhvZCBzZXRUZXh0QWxpZ25cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHRBbGlnbiBUZXh0IGFsaWdubWVudFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5UZXh0fVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBvYmplY3QncyB0ZXh0QmFja2dyb3VuZENvbG9yXG4gICAgICogQG1ldGhvZCBnZXRUZXh0QmFja2dyb3VuZENvbG9yXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGV4dCBiYWNrZ3JvdW5kIGNvbG9yXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9iamVjdCdzIHRleHRCYWNrZ3JvdW5kQ29sb3JcbiAgICAgKiBAbWV0aG9kIHNldFRleHRCYWNrZ3JvdW5kQ29sb3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHRCYWNrZ3JvdW5kQ29sb3IgVGV4dCBiYWNrZ3JvdW5kIGNvbG9yXG4gICAgICogQHJldHVybiB7ZmFicmljLlRleHR9XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICAgICAgICAgICAgICAgICAndGV4dCcsXG5cbiAgICAvKipcbiAgICAgKiBGb250IHNpemUgKGluIHBpeGVscylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZvbnRTaXplOiAgICAgICAgICAgICA0MCxcblxuICAgIC8qKlxuICAgICAqIEZvbnQgd2VpZ2h0IChlLmcuIGJvbGQsIG5vcm1hbCwgNDAwLCA2MDAsIDgwMClcbiAgICAgKiBAdHlwZSB7KE51bWJlcnxTdHJpbmcpfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZm9udFdlaWdodDogICAgICAgICAgICdub3JtYWwnLFxuXG4gICAgLyoqXG4gICAgICogRm9udCBmYW1pbHlcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZvbnRGYW1pbHk6ICAgICAgICAgICAnVGltZXMgTmV3IFJvbWFuJyxcblxuICAgIC8qKlxuICAgICAqIFRleHQgZGVjb3JhdGlvbiBQb3NzaWJsZSB2YWx1ZXM6IFwiXCIsIFwidW5kZXJsaW5lXCIsIFwib3ZlcmxpbmVcIiBvciBcImxpbmUtdGhyb3VnaFwiLlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdGV4dERlY29yYXRpb246ICAgICAgICcnLFxuXG4gICAgLyoqXG4gICAgICogVGV4dCBhbGlnbm1lbnQuIFBvc3NpYmxlIHZhbHVlczogXCJsZWZ0XCIsIFwiY2VudGVyXCIsIFwicmlnaHRcIiBvciBcImp1c3RpZnlcIi5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRleHRBbGlnbjogICAgICAgICAgICAnbGVmdCcsXG5cbiAgICAvKipcbiAgICAgKiBGb250IHN0eWxlIC4gUG9zc2libGUgdmFsdWVzOiBcIlwiLCBcIm5vcm1hbFwiLCBcIml0YWxpY1wiIG9yIFwib2JsaXF1ZVwiLlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZm9udFN0eWxlOiAgICAgICAgICAgICcnLFxuXG4gICAgLyoqXG4gICAgICogTGluZSBoZWlnaHRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxpbmVIZWlnaHQ6ICAgICAgICAgICAxLjE2LFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBjb2xvciBvZiB0ZXh0IGxpbmVzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0ZXh0QmFja2dyb3VuZENvbG9yOiAgJycsXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZlxuICAgICAqIHN0YXRlIG9mIGFuIG9iamVjdCBpcyBjaGFuZ2VkICh7QGxpbmsgZmFicmljLk9iamVjdCNoYXNTdGF0ZUNoYW5nZWR9KVxuICAgICAqIGFzIHdlbGwgYXMgZm9yIGhpc3RvcnkgKHVuZG8vcmVkbykgcHVycG9zZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHN0YXRlUHJvcGVydGllczogICAgICBzdGF0ZVByb3BlcnRpZXMsXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZiBjYWNoZSBuZWVkcyByZWZyZXNoXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBjYWNoZVByb3BlcnRpZXM6ICAgICAgY2FjaGVQcm9wZXJ0aWVzLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBkZWZpbmVkLCBhbiBvYmplY3QgaXMgcmVuZGVyZWQgdmlhIHN0cm9rZSBhbmQgdGhpcyBwcm9wZXJ0eSBzcGVjaWZpZXMgaXRzIGNvbG9yLlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgd2FzIG5hbWVkIFwic3Ryb2tlU3R5bGVcIiB1bnRpbCB2MS4xLjZcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZTogICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogU2hhZG93IG9iamVjdCByZXByZXNlbnRpbmcgc2hhZG93IG9mIHRoaXMgc2hhcGUuXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSB3YXMgbmFtZWQgXCJ0ZXh0U2hhZG93XCIgKFN0cmluZykgdW50aWwgdjEuMi4xMVxuICAgICAqIEB0eXBlIGZhYnJpYy5TaGFkb3dcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNoYWRvdzogICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZm9udFNpemVGcmFjdGlvbjogMC4yNSxcblxuICAgIC8qKlxuICAgICAqIFRleHQgTGluZSBwcm9wb3J0aW9uIHRvIGZvbnQgU2l6ZSAoaW4gcGl4ZWxzKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgX2ZvbnRTaXplTXVsdDogICAgICAgICAgICAgMS4xMyxcblxuICAgIC8qKlxuICAgICAqIGFkZGl0aW9uYWwgc3BhY2UgYmV0d2VlbiBjaGFyYWN0ZXJzXG4gICAgICogZXhwcmVzc2VkIGluIHRob3VzYW5kcyBvZiBlbSB1bml0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjaGFyU3BhY2luZzogICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGV4dCBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLlRleHR9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbih0ZXh0LCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG4gICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgdGhpcy5fX3NraXBEaW1lbnNpb24gPSB0cnVlO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX19za2lwRGltZW5zaW9uID0gZmFsc2U7XG4gICAgICB0aGlzLl9pbml0RGltZW5zaW9ucygpO1xuICAgICAgdGhpcy5zZXR1cFN0YXRlKHsgcHJvcGVydHlTZXQ6ICdfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMnIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRleHQgZGltZW5zaW9ucy4gUmVuZGVyIGFsbCB0ZXh0IG9uIGdpdmVuIGNvbnRleHRcbiAgICAgKiBvciBvbiBhIG9mZnNjcmVlbiBjYW52YXMgdG8gZ2V0IHRoZSB0ZXh0IHdpZHRoIHdpdGggbWVhc3VyZVRleHQuXG4gICAgICogVXBkYXRlcyB0aGlzLndpZHRoIGFuZCB0aGlzLmhlaWdodCB3aXRoIHRoZSBwcm9wZXIgdmFsdWVzLlxuICAgICAqIERvZXMgbm90IHJldHVybiBkaW1lbnNpb25zLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBbY3R4XSBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXREaW1lbnNpb25zOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICh0aGlzLl9fc2tpcERpbWVuc2lvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWN0eCkge1xuICAgICAgICBjdHggPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdGhpcy5fc2V0VGV4dFN0eWxlcyhjdHgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdGV4dExpbmVzID0gdGhpcy5fc3BsaXRUZXh0SW50b0xpbmVzKCk7XG4gICAgICB0aGlzLl9jbGVhckNhY2hlKCk7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5fZ2V0VGV4dFdpZHRoKGN0eCkgfHwgdGhpcy5jdXJzb3JXaWR0aCB8fCBNSU5fVEVYVF9XSURUSDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5fZ2V0VGV4dEhlaWdodChjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRleHQgb2JqZWN0XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5UZXh0ICgnICsgdGhpcy5jb21wbGV4aXR5KCkgK1xuICAgICAgICAnKTogeyBcInRleHRcIjogXCInICsgdGhpcy50ZXh0ICsgJ1wiLCBcImZvbnRGYW1pbHlcIjogXCInICsgdGhpcy5mb250RmFtaWx5ICsgJ1wiIH0+JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBkaW1lbnNpb24gYW5kIHRoZSB6b29tIGxldmVsIG5lZWRlZCB0byBjcmVhdGUgYSBjYWNoZSBjYW52YXNcbiAgICAgKiBiaWcgZW5vdWdoIHRvIGhvc3QgdGhlIG9iamVjdCB0byBiZSBjYWNoZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9LndpZHRoIHdpZHRoIG9mIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0uaGVpZ2h0IGhlaWdodCBvZiBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9Lnpvb21YIHpvb21YIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICogQHJldHVybiB7T2JqZWN0fS56b29tWSB6b29tWSB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqL1xuICAgIF9nZXRDYWNoZUNhbnZhc0RpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRpbSA9IHRoaXMuY2FsbFN1cGVyKCdfZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zJyk7XG4gICAgICB2YXIgZm9udFNpemUgPSBNYXRoLmNlaWwodGhpcy5mb250U2l6ZSkgKiAyO1xuICAgICAgZGltLndpZHRoICs9IGZvbnRTaXplO1xuICAgICAgZGltLmhlaWdodCArPSBmb250U2l6ZTtcbiAgICAgIHJldHVybiBkaW07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5fc2V0VGV4dFN0eWxlcyhjdHgpO1xuICAgICAgaWYgKHRoaXMuZ3JvdXAgJiYgdGhpcy5ncm91cC50eXBlID09PSAncGF0aC1ncm91cCcpIHtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLmxlZnQsIHRoaXMudG9wKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlbmRlclRleHRMaW5lc0JhY2tncm91bmQoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHQoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHREZWNvcmF0aW9uKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuX3JlbmRlclRleHRGaWxsKGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0U3Ryb2tlKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9zZXRUZXh0U3R5bGVzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnYWxwaGFiZXRpYyc7XG4gICAgICBjdHguZm9udCA9IHRoaXMuX2dldEZvbnREZWNsYXJhdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gSGVpZ2h0IG9mIGZhYnJpYy5UZXh0IG9iamVjdFxuICAgICAqL1xuICAgIF9nZXRUZXh0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRIZWlnaHRPZlNpbmdsZUxpbmUoKSArICh0aGlzLl90ZXh0TGluZXMubGVuZ3RoIC0gMSkgKiB0aGlzLl9nZXRIZWlnaHRPZkxpbmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBNYXhpbXVtIHdpZHRoIG9mIGZhYnJpYy5UZXh0IG9iamVjdFxuICAgICAqL1xuICAgIF9nZXRUZXh0V2lkdGg6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIG1heFdpZHRoID0gdGhpcy5fZ2V0TGluZVdpZHRoKGN0eCwgMCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnRMaW5lV2lkdGggPSB0aGlzLl9nZXRMaW5lV2lkdGgoY3R4LCBpKTtcbiAgICAgICAgaWYgKGN1cnJlbnRMaW5lV2lkdGggPiBtYXhXaWR0aCkge1xuICAgICAgICAgIG1heFdpZHRoID0gY3VycmVudExpbmVXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1heFdpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgTWV0aG9kIG5hbWUgKFwiZmlsbFRleHRcIiBvciBcInN0cm9rZVRleHRcIilcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNoYXJzIENoYXJzIHRvIHJlbmRlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IExlZnQgcG9zaXRpb24gb2YgdGV4dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgVG9wIHBvc2l0aW9uIG9mIHRleHRcbiAgICAgKi9cbiAgICBfcmVuZGVyQ2hhcnM6IGZ1bmN0aW9uKG1ldGhvZCwgY3R4LCBjaGFycywgbGVmdCwgdG9wKSB7XG4gICAgICAvLyByZW1vdmUgVGV4dCB3b3JkIGZyb20gbWV0aG9kIHZhclxuICAgICAgdmFyIHNob3J0TSA9IG1ldGhvZC5zbGljZSgwLCAtNCksIGNoYXIsIHdpZHRoO1xuICAgICAgaWYgKHRoaXNbc2hvcnRNXS50b0xpdmUpIHtcbiAgICAgICAgdmFyIG9mZnNldFggPSAtdGhpcy53aWR0aCAvIDIgKyB0aGlzW3Nob3J0TV0ub2Zmc2V0WCB8fCAwLFxuICAgICAgICAgICAgb2Zmc2V0WSA9IC10aGlzLmhlaWdodCAvIDIgKyB0aGlzW3Nob3J0TV0ub2Zmc2V0WSB8fCAwO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgICBsZWZ0IC09IG9mZnNldFg7XG4gICAgICAgIHRvcCAtPSBvZmZzZXRZO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2hhclNwYWNpbmcgIT09IDApIHtcbiAgICAgICAgdmFyIGFkZGl0aW9uYWxTcGFjZSA9IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpO1xuICAgICAgICBjaGFycyA9IGNoYXJzLnNwbGl0KCcnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoYXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY2hhciA9IGNoYXJzW2ldO1xuICAgICAgICAgIHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGNoYXIpLndpZHRoICsgYWRkaXRpb25hbFNwYWNlO1xuICAgICAgICAgIGN0eFttZXRob2RdKGNoYXIsIGxlZnQsIHRvcCk7XG4gICAgICAgICAgbGVmdCArPSB3aWR0aCA+IDAgPyB3aWR0aCA6IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjdHhbbWV0aG9kXShjaGFycywgbGVmdCwgdG9wKTtcbiAgICAgIH1cbiAgICAgIHRoaXNbc2hvcnRNXS50b0xpdmUgJiYgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIE1ldGhvZCBuYW1lIChcImZpbGxUZXh0XCIgb3IgXCJzdHJva2VUZXh0XCIpXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lIFRleHQgdG8gcmVuZGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBwb3NpdGlvbiBvZiB0ZXh0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgcG9zaXRpb24gb2YgdGV4dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggSW5kZXggb2YgYSBsaW5lIGluIGEgdGV4dFxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0TGluZTogZnVuY3Rpb24obWV0aG9kLCBjdHgsIGxpbmUsIGxlZnQsIHRvcCwgbGluZUluZGV4KSB7XG4gICAgICAvLyBsaWZ0IHRoZSBsaW5lIGJ5IHF1YXJ0ZXIgb2YgZm9udFNpemVcbiAgICAgIHRvcCAtPSB0aGlzLmZvbnRTaXplICogdGhpcy5fZm9udFNpemVGcmFjdGlvbjtcblxuICAgICAgLy8gc2hvcnQtY2lyY3VpdFxuICAgICAgdmFyIGxpbmVXaWR0aCA9IHRoaXMuX2dldExpbmVXaWR0aChjdHgsIGxpbmVJbmRleCk7XG4gICAgICBpZiAodGhpcy50ZXh0QWxpZ24gIT09ICdqdXN0aWZ5JyB8fCB0aGlzLndpZHRoIDwgbGluZVdpZHRoKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlckNoYXJzKG1ldGhvZCwgY3R4LCBsaW5lLCBsZWZ0LCB0b3AsIGxpbmVJbmRleCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gc3RyZXRjaCB0aGUgbGluZVxuICAgICAgdmFyIHdvcmRzID0gbGluZS5zcGxpdCgvXFxzKy8pLFxuICAgICAgICAgIGNoYXJPZmZzZXQgPSAwLFxuICAgICAgICAgIHdvcmRzV2lkdGggPSB0aGlzLl9nZXRXaWR0aE9mV29yZHMoY3R4LCB3b3Jkcy5qb2luKCcgJyksIGxpbmVJbmRleCwgMCksXG4gICAgICAgICAgd2lkdGhEaWZmID0gdGhpcy53aWR0aCAtIHdvcmRzV2lkdGgsXG4gICAgICAgICAgbnVtU3BhY2VzID0gd29yZHMubGVuZ3RoIC0gMSxcbiAgICAgICAgICBzcGFjZVdpZHRoID0gbnVtU3BhY2VzID4gMCA/IHdpZHRoRGlmZiAvIG51bVNwYWNlcyA6IDAsXG4gICAgICAgICAgbGVmdE9mZnNldCA9IDAsIHdvcmQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB3b3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB3aGlsZSAobGluZVtjaGFyT2Zmc2V0XSA9PT0gJyAnICYmIGNoYXJPZmZzZXQgPCBsaW5lLmxlbmd0aCkge1xuICAgICAgICAgIGNoYXJPZmZzZXQrKztcbiAgICAgICAgfVxuICAgICAgICB3b3JkID0gd29yZHNbaV07XG4gICAgICAgIHRoaXMuX3JlbmRlckNoYXJzKG1ldGhvZCwgY3R4LCB3b3JkLCBsZWZ0ICsgbGVmdE9mZnNldCwgdG9wLCBsaW5lSW5kZXgsIGNoYXJPZmZzZXQpO1xuICAgICAgICBsZWZ0T2Zmc2V0ICs9IHRoaXMuX2dldFdpZHRoT2ZXb3JkcyhjdHgsIHdvcmQsIGxpbmVJbmRleCwgY2hhck9mZnNldCkgKyBzcGFjZVdpZHRoO1xuICAgICAgICBjaGFyT2Zmc2V0ICs9IHdvcmQubGVuZ3RoO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gd29yZFxuICAgICAqL1xuICAgIF9nZXRXaWR0aE9mV29yZHM6IGZ1bmN0aW9uIChjdHgsIHdvcmQpIHtcbiAgICAgIHZhciB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh3b3JkKS53aWR0aCwgY2hhckNvdW50LCBhZGRpdGlvbmFsU3BhY2U7XG4gICAgICBpZiAodGhpcy5jaGFyU3BhY2luZyAhPT0gMCkge1xuICAgICAgICBjaGFyQ291bnQgPSB3b3JkLnNwbGl0KCcnKS5sZW5ndGg7XG4gICAgICAgIGFkZGl0aW9uYWxTcGFjZSA9IGNoYXJDb3VudCAqIHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpO1xuICAgICAgICB3aWR0aCArPSBhZGRpdGlvbmFsU3BhY2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2lkdGggPiAwID8gd2lkdGggOiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTGVmdCBvZmZzZXRcbiAgICAgKi9cbiAgICBfZ2V0TGVmdE9mZnNldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gLXRoaXMud2lkdGggLyAyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVG9wIG9mZnNldFxuICAgICAqL1xuICAgIF9nZXRUb3BPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIC10aGlzLmhlaWdodCAvIDI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBiZWNhdXNlIHRleHQgaGFzIG5vIHN0eWxlXG4gICAgICovXG4gICAgaXNFbXB0eVN0eWxlczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBNZXRob2QgbmFtZSAoXCJmaWxsVGV4dFwiIG9yIFwic3Ryb2tlVGV4dFwiKVxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0Q29tbW9uOiBmdW5jdGlvbihjdHgsIG1ldGhvZCkge1xuXG4gICAgICB2YXIgbGluZUhlaWdodHMgPSAwLCBsZWZ0ID0gdGhpcy5fZ2V0TGVmdE9mZnNldCgpLCB0b3AgPSB0aGlzLl9nZXRUb3BPZmZzZXQoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaGVpZ2h0T2ZMaW5lID0gdGhpcy5fZ2V0SGVpZ2h0T2ZMaW5lKGN0eCwgaSksXG4gICAgICAgICAgICBtYXhIZWlnaHQgPSBoZWlnaHRPZkxpbmUgLyB0aGlzLmxpbmVIZWlnaHQsXG4gICAgICAgICAgICBsaW5lV2lkdGggPSB0aGlzLl9nZXRMaW5lV2lkdGgoY3R4LCBpKSxcbiAgICAgICAgICAgIGxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChsaW5lV2lkdGgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0TGluZShcbiAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgY3R4LFxuICAgICAgICAgIHRoaXMuX3RleHRMaW5lc1tpXSxcbiAgICAgICAgICBsZWZ0ICsgbGVmdE9mZnNldCxcbiAgICAgICAgICB0b3AgKyBsaW5lSGVpZ2h0cyArIG1heEhlaWdodCxcbiAgICAgICAgICBpXG4gICAgICAgICk7XG4gICAgICAgIGxpbmVIZWlnaHRzICs9IGhlaWdodE9mTGluZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclRleHRGaWxsOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5maWxsICYmIHRoaXMuaXNFbXB0eVN0eWxlcygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVuZGVyVGV4dENvbW1vbihjdHgsICdmaWxsVGV4dCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dFN0cm9rZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoKCF0aGlzLnN0cm9rZSB8fCB0aGlzLnN0cm9rZVdpZHRoID09PSAwKSAmJiB0aGlzLmlzRW1wdHlTdHlsZXMoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNoYWRvdyAmJiAhdGhpcy5zaGFkb3cuYWZmZWN0U3Ryb2tlKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVNoYWRvdyhjdHgpO1xuICAgICAgfVxuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdGhpcy5fc2V0TGluZURhc2goY3R4LCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0Q29tbW9uKGN0eCwgJ3N0cm9rZVRleHQnKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBoZWlnaHQgb2YgbGluZVxuICAgICAqL1xuICAgIF9nZXRIZWlnaHRPZkxpbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldEhlaWdodE9mU2luZ2xlTGluZSgpICogdGhpcy5saW5lSGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gaGVpZ2h0IG9mIGxpbmUgd2l0aG91dCBsaW5lSGVpZ2h0XG4gICAgICovXG4gICAgX2dldEhlaWdodE9mU2luZ2xlTGluZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb250U2l6ZSAqIHRoaXMuX2ZvbnRTaXplTXVsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclRleHRMaW5lc0JhY2tncm91bmQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnRleHRCYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGxpbmVUb3BPZmZzZXQgPSAwLCBoZWlnaHRPZkxpbmUsXG4gICAgICAgICAgbGluZVdpZHRoLCBsaW5lTGVmdE9mZnNldCwgb3JpZ2luYWxGaWxsID0gY3R4LmZpbGxTdHlsZTtcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMudGV4dEJhY2tncm91bmRDb2xvcjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaGVpZ2h0T2ZMaW5lID0gdGhpcy5fZ2V0SGVpZ2h0T2ZMaW5lKGN0eCwgaSk7XG4gICAgICAgIGxpbmVXaWR0aCA9IHRoaXMuX2dldExpbmVXaWR0aChjdHgsIGkpO1xuICAgICAgICBpZiAobGluZVdpZHRoID4gMCkge1xuICAgICAgICAgIGxpbmVMZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQobGluZVdpZHRoKTtcbiAgICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICB0aGlzLl9nZXRMZWZ0T2Zmc2V0KCkgKyBsaW5lTGVmdE9mZnNldCxcbiAgICAgICAgICAgIHRoaXMuX2dldFRvcE9mZnNldCgpICsgbGluZVRvcE9mZnNldCxcbiAgICAgICAgICAgIGxpbmVXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodE9mTGluZSAvIHRoaXMubGluZUhlaWdodFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbGluZVRvcE9mZnNldCArPSBoZWlnaHRPZkxpbmU7XG4gICAgICB9XG4gICAgICBjdHguZmlsbFN0eWxlID0gb3JpZ2luYWxGaWxsO1xuICAgICAgLy8gaWYgdGhlcmUgaXMgdGV4dCBiYWNrZ3JvdW5kIGNvbG9yIG5vXG4gICAgICAvLyBvdGhlciBzaGFkb3dzIHNob3VsZCBiZSBjYXN0ZWRcbiAgICAgIHRoaXMuX3JlbW92ZVNoYWRvdyhjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lV2lkdGggV2lkdGggb2YgdGV4dCBsaW5lXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBMaW5lIGxlZnQgb2Zmc2V0XG4gICAgICovXG4gICAgX2dldExpbmVMZWZ0T2Zmc2V0OiBmdW5jdGlvbihsaW5lV2lkdGgpIHtcbiAgICAgIGlmICh0aGlzLnRleHRBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLndpZHRoIC0gbGluZVdpZHRoKSAvIDI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50ZXh0QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggLSBsaW5lV2lkdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2xlYXJDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9fbGluZVdpZHRocyA9IFtdO1xuICAgICAgdGhpcy5fX2xpbmVIZWlnaHRzID0gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Nob3VsZENsZWFyRGltZW5zaW9uQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNob3VsZENsZWFyID0gdGhpcy5fZm9yY2VDbGVhckNhY2hlO1xuICAgICAgc2hvdWxkQ2xlYXIgfHwgKHNob3VsZENsZWFyID0gdGhpcy5oYXNTdGF0ZUNoYW5nZWQoJ19kaW1lbnNpb25BZmZlY3RpbmdQcm9wcycpKTtcbiAgICAgIGlmIChzaG91bGRDbGVhcikge1xuICAgICAgICB0aGlzLnNhdmVTdGF0ZSh7IHByb3BlcnR5U2V0OiAnX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzJyB9KTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2hvdWxkQ2xlYXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggbGluZSBudW1iZXJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IExpbmUgd2lkdGhcbiAgICAgKi9cbiAgICBfZ2V0TGluZVdpZHRoOiBmdW5jdGlvbihjdHgsIGxpbmVJbmRleCkge1xuICAgICAgaWYgKHRoaXMuX19saW5lV2lkdGhzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19saW5lV2lkdGhzW2xpbmVJbmRleF0gPT09IC0xID8gdGhpcy53aWR0aCA6IHRoaXMuX19saW5lV2lkdGhzW2xpbmVJbmRleF07XG4gICAgICB9XG5cbiAgICAgIHZhciB3aWR0aCwgd29yZENvdW50LCBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF07XG5cbiAgICAgIGlmIChsaW5lID09PSAnJykge1xuICAgICAgICB3aWR0aCA9IDA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgd2lkdGggPSB0aGlzLl9tZWFzdXJlTGluZShjdHgsIGxpbmVJbmRleCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9fbGluZVdpZHRoc1tsaW5lSW5kZXhdID0gd2lkdGg7XG5cbiAgICAgIGlmICh3aWR0aCAmJiB0aGlzLnRleHRBbGlnbiA9PT0gJ2p1c3RpZnknKSB7XG4gICAgICAgIHdvcmRDb3VudCA9IGxpbmUuc3BsaXQoL1xccysvKTtcbiAgICAgICAgaWYgKHdvcmRDb3VudC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhpcy5fX2xpbmVXaWR0aHNbbGluZUluZGV4XSA9IC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gd2lkdGg7XG4gICAgfSxcblxuICAgIF9nZXRXaWR0aE9mQ2hhclNwYWNpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuY2hhclNwYWNpbmcgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9udFNpemUgKiB0aGlzLmNoYXJTcGFjaW5nIC8gMTAwMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IGxpbmUgbnVtYmVyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBMaW5lIHdpZHRoXG4gICAgICovXG4gICAgX21lYXN1cmVMaW5lOiBmdW5jdGlvbihjdHgsIGxpbmVJbmRleCkge1xuICAgICAgdmFyIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XSxcbiAgICAgICAgICB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsaW5lKS53aWR0aCxcbiAgICAgICAgICBhZGRpdGlvbmFsU3BhY2UgPSAwLCBjaGFyQ291bnQsIGZpbmFsV2lkdGg7XG4gICAgICBpZiAodGhpcy5jaGFyU3BhY2luZyAhPT0gMCkge1xuICAgICAgICBjaGFyQ291bnQgPSBsaW5lLnNwbGl0KCcnKS5sZW5ndGg7XG4gICAgICAgIGFkZGl0aW9uYWxTcGFjZSA9IChjaGFyQ291bnQgLSAxKSAqIHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpO1xuICAgICAgfVxuICAgICAgZmluYWxXaWR0aCA9IHdpZHRoICsgYWRkaXRpb25hbFNwYWNlO1xuICAgICAgcmV0dXJuIGZpbmFsV2lkdGggPiAwID8gZmluYWxXaWR0aCA6IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0RGVjb3JhdGlvbjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMudGV4dERlY29yYXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGhhbGZPZlZlcnRpY2FsQm94ID0gdGhpcy5oZWlnaHQgLyAyLFxuICAgICAgICAgIF90aGlzID0gdGhpcywgb2Zmc2V0cyA9IFtdO1xuXG4gICAgICAvKiogQGlnbm9yZSAqL1xuICAgICAgZnVuY3Rpb24gcmVuZGVyTGluZXNBdE9mZnNldChvZmZzZXRzKSB7XG4gICAgICAgIHZhciBpLCBsaW5lSGVpZ2h0ID0gMCwgbGVuLCBqLCBvTGVuLCBsaW5lV2lkdGgsXG4gICAgICAgICAgICBsaW5lTGVmdE9mZnNldCwgaGVpZ2h0T2ZMaW5lO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IF90aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgICAgIGxpbmVXaWR0aCA9IF90aGlzLl9nZXRMaW5lV2lkdGgoY3R4LCBpKTtcbiAgICAgICAgICBsaW5lTGVmdE9mZnNldCA9IF90aGlzLl9nZXRMaW5lTGVmdE9mZnNldChsaW5lV2lkdGgpO1xuICAgICAgICAgIGhlaWdodE9mTGluZSA9IF90aGlzLl9nZXRIZWlnaHRPZkxpbmUoY3R4LCBpKTtcblxuICAgICAgICAgIGZvciAoaiA9IDAsIG9MZW4gPSBvZmZzZXRzLmxlbmd0aDsgaiA8IG9MZW47IGorKykge1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgICBfdGhpcy5fZ2V0TGVmdE9mZnNldCgpICsgbGluZUxlZnRPZmZzZXQsXG4gICAgICAgICAgICAgIGxpbmVIZWlnaHQgKyAoX3RoaXMuX2ZvbnRTaXplTXVsdCAtIDEgKyBvZmZzZXRzW2pdICkgKiBfdGhpcy5mb250U2l6ZSAtIGhhbGZPZlZlcnRpY2FsQm94LFxuICAgICAgICAgICAgICBsaW5lV2lkdGgsXG4gICAgICAgICAgICAgIF90aGlzLmZvbnRTaXplIC8gMTUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsaW5lSGVpZ2h0ICs9IGhlaWdodE9mTGluZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCd1bmRlcmxpbmUnKSA+IC0xKSB7XG4gICAgICAgIG9mZnNldHMucHVzaCgwLjg1KTsgLy8gMSAtIDMvMTZcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRleHREZWNvcmF0aW9uLmluZGV4T2YoJ2xpbmUtdGhyb3VnaCcpID4gLTEpIHtcbiAgICAgICAgb2Zmc2V0cy5wdXNoKDAuNDMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudGV4dERlY29yYXRpb24uaW5kZXhPZignb3ZlcmxpbmUnKSA+IC0xKSB7XG4gICAgICAgIG9mZnNldHMucHVzaCgtMC4xMik7XG4gICAgICB9XG4gICAgICBpZiAob2Zmc2V0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlbmRlckxpbmVzQXRPZmZzZXQob2Zmc2V0cyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBmb250IGRlY2xhcmF0aW9uIHN0cmluZyBmb3IgY2FudmFzIGNvbnRleHRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBmb250IGRlY2xhcmF0aW9uIGZvcm1hdHRlZCBmb3IgY2FudmFzIGNvbnRleHQuXG4gICAgICovXG4gICAgX2dldEZvbnREZWNsYXJhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAvLyBub2RlLWNhbnZhcyBuZWVkcyBcIndlaWdodCBzdHlsZVwiLCB3aGlsZSBicm93c2VycyBuZWVkIFwic3R5bGUgd2VpZ2h0XCJcbiAgICAgICAgKGZhYnJpYy5pc0xpa2VseU5vZGUgPyB0aGlzLmZvbnRXZWlnaHQgOiB0aGlzLmZvbnRTdHlsZSksXG4gICAgICAgIChmYWJyaWMuaXNMaWtlbHlOb2RlID8gdGhpcy5mb250U3R5bGUgOiB0aGlzLmZvbnRXZWlnaHQpLFxuICAgICAgICB0aGlzLmZvbnRTaXplICsgJ3B4JyxcbiAgICAgICAgKGZhYnJpYy5pc0xpa2VseU5vZGUgPyAoJ1wiJyArIHRoaXMuZm9udEZhbWlseSArICdcIicpIDogdGhpcy5mb250RmFtaWx5KVxuICAgICAgXS5qb2luKCcgJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGV4dCBpbnN0YW5jZSBvbiBhIHNwZWNpZmllZCBjb250ZXh0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbm9UcmFuc2Zvcm1cbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCwgbm9UcmFuc2Zvcm0pIHtcbiAgICAgIC8vIGRvIG5vdCByZW5kZXIgaWYgb2JqZWN0IGlzIG5vdCB2aXNpYmxlXG4gICAgICBpZiAoIXRoaXMudmlzaWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc2hvdWxkQ2xlYXJEaW1lbnNpb25DYWNoZSgpKSB7XG4gICAgICAgIHRoaXMuX3NldFRleHRTdHlsZXMoY3R4KTtcbiAgICAgICAgdGhpcy5faW5pdERpbWVuc2lvbnMoY3R4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdyZW5kZXInLCBjdHgsIG5vVHJhbnNmb3JtKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGV4dCBhcyBhbiBhcnJheSBvZiBsaW5lcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IExpbmVzIGluIHRoZSB0ZXh0XG4gICAgICovXG4gICAgX3NwbGl0VGV4dEludG9MaW5lczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0LnNwbGl0KHRoaXMuX3JlTmV3bGluZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBhZGRpdGlvbmFsUHJvcGVydGllcyA9IFtcbiAgICAgICAgJ3RleHQnLFxuICAgICAgICAnZm9udFNpemUnLFxuICAgICAgICAnZm9udFdlaWdodCcsXG4gICAgICAgICdmb250RmFtaWx5JyxcbiAgICAgICAgJ2ZvbnRTdHlsZScsXG4gICAgICAgICdsaW5lSGVpZ2h0JyxcbiAgICAgICAgJ3RleHREZWNvcmF0aW9uJyxcbiAgICAgICAgJ3RleHRBbGlnbicsXG4gICAgICAgICd0ZXh0QmFja2dyb3VuZENvbG9yJyxcbiAgICAgICAgJ2NoYXJTcGFjaW5nJ1xuICAgICAgXS5jb25jYXQocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICByZXR1cm4gdGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JywgYWRkaXRpb25hbFByb3BlcnRpZXMpO1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICBpZiAoIXRoaXMuY3R4KSB7XG4gICAgICAgIHRoaXMuY3R4ID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLmdldENvbnRleHQoJzJkJyk7XG4gICAgICB9XG4gICAgICB2YXIgbWFya3VwID0gdGhpcy5fY3JlYXRlQmFzZVNWR01hcmt1cCgpLFxuICAgICAgICAgIG9mZnNldHMgPSB0aGlzLl9nZXRTVkdMZWZ0VG9wT2Zmc2V0cyh0aGlzLmN0eCksXG4gICAgICAgICAgdGV4dEFuZEJnID0gdGhpcy5fZ2V0U1ZHVGV4dEFuZEJnKG9mZnNldHMudGV4dFRvcCwgb2Zmc2V0cy50ZXh0TGVmdCk7XG4gICAgICB0aGlzLl93cmFwU1ZHVGV4dEFuZEJnKG1hcmt1cCwgdGV4dEFuZEJnKTtcblxuICAgICAgcmV0dXJuIHJldml2ZXIgPyByZXZpdmVyKG1hcmt1cC5qb2luKCcnKSkgOiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFNWR0xlZnRUb3BPZmZzZXRzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBsaW5lVG9wID0gdGhpcy5fZ2V0SGVpZ2h0T2ZMaW5lKGN0eCwgMCksXG4gICAgICAgICAgdGV4dExlZnQgPSAtdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgdGV4dFRvcCA9IDA7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRleHRMZWZ0OiB0ZXh0TGVmdCArICh0aGlzLmdyb3VwICYmIHRoaXMuZ3JvdXAudHlwZSA9PT0gJ3BhdGgtZ3JvdXAnID8gdGhpcy5sZWZ0IDogMCksXG4gICAgICAgIHRleHRUb3A6IHRleHRUb3AgKyAodGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLnR5cGUgPT09ICdwYXRoLWdyb3VwJyA/IC10aGlzLnRvcCA6IDApLFxuICAgICAgICBsaW5lVG9wOiBsaW5lVG9wXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF93cmFwU1ZHVGV4dEFuZEJnOiBmdW5jdGlvbihtYXJrdXAsIHRleHRBbmRCZykge1xuICAgICAgdmFyIG5vU2hhZG93ID0gdHJ1ZSwgZmlsdGVyID0gdGhpcy5nZXRTdmdGaWx0ZXIoKSxcbiAgICAgICAgICBzdHlsZSA9IGZpbHRlciA9PT0gJycgPyAnJyA6ICcgc3R5bGU9XCInICsgZmlsdGVyICsgJ1wiJztcblxuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICdcXHQ8ZyAnLCB0aGlzLmdldFN2Z0lkKCksICd0cmFuc2Zvcm09XCInLCB0aGlzLmdldFN2Z1RyYW5zZm9ybSgpLCB0aGlzLmdldFN2Z1RyYW5zZm9ybU1hdHJpeCgpLCAnXCInLFxuICAgICAgICAgIHN0eWxlLCAnPlxcbicsXG4gICAgICAgICAgdGV4dEFuZEJnLnRleHRCZ1JlY3RzLmpvaW4oJycpLFxuICAgICAgICAgICdcXHRcXHQ8dGV4dCAnLFxuICAgICAgICAgICAgKHRoaXMuZm9udEZhbWlseSA/ICdmb250LWZhbWlseT1cIicgKyB0aGlzLmZvbnRGYW1pbHkucmVwbGFjZSgvXCIvZywgJ1xcJycpICsgJ1wiICcgOiAnJyksXG4gICAgICAgICAgICAodGhpcy5mb250U2l6ZSA/ICdmb250LXNpemU9XCInICsgdGhpcy5mb250U2l6ZSArICdcIiAnIDogJycpLFxuICAgICAgICAgICAgKHRoaXMuZm9udFN0eWxlID8gJ2ZvbnQtc3R5bGU9XCInICsgdGhpcy5mb250U3R5bGUgKyAnXCIgJyA6ICcnKSxcbiAgICAgICAgICAgICh0aGlzLmZvbnRXZWlnaHQgPyAnZm9udC13ZWlnaHQ9XCInICsgdGhpcy5mb250V2VpZ2h0ICsgJ1wiICcgOiAnJyksXG4gICAgICAgICAgICAodGhpcy50ZXh0RGVjb3JhdGlvbiA/ICd0ZXh0LWRlY29yYXRpb249XCInICsgdGhpcy50ZXh0RGVjb3JhdGlvbiArICdcIiAnIDogJycpLFxuICAgICAgICAgICAgJ3N0eWxlPVwiJywgdGhpcy5nZXRTdmdTdHlsZXMobm9TaGFkb3cpLCAnXCIgPlxcbicsXG4gICAgICAgICAgICB0ZXh0QW5kQmcudGV4dFNwYW5zLmpvaW4oJycpLFxuICAgICAgICAgICdcXHRcXHQ8L3RleHQ+XFxuJyxcbiAgICAgICAgJ1xcdDwvZz5cXG4nXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0ZXh0VG9wT2Zmc2V0IFRleHQgdG9wIG9mZnNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0ZXh0TGVmdE9mZnNldCBUZXh0IGxlZnQgb2Zmc2V0XG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIF9nZXRTVkdUZXh0QW5kQmc6IGZ1bmN0aW9uKHRleHRUb3BPZmZzZXQsIHRleHRMZWZ0T2Zmc2V0KSB7XG4gICAgICB2YXIgdGV4dFNwYW5zID0gW10sXG4gICAgICAgICAgdGV4dEJnUmVjdHMgPSBbXSxcbiAgICAgICAgICBoZWlnaHQgPSAwO1xuICAgICAgLy8gYm91bmRpbmctYm94IGJhY2tncm91bmRcbiAgICAgIHRoaXMuX3NldFNWR0JnKHRleHRCZ1JlY3RzKTtcblxuICAgICAgLy8gdGV4dCBhbmQgdGV4dC1iYWNrZ3JvdW5kXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLnRleHRCYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgICB0aGlzLl9zZXRTVkdUZXh0TGluZUJnKHRleHRCZ1JlY3RzLCBpLCB0ZXh0TGVmdE9mZnNldCwgdGV4dFRvcE9mZnNldCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRTVkdUZXh0TGluZVRleHQoaSwgdGV4dFNwYW5zLCBoZWlnaHQsIHRleHRMZWZ0T2Zmc2V0LCB0ZXh0VG9wT2Zmc2V0LCB0ZXh0QmdSZWN0cyk7XG4gICAgICAgIGhlaWdodCArPSB0aGlzLl9nZXRIZWlnaHRPZkxpbmUodGhpcy5jdHgsIGkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0U3BhbnM6IHRleHRTcGFucyxcbiAgICAgICAgdGV4dEJnUmVjdHM6IHRleHRCZ1JlY3RzXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBfc2V0U1ZHVGV4dExpbmVUZXh0OiBmdW5jdGlvbihpLCB0ZXh0U3BhbnMsIGhlaWdodCwgdGV4dExlZnRPZmZzZXQsIHRleHRUb3BPZmZzZXQpIHtcbiAgICAgIHZhciB5UG9zID0gdGhpcy5mb250U2l6ZSAqICh0aGlzLl9mb250U2l6ZU11bHQgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKVxuICAgICAgICAtIHRleHRUb3BPZmZzZXQgKyBoZWlnaHQgLSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICBpZiAodGhpcy50ZXh0QWxpZ24gPT09ICdqdXN0aWZ5Jykge1xuICAgICAgICAvLyBpIGNhbGwgZnJvbSBoZXJlIHRvIGRvIG5vdCBpbnRlZmVyZSB3aXRoIElUZXh0XG4gICAgICAgIHRoaXMuX3NldFNWR1RleHRMaW5lSnVzdGlmZWQoaSwgdGV4dFNwYW5zLCB5UG9zLCB0ZXh0TGVmdE9mZnNldCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRleHRTcGFucy5wdXNoKFxuICAgICAgICAnXFx0XFx0XFx0PHRzcGFuIHg9XCInLFxuICAgICAgICAgIHRvRml4ZWQodGV4dExlZnRPZmZzZXQgKyB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldCh0aGlzLl9nZXRMaW5lV2lkdGgodGhpcy5jdHgsIGkpKSwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksICdcIiAnLFxuICAgICAgICAgICd5PVwiJyxcbiAgICAgICAgICB0b0ZpeGVkKHlQb3MsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICdcIiAnLFxuICAgICAgICAgIC8vIGRvaW5nIHRoaXMgb24gPHRzcGFuPiBlbGVtZW50cyBzaW5jZSBzZXR0aW5nIG9wYWNpdHlcbiAgICAgICAgICAvLyBvbiBjb250YWluaW5nIDx0ZXh0PiBvbmUgZG9lc24ndCB3b3JrIGluIElsbHVzdHJhdG9yXG4gICAgICAgICAgdGhpcy5fZ2V0RmlsbEF0dHJpYnV0ZXModGhpcy5maWxsKSwgJz4nLFxuICAgICAgICAgIGZhYnJpYy51dGlsLnN0cmluZy5lc2NhcGVYbWwodGhpcy5fdGV4dExpbmVzW2ldKSxcbiAgICAgICAgJzwvdHNwYW4+XFxuJ1xuICAgICAgKTtcbiAgICB9LFxuXG4gICAgX3NldFNWR1RleHRMaW5lSnVzdGlmZWQ6IGZ1bmN0aW9uKGksIHRleHRTcGFucywgeVBvcywgdGV4dExlZnRPZmZzZXQpIHtcbiAgICAgIHZhciBjdHggPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCkuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgdGhpcy5fc2V0VGV4dFN0eWxlcyhjdHgpO1xuXG4gICAgICB2YXIgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tpXSxcbiAgICAgICAgICB3b3JkcyA9IGxpbmUuc3BsaXQoL1xccysvKSxcbiAgICAgICAgICB3b3Jkc1dpZHRoID0gdGhpcy5fZ2V0V2lkdGhPZldvcmRzKGN0eCwgd29yZHMuam9pbignJykpLFxuICAgICAgICAgIHdpZHRoRGlmZiA9IHRoaXMud2lkdGggLSB3b3Jkc1dpZHRoLFxuICAgICAgICAgIG51bVNwYWNlcyA9IHdvcmRzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgc3BhY2VXaWR0aCA9IG51bVNwYWNlcyA+IDAgPyB3aWR0aERpZmYgLyBudW1TcGFjZXMgOiAwLFxuICAgICAgICAgIHdvcmQsIGF0dHJpYnV0ZXMgPSB0aGlzLl9nZXRGaWxsQXR0cmlidXRlcyh0aGlzLmZpbGwpLFxuICAgICAgICAgIGxlbjtcblxuICAgICAgdGV4dExlZnRPZmZzZXQgKz0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQodGhpcy5fZ2V0TGluZVdpZHRoKGN0eCwgaSkpO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSB3b3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB3b3JkID0gd29yZHNbaV07XG4gICAgICAgIHRleHRTcGFucy5wdXNoKFxuICAgICAgICAgICdcXHRcXHRcXHQ8dHNwYW4geD1cIicsXG4gICAgICAgICAgICB0b0ZpeGVkKHRleHRMZWZ0T2Zmc2V0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSwgJ1wiICcsXG4gICAgICAgICAgICAneT1cIicsXG4gICAgICAgICAgICB0b0ZpeGVkKHlQb3MsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgJ1wiICcsXG4gICAgICAgICAgICAvLyBkb2luZyB0aGlzIG9uIDx0c3Bhbj4gZWxlbWVudHMgc2luY2Ugc2V0dGluZyBvcGFjaXR5XG4gICAgICAgICAgICAvLyBvbiBjb250YWluaW5nIDx0ZXh0PiBvbmUgZG9lc24ndCB3b3JrIGluIElsbHVzdHJhdG9yXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLCAnPicsXG4gICAgICAgICAgICBmYWJyaWMudXRpbC5zdHJpbmcuZXNjYXBlWG1sKHdvcmQpLFxuICAgICAgICAgICc8L3RzcGFuPlxcbidcbiAgICAgICAgKTtcbiAgICAgICAgdGV4dExlZnRPZmZzZXQgKz0gdGhpcy5fZ2V0V2lkdGhPZldvcmRzKGN0eCwgd29yZCkgKyBzcGFjZVdpZHRoO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2V0U1ZHVGV4dExpbmVCZzogZnVuY3Rpb24odGV4dEJnUmVjdHMsIGksIHRleHRMZWZ0T2Zmc2V0LCB0ZXh0VG9wT2Zmc2V0LCBoZWlnaHQpIHtcbiAgICAgIHRleHRCZ1JlY3RzLnB1c2goXG4gICAgICAgICdcXHRcXHQ8cmVjdCAnLFxuICAgICAgICAgIHRoaXMuX2dldEZpbGxBdHRyaWJ1dGVzKHRoaXMudGV4dEJhY2tncm91bmRDb2xvciksXG4gICAgICAgICAgJyB4PVwiJyxcbiAgICAgICAgICB0b0ZpeGVkKHRleHRMZWZ0T2Zmc2V0ICsgdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQodGhpcy5fZ2V0TGluZVdpZHRoKHRoaXMuY3R4LCBpKSksIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICdcIiB5PVwiJyxcbiAgICAgICAgICB0b0ZpeGVkKGhlaWdodCAtIHRoaXMuaGVpZ2h0IC8gMiwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgJ1wiIHdpZHRoPVwiJyxcbiAgICAgICAgICB0b0ZpeGVkKHRoaXMuX2dldExpbmVXaWR0aCh0aGlzLmN0eCwgaSksIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICdcIiBoZWlnaHQ9XCInLFxuICAgICAgICAgIHRvRml4ZWQodGhpcy5fZ2V0SGVpZ2h0T2ZMaW5lKHRoaXMuY3R4LCBpKSAvIHRoaXMubGluZUhlaWdodCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICdcIj48L3JlY3Q+XFxuJyk7XG4gICAgfSxcblxuICAgIF9zZXRTVkdCZzogZnVuY3Rpb24odGV4dEJnUmVjdHMpIHtcbiAgICAgIGlmICh0aGlzLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICB0ZXh0QmdSZWN0cy5wdXNoKFxuICAgICAgICAgICdcXHRcXHQ8cmVjdCAnLFxuICAgICAgICAgICAgdGhpcy5fZ2V0RmlsbEF0dHJpYnV0ZXModGhpcy5iYWNrZ3JvdW5kQ29sb3IpLFxuICAgICAgICAgICAgJyB4PVwiJyxcbiAgICAgICAgICAgIHRvRml4ZWQoLXRoaXMud2lkdGggLyAyLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgICdcIiB5PVwiJyxcbiAgICAgICAgICAgIHRvRml4ZWQoLXRoaXMuaGVpZ2h0IC8gMiwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICAnXCIgd2lkdGg9XCInLFxuICAgICAgICAgICAgdG9GaXhlZCh0aGlzLndpZHRoLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgICdcIiBoZWlnaHQ9XCInLFxuICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmhlaWdodCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgJ1wiPjwvcmVjdD5cXG4nKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRvYmUgSWxsdXN0cmF0b3IgKGF0IGxlYXN0IENTNSkgaXMgdW5hYmxlIHRvIHJlbmRlciByZ2JhKCktYmFzZWQgZmlsbCB2YWx1ZXNcbiAgICAgKiB3ZSB3b3JrIGFyb3VuZCBpdCBieSBcIm1vdmluZ1wiIGFscGhhIGNoYW5uZWwgaW50byBvcGFjaXR5IGF0dHJpYnV0ZSBhbmQgc2V0dGluZyBmaWxsJ3MgYWxwaGEgdG8gMVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIF9nZXRGaWxsQXR0cmlidXRlczogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBmaWxsQ29sb3IgPSAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgPyBuZXcgZmFicmljLkNvbG9yKHZhbHVlKSA6ICcnO1xuICAgICAgaWYgKCFmaWxsQ29sb3IgfHwgIWZpbGxDb2xvci5nZXRTb3VyY2UoKSB8fCBmaWxsQ29sb3IuZ2V0QWxwaGEoKSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gJ2ZpbGw9XCInICsgdmFsdWUgKyAnXCInO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdvcGFjaXR5PVwiJyArIGZpbGxDb2xvci5nZXRBbHBoYSgpICsgJ1wiIGZpbGw9XCInICsgZmlsbENvbG9yLnNldEFscGhhKDEpLnRvUmdiKCkgKyAnXCInO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNwZWNpZmllZCBwcm9wZXJ0eSB0byBhIHNwZWNpZmllZCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLlRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgX3NldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19zZXQnLCBrZXksIHZhbHVlKTtcblxuICAgICAgaWYgKHRoaXMuX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgIHRoaXMuX2luaXREaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29tcGxleGl0eSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gY29tcGxleGl0eVxuICAgICAqL1xuICAgIGNvbXBsZXhpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkge0BsaW5rIGZhYnJpYy5UZXh0LmZyb21FbGVtZW50fSlcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHRcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3RleHQuaHRtbCNUZXh0RWxlbWVudFxuICAgKi9cbiAgZmFicmljLlRleHQuQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdChcbiAgICAneCB5IGR4IGR5IGZvbnQtZmFtaWx5IGZvbnQtc3R5bGUgZm9udC13ZWlnaHQgZm9udC1zaXplIHRleHQtZGVjb3JhdGlvbiB0ZXh0LWFuY2hvcicuc3BsaXQoJyAnKSk7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgU1ZHIGZvbnQgc2l6ZVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dFxuICAgKi9cbiAgZmFicmljLlRleHQuREVGQVVMVF9TVkdfRk9OVF9TSVpFID0gMTY7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLlRleHQgaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudCAoPGI+bm90IHlldCBpbXBsZW1lbnRlZDwvYj4pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0XG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLlRleHR9IEluc3RhbmNlIG9mIGZhYnJpYy5UZXh0XG4gICAqL1xuICBmYWJyaWMuVGV4dC5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuVGV4dC5BVFRSSUJVVEVfTkFNRVMpO1xuICAgIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKChvcHRpb25zID8gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKG9wdGlvbnMpIDogeyB9KSwgcGFyc2VkQXR0cmlidXRlcyk7XG5cbiAgICBvcHRpb25zLnRvcCA9IG9wdGlvbnMudG9wIHx8IDA7XG4gICAgb3B0aW9ucy5sZWZ0ID0gb3B0aW9ucy5sZWZ0IHx8IDA7XG4gICAgaWYgKCdkeCcgaW4gcGFyc2VkQXR0cmlidXRlcykge1xuICAgICAgb3B0aW9ucy5sZWZ0ICs9IHBhcnNlZEF0dHJpYnV0ZXMuZHg7XG4gICAgfVxuICAgIGlmICgnZHknIGluIHBhcnNlZEF0dHJpYnV0ZXMpIHtcbiAgICAgIG9wdGlvbnMudG9wICs9IHBhcnNlZEF0dHJpYnV0ZXMuZHk7XG4gICAgfVxuICAgIGlmICghKCdmb250U2l6ZScgaW4gb3B0aW9ucykpIHtcbiAgICAgIG9wdGlvbnMuZm9udFNpemUgPSBmYWJyaWMuVGV4dC5ERUZBVUxUX1NWR19GT05UX1NJWkU7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLm9yaWdpblgpIHtcbiAgICAgIG9wdGlvbnMub3JpZ2luWCA9ICdsZWZ0JztcbiAgICB9XG5cbiAgICB2YXIgdGV4dENvbnRlbnQgPSAnJztcblxuICAgIC8vIFRoZSBYTUwgaXMgbm90IHByb3Blcmx5IHBhcnNlZCBpbiBJRTkgc28gYSB3b3JrYXJvdW5kIHRvIGdldFxuICAgIC8vIHRleHRDb250ZW50IGlzIHRocm91Z2ggZmlyc3RDaGlsZC5kYXRhLiBBbm90aGVyIHdvcmthcm91bmQgd291bGQgYmVcbiAgICAvLyB0byBjb252ZXJ0IFhNTCBsb2FkZWQgZnJvbSBhIGZpbGUgdG8gYmUgY29udmVydGVkIHVzaW5nIERPTVBhcnNlciAoc2FtZSB3YXkgbG9hZFNWR0Zyb21TdHJpbmcoKSBkb2VzKVxuICAgIGlmICghKCd0ZXh0Q29udGVudCcgaW4gZWxlbWVudCkpIHtcbiAgICAgIGlmICgnZmlyc3RDaGlsZCcgaW4gZWxlbWVudCAmJiBlbGVtZW50LmZpcnN0Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCdkYXRhJyBpbiBlbGVtZW50LmZpcnN0Q2hpbGQgJiYgZWxlbWVudC5maXJzdENoaWxkLmRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICB0ZXh0Q29udGVudCA9IGVsZW1lbnQuZmlyc3RDaGlsZC5kYXRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGV4dENvbnRlbnQgPSBlbGVtZW50LnRleHRDb250ZW50O1xuICAgIH1cblxuICAgIHRleHRDb250ZW50ID0gdGV4dENvbnRlbnQucmVwbGFjZSgvXlxccyt8XFxzKyR8XFxuKy9nLCAnJykucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuXG4gICAgdmFyIHRleHQgPSBuZXcgZmFicmljLlRleHQodGV4dENvbnRlbnQsIG9wdGlvbnMpLFxuICAgICAgICB0ZXh0SGVpZ2h0U2NhbGVGYWN0b3IgPSB0ZXh0LmdldEhlaWdodCgpIC8gdGV4dC5oZWlnaHQsXG4gICAgICAgIGxpbmVIZWlnaHREaWZmID0gKHRleHQuaGVpZ2h0ICsgdGV4dC5zdHJva2VXaWR0aCkgKiB0ZXh0LmxpbmVIZWlnaHQgLSB0ZXh0LmhlaWdodCxcbiAgICAgICAgc2NhbGVkRGlmZiA9IGxpbmVIZWlnaHREaWZmICogdGV4dEhlaWdodFNjYWxlRmFjdG9yLFxuICAgICAgICB0ZXh0SGVpZ2h0ID0gdGV4dC5nZXRIZWlnaHQoKSArIHNjYWxlZERpZmYsXG4gICAgICAgIG9mZlggPSAwO1xuICAgIC8qXG4gICAgICBBZGp1c3QgcG9zaXRpb25pbmc6XG4gICAgICAgIHgveSBhdHRyaWJ1dGVzIGluIFNWRyBjb3JyZXNwb25kIHRvIHRoZSBib3R0b20tbGVmdCBjb3JuZXIgb2YgdGV4dCBib3VuZGluZyBib3hcbiAgICAgICAgdG9wL2xlZnQgcHJvcGVydGllcyBpbiBGYWJyaWMgY29ycmVzcG9uZCB0byBjZW50ZXIgcG9pbnQgb2YgdGV4dCBib3VuZGluZyBib3hcbiAgICAqL1xuICAgIGlmICh0ZXh0Lm9yaWdpblggPT09ICdsZWZ0Jykge1xuICAgICAgb2ZmWCA9IHRleHQuZ2V0V2lkdGgoKSAvIDI7XG4gICAgfVxuICAgIGlmICh0ZXh0Lm9yaWdpblggPT09ICdyaWdodCcpIHtcbiAgICAgIG9mZlggPSAtdGV4dC5nZXRXaWR0aCgpIC8gMjtcbiAgICB9XG4gICAgdGV4dC5zZXQoe1xuICAgICAgbGVmdDogdGV4dC5nZXRMZWZ0KCkgKyBvZmZYLFxuICAgICAgdG9wOiB0ZXh0LmdldFRvcCgpIC0gdGV4dEhlaWdodCAvIDIgKyB0ZXh0LmZvbnRTaXplICogKDAuMTggKyB0ZXh0Ll9mb250U2l6ZUZyYWN0aW9uKSAvIHRleHQubGluZUhlaWdodCAvKiAwLjMgaXMgdGhlIG9sZCBsaW5lSGVpZ2h0ICovXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuVGV4dCBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGZhYnJpYy5UZXh0IGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VBc3luY10gRm9yY2UgYW4gYXN5bmMgYmVoYXZpb3VyIHRyeWluZyB0byBjcmVhdGUgcGF0dGVybiBmaXJzdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dH0gSW5zdGFuY2Ugb2YgZmFicmljLlRleHRcbiAgICovXG4gIGZhYnJpYy5UZXh0LmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrLCBmb3JjZUFzeW5jKSB7XG4gICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1RleHQnLCBvYmplY3QsIGNhbGxiYWNrLCBmb3JjZUFzeW5jLCAndGV4dCcpO1xuICB9O1xuXG4gIGZhYnJpYy51dGlsLmNyZWF0ZUFjY2Vzc29ycyhmYWJyaWMuVGV4dCk7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGNsb25lID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lO1xuXG4gIC8qKlxuICAgKiBJVGV4dCBjbGFzcyAoaW50cm9kdWNlZCBpbiA8Yj52MS40PC9iPikgRXZlbnRzIGFyZSBhbHNvIGZpcmVkIHdpdGggXCJ0ZXh0OlwiXG4gICAqIHByZWZpeCB3aGVuIG9ic2VydmluZyBjYW52YXMuXG4gICAqIEBjbGFzcyBmYWJyaWMuSVRleHRcbiAgICogQGV4dGVuZHMgZmFicmljLlRleHRcbiAgICogQG1peGVzIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqXG4gICAqIEBmaXJlcyBjaGFuZ2VkXG4gICAqIEBmaXJlcyBzZWxlY3Rpb246Y2hhbmdlZFxuICAgKiBAZmlyZXMgZWRpdGluZzplbnRlcmVkXG4gICAqIEBmaXJlcyBlZGl0aW5nOmV4aXRlZFxuICAgKlxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLklUZXh0I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqXG4gICAqIDxwPlN1cHBvcnRlZCBrZXkgY29tYmluYXRpb25zOjwvcD5cbiAgICogPHByZT5cbiAgICogICBNb3ZlIGN1cnNvcjogICAgICAgICAgICAgICAgICAgIGxlZnQsIHJpZ2h0LCB1cCwgZG93blxuICAgKiAgIFNlbGVjdCBjaGFyYWN0ZXI6ICAgICAgICAgICAgICAgc2hpZnQgKyBsZWZ0LCBzaGlmdCArIHJpZ2h0XG4gICAqICAgU2VsZWN0IHRleHQgdmVydGljYWxseTogICAgICAgICBzaGlmdCArIHVwLCBzaGlmdCArIGRvd25cbiAgICogICBNb3ZlIGN1cnNvciBieSB3b3JkOiAgICAgICAgICAgIGFsdCArIGxlZnQsIGFsdCArIHJpZ2h0XG4gICAqICAgU2VsZWN0IHdvcmRzOiAgICAgICAgICAgICAgICAgICBzaGlmdCArIGFsdCArIGxlZnQsIHNoaWZ0ICsgYWx0ICsgcmlnaHRcbiAgICogICBNb3ZlIGN1cnNvciB0byBsaW5lIHN0YXJ0L2VuZDogIGNtZCArIGxlZnQsIGNtZCArIHJpZ2h0IG9yIGhvbWUsIGVuZFxuICAgKiAgIFNlbGVjdCB0aWxsIHN0YXJ0L2VuZCBvZiBsaW5lOiAgY21kICsgc2hpZnQgKyBsZWZ0LCBjbWQgKyBzaGlmdCArIHJpZ2h0IG9yIHNoaWZ0ICsgaG9tZSwgc2hpZnQgKyBlbmRcbiAgICogICBKdW1wIHRvIHN0YXJ0L2VuZCBvZiB0ZXh0OiAgICAgIGNtZCArIHVwLCBjbWQgKyBkb3duXG4gICAqICAgU2VsZWN0IHRpbGwgc3RhcnQvZW5kIG9mIHRleHQ6ICBjbWQgKyBzaGlmdCArIHVwLCBjbWQgKyBzaGlmdCArIGRvd24gb3Igc2hpZnQgKyBwZ1VwLCBzaGlmdCArIHBnRG93blxuICAgKiAgIERlbGV0ZSBjaGFyYWN0ZXI6ICAgICAgICAgICAgICAgYmFja3NwYWNlXG4gICAqICAgRGVsZXRlIHdvcmQ6ICAgICAgICAgICAgICAgICAgICBhbHQgKyBiYWNrc3BhY2VcbiAgICogICBEZWxldGUgbGluZTogICAgICAgICAgICAgICAgICAgIGNtZCArIGJhY2tzcGFjZVxuICAgKiAgIEZvcndhcmQgZGVsZXRlOiAgICAgICAgICAgICAgICAgZGVsZXRlXG4gICAqICAgQ29weSB0ZXh0OiAgICAgICAgICAgICAgICAgICAgICBjdHJsL2NtZCArIGNcbiAgICogICBQYXN0ZSB0ZXh0OiAgICAgICAgICAgICAgICAgICAgIGN0cmwvY21kICsgdlxuICAgKiAgIEN1dCB0ZXh0OiAgICAgICAgICAgICAgICAgICAgICAgY3RybC9jbWQgKyB4XG4gICAqICAgU2VsZWN0IGVudGlyZSB0ZXh0OiAgICAgICAgICAgICBjdHJsL2NtZCArIGFcbiAgICogICBRdWl0IGVkaXRpbmcgICAgICAgICAgICAgICAgICAgIHRhYiBvciBlc2NcbiAgICogPC9wcmU+XG4gICAqXG4gICAqIDxwPlN1cHBvcnRlZCBtb3VzZS90b3VjaCBjb21iaW5hdGlvbjwvcD5cbiAgICogPHByZT5cbiAgICogICBQb3NpdGlvbiBjdXJzb3I6ICAgICAgICAgICAgICAgIGNsaWNrL3RvdWNoXG4gICAqICAgQ3JlYXRlIHNlbGVjdGlvbjogICAgICAgICAgICAgICBjbGljay90b3VjaCAmIGRyYWdcbiAgICogICBDcmVhdGUgc2VsZWN0aW9uOiAgICAgICAgICAgICAgIGNsaWNrICYgc2hpZnQgKyBjbGlja1xuICAgKiAgIFNlbGVjdCB3b3JkOiAgICAgICAgICAgICAgICAgICAgZG91YmxlIGNsaWNrXG4gICAqICAgU2VsZWN0IGxpbmU6ICAgICAgICAgICAgICAgICAgICB0cmlwbGUgY2xpY2tcbiAgICogPC9wcmU+XG4gICAqL1xuICBmYWJyaWMuSVRleHQgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuVGV4dCwgZmFicmljLk9ic2VydmFibGUsIC8qKiBAbGVuZHMgZmFicmljLklUZXh0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2ktdGV4dCcsXG5cbiAgICAvKipcbiAgICAgKiBJbmRleCB3aGVyZSB0ZXh0IHNlbGVjdGlvbiBzdGFydHMgKG9yIHdoZXJlIGN1cnNvciBpcyB3aGVuIHRoZXJlIGlzIG5vIHNlbGVjdGlvbilcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvblN0YXJ0OiAwLFxuXG4gICAgLyoqXG4gICAgICogSW5kZXggd2hlcmUgdGV4dCBzZWxlY3Rpb24gZW5kc1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uRW5kOiAwLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2YgdGV4dCBzZWxlY3Rpb25cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbkNvbG9yOiAncmdiYSgxNywxMTksMjU1LDAuMyknLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGV4dCBpcyBpbiBlZGl0aW5nIG1vZGVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpc0VkaXRpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgYSB0ZXh0IGNhbiBiZSBlZGl0ZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBlZGl0YWJsZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEJvcmRlciBjb2xvciBvZiB0ZXh0IG9iamVjdCB3aGlsZSBpdCdzIGluIGVkaXRpbmcgbW9kZVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZWRpdGluZ0JvcmRlckNvbG9yOiAncmdiYSgxMDIsMTUzLDI1NSwwLjI1KScsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBjdXJzb3IgKGluIHB4KVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3Vyc29yV2lkdGg6IDIsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiBkZWZhdWx0IGN1cnNvciAod2hlbiBub3Qgb3ZlcndyaXR0ZW4gYnkgY2hhcmFjdGVyIHN0eWxlKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3Vyc29yQ29sb3I6ICcjMzMzJyxcblxuICAgIC8qKlxuICAgICAqIERlbGF5IGJldHdlZW4gY3Vyc29yIGJsaW5rIChpbiBtcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGN1cnNvckRlbGF5OiAxMDAwLFxuXG4gICAgLyoqXG4gICAgICogRHVyYXRpb24gb2YgY3Vyc29yIGZhZGVpbiAoaW4gbXMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjdXJzb3JEdXJhdGlvbjogNjAwLFxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IGNvbnRhaW5pbmcgY2hhcmFjdGVyIHN0eWxlc1xuICAgICAqICh3aGVyZSB0b3AtbGV2ZWwgcHJvcGVydGllcyBjb3JyZXNwb25kcyB0byBsaW5lIG51bWJlciBhbmQgMm5kLWxldmVsIHByb3BlcnRpZXMgLS0gdG8gY2hhciBudW1iZXIgaW4gYSBsaW5lKVxuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3R5bGVzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgaW50ZXJuYWwgdGV4dCBjaGFyIHdpZHRocyBjYW4gYmUgY2FjaGVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2FjaGluZzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlU3BhY2U6IC9cXHN8XFxuLyxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2N1cnJlbnRDdXJzb3JPcGFjaXR5OiAwLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2VsZWN0aW9uRGlyZWN0aW9uOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWJvcnRDdXJzb3JBbmltYXRpb246IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfX3dpZHRoT2ZTcGFjZTogW10sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRleHQgc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JVGV4dH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc3R5bGVzID0gb3B0aW9ucyA/IChvcHRpb25zLnN0eWxlcyB8fCB7IH0pIDogeyB9O1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCB0ZXh0LCBvcHRpb25zKTtcbiAgICAgIHRoaXMuaW5pdEJlaGF2aW9yKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NsZWFyQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19jbGVhckNhY2hlJyk7XG4gICAgICB0aGlzLl9fd2lkdGhPZlNwYWNlID0gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaGFzIG5vIHN0eWxpbmdcbiAgICAgKi9cbiAgICBpc0VtcHR5U3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0gdGhpcy5zdHlsZXM7XG5cbiAgICAgIGZvciAodmFyIHAxIGluIG9iaikge1xuICAgICAgICBmb3IgKHZhciBwMiBpbiBvYmpbcDFdKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgICAgZm9yICh2YXIgcDMgaW4gb2JqW3AxXVtwMl0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNlbGVjdGlvbiBzdGFydCAobGVmdCBib3VuZGFyeSBvZiBhIHNlbGVjdGlvbilcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggdG8gc2V0IHNlbGVjdGlvbiBzdGFydCB0b1xuICAgICAqL1xuICAgIHNldFNlbGVjdGlvblN0YXJ0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaW5kZXggPSBNYXRoLm1heChpbmRleCwgMCk7XG4gICAgICB0aGlzLl91cGRhdGVBbmRGaXJlKCdzZWxlY3Rpb25TdGFydCcsIGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzZWxlY3Rpb24gZW5kIChyaWdodCBib3VuZGFyeSBvZiBhIHNlbGVjdGlvbilcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggdG8gc2V0IHNlbGVjdGlvbiBlbmQgdG9cbiAgICAgKi9cbiAgICBzZXRTZWxlY3Rpb25FbmQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpbmRleCA9IE1hdGgubWluKGluZGV4LCB0aGlzLnRleHQubGVuZ3RoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUFuZEZpcmUoJ3NlbGVjdGlvbkVuZCcsIGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgJ3NlbGVjdGlvblN0YXJ0JyBvciAnc2VsZWN0aW9uRW5kJ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBuZXcgcG9zaXRpb24gb2YgcHJvcGVydHlcbiAgICAgKi9cbiAgICBfdXBkYXRlQW5kRmlyZTogZnVuY3Rpb24ocHJvcGVydHksIGluZGV4KSB7XG4gICAgICBpZiAodGhpc1twcm9wZXJ0eV0gIT09IGluZGV4KSB7XG4gICAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gaW5kZXg7XG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB0aGUgZXZlbiBvZiBzZWxlY3Rpb24gY2hhbmdlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZmlyZSgnc2VsZWN0aW9uOmNoYW5nZWQnKTtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6c2VsZWN0aW9uOmNoYW5nZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBzdHlsZSBvZiBhIGN1cnJlbnQgc2VsZWN0aW9uL2N1cnNvciAoYXQgdGhlIHN0YXJ0IHBvc2l0aW9uKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRJbmRleF0gU3RhcnQgaW5kZXggdG8gZ2V0IHN0eWxlcyBhdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kSW5kZXhdIEVuZCBpbmRleCB0byBnZXQgc3R5bGVzIGF0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBzdHlsZXMgU3R5bGUgb2JqZWN0IGF0IGEgc3BlY2lmaWVkIChvciBjdXJyZW50KSBpbmRleFxuICAgICAqL1xuICAgIGdldFNlbGVjdGlvblN0eWxlczogZnVuY3Rpb24oc3RhcnRJbmRleCwgZW5kSW5kZXgpIHtcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgdmFyIHN0eWxlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgICBzdHlsZXMucHVzaCh0aGlzLmdldFNlbGVjdGlvblN0eWxlcyhpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICAgIH1cblxuICAgICAgdmFyIGxvYyA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzdGFydEluZGV4KSxcbiAgICAgICAgICBzdHlsZSA9IHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCk7XG5cbiAgICAgIHJldHVybiBzdHlsZSB8fCB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzdHlsZSBvZiBhIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZXNdIFN0eWxlcyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0U2VsZWN0aW9uU3R5bGVzOiBmdW5jdGlvbihzdHlsZXMpIHtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgICB0aGlzLl9leHRlbmRTdHlsZXModGhpcy5zZWxlY3Rpb25TdGFydCwgc3R5bGVzKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5zZWxlY3Rpb25TdGFydDsgaSA8IHRoaXMuc2VsZWN0aW9uRW5kOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl9leHRlbmRTdHlsZXMoaSwgc3R5bGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyogbm90IGluY2x1ZGVkIGluIF9leHRlbmRTdHlsZXMgdG8gYXZvaWQgY2xlYXJpbmcgY2FjaGUgbW9yZSB0aGFuIG9uY2UgKi9cbiAgICAgIHRoaXMuX2ZvcmNlQ2xlYXJDYWNoZSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZXh0ZW5kU3R5bGVzOiBmdW5jdGlvbihpbmRleCwgc3R5bGVzKSB7XG4gICAgICB2YXIgbG9jID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKGluZGV4KTtcblxuICAgICAgaWYgKCF0aGlzLl9nZXRMaW5lU3R5bGUobG9jLmxpbmVJbmRleCkpIHtcbiAgICAgICAgdGhpcy5fc2V0TGluZVN0eWxlKGxvYy5saW5lSW5kZXgsIHt9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxvYy5saW5lSW5kZXgsIGxvYy5jaGFySW5kZXgpKSB7XG4gICAgICAgIHRoaXMuX3NldFN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCwge30pO1xuICAgICAgfVxuXG4gICAgICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCksIHN0eWxlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGV4dCBkaW1lbnNpb25zLiBSZW5kZXIgYWxsIHRleHQgb24gZ2l2ZW4gY29udGV4dFxuICAgICAqIG9yIG9uIGEgb2Zmc2NyZWVuIGNhbnZhcyB0byBnZXQgdGhlIHRleHQgd2lkdGggd2l0aCBtZWFzdXJlVGV4dC5cbiAgICAgKiBVcGRhdGVzIHRoaXMud2lkdGggYW5kIHRoaXMuaGVpZ2h0IHdpdGggdGhlIHByb3BlciB2YWx1ZXMuXG4gICAgICogRG9lcyBub3QgcmV0dXJuIGRpbWVuc2lvbnMuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFtjdHhdIENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdERpbWVuc2lvbnM6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgdGhpcy5jbGVhckNvbnRleHRUb3AoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfaW5pdERpbWVuc2lvbnMnLCBjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG5vVHJhbnNmb3JtXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjdHgsIG5vVHJhbnNmb3JtKSB7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dFRvcCgpO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ3JlbmRlcicsIGN0eCwgbm9UcmFuc2Zvcm0pO1xuICAgICAgLy8gY2xlYXIgdGhlIGN1cnNvck9mZnNldENhY2hlLCBzbyB3ZSBlbnN1cmUgdG8gY2FsY3VsYXRlIG9uY2UgcGVyIHJlbmRlckN1cnNvclxuICAgICAgLy8gdGhlIGNvcnJlY3QgcG9zaXRpb24gYnV0IG5vdCBhdCBldmVyeSBjdXJzb3IgYW5pbWF0aW9uLlxuICAgICAgdGhpcy5jdXJzb3JPZmZzZXRDYWNoZSA9IHsgfTtcbiAgICAgIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3JlbmRlcicsIGN0eCk7XG4gICAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSBhbmQgY2xlYW4gdGhlIGNvbnRleHRUb3BcbiAgICAgKi9cbiAgICBjbGVhckNvbnRleHRUb3A6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmFjdGl2ZSB8fCAhdGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmNvbnRleHRUb3ApIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0uYXBwbHkoY3R4LCB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybSk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtKGN0eCk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtTWF0cml4ICYmIGN0eC50cmFuc2Zvcm0uYXBwbHkoY3R4LCB0aGlzLnRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICAgIHRoaXMuX2NsZWFyVGV4dEFyZWEoY3R4KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBjdXJzb3Igb3Igc2VsZWN0aW9uIChkZXBlbmRpbmcgb24gd2hhdCBleGlzdHMpXG4gICAgICovXG4gICAgcmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmFjdGl2ZSB8fCAhdGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGNoYXJzID0gdGhpcy50ZXh0LnNwbGl0KCcnKSxcbiAgICAgICAgICBib3VuZGFyaWVzLCBjdHg7XG4gICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuY29udGV4dFRvcCkge1xuICAgICAgICBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgudHJhbnNmb3JtLmFwcGx5KGN0eCwgdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm0pO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybShjdHgpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybU1hdHJpeCAmJiBjdHgudHJhbnNmb3JtLmFwcGx5KGN0eCwgdGhpcy50cmFuc2Zvcm1NYXRyaXgpO1xuICAgICAgICB0aGlzLl9jbGVhclRleHRBcmVhKGN0eCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgYm91bmRhcmllcyA9IHRoaXMuX2dldEN1cnNvckJvdW5kYXJpZXMoY2hhcnMsICdjdXJzb3InKTtcbiAgICAgICAgdGhpcy5yZW5kZXJDdXJzb3IoYm91bmRhcmllcywgY3R4KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBib3VuZGFyaWVzID0gdGhpcy5fZ2V0Q3Vyc29yQm91bmRhcmllcyhjaGFycywgJ3NlbGVjdGlvbicpO1xuICAgICAgICB0aGlzLnJlbmRlclNlbGVjdGlvbihjaGFycywgYm91bmRhcmllcywgY3R4KTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIF9jbGVhclRleHRBcmVhOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIC8vIHdlIGFkZCA0IHBpeGVsLCB0byBiZSBzdXJlIHRvIGRvIG5vdCBsZWF2ZSBhbnkgcGl4ZWwgb3V0XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoICsgNCwgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyA0O1xuICAgICAgY3R4LmNsZWFyUmVjdCgtd2lkdGggLyAyLCAtaGVpZ2h0IC8gMiwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIDJkIHJlcHJlc2VudGF0aW9uIChsaW5lSW5kZXggYW5kIGNoYXJJbmRleCkgb2YgY3Vyc29yIChvciBzZWxlY3Rpb24gc3RhcnQpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzZWxlY3Rpb25TdGFydF0gT3B0aW9uYWwgaW5kZXguIFdoZW4gbm90IGdpdmVuLCBjdXJyZW50IHNlbGVjdGlvblN0YXJ0IGlzIHVzZWQuXG4gICAgICovXG4gICAgZ2V0MkRDdXJzb3JMb2NhdGlvbjogZnVuY3Rpb24oc2VsZWN0aW9uU3RhcnQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0aW9uU3RhcnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgIH1cbiAgICAgIHZhciBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPD0gdGhpcy5fdGV4dExpbmVzW2ldLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5lSW5kZXg6IGksXG4gICAgICAgICAgICBjaGFySW5kZXg6IHNlbGVjdGlvblN0YXJ0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3Rpb25TdGFydCAtPSB0aGlzLl90ZXh0TGluZXNbaV0ubGVuZ3RoICsgMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmVJbmRleDogaSAtIDEsXG4gICAgICAgIGNoYXJJbmRleDogdGhpcy5fdGV4dExpbmVzW2kgLSAxXS5sZW5ndGggPCBzZWxlY3Rpb25TdGFydCA/IHRoaXMuX3RleHRMaW5lc1tpIC0gMV0ubGVuZ3RoIDogc2VsZWN0aW9uU3RhcnRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29tcGxldGUgc3R5bGUgb2YgY2hhciBhdCB0aGUgY3VycmVudCBjdXJzb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IExpbmUgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4IENoYXIgaW5kZXhcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IENoYXJhY3RlciBzdHlsZVxuICAgICAqL1xuICAgIGdldEN1cnJlbnRDaGFyU3R5bGU6IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB7XG4gICAgICB2YXIgc3R5bGUgPSB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4ID09PSAwID8gMCA6IGNoYXJJbmRleCAtIDEpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBmb250U2l6ZTogc3R5bGUgJiYgc3R5bGUuZm9udFNpemUgfHwgdGhpcy5mb250U2l6ZSxcbiAgICAgICAgZmlsbDogc3R5bGUgJiYgc3R5bGUuZmlsbCB8fCB0aGlzLmZpbGwsXG4gICAgICAgIHRleHRCYWNrZ3JvdW5kQ29sb3I6IHN0eWxlICYmIHN0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3IgfHwgdGhpcy50ZXh0QmFja2dyb3VuZENvbG9yLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogc3R5bGUgJiYgc3R5bGUudGV4dERlY29yYXRpb24gfHwgdGhpcy50ZXh0RGVjb3JhdGlvbixcbiAgICAgICAgZm9udEZhbWlseTogc3R5bGUgJiYgc3R5bGUuZm9udEZhbWlseSB8fCB0aGlzLmZvbnRGYW1pbHksXG4gICAgICAgIGZvbnRXZWlnaHQ6IHN0eWxlICYmIHN0eWxlLmZvbnRXZWlnaHQgfHwgdGhpcy5mb250V2VpZ2h0LFxuICAgICAgICBmb250U3R5bGU6IHN0eWxlICYmIHN0eWxlLmZvbnRTdHlsZSB8fCB0aGlzLmZvbnRTdHlsZSxcbiAgICAgICAgc3Ryb2tlOiBzdHlsZSAmJiBzdHlsZS5zdHJva2UgfHwgdGhpcy5zdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBzdHlsZSAmJiBzdHlsZS5zdHJva2VXaWR0aCB8fCB0aGlzLnN0cm9rZVdpZHRoXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGZvbnRTaXplIG9mIGNoYXIgYXQgdGhlIGN1cnJlbnQgY3Vyc29yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBMaW5lIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleCBDaGFyIGluZGV4XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBDaGFyYWN0ZXIgZm9udCBzaXplXG4gICAgICovXG4gICAgZ2V0Q3VycmVudENoYXJGb250U2l6ZTogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICAgIHZhciBzdHlsZSA9IHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBjaGFySW5kZXggPT09IDAgPyAwIDogY2hhckluZGV4IC0gMSk7XG4gICAgICByZXR1cm4gc3R5bGUgJiYgc3R5bGUuZm9udFNpemUgPyBzdHlsZS5mb250U2l6ZSA6IHRoaXMuZm9udFNpemU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29sb3IgKGZpbGwpIG9mIGNoYXIgYXQgdGhlIGN1cnJlbnQgY3Vyc29yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBMaW5lIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleCBDaGFyIGluZGV4XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBDaGFyYWN0ZXIgY29sb3IgKGZpbGwpXG4gICAgICovXG4gICAgZ2V0Q3VycmVudENoYXJDb2xvcjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICAgIHZhciBzdHlsZSA9IHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBjaGFySW5kZXggPT09IDAgPyAwIDogY2hhckluZGV4IC0gMSk7XG4gICAgICByZXR1cm4gc3R5bGUgJiYgc3R5bGUuZmlsbCA/IHN0eWxlLmZpbGwgOiB0aGlzLmN1cnNvckNvbG9yO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGN1cnNvciBib3VuZGFyaWVzIChsZWZ0LCB0b3AsIGxlZnRPZmZzZXQsIHRvcE9mZnNldClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNoYXJzIEFycmF5IG9mIGNoYXJhY3RlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZU9mQm91bmRhcmllc1xuICAgICAqL1xuICAgIF9nZXRDdXJzb3JCb3VuZGFyaWVzOiBmdW5jdGlvbihjaGFycywgdHlwZU9mQm91bmRhcmllcykge1xuXG4gICAgICAvLyBsZWZ0L3RvcCBhcmUgbGVmdC90b3Agb2YgZW50aXJlIHRleHQgYm94XG4gICAgICAvLyBsZWZ0T2Zmc2V0L3RvcE9mZnNldCBhcmUgb2Zmc2V0IGZyb20gdGhhdCBsZWZ0L3RvcCBwb2ludCBvZiBhIHRleHQgYm94XG5cbiAgICAgIHZhciBsZWZ0ID0gTWF0aC5yb3VuZCh0aGlzLl9nZXRMZWZ0T2Zmc2V0KCkpLFxuICAgICAgICAgIHRvcCA9IHRoaXMuX2dldFRvcE9mZnNldCgpLFxuXG4gICAgICAgICAgb2Zmc2V0cyA9IHRoaXMuX2dldEN1cnNvckJvdW5kYXJpZXNPZmZzZXRzKFxuICAgICAgICAgICAgICAgICAgICAgIGNoYXJzLCB0eXBlT2ZCb3VuZGFyaWVzKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgIGxlZnRPZmZzZXQ6IG9mZnNldHMubGVmdCArIG9mZnNldHMubGluZUxlZnQsXG4gICAgICAgIHRvcE9mZnNldDogb2Zmc2V0cy50b3BcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEN1cnNvckJvdW5kYXJpZXNPZmZzZXRzOiBmdW5jdGlvbihjaGFycywgdHlwZU9mQm91bmRhcmllcykge1xuICAgICAgaWYgKHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUgJiYgJ3RvcCcgaW4gdGhpcy5jdXJzb3JPZmZzZXRDYWNoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3JPZmZzZXRDYWNoZTtcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lTGVmdE9mZnNldCA9IDAsXG4gICAgICAgICAgbGluZUluZGV4ID0gMCxcbiAgICAgICAgICBjaGFySW5kZXggPSAwLFxuICAgICAgICAgIHRvcE9mZnNldCA9IDAsXG4gICAgICAgICAgbGVmdE9mZnNldCA9IDAsXG4gICAgICAgICAgYm91bmRhcmllcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNlbGVjdGlvblN0YXJ0OyBpKyspIHtcbiAgICAgICAgaWYgKGNoYXJzW2ldID09PSAnXFxuJykge1xuICAgICAgICAgIGxlZnRPZmZzZXQgPSAwO1xuICAgICAgICAgIHRvcE9mZnNldCArPSB0aGlzLl9nZXRIZWlnaHRPZkxpbmUodGhpcy5jdHgsIGxpbmVJbmRleCk7XG5cbiAgICAgICAgICBsaW5lSW5kZXgrKztcbiAgICAgICAgICBjaGFySW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGxlZnRPZmZzZXQgKz0gdGhpcy5fZ2V0V2lkdGhPZkNoYXIodGhpcy5jdHgsIGNoYXJzW2ldLCBsaW5lSW5kZXgsIGNoYXJJbmRleCk7XG4gICAgICAgICAgY2hhckluZGV4Kys7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lTGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KHRoaXMuX2dldExpbmVXaWR0aCh0aGlzLmN0eCwgbGluZUluZGV4KSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZU9mQm91bmRhcmllcyA9PT0gJ2N1cnNvcicpIHtcbiAgICAgICAgdG9wT2Zmc2V0ICs9ICgxIC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbikgKiB0aGlzLl9nZXRIZWlnaHRPZkxpbmUodGhpcy5jdHgsIGxpbmVJbmRleCkgLyB0aGlzLmxpbmVIZWlnaHRcbiAgICAgICAgICAtIHRoaXMuZ2V0Q3VycmVudENoYXJGb250U2l6ZShsaW5lSW5kZXgsIGNoYXJJbmRleCkgKiAoMSAtIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2hhclNwYWNpbmcgIT09IDAgJiYgY2hhckluZGV4ID09PSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XS5sZW5ndGgpIHtcbiAgICAgICAgbGVmdE9mZnNldCAtPSB0aGlzLl9nZXRXaWR0aE9mQ2hhclNwYWNpbmcoKTtcbiAgICAgIH1cbiAgICAgIGJvdW5kYXJpZXMgPSB7XG4gICAgICAgIHRvcDogdG9wT2Zmc2V0LFxuICAgICAgICBsZWZ0OiBsZWZ0T2Zmc2V0ID4gMCA/IGxlZnRPZmZzZXQgOiAwLFxuICAgICAgICBsaW5lTGVmdDogbGluZUxlZnRPZmZzZXRcbiAgICAgIH07XG4gICAgICB0aGlzLmN1cnNvck9mZnNldENhY2hlID0gYm91bmRhcmllcztcbiAgICAgIHJldHVybiB0aGlzLmN1cnNvck9mZnNldENhY2hlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGN1cnNvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBib3VuZGFyaWVzXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCB0cmFuc2Zvcm1lZCBjb250ZXh0IHRvIGRyYXcgb25cbiAgICAgKi9cbiAgICByZW5kZXJDdXJzb3I6IGZ1bmN0aW9uKGJvdW5kYXJpZXMsIGN0eCkge1xuXG4gICAgICB2YXIgY3Vyc29yTG9jYXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oKSxcbiAgICAgICAgICBsaW5lSW5kZXggPSBjdXJzb3JMb2NhdGlvbi5saW5lSW5kZXgsXG4gICAgICAgICAgY2hhckluZGV4ID0gY3Vyc29yTG9jYXRpb24uY2hhckluZGV4LFxuICAgICAgICAgIGNoYXJIZWlnaHQgPSB0aGlzLmdldEN1cnJlbnRDaGFyRm9udFNpemUobGluZUluZGV4LCBjaGFySW5kZXgpLFxuICAgICAgICAgIGxlZnRPZmZzZXQgPSAobGluZUluZGV4ID09PSAwICYmIGNoYXJJbmRleCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldCh0aGlzLl9nZXRMaW5lV2lkdGgoY3R4LCBsaW5lSW5kZXgpKVxuICAgICAgICAgICAgICAgICAgICA6IGJvdW5kYXJpZXMubGVmdE9mZnNldCxcbiAgICAgICAgICBtdWx0aXBsaWVyID0gdGhpcy5zY2FsZVggKiB0aGlzLmNhbnZhcy5nZXRab29tKCksXG4gICAgICAgICAgY3Vyc29yV2lkdGggPSB0aGlzLmN1cnNvcldpZHRoIC8gbXVsdGlwbGllcjtcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuZ2V0Q3VycmVudENoYXJDb2xvcihsaW5lSW5kZXgsIGNoYXJJbmRleCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLl9faXNNb3VzZWRvd24gPyAxIDogdGhpcy5fY3VycmVudEN1cnNvck9wYWNpdHk7XG5cbiAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgYm91bmRhcmllcy5sZWZ0ICsgbGVmdE9mZnNldCAtIGN1cnNvcldpZHRoIC8gMixcbiAgICAgICAgYm91bmRhcmllcy50b3AgKyBib3VuZGFyaWVzLnRvcE9mZnNldCxcbiAgICAgICAgY3Vyc29yV2lkdGgsXG4gICAgICAgIGNoYXJIZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRleHQgc2VsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gY2hhcnMgQXJyYXkgb2YgY2hhcmFjdGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBib3VuZGFyaWVzIE9iamVjdCB3aXRoIGxlZnQvdG9wL2xlZnRPZmZzZXQvdG9wT2Zmc2V0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCB0cmFuc2Zvcm1lZCBjb250ZXh0IHRvIGRyYXcgb25cbiAgICAgKi9cbiAgICByZW5kZXJTZWxlY3Rpb246IGZ1bmN0aW9uKGNoYXJzLCBib3VuZGFyaWVzLCBjdHgpIHtcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuc2VsZWN0aW9uQ29sb3I7XG5cbiAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbih0aGlzLnNlbGVjdGlvblN0YXJ0KSxcbiAgICAgICAgICBlbmQgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24odGhpcy5zZWxlY3Rpb25FbmQpLFxuICAgICAgICAgIHN0YXJ0TGluZSA9IHN0YXJ0LmxpbmVJbmRleCxcbiAgICAgICAgICBlbmRMaW5lID0gZW5kLmxpbmVJbmRleDtcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydExpbmU7IGkgPD0gZW5kTGluZTsgaSsrKSB7XG4gICAgICAgIHZhciBsaW5lT2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQodGhpcy5fZ2V0TGluZVdpZHRoKGN0eCwgaSkpIHx8IDAsXG4gICAgICAgICAgICBsaW5lSGVpZ2h0ID0gdGhpcy5fZ2V0SGVpZ2h0T2ZMaW5lKHRoaXMuY3R4LCBpKSxcbiAgICAgICAgICAgIHJlYWxMaW5lSGVpZ2h0ID0gMCwgYm94V2lkdGggPSAwLCBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2ldO1xuXG4gICAgICAgIGlmIChpID09PSBzdGFydExpbmUpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gbGluZS5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgaWYgKGogPj0gc3RhcnQuY2hhckluZGV4ICYmIChpICE9PSBlbmRMaW5lIHx8IGogPCBlbmQuY2hhckluZGV4KSkge1xuICAgICAgICAgICAgICBib3hXaWR0aCArPSB0aGlzLl9nZXRXaWR0aE9mQ2hhcihjdHgsIGxpbmVbal0sIGksIGopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGogPCBzdGFydC5jaGFySW5kZXgpIHtcbiAgICAgICAgICAgICAgbGluZU9mZnNldCArPSB0aGlzLl9nZXRXaWR0aE9mQ2hhcihjdHgsIGxpbmVbal0sIGksIGopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaiA9PT0gbGluZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJveFdpZHRoIC09IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpID4gc3RhcnRMaW5lICYmIGkgPCBlbmRMaW5lKSB7XG4gICAgICAgICAgYm94V2lkdGggKz0gdGhpcy5fZ2V0TGluZVdpZHRoKGN0eCwgaSkgfHwgNTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpID09PSBlbmRMaW5lKSB7XG4gICAgICAgICAgZm9yICh2YXIgajIgPSAwLCBqMmxlbiA9IGVuZC5jaGFySW5kZXg7IGoyIDwgajJsZW47IGoyKyspIHtcbiAgICAgICAgICAgIGJveFdpZHRoICs9IHRoaXMuX2dldFdpZHRoT2ZDaGFyKGN0eCwgbGluZVtqMl0sIGksIGoyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVuZC5jaGFySW5kZXggPT09IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBib3hXaWR0aCAtPSB0aGlzLl9nZXRXaWR0aE9mQ2hhclNwYWNpbmcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVhbExpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5saW5lSGVpZ2h0IDwgMSB8fCAoaSA9PT0gZW5kTGluZSAmJiB0aGlzLmxpbmVIZWlnaHQgPiAxKSkge1xuICAgICAgICAgIGxpbmVIZWlnaHQgLz0gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICBib3VuZGFyaWVzLmxlZnQgKyBsaW5lT2Zmc2V0LFxuICAgICAgICAgIGJvdW5kYXJpZXMudG9wICsgYm91bmRhcmllcy50b3BPZmZzZXQsXG4gICAgICAgICAgYm94V2lkdGggPiAwID8gYm94V2lkdGggOiAwLFxuICAgICAgICAgIGxpbmVIZWlnaHQpO1xuXG4gICAgICAgIGJvdW5kYXJpZXMudG9wT2Zmc2V0ICs9IHJlYWxMaW5lSGVpZ2h0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxpbmUgQ29udGVudCBvZiB0aGUgbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhck9mZnNldFxuICAgICAqL1xuICAgIF9yZW5kZXJDaGFyczogZnVuY3Rpb24obWV0aG9kLCBjdHgsIGxpbmUsIGxlZnQsIHRvcCwgbGluZUluZGV4LCBjaGFyT2Zmc2V0KSB7XG5cbiAgICAgIGlmICh0aGlzLmlzRW1wdHlTdHlsZXMoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyQ2hhcnNGYXN0KG1ldGhvZCwgY3R4LCBsaW5lLCBsZWZ0LCB0b3ApO1xuICAgICAgfVxuXG4gICAgICBjaGFyT2Zmc2V0ID0gY2hhck9mZnNldCB8fCAwO1xuXG4gICAgICAvLyBzZXQgcHJvcGVyIGxpbmUgb2Zmc2V0XG4gICAgICB2YXIgbGluZUhlaWdodCA9IHRoaXMuX2dldEhlaWdodE9mTGluZShjdHgsIGxpbmVJbmRleCksXG4gICAgICAgICAgcHJldlN0eWxlLFxuICAgICAgICAgIHRoaXNTdHlsZSxcbiAgICAgICAgICBjaGFyc1RvUmVuZGVyID0gJyc7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0b3AgLT0gbGluZUhlaWdodCAvIHRoaXMubGluZUhlaWdodCAqIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb247XG4gICAgICBmb3IgKHZhciBpID0gY2hhck9mZnNldCwgbGVuID0gbGluZS5sZW5ndGggKyBjaGFyT2Zmc2V0OyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgIHByZXZTdHlsZSA9IHByZXZTdHlsZSB8fCB0aGlzLmdldEN1cnJlbnRDaGFyU3R5bGUobGluZUluZGV4LCBpKTtcbiAgICAgICAgdGhpc1N0eWxlID0gdGhpcy5nZXRDdXJyZW50Q2hhclN0eWxlKGxpbmVJbmRleCwgaSArIDEpO1xuXG4gICAgICAgIGlmICh0aGlzLl9oYXNTdHlsZUNoYW5nZWQocHJldlN0eWxlLCB0aGlzU3R5bGUpIHx8IGkgPT09IGxlbikge1xuICAgICAgICAgIHRoaXMuX3JlbmRlckNoYXIobWV0aG9kLCBjdHgsIGxpbmVJbmRleCwgaSAtIDEsIGNoYXJzVG9SZW5kZXIsIGxlZnQsIHRvcCwgbGluZUhlaWdodCk7XG4gICAgICAgICAgY2hhcnNUb1JlbmRlciA9ICcnO1xuICAgICAgICAgIHByZXZTdHlsZSA9IHRoaXNTdHlsZTtcbiAgICAgICAgfVxuICAgICAgICBjaGFyc1RvUmVuZGVyICs9IGxpbmVbaSAtIGNoYXJPZmZzZXRdO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lIENvbnRlbnQgb2YgdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBjb29yZGluYXRlXG4gICAgICovXG4gICAgX3JlbmRlckNoYXJzRmFzdDogZnVuY3Rpb24obWV0aG9kLCBjdHgsIGxpbmUsIGxlZnQsIHRvcCkge1xuXG4gICAgICBpZiAobWV0aG9kID09PSAnZmlsbFRleHQnICYmIHRoaXMuZmlsbCkge1xuICAgICAgICB0aGlzLmNhbGxTdXBlcignX3JlbmRlckNoYXJzJywgbWV0aG9kLCBjdHgsIGxpbmUsIGxlZnQsIHRvcCk7XG4gICAgICB9XG4gICAgICBpZiAobWV0aG9kID09PSAnc3Ryb2tlVGV4dCcgJiYgKCh0aGlzLnN0cm9rZSAmJiB0aGlzLnN0cm9rZVdpZHRoID4gMCkgfHwgdGhpcy5za2lwRmlsbFN0cm9rZUNoZWNrKSkge1xuICAgICAgICB0aGlzLmNhbGxTdXBlcignX3JlbmRlckNoYXJzJywgbWV0aG9kLCBjdHgsIGxpbmUsIGxlZnQsIHRvcCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gX2NoYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVIZWlnaHQgSGVpZ2h0IG9mIHRoZSBsaW5lXG4gICAgICovXG4gICAgX3JlbmRlckNoYXI6IGZ1bmN0aW9uKG1ldGhvZCwgY3R4LCBsaW5lSW5kZXgsIGksIF9jaGFyLCBsZWZ0LCB0b3AsIGxpbmVIZWlnaHQpIHtcbiAgICAgIHZhciBjaGFyV2lkdGgsIGNoYXJIZWlnaHQsIHNob3VsZEZpbGwsIHNob3VsZFN0cm9rZSxcbiAgICAgICAgICBkZWNsID0gdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGkpLFxuICAgICAgICAgIG9mZnNldCwgdGV4dERlY29yYXRpb24sIGNoYXJzLCBhZGRpdGlvbmFsU3BhY2UsIF9jaGFyV2lkdGg7XG5cbiAgICAgIGlmIChkZWNsKSB7XG4gICAgICAgIGNoYXJIZWlnaHQgPSB0aGlzLl9nZXRIZWlnaHRPZkNoYXIoY3R4LCBfY2hhciwgbGluZUluZGV4LCBpKTtcbiAgICAgICAgc2hvdWxkU3Ryb2tlID0gZGVjbC5zdHJva2U7XG4gICAgICAgIHNob3VsZEZpbGwgPSBkZWNsLmZpbGw7XG4gICAgICAgIHRleHREZWNvcmF0aW9uID0gZGVjbC50ZXh0RGVjb3JhdGlvbjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjaGFySGVpZ2h0ID0gdGhpcy5mb250U2l6ZTtcbiAgICAgIH1cblxuICAgICAgc2hvdWxkU3Ryb2tlID0gKHNob3VsZFN0cm9rZSB8fCB0aGlzLnN0cm9rZSkgJiYgbWV0aG9kID09PSAnc3Ryb2tlVGV4dCc7XG4gICAgICBzaG91bGRGaWxsID0gKHNob3VsZEZpbGwgfHwgdGhpcy5maWxsKSAmJiBtZXRob2QgPT09ICdmaWxsVGV4dCc7XG5cbiAgICAgIGRlY2wgJiYgY3R4LnNhdmUoKTtcblxuICAgICAgY2hhcldpZHRoID0gdGhpcy5fYXBwbHlDaGFyU3R5bGVzR2V0V2lkdGgoY3R4LCBfY2hhciwgbGluZUluZGV4LCBpLCBkZWNsIHx8IG51bGwpO1xuICAgICAgdGV4dERlY29yYXRpb24gPSB0ZXh0RGVjb3JhdGlvbiB8fCB0aGlzLnRleHREZWNvcmF0aW9uO1xuXG4gICAgICBpZiAoZGVjbCAmJiBkZWNsLnRleHRCYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU2hhZG93KGN0eCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jaGFyU3BhY2luZyAhPT0gMCkge1xuICAgICAgICBhZGRpdGlvbmFsU3BhY2UgPSB0aGlzLl9nZXRXaWR0aE9mQ2hhclNwYWNpbmcoKTtcbiAgICAgICAgY2hhcnMgPSBfY2hhci5zcGxpdCgnJyk7XG4gICAgICAgIGNoYXJXaWR0aCA9IDA7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSBjaGFycy5sZW5ndGgsIGNoYXI7IGogPCBsZW47IGorKykge1xuICAgICAgICAgIGNoYXIgPSBjaGFyc1tqXTtcbiAgICAgICAgICBzaG91bGRGaWxsICYmIGN0eC5maWxsVGV4dChjaGFyLCBsZWZ0ICsgY2hhcldpZHRoLCB0b3ApO1xuICAgICAgICAgIHNob3VsZFN0cm9rZSAmJiBjdHguc3Ryb2tlVGV4dChjaGFyLCBsZWZ0ICsgY2hhcldpZHRoLCB0b3ApO1xuICAgICAgICAgIF9jaGFyV2lkdGggPSBjdHgubWVhc3VyZVRleHQoY2hhcikud2lkdGggKyBhZGRpdGlvbmFsU3BhY2U7XG4gICAgICAgICAgY2hhcldpZHRoICs9IF9jaGFyV2lkdGggPiAwID8gX2NoYXJXaWR0aCA6IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzaG91bGRGaWxsICYmIGN0eC5maWxsVGV4dChfY2hhciwgbGVmdCwgdG9wKTtcbiAgICAgICAgc2hvdWxkU3Ryb2tlICYmIGN0eC5zdHJva2VUZXh0KF9jaGFyLCBsZWZ0LCB0b3ApO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dERlY29yYXRpb24gfHwgdGV4dERlY29yYXRpb24gIT09ICcnKSB7XG4gICAgICAgIG9mZnNldCA9IHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24gKiBsaW5lSGVpZ2h0IC8gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICB0aGlzLl9yZW5kZXJDaGFyRGVjb3JhdGlvbihjdHgsIHRleHREZWNvcmF0aW9uLCBsZWZ0LCB0b3AsIG9mZnNldCwgY2hhcldpZHRoLCBjaGFySGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgZGVjbCAmJiBjdHgucmVzdG9yZSgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZShjaGFyV2lkdGgsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcmV2U3R5bGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGhpc1N0eWxlXG4gICAgICovXG4gICAgX2hhc1N0eWxlQ2hhbmdlZDogZnVuY3Rpb24ocHJldlN0eWxlLCB0aGlzU3R5bGUpIHtcbiAgICAgIHJldHVybiAocHJldlN0eWxlLmZpbGwgIT09IHRoaXNTdHlsZS5maWxsIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5mb250U2l6ZSAhPT0gdGhpc1N0eWxlLmZvbnRTaXplIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yICE9PSB0aGlzU3R5bGUudGV4dEJhY2tncm91bmRDb2xvciB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUudGV4dERlY29yYXRpb24gIT09IHRoaXNTdHlsZS50ZXh0RGVjb3JhdGlvbiB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUuZm9udEZhbWlseSAhPT0gdGhpc1N0eWxlLmZvbnRGYW1pbHkgfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLmZvbnRXZWlnaHQgIT09IHRoaXNTdHlsZS5mb250V2VpZ2h0IHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5mb250U3R5bGUgIT09IHRoaXNTdHlsZS5mb250U3R5bGUgfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLnN0cm9rZSAhPT0gdGhpc1N0eWxlLnN0cm9rZSB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUuc3Ryb2tlV2lkdGggIT09IHRoaXNTdHlsZS5zdHJva2VXaWR0aFxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckNoYXJEZWNvcmF0aW9uOiBmdW5jdGlvbihjdHgsIHRleHREZWNvcmF0aW9uLCBsZWZ0LCB0b3AsIG9mZnNldCwgY2hhcldpZHRoLCBjaGFySGVpZ2h0KSB7XG5cbiAgICAgIGlmICghdGV4dERlY29yYXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVjb3JhdGlvbldlaWdodCA9IGNoYXJIZWlnaHQgLyAxNSxcbiAgICAgICAgICBwb3NpdGlvbnMgPSB7XG4gICAgICAgICAgICB1bmRlcmxpbmU6IHRvcCArIGNoYXJIZWlnaHQgLyAxMCxcbiAgICAgICAgICAgICdsaW5lLXRocm91Z2gnOiB0b3AgLSBjaGFySGVpZ2h0ICogKHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24gKyB0aGlzLl9mb250U2l6ZU11bHQgLSAxKSArIGRlY29yYXRpb25XZWlnaHQsXG4gICAgICAgICAgICBvdmVybGluZTogdG9wIC0gKHRoaXMuX2ZvbnRTaXplTXVsdCAtIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24pICogY2hhckhlaWdodFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVjb3JhdGlvbnMgPSBbJ3VuZGVybGluZScsICdsaW5lLXRocm91Z2gnLCAnb3ZlcmxpbmUnXSwgaSwgZGVjb3JhdGlvbjtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGRlY29yYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlY29yYXRpb24gPSBkZWNvcmF0aW9uc1tpXTtcbiAgICAgICAgaWYgKHRleHREZWNvcmF0aW9uLmluZGV4T2YoZGVjb3JhdGlvbikgPiAtMSkge1xuICAgICAgICAgIGN0eC5maWxsUmVjdChsZWZ0LCBwb3NpdGlvbnNbZGVjb3JhdGlvbl0sIGNoYXJXaWR0aCAsIGRlY29yYXRpb25XZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dExpbmU6IGZ1bmN0aW9uKG1ldGhvZCwgY3R4LCBsaW5lLCBsZWZ0LCB0b3AsIGxpbmVJbmRleCkge1xuICAgICAgLy8gdG8gXCJjYW5jZWxcIiB0aGlzLmZvbnRTaXplIHN1YnRyYWN0aW9uIGluIGZhYnJpYy5UZXh0I19yZW5kZXJUZXh0TGluZVxuICAgICAgLy8gdGhlIGFkZGluZyAwLjAzIGlzIGp1c3QgdG8gYWxpZ24gdGV4dCB3aXRoIGl0ZXh0IGJ5IG92ZXJsYXAgdGVzdFxuICAgICAgaWYgKCF0aGlzLmlzRW1wdHlTdHlsZXMoKSkge1xuICAgICAgICB0b3AgKz0gdGhpcy5mb250U2l6ZSAqICh0aGlzLl9mb250U2l6ZUZyYWN0aW9uICsgMC4wMyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3JlbmRlclRleHRMaW5lJywgbWV0aG9kLCBjdHgsIGxpbmUsIGxlZnQsIHRvcCwgbGluZUluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclRleHREZWNvcmF0aW9uOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICh0aGlzLmlzRW1wdHlTdHlsZXMoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsU3VwZXIoJ19yZW5kZXJUZXh0RGVjb3JhdGlvbicsIGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0TGluZXNCYWNrZ3JvdW5kOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfcmVuZGVyVGV4dExpbmVzQmFja2dyb3VuZCcsIGN0eCk7XG5cbiAgICAgIHZhciBsaW5lVG9wT2Zmc2V0ID0gMCwgaGVpZ2h0T2ZMaW5lLFxuICAgICAgICAgIGxpbmVXaWR0aCwgbGluZUxlZnRPZmZzZXQsXG4gICAgICAgICAgbGVmdE9mZnNldCA9IHRoaXMuX2dldExlZnRPZmZzZXQoKSxcbiAgICAgICAgICB0b3BPZmZzZXQgPSB0aGlzLl9nZXRUb3BPZmZzZXQoKSxcbiAgICAgICAgICBsaW5lLCBfY2hhciwgc3R5bGU7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBoZWlnaHRPZkxpbmUgPSB0aGlzLl9nZXRIZWlnaHRPZkxpbmUoY3R4LCBpKTtcbiAgICAgICAgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tpXTtcblxuICAgICAgICBpZiAobGluZSA9PT0gJycgfHwgIXRoaXMuc3R5bGVzIHx8ICF0aGlzLl9nZXRMaW5lU3R5bGUoaSkpIHtcbiAgICAgICAgICBsaW5lVG9wT2Zmc2V0ICs9IGhlaWdodE9mTGluZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmVXaWR0aCA9IHRoaXMuX2dldExpbmVXaWR0aChjdHgsIGkpO1xuICAgICAgICBsaW5lTGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGxpbmVXaWR0aCk7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBsaW5lLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgICAgIHN0eWxlID0gdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihpLCBqKTtcbiAgICAgICAgICBpZiAoIXN0eWxlIHx8ICFzdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2NoYXIgPSBsaW5lW2pdO1xuXG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICBsZWZ0T2Zmc2V0ICsgbGluZUxlZnRPZmZzZXQgKyB0aGlzLl9nZXRXaWR0aE9mQ2hhcnNBdChjdHgsIGksIGopLFxuICAgICAgICAgICAgdG9wT2Zmc2V0ICsgbGluZVRvcE9mZnNldCxcbiAgICAgICAgICAgIHRoaXMuX2dldFdpZHRoT2ZDaGFyKGN0eCwgX2NoYXIsIGksIGopLFxuICAgICAgICAgICAgaGVpZ2h0T2ZMaW5lIC8gdGhpcy5saW5lSGVpZ2h0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lVG9wT2Zmc2V0ICs9IGhlaWdodE9mTGluZTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldENhY2hlUHJvcDogZnVuY3Rpb24oX2NoYXIsIHN0eWxlRGVjbGFyYXRpb24pIHtcbiAgICAgIHJldHVybiBfY2hhciArXG4gICAgICAgICAgICAgc3R5bGVEZWNsYXJhdGlvbi5mb250U2l6ZSArXG4gICAgICAgICAgICAgc3R5bGVEZWNsYXJhdGlvbi5mb250V2VpZ2h0ICtcbiAgICAgICAgICAgICBzdHlsZURlY2xhcmF0aW9uLmZvbnRTdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZm9udEZhbWlseSBuYW1lXG4gICAgICogQHJldHVybiB7T2JqZWN0fSByZWZlcmVuY2UgdG8gY2FjaGVcbiAgICAgKi9cbiAgICBfZ2V0Rm9udENhY2hlOiBmdW5jdGlvbihmb250RmFtaWx5KSB7XG4gICAgICBpZiAoIWZhYnJpYy5jaGFyV2lkdGhzQ2FjaGVbZm9udEZhbWlseV0pIHtcbiAgICAgICAgZmFicmljLmNoYXJXaWR0aHNDYWNoZVtmb250RmFtaWx5XSA9IHsgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWJyaWMuY2hhcldpZHRoc0NhY2hlW2ZvbnRGYW1pbHldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gX2NoYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZGVjbF1cbiAgICAgKi9cbiAgICBfYXBwbHlDaGFyU3R5bGVzR2V0V2lkdGg6IGZ1bmN0aW9uKGN0eCwgX2NoYXIsIGxpbmVJbmRleCwgY2hhckluZGV4LCBkZWNsKSB7XG4gICAgICB2YXIgY2hhckRlY2wgPSBkZWNsIHx8IHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBjaGFySW5kZXgpLFxuICAgICAgICAgIHN0eWxlRGVjbGFyYXRpb24gPSBjbG9uZShjaGFyRGVjbCksXG4gICAgICAgICAgd2lkdGgsIGNhY2hlUHJvcCwgY2hhcldpZHRoc0NhY2hlO1xuXG4gICAgICB0aGlzLl9hcHBseUZvbnRTdHlsZXMoc3R5bGVEZWNsYXJhdGlvbik7XG4gICAgICBjaGFyV2lkdGhzQ2FjaGUgPSB0aGlzLl9nZXRGb250Q2FjaGUoc3R5bGVEZWNsYXJhdGlvbi5mb250RmFtaWx5KTtcbiAgICAgIGNhY2hlUHJvcCA9IHRoaXMuX2dldENhY2hlUHJvcChfY2hhciwgc3R5bGVEZWNsYXJhdGlvbik7XG5cbiAgICAgIC8vIHNob3J0LWNpcmN1aXQgaWYgbm8gc3R5bGVzIGZvciB0aGlzIGNoYXJcbiAgICAgIC8vIGdsb2JhbCBzdHlsZSBmcm9tIG9iamVjdCBpcyBhbHdheXMgYXBwbHllZCBhbmQgaGFuZGxlZCBieSBzYXZlIGFuZCByZXN0b3JlXG4gICAgICBpZiAoIWNoYXJEZWNsICYmIGNoYXJXaWR0aHNDYWNoZVtjYWNoZVByb3BdICYmIHRoaXMuY2FjaGluZykge1xuICAgICAgICByZXR1cm4gY2hhcldpZHRoc0NhY2hlW2NhY2hlUHJvcF07XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc3R5bGVEZWNsYXJhdGlvbi5zaGFkb3cgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHN0eWxlRGVjbGFyYXRpb24uc2hhZG93ID0gbmV3IGZhYnJpYy5TaGFkb3coc3R5bGVEZWNsYXJhdGlvbi5zaGFkb3cpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmlsbCA9IHN0eWxlRGVjbGFyYXRpb24uZmlsbCB8fCB0aGlzLmZpbGw7XG4gICAgICBjdHguZmlsbFN0eWxlID0gZmlsbC50b0xpdmVcbiAgICAgICAgPyBmaWxsLnRvTGl2ZShjdHgsIHRoaXMpXG4gICAgICAgIDogZmlsbDtcblxuICAgICAgaWYgKHN0eWxlRGVjbGFyYXRpb24uc3Ryb2tlKSB7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IChzdHlsZURlY2xhcmF0aW9uLnN0cm9rZSAmJiBzdHlsZURlY2xhcmF0aW9uLnN0cm9rZS50b0xpdmUpXG4gICAgICAgICAgPyBzdHlsZURlY2xhcmF0aW9uLnN0cm9rZS50b0xpdmUoY3R4LCB0aGlzKVxuICAgICAgICAgIDogc3R5bGVEZWNsYXJhdGlvbi5zdHJva2U7XG4gICAgICB9XG5cbiAgICAgIGN0eC5saW5lV2lkdGggPSBzdHlsZURlY2xhcmF0aW9uLnN0cm9rZVdpZHRoIHx8IHRoaXMuc3Ryb2tlV2lkdGg7XG4gICAgICBjdHguZm9udCA9IHRoaXMuX2dldEZvbnREZWNsYXJhdGlvbi5jYWxsKHN0eWxlRGVjbGFyYXRpb24pO1xuXG4gICAgICAvL2lmIHdlIHdhbnQgdGhpcy5fc2V0U2hhZG93LmNhbGwgdG8gd29yayB3aXRoIHN0eWxlRGVjbGFyaW9uXG4gICAgICAvL3dlIGhhdmUgdG8gYWRkIHRob3NlIHJlZmVyZW5jZXNcbiAgICAgIGlmIChzdHlsZURlY2xhcmF0aW9uLnNoYWRvdykge1xuICAgICAgICBzdHlsZURlY2xhcmF0aW9uLnNjYWxlWCA9IHRoaXMuc2NhbGVYO1xuICAgICAgICBzdHlsZURlY2xhcmF0aW9uLnNjYWxlWSA9IHRoaXMuc2NhbGVZO1xuICAgICAgICBzdHlsZURlY2xhcmF0aW9uLmNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgICBzdHlsZURlY2xhcmF0aW9uLmdldE9iamVjdFNjYWxpbmcgPSB0aGlzLmdldE9iamVjdFNjYWxpbmc7XG4gICAgICAgIHRoaXMuX3NldFNoYWRvdy5jYWxsKHN0eWxlRGVjbGFyYXRpb24sIGN0eCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5jYWNoaW5nIHx8ICFjaGFyV2lkdGhzQ2FjaGVbY2FjaGVQcm9wXSkge1xuICAgICAgICB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dChfY2hhcikud2lkdGg7XG4gICAgICAgIHRoaXMuY2FjaGluZyAmJiAoY2hhcldpZHRoc0NhY2hlW2NhY2hlUHJvcF0gPSB3aWR0aCk7XG4gICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYXJXaWR0aHNDYWNoZVtjYWNoZVByb3BdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZURlY2xhcmF0aW9uXG4gICAgICovXG4gICAgX2FwcGx5Rm9udFN0eWxlczogZnVuY3Rpb24oc3R5bGVEZWNsYXJhdGlvbikge1xuICAgICAgaWYgKCFzdHlsZURlY2xhcmF0aW9uLmZvbnRGYW1pbHkpIHtcbiAgICAgICAgc3R5bGVEZWNsYXJhdGlvbi5mb250RmFtaWx5ID0gdGhpcy5mb250RmFtaWx5O1xuICAgICAgfVxuICAgICAgaWYgKCFzdHlsZURlY2xhcmF0aW9uLmZvbnRTaXplKSB7XG4gICAgICAgIHN0eWxlRGVjbGFyYXRpb24uZm9udFNpemUgPSB0aGlzLmZvbnRTaXplO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHlsZURlY2xhcmF0aW9uLmZvbnRXZWlnaHQpIHtcbiAgICAgICAgc3R5bGVEZWNsYXJhdGlvbi5mb250V2VpZ2h0ID0gdGhpcy5mb250V2VpZ2h0O1xuICAgICAgfVxuICAgICAgaWYgKCFzdHlsZURlY2xhcmF0aW9uLmZvbnRTdHlsZSkge1xuICAgICAgICBzdHlsZURlY2xhcmF0aW9uLmZvbnRTdHlsZSA9IHRoaXMuZm9udFN0eWxlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JldHVybkNsb25lT3JFbXB0eT1mYWxzZV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgcmV0dXJuQ2xvbmVPckVtcHR5KSB7XG4gICAgICBpZiAocmV0dXJuQ2xvbmVPckVtcHR5KSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zdHlsZXNbbGluZUluZGV4XSAmJiB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleF0pXG4gICAgICAgICAgPyBjbG9uZSh0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleF0pXG4gICAgICAgICAgOiB7IH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdICYmIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4XSA/IHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4XSA6IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgsIHN0eWxlKSB7XG4gICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleF0gPSBzdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RlbGV0ZVN0eWxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB7XG4gICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0TGluZVN0eWxlOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0TGluZVN0eWxlOiBmdW5jdGlvbihsaW5lSW5kZXgsIHN0eWxlKSB7XG4gICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdID0gc3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZWxldGVMaW5lU3R5bGU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2xpbmVJbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9nZXRXaWR0aE9mQ2hhcjogZnVuY3Rpb24oY3R4LCBfY2hhciwgbGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICAgIGlmICghdGhpcy5faXNNZWFzdXJpbmcgJiYgdGhpcy50ZXh0QWxpZ24gPT09ICdqdXN0aWZ5JyAmJiB0aGlzLl9yZVNwYWNlc0FuZFRhYnMudGVzdChfY2hhcikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFdpZHRoT2ZTcGFjZShjdHgsIGxpbmVJbmRleCk7XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy5fYXBwbHlDaGFyU3R5bGVzR2V0V2lkdGgoY3R4LCBfY2hhciwgbGluZUluZGV4LCBjaGFySW5kZXgpO1xuICAgICAgaWYgKHRoaXMuY2hhclNwYWNpbmcgIT09IDApIHtcbiAgICAgICAgd2lkdGggKz0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuIHdpZHRoID4gMCA/IHdpZHRoIDogMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKi9cbiAgICBfZ2V0SGVpZ2h0T2ZDaGFyOiBmdW5jdGlvbihjdHgsIGxpbmVJbmRleCwgY2hhckluZGV4KSB7XG4gICAgICB2YXIgc3R5bGUgPSB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KTtcbiAgICAgIHJldHVybiBzdHlsZSAmJiBzdHlsZS5mb250U2l6ZSA/IHN0eWxlLmZvbnRTaXplIDogdGhpcy5mb250U2l6ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKi9cbiAgICBfZ2V0V2lkdGhPZkNoYXJzQXQ6IGZ1bmN0aW9uKGN0eCwgbGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICAgIHZhciB3aWR0aCA9IDAsIGksIF9jaGFyO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNoYXJJbmRleDsgaSsrKSB7XG4gICAgICAgIF9jaGFyID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF1baV07XG4gICAgICAgIHdpZHRoICs9IHRoaXMuX2dldFdpZHRoT2ZDaGFyKGN0eCwgX2NoYXIsIGxpbmVJbmRleCwgaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggbGluZSBudW1iZXJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IExpbmUgd2lkdGhcbiAgICAgKi9cbiAgICBfbWVhc3VyZUxpbmU6IGZ1bmN0aW9uKGN0eCwgbGluZUluZGV4KSB7XG4gICAgICB0aGlzLl9pc01lYXN1cmluZyA9IHRydWU7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLl9nZXRXaWR0aE9mQ2hhcnNBdChjdHgsIGxpbmVJbmRleCwgdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0ubGVuZ3RoKTtcbiAgICAgIGlmICh0aGlzLmNoYXJTcGFjaW5nICE9PSAwKSB7XG4gICAgICAgIHdpZHRoIC09IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpO1xuICAgICAgfVxuICAgICAgdGhpcy5faXNNZWFzdXJpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiB3aWR0aCA+IDAgPyB3aWR0aCA6IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKi9cbiAgICBfZ2V0V2lkdGhPZlNwYWNlOiBmdW5jdGlvbiAoY3R4LCBsaW5lSW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLl9fd2lkdGhPZlNwYWNlW2xpbmVJbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX193aWR0aE9mU3BhY2VbbGluZUluZGV4XTtcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0sXG4gICAgICAgICAgd29yZHNXaWR0aCA9IHRoaXMuX2dldFdpZHRoT2ZXb3JkcyhjdHgsIGxpbmUsIGxpbmVJbmRleCwgMCksXG4gICAgICAgICAgd2lkdGhEaWZmID0gdGhpcy53aWR0aCAtIHdvcmRzV2lkdGgsXG4gICAgICAgICAgbnVtU3BhY2VzID0gbGluZS5sZW5ndGggLSBsaW5lLnJlcGxhY2UodGhpcy5fcmVTcGFjZXNBbmRUYWJzLCAnJykubGVuZ3RoLFxuICAgICAgICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGhEaWZmIC8gbnVtU3BhY2VzLCBjdHgubWVhc3VyZVRleHQoJyAnKS53aWR0aCk7XG4gICAgICB0aGlzLl9fd2lkdGhPZlNwYWNlW2xpbmVJbmRleF0gPSB3aWR0aDtcbiAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJPZmZzZXRcbiAgICAgKi9cbiAgICBfZ2V0V2lkdGhPZldvcmRzOiBmdW5jdGlvbiAoY3R4LCBsaW5lLCBsaW5lSW5kZXgsIGNoYXJPZmZzZXQpIHtcbiAgICAgIHZhciB3aWR0aCA9IDA7XG5cbiAgICAgIGZvciAodmFyIGNoYXJJbmRleCA9IDA7IGNoYXJJbmRleCA8IGxpbmUubGVuZ3RoOyBjaGFySW5kZXgrKykge1xuICAgICAgICB2YXIgX2NoYXIgPSBsaW5lW2NoYXJJbmRleF07XG5cbiAgICAgICAgaWYgKCFfY2hhci5tYXRjaCgvXFxzLykpIHtcbiAgICAgICAgICB3aWR0aCArPSB0aGlzLl9nZXRXaWR0aE9mQ2hhcihjdHgsIF9jaGFyLCBsaW5lSW5kZXgsIGNoYXJJbmRleCArIGNoYXJPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX2dldEhlaWdodE9mTGluZTogZnVuY3Rpb24oY3R4LCBsaW5lSW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLl9fbGluZUhlaWdodHNbbGluZUluZGV4XSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2xpbmVIZWlnaHRzW2xpbmVJbmRleF07XG4gICAgICB9XG5cbiAgICAgIHZhciBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0sXG4gICAgICAgICAgbWF4SGVpZ2h0ID0gdGhpcy5fZ2V0SGVpZ2h0T2ZDaGFyKGN0eCwgbGluZUluZGV4LCAwKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IGxpbmUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnRDaGFySGVpZ2h0ID0gdGhpcy5fZ2V0SGVpZ2h0T2ZDaGFyKGN0eCwgbGluZUluZGV4LCBpKTtcbiAgICAgICAgaWYgKGN1cnJlbnRDaGFySGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgbWF4SGVpZ2h0ID0gY3VycmVudENoYXJIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX19saW5lSGVpZ2h0c1tsaW5lSW5kZXhdID0gbWF4SGVpZ2h0ICogdGhpcy5saW5lSGVpZ2h0ICogdGhpcy5fZm9udFNpemVNdWx0O1xuICAgICAgcmV0dXJuIHRoaXMuX19saW5lSGVpZ2h0c1tsaW5lSW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfZ2V0VGV4dEhlaWdodDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgbGluZUhlaWdodCwgaGVpZ2h0ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbGluZUhlaWdodCA9IHRoaXMuX2dldEhlaWdodE9mTGluZShjdHgsIGkpO1xuICAgICAgICBoZWlnaHQgKz0gKGkgPT09IGxlbiAtIDEgPyBsaW5lSGVpZ2h0IC8gdGhpcy5saW5lSGVpZ2h0IDogbGluZUhlaWdodCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBtZXRob2QgdG9PYmplY3RcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JywgcHJvcGVydGllc1RvSW5jbHVkZSksIHtcbiAgICAgICAgc3R5bGVzOiBjbG9uZSh0aGlzLnN0eWxlcywgdHJ1ZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLklUZXh0IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JVGV4dFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGludm9rZWQgd2l0aCBuZXcgaW5zdGFuY2UgYXMgYXJndW1lbnRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VBc3luY10gRm9yY2UgYW4gYXN5bmMgYmVoYXZpb3VyIHRyeWluZyB0byBjcmVhdGUgcGF0dGVybiBmaXJzdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IGluc3RhbmNlIG9mIGZhYnJpYy5JVGV4dFxuICAgKi9cbiAgZmFicmljLklUZXh0LmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrLCBmb3JjZUFzeW5jKSB7XG4gICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ0lUZXh0Jywgb2JqZWN0LCBjYWxsYmFjaywgZm9yY2VBc3luYywgJ3RleHQnKTtcbiAgfTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBjbG9uZSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZTtcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5JVGV4dC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLklUZXh0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbGwgdGhlIGludGVyYWN0aXZlIGJlaGF2aW9yIG9mIElUZXh0XG4gICAgICovXG4gICAgaW5pdEJlaGF2aW9yOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaW5pdEFkZGVkSGFuZGxlcigpO1xuICAgICAgdGhpcy5pbml0UmVtb3ZlZEhhbmRsZXIoKTtcbiAgICAgIHRoaXMuaW5pdEN1cnNvclNlbGVjdGlvbkhhbmRsZXJzKCk7XG4gICAgICB0aGlzLmluaXREb3VibGVDbGlja1NpbXVsYXRpb24oKTtcbiAgICAgIHRoaXMubW91c2VNb3ZlSGFuZGxlciA9IHRoaXMubW91c2VNb3ZlSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBcInNlbGVjdGVkXCIgZXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIGluaXRTZWxlY3RlZEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5vbignc2VsZWN0ZWQnLCBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIF90aGlzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBcImFkZGVkXCIgZXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIGluaXRBZGRlZEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMub24oJ2FkZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSBfdGhpcy5jYW52YXM7XG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICBpZiAoIWNhbnZhcy5faGFzSVRleHRIYW5kbGVycykge1xuICAgICAgICAgICAgY2FudmFzLl9oYXNJVGV4dEhhbmRsZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLl9pbml0Q2FudmFzSGFuZGxlcnMoY2FudmFzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FudmFzLl9pVGV4dEluc3RhbmNlcyA9IGNhbnZhcy5faVRleHRJbnN0YW5jZXMgfHwgW107XG4gICAgICAgICAgY2FudmFzLl9pVGV4dEluc3RhbmNlcy5wdXNoKF90aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGluaXRSZW1vdmVkSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5vbigncmVtb3ZlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2FudmFzID0gX3RoaXMuY2FudmFzO1xuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgY2FudmFzLl9pVGV4dEluc3RhbmNlcyA9IGNhbnZhcy5faVRleHRJbnN0YW5jZXMgfHwgW107XG4gICAgICAgICAgZmFicmljLnV0aWwucmVtb3ZlRnJvbUFycmF5KGNhbnZhcy5faVRleHRJbnN0YW5jZXMsIF90aGlzKTtcbiAgICAgICAgICBpZiAoY2FudmFzLl9pVGV4dEluc3RhbmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNhbnZhcy5faGFzSVRleHRIYW5kbGVycyA9IGZhbHNlO1xuICAgICAgICAgICAgX3RoaXMuX3JlbW92ZUNhbnZhc0hhbmRsZXJzKGNhbnZhcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVnaXN0ZXIgY2FudmFzIGV2ZW50IHRvIG1hbmFnZSBleGl0aW5nIG9uIG90aGVyIGluc3RhbmNlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRDYW52YXNIYW5kbGVyczogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICBjYW52YXMuX2NhbnZhc0lUZXh0U2VsZWN0aW9uQ2xlYXJlZEhhbmxkZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZhYnJpYy5JVGV4dC5wcm90b3R5cGUuZXhpdEVkaXRpbmdPbk90aGVycyhjYW52YXMpO1xuICAgICAgfSkuYmluZCh0aGlzKTtcbiAgICAgIGNhbnZhcy5fbW91c2VVcElUZXh0SGFuZGxlciA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGNhbnZhcy5faVRleHRJbnN0YW5jZXMpIHtcbiAgICAgICAgICBjYW52YXMuX2lUZXh0SW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICBvYmouX19pc01vdXNlZG93biA9IGZhbHNlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KS5iaW5kKHRoaXMpO1xuICAgICAgY2FudmFzLm9uKCdzZWxlY3Rpb246Y2xlYXJlZCcsIGNhbnZhcy5fY2FudmFzSVRleHRTZWxlY3Rpb25DbGVhcmVkSGFubGRlcik7XG4gICAgICBjYW52YXMub24oJ29iamVjdDpzZWxlY3RlZCcsIGNhbnZhcy5fY2FudmFzSVRleHRTZWxlY3Rpb25DbGVhcmVkSGFubGRlcik7XG4gICAgICBjYW52YXMub24oJ21vdXNlOnVwJywgY2FudmFzLl9tb3VzZVVwSVRleHRIYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGNhbnZhcyBldmVudCB0byBtYW5hZ2UgZXhpdGluZyBvbiBvdGhlciBpbnN0YW5jZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmVDYW52YXNIYW5kbGVyczogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICBjYW52YXMub2ZmKCdzZWxlY3Rpb246Y2xlYXJlZCcsIGNhbnZhcy5fY2FudmFzSVRleHRTZWxlY3Rpb25DbGVhcmVkSGFubGRlcik7XG4gICAgICBjYW52YXMub2ZmKCdvYmplY3Q6c2VsZWN0ZWQnLCBjYW52YXMuX2NhbnZhc0lUZXh0U2VsZWN0aW9uQ2xlYXJlZEhhbmxkZXIpO1xuICAgICAgY2FudmFzLm9mZignbW91c2U6dXAnLCBjYW52YXMuX21vdXNlVXBJVGV4dEhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90aWNrOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRUaWNrU3RhdGUgPSB0aGlzLl9hbmltYXRlQ3Vyc29yKHRoaXMsIDEsIHRoaXMuY3Vyc29yRHVyYXRpb24sICdfb25UaWNrQ29tcGxldGUnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYW5pbWF0ZUN1cnNvcjogZnVuY3Rpb24ob2JqLCB0YXJnZXRPcGFjaXR5LCBkdXJhdGlvbiwgY29tcGxldGVNZXRob2QpIHtcblxuICAgICAgdmFyIHRpY2tTdGF0ZTtcblxuICAgICAgdGlja1N0YXRlID0ge1xuICAgICAgICBpc0Fib3J0ZWQ6IGZhbHNlLFxuICAgICAgICBhYm9ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5pc0Fib3J0ZWQgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgb2JqLmFuaW1hdGUoJ19jdXJyZW50Q3Vyc29yT3BhY2l0eScsIHRhcmdldE9wYWNpdHksIHtcbiAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoIXRpY2tTdGF0ZS5pc0Fib3J0ZWQpIHtcbiAgICAgICAgICAgIG9ialtjb21wbGV0ZU1ldGhvZF0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBhbmltYXRlIGEgc2VsZWN0aW9uLCBvbmx5IGN1cnNvclxuICAgICAgICAgIGlmIChvYmouY2FudmFzICYmIG9iai5zZWxlY3Rpb25TdGFydCA9PT0gb2JqLnNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgb2JqLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhYm9ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRpY2tTdGF0ZS5pc0Fib3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRpY2tTdGF0ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25UaWNrQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5fY3Vyc29yVGltZW91dDEpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2N1cnNvclRpbWVvdXQxKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2N1cnNvclRpbWVvdXQxID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMuX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZSA9IF90aGlzLl9hbmltYXRlQ3Vyc29yKF90aGlzLCAwLCB0aGlzLmN1cnNvckR1cmF0aW9uIC8gMiwgJ190aWNrJyk7XG4gICAgICB9LCAxMDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBkZWxheWVkIGN1cnNvclxuICAgICAqL1xuICAgIGluaXREZWxheWVkQ3Vyc29yOiBmdW5jdGlvbihyZXN0YXJ0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgIGRlbGF5ID0gcmVzdGFydCA/IDAgOiB0aGlzLmN1cnNvckRlbGF5O1xuXG4gICAgICB0aGlzLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCk7XG4gICAgICB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eSA9IDE7XG4gICAgICB0aGlzLl9jdXJzb3JUaW1lb3V0MiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLl90aWNrKCk7XG4gICAgICB9LCBkZWxheSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFib3J0cyBjdXJzb3IgYW5pbWF0aW9uIGFuZCBjbGVhcnMgYWxsIHRpbWVvdXRzXG4gICAgICovXG4gICAgYWJvcnRDdXJzb3JBbmltYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNob3VsZENsZWFyID0gdGhpcy5fY3VycmVudFRpY2tTdGF0ZSB8fCB0aGlzLl9jdXJyZW50VGlja0NvbXBsZXRlU3RhdGU7XG4gICAgICB0aGlzLl9jdXJyZW50VGlja1N0YXRlICYmIHRoaXMuX2N1cnJlbnRUaWNrU3RhdGUuYWJvcnQoKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZSAmJiB0aGlzLl9jdXJyZW50VGlja0NvbXBsZXRlU3RhdGUuYWJvcnQoKTtcblxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2N1cnNvclRpbWVvdXQxKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9jdXJzb3JUaW1lb3V0Mik7XG5cbiAgICAgIHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5ID0gMDtcbiAgICAgIC8vIHRvIGNsZWFyIGp1c3QgaXRleHQgYXJlYSB3ZSBuZWVkIHRvIHRyYW5zZm9ybSB0aGUgY29udGV4dFxuICAgICAgLy8gaXQgbWF5IG5vdCBiZSB3b3J0aCBpdFxuICAgICAgaWYgKHNob3VsZENsZWFyKSB7XG4gICAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wIHx8IHRoaXMuY3R4KTtcbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGVudGlyZSB0ZXh0XG4gICAgICovXG4gICAgc2VsZWN0QWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSAwO1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLnRleHQubGVuZ3RoO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc2VsZWN0ZWQgdGV4dFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZFRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dC5zbGljZSh0aGlzLnNlbGVjdGlvblN0YXJ0LCB0aGlzLnNlbGVjdGlvbkVuZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgbmV3IHNlbGVjdGlvbiBpbmRleCByZXByZXNlbnRpbmcgc3RhcnQgb2YgY3VycmVudCB3b3JkIGFjY29yZGluZyB0byBjdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEZyb20gU3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IE5ldyBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKi9cbiAgICBmaW5kV29yZEJvdW5kYXJ5TGVmdDogZnVuY3Rpb24oc3RhcnRGcm9tKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMCwgaW5kZXggPSBzdGFydEZyb20gLSAxO1xuXG4gICAgICAvLyByZW1vdmUgc3BhY2UgYmVmb3JlIGN1cnNvciBmaXJzdFxuICAgICAgaWYgKHRoaXMuX3JlU3BhY2UudGVzdCh0aGlzLnRleHQuY2hhckF0KGluZGV4KSkpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3JlU3BhY2UudGVzdCh0aGlzLnRleHQuY2hhckF0KGluZGV4KSkpIHtcbiAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICBpbmRleC0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoL1xcUy8udGVzdCh0aGlzLnRleHQuY2hhckF0KGluZGV4KSkgJiYgaW5kZXggPiAtMSkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXJ0RnJvbSAtIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBuZXcgc2VsZWN0aW9uIGluZGV4IHJlcHJlc2VudGluZyBlbmQgb2YgY3VycmVudCB3b3JkIGFjY29yZGluZyB0byBjdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEZyb20gQ3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IE5ldyBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKi9cbiAgICBmaW5kV29yZEJvdW5kYXJ5UmlnaHQ6IGZ1bmN0aW9uKHN0YXJ0RnJvbSkge1xuICAgICAgdmFyIG9mZnNldCA9IDAsIGluZGV4ID0gc3RhcnRGcm9tO1xuXG4gICAgICAvLyByZW1vdmUgc3BhY2UgYWZ0ZXIgY3Vyc29yIGZpcnN0XG4gICAgICBpZiAodGhpcy5fcmVTcGFjZS50ZXN0KHRoaXMudGV4dC5jaGFyQXQoaW5kZXgpKSkge1xuICAgICAgICB3aGlsZSAodGhpcy5fcmVTcGFjZS50ZXN0KHRoaXMudGV4dC5jaGFyQXQoaW5kZXgpKSkge1xuICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICgvXFxTLy50ZXN0KHRoaXMudGV4dC5jaGFyQXQoaW5kZXgpKSAmJiBpbmRleCA8IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGFydEZyb20gKyBvZmZzZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgbmV3IHNlbGVjdGlvbiBpbmRleCByZXByZXNlbnRpbmcgc3RhcnQgb2YgY3VycmVudCBsaW5lIGFjY29yZGluZyB0byBjdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEZyb20gQ3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IE5ldyBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKi9cbiAgICBmaW5kTGluZUJvdW5kYXJ5TGVmdDogZnVuY3Rpb24oc3RhcnRGcm9tKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMCwgaW5kZXggPSBzdGFydEZyb20gLSAxO1xuXG4gICAgICB3aGlsZSAoIS9cXG4vLnRlc3QodGhpcy50ZXh0LmNoYXJBdChpbmRleCkpICYmIGluZGV4ID4gLTEpIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGFydEZyb20gLSBvZmZzZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgbmV3IHNlbGVjdGlvbiBpbmRleCByZXByZXNlbnRpbmcgZW5kIG9mIGN1cnJlbnQgbGluZSBhY2NvcmRpbmcgdG8gY3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRGcm9tIEN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBOZXcgc2VsZWN0aW9uIGluZGV4XG4gICAgICovXG4gICAgZmluZExpbmVCb3VuZGFyeVJpZ2h0OiBmdW5jdGlvbihzdGFydEZyb20pIHtcbiAgICAgIHZhciBvZmZzZXQgPSAwLCBpbmRleCA9IHN0YXJ0RnJvbTtcblxuICAgICAgd2hpbGUgKCEvXFxuLy50ZXN0KHRoaXMudGV4dC5jaGFyQXQoaW5kZXgpKSAmJiBpbmRleCA8IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGFydEZyb20gKyBvZmZzZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbnVtYmVyIG9mIG5ld2xpbmVzIGluIHNlbGVjdGVkIHRleHRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IE51bWJlciBvZiBuZXdsaW5lcyBpbiBzZWxlY3RlZCB0ZXh0XG4gICAgICovXG4gICAgZ2V0TnVtTmV3TGluZXNJblNlbGVjdGVkVGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZWN0ZWRUZXh0ID0gdGhpcy5nZXRTZWxlY3RlZFRleHQoKSxcbiAgICAgICAgICBudW1OZXdMaW5lcyAgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsZWN0ZWRUZXh0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxlY3RlZFRleHRbaV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgbnVtTmV3TGluZXMrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bU5ld0xpbmVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBpbmRleCBjb3JyZXNwb25kaW5nIHRvIGJlZ2lubmluZyBvciBlbmQgb2YgYSB3b3JkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNlbGVjdGlvblN0YXJ0IEluZGV4IG9mIGEgY2hhcmFjdGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRpcmVjdGlvbiAxIG9yIC0xXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBJbmRleCBvZiB0aGUgYmVnaW5uaW5nIG9yIGVuZCBvZiBhIHdvcmRcbiAgICAgKi9cbiAgICBzZWFyY2hXb3JkQm91bmRhcnk6IGZ1bmN0aW9uKHNlbGVjdGlvblN0YXJ0LCBkaXJlY3Rpb24pIHtcbiAgICAgIHZhciBpbmRleCAgICAgPSB0aGlzLl9yZVNwYWNlLnRlc3QodGhpcy50ZXh0LmNoYXJBdChzZWxlY3Rpb25TdGFydCkpID8gc2VsZWN0aW9uU3RhcnQgLSAxIDogc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgX2NoYXIgICAgID0gdGhpcy50ZXh0LmNoYXJBdChpbmRleCksXG4gICAgICAgICAgcmVOb25Xb3JkID0gL1sgXFxuXFwuLDshXFw/XFwtXS87XG5cbiAgICAgIHdoaWxlICghcmVOb25Xb3JkLnRlc3QoX2NoYXIpICYmIGluZGV4ID4gMCAmJiBpbmRleCA8IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgaW5kZXggKz0gZGlyZWN0aW9uO1xuICAgICAgICBfY2hhciA9IHRoaXMudGV4dC5jaGFyQXQoaW5kZXgpO1xuICAgICAgfVxuICAgICAgaWYgKHJlTm9uV29yZC50ZXN0KF9jaGFyKSAmJiBfY2hhciAhPT0gJ1xcbicpIHtcbiAgICAgICAgaW5kZXggKz0gZGlyZWN0aW9uID09PSAxID8gMCA6IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgYSB3b3JkIGJhc2VkIG9uIHRoZSBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWxlY3Rpb25TdGFydCBJbmRleCBvZiBhIGNoYXJhY3RlclxuICAgICAqL1xuICAgIHNlbGVjdFdvcmQ6IGZ1bmN0aW9uKHNlbGVjdGlvblN0YXJ0KSB7XG4gICAgICBzZWxlY3Rpb25TdGFydCA9IHNlbGVjdGlvblN0YXJ0IHx8IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICB2YXIgbmV3U2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlYXJjaFdvcmRCb3VuZGFyeShzZWxlY3Rpb25TdGFydCwgLTEpLCAvKiBzZWFyY2ggYmFja3dhcmRzICovXG4gICAgICAgICAgbmV3U2VsZWN0aW9uRW5kID0gdGhpcy5zZWFyY2hXb3JkQm91bmRhcnkoc2VsZWN0aW9uU3RhcnQsIDEpOyAvKiBzZWFyY2ggZm9yd2FyZCAqL1xuXG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uU3RhcnQ7XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvbkVuZDtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgICAgdGhpcy5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGEgbGluZSBiYXNlZCBvbiB0aGUgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2VsZWN0aW9uU3RhcnQgSW5kZXggb2YgYSBjaGFyYWN0ZXJcbiAgICAgKi9cbiAgICBzZWxlY3RMaW5lOiBmdW5jdGlvbihzZWxlY3Rpb25TdGFydCkge1xuICAgICAgc2VsZWN0aW9uU3RhcnQgPSBzZWxlY3Rpb25TdGFydCB8fCB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgdmFyIG5ld1NlbGVjdGlvblN0YXJ0ID0gdGhpcy5maW5kTGluZUJvdW5kYXJ5TGVmdChzZWxlY3Rpb25TdGFydCksXG4gICAgICAgICAgbmV3U2VsZWN0aW9uRW5kID0gdGhpcy5maW5kTGluZUJvdW5kYXJ5UmlnaHQoc2VsZWN0aW9uU3RhcnQpO1xuXG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uU3RhcnQ7XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvbkVuZDtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbnRlcnMgZWRpdGluZyBzdGF0ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBlbnRlckVkaXRpbmc6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICh0aGlzLmlzRWRpdGluZyB8fCAhdGhpcy5lZGl0YWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmV4aXRFZGl0aW5nT25PdGhlcnModGhpcy5jYW52YXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlzRWRpdGluZyA9IHRydWU7XG5cbiAgICAgIHRoaXMuaW5pdEhpZGRlblRleHRhcmVhKGUpO1xuICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5mb2N1cygpO1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICAgIHRoaXMuX3NhdmVFZGl0aW5nUHJvcHMoKTtcbiAgICAgIHRoaXMuX3NldEVkaXRpbmdQcm9wcygpO1xuICAgICAgdGhpcy5fdGV4dEJlZm9yZUVkaXQgPSB0aGlzLnRleHQ7XG5cbiAgICAgIHRoaXMuX3RpY2soKTtcbiAgICAgIHRoaXMuZmlyZSgnZWRpdGluZzplbnRlcmVkJyk7XG5cbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbnZhcy5maXJlKCd0ZXh0OmVkaXRpbmc6ZW50ZXJlZCcsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICAgICAgdGhpcy5pbml0TW91c2VNb3ZlSGFuZGxlcigpO1xuICAgICAgdGhpcy5jYW52YXMucmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZXhpdEVkaXRpbmdPbk90aGVyczogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICBpZiAoY2FudmFzLl9pVGV4dEluc3RhbmNlcykge1xuICAgICAgICBjYW52YXMuX2lUZXh0SW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgb2JqLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgaWYgKG9iai5pc0VkaXRpbmcpIHtcbiAgICAgICAgICAgIG9iai5leGl0RWRpdGluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIFwibW91c2Vtb3ZlXCIgZXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIGluaXRNb3VzZU1vdmVIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY2FudmFzLm9uKCdtb3VzZTptb3ZlJywgdGhpcy5tb3VzZU1vdmVIYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBtb3VzZU1vdmVIYW5kbGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoIXRoaXMuX19pc01vdXNlZG93biB8fCAhdGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3U2VsZWN0aW9uU3RhcnQgPSB0aGlzLmdldFNlbGVjdGlvblN0YXJ0RnJvbVBvaW50ZXIob3B0aW9ucy5lKSxcbiAgICAgICAgICBjdXJyZW50U3RhcnQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgIGN1cnJlbnRFbmQgPSB0aGlzLnNlbGVjdGlvbkVuZDtcbiAgICAgIGlmIChuZXdTZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5fX3NlbGVjdGlvblN0YXJ0T25Nb3VzZURvd24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG5ld1NlbGVjdGlvblN0YXJ0ID4gdGhpcy5fX3NlbGVjdGlvblN0YXJ0T25Nb3VzZURvd24pIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IHRoaXMuX19zZWxlY3Rpb25TdGFydE9uTW91c2VEb3duO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvblN0YXJ0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb25TdGFydDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLl9fc2VsZWN0aW9uU3RhcnRPbk1vdXNlRG93bjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSBjdXJyZW50U3RhcnQgfHwgdGhpcy5zZWxlY3Rpb25FbmQgIT09IGN1cnJlbnRFbmQpIHtcbiAgICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRFZGl0aW5nUHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5ob3ZlckN1cnNvciA9ICd0ZXh0JztcblxuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmRlZmF1bHRDdXJzb3IgPSB0aGlzLmNhbnZhcy5tb3ZlQ3Vyc29yID0gJ3RleHQnO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvcmRlckNvbG9yID0gdGhpcy5lZGl0aW5nQm9yZGVyQ29sb3I7XG5cbiAgICAgIHRoaXMuaGFzQ29udHJvbHMgPSB0aGlzLnNlbGVjdGFibGUgPSBmYWxzZTtcbiAgICAgIHRoaXMubG9ja01vdmVtZW50WCA9IHRoaXMubG9ja01vdmVtZW50WSA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZVRleHRhcmVhOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5oaWRkZW5UZXh0YXJlYSB8fCB0aGlzLmluQ29tcG9zaXRpb25Nb2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUgPSB7IH07XG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnZhbHVlID0gdGhpcy50ZXh0O1xuICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvbkVuZCA9IHRoaXMuc2VsZWN0aW9uRW5kO1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX2NhbGNUZXh0YXJlYVBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc3R5bGUubGVmdCA9IHN0eWxlLmxlZnQ7XG4gICAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc3R5bGUudG9wID0gc3R5bGUudG9wO1xuICAgICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnN0eWxlLmZvbnRTaXplID0gc3R5bGUuZm9udFNpemU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBzdHlsZSBjb250YWlucyBzdHlsZSBmb3IgaGlkZGVuVGV4dGFyZWFcbiAgICAgKi9cbiAgICBfY2FsY1RleHRhcmVhUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgICByZXR1cm4geyB4OiAxLCB5OiAxIH07XG4gICAgICB9XG4gICAgICB2YXIgY2hhcnMgPSB0aGlzLnRleHQuc3BsaXQoJycpLFxuICAgICAgICAgIGJvdW5kYXJpZXMgPSB0aGlzLl9nZXRDdXJzb3JCb3VuZGFyaWVzKGNoYXJzLCAnY3Vyc29yJyksXG4gICAgICAgICAgY3Vyc29yTG9jYXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oKSxcbiAgICAgICAgICBsaW5lSW5kZXggPSBjdXJzb3JMb2NhdGlvbi5saW5lSW5kZXgsXG4gICAgICAgICAgY2hhckluZGV4ID0gY3Vyc29yTG9jYXRpb24uY2hhckluZGV4LFxuICAgICAgICAgIGNoYXJIZWlnaHQgPSB0aGlzLmdldEN1cnJlbnRDaGFyRm9udFNpemUobGluZUluZGV4LCBjaGFySW5kZXgpLFxuICAgICAgICAgIGxlZnRPZmZzZXQgPSAobGluZUluZGV4ID09PSAwICYmIGNoYXJJbmRleCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldCh0aGlzLl9nZXRMaW5lV2lkdGgodGhpcy5jdHgsIGxpbmVJbmRleCkpXG4gICAgICAgICAgICAgICAgICAgIDogYm91bmRhcmllcy5sZWZ0T2Zmc2V0LFxuICAgICAgICAgIG0gPSB0aGlzLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSxcbiAgICAgICAgICBwID0ge1xuICAgICAgICAgICAgeDogYm91bmRhcmllcy5sZWZ0ICsgbGVmdE9mZnNldCxcbiAgICAgICAgICAgIHk6IGJvdW5kYXJpZXMudG9wICsgYm91bmRhcmllcy50b3BPZmZzZXQgKyBjaGFySGVpZ2h0XG4gICAgICAgICAgfSxcbiAgICAgICAgICB1cHBlckNhbnZhcyA9IHRoaXMuY2FudmFzLnVwcGVyQ2FudmFzRWwsXG4gICAgICAgICAgbWF4V2lkdGggPSB1cHBlckNhbnZhcy53aWR0aCAtIGNoYXJIZWlnaHQsXG4gICAgICAgICAgbWF4SGVpZ2h0ID0gdXBwZXJDYW52YXMuaGVpZ2h0IC0gY2hhckhlaWdodDtcblxuICAgICAgcCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHAsIG0pO1xuICAgICAgcCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHAsIHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtKTtcblxuICAgICAgaWYgKHAueCA8IDApIHtcbiAgICAgICAgcC54ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChwLnggPiBtYXhXaWR0aCkge1xuICAgICAgICBwLnggPSBtYXhXaWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChwLnkgPCAwKSB7XG4gICAgICAgIHAueSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAocC55ID4gbWF4SGVpZ2h0KSB7XG4gICAgICAgIHAueSA9IG1heEhlaWdodDtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIGNhbnZhcyBvZmZzZXQgb24gZG9jdW1lbnRcbiAgICAgIHAueCArPSB0aGlzLmNhbnZhcy5fb2Zmc2V0LmxlZnQ7XG4gICAgICBwLnkgKz0gdGhpcy5jYW52YXMuX29mZnNldC50b3A7XG5cbiAgICAgIHJldHVybiB7IGxlZnQ6IHAueCArICdweCcsIHRvcDogcC55ICsgJ3B4JywgZm9udFNpemU6IGNoYXJIZWlnaHQgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2F2ZUVkaXRpbmdQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9zYXZlZFByb3BzID0ge1xuICAgICAgICBoYXNDb250cm9sczogdGhpcy5oYXNDb250cm9scyxcbiAgICAgICAgYm9yZGVyQ29sb3I6IHRoaXMuYm9yZGVyQ29sb3IsXG4gICAgICAgIGxvY2tNb3ZlbWVudFg6IHRoaXMubG9ja01vdmVtZW50WCxcbiAgICAgICAgbG9ja01vdmVtZW50WTogdGhpcy5sb2NrTW92ZW1lbnRZLFxuICAgICAgICBob3ZlckN1cnNvcjogdGhpcy5ob3ZlckN1cnNvcixcbiAgICAgICAgZGVmYXVsdEN1cnNvcjogdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuZGVmYXVsdEN1cnNvcixcbiAgICAgICAgbW92ZUN1cnNvcjogdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMubW92ZUN1cnNvclxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVzdG9yZUVkaXRpbmdQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuX3NhdmVkUHJvcHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhvdmVyQ3Vyc29yID0gdGhpcy5fc2F2ZWRQcm9wcy5vdmVyQ3Vyc29yO1xuICAgICAgdGhpcy5oYXNDb250cm9scyA9IHRoaXMuX3NhdmVkUHJvcHMuaGFzQ29udHJvbHM7XG4gICAgICB0aGlzLmJvcmRlckNvbG9yID0gdGhpcy5fc2F2ZWRQcm9wcy5ib3JkZXJDb2xvcjtcbiAgICAgIHRoaXMubG9ja01vdmVtZW50WCA9IHRoaXMuX3NhdmVkUHJvcHMubG9ja01vdmVtZW50WDtcbiAgICAgIHRoaXMubG9ja01vdmVtZW50WSA9IHRoaXMuX3NhdmVkUHJvcHMubG9ja01vdmVtZW50WTtcblxuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmRlZmF1bHRDdXJzb3IgPSB0aGlzLl9zYXZlZFByb3BzLmRlZmF1bHRDdXJzb3I7XG4gICAgICAgIHRoaXMuY2FudmFzLm1vdmVDdXJzb3IgPSB0aGlzLl9zYXZlZFByb3BzLm1vdmVDdXJzb3I7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4aXRzIGZyb20gZWRpdGluZyBzdGF0ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBleGl0RWRpdGluZzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXNUZXh0Q2hhbmdlZCA9ICh0aGlzLl90ZXh0QmVmb3JlRWRpdCAhPT0gdGhpcy50ZXh0KTtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICB0aGlzLnNlbGVjdGFibGUgPSB0cnVlO1xuXG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhLmJsdXIgJiYgdGhpcy5oaWRkZW5UZXh0YXJlYS5ibHVyKCk7XG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhICYmIHRoaXMuY2FudmFzICYmIHRoaXMuaGlkZGVuVGV4dGFyZWEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmhpZGRlblRleHRhcmVhKTtcbiAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEgPSBudWxsO1xuXG4gICAgICB0aGlzLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCk7XG4gICAgICB0aGlzLl9yZXN0b3JlRWRpdGluZ1Byb3BzKCk7XG4gICAgICB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eSA9IDA7XG5cbiAgICAgIHRoaXMuZmlyZSgnZWRpdGluZzpleGl0ZWQnKTtcbiAgICAgIGlzVGV4dENoYW5nZWQgJiYgdGhpcy5maXJlKCdtb2RpZmllZCcpO1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLm9mZignbW91c2U6bW92ZScsIHRoaXMubW91c2VNb3ZlSGFuZGxlcik7XG4gICAgICAgIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6ZWRpdGluZzpleGl0ZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgICAgaXNUZXh0Q2hhbmdlZCAmJiB0aGlzLmNhbnZhcy5maXJlKCdvYmplY3Q6bW9kaWZpZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbW92ZUV4dHJhbmVvdXNTdHlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzLnN0eWxlcykge1xuICAgICAgICBpZiAoIXRoaXMuX3RleHRMaW5lc1twcm9wXSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmVDaGFyc0Zyb21UbzogZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgd2hpbGUgKGVuZCAhPT0gc3RhcnQpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU2luZ2xlQ2hhckFuZFN0eWxlKHN0YXJ0ICsgMSk7XG4gICAgICAgIGVuZC0tO1xuICAgICAgfVxuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBzdGFydDtcbiAgICB9LFxuXG4gICAgX3JlbW92ZVNpbmdsZUNoYXJBbmRTdHlsZTogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIHZhciBpc0JlZ2lubmluZ09mTGluZSA9IHRoaXMudGV4dFtpbmRleCAtIDFdID09PSAnXFxuJyxcbiAgICAgICAgICBpbmRleFN0eWxlICAgICAgICA9IGlzQmVnaW5uaW5nT2ZMaW5lID8gaW5kZXggOiBpbmRleCAtIDE7XG4gICAgICB0aGlzLnJlbW92ZVN0eWxlT2JqZWN0KGlzQmVnaW5uaW5nT2ZMaW5lLCBpbmRleFN0eWxlKTtcbiAgICAgIHRoaXMudGV4dCA9IHRoaXMudGV4dC5zbGljZSgwLCBpbmRleCAtIDEpICtcbiAgICAgICAgdGhpcy50ZXh0LnNsaWNlKGluZGV4KTtcblxuICAgICAgdGhpcy5fdGV4dExpbmVzID0gdGhpcy5fc3BsaXRUZXh0SW50b0xpbmVzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgY2hhcmFjdGVycyB3aGVyZSBjdXJzb3IgaXMgKHJlcGxhY2luZyBzZWxlY3Rpb24gaWYgb25lIGV4aXN0cylcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gX2NoYXJzIENoYXJhY3RlcnMgdG8gaW5zZXJ0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSB1c2VDb3BpZWRTdHlsZSB1c2UgZmFicmljLmNvcGllZFRleHRTdHlsZVxuICAgICAqL1xuICAgIGluc2VydENoYXJzOiBmdW5jdGlvbihfY2hhcnMsIHVzZUNvcGllZFN0eWxlKSB7XG4gICAgICB2YXIgc3R5bGU7XG5cbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbkVuZCAtIHRoaXMuc2VsZWN0aW9uU3RhcnQgPiAxKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUNoYXJzRnJvbVRvKHRoaXMuc2VsZWN0aW9uU3RhcnQsIHRoaXMuc2VsZWN0aW9uRW5kKTtcbiAgICAgIH1cbiAgICAgIC8vc2hvcnQgY2lyY3VpdCBmb3IgYmxvY2sgcGFzdGVcbiAgICAgIGlmICghdXNlQ29waWVkU3R5bGUgJiYgdGhpcy5pc0VtcHR5U3R5bGVzKCkpIHtcbiAgICAgICAgdGhpcy5pbnNlcnRDaGFyKF9jaGFycywgZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gX2NoYXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh1c2VDb3BpZWRTdHlsZSkge1xuICAgICAgICAgIHN0eWxlID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKGZhYnJpYy5jb3BpZWRUZXh0U3R5bGVbaV0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5zZXJ0Q2hhcihfY2hhcnNbaV0sIGkgPCBsZW4gLSAxLCBzdHlsZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBjaGFyYWN0ZXIgd2hlcmUgY3Vyc29yIGlzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IF9jaGFyIENoYXJhY3RlcnMgdG8gaW5zZXJ0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBza2lwVXBkYXRlIHRyaWdnZXIgcmVuZGVyaW5nIGFuZCB1cGRhdGVzIGF0IHRoZSBlbmQgb2YgdGV4dCBpbnNlcnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVPYmplY3QgU3R5bGUgdG8gYmUgaW5zZXJ0ZWQgZm9yIHRoZSBuZXcgY2hhclxuICAgICAqL1xuICAgIGluc2VydENoYXI6IGZ1bmN0aW9uKF9jaGFyLCBza2lwVXBkYXRlLCBzdHlsZU9iamVjdCkge1xuICAgICAgdmFyIGlzRW5kT2ZMaW5lID0gdGhpcy50ZXh0W3RoaXMuc2VsZWN0aW9uU3RhcnRdID09PSAnXFxuJztcbiAgICAgIHRoaXMudGV4dCA9IHRoaXMudGV4dC5zbGljZSgwLCB0aGlzLnNlbGVjdGlvblN0YXJ0KSArXG4gICAgICAgIF9jaGFyICsgdGhpcy50ZXh0LnNsaWNlKHRoaXMuc2VsZWN0aW9uRW5kKTtcbiAgICAgIHRoaXMuX3RleHRMaW5lcyA9IHRoaXMuX3NwbGl0VGV4dEludG9MaW5lcygpO1xuICAgICAgdGhpcy5pbnNlcnRTdHlsZU9iamVjdHMoX2NoYXIsIGlzRW5kT2ZMaW5lLCBzdHlsZU9iamVjdCk7XG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ICs9IF9jaGFyLmxlbmd0aDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgIGlmIChza2lwVXBkYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIHRoaXMuZmlyZSgnY2hhbmdlZCcpO1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuZmlyZSgndGV4dDpjaGFuZ2VkJywgeyB0YXJnZXQ6IHRoaXMgfSk7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBuZXcgc3R5bGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBJbmRleCBvZiBhIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4IEluZGV4IG9mIGEgY2hhclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNFbmRPZkxpbmUgVHJ1ZSBpZiBpdCdzIGVuZCBvZiBsaW5lXG4gICAgICovXG4gICAgaW5zZXJ0TmV3bGluZVN0eWxlT2JqZWN0OiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgaXNFbmRPZkxpbmUpIHtcblxuICAgICAgdGhpcy5zaGlmdExpbmVTdHlsZXMobGluZUluZGV4LCArMSk7XG5cbiAgICAgIGlmICghdGhpcy5zdHlsZXNbbGluZUluZGV4ICsgMV0pIHtcbiAgICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4ICsgMV0gPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnRDaGFyU3R5bGUgPSB7fSxcbiAgICAgICAgICBuZXdMaW5lU3R5bGVzICAgID0ge307XG5cbiAgICAgIGlmICh0aGlzLnN0eWxlc1tsaW5lSW5kZXhdICYmIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4IC0gMV0pIHtcbiAgICAgICAgY3VycmVudENoYXJTdHlsZSA9IHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4IC0gMV07XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBhZnRlciBjdXJzb3IsXG4gICAgICAvLyB3ZSBjbG9uZSBjdXJyZW50IGNoYXIgc3R5bGUgb250byB0aGUgbmV4dCAob3RoZXJ3aXNlIGVtcHR5KSBsaW5lXG4gICAgICBpZiAoaXNFbmRPZkxpbmUpIHtcbiAgICAgICAgbmV3TGluZVN0eWxlc1swXSA9IGNsb25lKGN1cnJlbnRDaGFyU3R5bGUpO1xuICAgICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXggKyAxXSA9IG5ld0xpbmVTdHlsZXM7XG4gICAgICB9XG4gICAgICAvLyBvdGhlcndpc2Ugd2UgY2xvbmUgc3R5bGVzIG9mIGFsbCBjaGFyc1xuICAgICAgLy8gYWZ0ZXIgY3Vyc29yIG9udG8gdGhlIG5leHQgbGluZSwgZnJvbSB0aGUgYmVnaW5uaW5nXG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggaW4gdGhpcy5zdHlsZXNbbGluZUluZGV4XSkge1xuICAgICAgICAgIGlmIChwYXJzZUludChpbmRleCwgMTApID49IGNoYXJJbmRleCkge1xuICAgICAgICAgICAgbmV3TGluZVN0eWxlc1twYXJzZUludChpbmRleCwgMTApIC0gY2hhckluZGV4XSA9IHRoaXMuc3R5bGVzW2xpbmVJbmRleF1baW5kZXhdO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGxpbmVzIGZyb20gdGhlIHByZXZpb3VzIGxpbmUgc2luY2UgdGhleSdyZSBvbiBhIG5ldyBsaW5lIG5vd1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1baW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXggKyAxXSA9IG5ld0xpbmVTdHlsZXM7XG4gICAgICB9XG4gICAgICB0aGlzLl9mb3JjZUNsZWFyQ2FjaGUgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIHN0eWxlIG9iamVjdCBmb3IgYSBnaXZlbiBsaW5lL2NoYXIgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IEluZGV4IG9mIGEgbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXggSW5kZXggb2YgYSBjaGFyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZV0gU3R5bGUgb2JqZWN0IHRvIGluc2VydCwgaWYgZ2l2ZW5cbiAgICAgKi9cbiAgICBpbnNlcnRDaGFyU3R5bGVPYmplY3Q6IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4LCBzdHlsZSkge1xuXG4gICAgICB2YXIgY3VycmVudExpbmVTdHlsZXMgICAgICAgPSB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdLFxuICAgICAgICAgIGN1cnJlbnRMaW5lU3R5bGVzQ2xvbmVkID0gY2xvbmUoY3VycmVudExpbmVTdHlsZXMpO1xuXG4gICAgICBpZiAoY2hhckluZGV4ID09PSAwICYmICFzdHlsZSkge1xuICAgICAgICBjaGFySW5kZXggPSAxO1xuICAgICAgfVxuXG4gICAgICAvLyBzaGlmdCBhbGwgY2hhciBzdHlsZXMgYnkgMSBmb3J3YXJkXG4gICAgICAvLyAwLDEsMiwzIC0+IChjaGFySW5kZXg9MikgLT4gMCwxLDMsNCAtPiAoaW5zZXJ0IDIpIC0+IDAsMSwyLDMsNFxuICAgICAgZm9yICh2YXIgaW5kZXggaW4gY3VycmVudExpbmVTdHlsZXNDbG9uZWQpIHtcbiAgICAgICAgdmFyIG51bWVyaWNJbmRleCA9IHBhcnNlSW50KGluZGV4LCAxMCk7XG5cbiAgICAgICAgaWYgKG51bWVyaWNJbmRleCA+PSBjaGFySW5kZXgpIHtcbiAgICAgICAgICBjdXJyZW50TGluZVN0eWxlc1tudW1lcmljSW5kZXggKyAxXSA9IGN1cnJlbnRMaW5lU3R5bGVzQ2xvbmVkW251bWVyaWNJbmRleF07XG5cbiAgICAgICAgICAvLyBvbmx5IGRlbGV0ZSB0aGUgc3R5bGUgaWYgdGhlcmUgd2FzIG5vdGhpbmcgbW92ZWQgdGhlcmVcbiAgICAgICAgICBpZiAoIWN1cnJlbnRMaW5lU3R5bGVzQ2xvbmVkW251bWVyaWNJbmRleCAtIDFdKSB7XG4gICAgICAgICAgICBkZWxldGUgY3VycmVudExpbmVTdHlsZXNbbnVtZXJpY0luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXhdID1cbiAgICAgICAgc3R5bGUgfHwgY2xvbmUoY3VycmVudExpbmVTdHlsZXNbY2hhckluZGV4IC0gMV0pO1xuICAgICAgdGhpcy5fZm9yY2VDbGVhckNhY2hlID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBzdHlsZSBvYmplY3QocylcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gX2NoYXJzIENoYXJhY3RlcnMgYXQgdGhlIGxvY2F0aW9uIHdoZXJlIHN0eWxlIGlzIGluc2VydGVkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc0VuZE9mTGluZSBUcnVlIGlmIGl0J3MgZW5kIG9mIGxpbmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0eWxlT2JqZWN0XSBTdHlsZSB0byBpbnNlcnRcbiAgICAgKi9cbiAgICBpbnNlcnRTdHlsZU9iamVjdHM6IGZ1bmN0aW9uKF9jaGFycywgaXNFbmRPZkxpbmUsIHN0eWxlT2JqZWN0KSB7XG4gICAgICAvLyByZW1vdmVkIHNob3J0Y2lyY3VpdCBvdmVyIGlzRW1wdHlTdHlsZXNcblxuICAgICAgdmFyIGN1cnNvckxvY2F0aW9uID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKCksXG4gICAgICAgICAgbGluZUluZGV4ICAgICAgPSBjdXJzb3JMb2NhdGlvbi5saW5lSW5kZXgsXG4gICAgICAgICAgY2hhckluZGV4ICAgICAgPSBjdXJzb3JMb2NhdGlvbi5jaGFySW5kZXg7XG5cbiAgICAgIGlmICghdGhpcy5fZ2V0TGluZVN0eWxlKGxpbmVJbmRleCkpIHtcbiAgICAgICAgdGhpcy5fc2V0TGluZVN0eWxlKGxpbmVJbmRleCwge30pO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2NoYXJzID09PSAnXFxuJykge1xuICAgICAgICB0aGlzLmluc2VydE5ld2xpbmVTdHlsZU9iamVjdChsaW5lSW5kZXgsIGNoYXJJbmRleCwgaXNFbmRPZkxpbmUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0Q2hhclN0eWxlT2JqZWN0KGxpbmVJbmRleCwgY2hhckluZGV4LCBzdHlsZU9iamVjdCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNoaWZ0cyBsaW5lIHN0eWxlcyB1cCBvciBkb3duXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBJbmRleCBvZiBhIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IENhbiBiZSAtMSBvciArMVxuICAgICAqL1xuICAgIHNoaWZ0TGluZVN0eWxlczogZnVuY3Rpb24obGluZUluZGV4LCBvZmZzZXQpIHtcbiAgICAgIC8vIHNoaWZ0IGFsbCBsaW5lIHN0eWxlcyBieSAxIHVwd2FyZFxuICAgICAgdmFyIGNsb25lZFN0eWxlcyA9IGNsb25lKHRoaXMuc3R5bGVzKTtcbiAgICAgIGZvciAodmFyIGxpbmUgaW4gdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgdmFyIG51bWVyaWNMaW5lID0gcGFyc2VJbnQobGluZSwgMTApO1xuICAgICAgICBpZiAobnVtZXJpY0xpbmUgPiBsaW5lSW5kZXgpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlc1tudW1lcmljTGluZSArIG9mZnNldF0gPSBjbG9uZWRTdHlsZXNbbnVtZXJpY0xpbmVdO1xuICAgICAgICAgIGlmICghY2xvbmVkU3R5bGVzW251bWVyaWNMaW5lIC0gb2Zmc2V0XSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW251bWVyaWNMaW5lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vVE9ETzogZXZhbHVhdGUgaWYgZGVsZXRlIG9sZCBzdHlsZSBsaW5lcyB3aXRoIG9mZnNldCAtMVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHN0eWxlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNCZWdpbm5pbmdPZkxpbmUgVHJ1ZSBpZiBjdXJzb3IgaXMgYXQgdGhlIGJlZ2lubmluZyBvZiBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleF0gT3B0aW9uYWwgaW5kZXguIFdoZW4gbm90IGdpdmVuLCBjdXJyZW50IHNlbGVjdGlvblN0YXJ0IGlzIHVzZWQuXG4gICAgICovXG4gICAgcmVtb3ZlU3R5bGVPYmplY3Q6IGZ1bmN0aW9uKGlzQmVnaW5uaW5nT2ZMaW5lLCBpbmRleCkge1xuXG4gICAgICB2YXIgY3Vyc29yTG9jYXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oaW5kZXgpLFxuICAgICAgICAgIGxpbmVJbmRleCAgICAgID0gY3Vyc29yTG9jYXRpb24ubGluZUluZGV4LFxuICAgICAgICAgIGNoYXJJbmRleCAgICAgID0gY3Vyc29yTG9jYXRpb24uY2hhckluZGV4O1xuXG4gICAgICB0aGlzLl9yZW1vdmVTdHlsZU9iamVjdChpc0JlZ2lubmluZ09mTGluZSwgY3Vyc29yTG9jYXRpb24sIGxpbmVJbmRleCwgY2hhckluZGV4KTtcbiAgICB9LFxuXG4gICAgX2dldFRleHRPblByZXZpb3VzTGluZTogZnVuY3Rpb24obEluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGV4dExpbmVzW2xJbmRleCAtIDFdO1xuICAgIH0sXG5cbiAgICBfcmVtb3ZlU3R5bGVPYmplY3Q6IGZ1bmN0aW9uKGlzQmVnaW5uaW5nT2ZMaW5lLCBjdXJzb3JMb2NhdGlvbiwgbGluZUluZGV4LCBjaGFySW5kZXgpIHtcblxuICAgICAgaWYgKGlzQmVnaW5uaW5nT2ZMaW5lKSB7XG4gICAgICAgIHZhciB0ZXh0T25QcmV2aW91c0xpbmUgICAgID0gdGhpcy5fZ2V0VGV4dE9uUHJldmlvdXNMaW5lKGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleCksXG4gICAgICAgICAgICBuZXdDaGFySW5kZXhPblByZXZMaW5lID0gdGV4dE9uUHJldmlvdXNMaW5lID8gdGV4dE9uUHJldmlvdXNMaW5lLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgaWYgKCF0aGlzLnN0eWxlc1tsaW5lSW5kZXggLSAxXSkge1xuICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleCAtIDFdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjaGFySW5kZXggaW4gdGhpcy5zdHlsZXNbbGluZUluZGV4XSkge1xuICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleCAtIDFdW3BhcnNlSW50KGNoYXJJbmRleCwgMTApICsgbmV3Q2hhckluZGV4T25QcmV2TGluZV1cbiAgICAgICAgICAgID0gdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hpZnRMaW5lU3R5bGVzKGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleCwgLTEpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBjdXJyZW50TGluZVN0eWxlcyA9IHRoaXMuc3R5bGVzW2xpbmVJbmRleF07XG5cbiAgICAgICAgaWYgKGN1cnJlbnRMaW5lU3R5bGVzKSB7XG4gICAgICAgICAgZGVsZXRlIGN1cnJlbnRMaW5lU3R5bGVzW2NoYXJJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnRMaW5lU3R5bGVzQ2xvbmVkID0gY2xvbmUoY3VycmVudExpbmVTdHlsZXMpO1xuICAgICAgICAvLyBzaGlmdCBhbGwgc3R5bGVzIGJ5IDEgYmFja3dhcmRzXG4gICAgICAgIGZvciAodmFyIGkgaW4gY3VycmVudExpbmVTdHlsZXNDbG9uZWQpIHtcbiAgICAgICAgICB2YXIgbnVtZXJpY0luZGV4ID0gcGFyc2VJbnQoaSwgMTApO1xuICAgICAgICAgIGlmIChudW1lcmljSW5kZXggPj0gY2hhckluZGV4ICYmIG51bWVyaWNJbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgY3VycmVudExpbmVTdHlsZXNbbnVtZXJpY0luZGV4IC0gMV0gPSBjdXJyZW50TGluZVN0eWxlc0Nsb25lZFtudW1lcmljSW5kZXhdO1xuICAgICAgICAgICAgZGVsZXRlIGN1cnJlbnRMaW5lU3R5bGVzW251bWVyaWNJbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgbmV3IGxpbmVcbiAgICAgKi9cbiAgICBpbnNlcnROZXdsaW5lOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaW5zZXJ0Q2hhcnMoJ1xcbicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHNlbGVjdGlvblN0YXJ0IGFuZCBzZWxlY3Rpb25FbmQgYWNjb3JkaW5nIHRvIHRoZSBuZSBwb3N0aW9uIG9mIGN1cnNvclxuICAgICAqIG1pbWljIHRoZSBrZXkgLSBtb3VzZSBuYXZpZ2F0aW9uIHdoZW4gc2hpZnQgaXMgcHJlc3NlZC5cbiAgICAgKi9cbiAgICBzZXRTZWxlY3Rpb25TdGFydEVuZFdpdGhTaGlmdDogZnVuY3Rpb24oc3RhcnQsIGVuZCwgbmV3U2VsZWN0aW9uKSB7XG4gICAgICBpZiAobmV3U2VsZWN0aW9uIDw9IHN0YXJ0KSB7XG4gICAgICAgIGlmIChlbmQgPT09IHN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb247XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChuZXdTZWxlY3Rpb24gPiBzdGFydCAmJiBuZXdTZWxlY3Rpb24gPCBlbmQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbmV3U2VsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBuZXdTZWxlY3Rpb24gaXMgPiBzZWxlY3Rpb24gc3RhcnQgYW5kIGVuZFxuICAgICAgICBpZiAoZW5kID09PSBzdGFydCkge1xuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAncmlnaHQnO1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb247XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNldFNlbGVjdGlvbkluQm91bmRhcmllczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID4gbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0IDwgMCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbkVuZCA+IGxlbmd0aCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uRW5kIDwgMCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuSVRleHQucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5JVGV4dC5wcm90b3R5cGUgKi8ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgXCJkYmNsaWNrXCIgZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgaW5pdERvdWJsZUNsaWNrU2ltdWxhdGlvbjogZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBmb3IgZG91YmxlIGNsaWNrXG4gICAgdGhpcy5fX2xhc3RDbGlja1RpbWUgPSArbmV3IERhdGUoKTtcblxuICAgIC8vIGZvciB0cmlwbGUgY2xpY2tcbiAgICB0aGlzLl9fbGFzdExhc3RDbGlja1RpbWUgPSArbmV3IERhdGUoKTtcblxuICAgIHRoaXMuX19sYXN0UG9pbnRlciA9IHsgfTtcblxuICAgIHRoaXMub24oJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gIH0sXG5cbiAgb25Nb3VzZURvd246IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuICAgIHRoaXMuX19uZXdDbGlja1RpbWUgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbmV3UG9pbnRlciA9IHRoaXMuY2FudmFzLmdldFBvaW50ZXIob3B0aW9ucy5lKTtcblxuICAgIGlmICh0aGlzLmlzVHJpcGxlQ2xpY2sobmV3UG9pbnRlcikpIHtcbiAgICAgIHRoaXMuZmlyZSgndHJpcGxlY2xpY2snLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX3N0b3BFdmVudChvcHRpb25zLmUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmlzRG91YmxlQ2xpY2sobmV3UG9pbnRlcikpIHtcbiAgICAgIHRoaXMuZmlyZSgnZGJsY2xpY2snLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX3N0b3BFdmVudChvcHRpb25zLmUpO1xuICAgIH1cblxuICAgIHRoaXMuX19sYXN0TGFzdENsaWNrVGltZSA9IHRoaXMuX19sYXN0Q2xpY2tUaW1lO1xuICAgIHRoaXMuX19sYXN0Q2xpY2tUaW1lID0gdGhpcy5fX25ld0NsaWNrVGltZTtcbiAgICB0aGlzLl9fbGFzdFBvaW50ZXIgPSBuZXdQb2ludGVyO1xuICAgIHRoaXMuX19sYXN0SXNFZGl0aW5nID0gdGhpcy5pc0VkaXRpbmc7XG4gICAgdGhpcy5fX2xhc3RTZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWQ7XG4gIH0sXG5cbiAgaXNEb3VibGVDbGljazogZnVuY3Rpb24obmV3UG9pbnRlcikge1xuICAgIHJldHVybiB0aGlzLl9fbmV3Q2xpY2tUaW1lIC0gdGhpcy5fX2xhc3RDbGlja1RpbWUgPCA1MDAgJiZcbiAgICAgICAgdGhpcy5fX2xhc3RQb2ludGVyLnggPT09IG5ld1BvaW50ZXIueCAmJlxuICAgICAgICB0aGlzLl9fbGFzdFBvaW50ZXIueSA9PT0gbmV3UG9pbnRlci55ICYmIHRoaXMuX19sYXN0SXNFZGl0aW5nO1xuICB9LFxuXG4gIGlzVHJpcGxlQ2xpY2s6IGZ1bmN0aW9uKG5ld1BvaW50ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fX25ld0NsaWNrVGltZSAtIHRoaXMuX19sYXN0Q2xpY2tUaW1lIDwgNTAwICYmXG4gICAgICAgIHRoaXMuX19sYXN0Q2xpY2tUaW1lIC0gdGhpcy5fX2xhc3RMYXN0Q2xpY2tUaW1lIDwgNTAwICYmXG4gICAgICAgIHRoaXMuX19sYXN0UG9pbnRlci54ID09PSBuZXdQb2ludGVyLnggJiZcbiAgICAgICAgdGhpcy5fX2xhc3RQb2ludGVyLnkgPT09IG5ld1BvaW50ZXIueTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zdG9wRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0ICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbiAmJiBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBldmVudCBoYW5kbGVycyByZWxhdGVkIHRvIGN1cnNvciBvciBzZWxlY3Rpb25cbiAgICovXG4gIGluaXRDdXJzb3JTZWxlY3Rpb25IYW5kbGVyczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbml0U2VsZWN0ZWRIYW5kbGVyKCk7XG4gICAgdGhpcy5pbml0TW91c2Vkb3duSGFuZGxlcigpO1xuICAgIHRoaXMuaW5pdE1vdXNldXBIYW5kbGVyKCk7XG4gICAgdGhpcy5pbml0Q2xpY2tzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGRvdWJsZSBhbmQgdHJpcGxlIGNsaWNrIGV2ZW50IGhhbmRsZXJzXG4gICAqL1xuICBpbml0Q2xpY2tzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9uKCdkYmxjbGljaycsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc2VsZWN0V29yZCh0aGlzLmdldFNlbGVjdGlvblN0YXJ0RnJvbVBvaW50ZXIob3B0aW9ucy5lKSk7XG4gICAgfSk7XG4gICAgdGhpcy5vbigndHJpcGxlY2xpY2snLCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLnNlbGVjdExpbmUodGhpcy5nZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyKG9wdGlvbnMuZSkpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBcIm1vdXNlZG93blwiIGV2ZW50IGhhbmRsZXJcbiAgICovXG4gIGluaXRNb3VzZWRvd25IYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoIXRoaXMuZWRpdGFibGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmNhbnZhcy5nZXRQb2ludGVyKG9wdGlvbnMuZSk7XG5cbiAgICAgIHRoaXMuX19tb3VzZWRvd25YID0gcG9pbnRlci54O1xuICAgICAgdGhpcy5fX21vdXNlZG93blkgPSBwb2ludGVyLnk7XG4gICAgICB0aGlzLl9faXNNb3VzZWRvd24gPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgICB0aGlzLnNldEN1cnNvckJ5Q2xpY2sob3B0aW9ucy5lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICAgIHRoaXMuX19zZWxlY3Rpb25TdGFydE9uTW91c2VEb3duID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgdGhpcy5hYm9ydEN1cnNvckFuaW1hdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pc09iamVjdE1vdmVkOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHBvaW50ZXIgPSB0aGlzLmNhbnZhcy5nZXRQb2ludGVyKGUpO1xuXG4gICAgcmV0dXJuIHRoaXMuX19tb3VzZWRvd25YICE9PSBwb2ludGVyLnggfHxcbiAgICAgICAgICAgdGhpcy5fX21vdXNlZG93blkgIT09IHBvaW50ZXIueTtcbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgXCJtb3VzZXVwXCIgZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgaW5pdE1vdXNldXBIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9uKCdtb3VzZXVwJywgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5fX2lzTW91c2Vkb3duID0gZmFsc2U7XG4gICAgICBpZiAoIXRoaXMuZWRpdGFibGUgfHwgdGhpcy5faXNPYmplY3RNb3ZlZChvcHRpb25zLmUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX19sYXN0U2VsZWN0ZWQgJiYgIXRoaXMuX19jb3JuZXIpIHtcbiAgICAgICAgdGhpcy5lbnRlckVkaXRpbmcob3B0aW9ucy5lKTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgdGhpcy5pbml0RGVsYXllZEN1cnNvcih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIGN1cnNvciBsb2NhdGlvbiBpbiBhIHRleHQgZGVwZW5kaW5nIG9uIHBhc3NlZCBwb2ludGVyICh4L3kpIG9iamVjdFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgc2V0Q3Vyc29yQnlDbGljazogZnVuY3Rpb24oZSkge1xuICAgIHZhciBuZXdTZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvblN0YXJ0RnJvbVBvaW50ZXIoZSksXG4gICAgICAgIHN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25TdGFydCwgZW5kID0gdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uU3RhcnRFbmRXaXRoU2hpZnQoc3RhcnQsIGVuZCwgbmV3U2VsZWN0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uO1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb247XG4gICAgfVxuICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBpbmRleCBvZiBhIGNoYXJhY3RlciBjb3JyZXNwb25kaW5nIHRvIHdoZXJlIGFuIG9iamVjdCB3YXMgY2xpY2tlZFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEluZGV4IG9mIGEgY2hhcmFjdGVyXG4gICAqL1xuICBnZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIG1vdXNlT2Zmc2V0ID0gdGhpcy5nZXRMb2NhbFBvaW50ZXIoZSksXG4gICAgICAgIHByZXZXaWR0aCA9IDAsXG4gICAgICAgIHdpZHRoID0gMCxcbiAgICAgICAgaGVpZ2h0ID0gMCxcbiAgICAgICAgY2hhckluZGV4ID0gMCxcbiAgICAgICAgbmV3U2VsZWN0aW9uU3RhcnQsXG4gICAgICAgIGxpbmU7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2ldO1xuICAgICAgaGVpZ2h0ICs9IHRoaXMuX2dldEhlaWdodE9mTGluZSh0aGlzLmN0eCwgaSkgKiB0aGlzLnNjYWxlWTtcblxuICAgICAgdmFyIHdpZHRoT2ZMaW5lID0gdGhpcy5fZ2V0TGluZVdpZHRoKHRoaXMuY3R4LCBpKSxcbiAgICAgICAgICBsaW5lTGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KHdpZHRoT2ZMaW5lKTtcblxuICAgICAgd2lkdGggPSBsaW5lTGVmdE9mZnNldCAqIHRoaXMuc2NhbGVYO1xuXG4gICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGxpbmUubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG5cbiAgICAgICAgcHJldldpZHRoID0gd2lkdGg7XG5cbiAgICAgICAgd2lkdGggKz0gdGhpcy5fZ2V0V2lkdGhPZkNoYXIodGhpcy5jdHgsIGxpbmVbal0sIGksIHRoaXMuZmxpcFggPyBqbGVuIC0gaiA6IGopICpcbiAgICAgICAgICAgICAgICAgdGhpcy5zY2FsZVg7XG5cbiAgICAgICAgaWYgKGhlaWdodCA8PSBtb3VzZU9mZnNldC55IHx8IHdpZHRoIDw9IG1vdXNlT2Zmc2V0LngpIHtcbiAgICAgICAgICBjaGFySW5kZXgrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXROZXdTZWxlY3Rpb25TdGFydEZyb21PZmZzZXQoXG4gICAgICAgICAgbW91c2VPZmZzZXQsIHByZXZXaWR0aCwgd2lkdGgsIGNoYXJJbmRleCArIGksIGpsZW4pO1xuICAgICAgfVxuXG4gICAgICBpZiAobW91c2VPZmZzZXQueSA8IGhlaWdodCkge1xuICAgICAgICAvL3RoaXMgaGFwcGVucyBqdXN0IG9uIGVuZCBvZiBsaW5lcy5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE5ld1NlbGVjdGlvblN0YXJ0RnJvbU9mZnNldChcbiAgICAgICAgICBtb3VzZU9mZnNldCwgcHJldldpZHRoLCB3aWR0aCwgY2hhckluZGV4ICsgaSAtIDEsIGpsZW4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNsaWNrZWQgc29tZXdoZXJlIGFmdGVyIGFsbCBjaGFycywgc28gc2V0IGF0IHRoZSBlbmRcbiAgICBpZiAodHlwZW9mIG5ld1NlbGVjdGlvblN0YXJ0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldE5ld1NlbGVjdGlvblN0YXJ0RnJvbU9mZnNldDogZnVuY3Rpb24obW91c2VPZmZzZXQsIHByZXZXaWR0aCwgd2lkdGgsIGluZGV4LCBqbGVuKSB7XG5cbiAgICB2YXIgZGlzdGFuY2VCdHdMYXN0Q2hhckFuZEN1cnNvciA9IG1vdXNlT2Zmc2V0LnggLSBwcmV2V2lkdGgsXG4gICAgICAgIGRpc3RhbmNlQnR3TmV4dENoYXJBbmRDdXJzb3IgPSB3aWR0aCAtIG1vdXNlT2Zmc2V0LngsXG4gICAgICAgIG9mZnNldCA9IGRpc3RhbmNlQnR3TmV4dENoYXJBbmRDdXJzb3IgPiBkaXN0YW5jZUJ0d0xhc3RDaGFyQW5kQ3Vyc29yID8gMCA6IDEsXG4gICAgICAgIG5ld1NlbGVjdGlvblN0YXJ0ID0gaW5kZXggKyBvZmZzZXQ7XG5cbiAgICAvLyBpZiBvYmplY3QgaXMgaG9yaXpvbnRhbGx5IGZsaXBwZWQsIG1pcnJvciBjdXJzb3IgbG9jYXRpb24gZnJvbSB0aGUgZW5kXG4gICAgaWYgKHRoaXMuZmxpcFgpIHtcbiAgICAgIG5ld1NlbGVjdGlvblN0YXJ0ID0gamxlbiAtIG5ld1NlbGVjdGlvblN0YXJ0O1xuICAgIH1cblxuICAgIGlmIChuZXdTZWxlY3Rpb25TdGFydCA+IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgIG5ld1NlbGVjdGlvblN0YXJ0ID0gdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3U2VsZWN0aW9uU3RhcnQ7XG4gIH1cbn0pO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLklUZXh0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuSVRleHQucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgaGlkZGVuIHRleHRhcmVhIChuZWVkZWQgdG8gYnJpbmcgdXAga2V5Ym9hcmQgaW4gaU9TKVxuICAgKi9cbiAgaW5pdEhpZGRlblRleHRhcmVhOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhID0gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ2F1dG9jYXBpdGFsaXplJywgJ29mZicpO1xuICAgIHZhciBzdHlsZSA9IHRoaXMuX2NhbGNUZXh0YXJlYVBvc2l0aW9uKCk7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAnICsgc3R5bGUudG9wICsgJzsgbGVmdDogJyArIHN0eWxlLmxlZnQgKyAnOydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICcgb3BhY2l0eTogMDsgd2lkdGg6IDBweDsgaGVpZ2h0OiAwcHg7IHotaW5kZXg6IC05OTk7JztcbiAgICBmYWJyaWMuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmhpZGRlblRleHRhcmVhKTtcblxuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdrZXlkb3duJywgdGhpcy5vbktleURvd24uYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2tleXVwJywgdGhpcy5vbktleVVwLmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdpbnB1dCcsIHRoaXMub25JbnB1dC5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAnY29weScsIHRoaXMuY29weS5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAnY3V0JywgdGhpcy5jdXQuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ3Bhc3RlJywgdGhpcy5wYXN0ZS5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAnY29tcG9zaXRpb25zdGFydCcsIHRoaXMub25Db21wb3NpdGlvblN0YXJ0LmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdjb21wb3NpdGlvbnVwZGF0ZScsIHRoaXMub25Db21wb3NpdGlvblVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAnY29tcG9zaXRpb25lbmQnLCB0aGlzLm9uQ29tcG9zaXRpb25FbmQuYmluZCh0aGlzKSk7XG5cbiAgICBpZiAoIXRoaXMuX2NsaWNrSGFuZGxlckluaXRpYWxpemVkICYmIHRoaXMuY2FudmFzKSB7XG4gICAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmNhbnZhcy51cHBlckNhbnZhc0VsLCAnY2xpY2snLCB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLl9jbGlja0hhbmRsZXJJbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2tleXNNYXA6IHtcbiAgICA4OiAgJ3JlbW92ZUNoYXJzJyxcbiAgICA5OiAgJ2V4aXRFZGl0aW5nJyxcbiAgICAyNzogJ2V4aXRFZGl0aW5nJyxcbiAgICAxMzogJ2luc2VydE5ld2xpbmUnLFxuICAgIDMzOiAnbW92ZUN1cnNvclVwJyxcbiAgICAzNDogJ21vdmVDdXJzb3JEb3duJyxcbiAgICAzNTogJ21vdmVDdXJzb3JSaWdodCcsXG4gICAgMzY6ICdtb3ZlQ3Vyc29yTGVmdCcsXG4gICAgMzc6ICdtb3ZlQ3Vyc29yTGVmdCcsXG4gICAgMzg6ICdtb3ZlQ3Vyc29yVXAnLFxuICAgIDM5OiAnbW92ZUN1cnNvclJpZ2h0JyxcbiAgICA0MDogJ21vdmVDdXJzb3JEb3duJyxcbiAgICA0NjogJ2ZvcndhcmREZWxldGUnXG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3RybEtleXNNYXBVcDoge1xuICAgIDY3OiAnY29weScsXG4gICAgODg6ICdjdXQnXG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3RybEtleXNNYXBEb3duOiB7XG4gICAgNjU6ICdzZWxlY3RBbGwnXG4gIH0sXG5cbiAgb25DbGljazogZnVuY3Rpb24oKSB7XG4gICAgLy8gTm8gbmVlZCB0byB0cmlnZ2VyIGNsaWNrIGV2ZW50IGhlcmUsIGZvY3VzIGlzIGVub3VnaCB0byBoYXZlIHRoZSBrZXlib2FyZCBhcHBlYXIgb24gQW5kcm9pZFxuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEgJiYgdGhpcy5oaWRkZW5UZXh0YXJlYS5mb2N1cygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGtleXVwIGV2ZW50XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBvbktleURvd246IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoIXRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlLmtleUNvZGUgaW4gdGhpcy5fa2V5c01hcCkge1xuICAgICAgdGhpc1t0aGlzLl9rZXlzTWFwW2Uua2V5Q29kZV1dKGUpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoZS5rZXlDb2RlIGluIHRoaXMuX2N0cmxLZXlzTWFwRG93bikgJiYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpKSB7XG4gICAgICB0aGlzW3RoaXMuX2N0cmxLZXlzTWFwRG93bltlLmtleUNvZGVdXShlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmIChlLmtleUNvZGUgPj0gMzMgJiYgZS5rZXlDb2RlIDw9IDQwKSB7XG4gICAgICAvLyBpZiBpIHByZXNzIGFuIGFycm93IGtleSBqdXN0IHVwZGF0ZSBzZWxlY3Rpb25cbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0VG9wKCk7XG4gICAgICB0aGlzLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMucmVuZGVyQWxsKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGtleXVwIGV2ZW50XG4gICAqIFdlIGhhbmRsZSBLZXlVcCBiZWNhdXNlIGllMTEgYW5kIGVkZ2UgaGF2ZSBkaWZmaWN1bHRpZXMgY29weS9wYXN0aW5nXG4gICAqIGlmIGEgY29weS9jdXQgZXZlbnQgZmlyZWQsIGtleXVwIGlzIGRpc21pc3NlZFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgb25LZXlVcDogZnVuY3Rpb24oZSkge1xuICAgIGlmICghdGhpcy5pc0VkaXRpbmcgfHwgdGhpcy5fY29weURvbmUpIHtcbiAgICAgIHRoaXMuX2NvcHlEb25lID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgoZS5rZXlDb2RlIGluIHRoaXMuX2N0cmxLZXlzTWFwVXApICYmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSkge1xuICAgICAgdGhpc1t0aGlzLl9jdHJsS2V5c01hcFVwW2Uua2V5Q29kZV1dKGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMucmVuZGVyQWxsKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgb25JbnB1dCBldmVudFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgb25JbnB1dDogZnVuY3Rpb24oZSkge1xuICAgIGlmICghdGhpcy5pc0VkaXRpbmcgfHwgdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5zZWxlY3Rpb25TdGFydCB8fCAwLFxuICAgICAgICBvZmZzZXRFbmQgPSB0aGlzLnNlbGVjdGlvbkVuZCB8fCAwLFxuICAgICAgICB0ZXh0TGVuZ3RoID0gdGhpcy50ZXh0Lmxlbmd0aCxcbiAgICAgICAgbmV3VGV4dExlbmd0aCA9IHRoaXMuaGlkZGVuVGV4dGFyZWEudmFsdWUubGVuZ3RoLFxuICAgICAgICBkaWZmLCBjaGFyc1RvSW5zZXJ0LCBzdGFydDtcbiAgICBpZiAobmV3VGV4dExlbmd0aCA+IHRleHRMZW5ndGgpIHtcbiAgICAgIC8vd2UgYWRkZWQgc29tZSBjaGFyYWN0ZXJcbiAgICAgIHN0YXJ0ID0gdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAnbGVmdCcgPyBvZmZzZXRFbmQgOiBvZmZzZXQ7XG4gICAgICBkaWZmID0gbmV3VGV4dExlbmd0aCAtIHRleHRMZW5ndGg7XG4gICAgICBjaGFyc1RvSW5zZXJ0ID0gdGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZS5zbGljZShzdGFydCwgc3RhcnQgKyBkaWZmKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvL3dlIHNlbGVjdGVkIGEgcG9ydGlvbiBvZiB0ZXh0IGFuZCB0aGVuIGlucHV0IHNvbWV0aGluZyBlbHNlLlxuICAgICAgLy9JbnRlcm5ldCBleHBsb3JlciBkb2VzIG5vdCB0cmlnZ2VyIHRoaXMgZWxzZVxuICAgICAgZGlmZiA9IG5ld1RleHRMZW5ndGggLSB0ZXh0TGVuZ3RoICsgb2Zmc2V0RW5kIC0gb2Zmc2V0O1xuICAgICAgY2hhcnNUb0luc2VydCA9IHRoaXMuaGlkZGVuVGV4dGFyZWEudmFsdWUuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBkaWZmKTtcbiAgICB9XG4gICAgdGhpcy5pbnNlcnRDaGFycyhjaGFyc1RvSW5zZXJ0KTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb21wb3NpdGlvbiBzdGFydFxuICAgKi9cbiAgb25Db21wb3NpdGlvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID0gdHJ1ZTtcbiAgICB0aGlzLnByZXZDb21wb3NpdGlvbkxlbmd0aCA9IDA7XG4gICAgdGhpcy5jb21wb3NpdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgfSxcblxuICAvKipcbiAgICogQ29tcG9zaXRpb24gZW5kXG4gICAqL1xuICBvbkNvbXBvc2l0aW9uRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID0gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXBvc2l0aW9uIHVwZGF0ZVxuICAgKi9cbiAgb25Db21wb3NpdGlvblVwZGF0ZTogZnVuY3Rpb24oZSkge1xuICAgIHZhciBkYXRhID0gZS5kYXRhO1xuICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSB0aGlzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvbkVuZCA9PT0gdGhpcy5zZWxlY3Rpb25TdGFydCA/XG4gICAgICB0aGlzLmNvbXBvc2l0aW9uU3RhcnQgKyB0aGlzLnByZXZDb21wb3NpdGlvbkxlbmd0aCA6IHRoaXMuc2VsZWN0aW9uRW5kO1xuICAgIHRoaXMuaW5zZXJ0Q2hhcnMoZGF0YSwgZmFsc2UpO1xuICAgIHRoaXMucHJldkNvbXBvc2l0aW9uTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcndhcmQgZGVsZXRlXG4gICAqL1xuICBmb3J3YXJkRGVsZXRlOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm1vdmVDdXJzb3JSaWdodChlKTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVDaGFycyhlKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29waWVzIHNlbGVjdGVkIHRleHRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIGNvcHk6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgIC8vZG8gbm90IGN1dC1jb3B5IGlmIG5vIHNlbGVjdGlvblxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc2VsZWN0ZWRUZXh0ID0gdGhpcy5nZXRTZWxlY3RlZFRleHQoKSxcbiAgICAgICAgY2xpcGJvYXJkRGF0YSA9IHRoaXMuX2dldENsaXBib2FyZERhdGEoZSk7XG5cbiAgICAvLyBDaGVjayBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBicm93c2Vyc1xuICAgIGlmIChjbGlwYm9hcmREYXRhKSB7XG4gICAgICBjbGlwYm9hcmREYXRhLnNldERhdGEoJ3RleHQnLCBzZWxlY3RlZFRleHQpO1xuICAgIH1cblxuICAgIGZhYnJpYy5jb3BpZWRUZXh0ID0gc2VsZWN0ZWRUZXh0O1xuICAgIGZhYnJpYy5jb3BpZWRUZXh0U3R5bGUgPSB0aGlzLmdldFNlbGVjdGlvblN0eWxlcyh0aGlzLnNlbGVjdGlvblN0YXJ0LCB0aGlzLnNlbGVjdGlvbkVuZCk7XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5fY29weURvbmUgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQYXN0ZXMgdGV4dFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgcGFzdGU6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgY29waWVkVGV4dCA9IG51bGwsXG4gICAgICAgIGNsaXBib2FyZERhdGEgPSB0aGlzLl9nZXRDbGlwYm9hcmREYXRhKGUpLFxuICAgICAgICB1c2VDb3BpZWRTdHlsZSA9IHRydWU7XG5cbiAgICAvLyBDaGVjayBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBicm93c2Vyc1xuICAgIGlmIChjbGlwYm9hcmREYXRhKSB7XG4gICAgICBjb3BpZWRUZXh0ID0gY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0JykucmVwbGFjZSgvXFxyL2csICcnKTtcbiAgICAgIGlmICghZmFicmljLmNvcGllZFRleHRTdHlsZSB8fCBmYWJyaWMuY29waWVkVGV4dCAhPT0gY29waWVkVGV4dCkge1xuICAgICAgICB1c2VDb3BpZWRTdHlsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvcGllZFRleHQgPSBmYWJyaWMuY29waWVkVGV4dDtcbiAgICB9XG5cbiAgICBpZiAoY29waWVkVGV4dCkge1xuICAgICAgdGhpcy5pbnNlcnRDaGFycyhjb3BpZWRUZXh0LCB1c2VDb3BpZWRTdHlsZSk7XG4gICAgfVxuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDdXRzIHRleHRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIGN1dDogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY29weShlKTtcbiAgICB0aGlzLnJlbW92ZUNoYXJzKGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IENsaXBib2FyZCBkYXRhIG9iamVjdFxuICAgKi9cbiAgX2dldENsaXBib2FyZERhdGE6IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gKGUgJiYgZS5jbGlwYm9hcmREYXRhKSB8fCBmYWJyaWMud2luZG93LmNsaXBib2FyZERhdGE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSB3aWR0aCBpbiBwaXhlbHMgYmVmb3JlIHRoZSBjdXJzb3Igb24gdGhlIHNhbWUgbGluZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICogQHJldHVybiB7TnVtYmVyfSB3aWR0aEJlZm9yZUN1cnNvciB3aWR0aCBiZWZvcmUgY3Vyc29yXG4gICAqL1xuICBfZ2V0V2lkdGhCZWZvcmVDdXJzb3I6IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB7XG4gICAgdmFyIHRleHRCZWZvcmVDdXJzb3IgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XS5zbGljZSgwLCBjaGFySW5kZXgpLFxuICAgICAgICB3aWR0aE9mTGluZSA9IHRoaXMuX2dldExpbmVXaWR0aCh0aGlzLmN0eCwgbGluZUluZGV4KSxcbiAgICAgICAgd2lkdGhCZWZvcmVDdXJzb3IgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldCh3aWR0aE9mTGluZSksIF9jaGFyO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRleHRCZWZvcmVDdXJzb3IubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIF9jaGFyID0gdGV4dEJlZm9yZUN1cnNvcltpXTtcbiAgICAgIHdpZHRoQmVmb3JlQ3Vyc29yICs9IHRoaXMuX2dldFdpZHRoT2ZDaGFyKHRoaXMuY3R4LCBfY2hhciwgbGluZUluZGV4LCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpZHRoQmVmb3JlQ3Vyc29yO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHN0YXJ0IG9mZnNldCBvZiBhIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzUmlnaHRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0RG93bkN1cnNvck9mZnNldDogZnVuY3Rpb24oZSwgaXNSaWdodCkge1xuICAgIHZhciBzZWxlY3Rpb25Qcm9wID0gdGhpcy5fZ2V0U2VsZWN0aW9uRm9yT2Zmc2V0KGUsIGlzUmlnaHQpLFxuICAgICAgICBjdXJzb3JMb2NhdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzZWxlY3Rpb25Qcm9wKSxcbiAgICAgICAgbGluZUluZGV4ID0gY3Vyc29yTG9jYXRpb24ubGluZUluZGV4O1xuICAgIC8vIGlmIG9uIGxhc3QgbGluZSwgZG93biBjdXJzb3IgZ29lcyB0byBlbmQgb2YgbGluZVxuICAgIGlmIChsaW5lSW5kZXggPT09IHRoaXMuX3RleHRMaW5lcy5sZW5ndGggLSAxIHx8IGUubWV0YUtleSB8fCBlLmtleUNvZGUgPT09IDM0KSB7XG4gICAgICAvLyBtb3ZlIHRvIHRoZSBlbmQgb2YgYSB0ZXh0XG4gICAgICByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aCAtIHNlbGVjdGlvblByb3A7XG4gICAgfVxuICAgIHZhciBjaGFySW5kZXggPSBjdXJzb3JMb2NhdGlvbi5jaGFySW5kZXgsXG4gICAgICAgIHdpZHRoQmVmb3JlQ3Vyc29yID0gdGhpcy5fZ2V0V2lkdGhCZWZvcmVDdXJzb3IobGluZUluZGV4LCBjaGFySW5kZXgpLFxuICAgICAgICBpbmRleE9uT3RoZXJMaW5lID0gdGhpcy5fZ2V0SW5kZXhPbkxpbmUobGluZUluZGV4ICsgMSwgd2lkdGhCZWZvcmVDdXJzb3IpLFxuICAgICAgICB0ZXh0QWZ0ZXJDdXJzb3IgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XS5zbGljZShjaGFySW5kZXgpO1xuXG4gICAgcmV0dXJuIHRleHRBZnRlckN1cnNvci5sZW5ndGggKyBpbmRleE9uT3RoZXJMaW5lICsgMjtcbiAgfSxcblxuICAvKipcbiAgICogcHJpdmF0ZVxuICAgKiBIZWxwcyBmaW5kaW5nIGlmIHRoZSBvZmZzZXQgc2hvdWxkIGJlIGNvdW50ZWQgZnJvbSBTdGFydCBvciBFbmRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1JpZ2h0XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIF9nZXRTZWxlY3Rpb25Gb3JPZmZzZXQ6IGZ1bmN0aW9uKGUsIGlzUmlnaHQpIHtcbiAgICBpZiAoZS5zaGlmdEtleSAmJiB0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSB0aGlzLnNlbGVjdGlvbkVuZCAmJiBpc1JpZ2h0KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzUmlnaHRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0VXBDdXJzb3JPZmZzZXQ6IGZ1bmN0aW9uKGUsIGlzUmlnaHQpIHtcbiAgICB2YXIgc2VsZWN0aW9uUHJvcCA9IHRoaXMuX2dldFNlbGVjdGlvbkZvck9mZnNldChlLCBpc1JpZ2h0KSxcbiAgICAgICAgY3Vyc29yTG9jYXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oc2VsZWN0aW9uUHJvcCksXG4gICAgICAgIGxpbmVJbmRleCA9IGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleDtcbiAgICBpZiAobGluZUluZGV4ID09PSAwIHx8IGUubWV0YUtleSB8fCBlLmtleUNvZGUgPT09IDMzKSB7XG4gICAgICAvLyBpZiBvbiBmaXJzdCBsaW5lLCB1cCBjdXJzb3IgZ29lcyB0byBzdGFydCBvZiBsaW5lXG4gICAgICByZXR1cm4gLXNlbGVjdGlvblByb3A7XG4gICAgfVxuICAgIHZhciBjaGFySW5kZXggPSBjdXJzb3JMb2NhdGlvbi5jaGFySW5kZXgsXG4gICAgICAgIHdpZHRoQmVmb3JlQ3Vyc29yID0gdGhpcy5fZ2V0V2lkdGhCZWZvcmVDdXJzb3IobGluZUluZGV4LCBjaGFySW5kZXgpLFxuICAgICAgICBpbmRleE9uT3RoZXJMaW5lID0gdGhpcy5fZ2V0SW5kZXhPbkxpbmUobGluZUluZGV4IC0gMSwgd2lkdGhCZWZvcmVDdXJzb3IpLFxuICAgICAgICB0ZXh0QmVmb3JlQ3Vyc29yID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0uc2xpY2UoMCwgY2hhckluZGV4KTtcbiAgICAvLyByZXR1cm4gYSBuZWdhdGl2ZSBvZmZzZXRcbiAgICByZXR1cm4gLXRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXggLSAxXS5sZW5ndGggKyBpbmRleE9uT3RoZXJMaW5lIC0gdGV4dEJlZm9yZUN1cnNvci5sZW5ndGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZpbmQgZm9yIGEgZ2l2ZW4gd2lkdGggaXQgZm91bmRzIHRoZSBtYXRjaGluZyBjaGFyYWN0ZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0SW5kZXhPbkxpbmU6IGZ1bmN0aW9uKGxpbmVJbmRleCwgd2lkdGgpIHtcblxuICAgIHZhciB3aWR0aE9mTGluZSA9IHRoaXMuX2dldExpbmVXaWR0aCh0aGlzLmN0eCwgbGluZUluZGV4KSxcbiAgICAgICAgdGV4dE9uTGluZSA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLFxuICAgICAgICBsaW5lTGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KHdpZHRoT2ZMaW5lKSxcbiAgICAgICAgd2lkdGhPZkNoYXJzT25MaW5lID0gbGluZUxlZnRPZmZzZXQsXG4gICAgICAgIGluZGV4T25MaW5lID0gMCxcbiAgICAgICAgZm91bmRNYXRjaDtcblxuICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gdGV4dE9uTGluZS5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcblxuICAgICAgdmFyIF9jaGFyID0gdGV4dE9uTGluZVtqXSxcbiAgICAgICAgICB3aWR0aE9mQ2hhciA9IHRoaXMuX2dldFdpZHRoT2ZDaGFyKHRoaXMuY3R4LCBfY2hhciwgbGluZUluZGV4LCBqKTtcblxuICAgICAgd2lkdGhPZkNoYXJzT25MaW5lICs9IHdpZHRoT2ZDaGFyO1xuXG4gICAgICBpZiAod2lkdGhPZkNoYXJzT25MaW5lID4gd2lkdGgpIHtcblxuICAgICAgICBmb3VuZE1hdGNoID0gdHJ1ZTtcblxuICAgICAgICB2YXIgbGVmdEVkZ2UgPSB3aWR0aE9mQ2hhcnNPbkxpbmUgLSB3aWR0aE9mQ2hhcixcbiAgICAgICAgICAgIHJpZ2h0RWRnZSA9IHdpZHRoT2ZDaGFyc09uTGluZSxcbiAgICAgICAgICAgIG9mZnNldEZyb21MZWZ0RWRnZSA9IE1hdGguYWJzKGxlZnRFZGdlIC0gd2lkdGgpLFxuICAgICAgICAgICAgb2Zmc2V0RnJvbVJpZ2h0RWRnZSA9IE1hdGguYWJzKHJpZ2h0RWRnZSAtIHdpZHRoKTtcblxuICAgICAgICBpbmRleE9uTGluZSA9IG9mZnNldEZyb21SaWdodEVkZ2UgPCBvZmZzZXRGcm9tTGVmdEVkZ2UgPyBqIDogKGogLSAxKTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZWFjaGVkIGVuZFxuICAgIGlmICghZm91bmRNYXRjaCkge1xuICAgICAgaW5kZXhPbkxpbmUgPSB0ZXh0T25MaW5lLmxlbmd0aCAtIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4T25MaW5lO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciBkb3duXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBtb3ZlQ3Vyc29yRG93bjogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID49IHRoaXMudGV4dC5sZW5ndGggJiYgdGhpcy5zZWxlY3Rpb25FbmQgPj0gdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9tb3ZlQ3Vyc29yVXBPckRvd24oJ0Rvd24nLCBlKTtcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHVwXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBtb3ZlQ3Vyc29yVXA6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gMCAmJiB0aGlzLnNlbGVjdGlvbkVuZCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9tb3ZlQ3Vyc29yVXBPckRvd24oJ1VwJywgZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciB1cCBvciBkb3duLCBmaXJlcyB0aGUgZXZlbnRzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gJ1VwJyBvciAnRG93bidcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIF9tb3ZlQ3Vyc29yVXBPckRvd246IGZ1bmN0aW9uKGRpcmVjdGlvbiwgZSkge1xuICAgIC8vIGdldFVwQ3Vyc29yT2Zmc2V0XG4gICAgLy8gZ2V0RG93bkN1cnNvck9mZnNldFxuICAgIHZhciBhY3Rpb24gPSAnZ2V0JyArIGRpcmVjdGlvbiArICdDdXJzb3JPZmZzZXQnLFxuICAgICAgICBvZmZzZXQgPSB0aGlzW2FjdGlvbl0oZSwgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAncmlnaHQnKTtcbiAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgdGhpcy5tb3ZlQ3Vyc29yV2l0aFNoaWZ0KG9mZnNldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5tb3ZlQ3Vyc29yV2l0aG91dFNoaWZ0KG9mZnNldCk7XG4gICAgfVxuICAgIGlmIChvZmZzZXQgIT09IDApIHtcbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uSW5Cb3VuZGFyaWVzKCk7XG4gICAgICB0aGlzLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCk7XG4gICAgICB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eSA9IDE7XG4gICAgICB0aGlzLmluaXREZWxheWVkQ3Vyc29yKCk7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciB3aXRoIHNoaWZ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIG1vdmVDdXJzb3JXaXRoU2hpZnQ6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgIHZhciBuZXdTZWxlY3Rpb24gPSB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdsZWZ0J1xuICAgID8gdGhpcy5zZWxlY3Rpb25TdGFydCArIG9mZnNldFxuICAgIDogdGhpcy5zZWxlY3Rpb25FbmQgKyBvZmZzZXQ7XG4gICAgdGhpcy5zZXRTZWxlY3Rpb25TdGFydEVuZFdpdGhTaGlmdCh0aGlzLnNlbGVjdGlvblN0YXJ0LCB0aGlzLnNlbGVjdGlvbkVuZCwgbmV3U2VsZWN0aW9uKTtcbiAgICByZXR1cm4gb2Zmc2V0ICE9PSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgdXAgd2l0aG91dCBzaGlmdFxuICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XG4gICAqL1xuICBtb3ZlQ3Vyc29yV2l0aG91dFNoaWZ0OiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCArPSBvZmZzZXQ7XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgKz0gb2Zmc2V0O1xuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VsZWN0aW9uRW5kO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0ICE9PSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgbGVmdFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgbW92ZUN1cnNvckxlZnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gMCAmJiB0aGlzLnNlbGVjdGlvbkVuZCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9tb3ZlQ3Vyc29yTGVmdE9yUmlnaHQoJ0xlZnQnLCBlKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBhIGNoYW5nZSBoYXBwZW5lZFxuICAgKi9cbiAgX21vdmU6IGZ1bmN0aW9uKGUsIHByb3AsIGRpcmVjdGlvbikge1xuICAgIHZhciBuZXdWYWx1ZTtcbiAgICBpZiAoZS5hbHRLZXkpIHtcbiAgICAgIG5ld1ZhbHVlID0gdGhpc1snZmluZFdvcmRCb3VuZGFyeScgKyBkaXJlY3Rpb25dKHRoaXNbcHJvcF0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChlLm1ldGFLZXkgfHwgZS5rZXlDb2RlID09PSAzNSB8fCAgZS5rZXlDb2RlID09PSAzNiApIHtcbiAgICAgIG5ld1ZhbHVlID0gdGhpc1snZmluZExpbmVCb3VuZGFyeScgKyBkaXJlY3Rpb25dKHRoaXNbcHJvcF0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXNbcHJvcF0gKz0gZGlyZWN0aW9uID09PSAnTGVmdCcgPyAtMSA6IDE7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXdWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXNbcHJvcF0gIT09IG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzW3Byb3BdID0gbmV3VmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbW92ZUxlZnQ6IGZ1bmN0aW9uKGUsIHByb3ApIHtcbiAgICByZXR1cm4gdGhpcy5fbW92ZShlLCBwcm9wLCAnTGVmdCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21vdmVSaWdodDogZnVuY3Rpb24oZSwgcHJvcCkge1xuICAgIHJldHVybiB0aGlzLl9tb3ZlKGUsIHByb3AsICdSaWdodCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgbGVmdCB3aXRob3V0IGtlZXBpbmcgc2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICovXG4gIG1vdmVDdXJzb3JMZWZ0V2l0aG91dFNoaWZ0OiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGNoYW5nZSA9IHRydWU7XG4gICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ2xlZnQnO1xuXG4gICAgLy8gb25seSBtb3ZlIGN1cnNvciB3aGVuIHRoZXJlIGlzIG5vIHNlbGVjdGlvbixcbiAgICAvLyBvdGhlcndpc2Ugd2UgZGlzY2FyZCBpdCwgYW5kIGxlYXZlIGN1cnNvciBvbiBzYW1lIHBsYWNlXG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uRW5kID09PSB0aGlzLnNlbGVjdGlvblN0YXJ0ICYmIHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IDApIHtcbiAgICAgIGNoYW5nZSA9IHRoaXMuX21vdmVMZWZ0KGUsICdzZWxlY3Rpb25TdGFydCcpO1xuXG4gICAgfVxuICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICByZXR1cm4gY2hhbmdlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgbGVmdCB3aGlsZSBrZWVwaW5nIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqL1xuICBtb3ZlQ3Vyc29yTGVmdFdpdGhTaGlmdDogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdyaWdodCcgJiYgdGhpcy5zZWxlY3Rpb25TdGFydCAhPT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tb3ZlTGVmdChlLCAnc2VsZWN0aW9uRW5kJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IDApe1xuICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgcmV0dXJuIHRoaXMuX21vdmVMZWZ0KGUsICdzZWxlY3Rpb25TdGFydCcpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHJpZ2h0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBtb3ZlQ3Vyc29yUmlnaHQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA+PSB0aGlzLnRleHQubGVuZ3RoICYmIHRoaXMuc2VsZWN0aW9uRW5kID49IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbW92ZUN1cnNvckxlZnRPclJpZ2h0KCdSaWdodCcsIGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgcmlnaHQgb3IgTGVmdCwgZmlyZXMgZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRpcmVjdGlvbiAnTGVmdCcsICdSaWdodCdcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIF9tb3ZlQ3Vyc29yTGVmdE9yUmlnaHQ6IGZ1bmN0aW9uKGRpcmVjdGlvbiwgZSkge1xuICAgIHZhciBhY3Rpb25OYW1lID0gJ21vdmVDdXJzb3InICsgZGlyZWN0aW9uICsgJ1dpdGgnO1xuICAgIHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5ID0gMTtcblxuICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICBhY3Rpb25OYW1lICs9ICdTaGlmdCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYWN0aW9uTmFtZSArPSAnb3V0U2hpZnQnO1xuICAgIH1cbiAgICBpZiAodGhpc1thY3Rpb25OYW1lXShlKSkge1xuICAgICAgdGhpcy5hYm9ydEN1cnNvckFuaW1hdGlvbigpO1xuICAgICAgdGhpcy5pbml0RGVsYXllZEN1cnNvcigpO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgcmlnaHQgd2hpbGUga2VlcGluZyBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgbW92ZUN1cnNvclJpZ2h0V2l0aFNoaWZ0OiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ2xlZnQnICYmIHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW92ZVJpZ2h0KGUsICdzZWxlY3Rpb25TdGFydCcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbkVuZCAhPT0gdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgIHJldHVybiB0aGlzLl9tb3ZlUmlnaHQoZSwgJ3NlbGVjdGlvbkVuZCcpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHJpZ2h0IHdpdGhvdXQga2VlcGluZyBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG1vdmVDdXJzb3JSaWdodFdpdGhvdXRTaGlmdDogZnVuY3Rpb24oZSkge1xuICAgIHZhciBjaGFuZ2VkID0gdHJ1ZTtcbiAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAncmlnaHQnO1xuXG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICBjaGFuZ2VkID0gdGhpcy5fbW92ZVJpZ2h0KGUsICdzZWxlY3Rpb25TdGFydCcpO1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlbGVjdGlvbkVuZDtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgY2hhcmFjdGVycyBzZWxlY3RlZCBieSBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIHJlbW92ZUNoYXJzOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICB0aGlzLl9yZW1vdmVDaGFyc05lYXJDdXJzb3IoZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fcmVtb3ZlQ2hhcnNGcm9tVG8odGhpcy5zZWxlY3Rpb25TdGFydCwgdGhpcy5zZWxlY3Rpb25FbmQpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0KCdkaXJ0eScsIHRydWUpO1xuICAgIHRoaXMuc2V0U2VsZWN0aW9uRW5kKHRoaXMuc2VsZWN0aW9uU3RhcnQpO1xuXG4gICAgdGhpcy5fcmVtb3ZlRXh0cmFuZW91c1N0eWxlcygpO1xuXG4gICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMucmVuZGVyQWxsKCk7XG5cbiAgICB0aGlzLnNldENvb3JkcygpO1xuICAgIHRoaXMuZmlyZSgnY2hhbmdlZCcpO1xuICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6Y2hhbmdlZCcsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgX3JlbW92ZUNoYXJzTmVhckN1cnNvcjogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlLm1ldGFLZXkpIHtcbiAgICAgIC8vIHJlbW92ZSBhbGwgdGlsbCB0aGUgc3RhcnQgb2YgY3VycmVudCBsaW5lXG4gICAgICB2YXIgbGVmdExpbmVCb3VuZGFyeSA9IHRoaXMuZmluZExpbmVCb3VuZGFyeUxlZnQodGhpcy5zZWxlY3Rpb25TdGFydCk7XG5cbiAgICAgIHRoaXMuX3JlbW92ZUNoYXJzRnJvbVRvKGxlZnRMaW5lQm91bmRhcnksIHRoaXMuc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgdGhpcy5zZXRTZWxlY3Rpb25TdGFydChsZWZ0TGluZUJvdW5kYXJ5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZS5hbHRLZXkpIHtcbiAgICAgIC8vIHJlbW92ZSBhbGwgdGlsbCB0aGUgc3RhcnQgb2YgY3VycmVudCB3b3JkXG4gICAgICB2YXIgbGVmdFdvcmRCb3VuZGFyeSA9IHRoaXMuZmluZFdvcmRCb3VuZGFyeUxlZnQodGhpcy5zZWxlY3Rpb25TdGFydCk7XG5cbiAgICAgIHRoaXMuX3JlbW92ZUNoYXJzRnJvbVRvKGxlZnRXb3JkQm91bmRhcnksIHRoaXMuc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgdGhpcy5zZXRTZWxlY3Rpb25TdGFydChsZWZ0V29yZEJvdW5kYXJ5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9yZW1vdmVTaW5nbGVDaGFyQW5kU3R5bGUodGhpcy5zZWxlY3Rpb25TdGFydCk7XG4gICAgICB0aGlzLnNldFNlbGVjdGlvblN0YXJ0KHRoaXMuc2VsZWN0aW9uU3RhcnQgLSAxKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cbi8qIF9UT19TVkdfU1RBUlRfICovXG4oZnVuY3Rpb24oKSB7XG4gIHZhciB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZCxcbiAgICAgIE5VTV9GUkFDVElPTl9ESUdJVFMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFM7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuSVRleHQucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5JVGV4dC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHVGV4dExpbmVUZXh0OiBmdW5jdGlvbihsaW5lSW5kZXgsIHRleHRTcGFucywgaGVpZ2h0LCB0ZXh0TGVmdE9mZnNldCwgdGV4dFRvcE9mZnNldCwgdGV4dEJnUmVjdHMpIHtcbiAgICAgIGlmICghdGhpcy5fZ2V0TGluZVN0eWxlKGxpbmVJbmRleCkpIHtcbiAgICAgICAgZmFicmljLlRleHQucHJvdG90eXBlLl9zZXRTVkdUZXh0TGluZVRleHQuY2FsbCh0aGlzLFxuICAgICAgICAgIGxpbmVJbmRleCwgdGV4dFNwYW5zLCBoZWlnaHQsIHRleHRMZWZ0T2Zmc2V0LCB0ZXh0VG9wT2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9zZXRTVkdUZXh0TGluZUNoYXJzKFxuICAgICAgICAgIGxpbmVJbmRleCwgdGV4dFNwYW5zLCBoZWlnaHQsIHRleHRMZWZ0T2Zmc2V0LCB0ZXh0QmdSZWN0cyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR1RleHRMaW5lQ2hhcnM6IGZ1bmN0aW9uKGxpbmVJbmRleCwgdGV4dFNwYW5zLCBoZWlnaHQsIHRleHRMZWZ0T2Zmc2V0LCB0ZXh0QmdSZWN0cykge1xuXG4gICAgICB2YXIgY2hhcnMgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XSxcbiAgICAgICAgICBjaGFyT2Zmc2V0ID0gMCxcbiAgICAgICAgICBsaW5lTGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KHRoaXMuX2dldExpbmVXaWR0aCh0aGlzLmN0eCwgbGluZUluZGV4KSkgLSB0aGlzLndpZHRoIC8gMixcbiAgICAgICAgICBsaW5lT2Zmc2V0ID0gdGhpcy5fZ2V0U1ZHTGluZVRvcE9mZnNldChsaW5lSW5kZXgpLFxuICAgICAgICAgIGhlaWdodE9mTGluZSA9IHRoaXMuX2dldEhlaWdodE9mTGluZSh0aGlzLmN0eCwgbGluZUluZGV4KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoYXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBzdHlsZURlY2wgPSB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgaSkgfHwgeyB9O1xuXG4gICAgICAgIHRleHRTcGFucy5wdXNoKFxuICAgICAgICAgIHRoaXMuX2NyZWF0ZVRleHRDaGFyU3BhbihcbiAgICAgICAgICAgIGNoYXJzW2ldLCBzdHlsZURlY2wsIGxpbmVMZWZ0T2Zmc2V0LCBsaW5lT2Zmc2V0LmxpbmVUb3AgKyBsaW5lT2Zmc2V0Lm9mZnNldCwgY2hhck9mZnNldCkpO1xuXG4gICAgICAgIHZhciBjaGFyV2lkdGggPSB0aGlzLl9nZXRXaWR0aE9mQ2hhcih0aGlzLmN0eCwgY2hhcnNbaV0sIGxpbmVJbmRleCwgaSk7XG5cbiAgICAgICAgaWYgKHN0eWxlRGVjbC50ZXh0QmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgICAgdGV4dEJnUmVjdHMucHVzaChcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVRleHRDaGFyQmcoXG4gICAgICAgICAgICAgIHN0eWxlRGVjbCwgbGluZUxlZnRPZmZzZXQsIGxpbmVPZmZzZXQubGluZVRvcCwgaGVpZ2h0T2ZMaW5lLCBjaGFyV2lkdGgsIGNoYXJPZmZzZXQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoYXJPZmZzZXQgKz0gY2hhcldpZHRoO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRTVkdMaW5lVG9wT2Zmc2V0OiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHZhciBsaW5lVG9wT2Zmc2V0ID0gMCwgbGFzdEhlaWdodCA9IDA7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmVJbmRleDsgaisrKSB7XG4gICAgICAgIGxpbmVUb3BPZmZzZXQgKz0gdGhpcy5fZ2V0SGVpZ2h0T2ZMaW5lKHRoaXMuY3R4LCBqKTtcbiAgICAgIH1cbiAgICAgIGxhc3RIZWlnaHQgPSB0aGlzLl9nZXRIZWlnaHRPZkxpbmUodGhpcy5jdHgsIGopO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZVRvcDogbGluZVRvcE9mZnNldCxcbiAgICAgICAgb2Zmc2V0OiAodGhpcy5fZm9udFNpemVNdWx0IC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbikgKiBsYXN0SGVpZ2h0IC8gKHRoaXMubGluZUhlaWdodCAqIHRoaXMuX2ZvbnRTaXplTXVsdClcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZVRleHRDaGFyQmc6IGZ1bmN0aW9uKHN0eWxlRGVjbCwgbGluZUxlZnRPZmZzZXQsIGxpbmVUb3BPZmZzZXQsIGhlaWdodE9mTGluZSwgY2hhcldpZHRoLCBjaGFyT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAnXFx0XFx0PHJlY3QgZmlsbD1cIicsIHN0eWxlRGVjbC50ZXh0QmFja2dyb3VuZENvbG9yLFxuICAgICAgICAnXCIgeD1cIicsIHRvRml4ZWQobGluZUxlZnRPZmZzZXQgKyBjaGFyT2Zmc2V0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgJ1wiIHk9XCInLCB0b0ZpeGVkKGxpbmVUb3BPZmZzZXQgLSB0aGlzLmhlaWdodCAvIDIsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAnXCIgd2lkdGg9XCInLCB0b0ZpeGVkKGNoYXJXaWR0aCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICdcIiBoZWlnaHQ9XCInLCB0b0ZpeGVkKGhlaWdodE9mTGluZSAvIHRoaXMubGluZUhlaWdodCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICdcIj48L3JlY3Q+XFxuJ1xuICAgICAgXS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlVGV4dENoYXJTcGFuOiBmdW5jdGlvbihfY2hhciwgc3R5bGVEZWNsLCBsaW5lTGVmdE9mZnNldCwgbGluZVRvcE9mZnNldCwgY2hhck9mZnNldCkge1xuXG4gICAgICB2YXIgZmlsbFN0eWxlcyA9IHRoaXMuZ2V0U3ZnU3R5bGVzLmNhbGwoZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCh7XG4gICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgIGZpbGw6IHRoaXMuZmlsbCxcbiAgICAgICAgc3Ryb2tlOiB0aGlzLnN0cm9rZSxcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICBnZXRTdmdGaWx0ZXI6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmdldFN2Z0ZpbHRlclxuICAgICAgfSwgc3R5bGVEZWNsKSk7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgICdcXHRcXHRcXHQ8dHNwYW4geD1cIicsIHRvRml4ZWQobGluZUxlZnRPZmZzZXQgKyBjaGFyT2Zmc2V0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSwgJ1wiIHk9XCInLFxuICAgICAgICB0b0ZpeGVkKGxpbmVUb3BPZmZzZXQgLSB0aGlzLmhlaWdodCAvIDIsIE5VTV9GUkFDVElPTl9ESUdJVFMpLCAnXCIgJyxcbiAgICAgICAgICAoc3R5bGVEZWNsLmZvbnRGYW1pbHkgPyAnZm9udC1mYW1pbHk9XCInICsgc3R5bGVEZWNsLmZvbnRGYW1pbHkucmVwbGFjZSgvXCIvZywgJ1xcJycpICsgJ1wiICcgOiAnJyksXG4gICAgICAgICAgKHN0eWxlRGVjbC5mb250U2l6ZSA/ICdmb250LXNpemU9XCInICsgc3R5bGVEZWNsLmZvbnRTaXplICsgJ1wiICcgOiAnJyksXG4gICAgICAgICAgKHN0eWxlRGVjbC5mb250U3R5bGUgPyAnZm9udC1zdHlsZT1cIicgKyBzdHlsZURlY2wuZm9udFN0eWxlICsgJ1wiICcgOiAnJyksXG4gICAgICAgICAgKHN0eWxlRGVjbC5mb250V2VpZ2h0ID8gJ2ZvbnQtd2VpZ2h0PVwiJyArIHN0eWxlRGVjbC5mb250V2VpZ2h0ICsgJ1wiICcgOiAnJyksXG4gICAgICAgICAgKHN0eWxlRGVjbC50ZXh0RGVjb3JhdGlvbiA/ICd0ZXh0LWRlY29yYXRpb249XCInICsgc3R5bGVEZWNsLnRleHREZWNvcmF0aW9uICsgJ1wiICcgOiAnJyksXG4gICAgICAgICdzdHlsZT1cIicsIGZpbGxTdHlsZXMsICdcIj4nLFxuICAgICAgICBmYWJyaWMudXRpbC5zdHJpbmcuZXNjYXBlWG1sKF9jaGFyKSxcbiAgICAgICAgJzwvdHNwYW4+XFxuJ1xuICAgICAgXS5qb2luKCcnKTtcbiAgICB9XG4gIH0pO1xufSkoKTtcbi8qIF9UT19TVkdfRU5EXyAqL1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7fSk7XG5cbiAgLyoqXG4gICAqIFRleHRib3ggY2xhc3MsIGJhc2VkIG9uIElUZXh0LCBhbGxvd3MgdGhlIHVzZXIgdG8gcmVzaXplIHRoZSB0ZXh0IHJlY3RhbmdsZVxuICAgKiBhbmQgd3JhcHMgbGluZXMgYXV0b21hdGljYWxseS4gVGV4dGJveGVzIGhhdmUgdGhlaXIgWSBzY2FsaW5nIGxvY2tlZCwgdGhlXG4gICAqIHVzZXIgY2FuIG9ubHkgY2hhbmdlIHdpZHRoLiBIZWlnaHQgaXMgYWRqdXN0ZWQgYXV0b21hdGljYWxseSBiYXNlZCBvbiB0aGVcbiAgICogd3JhcHBpbmcgb2YgbGluZXMuXG4gICAqIEBjbGFzcyBmYWJyaWMuVGV4dGJveFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSVRleHRcbiAgICogQG1peGVzIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5UZXh0Ym94fSB0aGlzQXJnXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5UZXh0Ym94I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuVGV4dGJveCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5JVGV4dCwgZmFicmljLk9ic2VydmFibGUsIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAndGV4dGJveCcsXG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIHdpZHRoIG9mIHRleHRib3gsIGluIHBpeGVscy5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1pbldpZHRoOiAyMCxcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gY2FsY3VsYXRlZCB3aWR0aCBvZiBhIHRleHRib3gsIGluIHBpeGVscy5cbiAgICAgKiBmaXhlZCB0byAyIHNvIHRoYXQgYW4gZW1wdHkgdGV4dGJveCBjYW5ub3QgZ28gdG8gMFxuICAgICAqIGFuZCBpcyBzdGlsbCBzZWxlY3RhYmxlIHdpdGhvdXQgdGV4dC5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGR5bmFtaWNNaW5XaWR0aDogMixcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBhcnJheSBvZiB0ZXh0IHdyYXBwaW5nLlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgX19jYWNoZWRMaW5lczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHN0YW5kYXJkIE9iamVjdCBjbGFzcyB2YWx1ZXNcbiAgICAgKi9cbiAgICBsb2NrU2NhbGluZ1k6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBzdGFuZGFyZCBPYmplY3QgY2xhc3MgdmFsdWVzXG4gICAgICovXG4gICAgbG9ja1NjYWxpbmdGbGlwOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgc3RhbmRhcmQgT2JqZWN0IGNsYXNzIHZhbHVlc1xuICAgICAqIFRleHRib3ggbmVlZHMgdGhpcyBvbiBmYWxzZVxuICAgICAqL1xuICAgIG5vU2NhbGVDYWNoZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3Rvci4gU29tZSBzY2FsaW5nIHJlbGF0ZWQgcHJvcGVydHkgdmFsdWVzIGFyZSBmb3JjZWQuIFZpc2liaWxpdHlcbiAgICAgKiBvZiBjb250cm9scyBpcyBhbHNvIGZpeGVkOyBvbmx5IHRoZSByb3RhdGlvbiBhbmQgd2lkdGggY29udHJvbHMgYXJlXG4gICAgICogbWFkZSBhdmFpbGFibGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGV4dCBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLlRleHRib3h9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbih0ZXh0LCBvcHRpb25zKSB7XG5cbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgdGV4dCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLnNldENvbnRyb2xzVmlzaWJpbGl0eShmYWJyaWMuVGV4dGJveC5nZXRUZXh0Ym94Q29udHJvbFZpc2liaWxpdHkoKSk7XG4gICAgICB0aGlzLmN0eCA9IHRoaXMub2JqZWN0Q2FjaGluZyA/IHRoaXMuX2NhY2hlQ29udGV4dCA6IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgLy8gYWRkIHdpZHRoIHRvIHRoaXMgbGlzdCBvZiBwcm9wcyB0aGF0IGVmZmVjdCBsaW5lIHdyYXBwaW5nLlxuICAgICAgdGhpcy5fZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMucHVzaCgnd2lkdGgnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5saWtlIHN1cGVyY2xhc3MncyB2ZXJzaW9uIG9mIHRoaXMgZnVuY3Rpb24sIFRleHRib3ggZG9lcyBub3QgdXBkYXRlXG4gICAgICogaXRzIHdpZHRoLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byB1c2UgZm9yIG1lYXN1cmVtZW50c1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2luaXREaW1lbnNpb25zOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICh0aGlzLl9fc2tpcERpbWVuc2lvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghY3R4KSB7XG4gICAgICAgIGN0eCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB0aGlzLl9zZXRUZXh0U3R5bGVzKGN0eCk7XG4gICAgICAgIHRoaXMuY2xlYXJDb250ZXh0VG9wKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNsZWFyIGR5bmFtaWNNaW5XaWR0aCBhcyBpdCB3aWxsIGJlIGRpZmZlcmVudCBhZnRlciB3ZSByZS13cmFwIGxpbmVcbiAgICAgIHRoaXMuZHluYW1pY01pbldpZHRoID0gMDtcblxuICAgICAgLy8gd3JhcCBsaW5lc1xuICAgICAgdGhpcy5fdGV4dExpbmVzID0gdGhpcy5fc3BsaXRUZXh0SW50b0xpbmVzKGN0eCk7XG4gICAgICAvLyBpZiBhZnRlciB3cmFwcGluZywgdGhlIHdpZHRoIGlzIHNtYWxsZXIgdGhhbiBkeW5hbWljTWluV2lkdGgsIGNoYW5nZSB0aGUgd2lkdGggYW5kIHJlLXdyYXBcbiAgICAgIGlmICh0aGlzLmR5bmFtaWNNaW5XaWR0aCA+IHRoaXMud2lkdGgpIHtcbiAgICAgICAgdGhpcy5fc2V0KCd3aWR0aCcsIHRoaXMuZHluYW1pY01pbldpZHRoKTtcbiAgICAgIH1cblxuICAgICAgLy8gY2xlYXIgY2FjaGUgYW5kIHJlLWNhbGN1bGF0ZSBoZWlnaHRcbiAgICAgIHRoaXMuX2NsZWFyQ2FjaGUoKTtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5fZ2V0VGV4dEhlaWdodChjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbiBvYmplY3QgdGhhdCB0cmFuc2xhdGVzIHRoZSBzdHlsZSBvYmplY3Qgc28gdGhhdCBpdCBpc1xuICAgICAqIGJyb2tlbiB1cCBieSB2aXN1YWwgbGluZXMgKG5ldyBsaW5lcyBhbmQgYXV0b21hdGljIHdyYXBwaW5nKS5cbiAgICAgKiBUaGUgb3JpZ2luYWwgdGV4dCBzdHlsZXMgb2JqZWN0IGlzIGJyb2tlbiB1cCBieSBhY3R1YWwgbGluZXMgKG5ldyBsaW5lcyBvbmx5KSxcbiAgICAgKiB3aGljaCBpcyBvbmx5IHN1ZmZpY2llbnQgZm9yIFRleHQgLyBJVGV4dFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dlbmVyYXRlU3R5bGVNYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlYWxMaW5lQ291bnQgICAgID0gMCxcbiAgICAgICAgICByZWFsTGluZUNoYXJDb3VudCA9IDAsXG4gICAgICAgICAgY2hhckNvdW50ICAgICAgICAgPSAwLFxuICAgICAgICAgIG1hcCAgICAgICAgICAgICAgID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLnRleHRbY2hhckNvdW50XSA9PT0gJ1xcbicgJiYgaSA+IDApIHtcbiAgICAgICAgICByZWFsTGluZUNoYXJDb3VudCA9IDA7XG4gICAgICAgICAgY2hhckNvdW50Kys7XG4gICAgICAgICAgcmVhbExpbmVDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudGV4dFtjaGFyQ291bnRdID09PSAnICcgJiYgaSA+IDApIHtcbiAgICAgICAgICAvLyB0aGlzIGNhc2UgZGVhbHMgd2l0aCBzcGFjZSdzIHRoYXQgYXJlIHJlbW92ZWQgZnJvbSBlbmQgb2YgbGluZXMgd2hlbiB3cmFwcGluZ1xuICAgICAgICAgIHJlYWxMaW5lQ2hhckNvdW50Kys7XG4gICAgICAgICAgY2hhckNvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICBtYXBbaV0gPSB7IGxpbmU6IHJlYWxMaW5lQ291bnQsIG9mZnNldDogcmVhbExpbmVDaGFyQ291bnQgfTtcblxuICAgICAgICBjaGFyQ291bnQgKz0gdGhpcy5fdGV4dExpbmVzW2ldLmxlbmd0aDtcbiAgICAgICAgcmVhbExpbmVDaGFyQ291bnQgKz0gdGhpcy5fdGV4dExpbmVzW2ldLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZXR1cm5DbG9uZU9yRW1wdHk9ZmFsc2VdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgsIHJldHVybkNsb25lT3JFbXB0eSkge1xuICAgICAgaWYgKHRoaXMuX3N0eWxlTWFwKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgIHJldHVybiByZXR1cm5DbG9uZU9yRW1wdHkgPyB7IH0gOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVJbmRleCA9IG1hcC5saW5lO1xuICAgICAgICBjaGFySW5kZXggPSBtYXAub2Zmc2V0ICsgY2hhckluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCdfZ2V0U3R5bGVEZWNsYXJhdGlvbicsIGxpbmVJbmRleCwgY2hhckluZGV4LCByZXR1cm5DbG9uZU9yRW1wdHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFN0eWxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4LCBzdHlsZSkge1xuICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICBsaW5lSW5kZXggPSBtYXAubGluZTtcbiAgICAgIGNoYXJJbmRleCA9IG1hcC5vZmZzZXQgKyBjaGFySW5kZXg7XG5cbiAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4XSA9IHN0eWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RlbGV0ZVN0eWxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4XTtcbiAgICAgIGxpbmVJbmRleCA9IG1hcC5saW5lO1xuICAgICAgY2hhckluZGV4ID0gbWFwLm9mZnNldCArIGNoYXJJbmRleDtcblxuICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldExpbmVTdHlsZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4XTtcbiAgICAgIHJldHVybiB0aGlzLnN0eWxlc1ttYXAubGluZV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRMaW5lU3R5bGU6IGZ1bmN0aW9uKGxpbmVJbmRleCwgc3R5bGUpIHtcbiAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgdGhpcy5zdHlsZXNbbWFwLmxpbmVdID0gc3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZWxldGVMaW5lU3R5bGU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbWFwLmxpbmVdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXcmFwcyB0ZXh0IHVzaW5nIHRoZSAnd2lkdGgnIHByb3BlcnR5IG9mIFRleHRib3guIEZpcnN0IHRoaXMgZnVuY3Rpb25cbiAgICAgKiBzcGxpdHMgdGV4dCBvbiBuZXdsaW5lcywgc28gd2UgcHJlc2VydmUgbmV3bGluZXMgZW50ZXJlZCBieSB0aGUgdXNlci5cbiAgICAgKiBUaGVuIGl0IHdyYXBzIGVhY2ggbGluZSB1c2luZyB0aGUgd2lkdGggb2YgdGhlIFRleHRib3ggYnkgY2FsbGluZ1xuICAgICAqIF93cmFwTGluZSgpLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byB1c2UgZm9yIG1lYXN1cmVtZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSBzdHJpbmcgb2YgdGV4dCB0aGF0IGlzIHNwbGl0IGludG8gbGluZXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGxpbmVzXG4gICAgICovXG4gICAgX3dyYXBUZXh0OiBmdW5jdGlvbihjdHgsIHRleHQpIHtcbiAgICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQodGhpcy5fcmVOZXdsaW5lKSwgd3JhcHBlZCA9IFtdLCBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd3JhcHBlZCA9IHdyYXBwZWQuY29uY2F0KHRoaXMuX3dyYXBMaW5lKGN0eCwgbGluZXNbaV0sIGkpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHdyYXBwZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0byBtZWFzdXJlIGEgc3RyaW5nIG9mIHRleHQsIGdpdmVuIGl0cyBsaW5lSW5kZXggYW5kIGNoYXJJbmRleCBvZmZzZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2hhck9mZnNldFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWVhc3VyZVRleHQ6IGZ1bmN0aW9uKGN0eCwgdGV4dCwgbGluZUluZGV4LCBjaGFyT2Zmc2V0KSB7XG4gICAgICB2YXIgd2lkdGggPSAwO1xuICAgICAgY2hhck9mZnNldCA9IGNoYXJPZmZzZXQgfHwgMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0ZXh0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHdpZHRoICs9IHRoaXMuX2dldFdpZHRoT2ZDaGFyKGN0eCwgdGV4dFtpXSwgbGluZUluZGV4LCBpICsgY2hhck9mZnNldCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdyYXBzIGEgbGluZSBvZiB0ZXh0IHVzaW5nIHRoZSB3aWR0aCBvZiB0aGUgVGV4dGJveCBhbmQgYSBjb250ZXh0LlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byB1c2UgZm9yIG1lYXN1cmVtZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSBzdHJpbmcgb2YgdGV4dCB0byBzcGxpdCBpbnRvIGxpbmVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2YgbGluZShzKSBpbnRvIHdoaWNoIHRoZSBnaXZlbiB0ZXh0IGlzIHdyYXBwZWRcbiAgICAgKiB0by5cbiAgICAgKi9cbiAgICBfd3JhcExpbmU6IGZ1bmN0aW9uKGN0eCwgdGV4dCwgbGluZUluZGV4KSB7XG4gICAgICB2YXIgbGluZVdpZHRoICAgICAgICA9IDAsXG4gICAgICAgICAgbGluZXMgICAgICAgICAgICA9IFtdLFxuICAgICAgICAgIGxpbmUgICAgICAgICAgICAgPSAnJyxcbiAgICAgICAgICB3b3JkcyAgICAgICAgICAgID0gdGV4dC5zcGxpdCgnICcpLFxuICAgICAgICAgIHdvcmQgICAgICAgICAgICAgPSAnJyxcbiAgICAgICAgICBvZmZzZXQgICAgICAgICAgID0gMCxcbiAgICAgICAgICBpbmZpeCAgICAgICAgICAgID0gJyAnLFxuICAgICAgICAgIHdvcmRXaWR0aCAgICAgICAgPSAwLFxuICAgICAgICAgIGluZml4V2lkdGggICAgICAgPSAwLFxuICAgICAgICAgIGxhcmdlc3RXb3JkV2lkdGggPSAwLFxuICAgICAgICAgIGxpbmVKdXN0U3RhcnRlZCA9IHRydWUsXG4gICAgICAgICAgYWRkaXRpb25hbFNwYWNlID0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd29yZCA9IHdvcmRzW2ldO1xuICAgICAgICB3b3JkV2lkdGggPSB0aGlzLl9tZWFzdXJlVGV4dChjdHgsIHdvcmQsIGxpbmVJbmRleCwgb2Zmc2V0KTtcblxuICAgICAgICBvZmZzZXQgKz0gd29yZC5sZW5ndGg7XG5cbiAgICAgICAgbGluZVdpZHRoICs9IGluZml4V2lkdGggKyB3b3JkV2lkdGggLSBhZGRpdGlvbmFsU3BhY2U7XG5cbiAgICAgICAgaWYgKGxpbmVXaWR0aCA+PSB0aGlzLndpZHRoICYmICFsaW5lSnVzdFN0YXJ0ZWQpIHtcbiAgICAgICAgICBsaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICAgIGxpbmUgPSAnJztcbiAgICAgICAgICBsaW5lV2lkdGggPSB3b3JkV2lkdGg7XG4gICAgICAgICAgbGluZUp1c3RTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsaW5lV2lkdGggKz0gYWRkaXRpb25hbFNwYWNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsaW5lSnVzdFN0YXJ0ZWQpIHtcbiAgICAgICAgICBsaW5lICs9IGluZml4O1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgKz0gd29yZDtcblxuICAgICAgICBpbmZpeFdpZHRoID0gdGhpcy5fbWVhc3VyZVRleHQoY3R4LCBpbmZpeCwgbGluZUluZGV4LCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgbGluZUp1c3RTdGFydGVkID0gZmFsc2U7XG4gICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgbGFyZ2VzdCB3b3JkXG4gICAgICAgIGlmICh3b3JkV2lkdGggPiBsYXJnZXN0V29yZFdpZHRoKSB7XG4gICAgICAgICAgbGFyZ2VzdFdvcmRXaWR0aCA9IHdvcmRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpICYmIGxpbmVzLnB1c2gobGluZSk7XG5cbiAgICAgIGlmIChsYXJnZXN0V29yZFdpZHRoID4gdGhpcy5keW5hbWljTWluV2lkdGgpIHtcbiAgICAgICAgdGhpcy5keW5hbWljTWluV2lkdGggPSBsYXJnZXN0V29yZFdpZHRoIC0gYWRkaXRpb25hbFNwYWNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGluZXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXRzIGxpbmVzIG9mIHRleHQgdG8gcmVuZGVyIGluIHRoZSBUZXh0Ym94LiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXNcbiAgICAgKiB0ZXh0IHdyYXBwaW5nIG9uIHRoZSBmbHkgZXZlcnl0aW1lIGl0IGlzIGNhbGxlZC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGxpbmVzIGluIHRoZSBUZXh0Ym94LlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9zcGxpdFRleHRJbnRvTGluZXM6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgY3R4ID0gY3R4IHx8IHRoaXMuY3R4O1xuICAgICAgdmFyIG9yaWdpbmFsQWxpZ24gPSB0aGlzLnRleHRBbGlnbjtcbiAgICAgIHRoaXMuX3N0eWxlTWFwID0gbnVsbDtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLl9zZXRUZXh0U3R5bGVzKGN0eCk7XG4gICAgICB0aGlzLnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgIHZhciBsaW5lcyA9IHRoaXMuX3dyYXBUZXh0KGN0eCwgdGhpcy50ZXh0KTtcbiAgICAgIHRoaXMudGV4dEFsaWduID0gb3JpZ2luYWxBbGlnbjtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLl90ZXh0TGluZXMgPSBsaW5lcztcbiAgICAgIHRoaXMuX3N0eWxlTWFwID0gdGhpcy5fZ2VuZXJhdGVTdHlsZU1hcCgpO1xuICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHBhcnQgb2YgYSBncm91cCwgd2UgZG9uJ3Qgd2FudCB0aGUgVGV4dGJveCdzIHNjYWxlIHRvIGluY3JlYXNlIGlmXG4gICAgICogdGhlIGdyb3VwJ3MgaW5jcmVhc2VzLiBUaGF0J3Mgd2h5IHdlIHJlZHVjZSB0aGUgc2NhbGUgb2YgdGhlIFRleHRib3ggYnlcbiAgICAgKiB0aGUgYW1vdW50IHRoYXQgdGhlIGdyb3VwJ3MgaW5jcmVhc2VzLiBUaGlzIGlzIHRvIG1haW50YWluIHRoZSBlZmZlY3RpdmVcbiAgICAgKiBzY2FsZSBvZiB0aGUgVGV4dGJveCBhdCAxLCBzbyB0aGF0IGZvbnQtc2l6ZSB2YWx1ZXMgbWFrZSBzZW5zZS4gT3RoZXJ3aXNlXG4gICAgICogdGhlIHNhbWUgZm9udC1zaXplIHZhbHVlIHdvdWxkIHJlc3VsdCBpbiBkaWZmZXJlbnQgYWN0dWFsIHNpemUgZGVwZW5kaW5nXG4gICAgICogb24gdGhlIHZhbHVlIG9mIHRoZSBzY2FsZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldE9uR3JvdXA6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXkgPT09ICdzY2FsZVgnKSB7XG4gICAgICAgIHRoaXMuc2V0KCdzY2FsZVgnLCBNYXRoLmFicygxIC8gdmFsdWUpKTtcbiAgICAgICAgdGhpcy5zZXQoJ3dpZHRoJywgKHRoaXMuZ2V0KCd3aWR0aCcpICogdmFsdWUpIC9cbiAgICAgICAgICAodHlwZW9mIHRoaXMuX19vbGRTY2FsZVggPT09ICd1bmRlZmluZWQnID8gMSA6IHRoaXMuX19vbGRTY2FsZVgpKTtcbiAgICAgICAgdGhpcy5fX29sZFNjYWxlWCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIDJkIHJlcHJlc2VudGF0aW9uIChsaW5lSW5kZXggYW5kIGNoYXJJbmRleCkgb2YgY3Vyc29yIChvciBzZWxlY3Rpb24gc3RhcnQpLlxuICAgICAqIE92ZXJyaWRlcyB0aGUgc3VwZXJjbGFzcyBmdW5jdGlvbiB0byB0YWtlIGludG8gYWNjb3VudCB0ZXh0IHdyYXBwaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzZWxlY3Rpb25TdGFydF0gT3B0aW9uYWwgaW5kZXguIFdoZW4gbm90IGdpdmVuLCBjdXJyZW50IHNlbGVjdGlvblN0YXJ0IGlzIHVzZWQuXG4gICAgICovXG4gICAgZ2V0MkRDdXJzb3JMb2NhdGlvbjogZnVuY3Rpb24oc2VsZWN0aW9uU3RhcnQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0aW9uU3RhcnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgIH1cblxuICAgICAgdmFyIG51bUxpbmVzID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aCxcbiAgICAgICAgICByZW1vdmVkICA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTGluZXM7IGkrKykge1xuICAgICAgICB2YXIgbGluZSAgICA9IHRoaXMuX3RleHRMaW5lc1tpXSxcbiAgICAgICAgICAgIGxpbmVMZW4gPSBsaW5lLmxlbmd0aDtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPD0gcmVtb3ZlZCArIGxpbmVMZW4pIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGluZUluZGV4OiBpLFxuICAgICAgICAgICAgY2hhckluZGV4OiBzZWxlY3Rpb25TdGFydCAtIHJlbW92ZWRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVtb3ZlZCArPSBsaW5lTGVuO1xuXG4gICAgICAgIGlmICh0aGlzLnRleHRbcmVtb3ZlZF0gPT09ICdcXG4nIHx8IHRoaXMudGV4dFtyZW1vdmVkXSA9PT0gJyAnKSB7XG4gICAgICAgICAgcmVtb3ZlZCsrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmVJbmRleDogbnVtTGluZXMgLSAxLFxuICAgICAgICBjaGFySW5kZXg6IHRoaXMuX3RleHRMaW5lc1tudW1MaW5lcyAtIDFdLmxlbmd0aFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIHN1cGVyY2xhc3MgZnVuY3Rpb24gYW5kIHVzZXMgdGV4dCB3cmFwcGluZyBkYXRhIHRvIGdldCBjdXJzb3JcbiAgICAgKiBib3VuZGFyeSBvZmZzZXRzIGluc3RlYWQgb2YgdGhlIGFycmF5IG9mIGNoYXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNoYXJzIFVudXNlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlT2ZCb3VuZGFyaWVzIENhbiBiZSAnY3Vyc29yJyBvciAnc2VsZWN0aW9uJ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCB3aXRoICd0b3AnLCAnbGVmdCcsIGFuZCAnbGluZUxlZnQnIHByb3BlcnRpZXMgc2V0LlxuICAgICAqL1xuICAgIF9nZXRDdXJzb3JCb3VuZGFyaWVzT2Zmc2V0czogZnVuY3Rpb24oY2hhcnMsIHR5cGVPZkJvdW5kYXJpZXMpIHtcbiAgICAgIHZhciB0b3BPZmZzZXQgICAgICA9IDAsXG4gICAgICAgICAgbGVmdE9mZnNldCAgICAgPSAwLFxuICAgICAgICAgIGN1cnNvckxvY2F0aW9uID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKCksXG4gICAgICAgICAgbGluZUNoYXJzICAgICAgPSB0aGlzLl90ZXh0TGluZXNbY3Vyc29yTG9jYXRpb24ubGluZUluZGV4XS5zcGxpdCgnJyksXG4gICAgICAgICAgbGluZUxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldCh0aGlzLl9nZXRMaW5lV2lkdGgodGhpcy5jdHgsIGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleCkpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnNvckxvY2F0aW9uLmNoYXJJbmRleDsgaSsrKSB7XG4gICAgICAgIGxlZnRPZmZzZXQgKz0gdGhpcy5fZ2V0V2lkdGhPZkNoYXIodGhpcy5jdHgsIGxpbmVDaGFyc1tpXSwgY3Vyc29yTG9jYXRpb24ubGluZUluZGV4LCBpKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleDsgaSsrKSB7XG4gICAgICAgIHRvcE9mZnNldCArPSB0aGlzLl9nZXRIZWlnaHRPZkxpbmUodGhpcy5jdHgsIGkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZU9mQm91bmRhcmllcyA9PT0gJ2N1cnNvcicpIHtcbiAgICAgICAgdG9wT2Zmc2V0ICs9ICgxIC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbikgKiB0aGlzLl9nZXRIZWlnaHRPZkxpbmUodGhpcy5jdHgsIGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleClcbiAgICAgICAgICAvIHRoaXMubGluZUhlaWdodCAtIHRoaXMuZ2V0Q3VycmVudENoYXJGb250U2l6ZShjdXJzb3JMb2NhdGlvbi5saW5lSW5kZXgsIGN1cnNvckxvY2F0aW9uLmNoYXJJbmRleClcbiAgICAgICAgICAqICgxIC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogdG9wT2Zmc2V0LFxuICAgICAgICBsZWZ0OiBsZWZ0T2Zmc2V0LFxuICAgICAgICBsaW5lTGVmdDogbGluZUxlZnRPZmZzZXRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIGdldE1pbldpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLm1pbldpZHRoLCB0aGlzLmR5bmFtaWNNaW5XaWR0aCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQG1ldGhvZCB0b09iamVjdFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JywgWydtaW5XaWR0aCddLmNvbmNhdChwcm9wZXJ0aWVzVG9JbmNsdWRlKSk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuVGV4dGJveCBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dGJveFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGZhYnJpYy5UZXh0Ym94IGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VBc3luY10gRm9yY2UgYW4gYXN5bmMgYmVoYXZpb3VyIHRyeWluZyB0byBjcmVhdGUgcGF0dGVybiBmaXJzdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dGJveH0gaW5zdGFuY2Ugb2YgZmFicmljLlRleHRib3hcbiAgICovXG4gIGZhYnJpYy5UZXh0Ym94LmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrLCBmb3JjZUFzeW5jKSB7XG4gICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1RleHRib3gnLCBvYmplY3QsIGNhbGxiYWNrLCBmb3JjZUFzeW5jLCAndGV4dCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IGNvbnRyb2xzIHZpc2liaWxpdHkgcmVxdWlyZWQgZm9yIFRleHRib3hlcy5cbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIGZhYnJpYy5UZXh0Ym94LmdldFRleHRib3hDb250cm9sVmlzaWJpbGl0eSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0bDogZmFsc2UsXG4gICAgICB0cjogZmFsc2UsXG4gICAgICBicjogZmFsc2UsXG4gICAgICBibDogZmFsc2UsXG4gICAgICBtbDogdHJ1ZSxcbiAgICAgIG10OiBmYWxzZSxcbiAgICAgIG1yOiB0cnVlLFxuICAgICAgbWI6IGZhbHNlLFxuICAgICAgbXRyOiB0cnVlXG4gICAgfTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgX3NldE9iamVjdFNjYWxlIGFuZCBhZGQgVGV4dGJveCBzcGVjaWZpYyByZXNpemluZyBiZWhhdmlvci4gUmVzaXppbmdcbiAgICogYSBUZXh0Ym94IGRvZXNuJ3Qgc2NhbGUgdGV4dCwgaXQgb25seSBjaGFuZ2VzIHdpZHRoIGFuZCBtYWtlcyB0ZXh0IHdyYXAgYXV0b21hdGljYWxseS5cbiAgICovXG4gIHZhciBzZXRPYmplY3RTY2FsZU92ZXJyaWRkZW4gPSBmYWJyaWMuQ2FudmFzLnByb3RvdHlwZS5fc2V0T2JqZWN0U2NhbGU7XG5cbiAgZmFicmljLkNhbnZhcy5wcm90b3R5cGUuX3NldE9iamVjdFNjYWxlID0gZnVuY3Rpb24obG9jYWxNb3VzZSwgdHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NrU2NhbGluZ1gsIGxvY2tTY2FsaW5nWSwgYnksIGxvY2tTY2FsaW5nRmxpcCwgX2RpbSkge1xuXG4gICAgdmFyIHQgPSB0cmFuc2Zvcm0udGFyZ2V0O1xuICAgIGlmICh0IGluc3RhbmNlb2YgZmFicmljLlRleHRib3gpIHtcbiAgICAgIHZhciB3ID0gdC53aWR0aCAqICgobG9jYWxNb3VzZS54IC8gdHJhbnNmb3JtLnNjYWxlWCkgLyAodC53aWR0aCArIHQuc3Ryb2tlV2lkdGgpKTtcbiAgICAgIGlmICh3ID49IHQuZ2V0TWluV2lkdGgoKSkge1xuICAgICAgICB0LnNldCgnd2lkdGgnLCB3KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHNldE9iamVjdFNjYWxlT3ZlcnJpZGRlbi5jYWxsKGZhYnJpYy5DYW52YXMucHJvdG90eXBlLCBsb2NhbE1vdXNlLCB0cmFuc2Zvcm0sXG4gICAgICAgIGxvY2tTY2FsaW5nWCwgbG9ja1NjYWxpbmdZLCBieSwgbG9ja1NjYWxpbmdGbGlwLCBfZGltKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgY29udHJvbHMgb2YgdGhpcyBncm91cCB0byB0aGUgVGV4dGJveCdzIHNwZWNpYWwgY29uZmlndXJhdGlvbiBpZlxuICAgKiBvbmUgaXMgcHJlc2VudCBpbiB0aGUgZ3JvdXAuIERlbGV0ZXMgX2NvbnRyb2xzVmlzaWJpbGl0eSBvdGhlcndpc2UsIHNvIHRoYXRcbiAgICogaXQgZ2V0cyBpbml0aWFsaXplZCB0byBkZWZhdWx0IHZhbHVlIGF0IHJ1bnRpbWUuXG4gICAqL1xuICBmYWJyaWMuR3JvdXAucHJvdG90eXBlLl9yZWZyZXNoQ29udHJvbHNWaXNpYmlsaXR5ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHR5cGVvZiBmYWJyaWMuVGV4dGJveCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICBpZiAodGhpcy5fb2JqZWN0c1tpXSBpbnN0YW5jZW9mIGZhYnJpYy5UZXh0Ym94KSB7XG4gICAgICAgIHRoaXMuc2V0Q29udHJvbHNWaXNpYmlsaXR5KGZhYnJpYy5UZXh0Ym94LmdldFRleHRib3hDb250cm9sVmlzaWJpbGl0eSgpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmU7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuVGV4dGJveC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLklUZXh0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVtb3ZlRXh0cmFuZW91c1N0eWxlczogZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIHRoaXMuX3N0eWxlTWFwKSB7XG4gICAgICAgIGlmICghdGhpcy5fdGV4dExpbmVzW3Byb3BdKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW3RoaXMuX3N0eWxlTWFwW3Byb3BdLmxpbmVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgc3R5bGUgb2JqZWN0IGZvciBhIGdpdmVuIGxpbmUvY2hhciBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggSW5kZXggb2YgYSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleCBJbmRleCBvZiBhIGNoYXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0eWxlXSBTdHlsZSBvYmplY3QgdG8gaW5zZXJ0LCBpZiBnaXZlblxuICAgICAqL1xuICAgIGluc2VydENoYXJTdHlsZU9iamVjdDogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgsIHN0eWxlKSB7XG4gICAgICAvLyBhZGp1c3QgbGluZUluZGV4IGFuZCBjaGFySW5kZXhcbiAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgbGluZUluZGV4ID0gbWFwLmxpbmU7XG4gICAgICBjaGFySW5kZXggPSBtYXAub2Zmc2V0ICsgY2hhckluZGV4O1xuXG4gICAgICBmYWJyaWMuSVRleHQucHJvdG90eXBlLmluc2VydENoYXJTdHlsZU9iamVjdC5hcHBseSh0aGlzLCBbbGluZUluZGV4LCBjaGFySW5kZXgsIHN0eWxlXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgbmV3IHN0eWxlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggSW5kZXggb2YgYSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleCBJbmRleCBvZiBhIGNoYXJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzRW5kT2ZMaW5lIFRydWUgaWYgaXQncyBlbmQgb2YgbGluZVxuICAgICAqL1xuICAgIGluc2VydE5ld2xpbmVTdHlsZU9iamVjdDogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgsIGlzRW5kT2ZMaW5lKSB7XG4gICAgICAvLyBhZGp1c3QgbGluZUluZGV4IGFuZCBjaGFySW5kZXhcbiAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgbGluZUluZGV4ID0gbWFwLmxpbmU7XG4gICAgICBjaGFySW5kZXggPSBtYXAub2Zmc2V0ICsgY2hhckluZGV4O1xuXG4gICAgICBmYWJyaWMuSVRleHQucHJvdG90eXBlLmluc2VydE5ld2xpbmVTdHlsZU9iamVjdC5hcHBseSh0aGlzLCBbbGluZUluZGV4LCBjaGFySW5kZXgsIGlzRW5kT2ZMaW5lXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNoaWZ0cyBsaW5lIHN0eWxlcyB1cCBvciBkb3duLiBUaGlzIGZ1bmN0aW9uIGlzIHNsaWdodGx5IGRpZmZlcmVudCB0aGFuIHRoZSBvbmUgaW5cbiAgICAgKiBpdGV4dF9iZWhhdmlvdXIgYXMgaXQgdGFrZXMgaW50byBhY2NvdW50IHRoZSBzdHlsZU1hcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggSW5kZXggb2YgYSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBDYW4gYmUgLTEgb3IgKzFcbiAgICAgKi9cbiAgICBzaGlmdExpbmVTdHlsZXM6IGZ1bmN0aW9uKGxpbmVJbmRleCwgb2Zmc2V0KSB7XG4gICAgICAvLyBzaGlmdCBhbGwgbGluZSBzdHlsZXMgYnkgMSB1cHdhcmRcbiAgICAgIHZhciBjbG9uZWRTdHlsZXMgPSBjbG9uZSh0aGlzLnN0eWxlcyksXG4gICAgICAgICAgbWFwICAgICAgICAgID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4XTtcblxuICAgICAgLy8gYWRqdXN0IGxpbmUgaW5kZXhcbiAgICAgIGxpbmVJbmRleCA9IG1hcC5saW5lO1xuXG4gICAgICBmb3IgKHZhciBsaW5lIGluIHRoaXMuc3R5bGVzKSB7XG4gICAgICAgIHZhciBudW1lcmljTGluZSA9IHBhcnNlSW50KGxpbmUsIDEwKTtcblxuICAgICAgICBpZiAobnVtZXJpY0xpbmUgPiBsaW5lSW5kZXgpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlc1tudW1lcmljTGluZSArIG9mZnNldF0gPSBjbG9uZWRTdHlsZXNbbnVtZXJpY0xpbmVdO1xuXG4gICAgICAgICAgaWYgKCFjbG9uZWRTdHlsZXNbbnVtZXJpY0xpbmUgLSBvZmZzZXRdKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbnVtZXJpY0xpbmVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9UT0RPOiBldmFsdWF0ZSBpZiBkZWxldGUgb2xkIHN0eWxlIGxpbmVzIHdpdGggb2Zmc2V0IC0xXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpZ3VyZSBvdXQgcHJvZ3JhbWF0aWNhbGx5IHRoZSB0ZXh0IG9uIHByZXZpb3VzIGFjdHVhbCBsaW5lIChhY3R1YWwgPSBzZXBhcmF0ZWQgYnkgXFxuKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFRleHRPblByZXZpb3VzTGluZTogZnVuY3Rpb24obEluZGV4KSB7XG4gICAgICB2YXIgdGV4dE9uUHJldmlvdXNMaW5lID0gdGhpcy5fdGV4dExpbmVzW2xJbmRleCAtIDFdO1xuXG4gICAgICB3aGlsZSAodGhpcy5fc3R5bGVNYXBbbEluZGV4IC0gMl0gJiYgdGhpcy5fc3R5bGVNYXBbbEluZGV4IC0gMl0ubGluZSA9PT0gdGhpcy5fc3R5bGVNYXBbbEluZGV4IC0gMV0ubGluZSkge1xuICAgICAgICB0ZXh0T25QcmV2aW91c0xpbmUgPSB0aGlzLl90ZXh0TGluZXNbbEluZGV4IC0gMl0gKyB0ZXh0T25QcmV2aW91c0xpbmU7XG5cbiAgICAgICAgbEluZGV4LS07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ZXh0T25QcmV2aW91c0xpbmU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgc3R5bGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc0JlZ2lubmluZ09mTGluZSBUcnVlIGlmIGN1cnNvciBpcyBhdCB0aGUgYmVnaW5uaW5nIG9mIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4XSBPcHRpb25hbCBpbmRleC4gV2hlbiBub3QgZ2l2ZW4sIGN1cnJlbnQgc2VsZWN0aW9uU3RhcnQgaXMgdXNlZC5cbiAgICAgKi9cbiAgICByZW1vdmVTdHlsZU9iamVjdDogZnVuY3Rpb24oaXNCZWdpbm5pbmdPZkxpbmUsIGluZGV4KSB7XG5cbiAgICAgIHZhciBjdXJzb3JMb2NhdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihpbmRleCksXG4gICAgICAgICAgbWFwICAgICAgICAgICAgPSB0aGlzLl9zdHlsZU1hcFtjdXJzb3JMb2NhdGlvbi5saW5lSW5kZXhdLFxuICAgICAgICAgIGxpbmVJbmRleCAgICAgID0gbWFwLmxpbmUsXG4gICAgICAgICAgY2hhckluZGV4ICAgICAgPSBtYXAub2Zmc2V0ICsgY3Vyc29yTG9jYXRpb24uY2hhckluZGV4O1xuICAgICAgdGhpcy5fcmVtb3ZlU3R5bGVPYmplY3QoaXNCZWdpbm5pbmdPZkxpbmUsIGN1cnNvckxvY2F0aW9uLCBsaW5lSW5kZXgsIGNoYXJJbmRleCk7XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgb3ZlcnJpZGUgPSBmYWJyaWMuSVRleHQucHJvdG90eXBlLl9nZXROZXdTZWxlY3Rpb25TdGFydEZyb21PZmZzZXQ7XG4gIC8qKlxuICAgKiBPdmVycmlkZXMgdGhlIElUZXh0IGltcGxlbWVudGF0aW9uIGFuZCBhZGp1c3RzIGNoYXJhY3RlciBpbmRleCBhcyB0aGVyZSBpcyBub3QgYWx3YXlzIGEgbGluZWJyZWFrXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtb3VzZU9mZnNldFxuICAgKiBAcGFyYW0ge051bWJlcn0gcHJldldpZHRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGpsZW5cbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG4gIGZhYnJpYy5JVGV4dC5wcm90b3R5cGUuX2dldE5ld1NlbGVjdGlvblN0YXJ0RnJvbU9mZnNldCA9IGZ1bmN0aW9uKG1vdXNlT2Zmc2V0LCBwcmV2V2lkdGgsIHdpZHRoLCBpbmRleCwgamxlbikge1xuICAgIGluZGV4ID0gb3ZlcnJpZGUuY2FsbCh0aGlzLCBtb3VzZU9mZnNldCwgcHJldldpZHRoLCB3aWR0aCwgaW5kZXgsIGpsZW4pO1xuXG4gICAgLy8gdGhlIGluZGV4IHBhc3NlZCBpbnRvIHRoZSBmdW5jdGlvbiBpcyBwYWRkZWQgYnkgdGhlIGFtb3VudCBvZiBsaW5lcyBmcm9tIF90ZXh0TGluZXMgKHRvIGFjY291bnQgZm9yIFxcbilcbiAgICAvLyB3ZSBuZWVkIHRvIHJlbW92ZSB0aGlzIHBhZGRpbmcsIGFuZCBwYWQgaXQgYnkgYWN0dWFsIGxpbmVzLCBhbmQgLyBvciBzcGFjZXMgdGhhdCBhcmUgbWVhbnQgdG8gYmUgdGhlcmVcbiAgICB2YXIgdG1wICAgICA9IDAsXG4gICAgICAgIHJlbW92ZWQgPSAwO1xuXG4gICAgLy8gYWNjb3VudCBmb3IgcmVtb3ZlZCBjaGFyYWN0ZXJzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRtcCArPSB0aGlzLl90ZXh0TGluZXNbaV0ubGVuZ3RoO1xuXG4gICAgICBpZiAodG1wICsgcmVtb3ZlZCA+PSBpbmRleCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudGV4dFt0bXAgKyByZW1vdmVkXSA9PT0gJ1xcbicgfHwgdGhpcy50ZXh0W3RtcCArIHJlbW92ZWRdID09PSAnICcpIHtcbiAgICAgICAgcmVtb3ZlZCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmRleCAtIGkgKyByZW1vdmVkO1xuICB9O1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgRE9NUGFyc2VyID0gcmVxdWlyZSgneG1sZG9tJykuRE9NUGFyc2VyLFxuICAgICAgVVJMID0gcmVxdWlyZSgndXJsJyksXG4gICAgICBIVFRQID0gcmVxdWlyZSgnaHR0cCcpLFxuICAgICAgSFRUUFMgPSByZXF1aXJlKCdodHRwcycpLFxuXG4gICAgICBDYW52YXMgPSByZXF1aXJlKCdjYW52YXMnKSxcbiAgICAgIEltYWdlID0gcmVxdWlyZSgnY2FudmFzJykuSW1hZ2U7XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGZ1bmN0aW9uIHJlcXVlc3QodXJsLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICB2YXIgb1VSTCA9IFVSTC5wYXJzZSh1cmwpO1xuXG4gICAgLy8gZGV0ZWN0IGlmIGh0dHAgb3IgaHR0cHMgaXMgdXNlZFxuICAgIGlmICggIW9VUkwucG9ydCApIHtcbiAgICAgIG9VUkwucG9ydCA9ICggb1VSTC5wcm90b2NvbC5pbmRleE9mKCdodHRwczonKSA9PT0gMCApID8gNDQzIDogODA7XG4gICAgfVxuXG4gICAgLy8gYXNzaWduIHJlcXVlc3QgaGFuZGxlciBiYXNlZCBvbiBwcm90b2NvbFxuICAgIHZhciByZXFIYW5kbGVyID0gKG9VUkwucHJvdG9jb2wuaW5kZXhPZignaHR0cHM6JykgPT09IDAgKSA/IEhUVFBTIDogSFRUUCxcbiAgICAgICAgcmVxID0gcmVxSGFuZGxlci5yZXF1ZXN0KHtcbiAgICAgICAgICBob3N0bmFtZTogb1VSTC5ob3N0bmFtZSxcbiAgICAgICAgICBwb3J0OiBvVVJMLnBvcnQsXG4gICAgICAgICAgcGF0aDogb1VSTC5wYXRoLFxuICAgICAgICAgIG1ldGhvZDogJ0dFVCdcbiAgICAgICAgfSwgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICB2YXIgYm9keSA9ICcnO1xuICAgICAgICAgIGlmIChlbmNvZGluZykge1xuICAgICAgICAgICAgcmVzcG9uc2Uuc2V0RW5jb2RpbmcoZW5jb2RpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNwb25zZS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FsbGJhY2soYm9keSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVzcG9uc2Uub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgICAgICAgICAgYm9keSArPSBjaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoZXJyLmVycm5vID09PSBwcm9jZXNzLkVDT05OUkVGVVNFRCkge1xuICAgICAgICBmYWJyaWMubG9nKCdFQ09OTlJFRlVTRUQ6IGNvbm5lY3Rpb24gcmVmdXNlZCB0byAnICsgb1VSTC5ob3N0bmFtZSArICc6JyArIG9VUkwucG9ydCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZmFicmljLmxvZyhlcnIubWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9KTtcblxuICAgIHJlcS5lbmQoKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBmdW5jdGlvbiByZXF1ZXN0RnMocGF0aCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuICAgIGZzLnJlYWRGaWxlKHBhdGgsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZmFicmljLmxvZyhlcnIpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmYWJyaWMudXRpbC5sb2FkSW1hZ2UgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlSW1hZ2VBbmRDYWxsQmFjayhkYXRhKSB7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBpbWcuc3JjID0gbmV3IEJ1ZmZlcihkYXRhLCAnYmluYXJ5Jyk7XG4gICAgICAgIC8vIHByZXNlcnZpbmcgb3JpZ2luYWwgdXJsLCB3aGljaCBzZWVtcyB0byBiZSBsb3N0IGluIG5vZGUtY2FudmFzXG4gICAgICAgIGltZy5fc3JjID0gdXJsO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGltZyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaW1nID0gbnVsbDtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbChjb250ZXh0LCBudWxsLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGlmICh1cmwgJiYgKHVybCBpbnN0YW5jZW9mIEJ1ZmZlciB8fCB1cmwuaW5kZXhPZignZGF0YScpID09PSAwKSkge1xuICAgICAgaW1nLnNyYyA9IGltZy5fc3JjID0gdXJsO1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbChjb250ZXh0LCBpbWcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh1cmwgJiYgdXJsLmluZGV4T2YoJ2h0dHAnKSAhPT0gMCkge1xuICAgICAgcmVxdWVzdEZzKHVybCwgY3JlYXRlSW1hZ2VBbmRDYWxsQmFjayk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHVybCkge1xuICAgICAgcmVxdWVzdCh1cmwsICdiaW5hcnknLCBjcmVhdGVJbWFnZUFuZENhbGxCYWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGNvbnRleHQsIHVybCk7XG4gICAgfVxuICB9O1xuXG4gIGZhYnJpYy5sb2FkU1ZHRnJvbVVSTCA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2ssIHJldml2ZXIpIHtcbiAgICB1cmwgPSB1cmwucmVwbGFjZSgvXlxcblxccyovLCAnJykucmVwbGFjZSgvXFw/LiokLywgJycpLnRyaW0oKTtcbiAgICBpZiAodXJsLmluZGV4T2YoJ2h0dHAnKSAhPT0gMCkge1xuICAgICAgcmVxdWVzdEZzKHVybCwgZnVuY3Rpb24oYm9keSkge1xuICAgICAgICBmYWJyaWMubG9hZFNWR0Zyb21TdHJpbmcoYm9keS50b1N0cmluZygpLCBjYWxsYmFjaywgcmV2aXZlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXF1ZXN0KHVybCwgJycsIGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgICAgZmFicmljLmxvYWRTVkdGcm9tU3RyaW5nKGJvZHksIGNhbGxiYWNrLCByZXZpdmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBmYWJyaWMubG9hZFNWR0Zyb21TdHJpbmcgPSBmdW5jdGlvbihzdHJpbmcsIGNhbGxiYWNrLCByZXZpdmVyKSB7XG4gICAgdmFyIGRvYyA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoc3RyaW5nKTtcbiAgICBmYWJyaWMucGFyc2VTVkdEb2N1bWVudChkb2MuZG9jdW1lbnRFbGVtZW50LCBmdW5jdGlvbihyZXN1bHRzLCBvcHRpb25zKSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZXN1bHRzLCBvcHRpb25zKTtcbiAgICB9LCByZXZpdmVyKTtcbiAgfTtcblxuICBmYWJyaWMudXRpbC5nZXRTY3JpcHQgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XG4gICAgcmVxdWVzdCh1cmwsICcnLCBmdW5jdGlvbihib2R5KSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXZhbFxuICAgICAgZXZhbChib2R5KTtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCA9IGZ1bmN0aW9uKF8sIHdpZHRoLCBoZWlnaHQpIHtcbiAgLy8gICByZXR1cm4gbmV3IENhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgLy8gfVxuXG4gIC8qKlxuICAgKiBPbmx5IGF2YWlsYWJsZSB3aGVuIHJ1bm5pbmcgZmFicmljIG9uIG5vZGUuanNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIENhbnZhcyB3aWR0aFxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IENhbnZhcyBoZWlnaHRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdG8gRmFicmljQ2FudmFzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW25vZGVDYW52YXNPcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdG8gTm9kZUNhbnZhcy5cbiAgICogQHJldHVybiB7T2JqZWN0fSB3cmFwcGVkIGNhbnZhcyBpbnN0YW5jZVxuICAgKi9cbiAgZmFicmljLmNyZWF0ZUNhbnZhc0Zvck5vZGUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBvcHRpb25zLCBub2RlQ2FudmFzT3B0aW9ucykge1xuICAgIG5vZGVDYW52YXNPcHRpb25zID0gbm9kZUNhbnZhc09wdGlvbnMgfHwgb3B0aW9ucztcblxuICAgIHZhciBjYW52YXNFbCA9IGZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSxcbiAgICAgICAgbm9kZUNhbnZhcyA9IG5ldyBDYW52YXMod2lkdGggfHwgNjAwLCBoZWlnaHQgfHwgNjAwLCBub2RlQ2FudmFzT3B0aW9ucyksXG4gICAgICAgIG5vZGVDYWNoZUNhbnZhcyA9IG5ldyBDYW52YXMod2lkdGggfHwgNjAwLCBoZWlnaHQgfHwgNjAwLCBub2RlQ2FudmFzT3B0aW9ucyk7XG5cbiAgICAvLyBqc2RvbSBkb2Vzbid0IGNyZWF0ZSBzdHlsZSBvbiBjYW52YXMgZWxlbWVudCwgc28gaGVyZSBiZSB0ZW1wLiB3b3JrYXJvdW5kXG4gICAgY2FudmFzRWwuc3R5bGUgPSB7IH07XG5cbiAgICBjYW52YXNFbC53aWR0aCA9IG5vZGVDYW52YXMud2lkdGg7XG4gICAgY2FudmFzRWwuaGVpZ2h0ID0gbm9kZUNhbnZhcy5oZWlnaHQ7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuICAgIG9wdGlvbnMubm9kZUNhbnZhcyA9IG5vZGVDYW52YXM7XG4gICAgb3B0aW9ucy5ub2RlQ2FjaGVDYW52YXMgPSBub2RlQ2FjaGVDYW52YXM7XG4gICAgdmFyIEZhYnJpY0NhbnZhcyA9IGZhYnJpYy5DYW52YXMgfHwgZmFicmljLlN0YXRpY0NhbnZhcyxcbiAgICAgICAgZmFicmljQ2FudmFzID0gbmV3IEZhYnJpY0NhbnZhcyhjYW52YXNFbCwgb3B0aW9ucyk7XG4gICAgZmFicmljQ2FudmFzLm5vZGVDYW52YXMgPSBub2RlQ2FudmFzO1xuICAgIGZhYnJpY0NhbnZhcy5ub2RlQ2FjaGVDYW52YXMgPSBub2RlQ2FjaGVDYW52YXM7XG4gICAgZmFicmljQ2FudmFzLmNvbnRleHRDb250YWluZXIgPSBub2RlQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgZmFicmljQ2FudmFzLmNvbnRleHRDYWNoZSA9IG5vZGVDYWNoZUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGZhYnJpY0NhbnZhcy5Gb250ID0gQ2FudmFzLkZvbnQ7XG4gICAgcmV0dXJuIGZhYnJpY0NhbnZhcztcbiAgfTtcblxuICB2YXIgb3JpZ2luYUluaXRTdGF0aWMgPSBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5faW5pdFN0YXRpYztcbiAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuX2luaXRTdGF0aWMgPSBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xuICAgIGVsID0gZWwgfHwgZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHRoaXMubm9kZUNhbnZhcyA9IG5ldyBDYW52YXMoZWwud2lkdGgsIGVsLmhlaWdodCk7XG4gICAgdGhpcy5ub2RlQ2FjaGVDYW52YXMgPSBuZXcgQ2FudmFzKGVsLndpZHRoLCBlbC5oZWlnaHQpO1xuICAgIG9yaWdpbmFJbml0U3RhdGljLmNhbGwodGhpcywgZWwsIG9wdGlvbnMpO1xuICAgIHRoaXMuY29udGV4dENvbnRhaW5lciA9IHRoaXMubm9kZUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRoaXMuY29udGV4dENhY2hlID0gdGhpcy5ub2RlQ2FjaGVDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLkZvbnQgPSBDYW52YXMuRm9udDtcbiAgfTtcblxuICAvKiogQGlnbm9yZSAqL1xuICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5jcmVhdGVQTkdTdHJlYW0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlQ2FudmFzLmNyZWF0ZVBOR1N0cmVhbSgpO1xuICB9O1xuXG4gIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLmNyZWF0ZUpQRUdTdHJlYW0gPSBmdW5jdGlvbihvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZUNhbnZhcy5jcmVhdGVKUEVHU3RyZWFtKG9wdHMpO1xuICB9O1xuXG4gIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLl9pbml0UmV0aW5hU2NhbGluZyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5faXNSZXRpbmFTY2FsaW5nKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmxvd2VyQ2FudmFzRWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMud2lkdGggKiBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgdGhpcy5sb3dlckNhbnZhc0VsLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5oZWlnaHQgKiBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgdGhpcy5ub2RlQ2FudmFzLndpZHRoID0gdGhpcy53aWR0aCAqIGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIHRoaXMubm9kZUNhbnZhcy5oZWlnaHQgPSB0aGlzLmhlaWdodCAqIGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIHRoaXMuY29udGV4dENvbnRhaW5lci5zY2FsZShmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbywgZmFicmljLmRldmljZVBpeGVsUmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBpZiAoZmFicmljLkNhbnZhcykge1xuICAgIGZhYnJpYy5DYW52YXMucHJvdG90eXBlLl9pbml0UmV0aW5hU2NhbGluZyA9IGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLl9pbml0UmV0aW5hU2NhbGluZztcbiAgfVxuXG4gIHZhciBvcmlnU2V0QmFja3N0b3JlRGltZW5zaW9uID0gZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuX3NldEJhY2tzdG9yZURpbWVuc2lvbjtcbiAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuX3NldEJhY2tzdG9yZURpbWVuc2lvbiA9IGZ1bmN0aW9uKHByb3AsIHZhbHVlKSB7XG4gICAgb3JpZ1NldEJhY2tzdG9yZURpbWVuc2lvbi5jYWxsKHRoaXMsIHByb3AsIHZhbHVlKTtcbiAgICB0aGlzLm5vZGVDYW52YXNbcHJvcF0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgaWYgKGZhYnJpYy5DYW52YXMpIHtcbiAgICBmYWJyaWMuQ2FudmFzLnByb3RvdHlwZS5fc2V0QmFja3N0b3JlRGltZW5zaW9uID0gZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuX3NldEJhY2tzdG9yZURpbWVuc2lvbjtcbiAgfVxuXG59KSgpO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2ZhYnJpYy9kaXN0L2ZhYnJpYy5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2J1ZmZlci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICByZXR1cm4gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIHJldHVybiBiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgcGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxuXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cblxuICB2YXIgTCA9IDBcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJ1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPT0nXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSlcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9J1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpXG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2Jhc2U2NC1qcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vaWVlZTc1NC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vaXNhcnJheS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogKGlnbm9yZWQpICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8ganNkb20gKGlnbm9yZWQpXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIChpZ25vcmVkKSAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGNhbnZhcyAoaWdub3JlZClcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIChpZ25vcmVkKSAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIHhtbGRvbSAoaWdub3JlZClcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi91cmwvdXJsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjMuMiBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS4zLjInLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdXJsL34vcHVueWNvZGUvcHVueWNvZGUuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi93ZWJwYWNrL2J1aWxkaW4vbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3VybC91dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcXVlcnlzdHJpbmcvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcXVlcnlzdHJpbmcvZGVjb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG9ialtrXS5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9xdWVyeXN0cmluZy9lbmNvZGUuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGllbnRSZXF1ZXN0ID0gcmVxdWlyZSgnLi9saWIvcmVxdWVzdCcpXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIHN0YXR1c0NvZGVzID0gcmVxdWlyZSgnYnVpbHRpbi1zdGF0dXMtY29kZXMnKVxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpXG5cbnZhciBodHRwID0gZXhwb3J0c1xuXG5odHRwLnJlcXVlc3QgPSBmdW5jdGlvbiAob3B0cywgY2IpIHtcblx0aWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJylcblx0XHRvcHRzID0gdXJsLnBhcnNlKG9wdHMpXG5cdGVsc2Vcblx0XHRvcHRzID0gZXh0ZW5kKG9wdHMpXG5cblx0Ly8gTm9ybWFsbHksIHRoZSBwYWdlIGlzIGxvYWRlZCBmcm9tIGh0dHAgb3IgaHR0cHMsIHNvIG5vdCBzcGVjaWZ5aW5nIGEgcHJvdG9jb2xcblx0Ly8gd2lsbCByZXN1bHQgaW4gYSAodmFsaWQpIHByb3RvY29sLXJlbGF0aXZlIHVybC4gSG93ZXZlciwgdGhpcyB3b24ndCB3b3JrIGlmXG5cdC8vIHRoZSBwcm90b2NvbCBpcyBzb21ldGhpbmcgZWxzZSwgbGlrZSAnZmlsZTonXG5cdHZhciBkZWZhdWx0UHJvdG9jb2wgPSBnbG9iYWwubG9jYXRpb24ucHJvdG9jb2wuc2VhcmNoKC9eaHR0cHM/OiQvKSA9PT0gLTEgPyAnaHR0cDonIDogJydcblxuXHR2YXIgcHJvdG9jb2wgPSBvcHRzLnByb3RvY29sIHx8IGRlZmF1bHRQcm90b2NvbFxuXHR2YXIgaG9zdCA9IG9wdHMuaG9zdG5hbWUgfHwgb3B0cy5ob3N0XG5cdHZhciBwb3J0ID0gb3B0cy5wb3J0XG5cdHZhciBwYXRoID0gb3B0cy5wYXRoIHx8ICcvJ1xuXG5cdC8vIE5lY2Vzc2FyeSBmb3IgSVB2NiBhZGRyZXNzZXNcblx0aWYgKGhvc3QgJiYgaG9zdC5pbmRleE9mKCc6JykgIT09IC0xKVxuXHRcdGhvc3QgPSAnWycgKyBob3N0ICsgJ10nXG5cblx0Ly8gVGhpcyBtYXkgYmUgYSByZWxhdGl2ZSB1cmwuIFRoZSBicm93c2VyIHNob3VsZCBhbHdheXMgYmUgYWJsZSB0byBpbnRlcnByZXQgaXQgY29ycmVjdGx5LlxuXHRvcHRzLnVybCA9IChob3N0ID8gKHByb3RvY29sICsgJy8vJyArIGhvc3QpIDogJycpICsgKHBvcnQgPyAnOicgKyBwb3J0IDogJycpICsgcGF0aFxuXHRvcHRzLm1ldGhvZCA9IChvcHRzLm1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKVxuXHRvcHRzLmhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge31cblxuXHQvLyBBbHNvIHZhbGlkIG9wdHMuYXV0aCwgb3B0cy5tb2RlXG5cblx0dmFyIHJlcSA9IG5ldyBDbGllbnRSZXF1ZXN0KG9wdHMpXG5cdGlmIChjYilcblx0XHRyZXEub24oJ3Jlc3BvbnNlJywgY2IpXG5cdHJldHVybiByZXFcbn1cblxuaHR0cC5nZXQgPSBmdW5jdGlvbiBnZXQgKG9wdHMsIGNiKSB7XG5cdHZhciByZXEgPSBodHRwLnJlcXVlc3Qob3B0cywgY2IpXG5cdHJlcS5lbmQoKVxuXHRyZXR1cm4gcmVxXG59XG5cbmh0dHAuQWdlbnQgPSBmdW5jdGlvbiAoKSB7fVxuaHR0cC5BZ2VudC5kZWZhdWx0TWF4U29ja2V0cyA9IDRcblxuaHR0cC5TVEFUVVNfQ09ERVMgPSBzdGF0dXNDb2Rlc1xuXG5odHRwLk1FVEhPRFMgPSBbXG5cdCdDSEVDS09VVCcsXG5cdCdDT05ORUNUJyxcblx0J0NPUFknLFxuXHQnREVMRVRFJyxcblx0J0dFVCcsXG5cdCdIRUFEJyxcblx0J0xPQ0snLFxuXHQnTS1TRUFSQ0gnLFxuXHQnTUVSR0UnLFxuXHQnTUtBQ1RJVklUWScsXG5cdCdNS0NPTCcsXG5cdCdNT1ZFJyxcblx0J05PVElGWScsXG5cdCdPUFRJT05TJyxcblx0J1BBVENIJyxcblx0J1BPU1QnLFxuXHQnUFJPUEZJTkQnLFxuXHQnUFJPUFBBVENIJyxcblx0J1BVUkdFJyxcblx0J1BVVCcsXG5cdCdSRVBPUlQnLFxuXHQnU0VBUkNIJyxcblx0J1NVQlNDUklCRScsXG5cdCdUUkFDRScsXG5cdCdVTkxPQ0snLFxuXHQnVU5TVUJTQ1JJQkUnXG5dXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9zdHJlYW0taHR0cC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL2NhcGFiaWxpdHknKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHJlc3BvbnNlID0gcmVxdWlyZSgnLi9yZXNwb25zZScpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcbnZhciB0b0FycmF5QnVmZmVyID0gcmVxdWlyZSgndG8tYXJyYXlidWZmZXInKVxuXG52YXIgSW5jb21pbmdNZXNzYWdlID0gcmVzcG9uc2UuSW5jb21pbmdNZXNzYWdlXG52YXIgclN0YXRlcyA9IHJlc3BvbnNlLnJlYWR5U3RhdGVzXG5cbmZ1bmN0aW9uIGRlY2lkZU1vZGUgKHByZWZlckJpbmFyeSwgdXNlRmV0Y2gpIHtcblx0aWYgKGNhcGFiaWxpdHkuZmV0Y2ggJiYgdXNlRmV0Y2gpIHtcblx0XHRyZXR1cm4gJ2ZldGNoJ1xuXHR9IGVsc2UgaWYgKGNhcGFiaWxpdHkubW96Y2h1bmtlZGFycmF5YnVmZmVyKSB7XG5cdFx0cmV0dXJuICdtb3otY2h1bmtlZC1hcnJheWJ1ZmZlcidcblx0fSBlbHNlIGlmIChjYXBhYmlsaXR5Lm1zc3RyZWFtKSB7XG5cdFx0cmV0dXJuICdtcy1zdHJlYW0nXG5cdH0gZWxzZSBpZiAoY2FwYWJpbGl0eS5hcnJheWJ1ZmZlciAmJiBwcmVmZXJCaW5hcnkpIHtcblx0XHRyZXR1cm4gJ2FycmF5YnVmZmVyJ1xuXHR9IGVsc2UgaWYgKGNhcGFiaWxpdHkudmJBcnJheSAmJiBwcmVmZXJCaW5hcnkpIHtcblx0XHRyZXR1cm4gJ3RleHQ6dmJhcnJheSdcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gJ3RleHQnXG5cdH1cbn1cblxudmFyIENsaWVudFJlcXVlc3QgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRzdHJlYW0uV3JpdGFibGUuY2FsbChzZWxmKVxuXG5cdHNlbGYuX29wdHMgPSBvcHRzXG5cdHNlbGYuX2JvZHkgPSBbXVxuXHRzZWxmLl9oZWFkZXJzID0ge31cblx0aWYgKG9wdHMuYXV0aClcblx0XHRzZWxmLnNldEhlYWRlcignQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICsgbmV3IEJ1ZmZlcihvcHRzLmF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKSlcblx0T2JqZWN0LmtleXMob3B0cy5oZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0c2VsZi5zZXRIZWFkZXIobmFtZSwgb3B0cy5oZWFkZXJzW25hbWVdKVxuXHR9KVxuXG5cdHZhciBwcmVmZXJCaW5hcnlcblx0dmFyIHVzZUZldGNoID0gdHJ1ZVxuXHRpZiAob3B0cy5tb2RlID09PSAnZGlzYWJsZS1mZXRjaCcgfHwgJ3RpbWVvdXQnIGluIG9wdHMpIHtcblx0XHQvLyBJZiB0aGUgdXNlIG9mIFhIUiBzaG91bGQgYmUgcHJlZmVycmVkIGFuZCBpbmNsdWRlcyBwcmVzZXJ2aW5nIHRoZSAnY29udGVudC10eXBlJyBoZWFkZXIuXG5cdFx0Ly8gRm9yY2UgWEhSIHRvIGJlIHVzZWQgc2luY2UgdGhlIEZldGNoIEFQSSBkb2VzIG5vdCB5ZXQgc3VwcG9ydCB0aW1lb3V0cy5cblx0XHR1c2VGZXRjaCA9IGZhbHNlXG5cdFx0cHJlZmVyQmluYXJ5ID0gdHJ1ZVxuXHR9IGVsc2UgaWYgKG9wdHMubW9kZSA9PT0gJ3ByZWZlci1zdHJlYW1pbmcnKSB7XG5cdFx0Ly8gSWYgc3RyZWFtaW5nIGlzIGEgaGlnaCBwcmlvcml0eSBidXQgYmluYXJ5IGNvbXBhdGliaWxpdHkgYW5kXG5cdFx0Ly8gdGhlIGFjY3VyYWN5IG9mIHRoZSAnY29udGVudC10eXBlJyBoZWFkZXIgYXJlbid0XG5cdFx0cHJlZmVyQmluYXJ5ID0gZmFsc2Vcblx0fSBlbHNlIGlmIChvcHRzLm1vZGUgPT09ICdhbGxvdy13cm9uZy1jb250ZW50LXR5cGUnKSB7XG5cdFx0Ly8gSWYgc3RyZWFtaW5nIGlzIG1vcmUgaW1wb3J0YW50IHRoYW4gcHJlc2VydmluZyB0aGUgJ2NvbnRlbnQtdHlwZScgaGVhZGVyXG5cdFx0cHJlZmVyQmluYXJ5ID0gIWNhcGFiaWxpdHkub3ZlcnJpZGVNaW1lVHlwZVxuXHR9IGVsc2UgaWYgKCFvcHRzLm1vZGUgfHwgb3B0cy5tb2RlID09PSAnZGVmYXVsdCcgfHwgb3B0cy5tb2RlID09PSAncHJlZmVyLWZhc3QnKSB7XG5cdFx0Ly8gVXNlIGJpbmFyeSBpZiB0ZXh0IHN0cmVhbWluZyBtYXkgY29ycnVwdCBkYXRhIG9yIHRoZSBjb250ZW50LXR5cGUgaGVhZGVyLCBvciBmb3Igc3BlZWRcblx0XHRwcmVmZXJCaW5hcnkgPSB0cnVlXG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBvcHRzLm1vZGUnKVxuXHR9XG5cdHNlbGYuX21vZGUgPSBkZWNpZGVNb2RlKHByZWZlckJpbmFyeSwgdXNlRmV0Y2gpXG5cblx0c2VsZi5vbignZmluaXNoJywgZnVuY3Rpb24gKCkge1xuXHRcdHNlbGYuX29uRmluaXNoKClcblx0fSlcbn1cblxuaW5oZXJpdHMoQ2xpZW50UmVxdWVzdCwgc3RyZWFtLldyaXRhYmxlKVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5zZXRIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdHZhciBsb3dlck5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKClcblx0Ly8gVGhpcyBjaGVjayBpcyBub3QgbmVjZXNzYXJ5LCBidXQgaXQgcHJldmVudHMgd2FybmluZ3MgZnJvbSBicm93c2VycyBhYm91dCBzZXR0aW5nIHVuc2FmZVxuXHQvLyBoZWFkZXJzLiBUbyBiZSBob25lc3QgSSdtIG5vdCBlbnRpcmVseSBzdXJlIGhpZGluZyB0aGVzZSB3YXJuaW5ncyBpcyBhIGdvb2QgdGhpbmcsIGJ1dFxuXHQvLyBodHRwLWJyb3dzZXJpZnkgZGlkIGl0LCBzbyBJIHdpbGwgdG9vLlxuXHRpZiAodW5zYWZlSGVhZGVycy5pbmRleE9mKGxvd2VyTmFtZSkgIT09IC0xKVxuXHRcdHJldHVyblxuXG5cdHNlbGYuX2hlYWRlcnNbbG93ZXJOYW1lXSA9IHtcblx0XHRuYW1lOiBuYW1lLFxuXHRcdHZhbHVlOiB2YWx1ZVxuXHR9XG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLmdldEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRyZXR1cm4gc2VsZi5faGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldLnZhbHVlXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnJlbW92ZUhlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRkZWxldGUgc2VsZi5faGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLl9vbkZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0aWYgKHNlbGYuX2Rlc3Ryb3llZClcblx0XHRyZXR1cm5cblx0dmFyIG9wdHMgPSBzZWxmLl9vcHRzXG5cblx0dmFyIGhlYWRlcnNPYmogPSBzZWxmLl9oZWFkZXJzXG5cdHZhciBib2R5ID0gbnVsbFxuXHRpZiAob3B0cy5tZXRob2QgPT09ICdQT1NUJyB8fCBvcHRzLm1ldGhvZCA9PT0gJ1BVVCcgfHwgb3B0cy5tZXRob2QgPT09ICdQQVRDSCcgfHwgb3B0cy5tZXRob2QgPT09ICdNRVJHRScpIHtcblx0XHRpZiAoY2FwYWJpbGl0eS5ibG9iQ29uc3RydWN0b3IpIHtcblx0XHRcdGJvZHkgPSBuZXcgZ2xvYmFsLkJsb2Ioc2VsZi5fYm9keS5tYXAoZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHRcdFx0XHRyZXR1cm4gdG9BcnJheUJ1ZmZlcihidWZmZXIpXG5cdFx0XHR9KSwge1xuXHRcdFx0XHR0eXBlOiAoaGVhZGVyc09ialsnY29udGVudC10eXBlJ10gfHwge30pLnZhbHVlIHx8ICcnXG5cdFx0XHR9KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBnZXQgdXRmOCBzdHJpbmdcblx0XHRcdGJvZHkgPSBCdWZmZXIuY29uY2F0KHNlbGYuX2JvZHkpLnRvU3RyaW5nKClcblx0XHR9XG5cdH1cblxuXHRpZiAoc2VsZi5fbW9kZSA9PT0gJ2ZldGNoJykge1xuXHRcdHZhciBoZWFkZXJzID0gT2JqZWN0LmtleXMoaGVhZGVyc09iaikubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRyZXR1cm4gW2hlYWRlcnNPYmpbbmFtZV0ubmFtZSwgaGVhZGVyc09ialtuYW1lXS52YWx1ZV1cblx0XHR9KVxuXG5cdFx0Z2xvYmFsLmZldGNoKHNlbGYuX29wdHMudXJsLCB7XG5cdFx0XHRtZXRob2Q6IHNlbGYuX29wdHMubWV0aG9kLFxuXHRcdFx0aGVhZGVyczogaGVhZGVycyxcblx0XHRcdGJvZHk6IGJvZHkgfHwgdW5kZWZpbmVkLFxuXHRcdFx0bW9kZTogJ2NvcnMnLFxuXHRcdFx0Y3JlZGVudGlhbHM6IG9wdHMud2l0aENyZWRlbnRpYWxzID8gJ2luY2x1ZGUnIDogJ3NhbWUtb3JpZ2luJ1xuXHRcdH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdFx0XHRzZWxmLl9mZXRjaFJlc3BvbnNlID0gcmVzcG9uc2Vcblx0XHRcdHNlbGYuX2Nvbm5lY3QoKVxuXHRcdH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcblx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCByZWFzb24pXG5cdFx0fSlcblx0fSBlbHNlIHtcblx0XHR2YXIgeGhyID0gc2VsZi5feGhyID0gbmV3IGdsb2JhbC5YTUxIdHRwUmVxdWVzdCgpXG5cdFx0dHJ5IHtcblx0XHRcdHhoci5vcGVuKHNlbGYuX29wdHMubWV0aG9kLCBzZWxmLl9vcHRzLnVybCwgdHJ1ZSlcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHRcdFx0fSlcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdC8vIENhbid0IHNldCByZXNwb25zZVR5cGUgb24gcmVhbGx5IG9sZCBicm93c2Vyc1xuXHRcdGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIpXG5cdFx0XHR4aHIucmVzcG9uc2VUeXBlID0gc2VsZi5fbW9kZS5zcGxpdCgnOicpWzBdXG5cblx0XHRpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKVxuXHRcdFx0eGhyLndpdGhDcmVkZW50aWFscyA9ICEhb3B0cy53aXRoQ3JlZGVudGlhbHNcblxuXHRcdGlmIChzZWxmLl9tb2RlID09PSAndGV4dCcgJiYgJ292ZXJyaWRlTWltZVR5cGUnIGluIHhocilcblx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCd0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkJylcblxuXHRcdGlmICgndGltZW91dCcgaW4gb3B0cykge1xuXHRcdFx0eGhyLnRpbWVvdXQgPSBvcHRzLnRpbWVvdXRcblx0XHRcdHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNlbGYuZW1pdCgndGltZW91dCcpXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0T2JqZWN0LmtleXMoaGVhZGVyc09iaikuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyc09ialtuYW1lXS5uYW1lLCBoZWFkZXJzT2JqW25hbWVdLnZhbHVlKVxuXHRcdH0pXG5cblx0XHRzZWxmLl9yZXNwb25zZSA9IG51bGxcblx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0c3dpdGNoICh4aHIucmVhZHlTdGF0ZSkge1xuXHRcdFx0XHRjYXNlIHJTdGF0ZXMuTE9BRElORzpcblx0XHRcdFx0Y2FzZSByU3RhdGVzLkRPTkU6XG5cdFx0XHRcdFx0c2VsZi5fb25YSFJQcm9ncmVzcygpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gTmVjZXNzYXJ5IGZvciBzdHJlYW1pbmcgaW4gRmlyZWZveCwgc2luY2UgeGhyLnJlc3BvbnNlIGlzIE9OTFkgZGVmaW5lZFxuXHRcdC8vIGluIG9ucHJvZ3Jlc3MsIG5vdCBpbiBvbnJlYWR5c3RhdGVjaGFuZ2Ugd2l0aCB4aHIucmVhZHlTdGF0ZSA9IDNcblx0XHRpZiAoc2VsZi5fbW9kZSA9PT0gJ21vei1jaHVua2VkLWFycmF5YnVmZmVyJykge1xuXHRcdFx0eGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNlbGYuX29uWEhSUHJvZ3Jlc3MoKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHNlbGYuX2Rlc3Ryb3llZClcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdYSFIgZXJyb3InKSlcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0eGhyLnNlbmQoYm9keSlcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHRcdFx0fSlcblx0XHRcdHJldHVyblxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiB4aHIuc3RhdHVzIGlzIHJlYWRhYmxlIGFuZCBub24temVybywgaW5kaWNhdGluZyBubyBlcnJvci5cbiAqIEV2ZW4gdGhvdWdoIHRoZSBzcGVjIHNheXMgaXQgc2hvdWxkIGJlIGF2YWlsYWJsZSBpbiByZWFkeVN0YXRlIDMsXG4gKiBhY2Nlc3NpbmcgaXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpbiBJRThcbiAqL1xuZnVuY3Rpb24gc3RhdHVzVmFsaWQgKHhocikge1xuXHR0cnkge1xuXHRcdHZhciBzdGF0dXMgPSB4aHIuc3RhdHVzXG5cdFx0cmV0dXJuIChzdGF0dXMgIT09IG51bGwgJiYgc3RhdHVzICE9PSAwKVxuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuX29uWEhSUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdGlmICghc3RhdHVzVmFsaWQoc2VsZi5feGhyKSB8fCBzZWxmLl9kZXN0cm95ZWQpXG5cdFx0cmV0dXJuXG5cblx0aWYgKCFzZWxmLl9yZXNwb25zZSlcblx0XHRzZWxmLl9jb25uZWN0KClcblxuXHRzZWxmLl9yZXNwb25zZS5fb25YSFJQcm9ncmVzcygpXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLl9jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHRpZiAoc2VsZi5fZGVzdHJveWVkKVxuXHRcdHJldHVyblxuXG5cdHNlbGYuX3Jlc3BvbnNlID0gbmV3IEluY29taW5nTWVzc2FnZShzZWxmLl94aHIsIHNlbGYuX2ZldGNoUmVzcG9uc2UsIHNlbGYuX21vZGUpXG5cdHNlbGYuX3Jlc3BvbnNlLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuXHRcdHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG5cdH0pXG5cblx0c2VsZi5lbWl0KCdyZXNwb25zZScsIHNlbGYuX3Jlc3BvbnNlKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHRzZWxmLl9ib2R5LnB1c2goY2h1bmspXG5cdGNiKClcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBDbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0c2VsZi5fZGVzdHJveWVkID0gdHJ1ZVxuXHRpZiAoc2VsZi5fcmVzcG9uc2UpXG5cdFx0c2VsZi5fcmVzcG9uc2UuX2Rlc3Ryb3llZCA9IHRydWVcblx0aWYgKHNlbGYuX3hocilcblx0XHRzZWxmLl94aHIuYWJvcnQoKVxuXHQvLyBDdXJyZW50bHksIHRoZXJlIGlzbid0IGEgd2F5IHRvIHRydWx5IGFib3J0IGEgZmV0Y2guXG5cdC8vIElmIHlvdSBsaWtlIGJpa2VzaGVkZGluZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvZmV0Y2gvaXNzdWVzLzI3XG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZywgY2IpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGNiID0gZGF0YVxuXHRcdGRhdGEgPSB1bmRlZmluZWRcblx0fVxuXG5cdHN0cmVhbS5Xcml0YWJsZS5wcm90b3R5cGUuZW5kLmNhbGwoc2VsZiwgZGF0YSwgZW5jb2RpbmcsIGNiKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5mbHVzaEhlYWRlcnMgPSBmdW5jdGlvbiAoKSB7fVxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuc2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHt9XG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5zZXROb0RlbGF5ID0gZnVuY3Rpb24gKCkge31cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnNldFNvY2tldEtlZXBBbGl2ZSA9IGZ1bmN0aW9uICgpIHt9XG5cbi8vIFRha2VuIGZyb20gaHR0cDovL3d3dy53My5vcmcvVFIvWE1MSHR0cFJlcXVlc3QvI3RoZS1zZXRyZXF1ZXN0aGVhZGVyJTI4JTI5LW1ldGhvZFxudmFyIHVuc2FmZUhlYWRlcnMgPSBbXG5cdCdhY2NlcHQtY2hhcnNldCcsXG5cdCdhY2NlcHQtZW5jb2RpbmcnLFxuXHQnYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1oZWFkZXJzJyxcblx0J2FjY2Vzcy1jb250cm9sLXJlcXVlc3QtbWV0aG9kJyxcblx0J2Nvbm5lY3Rpb24nLFxuXHQnY29udGVudC1sZW5ndGgnLFxuXHQnY29va2llJyxcblx0J2Nvb2tpZTInLFxuXHQnZGF0ZScsXG5cdCdkbnQnLFxuXHQnZXhwZWN0Jyxcblx0J2hvc3QnLFxuXHQna2VlcC1hbGl2ZScsXG5cdCdvcmlnaW4nLFxuXHQncmVmZXJlcicsXG5cdCd0ZScsXG5cdCd0cmFpbGVyJyxcblx0J3RyYW5zZmVyLWVuY29kaW5nJyxcblx0J3VwZ3JhZGUnLFxuXHQndXNlci1hZ2VudCcsXG5cdCd2aWEnXG5dXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3N0cmVhbS1odHRwL2xpYi9yZXF1ZXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLmZldGNoID0gaXNGdW5jdGlvbihnbG9iYWwuZmV0Y2gpICYmIGlzRnVuY3Rpb24oZ2xvYmFsLlJlYWRhYmxlU3RyZWFtKVxuXG5leHBvcnRzLmJsb2JDb25zdHJ1Y3RvciA9IGZhbHNlXG50cnkge1xuXHRuZXcgQmxvYihbbmV3IEFycmF5QnVmZmVyKDEpXSlcblx0ZXhwb3J0cy5ibG9iQ29uc3RydWN0b3IgPSB0cnVlXG59IGNhdGNoIChlKSB7fVxuXG4vLyBUaGUgeGhyIHJlcXVlc3QgdG8gZXhhbXBsZS5jb20gbWF5IHZpb2xhdGUgc29tZSByZXN0cmljdGl2ZSBDU1AgY29uZmlndXJhdGlvbnMsXG4vLyBzbyBpZiB3ZSdyZSBydW5uaW5nIGluIGEgYnJvd3NlciB0aGF0IHN1cHBvcnRzIGBmZXRjaGAsIGF2b2lkIGNhbGxpbmcgZ2V0WEhSKClcbi8vIGFuZCBhc3N1bWUgc3VwcG9ydCBmb3IgY2VydGFpbiBmZWF0dXJlcyBiZWxvdy5cbnZhciB4aHJcbmZ1bmN0aW9uIGdldFhIUiAoKSB7XG5cdC8vIENhY2hlIHRoZSB4aHIgdmFsdWVcblx0aWYgKHhociAhPT0gdW5kZWZpbmVkKSByZXR1cm4geGhyXG5cblx0aWYgKGdsb2JhbC5YTUxIdHRwUmVxdWVzdCkge1xuXHRcdHhociA9IG5ldyBnbG9iYWwuWE1MSHR0cFJlcXVlc3QoKVxuXHRcdC8vIElmIFhEb21haW5SZXF1ZXN0IGlzIGF2YWlsYWJsZSAoaWUgb25seSwgd2hlcmUgeGhyIG1pZ2h0IG5vdCB3b3JrXG5cdFx0Ly8gY3Jvc3MgZG9tYWluKSwgdXNlIHRoZSBwYWdlIGxvY2F0aW9uLiBPdGhlcndpc2UgdXNlIGV4YW1wbGUuY29tXG5cdFx0Ly8gTm90ZTogdGhpcyBkb2Vzbid0IGFjdHVhbGx5IG1ha2UgYW4gaHR0cCByZXF1ZXN0LlxuXHRcdHRyeSB7XG5cdFx0XHR4aHIub3BlbignR0VUJywgZ2xvYmFsLlhEb21haW5SZXF1ZXN0ID8gJy8nIDogJ2h0dHBzOi8vZXhhbXBsZS5jb20nKVxuXHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0eGhyID0gbnVsbFxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBTZXJ2aWNlIHdvcmtlcnMgZG9uJ3QgaGF2ZSBYSFJcblx0XHR4aHIgPSBudWxsXG5cdH1cblx0cmV0dXJuIHhoclxufVxuXG5mdW5jdGlvbiBjaGVja1R5cGVTdXBwb3J0ICh0eXBlKSB7XG5cdHZhciB4aHIgPSBnZXRYSFIoKVxuXHRpZiAoIXhocikgcmV0dXJuIGZhbHNlXG5cdHRyeSB7XG5cdFx0eGhyLnJlc3BvbnNlVHlwZSA9IHR5cGVcblx0XHRyZXR1cm4geGhyLnJlc3BvbnNlVHlwZSA9PT0gdHlwZVxuXHR9IGNhdGNoIChlKSB7fVxuXHRyZXR1cm4gZmFsc2Vcbn1cblxuLy8gRm9yIHNvbWUgc3RyYW5nZSByZWFzb24sIFNhZmFyaSA3LjAgcmVwb3J0cyB0eXBlb2YgZ2xvYmFsLkFycmF5QnVmZmVyID09PSAnb2JqZWN0Jy5cbi8vIFNhZmFyaSA3LjEgYXBwZWFycyB0byBoYXZlIGZpeGVkIHRoaXMgYnVnLlxudmFyIGhhdmVBcnJheUJ1ZmZlciA9IHR5cGVvZiBnbG9iYWwuQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnXG52YXIgaGF2ZVNsaWNlID0gaGF2ZUFycmF5QnVmZmVyICYmIGlzRnVuY3Rpb24oZ2xvYmFsLkFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSlcblxuLy8gSWYgZmV0Y2ggaXMgc3VwcG9ydGVkLCB0aGVuIGFycmF5YnVmZmVyIHdpbGwgYmUgc3VwcG9ydGVkIHRvby4gU2tpcCBjYWxsaW5nXG4vLyBjaGVja1R5cGVTdXBwb3J0KCksIHNpbmNlIHRoYXQgY2FsbHMgZ2V0WEhSKCkuXG5leHBvcnRzLmFycmF5YnVmZmVyID0gZXhwb3J0cy5mZXRjaCB8fCAoaGF2ZUFycmF5QnVmZmVyICYmIGNoZWNrVHlwZVN1cHBvcnQoJ2FycmF5YnVmZmVyJykpXG5cbi8vIFRoZXNlIG5leHQgdHdvIHRlc3RzIHVuYXZvaWRhYmx5IHNob3cgd2FybmluZ3MgaW4gQ2hyb21lLiBTaW5jZSBmZXRjaCB3aWxsIGFsd2F5c1xuLy8gYmUgdXNlZCBpZiBpdCdzIGF2YWlsYWJsZSwganVzdCByZXR1cm4gZmFsc2UgZm9yIHRoZXNlIHRvIGF2b2lkIHRoZSB3YXJuaW5ncy5cbmV4cG9ydHMubXNzdHJlYW0gPSAhZXhwb3J0cy5mZXRjaCAmJiBoYXZlU2xpY2UgJiYgY2hlY2tUeXBlU3VwcG9ydCgnbXMtc3RyZWFtJylcbmV4cG9ydHMubW96Y2h1bmtlZGFycmF5YnVmZmVyID0gIWV4cG9ydHMuZmV0Y2ggJiYgaGF2ZUFycmF5QnVmZmVyICYmXG5cdGNoZWNrVHlwZVN1cHBvcnQoJ21vei1jaHVua2VkLWFycmF5YnVmZmVyJylcblxuLy8gSWYgZmV0Y2ggaXMgc3VwcG9ydGVkLCB0aGVuIG92ZXJyaWRlTWltZVR5cGUgd2lsbCBiZSBzdXBwb3J0ZWQgdG9vLiBTa2lwIGNhbGxpbmdcbi8vIGdldFhIUigpLlxuZXhwb3J0cy5vdmVycmlkZU1pbWVUeXBlID0gZXhwb3J0cy5mZXRjaCB8fCAoZ2V0WEhSKCkgPyBpc0Z1bmN0aW9uKGdldFhIUigpLm92ZXJyaWRlTWltZVR5cGUpIDogZmFsc2UpXG5cbmV4cG9ydHMudmJBcnJheSA9IGlzRnVuY3Rpb24oZ2xvYmFsLlZCQXJyYXkpXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24gKHZhbHVlKSB7XG5cdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbidcbn1cblxueGhyID0gbnVsbCAvLyBIZWxwIGdjXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3N0cmVhbS1odHRwL2xpYi9jYXBhYmlsaXR5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL2NhcGFiaWxpdHknKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG5cbnZhciByU3RhdGVzID0gZXhwb3J0cy5yZWFkeVN0YXRlcyA9IHtcblx0VU5TRU5UOiAwLFxuXHRPUEVORUQ6IDEsXG5cdEhFQURFUlNfUkVDRUlWRUQ6IDIsXG5cdExPQURJTkc6IDMsXG5cdERPTkU6IDRcbn1cblxudmFyIEluY29taW5nTWVzc2FnZSA9IGV4cG9ydHMuSW5jb21pbmdNZXNzYWdlID0gZnVuY3Rpb24gKHhociwgcmVzcG9uc2UsIG1vZGUpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdHN0cmVhbS5SZWFkYWJsZS5jYWxsKHNlbGYpXG5cblx0c2VsZi5fbW9kZSA9IG1vZGVcblx0c2VsZi5oZWFkZXJzID0ge31cblx0c2VsZi5yYXdIZWFkZXJzID0gW11cblx0c2VsZi50cmFpbGVycyA9IHt9XG5cdHNlbGYucmF3VHJhaWxlcnMgPSBbXVxuXG5cdC8vIEZha2UgdGhlICdjbG9zZScgZXZlbnQsIGJ1dCBvbmx5IG9uY2UgJ2VuZCcgZmlyZXNcblx0c2VsZi5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuXHRcdC8vIFRoZSBuZXh0VGljayBpcyBuZWNlc3NhcnkgdG8gcHJldmVudCB0aGUgJ3JlcXVlc3QnIG1vZHVsZSBmcm9tIGNhdXNpbmcgYW4gaW5maW5pdGUgbG9vcFxuXHRcdHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuXHRcdFx0c2VsZi5lbWl0KCdjbG9zZScpXG5cdFx0fSlcblx0fSlcblxuXHRpZiAobW9kZSA9PT0gJ2ZldGNoJykge1xuXHRcdHNlbGYuX2ZldGNoUmVzcG9uc2UgPSByZXNwb25zZVxuXG5cdFx0c2VsZi51cmwgPSByZXNwb25zZS51cmxcblx0XHRzZWxmLnN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXNcblx0XHRzZWxmLnN0YXR1c01lc3NhZ2UgPSByZXNwb25zZS5zdGF0dXNUZXh0XG5cdFx0XG5cdFx0cmVzcG9uc2UuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlciwga2V5KXtcblx0XHRcdHNlbGYuaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSBoZWFkZXJcblx0XHRcdHNlbGYucmF3SGVhZGVycy5wdXNoKGtleSwgaGVhZGVyKVxuXHRcdH0pXG5cblxuXHRcdC8vIFRPRE86IHRoaXMgZG9lc24ndCByZXNwZWN0IGJhY2twcmVzc3VyZS4gT25jZSBXcml0YWJsZVN0cmVhbSBpcyBhdmFpbGFibGUsIHRoaXMgY2FuIGJlIGZpeGVkXG5cdFx0dmFyIHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKClcblx0XHRmdW5jdGlvbiByZWFkICgpIHtcblx0XHRcdHJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0XHRcdGlmIChzZWxmLl9kZXN0cm95ZWQpXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdGlmIChyZXN1bHQuZG9uZSkge1xuXHRcdFx0XHRcdHNlbGYucHVzaChudWxsKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYucHVzaChuZXcgQnVmZmVyKHJlc3VsdC52YWx1ZSkpXG5cdFx0XHRcdHJlYWQoKVxuXHRcdFx0fSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG5cdFx0XHR9KVxuXHRcdH1cblx0XHRyZWFkKClcblxuXHR9IGVsc2Uge1xuXHRcdHNlbGYuX3hociA9IHhoclxuXHRcdHNlbGYuX3BvcyA9IDBcblxuXHRcdHNlbGYudXJsID0geGhyLnJlc3BvbnNlVVJMXG5cdFx0c2VsZi5zdGF0dXNDb2RlID0geGhyLnN0YXR1c1xuXHRcdHNlbGYuc3RhdHVzTWVzc2FnZSA9IHhoci5zdGF0dXNUZXh0XG5cdFx0dmFyIGhlYWRlcnMgPSB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkuc3BsaXQoL1xccj9cXG4vKVxuXHRcdGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyA9IGhlYWRlci5tYXRjaCgvXihbXjpdKyk6XFxzKiguKikvKVxuXHRcdFx0aWYgKG1hdGNoZXMpIHtcblx0XHRcdFx0dmFyIGtleSA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKVxuXHRcdFx0XHRpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcblx0XHRcdFx0XHRpZiAoc2VsZi5oZWFkZXJzW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0c2VsZi5oZWFkZXJzW2tleV0gPSBbXVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzZWxmLmhlYWRlcnNba2V5XS5wdXNoKG1hdGNoZXNbMl0pXG5cdFx0XHRcdH0gZWxzZSBpZiAoc2VsZi5oZWFkZXJzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHNlbGYuaGVhZGVyc1trZXldICs9ICcsICcgKyBtYXRjaGVzWzJdXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VsZi5oZWFkZXJzW2tleV0gPSBtYXRjaGVzWzJdXG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi5yYXdIZWFkZXJzLnB1c2gobWF0Y2hlc1sxXSwgbWF0Y2hlc1syXSlcblx0XHRcdH1cblx0XHR9KVxuXG5cdFx0c2VsZi5fY2hhcnNldCA9ICd4LXVzZXItZGVmaW5lZCdcblx0XHRpZiAoIWNhcGFiaWxpdHkub3ZlcnJpZGVNaW1lVHlwZSkge1xuXHRcdFx0dmFyIG1pbWVUeXBlID0gc2VsZi5yYXdIZWFkZXJzWydtaW1lLXR5cGUnXVxuXHRcdFx0aWYgKG1pbWVUeXBlKSB7XG5cdFx0XHRcdHZhciBjaGFyc2V0TWF0Y2ggPSBtaW1lVHlwZS5tYXRjaCgvO1xccypjaGFyc2V0PShbXjtdKSg7fCQpLylcblx0XHRcdFx0aWYgKGNoYXJzZXRNYXRjaCkge1xuXHRcdFx0XHRcdHNlbGYuX2NoYXJzZXQgPSBjaGFyc2V0TWF0Y2hbMV0udG9Mb3dlckNhc2UoKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXNlbGYuX2NoYXJzZXQpXG5cdFx0XHRcdHNlbGYuX2NoYXJzZXQgPSAndXRmLTgnIC8vIGJlc3QgZ3Vlc3Ncblx0XHR9XG5cdH1cbn1cblxuaW5oZXJpdHMoSW5jb21pbmdNZXNzYWdlLCBzdHJlYW0uUmVhZGFibGUpXG5cbkluY29taW5nTWVzc2FnZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAoKSB7fVxuXG5JbmNvbWluZ01lc3NhZ2UucHJvdG90eXBlLl9vblhIUlByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHR2YXIgeGhyID0gc2VsZi5feGhyXG5cblx0dmFyIHJlc3BvbnNlID0gbnVsbFxuXHRzd2l0Y2ggKHNlbGYuX21vZGUpIHtcblx0XHRjYXNlICd0ZXh0OnZiYXJyYXknOiAvLyBGb3IgSUU5XG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgIT09IHJTdGF0ZXMuRE9ORSlcblx0XHRcdFx0YnJlYWtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIFRoaXMgZmFpbHMgaW4gSUU4XG5cdFx0XHRcdHJlc3BvbnNlID0gbmV3IGdsb2JhbC5WQkFycmF5KHhoci5yZXNwb25zZUJvZHkpLnRvQXJyYXkoKVxuXHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHRcdGlmIChyZXNwb25zZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRzZWxmLnB1c2gobmV3IEJ1ZmZlcihyZXNwb25zZSkpXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cdFx0XHQvLyBGYWxscyB0aHJvdWdoIGluIElFOFx0XG5cdFx0Y2FzZSAndGV4dCc6XG5cdFx0XHR0cnkgeyAvLyBUaGlzIHdpbGwgZmFpbCB3aGVuIHJlYWR5U3RhdGUgPSAzIGluIElFOS4gU3dpdGNoIG1vZGUgYW5kIHdhaXQgZm9yIHJlYWR5U3RhdGUgPSA0XG5cdFx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlVGV4dFxuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRzZWxmLl9tb2RlID0gJ3RleHQ6dmJhcnJheSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdH1cblx0XHRcdGlmIChyZXNwb25zZS5sZW5ndGggPiBzZWxmLl9wb3MpIHtcblx0XHRcdFx0dmFyIG5ld0RhdGEgPSByZXNwb25zZS5zdWJzdHIoc2VsZi5fcG9zKVxuXHRcdFx0XHRpZiAoc2VsZi5fY2hhcnNldCA9PT0gJ3gtdXNlci1kZWZpbmVkJykge1xuXHRcdFx0XHRcdHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKG5ld0RhdGEubGVuZ3RoKVxuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbmV3RGF0YS5sZW5ndGg7IGkrKylcblx0XHRcdFx0XHRcdGJ1ZmZlcltpXSA9IG5ld0RhdGEuY2hhckNvZGVBdChpKSAmIDB4ZmZcblxuXHRcdFx0XHRcdHNlbGYucHVzaChidWZmZXIpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VsZi5wdXNoKG5ld0RhdGEsIHNlbGYuX2NoYXJzZXQpXG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi5fcG9zID0gcmVzcG9uc2UubGVuZ3RoXG5cdFx0XHR9XG5cdFx0XHRicmVha1xuXHRcdGNhc2UgJ2FycmF5YnVmZmVyJzpcblx0XHRcdGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gclN0YXRlcy5ET05FIHx8ICF4aHIucmVzcG9uc2UpXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRyZXNwb25zZSA9IHhoci5yZXNwb25zZVxuXHRcdFx0c2VsZi5wdXNoKG5ldyBCdWZmZXIobmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UpKSlcblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSAnbW96LWNodW5rZWQtYXJyYXlidWZmZXInOiAvLyB0YWtlIHdob2xlXG5cdFx0XHRyZXNwb25zZSA9IHhoci5yZXNwb25zZVxuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlICE9PSByU3RhdGVzLkxPQURJTkcgfHwgIXJlc3BvbnNlKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0c2VsZi5wdXNoKG5ldyBCdWZmZXIobmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UpKSlcblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSAnbXMtc3RyZWFtJzpcblx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlXG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgIT09IHJTdGF0ZXMuTE9BRElORylcblx0XHRcdFx0YnJlYWtcblx0XHRcdHZhciByZWFkZXIgPSBuZXcgZ2xvYmFsLk1TU3RyZWFtUmVhZGVyKClcblx0XHRcdHJlYWRlci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAocmVhZGVyLnJlc3VsdC5ieXRlTGVuZ3RoID4gc2VsZi5fcG9zKSB7XG5cdFx0XHRcdFx0c2VsZi5wdXNoKG5ldyBCdWZmZXIobmV3IFVpbnQ4QXJyYXkocmVhZGVyLnJlc3VsdC5zbGljZShzZWxmLl9wb3MpKSkpXG5cdFx0XHRcdFx0c2VsZi5fcG9zID0gcmVhZGVyLnJlc3VsdC5ieXRlTGVuZ3RoXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNlbGYucHVzaChudWxsKVxuXHRcdFx0fVxuXHRcdFx0Ly8gcmVhZGVyLm9uZXJyb3IgPSA/Pz8gLy8gVE9ETzogdGhpc1xuXHRcdFx0cmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKHJlc3BvbnNlKVxuXHRcdFx0YnJlYWtcblx0fVxuXG5cdC8vIFRoZSBtcy1zdHJlYW0gY2FzZSBoYW5kbGVzIGVuZCBzZXBhcmF0ZWx5IGluIHJlYWRlci5vbmxvYWQoKVxuXHRpZiAoc2VsZi5feGhyLnJlYWR5U3RhdGUgPT09IHJTdGF0ZXMuRE9ORSAmJiBzZWxmLl9tb2RlICE9PSAnbXMtc3RyZWFtJykge1xuXHRcdHNlbGYucHVzaChudWxsKVxuXHR9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3N0cmVhbS1odHRwL2xpYi9yZXNwb25zZS5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFN0cmVhbSA9IChmdW5jdGlvbiAoKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTsgLy8gaGFjayB0byBmaXggYSBjaXJjdWxhciBkZXBlbmRlbmN5IGlzc3VlIHdoZW4gdXNlZCB3aXRoIGJyb3dzZXJpZnlcbiAgfSBjYXRjaChfKXt9XG59KCkpO1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBTdHJlYW0gfHwgZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5cbmlmICghcHJvY2Vzcy5icm93c2VyICYmIHByb2Nlc3MuZW52LlJFQURBQkxFX1NUUkVBTSA9PT0gJ2Rpc2FibGUnICYmIFN0cmVhbSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vZXZlbnRzL2V2ZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV93cml0YWJsZS5qc1wiKVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwcm9jZXNzTmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbTtcbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgU3RyZWFtID0gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTtcbiAgfSBjYXRjaCAoXykge30gZmluYWxseSB7XG4gICAgaWYgKCFTdHJlYW0pIFN0cmVhbSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiAgfVxufSkoKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBidWZmZXJTaGltID0gcmVxdWlyZSgnYnVmZmVyLXNoaW1zJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH4gfnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gSWYgd2UgZ2V0IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQsXG4vLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxuLy8gT3RoZXJ3aXNlIHN0cmVhbSBjaHVua3MgYXJlIGFsbCBjb25zaWRlcmVkIHRvIGJlIG9mIGxlbmd0aD0xLCBhbmQgdGhlXG4vLyB3YXRlcm1hcmtzIGRldGVybWluZSBob3cgbWFueSBvYmplY3RzIHRvIGtlZXAgaW4gdGhlIGJ1ZmZlciwgcmF0aGVyIHRoYW5cbi8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcbiAgLy8gQWx3YXlzIHRocm93IGVycm9yIGlmIGEgbnVsbCBpcyB3cml0dGVuXG4gIC8vIGlmIHdlIGFyZSBub3QgaW4gb2JqZWN0IG1vZGUgdGhlbiB0aHJvd1xuICAvLyBpZiBpdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgb3IgdW5kZWZpbmVkLlxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IGJ1ZmZlclNoaW0uZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSBlbmNvZGluZyA9ICdidWZmZXInO1xuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbmV3IFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG4gIGlmIChzeW5jKSBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtlbHNlIGNiKGVyKTtcblxuICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQpIHtcbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHByb2Nlc3NOZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG5cbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgdmFyIGVudHJ5ID0gX3RoaXMuZW50cnk7XG4gICAgX3RoaXMuZW50cnkgPSBudWxsO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICAgIGNiKGVycik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gX3RoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IF90aGlzO1xuICAgIH1cbiAgfTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAoIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IG5leHRUaWNrO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzLm5leHRUaWNrO1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Byb2Nlc3MtbmV4dGljay1hcmdzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKTtcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyO1xudmFyIFNsb3dCdWZmZXIgPSBidWZmZXIuU2xvd0J1ZmZlcjtcbnZhciBNQVhfTEVOID0gYnVmZmVyLmtNYXhMZW5ndGggfHwgMjE0NzQ4MzY0NztcbmV4cG9ydHMuYWxsb2MgPSBmdW5jdGlvbiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5hbGxvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpO1xuICB9XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBub3QgYmUgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmIChzaXplID4gTUFYX0xFTikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaXplIGlzIHRvbyBsYXJnZScpO1xuICB9XG4gIHZhciBlbmMgPSBlbmNvZGluZztcbiAgdmFyIF9maWxsID0gZmlsbDtcbiAgaWYgKF9maWxsID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmMgPSB1bmRlZmluZWQ7XG4gICAgX2ZpbGwgPSAwO1xuICB9XG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHNpemUpO1xuICBpZiAodHlwZW9mIF9maWxsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBmaWxsQnVmID0gbmV3IEJ1ZmZlcihfZmlsbCwgZW5jKTtcbiAgICB2YXIgZmxlbiA9IGZpbGxCdWYubGVuZ3RoO1xuICAgIHZhciBpID0gLTE7XG4gICAgd2hpbGUgKCsraSA8IHNpemUpIHtcbiAgICAgIGJ1ZltpXSA9IGZpbGxCdWZbaSAlIGZsZW5dO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbChfZmlsbCk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn1cbmV4cG9ydHMuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiBhbGxvY1Vuc2FmZShzaXplKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmFsbG9jVW5zYWZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKTtcbiAgfVxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHNpemUgPiBNQVhfTEVOKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NpemUgaXMgdG9vIGxhcmdlJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSk7XG59XG5leHBvcnRzLmZyb20gPSBmdW5jdGlvbiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuZnJvbSA9PT0gJ2Z1bmN0aW9uJyAmJiAoIWdsb2JhbC5VaW50OEFycmF5IHx8IFVpbnQ4QXJyYXkuZnJvbSAhPT0gQnVmZmVyLmZyb20pKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHZhciBvZmZzZXQgPSBlbmNvZGluZ09yT2Zmc2V0O1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgdmFyIGxlbiA9IGxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGxlbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxlbiA9IHZhbHVlLmJ5dGVMZW5ndGggLSBvZmZzZXQ7XG4gICAgfVxuICAgIGlmIChvZmZzZXQgPj0gdmFsdWUuYnl0ZUxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmIChsZW4gPiB2YWx1ZS5ieXRlTGVuZ3RoIC0gb2Zmc2V0KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW4pKTtcbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgIHZhciBvdXQgPSBuZXcgQnVmZmVyKHZhbHVlLmxlbmd0aCk7XG4gICAgdmFsdWUuY29weShvdXQsIDAsIDAsIHZhbHVlLmxlbmd0aCk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIHZhbHVlKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZS50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlLmRhdGEpKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZS5kYXRhKTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsICcgKyAnQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKTtcbn1cbmV4cG9ydHMuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gYWxsb2NVbnNhZmVTbG93KHNpemUpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3coc2l6ZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmIChzaXplID49IE1BWF9MRU4pIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2l6ZSBpcyB0b28gbGFyZ2UnKTtcbiAgfVxuICByZXR1cm4gbmV3IFNsb3dCdWZmZXIoc2l6ZSk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2J1ZmZlci1zaGltcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG52YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbmZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwcm9jZXNzTmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtO1xuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBTdHJlYW0gPSByZXF1aXJlKCdzdCcgKyAncmVhbScpO1xuICB9IGNhdGNoIChfKSB7fSBmaW5hbGx5IHtcbiAgICBpZiAoIVN0cmVhbSkgU3RyZWFtID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuICB9XG59KSgpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGJ1ZmZlclNoaW0gPSByZXF1aXJlKCdidWZmZXItc2hpbXMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gICAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICAgIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH4gfnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXG4gIHRoaXMucmFuT3V0ID0gZmFsc2U7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICBjaHVuayA9IGJ1ZmZlclNoaW0uZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBmYWxzZSk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcbiAgdmFyIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgIGlmIChzdGF0ZS5lbmRlZCAmJiAhYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZEVtaXR0ZWQgJiYgYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIF9lID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgX2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2tpcEFkZDtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFhZGRUb0Zyb250ICYmICFlbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICBza2lwQWRkID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgY2h1bmsubGVuZ3RoID09PSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFkZFRvRnJvbnQpIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgLy8gRG9uJ3QgYWRkIHRvIHRoZSBidWZmZXIgaWYgd2UndmUgZGVjb2RlZCB0byBhbiBlbXB0eSBzdHJpbmcgY2h1bmsgYW5kXG4gICAgICAvLyB3ZSdyZSBub3QgaW4gb2JqZWN0IG1vZGVcbiAgICAgIGlmICghc2tpcEFkZCkge1xuICAgICAgICAvLyBpZiB3ZSB3YW50IHRoZSBkYXRhIG5vdywganVzdCBlbWl0IGl0LlxuICAgICAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlciA9IG51bGw7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcHJvY2Vzc05leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiBjbGVhbnVwO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcHJvY2Vzc05leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSkge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICB9cmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHByb2Nlc3NOZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHNlbGYucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgc2VsZi5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gc2VsZi5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICB2YXIgZXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24gKGV2KSB7XG4gICAgc3RyZWFtLm9uKGV2LCBzZWxmLmVtaXQuYmluZChzZWxmLCBldikpO1xuICB9KTtcblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICBzZWxmLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc2VsZjtcbn07XG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IGZyb21MaXN0UGFydGlhbChuLCBzdGF0ZS5idWZmZXIsIHN0YXRlLmRlY29kZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gRXh0cmFjdHMgb25seSBlbm91Z2ggYnVmZmVyZWQgZGF0YSB0byBzYXRpc2Z5IHRoZSBhbW91bnQgcmVxdWVzdGVkLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdFBhcnRpYWwobiwgbGlzdCwgaGFzU3RyaW5ncykge1xuICB2YXIgcmV0O1xuICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzXG4gICAgcmV0ID0gbGlzdC5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTtcbiAgfSBlbHNlIGlmIChuID09PSBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBmaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyXG4gICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YVxuLy8gY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHZhciByZXQgPSBwLmRhdGE7XG4gIG4gLT0gcmV0Lmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7XG4gIHZhciByZXQgPSBidWZmZXJTaGltLmFsbG9jVW5zYWZlKG4pO1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICBwLmRhdGEuY29weShyZXQpO1xuICBuIC09IHAuZGF0YS5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAoaWdub3JlZCkgKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyB1dGlsIChpZ25vcmVkKVxuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBidWZmZXJTaGltID0gcmVxdWlyZSgnYnVmZmVyLXNoaW1zJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJMaXN0O1xuXG5mdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICB0aGlzLmhlYWQgPSBudWxsO1xuICB0aGlzLnRhaWwgPSBudWxsO1xuICB0aGlzLmxlbmd0aCA9IDA7XG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodikge1xuICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgKyt0aGlzLmxlbmd0aDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAodikge1xuICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgKyt0aGlzLmxlbmd0aDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgLS10aGlzLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICB0aGlzLmxlbmd0aCA9IDA7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKHMpIHtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciBwID0gdGhpcy5oZWFkO1xuICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gIH1yZXR1cm4gcmV0O1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKG4pIHtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gYnVmZmVyU2hpbS5hbGxvYygwKTtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gIHZhciByZXQgPSBidWZmZXJTaGltLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAocCkge1xuICAgIHAuZGF0YS5jb3B5KHJldCwgaSk7XG4gICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgIHAgPSBwLm5leHQ7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBpc0J1ZmZlckVuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmdcbiAgfHwgZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgICAgICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgIGNhc2UgJ2hleCc6IGNhc2UgJ3V0ZjgnOiBjYXNlICd1dGYtOCc6IGNhc2UgJ2FzY2lpJzogY2FzZSAnYmluYXJ5JzogY2FzZSAnYmFzZTY0JzogY2FzZSAndWNzMic6IGNhc2UgJ3Vjcy0yJzogY2FzZSAndXRmMTZsZSc6IGNhc2UgJ3V0Zi0xNmxlJzogY2FzZSAncmF3JzogcmV0dXJuIHRydWU7XG4gICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgfVxuICAgICB9XG5cblxuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nICYmICFpc0J1ZmZlckVuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuIENFU1UtOCBpcyBoYW5kbGVkIGFzIHBhcnQgb2YgdGhlIFVURi04IGVuY29kaW5nLlxuLy9cbi8vIEBUT0RPIEhhbmRsaW5nIGFsbCBlbmNvZGluZ3MgaW5zaWRlIGEgc2luZ2xlIG9iamVjdCBtYWtlcyBpdCB2ZXJ5IGRpZmZpY3VsdFxuLy8gdG8gcmVhc29uIGFib3V0IHRoaXMgY29kZSwgc28gaXQgc2hvdWxkIGJlIHNwbGl0IHVwIGluIHRoZSBmdXR1cmUuXG4vLyBAVE9ETyBUaGVyZSBzaG91bGQgYmUgYSB1dGY4LXN0cmljdCBlbmNvZGluZyB0aGF0IHJlamVjdHMgaW52YWxpZCBVVEYtOCBjb2RlXG4vLyBwb2ludHMgYXMgdXNlZCBieSBDRVNVLTguXG52YXIgU3RyaW5nRGVjb2RlciA9IGV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSAoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX10vLCAnJyk7XG4gIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKTtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICAvLyBDRVNVLTggcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDMtYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIC8vIFVURi0xNiByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMi1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMjtcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIEJhc2UtNjQgc3RvcmVzIDMgYnl0ZXMgaW4gNCBjaGFycywgYW5kIHBhZHMgdGhlIHJlbWFpbmRlci5cbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHBhc3NUaHJvdWdoV3JpdGU7XG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbm91Z2ggc3BhY2UgdG8gc3RvcmUgYWxsIGJ5dGVzIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci4gVVRGLTggbmVlZHMgNFxuICAvLyBieXRlcywgYnV0IENFU1UtOCBtYXkgcmVxdWlyZSB1cCB0byA2ICgzIGJ5dGVzIHBlciBzdXJyb2dhdGUpLlxuICB0aGlzLmNoYXJCdWZmZXIgPSBuZXcgQnVmZmVyKDYpO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgcmVjZWl2ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhclJlY2VpdmVkID0gMDtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIGV4cGVjdGVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJMZW5ndGggPSAwO1xufTtcblxuXG4vLyB3cml0ZSBkZWNvZGVzIHRoZSBnaXZlbiBidWZmZXIgYW5kIHJldHVybnMgaXQgYXMgSlMgc3RyaW5nIHRoYXQgaXNcbi8vIGd1YXJhbnRlZWQgdG8gbm90IGNvbnRhaW4gYW55IHBhcnRpYWwgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLiBBbnkgcGFydGlhbFxuLy8gY2hhcmFjdGVyIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBpcyBidWZmZXJlZCB1cCwgYW5kIHdpbGwgYmVcbi8vIHJldHVybmVkIHdoZW4gY2FsbGluZyB3cml0ZSBhZ2FpbiB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMuXG4vL1xuLy8gTm90ZTogQ29udmVydGluZyBhIEJ1ZmZlciBjb250YWluaW5nIGFuIG9ycGhhbiBzdXJyb2dhdGUgdG8gYSBTdHJpbmdcbi8vIGN1cnJlbnRseSB3b3JrcywgYnV0IGNvbnZlcnRpbmcgYSBTdHJpbmcgdG8gYSBCdWZmZXIgKHZpYSBgbmV3IEJ1ZmZlcmAsIG9yXG4vLyBCdWZmZXIjd3JpdGUpIHdpbGwgcmVwbGFjZSBpbmNvbXBsZXRlIHN1cnJvZ2F0ZXMgd2l0aCB0aGUgdW5pY29kZVxuLy8gcmVwbGFjZW1lbnQgY2hhcmFjdGVyLiBTZWUgaHR0cHM6Ly9jb2RlcmV2aWV3LmNocm9taXVtLm9yZy8xMjExNzMwMDkvIC5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBjaGFyU3RyID0gJyc7XG4gIC8vIGlmIG91ciBsYXN0IHdyaXRlIGVuZGVkIHdpdGggYW4gaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVyXG4gIHdoaWxlICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgcmVtYWluaW5nIGJ5dGVzIHRoaXMgYnVmZmVyIGhhcyB0byBvZmZlciBmb3IgdGhpcyBjaGFyXG4gICAgdmFyIGF2YWlsYWJsZSA9IChidWZmZXIubGVuZ3RoID49IHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkKSA/XG4gICAgICAgIHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkIDpcbiAgICAgICAgYnVmZmVyLmxlbmd0aDtcblxuICAgIC8vIGFkZCB0aGUgbmV3IGJ5dGVzIHRvIHRoZSBjaGFyIGJ1ZmZlclxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgdGhpcy5jaGFyUmVjZWl2ZWQsIDAsIGF2YWlsYWJsZSk7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gYXZhaWxhYmxlO1xuXG4gICAgaWYgKHRoaXMuY2hhclJlY2VpdmVkIDwgdGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgICAvLyBzdGlsbCBub3QgZW5vdWdoIGNoYXJzIGluIHRoaXMgYnVmZmVyPyB3YWl0IGZvciBtb3JlIC4uLlxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBieXRlcyBiZWxvbmdpbmcgdG8gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGZyb20gdGhlIGJ1ZmZlclxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShhdmFpbGFibGUsIGJ1ZmZlci5sZW5ndGgpO1xuXG4gICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgc3BsaXRcbiAgICBjaGFyU3RyID0gdGhpcy5jaGFyQnVmZmVyLnNsaWNlKDAsIHRoaXMuY2hhckxlbmd0aCkudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGNoYXJTdHIubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCArPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgICBjaGFyU3RyID0gJyc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgPSB0aGlzLmNoYXJMZW5ndGggPSAwO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgaW4gdGhpcyBidWZmZXIsIGp1c3QgZW1pdCBvdXIgY2hhclxuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY2hhclN0cjtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgYW5kIHNldCBjaGFyTGVuZ3RoIC8gY2hhclJlY2VpdmVkXG4gIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKTtcblxuICB2YXIgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgaWYgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGJ1ZmZlciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYnl0ZXMgd2UgZ290XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQsIGVuZCk7XG4gICAgZW5kIC09IHRoaXMuY2hhclJlY2VpdmVkO1xuICB9XG5cbiAgY2hhclN0ciArPSBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgZW5kKTtcblxuICB2YXIgZW5kID0gY2hhclN0ci5sZW5ndGggLSAxO1xuICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoZW5kKTtcbiAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgIHZhciBzaXplID0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgIHRoaXMuY2hhckxlbmd0aCArPSBzaXplO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IHNpemU7XG4gICAgdGhpcy5jaGFyQnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCBzaXplLCAwLCBzaXplKTtcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIDAsIHNpemUpO1xuICAgIHJldHVybiBjaGFyU3RyLnN1YnN0cmluZygwLCBlbmQpO1xuICB9XG5cbiAgLy8gb3IganVzdCBlbWl0IHRoZSBjaGFyU3RyXG4gIHJldHVybiBjaGFyU3RyO1xufTtcblxuLy8gZGV0ZWN0SW5jb21wbGV0ZUNoYXIgZGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBhbiBpbmNvbXBsZXRlIFVURi04IGNoYXJhY3RlciBhdFxuLy8gdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiBJZiBzbywgaXQgc2V0cyB0aGlzLmNoYXJMZW5ndGggdG8gdGhlIGJ5dGVcbi8vIGxlbmd0aCB0aGF0IGNoYXJhY3RlciwgYW5kIHNldHMgdGhpcy5jaGFyUmVjZWl2ZWQgdG8gdGhlIG51bWJlciBvZiBieXRlc1xuLy8gdGhhdCBhcmUgYXZhaWxhYmxlIGZvciB0aGlzIGNoYXJhY3Rlci5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmRldGVjdEluY29tcGxldGVDaGFyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIC8vIGRldGVybWluZSBob3cgbWFueSBieXRlcyB3ZSBoYXZlIHRvIGNoZWNrIGF0IHRoZSBlbmQgb2YgdGhpcyBidWZmZXJcbiAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSAzKSA/IDMgOiBidWZmZXIubGVuZ3RoO1xuXG4gIC8vIEZpZ3VyZSBvdXQgaWYgb25lIG9mIHRoZSBsYXN0IGkgYnl0ZXMgb2Ygb3VyIGJ1ZmZlciBhbm5vdW5jZXMgYW5cbiAgLy8gaW5jb21wbGV0ZSBjaGFyLlxuICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgIHZhciBjID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSBpXTtcblxuICAgIC8vIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uXG5cbiAgICAvLyAxMTBYWFhYWFxuICAgIGlmIChpID09IDEgJiYgYyA+PiA1ID09IDB4MDYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDI7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTEwWFhYWFxuICAgIGlmIChpIDw9IDIgJiYgYyA+PiA0ID09IDB4MEUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTExMFhYWFxuICAgIGlmIChpIDw9IDMgJiYgYyA+PiAzID09IDB4MUUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBpO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoKVxuICAgIHJlcyA9IHRoaXMud3JpdGUoYnVmZmVyKTtcblxuICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQpIHtcbiAgICB2YXIgY3IgPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgICB2YXIgYnVmID0gdGhpcy5jaGFyQnVmZmVyO1xuICAgIHZhciBlbmMgPSB0aGlzLmVuY29kaW5nO1xuICAgIHJlcyArPSBidWYuc2xpY2UoMCwgY3IpLnRvU3RyaW5nKGVuYyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gcGFzc1Rocm91Z2hXcml0ZShidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMjtcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAyIDogMDtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDM7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMyA6IDA7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3N0cmluZ19kZWNvZGVyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX2R1cGxleC5qc1wiKVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1wiKVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKHN0cmVhbSkge1xuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xuICB9O1xuXG4gIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuICB0aGlzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0aGlzLndyaXRlZW5jb2RpbmcgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm8gd3JpdGVjYiBpbiBUcmFuc2Zvcm0gY2xhc3MnKSk7XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZCkgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0uX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0gbmV3IFRyYW5zZm9ybVN0YXRlKHRoaXMpO1xuXG4gIHZhciBzdHJlYW0gPSB0aGlzO1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHRoaXMub25jZSgncHJlZmluaXNoJywgZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgICB9KTtlbHNlIGRvbmUoc3RyZWFtKTtcbiAgfSk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSBzdHJlYW0ucHVzaChkYXRhKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICB2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHdzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAodHMudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXCIpXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChidWYpIHtcblx0Ly8gSWYgdGhlIGJ1ZmZlciBpcyBiYWNrZWQgYnkgYSBVaW50OEFycmF5LCBhIGZhc3RlciB2ZXJzaW9uIHdpbGwgd29ya1xuXHRpZiAoYnVmIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuXHRcdC8vIElmIHRoZSBidWZmZXIgaXNuJ3QgYSBzdWJhcnJheSwgcmV0dXJuIHRoZSB1bmRlcmx5aW5nIEFycmF5QnVmZmVyXG5cdFx0aWYgKGJ1Zi5ieXRlT2Zmc2V0ID09PSAwICYmIGJ1Zi5ieXRlTGVuZ3RoID09PSBidWYuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcblx0XHRcdHJldHVybiBidWYuYnVmZmVyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgYnVmLmJ1ZmZlci5zbGljZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gZ2V0IGEgcHJvcGVyIGNvcHlcblx0XHRcdHJldHVybiBidWYuYnVmZmVyLnNsaWNlKGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZU9mZnNldCArIGJ1Zi5ieXRlTGVuZ3RoKVxuXHRcdH1cblx0fVxuXG5cdGlmIChCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuXHRcdC8vIFRoaXMgaXMgdGhlIHNsb3cgdmVyc2lvbiB0aGF0IHdpbGwgd29yayB3aXRoIGFueSBCdWZmZXJcblx0XHQvLyBpbXBsZW1lbnRhdGlvbiAoZXZlbiBpbiBvbGQgYnJvd3NlcnMpXG5cdFx0dmFyIGFycmF5Q29weSA9IG5ldyBVaW50OEFycmF5KGJ1Zi5sZW5ndGgpXG5cdFx0dmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRhcnJheUNvcHlbaV0gPSBidWZbaV1cblx0XHR9XG5cdFx0cmV0dXJuIGFycmF5Q29weS5idWZmZXJcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuXHR9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3RvLWFycmF5YnVmZmVyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgdmFyIHRhcmdldCA9IHt9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi94dGVuZC9pbW11dGFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBcIjEwMFwiOiBcIkNvbnRpbnVlXCIsXG4gIFwiMTAxXCI6IFwiU3dpdGNoaW5nIFByb3RvY29sc1wiLFxuICBcIjEwMlwiOiBcIlByb2Nlc3NpbmdcIixcbiAgXCIyMDBcIjogXCJPS1wiLFxuICBcIjIwMVwiOiBcIkNyZWF0ZWRcIixcbiAgXCIyMDJcIjogXCJBY2NlcHRlZFwiLFxuICBcIjIwM1wiOiBcIk5vbi1BdXRob3JpdGF0aXZlIEluZm9ybWF0aW9uXCIsXG4gIFwiMjA0XCI6IFwiTm8gQ29udGVudFwiLFxuICBcIjIwNVwiOiBcIlJlc2V0IENvbnRlbnRcIixcbiAgXCIyMDZcIjogXCJQYXJ0aWFsIENvbnRlbnRcIixcbiAgXCIyMDdcIjogXCJNdWx0aS1TdGF0dXNcIixcbiAgXCIyMDhcIjogXCJBbHJlYWR5IFJlcG9ydGVkXCIsXG4gIFwiMjI2XCI6IFwiSU0gVXNlZFwiLFxuICBcIjMwMFwiOiBcIk11bHRpcGxlIENob2ljZXNcIixcbiAgXCIzMDFcIjogXCJNb3ZlZCBQZXJtYW5lbnRseVwiLFxuICBcIjMwMlwiOiBcIkZvdW5kXCIsXG4gIFwiMzAzXCI6IFwiU2VlIE90aGVyXCIsXG4gIFwiMzA0XCI6IFwiTm90IE1vZGlmaWVkXCIsXG4gIFwiMzA1XCI6IFwiVXNlIFByb3h5XCIsXG4gIFwiMzA3XCI6IFwiVGVtcG9yYXJ5IFJlZGlyZWN0XCIsXG4gIFwiMzA4XCI6IFwiUGVybWFuZW50IFJlZGlyZWN0XCIsXG4gIFwiNDAwXCI6IFwiQmFkIFJlcXVlc3RcIixcbiAgXCI0MDFcIjogXCJVbmF1dGhvcml6ZWRcIixcbiAgXCI0MDJcIjogXCJQYXltZW50IFJlcXVpcmVkXCIsXG4gIFwiNDAzXCI6IFwiRm9yYmlkZGVuXCIsXG4gIFwiNDA0XCI6IFwiTm90IEZvdW5kXCIsXG4gIFwiNDA1XCI6IFwiTWV0aG9kIE5vdCBBbGxvd2VkXCIsXG4gIFwiNDA2XCI6IFwiTm90IEFjY2VwdGFibGVcIixcbiAgXCI0MDdcIjogXCJQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiLFxuICBcIjQwOFwiOiBcIlJlcXVlc3QgVGltZW91dFwiLFxuICBcIjQwOVwiOiBcIkNvbmZsaWN0XCIsXG4gIFwiNDEwXCI6IFwiR29uZVwiLFxuICBcIjQxMVwiOiBcIkxlbmd0aCBSZXF1aXJlZFwiLFxuICBcIjQxMlwiOiBcIlByZWNvbmRpdGlvbiBGYWlsZWRcIixcbiAgXCI0MTNcIjogXCJQYXlsb2FkIFRvbyBMYXJnZVwiLFxuICBcIjQxNFwiOiBcIlVSSSBUb28gTG9uZ1wiLFxuICBcIjQxNVwiOiBcIlVuc3VwcG9ydGVkIE1lZGlhIFR5cGVcIixcbiAgXCI0MTZcIjogXCJSYW5nZSBOb3QgU2F0aXNmaWFibGVcIixcbiAgXCI0MTdcIjogXCJFeHBlY3RhdGlvbiBGYWlsZWRcIixcbiAgXCI0MThcIjogXCJJJ20gYSB0ZWFwb3RcIixcbiAgXCI0MjFcIjogXCJNaXNkaXJlY3RlZCBSZXF1ZXN0XCIsXG4gIFwiNDIyXCI6IFwiVW5wcm9jZXNzYWJsZSBFbnRpdHlcIixcbiAgXCI0MjNcIjogXCJMb2NrZWRcIixcbiAgXCI0MjRcIjogXCJGYWlsZWQgRGVwZW5kZW5jeVwiLFxuICBcIjQyNVwiOiBcIlVub3JkZXJlZCBDb2xsZWN0aW9uXCIsXG4gIFwiNDI2XCI6IFwiVXBncmFkZSBSZXF1aXJlZFwiLFxuICBcIjQyOFwiOiBcIlByZWNvbmRpdGlvbiBSZXF1aXJlZFwiLFxuICBcIjQyOVwiOiBcIlRvbyBNYW55IFJlcXVlc3RzXCIsXG4gIFwiNDMxXCI6IFwiUmVxdWVzdCBIZWFkZXIgRmllbGRzIFRvbyBMYXJnZVwiLFxuICBcIjQ1MVwiOiBcIlVuYXZhaWxhYmxlIEZvciBMZWdhbCBSZWFzb25zXCIsXG4gIFwiNTAwXCI6IFwiSW50ZXJuYWwgU2VydmVyIEVycm9yXCIsXG4gIFwiNTAxXCI6IFwiTm90IEltcGxlbWVudGVkXCIsXG4gIFwiNTAyXCI6IFwiQmFkIEdhdGV3YXlcIixcbiAgXCI1MDNcIjogXCJTZXJ2aWNlIFVuYXZhaWxhYmxlXCIsXG4gIFwiNTA0XCI6IFwiR2F0ZXdheSBUaW1lb3V0XCIsXG4gIFwiNTA1XCI6IFwiSFRUUCBWZXJzaW9uIE5vdCBTdXBwb3J0ZWRcIixcbiAgXCI1MDZcIjogXCJWYXJpYW50IEFsc28gTmVnb3RpYXRlc1wiLFxuICBcIjUwN1wiOiBcIkluc3VmZmljaWVudCBTdG9yYWdlXCIsXG4gIFwiNTA4XCI6IFwiTG9vcCBEZXRlY3RlZFwiLFxuICBcIjUwOVwiOiBcIkJhbmR3aWR0aCBMaW1pdCBFeGNlZWRlZFwiLFxuICBcIjUxMFwiOiBcIk5vdCBFeHRlbmRlZFwiLFxuICBcIjUxMVwiOiBcIk5ldHdvcmsgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcIlxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9idWlsdGluLXN0YXR1cy1jb2Rlcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcblxudmFyIGh0dHBzID0gbW9kdWxlLmV4cG9ydHM7XG5cbmZvciAodmFyIGtleSBpbiBodHRwKSB7XG4gICAgaWYgKGh0dHAuaGFzT3duUHJvcGVydHkoa2V5KSkgaHR0cHNba2V5XSA9IGh0dHBba2V5XTtcbn07XG5cbmh0dHBzLnJlcXVlc3QgPSBmdW5jdGlvbiAocGFyYW1zLCBjYikge1xuICAgIGlmICghcGFyYW1zKSBwYXJhbXMgPSB7fTtcbiAgICBwYXJhbXMuc2NoZW1lID0gJ2h0dHBzJztcbiAgICBwYXJhbXMucHJvdG9jb2wgPSAnaHR0cHM6JztcbiAgICByZXR1cm4gaHR0cC5yZXF1ZXN0LmNhbGwodGhpcywgcGFyYW1zLCBjYik7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2h0dHBzLWJyb3dzZXJpZnkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIChpZ25vcmVkKSAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGZzIChpZ25vcmVkKVxuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiY29uc3QgZGVmYXVsdFBhcmFtcyA9IHtcbiAgICBwcm9wb3J0aW9uczogMC41LFxuICAgIGNvcm5lclNpemU6IDIwXG59O1xuXG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0UGFyYW1zO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RyYXdUb29sL2RhZmF1bHRQYXJhbXMuanMiLCIvKipcbiAqXG4gKiBAcGFyYW0gdGl0bGUge1N0cmluZ31cbiAqIEBwYXJhbSB1cmxzIHtPYmplY3R9XG4gKiBAcGFyYW0gdXJscy5lb3Qge1N0cmluZ31cbiAqIEBwYXJhbSB1cmxzLnR0ZiB7U3RyaW5nfVxuICogQHBhcmFtIHVybHMud29mZiB7U3RyaW5nfVxuICogQHBhcmFtIHVybHMud29mZjIge1N0cmluZ31cbiAqIEBwYXJhbSB1cmxzLnN2ZyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBmb250TG9hZGVyKHRpdGxlLCB1cmxzKXtcblxuICBsZXQgZm9udEZhY2UgPSBgQGZvbnQtZmFjZSB7Zm9udC1mYW1pbHk6ICcke3RpdGxlfSc7XG4gICAgc3JjOiB1cmwoJyR7dXJscy5lb3QgfHwgJyd9Jyk7XG4gICAgc3JjOiB1cmwoJyR7dXJscy5lb3QgfHwgJyd9PyNpZWZpeCcpIGZvcm1hdCgnZW1iZWRkZWQtb3BlbnR5cGUnKSxcbiAgICAgIHVybCgnJHt1cmxzLndvZmYyIHx8ICcnfScpIGZvcm1hdCgnd29mZjInKSxcbiAgICAgIHVybCgnJHt1cmxzLndvZmYgfHwgJyd9JykgZm9ybWF0KCd3b2ZmJyksXG4gICAgICB1cmwoJyR7dXJscy50dGYgfHwgJyd9JykgZm9ybWF0KCd0cnVldHlwZScpLFxuICAgICAgdXJsKCcke3VybHMuc3ZnIHx8ICcnfScpIGZvcm1hdCgnc3ZnJyk7XG4gICAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcbiAgICBmb250LXN0eWxlOiBub3JtYWw7XG4gIH1gO1xuXG4gIHRoaXMuZm9udHNbdGl0bGVdID0gdXJscztcblxuICBsZXQgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICBzdHlsZS5pbm5lclRleHQgPSBmb250RmFjZTtcbiAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cbiAgbGV0IGZvcmNlQ2FsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgZm9yY2VDYWxsLmlubmVyVGV4dCA9ICcmbmJzcDsnO1xuICBmb3JjZUNhbGwuc3R5bGUuZm9udEZhbWlseSA9IHRpdGxlO1xuICBmb3JjZUNhbGwuc3R5bGUudGV4dEluZGVudCA9ICctOTk5OTlweCc7XG4gIGZvcmNlQ2FsbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSdcbiAgZm9yY2VDYWxsLnN0eWxlLnpJbmRleCA9ICcwJztcbiAgZm9yY2VDYWxsLnN0eWxlLmxlZnQgPSAnLTk5OTlweCc7XG4gIGZvcmNlQ2FsbC5zdHlsZS50b3AgPSAnLTk5OTlweCc7XG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JjZUNhbGwpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmb250TG9hZGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RyYXdUb29sL3V0aWxzL2ZvbnRMb2FkZXIuanMiLCJjb25zdCBlcnJvcnMgPSB7XG4gIHNpZGVOb1NpemU6IHtcbiAgICBjb2RlOiAxLFxuICAgIG1lc3NhZ2U6ICdTaWRlIGhhcyBubyBzaXplJ1xuICB9LFxuICBzaWRlTm9Cb3JkZXI6IHtcbiAgICBjb2RlOiAyLFxuICAgIG1lc3NhZ2U6ICdTaWRlIGhhcyBubyB3b3JrIGFyZWEnXG4gIH0sXG4gIEhUTUxFbGVtZW50VW5kZWZpbmVkOiB7XG4gICAgY29kZTogMyxcbiAgICBtZXNzYWdlOiAnRHJhd1Rvb2w6IFRhcmdldCBzaG91bGQgYmUgYSBIVE1MRWxlbWVudCdcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBlcnJvcnM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZHJhd1Rvb2wvdXRpbHMvZXJyb3JzLmpzIiwiZnVuY3Rpb24gZXNjYXBlSlNPTihzdHJpbmcpe1xuXG4gIGxldCBzdHIgPSBzdHJpbmcucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIilcbiAgICAucmVwbGFjZSgvXFxyL2csIFwiXFxcXHJcIilcbiAgICAucmVwbGFjZSgvXFx0L2csIFwiXFxcXHRcIik7XG5cbiAgcmV0dXJuIHN0cjtcblxufVxuXG5leHBvcnQgZGVmYXVsdCBlc2NhcGVKU09OO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RyYXdUb29sL3V0aWxzL2VzY2FwZUpTT04uanMiLCJpbXBvcnQge2ZhYnJpY30gZnJvbSAnZmFicmljJztcblxuZnVuY3Rpb24gdXVpZCgpIHtcbiAgcmV0dXJuICd4eHh4eHh4eHh4eHg0eHh4eXh4eHh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCwgdiA9IGMgPT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcbiAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gIH0pO1xufVxuXG5mYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5zZXRPcHRpb25zID0gKGZ1bmN0aW9uIChzZXRPcHRpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHNldE9wdGlvbnMuYXBwbHkodGhpcywgW29wdGlvbnNdKTtcbiAgICB0aGlzLnV1aWQgPSB0aGlzLnV1aWQgfHwgdXVpZCgpO1xuICB9O1xufSkoZmFicmljLk9iamVjdC5wcm90b3R5cGUuc2V0T3B0aW9ucyk7XG5cbmZhYnJpYy5PYmplY3QucHJvdG90eXBlLnRvT2JqZWN0ID0gKGZ1bmN0aW9uICh0b09iamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICBwcm9wZXJ0aWVzVG9JbmNsdWRlID0gKHByb3BlcnRpZXNUb0luY2x1ZGUgfHwgW10pLmNvbmNhdChbJ3V1aWQnXSk7XG4gICAgcmV0dXJuIHRvT2JqZWN0LmFwcGx5KHRoaXMsIFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSk7XG4gIH07XG59KShmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS50b09iamVjdCk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZHJhd1Rvb2wvdXRpbHMvZmFicmljLnV1aWQuanMiLCJpbXBvcnQge2ZhYnJpY30gZnJvbSAnZmFicmljJztcbmltcG9ydCBEcmF3VG9vbCBmcm9tICcuL0RyYXdUb29sJztcbmltcG9ydCBTaWRlIGZyb20gJy4vU2lkZSc7XG5pbXBvcnQgZXNjYXBlSlNPTiBmcm9tICcuL3V0aWxzL2VzY2FwZUpTT04nO1xuXG4vKipcbiAqIFNpZGVzIGNsYXNzXG4gKi9cbmNsYXNzIFNpZGVze1xuXG4gIGNvbnN0cnVjdG9yKCl7XG4gICAgdGhpcy5fY29sbGVjdGlvbiA9IFtdO1xuICAgIC8qKlxuICAgICAqIEN1cnJlbnRseSBzZWxlY3RlZCBzaWRlXG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEB0eXBlIHtTaWRlfVxuICAgICAqL1xuICAgIHRoaXMuc2VsZWN0ZWQgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZGluZyBhIHNpZGVcbiAgICogQHBhcmFtIGlkXG4gICAqIEByZXR1cm4ge1NpZGV9XG4gICAqL1xuICBhZGRTaWRlKGlkKXtcbiAgICBsZXQgbmV3U2lkZSA9IG5ldyBTaWRlKGlkKTtcbiAgICB0aGlzLl9jb2xsZWN0aW9uLnB1c2gobmV3U2lkZSk7XG4gICAgcmV0dXJuIG5ld1NpZGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHNpZGUgYXMgcGxhaW4gSkF2YVNjcmlwdCBvYmplY3QuXG4gICAqIEBwYXJhbSBpZCB7U3RyaW5nfSBJZCBvZiBzaWRlXG4gICAqIEByZXR1cm4gc2lkZXMge09iamVjdH1cbiAgICovXG4gIGdldFNpZGUoaWQpe1xuICAgIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uLmZpbmQoKHNpZGUpID0+IHNpZGUuaWQgPT09IGlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3Qgc2lkZVxuICAgKiBAcGFyYW0gaWQge1N0cmluZ31cbiAgICovXG4gIHNlbGVjdChpZCkge1xuXG4gICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuX2NvbGxlY3Rpb24uZmluZCgoc2lkZSkgPT4gc2lkZS5pZCA9PT0gaWQpO1xuXG4gICAgaWYoIXRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLl9jb2xsZWN0aW9uLmZvckVhY2goKHNpZGUpID0+IHNpZGUuRmFicmljQ2FudmFzLndyYXBwZXJFbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnKTtcbiAgICB0aGlzLnNlbGVjdGVkLkZhYnJpY0NhbnZhcy53cmFwcGVyRWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICByZXR1cm4gdGhpcy5zZWxlY3RlZDtcblxuICB9XG5cbiAgLyoqXG4gICAqIEdldHRpbmcgd2hvbGUgY29sbGVjdGlvbiBhcyBKU09OXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIHRvSlNPTigpe1xuXG4gICAgbGV0IHNpZGVzID0gW107XG5cbiAgICB0aGlzLl9jb2xsZWN0aW9uLmZvckVhY2goc2lkZSA9PiB7XG4gICAgICBzaWRlcy5wdXNoKHNpZGUudG9PYmplY3QoKSlcbiAgICB9KTtcblxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzaWRlcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHNpZGUgYnkgaWRcbiAgICogQHBhcmFtIGlkXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICByZW1vdmVTaWRlKGlkKXtcbiAgICBsZXQgc2lkZSA9IHRoaXMuX2NvbGxlY3Rpb24uZmluZCgoc2lkZSkgPT4gc2lkZS5pZCA9PT0gaWQpO1xuICAgIGxldCBpbmRleCA9IHRoaXMuX2NvbGxlY3Rpb24uZmluZEluZGV4KChzaWRlKSA9PiBzaWRlLmlkID09PSBpZCk7XG5cbiAgICBpZighc2lkZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgc2lkZS5GYWJyaWNDYW52YXMuY2xlYXIoKTtcbiAgICBzaWRlLkZhYnJpY0NhbnZhcyA9IHVuZGVmaW5lZDtcbiAgICBzaWRlLmNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNpZGUuY2FudmFzKTtcblxuICAgIHRoaXMuc2VsZWN0ZWQgPSBudWxsO1xuXG4gICAgdGhpcy5fY29sbGVjdGlvbi5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogRW1wdHkgc2lkZXNcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBlbXB0eSgpe1xuXG4gICAgbGV0IGNvbGxlY3Rpb24gPSB0aGlzLl9jb2xsZWN0aW9uLm1hcChzaWRlID0+IHNpZGUuaWQpO1xuXG4gICAgY29sbGVjdGlvbi5mb3JFYWNoKGlkID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlU2lkZShpZCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbjtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTaWRlcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RyYXdUb29sL1NpZGVzLmpzIiwiaW1wb3J0IHtmYWJyaWN9IGZyb20gJ2ZhYnJpYyc7XG5pbXBvcnQgRHJhd1Rvb2wgZnJvbSAnLi9EcmF3VG9vbCc7XG5pbXBvcnQgSXRlbXMgZnJvbSAnLi9JdGVtcyc7XG5pbXBvcnQgTGF5ZXJzIGZyb20gJy4vTGF5ZXJzJztcbmltcG9ydCBlcnJvcnMgZnJvbSAnLi91dGlscy9lcnJvcnMnO1xuaW1wb3J0IGVzY2FwZUpTT04gZnJvbSAnLi91dGlscy9lc2NhcGVKU09OJztcbmltcG9ydCBjb2xvclBpY2tlciBmcm9tICcuL3V0aWxzL2NvbG9yUGlja2VyJztcbmltcG9ydCBjbGlwIGZyb20gJy4vdXRpbHMvY2xpcCc7XG5cbi8qKlxuICogU2lkZSBjbGFzc1xuICovXG5jbGFzcyBTaWRle1xuXG4gIC8qKlxuICAgKiBTaWRlIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSBpZCB7U3RyaW5nfVxuICAgKi9cbiAgY29uc3RydWN0b3IoaWQpe1xuXG4gICAgbGV0IHRoYXQgPSB0aGlzO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBpZDtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBhZGRpbmcgPSAxMDtcblxuICAgIC8qKlxuICAgICAqIENhbnZhcyBwYW5uaW5nXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLl9wYW5uaW5nID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBCYWNrZHJvcCBpbWFnZSB1cmxcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VVcmwgPSBudWxsO1xuXG4gICAgdGhpcy5jb250YWluZXIud2lkdGggPSBEcmF3VG9vbC5jb250YWluZXIuc2l6ZS53aWR0aCB8fCBEcmF3VG9vbC5jb250YWluZXIudGFyZ2V0LmNsaWVudFdpZHRoO1xuICAgIHRoaXMuY29udGFpbmVyLmhlaWdodCA9IERyYXdUb29sLmNvbnRhaW5lci5zaXplLmhlaWdodCB8fCBEcmF3VG9vbC5jb250YWluZXIudGFyZ2V0LmNsaWVudEhlaWdodDtcbiAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgdGhpcy5jb250YWluZXIuc3R5bGUudG9wID0gJzAnO1xuICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmxlZnQgPSAnMCc7XG5cbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IERyYXdUb29sLmNvbnRhaW5lci5zaXplLndpZHRoIHx8IERyYXdUb29sLmNvbnRhaW5lci50YXJnZXQuY2xpZW50V2lkdGg7XG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gRHJhd1Rvb2wuY29udGFpbmVyLnNpemUuaGVpZ2h0IHx8IERyYXdUb29sLmNvbnRhaW5lci50YXJnZXQuY2xpZW50SGVpZ2h0O1xuXG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuXG4gICAgRHJhd1Rvb2wuY29udGFpbmVyLnRhcmdldC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG5cbiAgICB0aGlzLl9pbml0RmFicmljKCk7XG4gICAgdGhpcy5faW5pdEV2ZW50cygpO1xuXG4gICAgdGhpcy5pdGVtcyA9IG5ldyBJdGVtcyh0aGlzKTtcblxuICAgIHRoaXMubGF5ZXJzID0gbmV3IExheWVycyh0aGlzKTtcblxuICAgIHRoaXMuY3VycmVudEJydXNoID0gJ1BlbmNpbEJydXNoJztcblxuICAgIHRoaXMuY29sb3JQaWNrZXIgPSBuZXcgY29sb3JQaWNrZXIodGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9XG5cbiAgc2V0IHBhbm5pbmcodmFsKXtcbiAgICBpZihCb29sZWFuKHZhbCkgPT09IHRydWUgJiYgdGhpcy5GYWJyaWNDYW52YXMuaXNEcmF3aW5nTW9kZSA9PT0gdHJ1ZSl7XG4gICAgICByZXR1cm4gdGhpcy5fcGFubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLml0ZW1zLnNlbGVjdGVkLmRlYWN0aXZhdGUoKTtcbiAgICB0aGlzLml0ZW1zLl9jb2xsZWN0aW9uLmZvckVhY2gob2JqZWN0ID0+IG9iamVjdC5zZWxlY3RhYmxlID0gIXZhbCk7XG4gICAgcmV0dXJuIHRoaXMuX3Bhbm5pbmcgPSB2YWw7XG4gIH1cblxuICBnZXQgcGFubmluZygpe1xuICAgIHJldHVybiB0aGlzLl9wYW5uaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBzaWRlIGltYWdlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAgICogQHBhcmFtIHNpemUge09iamVjdH0gc2l6ZVxuICAgKiBAcGFyYW0gc2l6ZS53aWR0aCB7TnVtYmVyfSBXaWR0aCBvZiBpbWFnZSBpbiBjZW50aW1ldGVyc1xuICAgKiBAcGFyYW0gc2l6ZS5oZWlnaHQge051bWJlcn0gSGVpZ2h0IG9mIGltYWdlIGluIGNlbnRpbWV0ZXJzXG4gICAqIEBwYXJhbSBwcm9wb3J0aW9ucyB7TnVtYmVyfVxuICAgKiBAcGFyYW0gYm9yZGVyU2l6ZSB7T2JqZWN0fVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgc2V0SW1hZ2UodXJsLCBzaXplLCBwcm9wb3J0aW9ucyA9IDEsIGJvcmRlclNpemUgPSBudWxsKXtcblxuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG5cbiAgICB0aGlzLmltYWdlVXJsID0gdXJsO1xuXG4gICAgbGV0IGNlbnRlciA9IHRoaXMuRmFicmljQ2FudmFzLmdldENlbnRlcigpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgdGhpcy5GYWJyaWNDYW52YXMuc2V0QmFja2dyb3VuZENvbG9yKCcjZmZmZmZmJyk7XG5cbiAgICAgIHRoaXMuRmFicmljQ2FudmFzLnNldEJhY2tncm91bmRJbWFnZSh1cmwsIGltZyA9PiB7XG5cbiAgICAgICAgdGhpcy5iYWNrZHJvcCA9IHRoaXMuRmFicmljQ2FudmFzLmJhY2tncm91bmRJbWFnZTtcblxuICAgICAgICB0aGlzLmJhY2tkcm9wLmV4Y2x1ZGVGcm9tRXhwb3J0ID0gdHJ1ZTtcblxuICAgICAgICBsZXQgY2FudmFzQXNwZWN0UmF0aW8gPSB0aGlzLmNhbnZhcy53aWR0aCAvIHRoaXMuY2FudmFzLmhlaWdodDtcbiAgICAgICAgbGV0IGJvcmRlckFzcGVjdFJhdGlvID0gYm9yZGVyU2l6ZS53aWR0aCAvIGJvcmRlclNpemUuaGVpZ2h0O1xuXG4gICAgICAgIGlmKGNhbnZhc0FzcGVjdFJhdGlvIDwgYm9yZGVyQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICBsZXQgY2FudmFzUHJvcG9ydGlvbnMgPSB0aGlzLkZhYnJpY0NhbnZhcy53aWR0aCAvIHRoaXMuc2l6ZS53aWR0aDtcbiAgICAgICAgICB0aGlzLmJnUHJvcG9ydGlvbnMgPSAodGhpcy5GYWJyaWNDYW52YXMud2lkdGggKiBwcm9wb3J0aW9ucykgLyAoYm9yZGVyU2l6ZS53aWR0aCAqIGNhbnZhc1Byb3BvcnRpb25zKTtcblxuICAgICAgICAgIHRoaXMuYmFja2Ryb3Auc2NhbGVUb1dpZHRoKHRoaXMuc2l6ZS53aWR0aCAqIGNhbnZhc1Byb3BvcnRpb25zICogdGhpcy5iZ1Byb3BvcnRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgY2FudmFzUHJvcG9ydGlvbnMgPSB0aGlzLkZhYnJpY0NhbnZhcy5oZWlnaHQgLyB0aGlzLnNpemUuaGVpZ2h0O1xuICAgICAgICAgIHRoaXMuYmdQcm9wb3J0aW9ucyA9ICh0aGlzLkZhYnJpY0NhbnZhcy5oZWlnaHQgKiBwcm9wb3J0aW9ucykgLyAoYm9yZGVyU2l6ZS5oZWlnaHQgKiBjYW52YXNQcm9wb3J0aW9ucyk7XG5cbiAgICAgICAgICB0aGlzLmJhY2tkcm9wLnNjYWxlVG9IZWlnaHQodGhpcy5zaXplLmhlaWdodCAqIGNhbnZhc1Byb3BvcnRpb25zICogdGhpcy5iZ1Byb3BvcnRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NldE9mZnNldChib3JkZXJTaXplKTtcblxuICAgICAgICB0aGlzLkZhYnJpY0NhbnZhcy5iYWNrZ3JvdW5kSW1hZ2UudG9wIC09IHRoaXMuYmdPZmZzZXQudG9wO1xuICAgICAgICB0aGlzLkZhYnJpY0NhbnZhcy5iYWNrZ3JvdW5kSW1hZ2UubGVmdCAtPSB0aGlzLmJnT2Zmc2V0LmxlZnQ7XG5cbiAgICAgICAgdGhpcy5jbVNpemUgPSB0aGlzLl9jYWxjdWxhdGVTaXplKCk7XG5cbiAgICAgICAgdGhpcy5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG5cbiAgICAgICAgRHJhd1Rvb2wudHJpZ2dlcignYmFja2Ryb3A6bG9hZGVkJywge3NpZGU6IHtpZDogdGhpcy5pZH19KTtcblxuICAgICAgICBEcmF3VG9vbC5oaXN0b3J5LnB1c2hTdGF0ZSh0aGlzLmlkKTtcbiAgICAgICAgcmVzb2x2ZSh7c2lkZToge2lkOiB0aGlzLmlkfX0pO1xuICAgICAgfSwge1xuICAgICAgICB0b3A6IGNlbnRlci50b3AsXG4gICAgICAgIGxlZnQ6IGNlbnRlci5sZWZ0LFxuICAgICAgICBvcmlnaW5YOiAnY2VudGVyJyxcbiAgICAgICAgb3JpZ2luWTogJ2NlbnRlcicsXG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIGNyb3NzT3JpZ2luOiAnYW5vbnltb3VzJ1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGltYWdlIHNpemVcbiAgICogQHBhcmFtIHNpemVcbiAgICogQHBhcmFtIHNpemUge09iamVjdH0gc2l6ZVxuICAgKiBAcGFyYW0gc2l6ZS53aWR0aCB7TnVtYmVyfSBXaWR0aCBvZiBpbWFnZSBpbiBjZW50aW1ldGVyc1xuICAgKiBAcGFyYW0gc2l6ZS5oZWlnaHQge051bWJlcn0gSGVpZ2h0IG9mIGltYWdlIGluIGNlbnRpbWV0ZXJzXG4gICAqL1xuICB1cGRhdGVTaXplKHNpemUpe1xuXG4gICAgdGhpcy5zaXplID0gc2l6ZTtcblxuICAgIHRoaXMuY21TaXplID0gdGhpcy5fY2FsY3VsYXRlU2l6ZSgpO1xuXG4gICAgdGhpcy5pbml0R3JpZCgpO1xuICAgIHRoaXMuaW5pdFJ1bGVyKCk7XG5cbiAgICBpZih0aGlzLkZhYnJpY0JvcmRlcikge1xuICAgICAgdGhpcy5pbml0V29ya3NwYWNlR3JpZCgpO1xuICAgICAgdGhpcy5pbml0V29ya3NwYWNlUnVsZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgaW1hZ2VcbiAgICovXG4gIHJlbW92ZUltYWdlKCl7XG4gICAgdGhpcy5GYWJyaWNDYW52YXMucmVtb3ZlKHRoaXMuYmFja2Ryb3ApO1xuICAgIHRoaXMuYmFja2Ryb3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucy53aWR0aCB7TnVtYmVyfSBXaWR0aCBvZiBib3JkZXJcbiAgICogQHBhcmFtIG9wdGlvbnMuaGVpZ2h0IHtOdW1iZXJ9IEhlaWdodCBvZiBib3JkZXJcbiAgICogQHBhcmFtIG9wdGlvbnMudG9wIHtOdW1iZXJ9IFRvcCBwb3NpdGlvblxuICAgKiBAcGFyYW0gb3B0aW9ucy5sZWZ0IHtOdW1iZXJ9IExlZnQgcG9zaXRpb25cbiAgICovXG4gIHNldEJvcmRlcihvcHRpb25zKXtcblxuICAgIGlmKCF0aGlzLmNtU2l6ZSl7XG4gICAgICB0aHJvdyAoIG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeSh7ZXJyb3I6IGVycm9ycy5zaWRlTm9TaXplfSkpICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYoIW9wdGlvbnMpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmKHRoaXMuRmFicmljQm9yZGVyKSB7XG4gICAgICB0aGlzLkZhYnJpY0JvcmRlci5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLmJvcmRlciA9IG9wdGlvbnM7XG5cbiAgICBsZXQgX29wdHMgPSB7XG4gICAgICBzdHJva2VXaWR0aDogRHJhd1Rvb2wuYm9yZGVyLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlOiBEcmF3VG9vbC5ib3JkZXIuY29sb3IsXG4gICAgICBmaWxsOiBEcmF3VG9vbC5ib3JkZXIuYmFja2dyb3VuZENvbG9yLFxuICAgICAgaGFzUm90YXRpbmdQb2ludDogZmFsc2UsXG4gICAgICBsb2NrUm90YXRpb246IHRydWUsXG4gICAgICBzdHJva2VEYXNoQXJyYXk6IERyYXdUb29sLmJvcmRlci5zdHJva2VEYXNoQXJyYXlcbiAgICB9O1xuXG4gICAgbGV0IHBhZGRpbmdUb3AgPSAodGhpcy5GYWJyaWNDYW52YXMuaGVpZ2h0IC0gKHRoaXMuYmFja2Ryb3AuaGVpZ2h0ICogdGhpcy5iYWNrZHJvcC5zY2FsZVkpKSAvIDI7XG4gICAgbGV0IHBhZGRpbmdMZWZ0ID0gKHRoaXMuRmFicmljQ2FudmFzLndpZHRoIC0gKHRoaXMuYmFja2Ryb3Aud2lkdGggKiB0aGlzLmJhY2tkcm9wLnNjYWxlWCkpIC8gMjtcblxuICAgIGxldCBfb3B0aW9ucyA9IHtcbiAgICAgIHdpZHRoOiBvcHRpb25zLndpZHRoICogdGhpcy5jbVNpemUud2lkdGgsXG4gICAgICBoZWlnaHQ6IG9wdGlvbnMuaGVpZ2h0ICogdGhpcy5jbVNpemUuaGVpZ2h0LFxuICAgICAgdG9wOiBvcHRpb25zLnRvcCAqIHRoaXMuY21TaXplLmhlaWdodCArIHBhZGRpbmdUb3AgLSB0aGlzLmJnT2Zmc2V0LnRvcCxcbiAgICAgIGxlZnQ6IG9wdGlvbnMubGVmdCAqIHRoaXMuY21TaXplLndpZHRoICsgcGFkZGluZ0xlZnQgLSB0aGlzLmJnT2Zmc2V0LmxlZnRcbiAgICB9O1xuXG4gICAgdGhpcy5GYWJyaWNCb3JkZXIgPSBuZXcgZmFicmljLlJlY3Qoe1xuICAgICAgLi4uX29wdHMsXG4gICAgICAuLi5fb3B0aW9uc1xuICAgIH0pO1xuXG4gICAgdGhpcy5GYWJyaWNCb3JkZXIuc2V0Q29vcmRzKCk7XG4gICAgdGhpcy5GYWJyaWNCb3JkZXIuaWQgPSAnRmFicmljQm9yZGVyJztcblxuICAgIHRoaXMuRmFicmljQm9yZGVyLmV4Y2x1ZGVGcm9tRXhwb3J0ID0gdHJ1ZTtcbiAgICB0aGlzLkZhYnJpY0JvcmRlci5zZWxlY3RhYmxlID0gRHJhd1Rvb2wuZWRpdGFibGU7XG4gICAgdGhpcy5GYWJyaWNCb3JkZXIuaG92ZXJDdXJzb3IgPSAnZGVmYXVsdCc7XG5cbiAgICB0aGlzLkZhYnJpY0NhbnZhcy5hZGQodGhpcy5GYWJyaWNCb3JkZXIpO1xuICAgIHRoaXMuY2VudGVyID0gdGhpcy5GYWJyaWNCb3JkZXIuZ2V0Q2VudGVyUG9pbnQoKTtcblxuICAgIHRoaXMuRmFicmljQ2FudmFzLnJlbmRlckFsbCgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYm9yZGVyXG4gICAqIEByZXR1cm4geyBjbToge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSwgcGl4ZWw6IHt9fVxuICAgKi9cbiAgZ2V0Qm9yZGVyKCkge1xuXG4gICAgbGV0IHBhZGRpbmdUb3AgPSAodGhpcy5GYWJyaWNDYW52YXMuaGVpZ2h0IC0gKHRoaXMuYmFja2Ryb3AuaGVpZ2h0ICogdGhpcy5iYWNrZHJvcC5zY2FsZVkpKSAvIDI7XG4gICAgbGV0IHBhZGRpbmdMZWZ0ID0gKHRoaXMuRmFicmljQ2FudmFzLndpZHRoIC0gKHRoaXMuYmFja2Ryb3Aud2lkdGggKiB0aGlzLmJhY2tkcm9wLnNjYWxlWCkpIC8gMjtcblxuICAgIHJldHVybiB7XG4gICAgICBjbToge1xuICAgICAgICBsZWZ0OiAodGhpcy5GYWJyaWNCb3JkZXIubGVmdCArIHRoaXMuYmdPZmZzZXQubGVmdCAtIHBhZGRpbmdMZWZ0KSAvIHRoaXMuY21TaXplLndpZHRoLFxuICAgICAgICB0b3A6ICh0aGlzLkZhYnJpY0JvcmRlci50b3AgKyB0aGlzLmJnT2Zmc2V0LnRvcCAtIHBhZGRpbmdUb3ApIC8gdGhpcy5jbVNpemUuaGVpZ2h0LFxuICAgICAgICB3aWR0aDogKHRoaXMuRmFicmljQm9yZGVyLndpZHRoICogdGhpcy5GYWJyaWNCb3JkZXIuc2NhbGVYKSAvIHRoaXMuY21TaXplLndpZHRoLFxuICAgICAgICBoZWlnaHQ6ICh0aGlzLkZhYnJpY0JvcmRlci5oZWlnaHQgKiB0aGlzLkZhYnJpY0JvcmRlci5zY2FsZVkpIC8gdGhpcy5jbVNpemUuaGVpZ2h0LFxuICAgICAgfSxcbiAgICAgIHBpeGVsOiB7XG4gICAgICAgIGxlZnQ6IHRoaXMuRmFicmljQm9yZGVyLmxlZnQgKyB0aGlzLmJnT2Zmc2V0LmxlZnQgLSBwYWRkaW5nTGVmdCxcbiAgICAgICAgdG9wOiB0aGlzLkZhYnJpY0JvcmRlci50b3AgKyB0aGlzLmJnT2Zmc2V0LnRvcCAtIHBhZGRpbmdUb3AsXG4gICAgICAgIHdpZHRoOiB0aGlzLkZhYnJpY0JvcmRlci53aWR0aCAqIHRoaXMuRmFicmljQm9yZGVyLnNjYWxlWCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLkZhYnJpY0JvcmRlci5oZWlnaHQgKiB0aGlzLkZhYnJpY0JvcmRlci5zY2FsZVksXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHpvb21Ub1ZhbCh2YWwpe1xuICAgIGxldCBjZW50ZXIgPSB0aGlzLkZhYnJpY0JvcmRlci5nZXRDZW50ZXJQb2ludCgpO1xuICAgIHRoaXMuRmFicmljQ2FudmFzLnpvb21Ub1BvaW50KGNlbnRlciwgdmFsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBab29tIHJlbGF0aXZlIHRvIGJvcmRlclxuICAgKiBAcmV0dXJuIHtTaWRlfVxuICAgKi9cbiAgem9vbUluKCl7XG4gICAgbGV0IHpvb20gPSB0aGlzLkZhYnJpY0NhbnZhcy5nZXRab29tKCk7XG4gICAgaWYoem9vbSA8PSAyKSB7XG4gICAgICBsZXQgY2VudGVyID0gdGhpcy5GYWJyaWNCb3JkZXIuZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICAgIHRoaXMuRmFicmljQ2FudmFzLnpvb21Ub1BvaW50KGNlbnRlciwgem9vbSAqIDEuMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFpvb20gcmVsYXRpdmUgdG8gYm9yZGVyXG4gICAqIEByZXR1cm4ge1NpZGV9XG4gICAqL1xuICB6b29tT3V0KCl7XG4gICAgbGV0IHpvb20gPSB0aGlzLkZhYnJpY0NhbnZhcy5nZXRab29tKCk7XG4gICAgaWYoem9vbSA+PSAwLjIpIHtcbiAgICAgIGxldCBjZW50ZXIgPSB0aGlzLkZhYnJpY0JvcmRlci5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgdGhpcy5GYWJyaWNDYW52YXMuem9vbVRvUG9pbnQoY2VudGVyLCB6b29tIC8gMS4xKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogWm9vbSByZWxhdGl2ZSB0byB2aWV3cG9ydFxuICAgKiBAcmV0dXJuIHtTaWRlfVxuICAgKi9cbiAgem9vbUluVlAoKXtcbiAgICBsZXQgem9vbSA9IHRoaXMuRmFicmljQ2FudmFzLmdldFpvb20oKTtcbiAgICBsZXQgY2VudGVyID0gbmV3IGZhYnJpYy5Qb2ludCh0aGlzLkZhYnJpY0NhbnZhcy5nZXRXaWR0aCgpIC8gMiwgdGhpcy5GYWJyaWNDYW52YXMuZ2V0SGVpZ2h0KCkgLyAyKTtcbiAgICB0aGlzLkZhYnJpY0NhbnZhcy56b29tVG9Qb2ludChjZW50ZXIsIHpvb20gKiAxLjEpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogWm9vbSByZWxhdGl2ZSB0byB2aWV3cG9ydFxuICAgKiBAcmV0dXJuIHtTaWRlfVxuICAgKi9cbiAgem9vbU91dFZQKCl7XG4gICAgbGV0IHpvb20gPSB0aGlzLkZhYnJpY0NhbnZhcy5nZXRab29tKCk7XG4gICAgbGV0IGNlbnRlciA9IG5ldyBmYWJyaWMuUG9pbnQodGhpcy5GYWJyaWNDYW52YXMuZ2V0V2lkdGgoKSAvIDIsIHRoaXMuRmFicmljQ2FudmFzLmdldEhlaWdodCgpIC8gMik7XG4gICAgdGhpcy5GYWJyaWNDYW52YXMuem9vbVRvUG9pbnQoY2VudGVyLCB6b29tIC8gMS4xKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICB0b09iamVjdCgpe1xuXG4gICAgbGV0IF9mb3JtYXR0ZWRTaWRlID0ge1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBpbWFnZVVybDogdGhpcy5pbWFnZVVybCxcbiAgICAgIHNpemU6IHRoaXMuc2l6ZSxcbiAgICAgIGNhbnZhczogdGhpcy5GYWJyaWNDYW52YXMudG9PYmplY3QoWydicnVzaCcsICdlZGl0YWJsZScsICd2ZXJ0aWNhbCddKSxcbiAgICAgIGZvbnRzOiBEcmF3VG9vbC5mb250c1xuICAgIH07XG5cbiAgICBfZm9ybWF0dGVkU2lkZS5jYW52YXMub2JqZWN0cy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgaXRlbS5sZWZ0ID0gaXRlbS5sZWZ0IC0gdGhpcy5jZW50ZXIueDtcbiAgICAgIGl0ZW0udG9wID0gaXRlbS50b3AgLSB0aGlzLmNlbnRlci55O1xuICAgICAgaXRlbS5jbGlwVG8gPSBudWxsO1xuXG4gICAgICBpZihpdGVtLnNlbGVjdGVkKXtcbiAgICAgICAgaXRlbS5zZWxlY3RhYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZih0aGlzLmJhY2tkcm9wKXtcblxuICAgICAgX2Zvcm1hdHRlZFNpZGUuaW1hZ2VVcmwgPSB0aGlzLmltYWdlVXJsXG5cbiAgICB9XG5cbiAgICBpZih0aGlzLkZhYnJpY0JvcmRlcil7XG5cbiAgICAgIF9mb3JtYXR0ZWRTaWRlLmJvcmRlciA9IHRoaXMuZ2V0Qm9yZGVyKCk7XG5cbiAgICAgIF9mb3JtYXR0ZWRTaWRlLmZhY3RvciA9IHtcbiAgICAgICAgeDogdGhpcy5nZXRCb3JkZXIoKS5waXhlbC53aWR0aCAvIHRoaXMuZGVmYXVsdFdvcmtzcGFjZVNpemUud2lkdGgsXG4gICAgICAgIHk6IHRoaXMuZ2V0Qm9yZGVyKCkucGl4ZWwuaGVpZ2h0IC8gdGhpcy5kZWZhdWx0V29ya3NwYWNlU2l6ZS5oZWlnaHQsXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gX2Zvcm1hdHRlZFNpZGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0XG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIHRvSlNPTigpe1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvT2JqZWN0KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBqc29uXG4gICAqL1xuICBmcm9tSlNPTihqc29uKXtcbiAgICBsZXQgZGF0YSA9IEpTT04ucGFyc2UoZXNjYXBlSlNPTihqc29uKSk7XG5cbiAgICB0aGlzLl9yZW1vdmVFdmVudHMoKTtcblxuICAgIHRoaXMuaXRlbXMuX2NvbGxlY3Rpb24gPSBbXTtcblxuICAgIGxldCBjYW52YXNEYXRhID0gSlNPTi5zdHJpbmdpZnkoe29iamVjdHM6IGRhdGEuY2FudmFzLm9iamVjdHN9KTtcblxuICAgIHRoaXMuRmFicmljQ2FudmFzLmxvYWRGcm9tSlNPTihjYW52YXNEYXRhLCAoKSA9PiB7XG4gICAgICBpZih0aGlzLmJhY2tkcm9wKSB7XG4gICAgICAgIHRoaXMuRmFicmljQ2FudmFzLmJhY2tncm91bmRJbWFnZSA9IHRoaXMuYmFja2Ryb3A7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEJvcmRlcih0aGlzLmJvcmRlcik7XG4gICAgICB0aGlzLkZhYnJpY0JvcmRlci5zZW5kVG9CYWNrKCk7XG4gICAgICB0aGlzLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwuYmluZCh0aGlzLkZhYnJpY0NhbnZhcyk7XG4gICAgICB0aGlzLl9pbml0RXZlbnRzKCk7XG4gICAgfSwgKG8sIGl0ZW0pID0+IHtcblxuICAgICAgaXRlbS5zZXQoe1xuICAgICAgICBsZWZ0OiB0aGlzLmNlbnRlci54ICsgKChpdGVtLmxlZnQgLyBkYXRhLmZhY3Rvci54KSAqICgodGhpcy5nZXRCb3JkZXIoKS5waXhlbC5sZWZ0IHx8IDEpIC8gKHRoaXMuZGVmYXVsdFdvcmtzcGFjZVNpemUubGVmdCB8fCAxKSkpLFxuICAgICAgICB0b3A6IHRoaXMuY2VudGVyLnkgKyAoKGl0ZW0udG9wIC8gZGF0YS5mYWN0b3IueSkgKiAoKHRoaXMuZ2V0Qm9yZGVyKCkucGl4ZWwudG9wIHx8IDEpIC8gKHRoaXMuZGVmYXVsdFdvcmtzcGFjZVNpemUudG9wIHx8IDEpKSksXG4gICAgICAgIHNjYWxlWDogKChpdGVtLnNjYWxlWCAvIGRhdGEuZmFjdG9yLngpICogKHRoaXMuZ2V0Qm9yZGVyKCkucGl4ZWwud2lkdGggLyB0aGlzLmRlZmF1bHRXb3Jrc3BhY2VTaXplLndpZHRoKSksXG4gICAgICAgIHNjYWxlWTogKChpdGVtLnNjYWxlWSAvIGRhdGEuZmFjdG9yLnkpICogKHRoaXMuZ2V0Qm9yZGVyKCkucGl4ZWwuaGVpZ2h0IC8gdGhpcy5kZWZhdWx0V29ya3NwYWNlU2l6ZS5oZWlnaHQpKSxcbiAgICAgICAgY2xpcFRvOiBjbGlwKHRoaXMuRmFicmljQm9yZGVyKSxcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLml0ZW1zLl9jb2xsZWN0aW9uLnB1c2goaXRlbSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICovXG4gIHRvU1ZHKGNhbGxiYWNrLCB3aXRob3V0QmcgPSBmYWxzZSl7XG5cbiAgICBpZighdGhpcy5jbVNpemUpe1xuICAgICAgdGhyb3cgKCBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoe2Vycm9yOiBlcnJvcnMuc2lkZU5vU2l6ZX0pKSApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmKCF0aGlzLkZhYnJpY0JvcmRlcil7XG4gICAgICB0aHJvdyAoIG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeSh7ZXJyb3I6IGVycm9ycy5zaWRlTm9Cb3JkZXJ9KSkgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLkZhYnJpY0NhbnZhcy5jbG9uZShjbG9uZSA9PiB7XG5cbiAgICAgIGNsb25lLmZvckVhY2hPYmplY3QoaXRlbSA9PiB7XG4gICAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdpLXRleHQnKSB7XG4gICAgICAgICAgaXRlbS5jbGlwVG8gPSBudWxsO1xuICAgICAgICAgIGxldCBiYXNlNjQgPSBpdGVtLnRvRGF0YVVSTCh7IGVuYWJsZVJldGluYTogdHJ1ZSB9KTtcbiAgICAgICAgICBsZXQgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICBpbWFnZS5zcmMgPSBiYXNlNjQ7XG4gICAgICAgICAgbGV0IGZhYnJpY0ltYWdlID0gbmV3IGZhYnJpYy5JbWFnZShpbWFnZSwge1xuICAgICAgICAgICAgdG9wOiBpdGVtLnRvcCxcbiAgICAgICAgICAgIGxlZnQ6IGl0ZW0ubGVmdCxcbiAgICAgICAgICAgIC8vIHdpZHRoOiBpdGVtLndpZHRoLFxuICAgICAgICAgICAgLy8gaGVpZ2h0OiBpdGVtLmhlaWdodCxcbiAgICAgICAgICAgIHNjYWxlWDogaXRlbS5zY2FsZVgsXG4gICAgICAgICAgICBzY2FsZVk6IGl0ZW0uc2NhbGVZLFxuICAgICAgICAgICAgb3JpZ2luWDogJ2NlbnRlcicsXG4gICAgICAgICAgICBvcmlnaW5ZOiAnY2VudGVyJyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsZXQgaW5kZXggPSBjbG9uZS5nZXRPYmplY3RzKCkuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgICBjbG9uZS5hZGQoZmFicmljSW1hZ2UpO1xuICAgICAgICAgIGZhYnJpY0ltYWdlLm1vdmVUbyhpbmRleCk7XG4gICAgICAgICAgZmFicmljSW1hZ2Uuc2V0Q29vcmRzKCk7XG4gICAgICAgICAgaXRlbS5yZW1vdmUoKTtcbiAgICAgICAgICBjbG9uZS5yZW5kZXJBbGwoKTtcblxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBsZXQgc3ZnID0gY2xvbmUudG9TVkcoe1xuICAgICAgICBzdXBwcmVzc1ByZWFtYmxlOiB0cnVlLFxuICAgICAgICB2aWV3Qm94OiB7XG4gICAgICAgICAgeDogdGhpcy5GYWJyaWNCb3JkZXIubGVmdCxcbiAgICAgICAgICB5OiB0aGlzLkZhYnJpY0JvcmRlci50b3AsXG4gICAgICAgICAgd2lkdGg6IHRoaXMuRmFicmljQm9yZGVyLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogdGhpcy5GYWJyaWNCb3JkZXIuaGVpZ2h0XG4gICAgICAgIH1cbiAgICAgIH0sIGVsID0+IHtcbiAgICAgICAgaWYgKCFlbC5pbmNsdWRlcyh0aGlzLmltYWdlVXJsKSkge1xuICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGxldCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICBsZXQgZG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhzdmcsIFwiaW1hZ2Uvc3ZnK3htbFwiKTtcblxuICAgICAgbGV0IHN2Z09iaiA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3ZnJylbMF07XG5cbiAgICAgIHN2Z09iai5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5GYWJyaWNCb3JkZXIud2lkdGgpO1xuICAgICAgc3ZnT2JqLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5GYWJyaWNCb3JkZXIuaGVpZ2h0KTtcbiAgICAgIHN2Z09iai5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2JhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50Jyk7XG5cbiAgICAgIGlmKHdpdGhvdXRCZyl7XG4gICAgICAgIGxldCByZWN0ID0gc3ZnT2JqLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdyZWN0JylbMF07XG4gICAgICAgIFxuICAgICAgICBpZih0eXBlb2YgcmVjdCAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnbm9uZScpO1xuICAgICAgfVxuXG4gICAgICBsZXQgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChzdmdPYmopO1xuXG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhjb250YWluZXIuaW5uZXJIVE1MKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IEJhc2UgNjQgcmVwcmVzZW50YXRpb24gb2YgY2FudmFzXG4gICAqL1xuICBnZXRQcmV2aWV3KCl7XG5cbiAgICB0aGlzLkZhYnJpY0JvcmRlci5zZXRWaXNpYmxlKGZhbHNlKTtcblxuICAgIGxldCB6b29tID0gdGhpcy5GYWJyaWNDYW52YXMuZ2V0Wm9vbSgpO1xuICAgIGxldCBjZW50ZXIgPSB0aGlzLkZhYnJpY0NhbnZhcy5nZXRWcENlbnRlcigpO1xuXG4gICAgdGhpcy5GYWJyaWNDYW52YXMuc2V0Wm9vbSgxKTtcbiAgICB0aGlzLkZhYnJpY0NhbnZhcy5hYnNvbHV0ZVBhbih7eDogMCwgeTogMH0pO1xuXG4gICAgbGV0IHByZXZpZXcgPSB0aGlzLkZhYnJpY0NhbnZhcy50b0RhdGFVUkwoe1xuICAgICAgbXVsdGlwbGllcjogMC41XG4gICAgfSk7XG4gICAgdGhpcy5GYWJyaWNCb3JkZXIuc2V0VmlzaWJsZSh0cnVlKTtcblxuICAgIHRoaXMuRmFicmljQ2FudmFzLnNldFpvb20oem9vbSk7XG4gICAgdGhpcy5GYWJyaWNDYW52YXMuYWJzb2x1dGVQYW4oe3g6IChjZW50ZXIueCAqIHpvb20gLSB0aGlzLkZhYnJpY0NhbnZhcy5nZXRXaWR0aCgpIC8gMiksIHk6IChjZW50ZXIueSAqIHpvb20gLSB0aGlzLkZhYnJpY0NhbnZhcy5nZXRIZWlnaHQoKSAvIDIpfSk7XG5cbiAgICB0aGlzLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcblxuICAgIHJldHVybiBwcmV2aWV3O1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ30gQmFzZSA2NCByZXByZXNlbnRhdGlvbiBvZiBjYW52YXNcbiAgICovXG4gIGdldEltYWdlUHJldmlldygpe1xuXG4gICAgdGhpcy5GYWJyaWNCb3JkZXIuc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgdGhpcy5iYWNrZHJvcC5zZXRWaXNpYmxlKGZhbHNlKTtcblxuICAgIGxldCB6b29tID0gdGhpcy5GYWJyaWNDYW52YXMuZ2V0Wm9vbSgpO1xuICAgIGxldCBjZW50ZXIgPSB0aGlzLkZhYnJpY0NhbnZhcy5nZXRWcENlbnRlcigpO1xuXG4gICAgdGhpcy5GYWJyaWNDYW52YXMuc2V0Wm9vbSgxKTtcbiAgICB0aGlzLkZhYnJpY0NhbnZhcy5hYnNvbHV0ZVBhbih7eDogMCwgeTogMH0pO1xuXG4gICAgbGV0IHByZXZpZXcgPSB0aGlzLkZhYnJpY0NhbnZhcy50b0RhdGFVUkwoe1xuICAgICAgbXVsdGlwbGllcjogMC41LFxuICAgICAgbGVmdDogdGhpcy5GYWJyaWNCb3JkZXIubGVmdCxcbiAgICAgIHRvcDogdGhpcy5GYWJyaWNCb3JkZXIudG9wLFxuICAgICAgd2lkdGg6IHRoaXMuRmFicmljQm9yZGVyLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLkZhYnJpY0JvcmRlci5oZWlnaHQsXG4gICAgfSk7XG4gICAgdGhpcy5GYWJyaWNCb3JkZXIuc2V0VmlzaWJsZSh0cnVlKTtcbiAgICB0aGlzLmJhY2tkcm9wLnNldFZpc2libGUodHJ1ZSk7XG5cbiAgICB0aGlzLkZhYnJpY0NhbnZhcy5zZXRab29tKHpvb20pO1xuICAgIHRoaXMuRmFicmljQ2FudmFzLmFic29sdXRlUGFuKHt4OiAoY2VudGVyLnggKiB6b29tIC0gdGhpcy5GYWJyaWNDYW52YXMuZ2V0V2lkdGgoKSAvIDIpLCB5OiAoY2VudGVyLnkgKiB6b29tIC0gdGhpcy5GYWJyaWNDYW52YXMuZ2V0SGVpZ2h0KCkgLyAyKX0pO1xuXG4gICAgdGhpcy5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG5cbiAgICByZXR1cm4gcHJldmlldztcbiAgfVxuXG4gIGRyYXdpbmdNb2RlKHZhbCl7XG4gICAgaWYodmFsID09PSB1bmRlZmluZWQpe1xuICAgICAgcmV0dXJuIHRoaXMuRmFicmljQ2FudmFzLmlzRHJhd2luZ01vZGU7XG4gICAgfVxuXG4gICAgaWYodGhpcy5wYW5uaW5nID09PSB0cnVlKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLkZhYnJpY0NhbnZhcy5pc0RyYXdpbmdNb2RlID0gdmFsO1xuICAgIHRoaXMuRmFicmljQ2FudmFzLmZyZWVEcmF3aW5nQnJ1c2ggPSBuZXcgZmFicmljLlBlbmNpbEJydXNoQyh0aGlzLkZhYnJpY0NhbnZhcywge2NvbG9yOiAnIzAwMDAwMCd9KTtcbiAgICB0aGlzLmN1cnJlbnRCcnVzaCA9ICdQZW5jaWxCcnVzaCc7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0RmFicmljKCl7XG5cbiAgICB0aGlzLkZhYnJpY0NhbnZhcyA9IG5ldyBmYWJyaWMuQ2FudmFzKHRoaXMuY2FudmFzLCB7XG4gICAgICBzZWxlY3Rpb246IGZhbHNlLFxuICAgICAgZW5hYmxlUmV0aW5hU2NhbGluZzogdHJ1ZSxcbiAgICAgIHByZXNlcnZlT2JqZWN0U3RhY2tpbmc6IHRydWVcbiAgICB9KTtcblxuICAgIHRoaXMuRmFicmljQ2FudmFzLndyYXBwZXJFbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgdGhpcy5GYWJyaWNDYW52YXMudXBwZXJDYW52YXNFbC5zdHlsZVsnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJ10gPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgdGhpcy5GYWJyaWNDYW52YXMubG93ZXJDYW52YXNFbC5zdHlsZVsnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJ10gPSAncmdiYSgwLDAsMCwwKSc7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRFdmVudHMoKXtcbiAgICB0aGlzLkZhYnJpY0NhbnZhcy5vbih7XG4gICAgICAnb2JqZWN0OmFkZGVkJzogKGUpID0+IHtcbiAgICAgICAgaWYoIWUudGFyZ2V0LmV4Y2x1ZGVGcm9tRXhwb3J0KXtcbiAgICAgICAgICBEcmF3VG9vbC50cmlnZ2VyKCdvYmplY3Q6YWRkZWQnLCB7c2lkZToge2lkOiB0aGlzLmlkfSwgaXRlbTogZS50YXJnZXQudG9PYmplY3QoWydicnVzaCcsICdlZGl0YWJsZScsICd2ZXJ0aWNhbCcsICd1dWlkJ10pLnV1aWR9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICdzZWxlY3Rpb246Y2xlYXJlZCc6IChlKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLml0ZW1zLnNlbGVjdGVkLml0ZW0pIHtcbiAgICAgICAgICB0aGlzLml0ZW1zLnNlbGVjdGVkLml0ZW0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLml0ZW1zLnNlbGVjdGVkLml0ZW0gPSBudWxsO1xuICAgICAgICBEcmF3VG9vbC50cmlnZ2VyKCdzZWxlY3Rpb246Y2xlYXJlZCcsIGUpO1xuICAgICAgfSxcbiAgICAgICdzZWxlY3Rpb246Y3JlYXRlZCc6IChlKSA9PiB7XG4gICAgICAgIERyYXdUb29sLnRyaWdnZXIoJ3NlbGVjdGlvbjpjcmVhdGVkJywgZSk7XG4gICAgICB9LFxuICAgICAgJ29iamVjdDpzZWxlY3RlZCc6IChlKSA9PiB7XG4gICAgICAgIGlmIChlLnRhcmdldC5pZCA9PT0gJ0ZhYnJpY0JvcmRlcicpIHtcbiAgICAgICAgICBlLnRhcmdldC5zZXRDb29yZHMoKTtcbiAgICAgICAgICB0aGlzLmNlbnRlciA9IHRoaXMuRmFicmljQm9yZGVyLmdldENlbnRlclBvaW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pdGVtcy5zZWxlY3RlZC5pdGVtID0gZS50YXJnZXQ7XG4gICAgICAgIHRoaXMuaXRlbXMuc2VsZWN0ZWQuaXRlbS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIERyYXdUb29sLnRyaWdnZXIoJ29iamVjdDpzZWxlY3RlZCcsIHtzaWRlOiB7aWQ6IHRoaXMuaWR9LCBpc1dvcmtTcGFjZUJvcmRlcjogZS50YXJnZXQuaWQgPT09ICdGYWJyaWNCb3JkZXInfSk7XG4gICAgICB9LFxuICAgICAgJ29iamVjdDptb2RpZmllZCc6IChlKSA9PiB7XG4gICAgICAgIGlmIChlLnRhcmdldC5pZCA9PT0gJ0ZhYnJpY0JvcmRlcicpIHtcbiAgICAgICAgICBlLnRhcmdldC5zZXRDb29yZHMoKTtcbiAgICAgICAgICB0aGlzLmNlbnRlciA9IHRoaXMuRmFicmljQm9yZGVyLmdldENlbnRlclBvaW50KCk7XG4gICAgICAgICAgdGhpcy5pbml0V29ya3NwYWNlR3JpZCgpO1xuICAgICAgICAgIHRoaXMuaW5pdFdvcmtzcGFjZVJ1bGVyKCk7XG5cbiAgICAgICAgfVxuICAgICAgICBEcmF3VG9vbC50cmlnZ2VyKCdvYmplY3Q6bW9kaWZpZWQnLCB7c2lkZToge2lkOiB0aGlzLmlkfSwgaXNXb3JrU3BhY2VCb3JkZXI6IGUudGFyZ2V0LmlkID09PSAnRmFicmljQm9yZGVyJywgaXRlbTogZS50YXJnZXQudG9PYmplY3QoWydicnVzaCcsICdlZGl0YWJsZScsICd2ZXJ0aWNhbCcsICd1dWlkJ10pLnV1aWR9KTtcbiAgICAgICAgaWYoIWUudGFyZ2V0LmV4Y2x1ZGVGcm9tRXhwb3J0KXtcbiAgICAgICAgICBEcmF3VG9vbC50cmlnZ2VyKCdoaXN0b3J5OnVwZGF0ZScsIHtzaWRlOiB7aWQ6IHRoaXMuaWR9LCBpc1dvcmtTcGFjZUJvcmRlcjogZmFsc2V9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICdvYmplY3Q6cmVtb3ZlZCc6IChlKSA9PiB7XG4gICAgICAgIGlmKGUudGFyZ2V0ICYmICFlLnRhcmdldC5leGNsdWRlRnJvbUV4cG9ydCl7XG4gICAgICAgICAgRHJhd1Rvb2wudHJpZ2dlcignb2JqZWN0OnJlbW92ZWQnLCB7c2lkZToge2lkOiB0aGlzLmlkfSwgaXRlbTogZS50YXJnZXQudG9PYmplY3QoWydicnVzaCcsICdlZGl0YWJsZScsICd2ZXJ0aWNhbCcsICd1dWlkJ10pLnV1aWR9KTtcbiAgICAgICAgICBEcmF3VG9vbC50cmlnZ2VyKCdoaXN0b3J5OnVwZGF0ZScsIHtzaWRlOiB7aWQ6IHRoaXMuaWR9fSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnZWRpdGluZzpleGl0ZWQnOiAoKSA9PiB7XG4gICAgICAgIERyYXdUb29sLnRyaWdnZXIoJ2VkaXRpbmc6ZXhpdGVkJywge3NpZGU6IHtpZDogdGhpcy5pZH19KTtcbiAgICAgIH0sXG4gICAgICAnZWRpdGluZzplbnRlcmVkJzogKCkgPT4ge1xuICAgICAgICBEcmF3VG9vbC50cmlnZ2VyKCdlZGl0aW5nOmVudGVyZWQnLCB7c2lkZToge2lkOiB0aGlzLmlkfX0pO1xuICAgICAgfSxcbiAgICAgICdtb3VzZTp1cCc6IChlKSA9PiB7XG4gICAgICAgIHRoaXMuX3Bhbm5pbmdEb3duID0gZmFsc2U7XG4gICAgICB9LFxuICAgICAgJ21vdXNlOmRvd24nOiAoZSkgPT4ge1xuICAgICAgICB0aGlzLl9wYW5uaW5nRG93biA9IHRydWU7XG5cbiAgICAgICAgdmFyIHRvdWNoZXMgPSBlLmUudG91Y2hlcyAmJiBlLmUudG91Y2hlcy5sZW5ndGggPyBlLmUudG91Y2hlcyA6IFtlLmVdO1xuICAgICAgICB2YXIgZXZ0ID0gKGUuZS5jaGFuZ2VkVG91Y2hlcyAmJiBlLmUuY2hhbmdlZFRvdWNoZXNbMF0pIHx8IHRvdWNoZXNbMF07XG5cbiAgICAgICAgdGhpcy5fcGFuX3gwID0gZXZ0LmxheWVyWCB8fCBldnQucGFnZVggfHwgMDtcbiAgICAgICAgdGhpcy5fcGFuX3kwID0gZXZ0LmxheWVyWSB8fCBldnQucGFnZVkgfHwgMDtcblxuICAgICAgICBpZih0aGlzLmNvbG9yUGlja2VyLmFjdGl2ZSl7XG4gICAgICAgICAgdGhpcy5jb2xvclBpY2tlci5tb3ZlKGUpO1xuICAgICAgICAgIERyYXdUb29sLnRyaWdnZXIoJ2NvbG9ycGlja2VyOnVwZGF0ZScsIHRoaXMuY29sb3JQaWNrZXIuY29sb3IpO1xuICAgICAgICB9XG5cbiAgICAgIH0sXG4gICAgICAnbW91c2U6bW92ZSc6IChlKSA9PiB7XG5cbiAgICAgICAgRHJhd1Rvb2wudHJpZ2dlcignbW91c2U6bW92ZScpO1xuXG4gICAgICAgIGlmICghISh0aGlzLl9wYW5uaW5nICYmIHRoaXMuX3Bhbm5pbmdEb3duICYmIGUgJiYgZS5lKSkge1xuXG4gICAgICAgICAgdmFyIHRvdWNoZXMgPSBlLmUudG91Y2hlcyAmJiBlLmUudG91Y2hlcy5sZW5ndGggPyBlLmUudG91Y2hlcyA6IFtlLmVdO1xuICAgICAgICAgIHZhciBldnQgPSAoZS5lLmNoYW5nZWRUb3VjaGVzICYmIGUuZS5jaGFuZ2VkVG91Y2hlc1swXSkgfHwgdG91Y2hlc1swXTtcblxuICAgICAgICAgIGxldCB4ID0gZXZ0LmxheWVyWCB8fCBldnQucGFnZVggfHwgMDtcbiAgICAgICAgICBsZXQgeSA9IGV2dC5sYXllclkgfHwgZXZ0LnBhZ2VZIHx8IDA7XG5cbiAgICAgICAgICB0aGlzLkZhYnJpY0NhbnZhcy5yZWxhdGl2ZVBhbih7IHg6IHggLSB0aGlzLl9wYW5feDAsIHk6IHkgLSB0aGlzLl9wYW5feTB9KTtcbiAgICAgICAgICB0aGlzLl9wYW5feDAgPSB4O1xuICAgICAgICAgIHRoaXMuX3Bhbl95MCA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5jb2xvclBpY2tlci5hY3RpdmUpe1xuICAgICAgICAgIHRoaXMuY29sb3JQaWNrZXIubW92ZShlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICdvYmplY3Q6c2NhbGluZyc6IChlKSA9PiB7XG4gICAgICAgIGxldCBvYmogPSBlLnRhcmdldDtcblxuICAgICAgICBpZihvYmoudHlwZS5pbmNsdWRlcygncGF0aCcpKXtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZihvYmoudHlwZS5pbmNsdWRlcygnaS10ZXh0Jykpe1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB3ID0gb2JqLndpZHRoICogb2JqLnNjYWxlWDtcbiAgICAgICAgbGV0IGggPSBvYmouaGVpZ2h0ICogb2JqLnNjYWxlWTtcbiAgICAgICAgbGV0IHMgPSBvYmouc3Ryb2tlV2lkdGg7XG5cbiAgICAgICAgb2JqLnNldCh7XG4gICAgICAgICAgJ2hlaWdodCcgICAgIDogaCxcbiAgICAgICAgICAnd2lkdGgnICAgICAgOiB3LFxuICAgICAgICAgICdzY2FsZVgnICAgICA6IDEsXG4gICAgICAgICAgJ3NjYWxlWScgICAgIDogMVxuICAgICAgICB9KTtcblxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX3JlbW92ZUV2ZW50cygpe1xuICAgIHRoaXMuRmFicmljQ2FudmFzLm9mZigpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpbml0R3JpZCgpe1xuXG4gICAgaWYoIXRoaXMuY21TaXplKXtcbiAgICAgIHRocm93ICggbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KHtlcnJvcjogZXJyb3JzLnNpZGVOb1NpemV9KSkgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc3RhdGU7XG5cbiAgICBpZih0aGlzLmdyaWQpe1xuICAgICAgc3RhdGUgPSB0aGlzLmdyaWQudmlzaWJsZTtcbiAgICAgIHRoaXMuZ3JpZC5kZXN0cm95KCk7XG4gICAgICB0aGlzLkZhYnJpY0NhbnZhcy5yZW1vdmUodGhpcy5ncmlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgY20gPSB0aGlzLmNtU2l6ZTtcblxuICAgIGxldCBzdGVwWCA9IGNtLndpZHRoO1xuICAgIGxldCBzdGVwWSA9IGNtLmhlaWdodDtcblxuICAgIHRoaXMuZ3JpZCA9IG5ldyBmYWJyaWMuR3JvdXAobnVsbCwge1xuICAgICAgZXhjbHVkZUZyb21FeHBvcnQ6IHRydWUsXG4gICAgICBoYXNDb250cm9sczogZmFsc2UsXG4gICAgICBob3ZlckN1cnNvcjogJ2RlZmF1bHQnLFxuICAgICAgc2VsZWN0YWJsZTogZmFsc2VcbiAgICB9KTtcblxuICAgIHRoaXMuRmFicmljQ2FudmFzLmFkZCh0aGlzLmdyaWQpO1xuXG4gICAgdGhpcy5ncmlkLnNlbmRUb0JhY2soKTtcblxuICAgIHRoaXMuZ3JpZC5lbmFibGUgPSBmdW5jdGlvbih2YWwgPSB0cnVlKSB7XG4gICAgICB0aGlzLnNldFZpc2libGUodmFsKTtcbiAgICAgIHRoaXMuY2FudmFzLnJlbmRlckFsbCgpO1xuICAgIH07XG5cbiAgICB0aGlzLmdyaWQuc2V0VmlzaWJsZShzdGF0ZSk7XG4gICAgdGhpcy5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaW5pdFJ1bGVyKCl7XG5cbiAgICBpZighdGhpcy5jbVNpemUpe1xuICAgICAgdGhyb3cgKCBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoe2Vycm9yOiBlcnJvcnMuc2lkZU5vU2l6ZX0pKSApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZTtcblxuICAgIGlmKHRoaXMucnVsZXIpe1xuICAgICAgc3RhdGUgPSB0aGlzLnJ1bGVyLnZpc2libGU7XG4gICAgICB0aGlzLnJ1bGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuRmFicmljQ2FudmFzLnJlbW92ZSh0aGlzLnJ1bGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgY20gPSB0aGlzLmNtU2l6ZTtcblxuICAgIGxldCBzdGVwWCA9IGNtLndpZHRoO1xuICAgIGxldCBzdGVwWSA9IGNtLmhlaWdodDtcblxuICAgIHRoaXMucnVsZXIgPSBuZXcgZmFicmljLkdyb3VwKG51bGwsIHtcbiAgICAgIGV4Y2x1ZGVGcm9tRXhwb3J0OiB0cnVlLFxuICAgICAgaGFzQ29udHJvbHM6IGZhbHNlLFxuICAgICAgaG92ZXJDdXJzb3I6ICdkZWZhdWx0JyxcbiAgICAgIHNlbGVjdGFibGU6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciB4ID0gc3RlcFgqMjsgeCA8PSB0aGlzLkZhYnJpY0NhbnZhcy53aWR0aDsgeCArPSBzdGVwWCkge1xuICAgICAgdGhpcy5ydWxlci5hZGQobmV3IGZhYnJpYy5MaW5lKFsgeCwgMCwgeCwgc3RlcFkqMl0sIHsgc3Ryb2tlOiAncmdiYSgwLCAwLCAwLCAwLjIpJywgc2VsZWN0YWJsZTogZmFsc2UsIGhvdmVyQ3Vyc29yOiAnZGVmYXVsdCcgfSkpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHkgPSBzdGVwWSoyOyB5IDw9IHRoaXMuRmFicmljQ2FudmFzLmhlaWdodDsgeSArPSBzdGVwWSkge1xuICAgICAgdGhpcy5ydWxlci5hZGQobmV3IGZhYnJpYy5MaW5lKFsgMCwgeSwgc3RlcFgqMiwgeV0sIHsgc3Ryb2tlOiAncmdiYSgwLCAwLCAwLCAwLjIpJywgc2VsZWN0YWJsZTogZmFsc2UsIGhvdmVyQ3Vyc29yOiAnZGVmYXVsdCcgfSkpO1xuICAgIH1cblxuICAgIHRoaXMuRmFicmljQ2FudmFzLmFkZCh0aGlzLnJ1bGVyKTtcblxuICAgIHRoaXMucnVsZXIuZW5hYmxlID0gZnVuY3Rpb24odmFsID0gdHJ1ZSkge1xuICAgICAgdGhpcy5zZXRWaXNpYmxlKHZhbCk7XG4gICAgICB0aGlzLmNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5ydWxlci5zZXRWaXNpYmxlKHN0YXRlKTtcbiAgICB0aGlzLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaW5pdFdvcmtzcGFjZUdyaWQoKXtcblxuICAgIGlmKCF0aGlzLmNtU2l6ZSl7XG4gICAgICB0aHJvdyAoIG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeSh7ZXJyb3I6IGVycm9ycy5zaWRlTm9TaXplfSkpICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlO1xuXG4gICAgaWYodGhpcy53b3Jrc3BhY2VHcmlkKXtcbiAgICAgIHN0YXRlID0gdGhpcy53b3Jrc3BhY2VHcmlkLnZpc2libGU7XG4gICAgICB0aGlzLndvcmtzcGFjZUdyaWQuZGVzdHJveSgpO1xuICAgICAgdGhpcy5GYWJyaWNDYW52YXMucmVtb3ZlKHRoaXMud29ya3NwYWNlR3JpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IGNtID0gdGhpcy5jbVNpemU7XG5cbiAgICB0aGlzLndvcmtzcGFjZUdyaWQgPSBuZXcgZmFicmljLkdyb3VwKG51bGwsIHtcbiAgICAgIGV4Y2x1ZGVGcm9tRXhwb3J0OiB0cnVlLFxuICAgICAgaGFzQ29udHJvbHM6IGZhbHNlLFxuICAgICAgaG92ZXJDdXJzb3I6ICdkZWZhdWx0JyxcbiAgICAgIHNlbGVjdGFibGU6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciB4ID0gdGhpcy5GYWJyaWNCb3JkZXIubGVmdDsgeCA8PSB0aGlzLkZhYnJpY0JvcmRlci5sZWZ0K3RoaXMuRmFicmljQm9yZGVyLndpZHRoOyB4ICs9IGNtLndpZHRoKSB7XG4gICAgICB0aGlzLndvcmtzcGFjZUdyaWQuYWRkKG5ldyBmYWJyaWMuTGluZShbIHgsIHRoaXMuRmFicmljQm9yZGVyLnRvcCwgeCwgdGhpcy5GYWJyaWNCb3JkZXIudG9wK3RoaXMuRmFicmljQm9yZGVyLmhlaWdodF0sIHsgc3Ryb2tlOiBEcmF3VG9vbC5ncmlkLmNvbG9yLCBzdHJva2VXaWR0aDogRHJhd1Rvb2wuZ3JpZC5zdHJva2VXaWR0aCwgc2VsZWN0YWJsZTogZmFsc2UsIGhvdmVyQ3Vyc29yOiAnZGVmYXVsdCcgfSkpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHkgPSB0aGlzLkZhYnJpY0JvcmRlci50b3A7IHkgPD0gdGhpcy5GYWJyaWNCb3JkZXIudG9wK3RoaXMuRmFicmljQm9yZGVyLmhlaWdodDsgeSArPSBjbS5oZWlnaHQpIHtcbiAgICAgIHRoaXMud29ya3NwYWNlR3JpZC5hZGQobmV3IGZhYnJpYy5MaW5lKFsgdGhpcy5GYWJyaWNCb3JkZXIubGVmdCwgeSwgdGhpcy5GYWJyaWNCb3JkZXIubGVmdCt0aGlzLkZhYnJpY0JvcmRlci53aWR0aCwgeV0sIHsgc3Ryb2tlOiBEcmF3VG9vbC5ncmlkLmNvbG9yLCBzdHJva2VXaWR0aDogRHJhd1Rvb2wuZ3JpZC5zdHJva2VXaWR0aCwgc2VsZWN0YWJsZTogZmFsc2UsIGhvdmVyQ3Vyc29yOiAnZGVmYXVsdCcgfSkpO1xuICAgIH1cblxuICAgIHRoaXMuRmFicmljQ2FudmFzLmFkZCh0aGlzLndvcmtzcGFjZUdyaWQpO1xuXG4gICAgdGhpcy5ncmlkLnNlbmRUb0JhY2soKTtcblxuICAgIHRoaXMud29ya3NwYWNlR3JpZC5lbmFibGUgPSBmdW5jdGlvbih2YWwgPSB0cnVlKSB7XG4gICAgICB0aGlzLnNldFZpc2libGUodmFsKTtcbiAgICAgIHRoaXMuY2FudmFzLnJlbmRlckFsbCgpO1xuICAgIH07XG5cbiAgICB0aGlzLndvcmtzcGFjZUdyaWQuc2V0VmlzaWJsZShzdGF0ZSk7XG4gICAgdGhpcy5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaW5pdFdvcmtzcGFjZVJ1bGVyKCl7XG5cbiAgICBpZighdGhpcy5jbVNpemUpe1xuICAgICAgdGhyb3cgKCBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoe2Vycm9yOiBlcnJvcnMuc2lkZU5vU2l6ZX0pKSApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZTtcblxuICAgIGlmKHRoaXMud29ya3NwYWNlUnVsZXIpe1xuICAgICAgc3RhdGUgPSB0aGlzLndvcmtzcGFjZVJ1bGVyLnZpc2libGU7XG4gICAgICB0aGlzLndvcmtzcGFjZVJ1bGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuRmFicmljQ2FudmFzLnJlbW92ZSh0aGlzLndvcmtzcGFjZVJ1bGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgY20gPSB0aGlzLmNtU2l6ZTtcblxuICAgIHRoaXMud29ya3NwYWNlUnVsZXI9IG5ldyBmYWJyaWMuR3JvdXAobnVsbCwge1xuICAgICAgZXhjbHVkZUZyb21FeHBvcnQ6IHRydWUsXG4gICAgICBoYXNDb250cm9sczogZmFsc2UsXG4gICAgICBob3ZlckN1cnNvcjogJ2RlZmF1bHQnLFxuICAgICAgc2VsZWN0YWJsZTogZmFsc2VcbiAgICB9KTtcblxuICAgIGZvciAodmFyIHggPSB0aGlzLkZhYnJpY0JvcmRlci5sZWZ0OyB4IDw9IHRoaXMuRmFicmljQm9yZGVyLmxlZnQrdGhpcy5GYWJyaWNCb3JkZXIud2lkdGg7IHggKz0gY20ud2lkdGgpIHtcbiAgICAgIHRoaXMud29ya3NwYWNlUnVsZXIuYWRkKG5ldyBmYWJyaWMuTGluZShbIHgsIGNtLmhlaWdodCwgeCwgY20uaGVpZ2h0KjJdLCB7IHN0cm9rZTogJ3JnYmEoMCwgMCwgMCwgMC4yKScsIHNlbGVjdGFibGU6IGZhbHNlLCBob3ZlckN1cnNvcjogJ2RlZmF1bHQnIH0pKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciB5ID0gdGhpcy5GYWJyaWNCb3JkZXIudG9wOyB5IDw9IHRoaXMuRmFicmljQm9yZGVyLnRvcCt0aGlzLkZhYnJpY0JvcmRlci5oZWlnaHQ7IHkgKz0gY20uaGVpZ2h0KSB7XG4gICAgICB0aGlzLndvcmtzcGFjZVJ1bGVyLmFkZChuZXcgZmFicmljLkxpbmUoWyBjbS53aWR0aCwgeSwgY20ud2lkdGgqMiwgeV0sIHsgc3Ryb2tlOiAncmdiYSgwLCAwLCAwLCAwLjIpJywgc2VsZWN0YWJsZTogZmFsc2UsIGhvdmVyQ3Vyc29yOiAnZGVmYXVsdCcgfSkpO1xuICAgIH1cblxuICAgIHRoaXMud29ya3NwYWNlUnVsZXIuYWRkKG5ldyBmYWJyaWMuTGluZShbIHRoaXMuRmFicmljQm9yZGVyLmxlZnQsIGNtLmhlaWdodCoxLjUsIHRoaXMuRmFicmljQm9yZGVyLmxlZnQrdGhpcy5GYWJyaWNCb3JkZXIud2lkdGgsIGNtLmhlaWdodCoxLjVdLCB7IHN0cm9rZTogJ3JnYmEoMCwgMCwgMCwgMC4yKScsIHNlbGVjdGFibGU6IGZhbHNlLCBob3ZlckN1cnNvcjogJ2RlZmF1bHQnIH0pKTtcbiAgICB0aGlzLndvcmtzcGFjZVJ1bGVyLmFkZChuZXcgZmFicmljLkxpbmUoWyBjbS53aWR0aCoxLjUsIHRoaXMuRmFicmljQm9yZGVyLnRvcCwgY20ud2lkdGgqMS41LCB0aGlzLkZhYnJpY0JvcmRlci50b3ArdGhpcy5GYWJyaWNCb3JkZXIuaGVpZ2h0XSwgeyBzdHJva2U6ICdyZ2JhKDAsIDAsIDAsIDAuMiknLCBzZWxlY3RhYmxlOiBmYWxzZSwgaG92ZXJDdXJzb3I6ICdkZWZhdWx0JyB9KSk7XG5cblxuICAgIHRoaXMuRmFicmljQ2FudmFzLmFkZCh0aGlzLndvcmtzcGFjZVJ1bGVyKTtcblxuICAgIHRoaXMud29ya3NwYWNlUnVsZXIuZW5hYmxlID0gZnVuY3Rpb24odmFsID0gdHJ1ZSkge1xuICAgICAgdGhpcy5zZXRWaXNpYmxlKHZhbCk7XG4gICAgICB0aGlzLmNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICB9O1xuXG4gICAgdGhpcy53b3Jrc3BhY2VSdWxlci5zZXRWaXNpYmxlKHN0YXRlKTtcbiAgICB0aGlzLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgcGl4ZWxzIGluIGNlbnRpbWV0ZXJcbiAgICogQHJldHVybiB7T2JqZWN0fSB7d2lkdGg6IE51bWJlciwgaGVpZ2h0OiBOdW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2FsY3VsYXRlU2l6ZSgpe1xuICAgIHRoaXMuY21TaXplID0ge1xuICAgICAgd2lkdGg6ICgodGhpcy5iYWNrZHJvcC53aWR0aCAqIHRoaXMuYmFja2Ryb3Auc2NhbGVYKSAvIHRoaXMuc2l6ZS53aWR0aCksXG4gICAgICBoZWlnaHQ6ICgodGhpcy5iYWNrZHJvcC5oZWlnaHQgKiB0aGlzLmJhY2tkcm9wLnNjYWxlWSkgLyB0aGlzLnNpemUuaGVpZ2h0KVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuY21TaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBvZmZzZXQgZm9yIGJhY2tncm91bmQgaW1hZ2UgYW5kIG1haW4gYm9yZGVyXG4gICAqIEBwYXJhbSBwcm9wb3J0aW9ucyB7TnVtYmVyfVxuICAgKiBAcGFyYW0gYm9yZGVyU2l6ZSB7T2JqZWN0fSBzaXplXG4gICAqIEBwYXJhbSBib3JkZXJTaXplLndpZHRoIHtOdW1iZXJ9IFdpZHRoIG9mIGJvcmRlclxuICAgKiBAcGFyYW0gYm9yZGVyU2l6ZS5oZWlnaHQge051bWJlcn0gSGVpZ2h0IG9mIGJvcmRlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldE9mZnNldChib3JkZXJTaXplKXtcbiAgICB0aGlzLmJnT2Zmc2V0ID0ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMFxuICAgIH07XG5cbiAgICB0aGlzLmJnT2Zmc2V0LmxlZnQgPSAoYm9yZGVyU2l6ZS5sZWZ0IC0gKCh0aGlzLnNpemUud2lkdGggLSBib3JkZXJTaXplLndpZHRoKSAvIDIpKSAqIHRoaXMuYmFja2Ryb3Auc2NhbGVYO1xuICAgIHRoaXMuYmdPZmZzZXQudG9wID0gKGJvcmRlclNpemUudG9wIC0gKCh0aGlzLnNpemUuaGVpZ2h0IC0gYm9yZGVyU2l6ZS5oZWlnaHQpIC8gMikpICogdGhpcy5iYWNrZHJvcC5zY2FsZVk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHNldFBhZGRpbmcobnVtYmVyKXtcbiAgICBpZih0eXBlb2YgbnVtYmVyICE9PSAnbnVtYmVyJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgdGhpcy5wYWRkaW5nID0gbnVtYmVyO1xuXG4gICAgaWYodGhpcy5iYWNrZHJvcCl7XG5cbiAgICAgIGlmICh0aGlzLmJhY2tkcm9wLndpZHRoID49IHRoaXMuYmFja2Ryb3AuaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuYmFja2Ryb3Auc2NhbGVUb1dpZHRoKHRoaXMuRmFicmljQ2FudmFzLndpZHRoIC0gKHRoaXMucGFkZGluZyAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJhY2tkcm9wLnNjYWxlVG9IZWlnaHQodGhpcy5GYWJyaWNDYW52YXMuaGVpZ2h0IC0gKHRoaXMucGFkZGluZyAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NhbGN1bGF0ZVNpemUoKTtcblxuICAgICAgdGhpcy5pbml0R3JpZCgpO1xuICAgICAgdGhpcy5pbml0UnVsZXIoKTtcblxuICAgICAgaWYodGhpcy5GYWJyaWNCb3JkZXIpIHtcbiAgICAgICAgdGhpcy5pbml0V29ya3NwYWNlR3JpZCgpO1xuICAgICAgICB0aGlzLmluaXRXb3Jrc3BhY2VSdWxlcigpO1xuXG4gICAgICAgIHRoaXMuc2V0Qm9yZGVyKHRoaXMuYm9yZGVyKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGxvYWRGcm9tSlNPTihqc29uKXtcblxuICAgIHRoaXMuRmFicmljQ2FudmFzLmxvYWRGcm9tSlNPTihqc29uLCAoKSA9PiB0aGlzLl91cGRhdGUoKSk7XG5cbiAgfVxuXG4gIF91cGRhdGUoKXtcbiAgICBpZih0aGlzLmJhY2tkcm9wKSB7XG4gICAgICB0aGlzLkZhYnJpY0NhbnZhcy5iYWNrZ3JvdW5kSW1hZ2Uuc2NhbGVYID0gdGhpcy5iYWNrZHJvcC5zY2FsZVg7XG4gICAgICB0aGlzLkZhYnJpY0NhbnZhcy5iYWNrZ3JvdW5kSW1hZ2Uuc2NhbGVZID0gdGhpcy5iYWNrZHJvcC5zY2FsZVk7XG4gICAgfVxuICAgIGlmKHRoaXMuRmFicmljQm9yZGVyKSB7XG4gICAgICB0aGlzLkZhYnJpY0NhbnZhcy5hZGQodGhpcy5GYWJyaWNCb3JkZXIpO1xuICAgICAgdGhpcy5GYWJyaWNCb3JkZXIuc2VuZFRvQmFjaygpO1xuICAgIH1cbiAgICBpZih0aGlzLnJ1bGVyKSB7XG4gICAgICB0aGlzLkZhYnJpY0NhbnZhcy5hZGQodGhpcy5ydWxlcik7XG4gICAgICB0aGlzLnJ1bGVyLnNldFZpc2libGUodGhpcy5ydWxlci52aXNpYmxlKTtcbiAgICB9XG4gICAgaWYodGhpcy5ncmlkKSB7XG4gICAgICB0aGlzLkZhYnJpY0NhbnZhcy5hZGQodGhpcy5ncmlkKTtcbiAgICAgIHRoaXMuZ3JpZC5zZXRWaXNpYmxlKHRoaXMuZ3JpZC52aXNpYmxlKTtcbiAgICB9XG5cbiAgICB0aGlzLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFNpZGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZHJhd1Rvb2wvU2lkZS5qcyIsImltcG9ydCB7ZmFicmljfSBmcm9tICdmYWJyaWMnO1xuaW1wb3J0IERyYXdUb29sIGZyb20gJy4vRHJhd1Rvb2wnO1xuaW1wb3J0IEl0ZW0gZnJvbSAnLi9JdGVtJztcbmltcG9ydCBjbGlwIGZyb20gJy4vdXRpbHMvY2xpcCc7XG5cbi8qKlxuICogSXRlbXMgY29sbGVjdGlvblxuICovXG5jbGFzcyBJdGVtc3tcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHNpZGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNpZGUpe1xuICAgIHRoaXMuc2lkZSA9IHNpZGU7XG4gICAgdGhpcy5fY29sbGVjdGlvbiA9IFtdO1xuXG4gICAgdGhpcy5zZWxlY3RlZCA9IG5ldyBJdGVtKHRoaXMuc2lkZSk7XG4gIH1cblxuICBnZXRJdGVtQnlVVUlEKHV1aWQpe1xuICAgIGxldCBfX2l0ZW0gPSB0aGlzLnNpZGUuRmFicmljQ2FudmFzLmdldE9iamVjdHMoKS5maW5kKGl0ZW0gPT4gaXRlbS51dWlkID09PSB1dWlkKTtcblxuICAgIGlmIChfX2l0ZW0pIHtcbiAgICAgIGxldCBpdGVtID0gX19pdGVtLnRvT2JqZWN0KFsnYnJ1c2gnLCAnZWRpdGFibGUnLCAndmVydGljYWwnLCAndXVpZCddKTtcbiAgICAgIGl0ZW0ubGVmdCA9IGl0ZW0ubGVmdCAtIHRoaXMuc2lkZS5jZW50ZXIueDtcbiAgICAgIGl0ZW0udG9wID0gaXRlbS50b3AgLSB0aGlzLnNpZGUuY2VudGVyLnk7XG4gICAgICBpdGVtLmNsaXBUbyA9IG51bGw7XG5cbiAgICAgIGlmKGl0ZW0uc2VsZWN0ZWQpe1xuICAgICAgICBpdGVtLnNlbGVjdGFibGUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgZmFjdG9yOiB7XG4gICAgICAgICAgeDogdGhpcy5zaWRlLmdldEJvcmRlcigpLnBpeGVsLndpZHRoIC8gdGhpcy5zaWRlLmRlZmF1bHRXb3Jrc3BhY2VTaXplLndpZHRoLFxuICAgICAgICAgIHk6IHRoaXMuc2lkZS5nZXRCb3JkZXIoKS5waXhlbC5oZWlnaHQgLyB0aGlzLnNpZGUuZGVmYXVsdFdvcmtzcGFjZVNpemUuaGVpZ2h0LFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlSXRlbSh1dWlkKXtcbiAgICBsZXQgaXRlbSA9IHRoaXMuX2NvbGxlY3Rpb24uZmluZChpdGVtID0+IGl0ZW0udXVpZCA9PT0gdXVpZCk7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHRoaXMuc2lkZS5fcmVtb3ZlRXZlbnRzKCk7XG4gICAgICBpdGVtLnJlbW92ZSgpO1xuICAgICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICAgIHRoaXMuc2lkZS5faW5pdEV2ZW50cygpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUl0ZW0oZGF0YSl7XG4gICAgbGV0IGxvY2FsSXRlbSA9IHRoaXMuX2NvbGxlY3Rpb24uZmluZChpdGVtID0+IGl0ZW0udXVpZCA9PT0gZGF0YS5pdGVtLnV1aWQpO1xuXG4gICAgaWYgKGxvY2FsSXRlbSkge1xuXG4gICAgICB0aGlzLnNpZGUuX3JlbW92ZUV2ZW50cygpO1xuXG4gICAgICBkZWxldGUgZGF0YS5pdGVtLmNsaXBUbztcbiAgICAgIGRlbGV0ZSBkYXRhLml0ZW0ucGF0aHM7XG5cbiAgICAgIGxvY2FsSXRlbS5zZXQoZGF0YS5pdGVtKTtcbiAgICAgIGxvY2FsSXRlbS5zZXQoe1xuICAgICAgICBsZWZ0OiB0aGlzLnNpZGUuY2VudGVyLnggKyAoKGRhdGEuaXRlbS5sZWZ0IC8gZGF0YS5mYWN0b3IueCkgKiAoKHRoaXMuc2lkZS5nZXRCb3JkZXIoKS5waXhlbC5sZWZ0IHx8IDEpIC8gKHRoaXMuc2lkZS5kZWZhdWx0V29ya3NwYWNlU2l6ZS5sZWZ0IHx8IDEpKSksXG4gICAgICAgIHRvcDogdGhpcy5zaWRlLmNlbnRlci55ICsgKChkYXRhLml0ZW0udG9wIC8gZGF0YS5mYWN0b3IueSkgKiAoKHRoaXMuc2lkZS5nZXRCb3JkZXIoKS5waXhlbC50b3AgfHwgMSkgLyAodGhpcy5zaWRlLmRlZmF1bHRXb3Jrc3BhY2VTaXplLnRvcCB8fCAxKSkpLFxuICAgICAgICBzY2FsZVg6ICgoZGF0YS5pdGVtLnNjYWxlWCAvIGRhdGEuZmFjdG9yLngpICogKHRoaXMuc2lkZS5nZXRCb3JkZXIoKS5waXhlbC53aWR0aCAvIHRoaXMuc2lkZS5kZWZhdWx0V29ya3NwYWNlU2l6ZS53aWR0aCkpLFxuICAgICAgICBzY2FsZVk6ICgoZGF0YS5pdGVtLnNjYWxlWSAvIGRhdGEuZmFjdG9yLnkpICogKHRoaXMuc2lkZS5nZXRCb3JkZXIoKS5waXhlbC5oZWlnaHQgLyB0aGlzLnNpZGUuZGVmYXVsdFdvcmtzcGFjZVNpemUuaGVpZ2h0KSksXG4gICAgICAgIGNsaXBUbzogY2xpcCh0aGlzLnNpZGUuRmFicmljQm9yZGVyKSxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICAgIHRoaXMuc2lkZS5faW5pdEV2ZW50cygpO1xuICAgIH1cbiAgfVxuXG4gIGluc2VydFBsYWluSXRlbShkYXRhKXtcbiAgICBpZighZGF0YS5pdGVtLnV1aWQpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZih0aGlzLmdldEl0ZW1CeVVVSUQoZGF0YS5pdGVtLnV1aWQpKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5zaWRlLl9yZW1vdmVFdmVudHMoKTtcbiAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhbZGF0YS5pdGVtXSwgKG9iamVjdHMpID0+IHtcbiAgICAgIHZhciBvcmlnUmVuZGVyT25BZGRSZW1vdmUgPSB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbmRlck9uQWRkUmVtb3ZlO1xuICAgICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZSA9IGZhbHNlO1xuXG4gICAgICBvYmplY3RzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgaXRlbS5zZXQoe1xuICAgICAgICAgIGxlZnQ6IHRoaXMuc2lkZS5jZW50ZXIueCArICgoaXRlbS5sZWZ0IC8gZGF0YS5mYWN0b3IueCkgKiAoKHRoaXMuc2lkZS5nZXRCb3JkZXIoKS5waXhlbC5sZWZ0IHx8IDEpIC8gKHRoaXMuc2lkZS5kZWZhdWx0V29ya3NwYWNlU2l6ZS5sZWZ0IHx8IDEpKSksXG4gICAgICAgICAgdG9wOiB0aGlzLnNpZGUuY2VudGVyLnkgKyAoKGl0ZW0udG9wIC8gZGF0YS5mYWN0b3IueSkgKiAoKHRoaXMuc2lkZS5nZXRCb3JkZXIoKS5waXhlbC50b3AgfHwgMSkgLyAodGhpcy5zaWRlLmRlZmF1bHRXb3Jrc3BhY2VTaXplLnRvcCB8fCAxKSkpLFxuICAgICAgICAgIHNjYWxlWDogKChpdGVtLnNjYWxlWCAvIGRhdGEuZmFjdG9yLngpICogKHRoaXMuc2lkZS5nZXRCb3JkZXIoKS5waXhlbC53aWR0aCAvIHRoaXMuc2lkZS5kZWZhdWx0V29ya3NwYWNlU2l6ZS53aWR0aCkpLFxuICAgICAgICAgIHNjYWxlWTogKChpdGVtLnNjYWxlWSAvIGRhdGEuZmFjdG9yLnkpICogKHRoaXMuc2lkZS5nZXRCb3JkZXIoKS5waXhlbC5oZWlnaHQgLyB0aGlzLnNpZGUuZGVmYXVsdFdvcmtzcGFjZVNpemUuaGVpZ2h0KSksXG4gICAgICAgICAgY2xpcFRvOiBjbGlwKHRoaXMuc2lkZS5GYWJyaWNCb3JkZXIpLFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLmFkZChpdGVtKTtcbiAgICAgICAgdGhpcy5fY29sbGVjdGlvbi5wdXNoKGl0ZW0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyT25BZGRSZW1vdmUgPSBvcmlnUmVuZGVyT25BZGRSZW1vdmU7XG4gICAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbmRlckFsbCgpO1xuICAgICAgdGhpcy5zaWRlLl9pbml0RXZlbnRzKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gaXRlbXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZhY3RvclxuICAgKi9cbiAgaW5zZXJ0UGxhaW5JdGVtcyhpdGVtcywgZmFjdG9yKSB7XG4gICAgdGhpcy5zaWRlLl9yZW1vdmVFdmVudHMoKTtcbiAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhpdGVtcywgKG9iamVjdHMpID0+IHtcbiAgICAgIHZhciBvcmlnUmVuZGVyT25BZGRSZW1vdmUgPSB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbmRlck9uQWRkUmVtb3ZlO1xuICAgICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZSA9IGZhbHNlO1xuXG4gICAgICBvYmplY3RzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgaXRlbS5zZXQoe1xuICAgICAgICAgIGxlZnQ6IHRoaXMuc2lkZS5jZW50ZXIueCArICgoaXRlbS5sZWZ0IC8gZmFjdG9yKSAqICgodGhpcy5zaWRlLmdldEJvcmRlcigpLnBpeGVsLmxlZnQgfHwgMSkgLyAodGhpcy5zaWRlLmRlZmF1bHRXb3Jrc3BhY2VTaXplLmxlZnQgfHwgMSkpKSxcbiAgICAgICAgICB0b3A6IHRoaXMuc2lkZS5jZW50ZXIueSArICgoaXRlbS50b3AgLyBmYWN0b3IpICogKCh0aGlzLnNpZGUuZ2V0Qm9yZGVyKCkucGl4ZWwudG9wIHx8IDEpIC8gKHRoaXMuc2lkZS5kZWZhdWx0V29ya3NwYWNlU2l6ZS50b3AgfHwgMSkpKSxcbiAgICAgICAgICBzY2FsZVg6ICgoaXRlbS5zY2FsZVggLyBmYWN0b3IpICogKHRoaXMuc2lkZS5nZXRCb3JkZXIoKS5waXhlbC53aWR0aCAvIHRoaXMuc2lkZS5kZWZhdWx0V29ya3NwYWNlU2l6ZS53aWR0aCkpLFxuICAgICAgICAgIHNjYWxlWTogKChpdGVtLnNjYWxlWSAvIGZhY3RvcikgKiAodGhpcy5zaWRlLmdldEJvcmRlcigpLnBpeGVsLmhlaWdodCAvIHRoaXMuc2lkZS5kZWZhdWx0V29ya3NwYWNlU2l6ZS5oZWlnaHQpKSxcbiAgICAgICAgICBjbGlwVG86IGNsaXAodGhpcy5zaWRlLkZhYnJpY0JvcmRlciksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuYWRkKGl0ZW0pO1xuICAgICAgICB0aGlzLl9jb2xsZWN0aW9uLnB1c2goaXRlbSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZSA9IG9yaWdSZW5kZXJPbkFkZFJlbW92ZTtcbiAgICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG4gICAgICB0aGlzLnNpZGUuX2luaXRFdmVudHMoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIGEgU1ZHIGltYWdlIGFuZCBwYXJzZSBhcyBGYWJyaWNKUyBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICAgKi9cbiAgYWRkU1ZHKHVybCwgZmlsbCl7XG5cbiAgICBmYWJyaWMubG9hZFNWR0Zyb21VUkwodXJsLCAob2JqZWN0cywgb3B0aW9ucykgPT4ge1xuXG4gICAgICBsZXQgbG9hZGVkT2JqZWN0ID0gZmFicmljLnV0aWwuZ3JvdXBTVkdFbGVtZW50cyhvYmplY3RzLCBvcHRpb25zKTtcblxuICAgICAgbG9hZGVkT2JqZWN0LnNldCh7XG4gICAgICAgICdsZWZ0JzogdGhpcy5zaWRlLmNlbnRlci54LFxuICAgICAgICAndG9wJzogdGhpcy5zaWRlLmNlbnRlci55LFxuICAgICAgICAnb3JpZ2luWCc6ICdjZW50ZXInLFxuICAgICAgICAnb3JpZ2luWSc6ICdjZW50ZXInLFxuICAgICAgICAnZmlsbCc6IGZpbGwgfHwgJyMwMDAwMDAnLFxuICAgICAgICBjbGlwVG86IGNsaXAoRHJhd1Rvb2wuc2lkZXMuc2VsZWN0ZWQuRmFicmljQm9yZGVyKVxuICAgICAgfSlcblxuICAgICAgaWYgKHRoaXMuc2lkZS5GYWJyaWNCb3JkZXIud2lkdGggPCB0aGlzLnNpZGUuRmFicmljQm9yZGVyLmhlaWdodCkge1xuICAgICAgICBsb2FkZWRPYmplY3Quc2NhbGVUb1dpZHRoKHRoaXMuc2lkZS5GYWJyaWNCb3JkZXIud2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9hZGVkT2JqZWN0LnNjYWxlVG9IZWlnaHQodGhpcy5zaWRlLkZhYnJpY0JvcmRlci5oZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBsb2FkZWRPYmplY3Quc2V0Q29vcmRzKCk7XG5cbiAgICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuYWRkKGxvYWRlZE9iamVjdCk7XG5cbiAgICAgIHRoaXMuX2NvbGxlY3Rpb24ucHVzaChsb2FkZWRPYmplY3QpO1xuXG4gICAgICB0aGlzLnRyaWdnZXJDcmVhdGVkKCk7XG5cbiAgICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG5cbiAgICB9KTtcblxuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgYSBpbWFnZSBhbmQgcGFyc2UgYXMgRmFicmljSlMgb2JqZWN0XG4gICAqIEBwYXJhbSB1cmxcbiAgICovXG4gIGFkZEltYWdlKHVybCwgc3ZnID0gZmFsc2Upe1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmKCFzdmcpe1xuICAgICAgICBmYWJyaWMuSW1hZ2UuZnJvbVVSTCh1cmwsIChvSW1nKSA9PiB7XG4gICAgICAgICAgb0ltZy5zZXQoe1xuICAgICAgICAgICAgJ2xlZnQnOiB0aGlzLnNpZGUuY2VudGVyLngsXG4gICAgICAgICAgICAndG9wJzogdGhpcy5zaWRlLmNlbnRlci55LFxuICAgICAgICAgICAgJ29yaWdpblgnOiAnY2VudGVyJyxcbiAgICAgICAgICAgICdvcmlnaW5ZJzogJ2NlbnRlcicsXG4gICAgICAgICAgICBjcm9zc09yaWdpbjogJ2Fub255bW91cycsXG4gICAgICAgICAgICBjbGlwVG86IGNsaXAoRHJhd1Rvb2wuc2lkZXMuc2VsZWN0ZWQuRmFicmljQm9yZGVyKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHRoaXMuc2lkZS5GYWJyaWNCb3JkZXIud2lkdGggPCB0aGlzLnNpZGUuRmFicmljQm9yZGVyLmhlaWdodCkge1xuICAgICAgICAgICAgb0ltZy5zY2FsZVRvV2lkdGgodGhpcy5zaWRlLkZhYnJpY0JvcmRlci53aWR0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9JbWcuc2NhbGVUb0hlaWdodCh0aGlzLnNpZGUuRmFicmljQm9yZGVyLmhlaWdodCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5hZGQob0ltZyk7XG5cbiAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uLnB1c2gob0ltZyk7XG5cbiAgICAgICAgICB0aGlzLnRyaWdnZXJDcmVhdGVkKCk7XG5cbiAgICAgICAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbmRlckFsbCgpO1xuXG4gICAgICAgICAgcmVzb2x2ZSgpO1xuXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjcm9zc09yaWdpbjogJ2Fub255bW91cydcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYWJyaWMubG9hZFNWR0Zyb21VUkwodXJsLCAob2JqZWN0cywgb3B0aW9ucykgPT4ge1xuICAgICAgICAgIGxldCBvSW1nID0gZmFicmljLnV0aWwuZ3JvdXBTVkdFbGVtZW50cyhvYmplY3RzLCBvcHRpb25zKTtcbiAgICAgICAgICBcbiAgICAgICAgICBvSW1nLnNldCh7XG4gICAgICAgICAgICAnbGVmdCc6IHRoaXMuc2lkZS5jZW50ZXIueCxcbiAgICAgICAgICAgICd0b3AnOiB0aGlzLnNpZGUuY2VudGVyLnksXG4gICAgICAgICAgICAnb3JpZ2luWCc6ICdjZW50ZXInLFxuICAgICAgICAgICAgJ29yaWdpblknOiAnY2VudGVyJyxcbiAgICAgICAgICAgIGNyb3NzT3JpZ2luOiAnYW5vbnltb3VzJyxcbiAgICAgICAgICAgIGNsaXBUbzogY2xpcChEcmF3VG9vbC5zaWRlcy5zZWxlY3RlZC5GYWJyaWNCb3JkZXIpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5zaWRlLkZhYnJpY0JvcmRlci53aWR0aCA8IHRoaXMuc2lkZS5GYWJyaWNCb3JkZXIuaGVpZ2h0KSB7XG4gICAgICAgICAgICBvSW1nLnNjYWxlVG9XaWR0aCh0aGlzLnNpZGUuRmFicmljQm9yZGVyLndpZHRoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb0ltZy5zY2FsZVRvSGVpZ2h0KHRoaXMuc2lkZS5GYWJyaWNCb3JkZXIuaGVpZ2h0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLmFkZChvSW1nKTtcblxuICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb24ucHVzaChvSW1nKTtcblxuICAgICAgICAgIHRoaXMudHJpZ2dlckNyZWF0ZWQoKTtcblxuICAgICAgICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG5cbiAgICAgICAgICByZXNvbHZlKCk7XG5cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMuZm9udFNpemUge051bWJlcn0gRm9udCBzaXplIHB4XG4gICAqIEBwYXJhbSBvcHRpb25zLmZpbGwge1N0cmluZ30gRm9udCBjb2xvcjogUmdiLCBoZXhcbiAgICogQHBhcmFtIG9wdGlvbnMuZm9udEZhbWlseSB7U3RyaW5nfSBGb250IGZhbWlseVxuICAgKiBAcGFyYW0gb3B0aW9ucy5mb250U3R5bGUge1N0cmluZ30gRm9udCBzdHlsZS4gUG9zc2libGUgdmFsdWVzOiBcIlwiLCBcIm5vcm1hbFwiLCBcIml0YWxpY1wiIG9yIFwib2JsaXF1ZVwiLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5mb250V2VpZ2h0IHtTdHJpbmd9IEZvbnQgd2VpZ2h0IChlLmcuIGJvbGQsIG5vcm1hbCwgNDAwLCA2MDAsIDgwMClcbiAgICogQHBhcmFtIG9wdGlvbnMudGV4dEFsaWduIHtTdHJpbmd9IFRleHQgYWxpZ25tZW50LiBQb3NzaWJsZSB2YWx1ZXM6IFwibGVmdFwiLCBcImNlbnRlclwiLCBcInJpZ2h0XCIgb3IgXCJqdXN0aWZ5XCIuXG4gICAqIEBwYXJhbSBvcHRpb25zLmVkaXRhYmxlIHtCb29sZWFufSBUZXh0IGNhbiBiZSBlZGl0ZWQgYnkgZG91YmxlIGNsaWNrLlxuICAgKiBAcGFyYW0gdHh0IHtTdHJpbmd9IFRleHQgY29udGVudFxuICAgKlxuICAgKi9cbiAgYWRkVGV4dChvcHRpb25zLCB0eHQpe1xuXG4gICAgbGV0IF9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBmb250U2l6ZTogMjQsXG4gICAgICBmb250RmFtaWx5OiAnc2VyaWYnLFxuICAgICAgZm9udFN0eWxlOiAnbm9ybWFsJyxcbiAgICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxuICAgICAgZmlsbDogJyMwMDAwMDAnLFxuICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgIHZlcnRpY2FsOiBmYWxzZSxcbiAgICB9LCBvcHRpb25zKVxuXG5cbiAgICBsZXQgdGV4dCA9IG5ldyBmYWJyaWMuSVRleHQodHh0IHx8ICdUZXh0Jywge1xuICAgICAgbGVmdDogdGhpcy5zaWRlLmNlbnRlci54LFxuICAgICAgdG9wOiB0aGlzLnNpZGUuY2VudGVyLnksXG4gICAgICBvcmlnaW5YOiAnY2VudGVyJyxcbiAgICAgIG9yaWdpblk6ICdjZW50ZXInLFxuICAgICAgLy8gd2lkdGg6IHRoaXMuc2lkZS5GYWJyaWNCb3JkZXIud2lkdGgsXG4gICAgICBlZGl0YWJsZTogdHJ1ZSxcbiAgICAgIGNsaXBUbzogY2xpcChEcmF3VG9vbC5zaWRlcy5zZWxlY3RlZC5GYWJyaWNCb3JkZXIpLFxuICAgICAgLi4uX29wdGlvbnNcbiAgICB9KTtcblxuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuYWRkKHRleHQpO1xuXG4gICAgdGV4dC52ZXJ0aWNhbCA9IF9vcHRpb25zLnZlcnRpY2FsO1xuXG4gICAgdGhpcy5fY29sbGVjdGlvbi5wdXNoKHRleHQpO1xuXG4gICAgdGhpcy50cmlnZ2VyQ3JlYXRlZCgpO1xuXG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcblxuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuc2V0QWN0aXZlT2JqZWN0KHRleHQpO1xuXG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cblxuXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBpdGVtc1xuICAgKi9cbiAgZW1wdHkoKXtcbiAgICB0aGlzLl9jb2xsZWN0aW9uLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBpdGVtLnJlbW92ZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy50cmlnZ2VyKCdvYmplY3Q6cmVtb3ZlZCcpO1xuICAgIHRoaXMuX2NvbGxlY3Rpb24gPSBbXTtcblxuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZnJlZURyYXdpbmdCcnVzaC5jbGVhbigpO1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG4gIH1cblxuICBlcmFzZXJFbmFibGUoKXtcbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLmlzRHJhd2luZ01vZGUgPSB0cnVlO1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZnJlZURyYXdpbmdCcnVzaCA9IG5ldyBmYWJyaWMuRXJhc2VyKHRoaXMuc2lkZS5GYWJyaWNDYW52YXMpO1xuICB9XG5cbiAgZXJhc2VyRGlzYWJsZSgpe1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZnJlZURyYXdpbmdCcnVzaCA9IG5ldyBmYWJyaWMuUGVuY2lsQnJ1c2hDKHRoaXMuc2lkZS5GYWJyaWNDYW52YXMpO1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuaXNEcmF3aW5nTW9kZSA9IGZhbHNlO1xuICB9XG5cbiAgcGVuY2lsQnJ1c2gob3B0aW9ucyl7XG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5mcmVlRHJhd2luZ0JydXNoID0gbmV3IGZhYnJpYy5QZW5jaWxCcnVzaEModGhpcy5zaWRlLkZhYnJpY0NhbnZhcywgb3B0aW9ucyk7XG4gICAgdGhpcy5zaWRlLmN1cnJlbnRCcnVzaCA9ICdQZW5jaWxCcnVzaCc7XG5cbiAgfVxuXG4gIGNyYXlvbkJydXNoKG9wdGlvbnMpe1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZnJlZURyYXdpbmdCcnVzaCA9IG5ldyBmYWJyaWMuQ3JheW9uQnJ1c2godGhpcy5zaWRlLkZhYnJpY0NhbnZhcywgb3B0aW9ucyk7XG4gICAgdGhpcy5zaWRlLmN1cnJlbnRCcnVzaCA9ICdDcmF5b25CcnVzaCc7XG5cbiAgfVxuXG4gIGlua0JydXNoKG9wdGlvbnMpe1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZnJlZURyYXdpbmdCcnVzaCA9IG5ldyBmYWJyaWMuSW5rQnJ1c2godGhpcy5zaWRlLkZhYnJpY0NhbnZhcywgb3B0aW9ucyk7XG4gICAgdGhpcy5zaWRlLmN1cnJlbnRCcnVzaCA9ICdJbmtCcnVzaCc7XG5cbiAgfVxuXG4gIG1hcmtlckJydXNoKG9wdGlvbnMpe1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZnJlZURyYXdpbmdCcnVzaCA9IG5ldyBmYWJyaWMuTWFya2VyQnJ1c2godGhpcy5zaWRlLkZhYnJpY0NhbnZhcywgb3B0aW9ucyk7XG4gICAgdGhpcy5zaWRlLmN1cnJlbnRCcnVzaCA9ICdNYXJrZXJCcnVzaCc7XG5cbiAgfVxuXG4gIHNwcmF5QnJ1c2gob3B0aW9ucyl7XG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5mcmVlRHJhd2luZ0JydXNoID0gbmV3IGZhYnJpYy5TcHJheUJydXNoKHRoaXMuc2lkZS5GYWJyaWNDYW52YXMsIG9wdGlvbnMpO1xuICAgIHRoaXMuc2lkZS5jdXJyZW50QnJ1c2ggPSAnU3ByYXlCcnVzaCc7XG5cbiAgfVxuXG4gIGN1c3RvbUJydXNoKG9wdGlvbnMpe1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZnJlZURyYXdpbmdCcnVzaCA9IG5ldyBmYWJyaWMuQ3VzdG9tQnJ1c2godGhpcy5zaWRlLkZhYnJpY0NhbnZhcywgb3B0aW9ucyk7XG4gICAgdGhpcy5zaWRlLmN1cnJlbnRCcnVzaCA9ICdDdXN0b21CcnVzaCc7XG4gIH1cblxuICBqYXBhbmVzZUJydXNoKG9wdGlvbnMpe1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZnJlZURyYXdpbmdCcnVzaCA9IG5ldyBmYWJyaWMuSmFwYW5lc2VCcnVzaCh0aGlzLnNpZGUuRmFicmljQ2FudmFzLCBvcHRpb25zKTtcbiAgICB0aGlzLnNpZGUuY3VycmVudEJydXNoID0gJ0phcGFuZXNlQnJ1c2gnO1xuICB9XG5cbiAgZmluYWxpemVCcnVzaCgpe1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZnJlZURyYXdpbmdCcnVzaC5maW5hbGl6ZSgpO1xuICB9XG5cbiAgYnJ1c2hPcHRpb25zKG9wdGlvbnMpe1xuICAgIGxldCBfbyA9IHtcbiAgICAgIGNvbG9yOiB0aGlzLnNpZGUuRmFicmljQ2FudmFzLmZyZWVEcmF3aW5nQnJ1c2guY29sb3IsXG4gICAgICB3aWR0aDogdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5mcmVlRHJhd2luZ0JydXNoLndpZHRoLFxuICAgICAgb3BhY2l0eTogdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5mcmVlRHJhd2luZ0JydXNoLm9wYWNpdHlcbiAgICB9XG5cbiAgICBpZihvcHRpb25zID09PSB1bmRlZmluZWQpe1xuICAgICAgcmV0dXJuIF9vO1xuICAgIH1cblxuICAgIGxldCBvID0gey4uLl9vLCAuLi5vcHRpb25zfTtcblxuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZnJlZURyYXdpbmdCcnVzaC5jaGFuZ2VDb2xvcihvLmNvbG9yKTtcbiAgICAvLyB0aGlzLnNpZGUuRmFicmljQ2FudmFzLmZyZWVEcmF3aW5nQnJ1c2guY2hhbmdlT3BhY2l0eShvLm9wYWNpdHkpO1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZnJlZURyYXdpbmdCcnVzaC53aWR0aCA9IG8ud2lkdGg7XG4gIH1cblxuICB0cmlnZ2VyQ3JlYXRlZCgpe1xuICAgIERyYXdUb29sLnRyaWdnZXIoJ2hpc3Rvcnk6dXBkYXRlJywge3NpZGU6IHtpZDogdGhpcy5zaWRlLmlkfX0pO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgSXRlbXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9kcmF3VG9vbC9JdGVtcy5qcyIsImltcG9ydCB7ZmFicmljfSBmcm9tICdmYWJyaWMnO1xuaW1wb3J0IERyYXdUb29sIGZyb20gJy4vRHJhd1Rvb2wnO1xuXG5jbGFzcyBJdGVtIHtcblxuICBjb25zdHJ1Y3RvcihzaWRlKXtcblxuICAgIHRoaXMuc2lkZSA9IHNpZGU7XG5cbiAgICB0aGlzLml0ZW0gPSBudWxsO1xuXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHJldHVybiB7e3R5cGU6IHN0cmluZywgdG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fVxuICAgKi9cbiAgdG9PYmplY3QoKXtcblxuICAgIGlmKCF0aGlzLml0ZW0pIHJldHVybiBmYWxzZTtcblxuICAgIGxldCBkYXRhID0ge1xuICAgICAgdHlwZTogdGhpcy5pdGVtLnR5cGUsXG4gICAgICB0b3A6ICh0aGlzLml0ZW0udG9wIC0gdGhpcy5zaWRlLkZhYnJpY0JvcmRlci50b3ApIC8gdGhpcy5zaWRlLmNtU2l6ZS5oZWlnaHQsXG4gICAgICBsZWZ0OiAodGhpcy5pdGVtLmxlZnQgLSB0aGlzLnNpZGUuRmFicmljQm9yZGVyLmxlZnQpIC8gdGhpcy5zaWRlLmNtU2l6ZS53aWR0aCxcbiAgICAgIHdpZHRoOiB0aGlzLml0ZW0ud2lkdGggLyB0aGlzLnNpZGUuY21TaXplLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLml0ZW0uaGVpZ2h0IC8gdGhpcy5zaWRlLmNtU2l6ZS5oZWlnaHQsXG4gICAgICBhbmdsZTogdGhpcy5pdGVtLmFuZ2xlLFxuICAgICAgc2NhbGU6IHRoaXMuaXRlbS5zY2FsZVgsXG4gICAgICBvcGFjaXR5OiB0aGlzLml0ZW0ub3BhY2l0eVxuICAgIH1cblxuICAgIGlmKHRoaXMuaXRlbS50eXBlID09PSAncGF0aCcpe1xuICAgICAgZGF0YS5maWxsID0gdGhpcy5pdGVtLmZpbGw7XG4gICAgfVxuXG4gICAgaWYodGhpcy5pdGVtLnR5cGUgPT09ICdpLXRleHQnKXtcbiAgICAgIGRhdGEuZm9udEZhbWlseSA9IHRoaXMuaXRlbS5mb250RmFtaWx5O1xuICAgICAgZGF0YS5mb250U3R5bGUgPSB0aGlzLml0ZW0uZm9udFN0eWxlO1xuICAgICAgZGF0YS5mb250V2VpZ2h0ID0gdGhpcy5pdGVtLmZvbnRXZWlnaHQ7XG4gICAgICBkYXRhLmZvbnRTaXplID0gdGhpcy5pdGVtLmZvbnRTaXplO1xuICAgICAgZGF0YS50ZXh0QWxpZ24gPSB0aGlzLml0ZW0udGV4dEFsaWduO1xuICAgICAgZGF0YS5maWxsID0gdGhpcy5pdGVtLmZpbGw7XG4gICAgfVxuXG4gICAgaWYodGhpcy5pdGVtLmJydXNoKXtcbiAgICAgIGRhdGEudHlwZSA9ICdicnVzaCc7XG4gICAgICBkYXRhLmZpbGwgPSB0aGlzLml0ZW0uY29sb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7U3RyaW5nfSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRvT2JqZWN0KClcbiAgICovXG4gIHRvSlNPTigpe1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvT2JqZWN0KCkpO1xuICB9XG5cbiAgZGVhY3RpdmF0ZSgpe1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZGVhY3RpdmF0ZUFsbCgpO1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG4gICAgdGhpcy5pdGVtID0gbnVsbDtcbiAgICBEcmF3VG9vbC50cmlnZ2VyKCdzZWxlY3Rpb246Y2xlYXJlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBzZWxlY3RlZCBpdGVtXG4gICAqL1xuICByZW1vdmUoKXtcbiAgICBpZighdGhpcy5pdGVtKSByZXR1cm47XG5cbiAgICB0aGlzLml0ZW0ucmVtb3ZlKCk7XG4gICAgdGhpcy5kZWFjdGl2YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0L3NldCByb3RhdGlvbiBhbmdsZSBvZiBzZWxlY3RlZCBlbGVtZW50XG4gICAqIEBwYXJhbSB2YWxcbiAgICogQHJldHVyblxuICAgKi9cbiAgcm90YXRpb24odmFsKXtcbiAgICBpZighdGhpcy5pdGVtKSByZXR1cm47XG5cbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQpe1xuICAgICAgcmV0dXJuIHRoaXMuaXRlbS5hbmdsZTtcbiAgICB9XG5cbiAgICB0aGlzLml0ZW0uc2V0QW5nbGUocGFyc2VJbnQodmFsKSk7XG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcblxuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMudHJpZ2dlcignb2JqZWN0Om1vZGlmaWVkJywge3RhcmdldDogdGhpcy5pdGVtfSk7XG4gICAgcmV0dXJuIHRoaXMuaXRlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQvc2V0IHBvc2l0aW9uIG9mIHNlbGVjdGVkIGVsZW1lbnRcbiAgICogQHBhcmFtIG9ialxuICAgKiBAcmV0dXJuXG4gICAqL1xuICBwb3NpdGlvbihvYmope1xuXG4gICAgaWYoIXRoaXMuaXRlbSkgcmV0dXJuO1xuXG4gICAgbGV0IHBvc2l0aW9uID0ge1xuICAgICAgdG9wOiAodGhpcy5pdGVtLnRvcCAtIHRoaXMuc2lkZS5GYWJyaWNCb3JkZXIudG9wKSAvIHRoaXMuc2lkZS5jbVNpemUuaGVpZ2h0LFxuICAgICAgbGVmdDogKHRoaXMuaXRlbS5sZWZ0IC0gdGhpcy5zaWRlLkZhYnJpY0JvcmRlci5sZWZ0KSAvIHRoaXMuc2lkZS5jbVNpemUud2lkdGgsXG4gICAgfVxuXG4gICAgaWYoIW9iail7XG4gICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfVxuXG4gICAgbGV0IF9wb3NpdGlvbiA9IHsuLi5wb3NpdGlvbiwgLi4ub2JqfTtcblxuICAgIGxldCB0b3AgPSB0aGlzLnNpZGUuRmFicmljQm9yZGVyLnRvcCArIF9wb3NpdGlvbi50b3AgKiB0aGlzLnNpZGUuY21TaXplLmhlaWdodDtcbiAgICBsZXQgbGVmdCA9IHRoaXMuc2lkZS5GYWJyaWNCb3JkZXIubGVmdCArIF9wb3NpdGlvbi5sZWZ0ICogdGhpcy5zaWRlLmNtU2l6ZS53aWR0aDtcblxuICAgIHRoaXMuaXRlbS5hbmltYXRlKCd0b3AnLCB0b3AsIHtcbiAgICAgIG9uQ2hhbmdlOiB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbmRlckFsbC5iaW5kKHRoaXMuc2lkZS5GYWJyaWNDYW52YXMpXG4gICAgfSk7XG4gICAgdGhpcy5pdGVtLmFuaW1hdGUoJ2xlZnQnLCBsZWZ0LCB7XG4gICAgICBvbkNoYW5nZTogdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwuYmluZCh0aGlzLnNpZGUuRmFicmljQ2FudmFzKVxuICAgIH0pO1xuXG4gICAgdGhpcy5pdGVtLnNldENvb3JkcygpO1xuXG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcblxuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMudHJpZ2dlcignb2JqZWN0Om1vZGlmaWVkJywge3RhcmdldDogdGhpcy5pdGVtfSk7XG4gICAgcmV0dXJuIHRoaXMuaXRlbTtcblxuICB9XG5cbiAgc2NhbGUodmFsKXtcblxuICAgIGlmKCF0aGlzLml0ZW0pIHJldHVybiBmYWxzZTtcblxuICAgIGlmKHZhbCA9PT0gdW5kZWZpbmVkKXtcbiAgICAgIHJldHVybiB0aGlzLml0ZW0uc2NhbGVYO1xuICAgIH1cblxuICAgIHRoaXMuaXRlbS5zY2FsZShwYXJzZUludCh2YWwpKTtcblxuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG5cbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnRyaWdnZXIoJ29iamVjdDptb2RpZmllZCcsIHt0YXJnZXQ6IHRoaXMuaXRlbX0pO1xuICAgIHJldHVybiB0aGlzLml0ZW07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHNldCBzaXplIG9mIHNlbGVjdGVkIGVsZW1lbnRcbiAgICogQHBhcmFtIG9ialxuICAgKiBAcmV0dXJuXG4gICAqL1xuICBzaXplKG9iail7XG5cbiAgICBpZighdGhpcy5pdGVtKSByZXR1cm47XG5cbiAgICBsZXQgc2l6ZSA9IHtcbiAgICAgIHdpZHRoOiB0aGlzLml0ZW0ud2lkdGggLyB0aGlzLnNpZGUuY21TaXplLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLml0ZW0uaGVpZ2h0IC8gdGhpcy5zaWRlLmNtU2l6ZS5oZWlnaHRcbiAgICB9XG5cbiAgICBpZighb2JqKXtcbiAgICAgIHJldHVybiBzaXplO1xuICAgIH1cblxuICAgIGxldCBfc2l6ZSA9IHsuLi5zaXplLCAuLi5vYmp9O1xuXG4gICAgdGhpcy5pdGVtLmFuaW1hdGUoJ2hlaWdodCcsIF9zaXplLmhlaWdodCAqIHRoaXMuc2lkZS5jbVNpemUuaGVpZ2h0LCB7XG4gICAgICBvbkNoYW5nZTogdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwuYmluZCh0aGlzLnNpZGUuRmFicmljQ2FudmFzKVxuICAgIH0pO1xuICAgIHRoaXMuaXRlbS5hbmltYXRlKCd3aWR0aCcsIF9zaXplLndpZHRoICogdGhpcy5zaWRlLmNtU2l6ZS53aWR0aCwge1xuICAgICAgb25DaGFuZ2U6IHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsLmJpbmQodGhpcy5zaWRlLkZhYnJpY0NhbnZhcylcbiAgICB9KTtcblxuICAgIHRoaXMuaXRlbS5zZXRDb29yZHMoKTtcbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbmRlckFsbCgpO1xuXG5cbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnRyaWdnZXIoJ29iamVjdDptb2RpZmllZCcsIHt0YXJnZXQ6IHRoaXMuaXRlbX0pO1xuICAgIHJldHVybiB0aGlzLml0ZW07XG5cbiAgfVxuXG4gIGZpbGwoY29sb3Ipe1xuXG4gICAgaWYoIXRoaXMuaXRlbSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYoY29sb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYodGhpcy5pdGVtLmJydXNoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbS5jb2xvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZih0aGlzLml0ZW0uYnJ1c2gpe1xuICAgICAgdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5UaW50KHtcbiAgICAgICAgY29sb3I6IGNvbG9yXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5pdGVtLmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgICAgdGhpcy5pdGVtLmFwcGx5RmlsdGVycyh0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbmRlckFsbC5iaW5kKHRoaXMuc2lkZS5GYWJyaWNDYW52YXMpKTtcbiAgICAgIHRoaXMuaXRlbS5jb2xvciA9IGNvbG9yO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXRlbS5zZXRDb2xvcihjb2xvcik7XG4gICAgfVxuXG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcblxuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMudHJpZ2dlcignb2JqZWN0Om1vZGlmaWVkJywge3RhcmdldDogdGhpcy5pdGVtfSk7XG5cbiAgICByZXR1cm4gdGhpcy5pdGVtO1xuICB9XG5cbiAgb3BhY2l0eSh2YWwpe1xuICAgIGlmKHZhbCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5pdGVtLm9wYWNpdHk7XG4gICAgdGhpcy5pdGVtLnNldE9wYWNpdHkoTnVtYmVyKHZhbCkpO1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG5cbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnRyaWdnZXIoJ29iamVjdDptb2RpZmllZCcsIHt0YXJnZXQ6IHRoaXMuaXRlbX0pO1xuICAgIHJldHVybiB0aGlzLml0ZW07XG4gIH1cblxuICAvLyBURVhUIE9QVElPTlNcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGZvbnRGYW1pbHkge1N0cmluZ31cbiAgICovXG4gIGZvbnRGYW1pbHkoZm9udEZhbWlseSl7XG5cbiAgICBpZighdGhpcy5pdGVtKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZih0aGlzLml0ZW0udHlwZSAhPT0gJ2ktdGV4dCcpIHJldHVybiBmYWxzZTtcbiAgICBpZighZm9udEZhbWlseSl7XG4gICAgICByZXR1cm4gdGhpcy5pdGVtLmdldEZvbnRGYW1pbHkoKTtcbiAgICB9XG4gICAgdGhpcy5pdGVtLnNldEZvbnRGYW1pbHkoZm9udEZhbWlseSk7XG4gICAgdGhpcy5pdGVtLl9pbml0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG5cbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnRyaWdnZXIoJ29iamVjdDptb2RpZmllZCcsIHt0YXJnZXQ6IHRoaXMuaXRlbX0pO1xuICAgIHJldHVybiB0aGlzLml0ZW07XG4gIH1cblxuICBmb250U3R5bGUoZm9udFN0eWxlKXtcblxuICAgIGlmKCF0aGlzLml0ZW0pIHJldHVybiBmYWxzZTtcblxuICAgIGlmKHRoaXMuaXRlbS50eXBlICE9PSAnaS10ZXh0JykgcmV0dXJuIGZhbHNlO1xuICAgIGlmKCFmb250U3R5bGUpe1xuICAgICAgcmV0dXJuIHRoaXMuaXRlbS5nZXRGb250U3R5bGUoKTtcbiAgICB9XG4gICAgdGhpcy5pdGVtLnNldEZvbnRTdHlsZShmb250U3R5bGUpO1xuICAgIHRoaXMuaXRlbS5faW5pdERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbmRlckFsbCgpO1xuXG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy50cmlnZ2VyKCdvYmplY3Q6bW9kaWZpZWQnLCB7dGFyZ2V0OiB0aGlzLml0ZW19KTtcbiAgICByZXR1cm4gdGhpcy5pdGVtO1xuICB9XG5cbiAgZm9udFdlaWdodChmb250V2VpZ2h0KXtcbiAgICBpZighdGhpcy5pdGVtKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZih0aGlzLml0ZW0udHlwZSAhPT0gJ2ktdGV4dCcpIHJldHVybiBmYWxzZTtcbiAgICBpZighZm9udFdlaWdodCl7XG4gICAgICByZXR1cm4gdGhpcy5pdGVtLmdldEZvbnRXZWlnaHQoKTtcbiAgICB9XG4gICAgdGhpcy5pdGVtLnNldEZvbnRXZWlnaHQoZm9udFdlaWdodCk7XG4gICAgdGhpcy5pdGVtLl9pbml0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG5cbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnRyaWdnZXIoJ29iamVjdDptb2RpZmllZCcsIHt0YXJnZXQ6IHRoaXMuaXRlbX0pO1xuICAgIHJldHVybiB0aGlzLml0ZW07XG4gIH1cblxuICBmb250U2l6ZShmb250U2l6ZSl7XG4gICAgaWYoIXRoaXMuaXRlbSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYodGhpcy5pdGVtLnR5cGUgIT09ICdpLXRleHQnKSByZXR1cm4gZmFsc2U7XG4gICAgaWYoZm9udFNpemUgPT09IHVuZGVmaW5lZCl7XG4gICAgICByZXR1cm4gdGhpcy5pdGVtLmdldEZvbnRTaXplKCk7XG4gICAgfVxuICAgIHRoaXMuaXRlbS5zZXRGb250U2l6ZShmb250U2l6ZSk7XG4gICAgdGhpcy5pdGVtLl9pbml0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG5cbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnRyaWdnZXIoJ29iamVjdDptb2RpZmllZCcsIHt0YXJnZXQ6IHRoaXMuaXRlbX0pO1xuICAgIHJldHVybiB0aGlzLml0ZW07XG4gIH1cblxuICB0ZXh0QWxpZ24odGV4dEFsaWduKXtcbiAgICBpZighdGhpcy5pdGVtKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZih0aGlzLml0ZW0udHlwZSAhPT0gJ2ktdGV4dCcpIHJldHVybiBmYWxzZTtcbiAgICBpZighdGV4dEFsaWduKXtcbiAgICAgIHJldHVybiB0aGlzLml0ZW0uZ2V0VGV4dEFsaWduKCk7XG4gICAgfVxuICAgIHRoaXMuaXRlbS5zZXRUZXh0QWxpZ24odGV4dEFsaWduKTtcbiAgICB0aGlzLml0ZW0uX2luaXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcblxuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMudHJpZ2dlcignb2JqZWN0Om1vZGlmaWVkJywge3RhcmdldDogdGhpcy5pdGVtfSk7XG4gICAgcmV0dXJuIHRoaXMuaXRlbTtcbiAgfVxuXG4gIHRleHQodGV4dCl7XG4gICAgaWYoIXRoaXMuaXRlbSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYodGhpcy5pdGVtLnR5cGUgIT09ICdpLXRleHQnKSByZXR1cm4gZmFsc2U7XG4gICAgaWYodGV4dCA9PT0gdW5kZWZpbmVkKXtcbiAgICAgIHJldHVybiB0aGlzLml0ZW0uZ2V0VGV4dCgpO1xuICAgIH1cbiAgICB0aGlzLml0ZW0uc2V0VGV4dCh0ZXh0KTtcbiAgICB0aGlzLml0ZW0uX2luaXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcblxuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMudHJpZ2dlcignb2JqZWN0Om1vZGlmaWVkJywge3RhcmdldDogdGhpcy5pdGVtfSk7XG4gICAgcmV0dXJuIHRoaXMuaXRlbTtcbiAgfVxuXG4gIHJlbW92ZUNvbG9yKGNvbG9yLCBkaXN0YW5jZSl7XG4gICAgaWYoIXRoaXMuaXRlbSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYodGhpcy5pdGVtLnR5cGUgPT09ICdpLXRleHQnKSB7XG4gICAgICBpZihuZXcgZmFicmljLkNvbG9yKHRoaXMuaXRlbS5maWxsKS50b0hleCgpID09PSBuZXcgZmFicmljLkNvbG9yKGNvbG9yKS50b0hleCgpKXtcbiAgICAgICAgdGhpcy5maWxsKCd0cmFuc3BhcmVudCcpXG4gICAgICB9XG4gICAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYodGhpcy5pdGVtLnR5cGUuaW5jbHVkZXMoJ3BhdGgnKSkge1xuICAgICAgdGhpcy5pdGVtLnBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgICAgbGV0IF9maWxsID0gbmV3IGZhYnJpYy5Db2xvcihwYXRoLmZpbGwpLnRvSGV4KCk7XG4gICAgICAgIGxldCBfY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKGNvbG9yKS50b0hleCgpO1xuICAgICAgICBwYXRoLmZpbGwgPSBfZmlsbCA9PT0gX2NvbG9yID8gJ3RyYW5zcGFyZW50JyA6IHBhdGguZmlsbFxuICAgICAgfSk7XG4gICAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgbGV0IGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVDb2xvcih7XG4gICAgICBjb2xvcjogY29sb3IsXG4gICAgICBkaXN0YW5jZTogZGlzdGFuY2VcbiAgICB9KTtcblxuICAgIHRoaXMuaXRlbS5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICB0aGlzLml0ZW0uYXBwbHlGaWx0ZXJzKHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsLmJpbmQodGhpcy5zaWRlLkZhYnJpY0NhbnZhcykpO1xuXG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy50cmlnZ2VyKCdvYmplY3Q6bW9kaWZpZWQnLCB7dGFyZ2V0OiB0aGlzLml0ZW19KTtcbiAgfVxuXG4gIGVudGVyRWRpdGluZygpe1xuICAgIGlmKCF0aGlzLml0ZW0pIHJldHVybiBmYWxzZTtcbiAgICBpZih0aGlzLml0ZW0udHlwZSAhPT0gJ2ktdGV4dCcpIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLml0ZW0uZW50ZXJFZGl0aW5nKCk7XG4gIH1cblxuICBleGl0RWRpdGluZygpe1xuICAgIGlmKCF0aGlzLml0ZW0pIHJldHVybiBmYWxzZTtcbiAgICBpZih0aGlzLml0ZW0udHlwZSAhPT0gJ2ktdGV4dCcpIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLml0ZW0uZXhpdEVkaXRpbmcoKTtcbiAgfVxuXG4gIHRvVkNlbnRlcigpe1xuICAgIGlmKCF0aGlzLml0ZW0pIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLml0ZW0uc2V0KCd0b3AnLCB0aGlzLnNpZGUuRmFicmljQm9yZGVyLnRvcCArIHRoaXMuc2lkZS5GYWJyaWNCb3JkZXIuaGVpZ2h0IC8gMik7XG5cbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnRyaWdnZXIoJ29iamVjdDptb2RpZmllZCcsIHt0YXJnZXQ6IHRoaXMuaXRlbX0pO1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG4gIH1cblxuICB0b0hDZW50ZXIoKXtcbiAgICBpZighdGhpcy5pdGVtKSByZXR1cm4gZmFsc2U7XG4gICAgdGhpcy5pdGVtLnNldCgnbGVmdCcsIHRoaXMuc2lkZS5GYWJyaWNCb3JkZXIubGVmdCArIHRoaXMuc2lkZS5GYWJyaWNCb3JkZXIud2lkdGggLyAyKTtcblxuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMudHJpZ2dlcignb2JqZWN0Om1vZGlmaWVkJywge3RhcmdldDogdGhpcy5pdGVtfSk7XG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW5kZXJBbGwoKTtcbiAgfVxuXG4gIHRvTGVmdCgpe1xuICAgIHRoaXMuaXRlbS5zZXQoJ2xlZnQnLCB0aGlzLnNpZGUuRmFicmljQm9yZGVyLmxlZnQgKyAodGhpcy5pdGVtLndpZHRoKnRoaXMuaXRlbS5zY2FsZVgpIC8gMik7XG5cbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnRyaWdnZXIoJ29iamVjdDptb2RpZmllZCcsIHt0YXJnZXQ6IHRoaXMuaXRlbX0pO1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG4gIH1cblxuICB0b1JpZ2h0KCl7XG4gICAgaWYoIXRoaXMuaXRlbSkgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMuaXRlbS5zZXQoJ2xlZnQnLCB0aGlzLnNpZGUuRmFicmljQm9yZGVyLmxlZnQgKyB0aGlzLnNpZGUuRmFicmljQm9yZGVyLndpZHRoIC0gKHRoaXMuaXRlbS53aWR0aCp0aGlzLml0ZW0uc2NhbGVYKSAvIDIpO1xuXG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy50cmlnZ2VyKCdvYmplY3Q6bW9kaWZpZWQnLCB7dGFyZ2V0OiB0aGlzLml0ZW19KTtcbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbmRlckFsbCgpO1xuICB9XG5cbiAgdG9Ub3AoKXtcbiAgICBpZighdGhpcy5pdGVtKSByZXR1cm4gZmFsc2U7XG4gICAgdGhpcy5pdGVtLnNldCgndG9wJywgdGhpcy5zaWRlLkZhYnJpY0JvcmRlci50b3AgKyAodGhpcy5pdGVtLmhlaWdodCp0aGlzLml0ZW0uc2NhbGVZKSAvIDIpO1xuXG4gICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy50cmlnZ2VyKCdvYmplY3Q6bW9kaWZpZWQnLCB7dGFyZ2V0OiB0aGlzLml0ZW19KTtcbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbmRlckFsbCgpO1xuICB9XG5cbiAgdG9Cb3R0b20oKXtcbiAgICBpZighdGhpcy5pdGVtKSByZXR1cm4gZmFsc2U7XG4gICAgdGhpcy5pdGVtLnNldCgndG9wJywgdGhpcy5zaWRlLkZhYnJpY0JvcmRlci50b3AgKyB0aGlzLnNpZGUuRmFicmljQm9yZGVyLmhlaWdodCAtICh0aGlzLml0ZW0uaGVpZ2h0KnRoaXMuaXRlbS5zY2FsZVkpIC8gMik7XG5cbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnRyaWdnZXIoJ29iamVjdDptb2RpZmllZCcsIHt0YXJnZXQ6IHRoaXMuaXRlbX0pO1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBJdGVtO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZHJhd1Rvb2wvSXRlbS5qcyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGJvcmRlcikge1xuXG4gIGNvbnN0IHJlY3QgPSBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgbGVmdDogYm9yZGVyLmxlZnQsXG4gICAgdG9wOiBib3JkZXIudG9wLFxuICAgIHdpZHRoOiBib3JkZXIud2lkdGgsXG4gICAgaGVpZ2h0OiBib3JkZXIuaGVpZ2h0LFxuICAgIHN0cm9rZVdpZHRoOiBib3JkZXIuc3Ryb2tlV2lkdGgsXG4gIH0pO1xuXG4gIGNvbnN0IGdlbmVyYXRlID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gYHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB2YXIgY2xpcFJlY3QgPSAke0pTT04uc3RyaW5naWZ5KHJlY3QpfTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB2YXIgbSA9IHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgdmFyIGlNID0gZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtKG0pO1xuICAgICAgY3R4LnRyYW5zZm9ybS5hcHBseShjdHgsIGlNKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgY3R4LnJlY3QoXG4gICAgICAgIGNsaXBSZWN0LmxlZnQsXG4gICAgICAgIGNsaXBSZWN0LnRvcCxcbiAgICAgICAgY2xpcFJlY3Qud2lkdGggLSBjbGlwUmVjdC5zdHJva2VXaWR0aCxcbiAgICAgICAgY2xpcFJlY3QuaGVpZ2h0IC0gY2xpcFJlY3Quc3Ryb2tlV2lkdGhcbiAgICAgICk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO2BcbiAgfVxuXG4gIHJldHVybiBuZXcgRnVuY3Rpb24oJ2N0eCcsIGdlbmVyYXRlKCkpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RyYXdUb29sL3V0aWxzL2NsaXAuanMiLCJpbXBvcnQgRHJhd1Rvb2wgZnJvbSAnLi9EcmF3VG9vbCc7XG5cbmNsYXNzIExheWVycyB7XG5cbiAgY29uc3RydWN0b3Ioc2lkZSl7XG4gICAgdGhpcy5zaWRlID0gc2lkZTtcbiAgICB0aGlzLmxpc3QgPSBudWxsO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICB1cGRhdGUoKXtcbiAgICBsZXQgbGF5ZXJzID0gW107XG5cbiAgICBsZXQgb3B0ID0ge1xuICAgICAgcXVhbGl0eTogMC41LFxuICAgICAgZW5hYmxlUmV0aW5hOiBmYWxzZVxuICAgIH1cblxuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZm9yRWFjaE9iamVjdCggKG9iaikgPT4ge1xuICAgICAgaWYoIW9iai5leGNsdWRlRnJvbUV4cG9ydCkge1xuICAgICAgICBsZXQgY2xpcHRvID0gb2JqLmdldENsaXBUbygpO1xuICAgICAgICBvYmouc2V0Q2xpcFRvKG51bGwpO1xuICAgICAgICBsYXllcnMucHVzaCh7aW5kZXg6IG9iai51dWlkLCBwcmV2aWV3OiBvYmoudG9EYXRhVVJMKG9wdCl9KVxuICAgICAgICBvYmouc2V0Q2xpcFRvKGNsaXB0byk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmxpc3QgPSBsYXllcnM7XG5cbiAgICByZXR1cm4gbGF5ZXJzO1xuICB9XG5cbiAgX2dldEl0ZW1zQnlJbmRleChpbmRleGVzKXtcbiAgICBsZXQgb2JqZWN0cyA9IHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZ2V0T2JqZWN0cygpLmZpbHRlcihvYmogPT4gaW5kZXhlcy5pbmNsdWRlcyhvYmoudXVpZCkgKTtcbiAgICByZXR1cm4gb2JqZWN0cztcbiAgfVxuXG4gIGJyaW5nVG9Gcm9udCguLi5pbmRleGVzKXtcbiAgICBsZXQgaXRlbXMgPSB0aGlzLl9nZXRJdGVtc0J5SW5kZXgoaW5kZXhlcyk7XG4gICAgbGV0IG9mZnNldCA9IHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZ2V0T2JqZWN0cygpLmZpbHRlcihvID0+IG8uZXhjbHVkZUZyb21FeHBvcnQpLmxlbmd0aDtcbiAgICBsZXQgbmV3SW5kZXhlcyA9IFtdO1xuXG4gICAgaXRlbXMuZm9yRWFjaCggaXRlbSA9PiB7XG4gICAgICBpdGVtLmJyaW5nVG9Gcm9udCgpO1xuICAgICAgbmV3SW5kZXhlcy5wdXNoKHt1dWlkOiBpdGVtLnV1aWQsIGluZGV4OiB0aGlzLnNpZGUuRmFicmljQ2FudmFzLmdldE9iamVjdHMoKS5maW5kSW5kZXgobyA9PiBvLnV1aWQgPT09IGl0ZW0udXVpZCkgLSBvZmZzZXR9KTtcbiAgICB9ICk7XG4gICAgRHJhd1Rvb2wudHJpZ2dlcignb2JqZWN0OmluZGV4VXBkYXRlJywgSlNPTi5zdHJpbmdpZnkoe3NpZGU6IHtpZDogdGhpcy5zaWRlLmlkfSwgaXRlbXM6IG5ld0luZGV4ZXN9KSk7XG4gICAgRHJhd1Rvb2wudHJpZ2dlcignaGlzdG9yeTp1cGRhdGUnLCB7c2lkZToge2lkOiB0aGlzLnNpZGUuaWR9fSk7XG4gIH1cblxuICBicmluZ0ZvcndhcmQoLi4uaW5kZXhlcyl7XG4gICAgbGV0IGl0ZW1zID0gdGhpcy5fZ2V0SXRlbXNCeUluZGV4KGluZGV4ZXMpO1xuICAgIGxldCBvZmZzZXQgPSB0aGlzLnNpZGUuRmFicmljQ2FudmFzLmdldE9iamVjdHMoKS5maWx0ZXIobyA9PiBvLmV4Y2x1ZGVGcm9tRXhwb3J0KS5sZW5ndGg7XG4gICAgbGV0IG5ld0luZGV4ZXMgPSBbXTtcblxuICAgIGl0ZW1zLmZvckVhY2goIGl0ZW0gPT4ge1xuICAgICAgaXRlbS5icmluZ0ZvcndhcmQoKVxuICAgICAgbmV3SW5kZXhlcy5wdXNoKHt1dWlkOiBpdGVtLnV1aWQsIGluZGV4OiB0aGlzLnNpZGUuRmFicmljQ2FudmFzLmdldE9iamVjdHMoKS5maW5kSW5kZXgobyA9PiBvLnV1aWQgPT09IGl0ZW0udXVpZCkgLSBvZmZzZXR9KTtcbiAgICB9ICk7XG4gICAgRHJhd1Rvb2wudHJpZ2dlcignb2JqZWN0OmluZGV4VXBkYXRlJywgSlNPTi5zdHJpbmdpZnkoe3NpZGU6IHtpZDogdGhpcy5zaWRlLmlkfSwgaXRlbXM6IG5ld0luZGV4ZXN9KSk7XG4gICAgRHJhd1Rvb2wudHJpZ2dlcignaGlzdG9yeTp1cGRhdGUnLCB7c2lkZToge2lkOiB0aGlzLnNpZGUuaWR9fSk7XG4gIH1cblxuICBzZW5kQmFja3dhcmRzKC4uLmluZGV4ZXMpe1xuICAgIGxldCBpdGVtcyA9IHRoaXMuX2dldEl0ZW1zQnlJbmRleChpbmRleGVzKTtcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5nZXRPYmplY3RzKCkuZmlsdGVyKG8gPT4gby5leGNsdWRlRnJvbUV4cG9ydCkubGVuZ3RoO1xuICAgIGxldCBuZXdJbmRleGVzID0gW107XG5cbiAgICBpdGVtcy5mb3JFYWNoKCBpdGVtID0+IHtcbiAgICAgIGl0ZW0uc2VuZEJhY2t3YXJkcygpXG4gICAgICBuZXdJbmRleGVzLnB1c2goe3V1aWQ6IGl0ZW0udXVpZCwgaW5kZXg6IHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZ2V0T2JqZWN0cygpLmZpbmRJbmRleChvID0+IG8udXVpZCA9PT0gaXRlbS51dWlkKSAtIG9mZnNldH0pO1xuICAgIH0pO1xuICAgIERyYXdUb29sLnRyaWdnZXIoJ29iamVjdDppbmRleFVwZGF0ZScsIEpTT04uc3RyaW5naWZ5KHtzaWRlOiB7aWQ6IHRoaXMuc2lkZS5pZH0sIGl0ZW1zOiBuZXdJbmRleGVzfSkpO1xuICAgIERyYXdUb29sLnRyaWdnZXIoJ2hpc3Rvcnk6dXBkYXRlJywge3NpZGU6IHtpZDogdGhpcy5zaWRlLmlkfX0pO1xuICB9XG5cbiAgc2VuZFRvQmFjayguLi5pbmRleGVzKXtcbiAgICBsZXQgaXRlbXMgPSB0aGlzLl9nZXRJdGVtc0J5SW5kZXgoaW5kZXhlcyk7XG4gICAgbGV0IG9mZnNldCA9IHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZ2V0T2JqZWN0cygpLmZpbHRlcihvID0+IG8uZXhjbHVkZUZyb21FeHBvcnQpLmxlbmd0aDtcbiAgICBsZXQgbmV3SW5kZXhlcyA9IFtdO1xuXG4gICAgaXRlbXMuZm9yRWFjaCggaXRlbSA9PiB7XG4gICAgICBpdGVtLnNlbmRUb0JhY2soKVxuICAgICAgbmV3SW5kZXhlcy5wdXNoKHt1dWlkOiBpdGVtLnV1aWQsIGluZGV4OiB0aGlzLnNpZGUuRmFicmljQ2FudmFzLmdldE9iamVjdHMoKS5maW5kSW5kZXgobyA9PiBvLnV1aWQgPT09IGl0ZW0udXVpZCkgLSBvZmZzZXR9KTtcbiAgICB9ICk7XG4gICAgRHJhd1Rvb2wudHJpZ2dlcignb2JqZWN0OmluZGV4VXBkYXRlJywgSlNPTi5zdHJpbmdpZnkoe3NpZGU6IHtpZDogdGhpcy5zaWRlLmlkfSwgaXRlbXM6IG5ld0luZGV4ZXN9KSk7XG4gICAgRHJhd1Rvb2wudHJpZ2dlcignaGlzdG9yeTp1cGRhdGUnLCB7c2lkZToge2lkOiB0aGlzLnNpZGUuaWR9fSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGRhdGFcbiAgICogQHBhcmFtIGRhdGEuaW5kZXhcbiAgICogQHBhcmFtIGRhdGEudXVpZFxuICAgKi9cbiAgbW92ZVRvSW5kZXgoZGF0YSkge1xuICAgIGxldCBpdGVtID0gdGhpcy5fZ2V0SXRlbXNCeUluZGV4KGRhdGEudXVpZClbMF07XG5cbiAgICBpZighaXRlbSkgcmV0dXJuO1xuXG4gICAgbGV0IG9mZnNldCA9IHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZ2V0T2JqZWN0cygpLmZpbHRlcihvID0+IG8uZXhjbHVkZUZyb21FeHBvcnQpLmxlbmd0aDtcblxuICAgIGxldCBvbGRJbmRleCA9IHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuZ2V0T2JqZWN0cygpLmZpbmRJbmRleChvID0+IG8udXVpZCA9PT0gaXRlbS51dWlkKSAtIG9mZnNldDtcbiAgICBsZXQgZGlmZiA9IGRhdGEuaW5kZXggLSBvbGRJbmRleDtcblxuICAgIGlmKGRpZmYgPiAwKXtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZjsgaSsrKSB7XG4gICAgICAgIGl0ZW0uYnJpbmdGb3J3YXJkKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGRpZmYgPCAwKXtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpID4gZGlmZjsgaS0tKSB7XG4gICAgICAgIGl0ZW0uc2VuZEJhY2t3YXJkcygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIERyYXdUb29sLnRyaWdnZXIoJ2hpc3Rvcnk6dXBkYXRlJywge3NpZGU6IHtpZDogdGhpcy5zaWRlLmlkfX0pO1xuICB9XG5cbiAgdG9WQ2VudGVyKC4uLmluZGV4ZXMpe1xuICAgIGxldCBpdGVtcyA9IHRoaXMuX2dldEl0ZW1zQnlJbmRleChpbmRleGVzKTtcblxuICAgIGl0ZW1zLmZvckVhY2goIGl0ZW0gPT4gaXRlbS5zZXQoJ3RvcCcsIHRoaXMuc2lkZS5GYWJyaWNCb3JkZXIudG9wICsgdGhpcy5zaWRlLkZhYnJpY0JvcmRlci5oZWlnaHQgLyAyKSApO1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG4gIH1cblxuICB0b0hDZW50ZXIoLi4uaW5kZXhlcyl7XG4gICAgbGV0IGl0ZW1zID0gdGhpcy5fZ2V0SXRlbXNCeUluZGV4KGluZGV4ZXMpO1xuXG4gICAgaXRlbXMuZm9yRWFjaCggaXRlbSA9PiB7XG4gICAgICBpdGVtLnNldCgnbGVmdCcsIHRoaXMuc2lkZS5GYWJyaWNCb3JkZXIubGVmdCArIHRoaXMuc2lkZS5GYWJyaWNCb3JkZXIud2lkdGggLyAyKTtcbiAgICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMudHJpZ2dlcignb2JqZWN0Om1vZGlmaWVkJywge3RhcmdldDogaXRlbX0pO1xuICAgIH0gKTtcbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbmRlckFsbCgpO1xuICB9XG5cbiAgdG9MZWZ0KC4uLmluZGV4ZXMpe1xuICAgIGxldCBpdGVtcyA9IHRoaXMuX2dldEl0ZW1zQnlJbmRleChpbmRleGVzKTtcblxuICAgIGl0ZW1zLmZvckVhY2goIGl0ZW0gPT4ge1xuICAgICAgaXRlbS5zZXQoJ2xlZnQnLCB0aGlzLnNpZGUuRmFicmljQm9yZGVyLmxlZnQgKyAoaXRlbS53aWR0aCppdGVtLnNjYWxlWCkgLyAyKTtcbiAgICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMudHJpZ2dlcignb2JqZWN0Om1vZGlmaWVkJywge3RhcmdldDogaXRlbX0pO1xuICAgIH0gKTtcbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbmRlckFsbCgpO1xuICB9XG5cbiAgdG9SaWdodCguLi5pbmRleGVzKXtcbiAgICBsZXQgaXRlbXMgPSB0aGlzLl9nZXRJdGVtc0J5SW5kZXgoaW5kZXhlcyk7XG5cbiAgICBpdGVtcy5mb3JFYWNoKCBpdGVtID0+IHtcbiAgICAgIGl0ZW0uc2V0KCdsZWZ0JywgdGhpcy5zaWRlLkZhYnJpY0JvcmRlci5sZWZ0ICsgdGhpcy5zaWRlLkZhYnJpY0JvcmRlci53aWR0aCAtIChpdGVtLndpZHRoKml0ZW0uc2NhbGVYKSAvIDIpO1xuICAgICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy50cmlnZ2VyKCdvYmplY3Q6bW9kaWZpZWQnLCB7dGFyZ2V0OiBpdGVtfSk7XG4gICAgfSApO1xuICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVuZGVyQWxsKCk7XG4gIH1cblxuICB0b1RvcCguLi5pbmRleGVzKXtcbiAgICBsZXQgaXRlbXMgPSB0aGlzLl9nZXRJdGVtc0J5SW5kZXgoaW5kZXhlcyk7XG5cbiAgICBpdGVtcy5mb3JFYWNoKCBpdGVtID0+IHtcbiAgICAgIGl0ZW0uc2V0KCd0b3AnLCB0aGlzLnNpZGUuRmFicmljQm9yZGVyLnRvcCArIChpdGVtLmhlaWdodCppdGVtLnNjYWxlWSkgLyAyKTtcbiAgICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMudHJpZ2dlcignb2JqZWN0Om1vZGlmaWVkJywge3RhcmdldDogaXRlbX0pO1xuICAgIH0gKTtcbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbmRlckFsbCgpO1xuICB9XG5cbiAgdG9Cb3R0b20oLi4uaW5kZXhlcyl7XG4gICAgbGV0IGl0ZW1zID0gdGhpcy5fZ2V0SXRlbXNCeUluZGV4KGluZGV4ZXMpO1xuXG4gICAgaXRlbXMuZm9yRWFjaCggaXRlbSA9PiB7XG4gICAgICBpdGVtLnNldCgndG9wJywgdGhpcy5zaWRlLkZhYnJpY0JvcmRlci50b3AgKyB0aGlzLnNpZGUuRmFicmljQm9yZGVyLmhlaWdodCAtIChpdGVtLmhlaWdodCppdGVtLnNjYWxlWSkgLyAyKTtcbiAgICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMudHJpZ2dlcignb2JqZWN0Om1vZGlmaWVkJywge3RhcmdldDogaXRlbX0pO1xuICAgIH0gKTtcbiAgICB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbmRlckFsbCgpO1xuICB9XG5cbn1cbmV4cG9ydCBkZWZhdWx0IExheWVycztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RyYXdUb29sL0xheWVycy5qcyIsImltcG9ydCB7ZmFicmljfSBmcm9tICdmYWJyaWMnO1xuXG5jbGFzcyBjb2xvclBpY2tlciB7XG5cbiAgY29uc3RydWN0b3Ioc2lkZSl7XG5cbiAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICB0aGlzLnNpZGUgPSBzaWRlO1xuXG4gICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cbiAgICB0aGlzLl9jb2xvciA9ICcjMDAwMDAwJztcblxuICAgIHRoaXMuY3Vyc29yID0gbmV3IGZhYnJpYy5DaXJjbGUoe1xuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIHJhZGl1czogMjAsXG4gICAgICBzdHJva2VXaWR0aDogMyxcbiAgICAgIHN0cm9rZTogJyNmZmZmZmYnLFxuICAgICAgb3JpZ2luWDogJ2NlbnRlcicsXG4gICAgICBvcmlnaW5ZOiAnY2VudGVyJyxcbiAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgICAgZXhjbHVkZUZyb21FeHBvcnQ6IHRydWUsXG4gICAgICBldmVudGVkOiBmYWxzZSxcbiAgICAgIHNoYWRvdzogbmV3IGZhYnJpYy5TaGFkb3coJzJweCAycHggMTBweCByZ2JhKDAsMCwwLDAuMiknKSxcbiAgICAgIGxvY2tVbmlTY2FsaW5nOiB0cnVlXG4gICAgfSlcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0IGFjdGl2ZSh2YWx1ZSkge1xuICAgIHRoaXMuX2FjdGl2ZSA9IHZhbHVlO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICF2YWx1ZSkge1xuICAgICAgdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5yZW1vdmUodGhpcy5jdXJzb3IpO1xuICAgICAgdGhpcy5zaWRlLml0ZW1zLl9jb2xsZWN0aW9uLmZvckVhY2gob2JqZWN0ID0+IG9iamVjdC5zZWxlY3RhYmxlID0gIXZhbHVlKTtcbiAgICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuaG92ZXJDdXJzb3IgPSAnYWxsLXNjcm9sbCc7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5zaWRlLml0ZW1zLl9jb2xsZWN0aW9uLmZvckVhY2gob2JqZWN0ID0+IG9iamVjdC5zZWxlY3RhYmxlID0gIXZhbHVlKTtcbiAgICAgIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuaG92ZXJDdXJzb3IgPSAndXJsKFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCUUFBQUFVQ0FNQUFBQzZWKzAvQUFBQWJGQk1WRVVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUIwSXYrcUFBQUFKSFJTVGxNQXo3Ym5CTm01NDd5VGpoRCs2OTdIdzdLSmZjdW1vSkoyWENrWUN2REJWRWxFTWlIbVo2RExBQUFBaUVsRVFWUVkwMjNPUnc2RU1CUURVQk1JNlkzZXB0Ly9qcU5JTEVLQ2wwLy9XOFpiOXlqQ3hHZ0w3a2Q4NkROWDl3SklsV0VYb2MxMTRIZGF0eWdibXBxY3Q2V1Mrd2FIZGJ2Y2hqaEUxMTdsRFJPRkpFaVZ5bWtBbUVNYXBTczBkaVlpeFpVQ1Z1QXdxZTYrWXpKK21DWFJINi9DQWVDYjdaVkdBWTNITmZOalErRElzakRLOXorNGtnVTlEdm9rSEFBQUFBQkpSVTVFcmtKZ2dnPT1cIiksIGF1dG8nO1xuICAgICAgLy8gdGhpcy5zaWRlLml0ZW1zLnNlbGVjdGVkLmRlYWN0aXZhdGUoKTtcbiAgICB9XG4gIH1cblxuICBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cblxuICBzZXQgY29sb3IoY29sb3IpIHtcbiAgICBpZiAoY29sb3IgIT09IHVuZGVmaW5lZCAmJiBjb2xvcikge1xuICAgICAgdGhpcy5fY29sb3IgPSBjb2xvcjtcbiAgICAgIHRoaXMuY3Vyc29yLnNldEZpbGwoY29sb3IpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBjb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29sb3I7XG4gIH1cblxuICBtb3ZlKGUpe1xuICAgIC8vIGxldCBwb2ludGVyID0gdGhpcy5zaWRlLkZhYnJpY0NhbnZhcy5nZXRQb2ludGVyKGUuZSk7XG5cbiAgICB0aGlzLmNvbG9yID0gdGhpcy5nZXRDb2xvcihlLmUubGF5ZXJYKndpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLCBlLmUubGF5ZXJZKndpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcblxuICAgIC8vIHRoaXMuc2lkZS5GYWJyaWNDYW52YXMucmVtb3ZlKHRoaXMuY3Vyc29yKTtcbiAgICAvLyB0aGlzLnNpZGUuRmFicmljQ2FudmFzLmFkZCh0aGlzLmN1cnNvcik7XG4gICAgLy8gdGhpcy5jdXJzb3IuYnJpbmdUb0Zyb250KCk7XG4gICAgLy9cbiAgICAvLyBpZihlLmUubGF5ZXJYIDwgNTAgfHwgZS5lLmxheWVyWSA8IDUwKXtcbiAgICAvLyAgIHRoaXMuY3Vyc29yLnRvcCA9IHBvaW50ZXIueSArIDMwO1xuICAgIC8vICAgdGhpcy5jdXJzb3IubGVmdCA9IHBvaW50ZXIueCArIDMwO1xuICAgIC8vIH0gZWxzZSB7XG4gICAgLy8gICB0aGlzLmN1cnNvci50b3AgPSBwb2ludGVyLnkgLSAzMDtcbiAgICAvLyAgIHRoaXMuY3Vyc29yLmxlZnQgPSBwb2ludGVyLnggLSAzMDtcbiAgICAvLyB9XG4gICAgLy9cbiAgICAvLyB0aGlzLnNpZGUuRmFicmljQ2FudmFzLnJlbmRlckFsbCgpXG4gIH1cblxuICBnZXRDb2xvcih4LCB5KXtcblxuICAgIGxldCBweCA9IHRoaXMuc2lkZS5GYWJyaWNDYW52YXMuY29udGV4dENvbnRhaW5lci5nZXRJbWFnZURhdGEoeCwgeSwgMSwgMSkuZGF0YTtcblxuICAgIHJldHVybiAnIycgKyBuZXcgZmFicmljLkNvbG9yKCdyZ2IoJyArIHB4WzBdICsgJywgJyArIHB4WzFdICsgJywgJyArIHB4WzJdICsgJyknKS50b0hleCgpO1xuICB9XG5cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNvbG9yUGlja2VyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZHJhd1Rvb2wvdXRpbHMvY29sb3JQaWNrZXIuanMiLCJpbXBvcnQgRHJhd1Rvb2wgZnJvbSAnLi9EcmF3VG9vbCc7XG5cbmNsYXNzIERyYXdIaXN0b3J5e1xuXG4gIGNvbnN0cnVjdG9yKCl7XG4gICAgdGhpcy5oaXN0b3J5ID0ge307XG4gIH1cblxuICBwdXNoU3RhdGUoaWQpe1xuXG4gICAgaWYodHlwZW9mIHRoaXMuaGlzdG9yeVtpZF0gPT09ICd1bmRlZmluZWQnKXtcbiAgICAgIHRoaXMuaGlzdG9yeVtpZF0gPSB7XG4gICAgICAgIGNvbGxlY3Rpb246IFtdLFxuICAgICAgICBjdXJyZW50SW5kZXg6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgbGV0IHNpZGUgPSBEcmF3VG9vbC5zaWRlcy5nZXRTaWRlKGlkKTtcbiAgICBsZXQgc3RhdGUgPSBKU09OLnN0cmluZ2lmeShzaWRlLkZhYnJpY0NhbnZhcyk7XG5cblxuICAgIHRoaXMuaGlzdG9yeVtpZF0uY29sbGVjdGlvbiA9IHRoaXMuaGlzdG9yeVtpZF0uY29sbGVjdGlvbi5zbGljZSgwLCB0aGlzLmhpc3RvcnlbaWRdLmN1cnJlbnRJbmRleCArIDEpXG4gICAgdGhpcy5oaXN0b3J5W2lkXS5jb2xsZWN0aW9uLnB1c2goc3RhdGUpO1xuICAgIHRoaXMuaGlzdG9yeVtpZF0uY3VycmVudEluZGV4ID0gdGhpcy5oaXN0b3J5W2lkXS5jb2xsZWN0aW9uLmxlbmd0aCAtIDE7XG5cbiAgfVxuXG4gIHVuZG8oaWQpe1xuXG4gICAgbGV0IHNpZGUgPSBEcmF3VG9vbC5zaWRlcy5nZXRTaWRlKGlkKTtcblxuICAgIGlmKCF0aGlzLmhpc3RvcnlbaWRdLmNvbGxlY3Rpb24ubGVuZ3RoKXtcbiAgICAgIHRoaXMuaGlzdG9yeVtpZF0uY3VycmVudEluZGV4ID0gMDtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZih0aGlzLmhpc3RvcnlbaWRdLmN1cnJlbnRJbmRleCA8PSAwKXtcbiAgICAgIHRoaXMuaGlzdG9yeVtpZF0uY3VycmVudEluZGV4ID0gMDtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgc3RhdGUgPSB0aGlzLmhpc3RvcnlbaWRdLmNvbGxlY3Rpb25bdGhpcy5oaXN0b3J5W2lkXS5jdXJyZW50SW5kZXggLSAxXTtcbiAgICB0aGlzLmhpc3RvcnlbaWRdLmN1cnJlbnRJbmRleCAtPSAxO1xuXG4gICAgc2lkZS5sb2FkRnJvbUpTT04oc3RhdGUpO1xuXG4gIH1cblxuICByZWRvKGlkKXtcblxuICAgIGxldCBzaWRlID0gRHJhd1Rvb2wuc2lkZXMuZ2V0U2lkZShpZCk7XG5cbiAgICBpZighdGhpcy5oaXN0b3J5W2lkXS5jb2xsZWN0aW9uLmxlbmd0aCl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYodGhpcy5oaXN0b3J5W2lkXS5jdXJyZW50SW5kZXggPj0gdGhpcy5oaXN0b3J5W2lkXS5jb2xsZWN0aW9uLmxlbmd0aCAtIDEpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBzdGF0ZSA9IHRoaXMuaGlzdG9yeVtpZF0uY29sbGVjdGlvblt0aGlzLmhpc3RvcnlbaWRdLmN1cnJlbnRJbmRleCArIDFdO1xuICAgIHRoaXMuaGlzdG9yeVtpZF0uY3VycmVudEluZGV4ICs9IDE7XG5cbiAgICBzaWRlLmxvYWRGcm9tSlNPTihzdGF0ZSk7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBEcmF3SGlzdG9yeTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RyYXdUb29sL0RyYXdIaXN0b3J5LmpzIiwiaW1wb3J0IHtmYWJyaWN9IGZyb20gJ2ZhYnJpYyc7XG5cbmZhYnJpYy5FcmFzZXIgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuQmFzZUJydXNoLCB7XG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gIH0sXG5cbiAgb25Nb3VzZURvd246IGZ1bmN0aW9uKHBvaW50ZXIpe1xuICAgIHRoaXMucmVtb3ZlKHBvaW50ZXIpO1xuICB9LFxuXG4gIG9uTW91c2VNb3ZlOiBmdW5jdGlvbihwb2ludGVyKXtcbiAgICB0aGlzLnJlbW92ZShwb2ludGVyKTtcbiAgfSxcblxuICBvbk1vdXNlVXA6IGZ1bmN0aW9uKHBvaW50ZXIpe1xuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24ocG9pbnRlcil7XG4gICAgbGV0IHRhcmdldHMgPSB0aGlzLmNhbnZhcy5nZXRPYmplY3RzKCkuZmlsdGVyKG9iaiA9PiB7XG4gICAgICByZXR1cm4gb2JqLmNvbnRhaW5zUG9pbnQocG9pbnRlcikgJiYgIXRoaXMuY2FudmFzLmlzVGFyZ2V0VHJhbnNwYXJlbnQob2JqLCBwb2ludGVyLngsIHBvaW50ZXIueSk7XG4gICAgfSk7XG5cbiAgICB0YXJnZXRzLmZvckVhY2gob2JqID0+IHtcblxuICAgICAgaWYob2JqLmlkICE9PSAnRmFicmljQm9yZGVyJykge1xuICAgICAgICBvYmoucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICB9KTtcbiAgfVxuXG5cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZHJhd1Rvb2wvRXJhc2VyLmpzIiwiaW1wb3J0IHtmYWJyaWN9IGZyb20gJ2ZhYnJpYyc7XG5cbmZhYnJpYy51dGlsLmdldFJhbmRvbSA9IGZ1bmN0aW9uKG1heCwgbWluKXtcbiAgbWluID0gbWluID8gbWluIDogMDtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAoKG1heCA/IG1heCA6IDEpIC0gbWluKSArIG1pbjtcbn07XG5cbmZhYnJpYy51dGlsLmNsYW1wID0gZnVuY3Rpb24gKG4sIG1heCwgbWluKSB7XG4gIGlmICh0eXBlb2YgbWluICE9PSAnbnVtYmVyJykgbWluID0gMDtcbiAgcmV0dXJuIG4gPiBtYXggPyBtYXggOiBuIDwgbWluID8gbWluIDogbjtcbn07XG5cbmZhYnJpYy51dGlsLnRyaW0gPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHZhciBjb3B5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICBwaXhlbHMgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjb250ZXh0LmNhbnZhcy53aWR0aCwgY29udGV4dC5jYW52YXMuaGVpZ2h0KSxcbiAgICBsID0gcGl4ZWxzLmRhdGEubGVuZ3RoLFxuICAgIGksXG4gICAgYm91bmQgPSB7XG4gICAgICB0b3A6IG51bGwsXG4gICAgICBsZWZ0OiBudWxsLFxuICAgICAgcmlnaHQ6IG51bGwsXG4gICAgICBib3R0b206IG51bGxcbiAgICB9LFxuICAgIHgsIHksIGltZztcblxuICBmb3IgKGkgPSAwOyBpIDwgbDsgaSArPSA0KSB7XG4gICAgaWYgKHBpeGVscy5kYXRhW2kgKyAzXSAhPT0gMCkge1xuICAgICAgeCA9IChpIC8gNCkgJSBjb250ZXh0LmNhbnZhcy53aWR0aDtcbiAgICAgIHkgPSB+figoaSAvIDQpIC8gY29udGV4dC5jYW52YXMud2lkdGgpO1xuXG4gICAgICBpZiAoYm91bmQudG9wID09PSBudWxsKSB7XG4gICAgICAgIGJvdW5kLnRvcCA9IHk7XG4gICAgICB9XG5cbiAgICAgIGlmIChib3VuZC5sZWZ0ID09PSBudWxsKSB7XG4gICAgICAgIGJvdW5kLmxlZnQgPSB4O1xuICAgICAgfSBlbHNlIGlmICh4IDwgYm91bmQubGVmdCkge1xuICAgICAgICBib3VuZC5sZWZ0ID0geDtcbiAgICAgIH1cblxuICAgICAgaWYgKGJvdW5kLnJpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgIGJvdW5kLnJpZ2h0ID0geDtcbiAgICAgIH0gZWxzZSBpZiAoYm91bmQucmlnaHQgPCB4KSB7XG4gICAgICAgIGJvdW5kLnJpZ2h0ID0geDtcbiAgICAgIH1cblxuICAgICAgaWYgKGJvdW5kLmJvdHRvbSA9PT0gbnVsbCkge1xuICAgICAgICBib3VuZC5ib3R0b20gPSB5O1xuICAgICAgfSBlbHNlIGlmIChib3VuZC5ib3R0b20gPCB5KSB7XG4gICAgICAgIGJvdW5kLmJvdHRvbSA9IHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHRyaW1IZWlnaHQgPSBib3VuZC5ib3R0b20gLSBib3VuZC50b3A7XG4gIHZhciB0cmltV2lkdGggPSBib3VuZC5yaWdodCAtIGJvdW5kLmxlZnQ7XG4gIGlmKCF0cmltSGVpZ2h0IHx8ICF0cmltV2lkdGgpe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHJpbW1lZCA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKGJvdW5kLmxlZnQsIGJvdW5kLnRvcCwgdHJpbVdpZHRoKzEwLCB0cmltSGVpZ2h0KzEwKTtcblxuICBjb3B5LmNhbnZhcy53aWR0aCA9IHRyaW1XaWR0aDtcbiAgY29weS5jYW52YXMuaGVpZ2h0ID0gdHJpbUhlaWdodDtcbiAgY29weS5wdXRJbWFnZURhdGEodHJpbW1lZCwgMCwgMCk7XG4gIGltZyA9IGNvcHkuY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG5cbiAgcmV0dXJuIHtcbiAgICBpbWc6IGltZyxcbiAgICBsZWZ0OiBib3VuZC5sZWZ0LFxuICAgIHRvcDogYm91bmQudG9wLFxuICAgIHdpZHRoOiB0cmltV2lkdGgsXG4gICAgaGVpZ2h0OiB0cmltSGVpZ2h0XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9kcmF3VG9vbC9icnVzaGVzL3V0aWwvdXRpbC5leHRlbmQuanMiLCJpbXBvcnQge2ZhYnJpY30gZnJvbSAnZmFicmljJztcbmltcG9ydCBjbGlwIGZyb20gJy4uLy4uL3V0aWxzL2NsaXAnO1xuaW1wb3J0IERyYXdUb29sIGZyb20gJy4uLy4uL0RyYXdUb29sJztcblxuZmFicmljLkJhc2VCcnVzaC5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbigpe1xuICBpZighdGhpcy5tb3ZlZCkgcmV0dXJuIGZhbHNlO1xuICB2YXIgb3JpZ2luYWxSZW5kZXJPbkFkZFJlbW92ZSA9IHRoaXMuY2FudmFzLnJlbmRlck9uQWRkUmVtb3ZlO1xuXG4gIHZhciB2dCA9IHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICB2YXIgcmFzdGVyID0gZmFicmljLnV0aWwudHJpbSh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcblxuICBmYWJyaWMuSW1hZ2UuZnJvbVVSTChyYXN0ZXIuaW1nLCAob0ltZykgPT4ge1xuXG4gICAgdGhpcy5jYW52YXMuY2xlYXJDb250ZXh0KHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgIHRoaXMuX3Jlc2V0U2hhZG93KCk7XG5cbiAgICBvSW1nLnNldCh7XG4gICAgICB0b3A6IChyYXN0ZXIudG9wIC8gdnRbMF0pIC0gdnRbNV0gLyB2dFswXSxcbiAgICAgIGxlZnQ6IChyYXN0ZXIubGVmdCAvIHZ0WzBdKSAtIHZ0WzRdIC8gdnRbMF0sXG4gICAgICB3aWR0aDogb0ltZy53aWR0aCAvIHZ0WzBdLFxuICAgICAgaGVpZ2h0OiBvSW1nLmhlaWdodCAvIHZ0WzBdLFxuICAgICAgYnJ1c2g6IHRydWUsXG4gICAgICBjb2xvcjogdGhpcy5jb2xvclxuICAgIH0pXG5cbiAgICBvSW1nLnNldCh7XG4gICAgICBvcmlnaW5YOiAnY2VudGVyJyxcbiAgICAgIG9yaWdpblk6ICdjZW50ZXInLFxuICAgICAgdG9wOiBvSW1nLnRvcCArIG9JbWcuaGVpZ2h0LzIsXG4gICAgICBsZWZ0OiBvSW1nLmxlZnQgKyBvSW1nLndpZHRoLzIsXG4gICAgICBjbGlwVG86IGNsaXAoRHJhd1Rvb2wuc2lkZXMuc2VsZWN0ZWQuRmFicmljQm9yZGVyKVxuICAgIH0pXG5cbiAgICB0aGlzLmNhbnZhcy5hZGQob0ltZyk7XG5cbiAgICBEcmF3VG9vbC5zaWRlcy5zZWxlY3RlZC5pdGVtcy5fY29sbGVjdGlvbi5wdXNoKG9JbWcpO1xuXG4gICAgdGhpcy5jYW52YXMucmVuZGVyQWxsKCk7XG5cbiAgICBEcmF3VG9vbC50cmlnZ2VyKCdoaXN0b3J5OnVwZGF0ZScsIHtzaWRlOiB7aWQ6IERyYXdUb29sLnNpZGVzLnNlbGVjdGVkLmlkfX0pO1xuXG4gICAgdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmUgPSBvcmlnaW5hbFJlbmRlck9uQWRkUmVtb3ZlO1xuXG4gICAgdGhpcy5tb3ZlZCA9IGZhbHNlO1xuXG4gIH0sXG4gIHtcbiAgICBjcm9zc09yaWdpbjogJ0Fub255bW91cydcbiAgfSk7XG59XG5cbmZhYnJpYy5CYXNlQnJ1c2gucHJvdG90eXBlLmNsZWFuID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5jYW52YXMuY2xlYXJDb250ZXh0KHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZHJhd1Rvb2wvYnJ1c2hlcy91dGlsL2Jhc2VCcnVzaC5leHRlbmQuanMiLCJpbXBvcnQge2ZhYnJpY30gZnJvbSAnZmFicmljJztcblxuZmFicmljLlBvaW50LnByb3RvdHlwZS5hbmdsZUJldHdlZW4gPSBmdW5jdGlvbih0aGF0KXtcbiAgcmV0dXJuIE1hdGguYXRhbjIoIHRoaXMueCAtIHRoYXQueCwgdGhpcy55IC0gdGhhdC55KTtcbn07XG5cbmZhYnJpYy5Qb2ludC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24odGhpY2tuZXNzKSB7XG4gIGlmIChudWxsID09PSB0aGlja25lc3MgfHwgdW5kZWZpbmVkID09PSB0aGlja25lc3MpIHtcbiAgICB0aGlja25lc3MgPSAxO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IHRoaXMuZGlzdGFuY2VGcm9tKHsgeDogMCwgeTogMCB9KTtcblxuICBpZiAobGVuZ3RoID4gMCkge1xuICAgIHRoaXMueCA9IHRoaXMueCAvIGxlbmd0aCAqIHRoaWNrbmVzcztcbiAgICB0aGlzLnkgPSB0aGlzLnkgLyBsZW5ndGggKiB0aGlja25lc3M7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZHJhd1Rvb2wvYnJ1c2hlcy91dGlsL3BvaW50LmV4dGVuZC5qcyIsImltcG9ydCB7ZmFicmljfSBmcm9tICdmYWJyaWMnO1xuXG5mYWJyaWMuU3Ryb2tlID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCx7XG4gIGNvbG9yOiBudWxsLFxuICBpbmtBbW91bnQ6IG51bGwsXG4gIGxpbmVXaWR0aDogbnVsbCxcbiAgX3BvaW50OiBudWxsLFxuICBfbGFzdFBvaW50OiBudWxsLFxuICBfY3VycmVudExpbmVXaWR0aDogbnVsbCxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihjdHgsIHBvaW50ZXIsIHJhbmdlLCBjb2xvciwgbGluZVdpZHRoLCBpbmtBbW91bnQpe1xuXG4gICAgdmFyIHJ4ID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tKHJhbmdlKSxcbiAgICAgIGMgPSBmYWJyaWMudXRpbC5nZXRSYW5kb20oTWF0aC5QSSAqIDIpLFxuICAgICAgYzAgPSBmYWJyaWMudXRpbC5nZXRSYW5kb20oTWF0aC5QSSAqIDIpLFxuICAgICAgeDAgPSByeCAqIE1hdGguc2luKGMwKSxcbiAgICAgIHkwID0gcnggLyAyICogTWF0aC5jb3MoYzApLFxuICAgICAgY29zID0gTWF0aC5jb3MoYyksXG4gICAgICBzaW4gPSBNYXRoLnNpbihjKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLl9wb2ludCA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRlci54ICsgeDAgKiBjb3MgLSB5MCAqIHNpbiwgcG9pbnRlci55ICsgeDAgKiBzaW4gKyB5MCAqIGNvcyk7XG4gICAgdGhpcy5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgdGhpcy5pbmtBbW91bnQgPSBpbmtBbW91bnQ7XG4gICAgdGhpcy5fY3VycmVudExpbmVXaWR0aCA9IGxpbmVXaWR0aDtcblxuICAgIGN0eC5saW5lQ2FwID0gXCJyb3VuZFwiO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24ocG9pbnRlciwgc3VidHJhY3RQb2ludCwgZGlzdGFuY2UpIHtcbiAgICB0aGlzLl9sYXN0UG9pbnQgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUodGhpcy5fcG9pbnQpO1xuICAgIHRoaXMuX3BvaW50ID0gdGhpcy5fcG9pbnQuYWRkRXF1YWxzKHsgeDogc3VidHJhY3RQb2ludC54LCB5OiBzdWJ0cmFjdFBvaW50LnkgfSk7XG5cbiAgICB2YXIgbiA9IHRoaXMuaW5rQW1vdW50IC8gKGRpc3RhbmNlICsgMSk7XG4gICAgdmFyIHBlciA9IChuID4gMC4zID8gMC4yIDogbiA8IDAgPyAwIDogbik7XG4gICAgdGhpcy5fY3VycmVudExpbmVXaWR0aCA9IHRoaXMubGluZVdpZHRoICogcGVyO1xuICB9LFxuXG4gIGRyYXc6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xuICAgIGN0eC5zYXZlKCk7XG4gICAgdGhpcy5saW5lKGN0eCwgdGhpcy5fbGFzdFBvaW50LCB0aGlzLl9wb2ludCwgdGhpcy5jb2xvciwgdGhpcy5fY3VycmVudExpbmVXaWR0aCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfSxcblxuICBsaW5lOiBmdW5jdGlvbihjdHgsIHBvaW50MSwgcG9pbnQyLCBjb2xvciwgbGluZVdpZHRoKSB7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyhwb2ludDEueCwgcG9pbnQxLnkpO1xuICAgIGN0eC5saW5lVG8ocG9pbnQyLngsIHBvaW50Mi55KTtcblxuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZHJhd1Rvb2wvYnJ1c2hlcy9icnVzaGVzL3N0cm9rZS5qcyIsImltcG9ydCB7ZmFicmljfSBmcm9tICdmYWJyaWMnO1xuXG5mYWJyaWMuUGVuY2lsQnJ1c2hDID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLkJhc2VCcnVzaCwge1xuXG4gIGNvbG9yOiBcIiMwMDAwMDBcIixcbiAgd2lkdGg6IDEsXG5cbiAgX2Jhc2VXaWR0aDogMSxcbiAgX2xhc3RQb2ludDogbnVsbCxcbiAgX2xpbmVXaWR0aDogMSxcbiAgX3BvaW50OiBudWxsLFxuICBfc2l6ZTogMCxcbiAgbW92ZWQ6IGZhbHNlLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGNhbnZhcywgb3B0ID0ge30pIHtcblxuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMud2lkdGggPSBvcHQud2lkdGggfHwgY2FudmFzLmZyZWVEcmF3aW5nQnJ1c2gud2lkdGg7XG4gICAgdGhpcy5jb2xvciA9IG9wdC5jb2xvciB8fCBjYW52YXMuZnJlZURyYXdpbmdCcnVzaC5jb2xvcjtcbiAgICB0aGlzLl9wb2ludCA9IG5ldyBmYWJyaWMuUG9pbnQoKTtcblxuICAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AubGluZUpvaW4gPSAncm91bmQnO1xuICAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AubGluZUNhcCA9ICdyb3VuZCc7XG5cbiAgfSxcblxuICBjaGFuZ2VDb2xvcjogZnVuY3Rpb24oY29sb3IpIHtcbiAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gIH0sXG5cbiAgX3JlbmRlcjogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHZhciBjdHgsIGxpbmVXaWR0aERpZmYsIGksIGxlbjtcbiAgICB2YXIgdnQgPSB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybTtcblxuICAgIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG5cbiAgICBjdHguc2F2ZSgpO1xuXG4gICAgY3R4LnRyYW5zZm9ybSh2dFswXSwgdnRbMV0sIHZ0WzJdLCB2dFszXSwgdnRbNF0sIHZ0WzVdKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuX3NpemU7XG5cbiAgICBmb3IoaSA9IDAsIGxlbiA9ICh0aGlzLl9zaXplIC8gdGhpcy5fc2l6ZSkgLyAyOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxpbmVXaWR0aERpZmYgPSAodGhpcy5fc2l6ZSAtIDEpICogaTtcbiAgICAgIGN0eC5tb3ZlVG8odGhpcy5fbGFzdFBvaW50LnggKyBsaW5lV2lkdGhEaWZmLCB0aGlzLl9sYXN0UG9pbnQueSArIGxpbmVXaWR0aERpZmYpO1xuICAgICAgY3R4LmxpbmVUbyhwb2ludGVyLnggKyBsaW5lV2lkdGhEaWZmLCBwb2ludGVyLnkgKyBsaW5lV2lkdGhEaWZmKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgdGhpcy5fbGFzdFBvaW50ID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSk7XG4gIH0sXG5cbiAgb25Nb3VzZURvd246IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB0aGlzLl9sYXN0UG9pbnQgPSBwb2ludGVyO1xuICAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3Auc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgIHRoaXMuX3NpemUgPSB0aGlzLndpZHRoO1xuICAgIHRoaXMubW92ZWQgPSBmYWxzZTtcbiAgfSxcblxuICBvbk1vdXNlTW92ZTogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIGlmICh0aGlzLmNhbnZhcy5faXNDdXJyZW50bHlEcmF3aW5nKSB7XG4gICAgICB0aGlzLl9yZW5kZXIocG9pbnRlcik7XG4gICAgfVxuICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICB9LFxuXG4gIG9uTW91c2VVcDogZnVuY3Rpb24oKSB7fVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9kcmF3VG9vbC9icnVzaGVzL2JydXNoZXMvcGVuY2lsQnJ1c2guanMiLCJpbXBvcnQge2ZhYnJpY30gZnJvbSAnZmFicmljJztcblxuZmFicmljLkNyYXlvbkJydXNoID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLkJhc2VCcnVzaCwge1xuXG4gIGNvbG9yOiBcIiMwMDAwMDBcIixcbiAgd2lkdGg6IDMwLFxuXG4gIF9iYXNlV2lkdGg6IDIwLFxuICBfaW5rQW1vdW50OiAxMCxcbiAgX2xhdGVzdFN0cm9rZUxlbmd0aDogMCxcbiAgX3BvaW50OiBudWxsLFxuICBfc2VwOiA1LFxuICBfc2l6ZTogMCxcbiAgbW92ZWQ6IGZhbHNlLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGNhbnZhcywgb3B0ID0ge30pIHtcblxuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMud2lkdGggPSBvcHQud2lkdGggfHwgY2FudmFzLmZyZWVEcmF3aW5nQnJ1c2gud2lkdGg7XG4gICAgdGhpcy5jb2xvciA9IG9wdC5jb2xvciB8fCBjYW52YXMuZnJlZURyYXdpbmdCcnVzaC5jb2xvcjtcbiAgICB0aGlzLl9wb2ludCA9IG5ldyBmYWJyaWMuUG9pbnQoMCwgMCk7XG4gIH0sXG5cbiAgY2hhbmdlQ29sb3I6IGZ1bmN0aW9uKGNvbG9yKXtcbiAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gIH0sXG5cbiAgb25Nb3VzZURvd246IGZ1bmN0aW9uKHBvaW50ZXIpe1xuICAgIHRoaXMuX3NpemUgPSB0aGlzLndpZHRoO1xuICAgIHRoaXMuc2V0KHBvaW50ZXIpO1xuICAgIHRoaXMubW92ZWQgPSBmYWxzZTtcbiAgfSxcblxuICBvbk1vdXNlTW92ZTogZnVuY3Rpb24ocG9pbnRlcil7XG4gICAgdGhpcy51cGRhdGUocG9pbnRlcik7XG4gICAgdGhpcy5yZW5kZXIodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgdGhpcy5tb3ZlZCA9IHRydWU7XG4gIH0sXG5cbiAgb25Nb3VzZVVwOiBmdW5jdGlvbihwb2ludGVyKXt9LFxuXG4gIHNldDogZnVuY3Rpb24ocCkge1xuICAgIGlmICh0aGlzLl9sYXRlc3QpIHtcbiAgICAgIHRoaXMuX2xhdGVzdC5zZXRGcm9tUG9pbnQodGhpcy5fcG9pbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9sYXRlc3QgPSBuZXcgZmFicmljLlBvaW50KHAueCwgcC55KTtcbiAgICB9XG4gICAgZmFicmljLlBvaW50LnByb3RvdHlwZS5zZXRGcm9tUG9pbnQuY2FsbCh0aGlzLl9wb2ludCwgcCk7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbihwKSB7XG4gICAgdGhpcy5zZXQocCk7XG4gICAgdGhpcy5fbGF0ZXN0U3Ryb2tlTGVuZ3RoID0gdGhpcy5fcG9pbnQuc3VidHJhY3QodGhpcy5fbGF0ZXN0KS5kaXN0YW5jZUZyb20oeyB4OiAwLCB5OiAwIH0pO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG4gICAgdmFyIHZ0ID0gdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm07XG4gICAgdmFyIGksIGosIHAsIHIsIGMsIHgsIHksIHcsIGgsIHYsIHMsIHN0ZXBOdW0sIGRvdFNpemUsIGRvdE51bSwgcmFuZ2U7XG4gICAgdiA9IHRoaXMuX3BvaW50LnN1YnRyYWN0KHRoaXMuX2xhdGVzdCk7XG4gICAgcyA9IE1hdGguY2VpbCh0aGlzLl9zaXplIC8gMik7XG4gICAgc3RlcE51bSA9IE1hdGguZmxvb3Iodi5kaXN0YW5jZUZyb20oeyB4OiAwLCB5OiAwIH0pIC8gcykgKyAxO1xuICAgIHYubm9ybWFsaXplKHMpO1xuXG4gICAgZG90U2l6ZSA9IHRoaXMuX3NlcCAqIGZhYnJpYy51dGlsLmNsYW1wKHRoaXMuX2lua0Ftb3VudCAvIHRoaXMuX2xhdGVzdFN0cm9rZUxlbmd0aCAqIDMsIDEsIDAuNSk7XG4gICAgZG90TnVtID0gTWF0aC5jZWlsKHRoaXMuX3NpemUgKiB0aGlzLl9zZXApO1xuXG4gICAgcmFuZ2UgPSB0aGlzLl9zaXplIC8gMjtcblxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zZm9ybSh2dFswXSwgdnRbMV0sIHZ0WzJdLCB2dFszXSwgdnRbNF0sIHZ0WzVdKTtcbiAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgZm9yIChpID0gMDsgaSA8IGRvdE51bTsgaSsrKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgc3RlcE51bTsgaisrKSB7XG4gICAgICAgIHAgPSB0aGlzLl9sYXRlc3QuYWRkKHYubXVsdGlwbHkoaikpO1xuICAgICAgICByID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tKHJhbmdlKTtcbiAgICAgICAgYyA9IGZhYnJpYy51dGlsLmdldFJhbmRvbShNYXRoLlBJICogMik7XG4gICAgICAgIHcgPSBmYWJyaWMudXRpbC5nZXRSYW5kb20oZG90U2l6ZSwgZG90U2l6ZSAvIDIpO1xuICAgICAgICBoID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tKGRvdFNpemUsIGRvdFNpemUgLyAyKTtcbiAgICAgICAgeCA9IHAueCArIHIgKiBNYXRoLnNpbihjKSAtIHcgLyAyO1xuICAgICAgICB5ID0gcC55ICsgciAqIE1hdGguY29zKGMpIC0gaCAvIDI7XG4gICAgICAgIGN0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN0eC5maWxsKCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG5cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZHJhd1Rvb2wvYnJ1c2hlcy9icnVzaGVzL2NyYXlvbkJydXNoLmpzIiwiaW1wb3J0IHtmYWJyaWN9IGZyb20gJ2ZhYnJpYyc7XG5cbmZhYnJpYy5JbmtCcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5CYXNlQnJ1c2gsIHtcblxuICBjb2xvcjogXCIjMDAwMDAwXCIsXG4gIHdpZHRoOiAzMCxcblxuICBfYmFzZVdpZHRoOiAyMCxcbiAgX2lua0Ftb3VudDogNyxcbiAgX2xhc3RQb2ludDogbnVsbCxcbiAgX3BvaW50OiBudWxsLFxuICBfcmFuZ2U6IDEwLFxuICBfc3Ryb2tlQ291bnQ6IDAsXG4gIF9zdHJva2VJZDogbnVsbCxcbiAgX3N0cm9rZU51bTogNDAsXG4gIF9zdHJva2VzOiBudWxsLFxuICBtb3ZlZDogZmFsc2UsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oY2FudmFzLCBvcHQgPSB7fSkge1xuXG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy53aWR0aCA9IG9wdC53aWR0aCB8fCBjYW52YXMuZnJlZURyYXdpbmdCcnVzaC53aWR0aDtcbiAgICB0aGlzLmNvbG9yID0gb3B0LmNvbG9yIHx8IGNhbnZhcy5mcmVlRHJhd2luZ0JydXNoLmNvbG9yO1xuXG4gICAgdGhpcy5fcG9pbnQgPSBuZXcgZmFicmljLlBvaW50KCk7XG4gIH0sXG5cbiAgY2hhbmdlQ29sb3I6IGZ1bmN0aW9uKGNvbG9yKXtcbiAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gIH0sXG5cbiAgX3JlbmRlcjogZnVuY3Rpb24ocG9pbnRlcil7XG4gICAgdmFyIHN1YnRyYWN0UG9pbnQsIGRpc3RhbmNlLCBwb2ludCwgaSwgbGVuLCBzdHJva2VzLCBzdHJva2U7XG4gICAgdGhpcy5fc3Ryb2tlQ291bnQrKztcblxuICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuICAgIHZhciB2dCA9IHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtO1xuXG4gICAgcG9pbnQgPSB0aGlzLnNldFBvaW50ZXIocG9pbnRlcik7XG4gICAgc3VidHJhY3RQb2ludCA9IHBvaW50LnN1YnRyYWN0KHRoaXMuX2xhc3RQb2ludCk7XG4gICAgZGlzdGFuY2UgPSBwb2ludC5kaXN0YW5jZUZyb20odGhpcy5fbGFzdFBvaW50KTtcbiAgICBzdHJva2VzID0gdGhpcy5fc3Ryb2tlcztcblxuICAgIGN0eC5zYXZlKClcbiAgICBjdHgudHJhbnNmb3JtKHZ0WzBdLCB2dFsxXSwgdnRbMl0sIHZ0WzNdLCB2dFs0XSwgdnRbNV0pO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IHN0cm9rZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHN0cm9rZSA9IHN0cm9rZXNbaV07XG4gICAgICBzdHJva2UudXBkYXRlKHBvaW50LCBzdWJ0cmFjdFBvaW50LCBkaXN0YW5jZSk7XG4gICAgICBzdHJva2UuZHJhdygpO1xuICAgIH1cblxuICAgIGlmIChkaXN0YW5jZSA+IDMwKSB7XG4gICAgICB0aGlzLmRyYXdTcGxhc2gocG9pbnQsIHRoaXMuX2lua0Ftb3VudCk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKClcbiAgfSxcblxuICBvbk1vdXNlRG93bjogZnVuY3Rpb24ocG9pbnRlcil7XG4gICAgdGhpcy5fcmVzZXRUaXAocG9pbnRlcik7XG4gICAgdGhpcy5fc3Ryb2tlSWQgPSArbmV3IERhdGUoKTtcbiAgICB0aGlzLm1vdmVkID0gZmFsc2U7XG4gIH0sXG5cbiAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKHBvaW50ZXIpe1xuICAgIGlmKHRoaXMuY2FudmFzLl9pc0N1cnJlbnRseURyYXdpbmcpe1xuICAgICAgdGhpcy5fcmVuZGVyKHBvaW50ZXIpO1xuICAgIH1cbiAgICB0aGlzLm1vdmVkID0gdHJ1ZTtcbiAgfSxcblxuICBvbk1vdXNlVXA6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5fc3Ryb2tlQ291bnQgPSAwO1xuICAgIHRoaXMuX3N0cm9rZUlkID0gbnVsbDtcbiAgfSxcblxuICBkcmF3U3BsYXNoOiBmdW5jdGlvbihwb2ludGVyLCBtYXhTaXplKSB7XG4gICAgdmFyIGMsIHIsIGksIHBvaW50LFxuICAgICAgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcCxcbiAgICAgIG51bSA9IGZhYnJpYy51dGlsLmdldFJhbmRvbSgxMiksXG4gICAgICByYW5nZSA9IG1heFNpemUgKiAxMCxcbiAgICAgIGNvbG9yID0gdGhpcy5jb2xvcjtcblxuICAgIGN0eC5zYXZlKCk7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgICByID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tKHJhbmdlLCAxKTtcbiAgICAgIGMgPSBmYWJyaWMudXRpbC5nZXRSYW5kb20oTWF0aC5QSSAqIDIpO1xuICAgICAgcG9pbnQgPSBuZXcgZmFicmljLlBvaW50KHBvaW50ZXIueCArIHIgKiBNYXRoLnNpbihjKSwgcG9pbnRlci55ICsgciAqIE1hdGguY29zKGMpKTtcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmFyYyhwb2ludC54LCBwb2ludC55LCBmYWJyaWMudXRpbC5nZXRSYW5kb20obWF4U2l6ZSkgLyAyLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfSxcblxuICBzZXRQb2ludGVyOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdmFyIHBvaW50ID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSk7XG5cbiAgICB0aGlzLl9sYXN0UG9pbnQgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUodGhpcy5fcG9pbnQpO1xuICAgIHRoaXMuX3BvaW50ID0gcG9pbnQ7XG5cbiAgICByZXR1cm4gcG9pbnQ7XG4gIH0sXG5cbiAgX3Jlc2V0VGlwOiBmdW5jdGlvbihwb2ludGVyKXtcbiAgICB2YXIgc3Ryb2tlcywgcG9pbnQsIGxlbiwgaTtcblxuICAgIHBvaW50ID0gdGhpcy5zZXRQb2ludGVyKHBvaW50ZXIpO1xuICAgIHN0cm9rZXMgPSB0aGlzLl9zdHJva2VzID0gW107XG4gICAgdGhpcy5zaXplID0gdGhpcy53aWR0aCAvIDUgKyB0aGlzLl9iYXNlV2lkdGg7XG4gICAgdGhpcy5fc3Ryb2tlTnVtID0gdGhpcy5zaXplO1xuICAgIHRoaXMuX3JhbmdlID0gdGhpcy5zaXplIC8gMjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3N0cm9rZU51bTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzdHJva2VzW2ldID0gbmV3IGZhYnJpYy5TdHJva2UodGhpcy5jYW52YXMuY29udGV4dFRvcCwgcG9pbnQsIHRoaXMuX3JhbmdlLCB0aGlzLmNvbG9yLCB0aGlzLndpZHRoLCB0aGlzLl9pbmtBbW91bnQpO1xuICAgIH1cbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9kcmF3VG9vbC9icnVzaGVzL2JydXNoZXMvaW5rQnJ1c2guanMiLCJpbXBvcnQge2ZhYnJpY30gZnJvbSAnZmFicmljJztcblxuZmFicmljLlNwcmF5QnJ1c2ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuQmFzZUJydXNoLCB7XG5cbiAgY29sb3I6IFwiIzAwMDAwMFwiLFxuICB3aWR0aDogMSxcblxuICBfZHJpcHM6IFtdLFxuICBfZHJpcFRocmVzaG9sZDogMTUsXG4gIF9pbmtBbW91bnQ6IDAsXG4gIF9pbnRlcnZhbDogMjAsXG4gIF9sYXN0UG9pbnQ6IG51bGwsXG4gIF9wb2ludDogbnVsbCxcbiAgX3N0cm9rZUlkOiAwLFxuICBicnVzaDogbnVsbCxcbiAgc3ByYXlCcnVzaERhdGFVcmw6IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFWY0FBQUZ0Q0FZQUFBSEUxeGxGQUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUtUMmxEUTFCUWFHOTBiM05vYjNBZ1NVTkRJSEJ5YjJacGJHVUFBSGphblZOblZGUHBGajMzM3ZSQ1M0aUFsRXR2VWhVSUlGSkNpNEFVa1NZcUlRa1FTb2dob2RrVlVjRVJSVVVFRzhpZ2lBT09qb0NNRlZFc0RJb0syQWZrSWFLT2c2T0lpc3I3NFh1amE5YTg5K2JOL3JYWFB1ZXM4NTJ6endmQUNBeVdTRE5STllBTXFVSWVFZUNEeDhURzRlUXVRSUVLSkhBQUVBaXpaQ0Z6L1NNQkFQaCtQRHdySXNBSHZnQUJlTk1MQ0FEQVRadkFNQnlIL3cvcVFwbGNBWUNFQWNCMGtUaExDSUFVQUVCNmprS21BRUJHQVlDZG1DWlRBS0FFQUdETFkyTGpBRkF0QUdBbmYrYlRBSUNkK0psN0FRQmJsQ0VWQWFDUkFDQVRaWWhFQUdnN0FLelBWb3BGQUZnd0FCUm1TOFE1QU5ndEFEQkpWMlpJQUxDM0FNRE9FQXV5QUFnTUFEQlJpSVVwQUFSN0FHRElJeU40QUlTWkFCUkc4bGM4OFN1dUVPY3FBQUI0bWJJOHVTUTVSWUZiQ0MxeEIxZFhMaDRvemtrWEt4UTJZUUpobWtBdXdubVpHVEtCTkEvZzg4d0FBS0NSRlJIZ2cvUDllTTRPcnM3T05vNjJEbDh0NnI4Ry95SmlZdVArNWMrcmNFQUFBT0YwZnRIK0xDK3pHb0E3Qm9CdC9xSWw3Z1JvWGd1Z2RmZUxacklQUUxVQW9PbmFWL053K0g0OFBFV2hrTG5aMmVYazVOaEt4RUpiWWNwWGZmNW53bC9BVi8xcytYNDgvUGYxNEw3aUpJRXlYWUZIQlBqZ3dzejBUS1VjejVJSmhHTGM1bzlIL0xjTC8vd2QweUxFU1dLNVdDb1U0MUVTY1k1RW1venpNcVVpaVVLU0tjVWwwdjlrNHQ4cyt3TSszelVBc0dvK0FYdVJMYWhkWXdQMlN5Y1FXSFRBNHZjQUFQSzdiOEhVS0FnRGdHaUQ0YzkzLys4Ly9VZWdKUUNBWmttU2NRQUFYa1FrTGxUS3N6L0hDQUFBUktDQktyQkJHL1RCR0N6QUJoekJCZHpCQy94Z05vUkNKTVRDUWhCQ0NtU0FISEpnS2F5Q1FpaUd6YkFkS21BdjFFQWROTUJSYUlhVGNBNHV3bFc0RGoxd0QvcGhDSjdCS0x5QkNRUkJ5QWdUWVNIYWlBRmlpbGdqamdnWG1ZWDRJY0ZJQkJLTEpDREppQlJSSWt1Uk5VZ3hVb3BVSUZWSUhmSTljZ0k1aDF4R3VwRTd5QUF5Z3Z5R3ZFY3hsSUd5VVQzVURMVkR1YWczR29SR29ndlFaSFF4bW84V29KdlFjclFhUFl3Mm9lZlFxMmdQMm84K1E4Y3d3T2dZQnpQRWJEQXV4c05Dc1Rnc0NaTmp5N0VpckF5cnhocXdWcXdEdTRuMVk4K3hkd1FTZ1VYQUNUWUVkMElnWVI1QlNGaE1XRTdZU0tnZ0hDUTBFZG9KTndrRGhGSENKeUtUcUV1MEpyb1IrY1FZWWpJeGgxaElMQ1BXRW84VEx4QjdpRVBFTnlRU2lVTXlKN21RQWtteHBGVFNFdEpHMG01U0kra3NxWnMwU0Jvams4bmFaR3V5QnptVUxDQXJ5SVhrbmVURDVEUGtHK1FoOGxzS25XSkFjYVQ0VStJb1VzcHFTaG5sRU9VMDVRWmxtREpCVmFPYVV0Mm9vVlFSTlk5YVFxMmh0bEt2VVllb0V6UjFtam5OZ3haSlM2V3RvcFhUR21nWGFQZHByK2gwdWhIZGxSNU9sOUJYMHN2cFIraVg2QVAwZHd3TmhoV0R4NGhuS0JtYkdBY1laeGwzR0srWVRLWVowNHNaeDFRd056SHJtT2VaRDVsdlZWZ3F0aXA4RlpIS0NwVktsU2FWR3lvdlZLbXFwcXJlcWd0VjgxWExWSStwWGxOOXJrWlZNMVBqcVFuVWxxdFZxcDFRNjFNYlUyZXBPNmlIcW1lb2IxUS9wSDVaL1lrR1djTk13MDlEcEZHZ3NWL2p2TVlnQzJNWnMzZ3NJV3NOcTRaMWdUWEVKckhOMlh4MktydVkvUjI3aXoycXFhRTVRek5LTTFlelV2T1VaajhINDVoeCtKeDBUZ25uS0tlWDgzNkszaFR2S2VJcEc2WTBUTGt4WlZ4cnFwYVhsbGlyU0t0UnEwZnJ2VGF1N2FlZHByMUZ1MW43Z1E1Qngwb25YQ2RIWjQvT0JaM25VOWxUM2FjS3B4Wk5QVHIxcmk2cWE2VWJvYnRFZDc5dXArNllucjVlZ0o1TWI2ZmVlYjNuK2h4OUwvMVUvVzM2cC9WSERGZ0dzd3drQnRzTXpoZzh4VFZ4Ynp3ZEw4ZmI4VkZEWGNOQVE2VmhsV0dYNFlTUnVkRThvOVZHalVZUGpHbkdYT01rNDIzR2JjYWpKZ1ltSVNaTFRlcE43cHBTVGJtbUthWTdURHRNeDgzTXphTE4xcGsxbXoweDF6TG5tK2ViMTV2ZnQyQmFlRm9zdHFpMnVHVkpzdVJhcGxudXRyeHVoVm81V2FWWVZWcGRzMGF0bmEwbDFydXR1NmNScDdsT2swNnJudFpudzdEeHRzbTJxYmNac09YWUJ0dXV0bTIyZldGblloZG50OFd1dys2VHZaTjl1bjJOL1QwSERZZlpEcXNkV2gxK2M3UnlGRHBXT3Q2YXpwenVQMzNGOUpicEwyZFl6eERQMkRQanRoUExLY1JwblZPYjAwZG5GMmU1YzRQemlJdUpTNExMTHBjK0xwc2J4dDNJdmVSS2RQVnhYZUY2MHZXZG03T2J3dTJvMjYvdU51NXA3b2Zjbjh3MG55bWVXVE56ME1QSVErQlI1ZEUvQzUrVk1HdmZySDVQUTArQlo3WG5JeTlqTDVGWHJkZXd0NlYzcXZkaDd4Yys5ajV5bitNKzR6dzMzakxlV1YvTU44QzN5TGZMVDhOdm5sK0YzME4vSS85ay8zci8wUUNuZ0NVQlp3T0pnVUdCV3dMNytIcDhJYitPUHpyYlpmYXkyZTFCaktDNVFSVkJqNEt0Z3VYQnJTRm95T3lRclNIMzU1ak9rYzVwRG9WUWZ1alcwQWRoNW1HTHczNE1KNFdIaFZlR1A0NXdpRmdhMFRHWE5YZlIzRU56MzBUNlJKWkUzcHRuTVU4NXJ5MUtOU28rcWk1cVBObzN1alM2UDhZdVpsbk0xVmlkV0Vsc1N4dzVMaXF1Tm01c3Z0Lzg3Zk9INHAzaUMrTjdGNWd2eUYxd2VhSE93dlNGcHhhcExoSXNPcFpBVEloT09KVHdRUkFxcUJhTUpmSVRkeVdPQ25uQ0hjSm5JaS9STnRHSTJFTmNLaDVPOGtncVRYcVM3Skc4Tlhra3hUT2xMT1c1aENlcGtMeE1EVXpkbXpxZUZwcDJJRzB5UFRxOU1ZT1NrWkJ4UXFvaFRaTzJaK3BuNW1aMnk2eGxoYkwreFc2THR5OGVsUWZKYTdPUXJBVlpMUXEyUXFib1ZGb28xeW9Ic21kbFYyYS96WW5LT1phcm5pdk43Y3l6eXR1UU41enZuLy90RXNJUzRaSzJwWVpMVnkwZFdPYTlyR281c2p4eGVkc0s0eFVGSzRaV0Jxdzh1SXEyS20zVlQ2dnRWNWV1ZnIwbWVrMXJnVjdCeW9MQnRRRnI2d3RWQ3VXRmZldmMxKzFkVDFndldkKzFZZnFHblJzK0ZZbUtyaFRiRjVjVmY5Z28zSGpsRzRkdnlyK1ozSlMwcWF2RXVXVFBadEptNmViZUxaNWJEcGFxbCthWERtNE4yZHEwRGQ5V3RPMzE5a1hiTDVmTktOdTdnN1pEdWFPL1BMaThaYWZKenMwN1AxU2tWUFJVK2xRMjd0TGR0V0hYK0c3UjdodDd2UFkwN05YYlc3ejMvVDdKdnR0VkFWVk4xV2JWWmZ0Sis3UDNQNjZKcXVuNGx2dHRYYTFPYlhIdHh3UFNBLzBISXc2MjE3blUxUjNTUFZSU2o5WXI2MGNPeHgrKy9wM3ZkeTBOTmcxVmpaekc0aU53UkhuazZmY0ozL2NlRFRyYWRveDdyT0VIMHg5MkhXY2RMMnBDbXZLYVJwdFRtdnRiWWx1NlQ4dyswZGJxM25yOFI5c2ZENXcwUEZsNVN2TlV5V25hNllMVGsyZnl6NHlkbFoxOWZpNzUzR0Rib3JaNzUyUE8zMm9QYisrNkVIVGgwa1gvaStjN3ZEdk9YUEs0ZFBLeTIrVVRWN2hYbXE4NlgyM3FkT284L3BQVFQ4ZTduTHVhcnJsY2E3bnVlcjIxZTJiMzZSdWVOODdkOUwxNThSYi8xdFdlT1QzZHZmTjZiL2ZGOS9YZkZ0MStjaWY5enN1NzJYY243cTI4VDd4ZjlFRHRRZGxEM1lmVlAxdiszTmp2M0g5cXdIZWc4OUhjUi9jR2hZUFAvcEgxanc5REJZK1pqOHVHRFlicm5qZytPVG5pUDNMOTZmeW5RODlrenlhZUYvNmkvc3V1RnhZdmZ2alY2OWZPMFpqUm9aZnlsNU8vYlh5bC9lckE2eG12MjhiQ3hoNit5WGd6TVY3MFZ2dnR3WGZjZHgzdm85OFBUK1I4SUg4by8yajVzZlZUMEtmN2t4bVRrLzhFQTVqei9HTXpMZHNBQUFBZ1kwaFNUUUFBZWlVQUFJQ0RBQUQ1L3dBQWdPa0FBSFV3QUFEcVlBQUFPcGdBQUJkdmtsL0ZSZ0FBOG10SlJFRlVlTnJVbVZsdjZ6WVFoWWVVdkNiTjdRYjAvLys4QXJkN0V0c1NLZmFoWjlMUEU4bDJrTnlIR0JDc2hTSm5ob2RuemxDcHRXYWY1WmZ0RS8zNld4dW1sTjQxMEVmTVlMcWxrL2NhK2xIR1h6WDJBd3hOWnRZdVhOOXNmSDZub1FuLzhiQ1ovM2orYlRBYm9oS2owK1I0Q3ZjYXp2MDNYUXJNcFFqM2I0aHFOSVQzT2hpWFpWQ24vNFoyTkg0V0RtK0d3UVZEZTcyVFpVelN2VTczN25TOU5iTTF4a2htdHRKNU03UDlFand1UVM5ZndhSmgwQTRSby9FL3c2QXNRLzM1UnUxWGVMYzNzMlBvNHd3cVN3YS9Zb1BRTUdHNk1xTGpBKzdOck9xNjEvbGF4MkJtSjkxL2toT0RtUlVkMHdLbUZ4a2lYMWxNUERvTTVGRFl5YkFtWTM1U08xTzdIK1hnQ3BGYzQzOGxaKzV2WVlyK1NsUXRUTi9Xeko0MXZmNzhYbTE4cXJkd3BvZEJEMloyMEh0Vnp3YzlPMkEyWGxnbnBYUVczUmNZTEJqcVVkb3BVbmNhdktselgxaWo3bThCbXdJY202QXd5cUdxWndjNTc3UFdjUDRLRHYyRjZUY1pkOVFBSHRtbWFCNnhlTzVtV01PeFBLS3ZabWFQaUxvSDRxRHJaNzEzRTg4U24xa0c3WFJ2cDZPaXpRWTB4djRtR09IM1BWcmY2WjAvMU82azZ5YzVQaTV4Y0o2WitneE1aVVRHZ0RtUGJpODRPR1k3T09adEhNTk9ZNk9PamQ3eHRpc3N2cGkyLzQ5RStnK3dMZVJ5eDZpZnIySDhBOW83VmoxaG5KQW9IUGNudGUvVjU2aDNPalA3QysyT2dOQXJTdXREK3N0SW13a2VSd29hRkpFZU5NVE14aG54eFVnVzJHRGF2Wi9ma1hoNlVPUVVZWkNDOE1qQWo3L3dCQ2VZU3ZlZ3FBNE9NWUgwTXVvZVkvWHFkNk9JcnRCM2dhT2JwUVhtMU5FcENsK1F2ZmJRQWowOHppRUZHMllvZzZvbUdGY1J3U2RCSTRzcEhoRW9FNFRPSXRzSGllZGk0eEc4NnNxcUFqSTdUSHRjRk5RTGEwQmhBa1pYTW40U2JSWEFaWkVOeUcyK21IekYvZ0NvZEdIQlRRc3BjazZVZDJDRUxiS2lLVEQzaXZBRVdLVTVZNmZBcndYUi9SV3B0QS92ZG0rb0FCSVdWMVJ4N3ZpZndMcUxuWmZzbW1lNHRVUE9IOHpzRjBRbmd5Rk1NTEVMeW1tT0x4dXlteSswQko1OVFHVFBncENEV0tsUVZuL3IraCsxV2NsNDU4MFJhZlphUmVIbjAwdzZiVGcyeW13V2VUK2xkSmJCS3NUekZyS3RCSHFicTZGNHYxMFI5RDd0RlROYUZJZ0tIcy9Ca1JjTU9zV013WEJpNXhrNndRYy9ndlNYdEhFTFJXVUpkVnNPNG4wTHdYT21FUWlEakpXK0RlQ25TaXE2UHlDTkhyRW9vNkVjc0NDU0ZxSjZSTCtQZ1NKVEZESU5ndVJaTC9rZ1gzVStLUG9WaTZNQTc5UE0xRTh3ek0rSDRGd05zR2dCZG0zTzJBU1I0VnpybGNGWHFQNkt4UklIYnNoV0V5TG5qakxWanFETkFVYTNPYTJkWndyRENhcWVTV05yWnIvQkNJT1JCN0ZHd1dxZnd1Q01YQTJPRktpeGlxQXRxaTRMYVhMVTh3SFk2WkVjUm9pT05mb1lBanhHcE93SkVTMDRUZ3JRRUtCd1Z0ck1pZThHTFhEQUZJMEN2dWZ3RWFxK2dwTVR1TGxBcHg0Zyt3b01yb0FldFd5T05WaHFyUzBWaXl1OHNBSnByMUFsVE1nOE9kUmVOZENpWVpvTEREMHBBSHoya2p4WTNmWitZMllYaEFSdFp2YTlPdlJpTVVNeEZlaUhtS0VLeXU2Q3FBNll3VWRnZWxyY3ZEdXJ5OC9MbTRhb1JtMndRN1c3aHdBNnlaa2EwdmdJSTQ0b3Z3K1FoU1hRNWFzZG1hWHRvd1N2cTFhcVkyc3ZCMDdBV1FjNFZDeTRBVkZOV0V5R3lwZkN2RjdhUHByZCtZYkJWUDNjODlwZ002SUx1RTBRODl6TWNJWTVnWmFtSmJFOWE5ZlM1bTB3T0VFK2xxQkZKNVEvc2FKd25UcUV6YmdHQlZkdS9lWnc2emVGRkFxOWdySm1DQktQMVhFRk5NYVFIQ2JVV3UyV2J3dnYrVnFUZ3VMUE00SzdvU3h2b1NxeFc2Yit6Y2JlNEVDYUtlbDdSSkc0N0s0dHBBODNkc0dCdExBUDhTRWY4TkszK0hhN3dOZnYvdEtZUHRPSDVuOEJBQUQvLyt5YlcyOGJPUXlGS1drdXNkTUdhSUUrN2YvL2N3c3NGbTFheDNPVDlxSGk5aHVPWkkrZDVLazFFTmdKYkZtaXlFUHlITWI5VWNYZjZkSGNFZmszUDk3cTlwcjNkREVOTHVmYzNYQjFUd1lydVU4c2JldzlMWCt2S3A0SzNZVVk3dXVhY25tem0xMHJaUFo4b2IxaVh5dWVwU3c2NzdhdzMrbDdBcm96RlhnQkJ4b3pvUmdYbEkrdTh2bmRGdlkzV0pWeWZBTisxUnU2VkNsNTFzSnpSUXg4WFlDWlRzRWJJam5LZXJhZ05UMVRoOWN0TkM1blNJMkx2VmJWTmErbzR0YjZEWHkwQWNmS09uWkJuUnB5Ry9SM0Z1dSt3MjBtNHdieHB1SWJHNldzcEJzNHdDS1BLSjdIVEFBUFJuYnFNMytnS3VXRXVwWUYrMVJCbG5vUFpqYnFZWUVXSFVFRXcvZ0JpeitpUlZIQjR3VldmODRkYlpzM0wvbVowdFdtU3R1N1dZRXdNVUhqT3VLYUg5Q3BQcUJINndwWFBNdXY2WTBYK0xKa2hyMEQxMXZkY0NuZEJyeFphUjFCZngvUmpyZm9kbWNFMHdHY2w3YmErcmRQMlhkMTB3ZFkrM3B0Z0dLWmdNNVpnUzV2V3RtK0JpNlJJRmdzUmlrY2NhQUZ5VVBSNVNtN1NEQ2Q3Lzl4d3dHSnBwQStrOUdvbmtCb0hFMkNhSEZvdHVGVUV2VUFNdzZzbi9zQmxIaVNuL3J0VXN0d2pRSHZnR3ZXaVAyYWVhNEdvTy9nRWcwWW1BU3NUVUNCQmY1UHpWWlpHdm94Mi9oVjZtNXlZT21IUjFDVUttRWVERytsaHp2bTkvWG1KaUlnejdJdERuNnFFSFlTa2IreXBIUXk3WHdzQlpnM3BQR0VmRC9rS3hxTnlEWUF2Z0xVSFFwekVRbGpOSEZBUFA0SGZqNUpaZlRFbTlTcTF1amw1NHdCdit3SkJVa0FWRDBBMmdoL0RYNW1mT2FZMStuaEFwb1ZBMXhwVTdzMEYyRHJHVkZNanF1citLOHJsSU1lcURFWlBZR3pDa3AvS20yNmxGS3dOd2pBN1BVbG43N0hKamtHRlhBVHBVN0JHMEt2enh2ckVaQWVhVmdSb3BmS3FCK0Y1Z2wrODVqOVNLREdPRm1QbVhUbXNIdksvV0N1T3BwMVQ4aGttM3JYSTJoVW1EaGwvRlBpZDBCQVRJQzNBZEpTclFkTEJiS09vd0FCRmozS3IyRUxscWNiQ1ovNlZZRFE4VEZiNExOQkFXWWhxV3gwTVFFeXd3ZjVyTzd4QXNqek5UUWdBeDFRNlN2R3RvallVT0pVemV2UkJLdE41WTNCNVFtdzF4bllTMFFaWDFBWGx3elFpOEc3Q0lyZEcrR05qKzVDTDhkeHZ4bjFoS2JpZjJVN2R4T3RaUmtnVTc3K01lZHFoWnl6ckdWOTFiQlN4ZExKQ0IwUmlXRTBnb2ZQVU5uaC9adlpXbCs0U3ZVZmhSbGF4VTV1ZnNlMW55cDhRbzhEQlZpV2cycWpXVjhLejZ1RzBKdlRUZ0RvRVc1Q0NWL2JtZ1hYVDBCWDF4bHhFeE1zdmtERW84ekU2OTlZbHBOeXpGaXExOUppczdId25LOXdnUDlTMG96NFhhMDc0TkJxRUk2akxpVTREQldXWlFhc0hDQU42UUlQNkhDOXJJZllLU1k3K0NsbkUzbFRaK0I3TkJ6RnFyWHgrVVdTN1ZDT05vYmZaRDNUbWhBRVZMV2pzUll0S2JJV29OVTl2dWExenFhVlYweXY5bUQyZndZR1FJM1BDMzlBcFhWR0FkMFk2WWp1cEoxc1FMMUtQMlc1ZUNwWmRyWFpySW9udzE4RkJJbVdldCtBZzZPcHFyenhOYnZPaEE1M3h0VnJwanViOUgxWnV5MlFITTZRYXZxL0JzZjhNK1NXSjVndUltS05FektUcHRRZitmVUVLMGZqOTd0VWNXZEtQd3JPTGRpWmdFci9qQlRhRzNCbmdlUVIrUUxMYmxKM2lUNXFMbFJLRER5UHNvN3R5VE9pWDY5NWtMVkd5NW8xR2xRbzFTaHZRaWEzS0xvZjg2WS9ndVBTREVRaG1ueUJSd2M3WXEzNUdtMjBTMU1vVUVxc1NTMjc2QkZNSXVzNW1kRmtwVmhxVzY2eDM3ZXE0czVrT3c2Mk84UE50dkRiemlRV01lV2pTenMyOGhwVjNGVTJTOEprTW5ENEtvM3N6ZVJRWTMxM0tWanUvYzQzazBOVFNtSlNkMUZLK20xVThmOEFBQUQvLyt5ZFczUGJSZ3lGc2J6SWtpOXBtK24vLzRPZEpET0p4NVlvY3JjUEZzcHZqM1lweVphYnVGTy8ySXJ0a0FLeEI4QUJjUHloYnZZamZUVC9tK0I5UHE3YXdIK1A5ZmUzWU5PSGhvSjNNbWFKT0h2VFFNTy8vU0NhbjJ6VWtyUkFYNkZQbFQrK0twUmQyMEd1TllaNHJoR3RrQmxxeVdhU3BLbnhKOGt3YTZNNlo0bFZ2SmYzTmxjMmFqanhiNDBkYi9tMmhXWkJRRG1xRDZOSEhVMSt2Q1NpRVd4aEdtZnAvYjNWZzVzTERSb3FQZjRHcFVHUnB4UTJPb0RHWVN1SGRPWWdodmJQOTFMa2tZdGRneHRvQ3ZSb2FTUDBYZURoVW1XZVV2K0FwWXNXakc3QVBYaXJUcXJpenZJcDVtVHpMTUlBMG1SditaaFdaeThEOFQ5d1A1UGw0OXFsN2V6YUEwOUx4cjBVSGk0ZFFReDJQSklReENoNnpMbnlmV3Z6V3Rra0JiQWIwWnRBUGhHd0UrT3dDOWJqSVczdHVOc2FMSjhDSUdGNVkxaVN0cnlaTkwwVmY4L2xZVW9YajBKdmNQMTlzcm5YSFdBd2JwYXZiZTZxK1NhWnM3MCtMYk1DQVpVT0h2cUk2d1I3NlNQNXJ2VWpqdnpPOHJtUnJlV0xodjV3b3MwREEybkJnUzR5OExsc1hBMXNlam1HM0Y2bmdJRXpkM3NZMGNsZFh5bDFRejFZM3NXTE1QU0R6UjFvWndTZDdQME5HUDdGNXQ2Q041NDV6elhDeUkwUUhEMEl1VmNiZDJsVGFTbnlrL0pzQlJZWTZXOEZ6MzJiM3lmclJoaXhBNjk3QjJ5ZDhHYVRHS2tYV1BpQnJPRUpSMzk5OEd3S21iaERjR09hc3hOUkhHaC9DVFIwRmFNR3lTUFpjSW00QVViNkRwNUorWU5uZTlGdjh1dVJaL1pkT0E5c3QrTDV2QVozNFZvcEpCd3ZOOEI2aHhZMzBwM2xRaFdPNmE0b00xcSs0c3RKaG5FSkxpOFpRbFY2bUpXUEJ4VHYyM2lnY2VFV0dpY2lVSGlibWVQQmEzdHBVTjFhcnVRUnBYRFFhUVVlNGNieXNTQXVIKzRSR0EwNDZqTjV6eloza3JtSHpXM2lwYW4xcXVmV0RLdUxpcjNsVTQ1Y2pXdmdOZTRaZmxOcitYNlNsSXRqZFN0NFI0c0E2S05JcGVYR1pQbDhUQUs4cUg2UmE4bDQvOHJ4L2F0QWdSY24zeTBmaEF5RmJPRWY3RlhEZGhWYVhkZjZhSVFrK01rVTZFK2JKNUEvMlR5NDYwZVVucTRhRzFSTkN6QStSMkFZV0toUkY4WG9sT0ZxZ2MrTzVUM3cybFBBRllLclNuYU5jb0xzVkRXblU5TTg5cjE0UkNjSjl3cWV4TkhCZTd6ZVdONEdhNUgrZUdQOXM4MHRZVDhaTGtHbjl4S0FmUXhvQ2dsSmdrMnd2SXYxZFBqNm04MWRYWi9sR0E0bjVSSHYzZUd2dGVNaDFWU0Znb05SMmF4TWhacStzMXhGaTRUSXZSeC8vLzgyOE81QktqSXZBTGd2a3ZDd0dqbUdVWDZmTTZBN2dRS2VOTWZhRlNyQUFhZUVBNitlSTkvWmk5d09CeGE4eTN3a05GTU5YaUFBa3VDb0lhWHlWTW5UbDhIbTlmcFBObXRXdFhMa291V2piMXgxN3BGcCtNUDZjdkJpR2pZVnlKaUlFNldCelNUdzdQQTllancxTlo1c25nbno4U3AvSGVURXhDVnZWY09XMXB5VXVPQlFUNE44MUVVWDkzYXNMa0hDWTFYd1ZyMkdRbEp0WDB5eExsbytsa1ZvOE4vL0poQVRjWko4bU9PYnpjTWRXOHMzQWdiQXdqK25ZbWxvbzFUamR6Z3l2ZVdUZGhIWWRDTS9Qd0ZQa3hRTVFjanFVR0Nja3RWMzJaUlJvME8wQWxjUkh1YmZmNEEza3dCcUFTODl2UGgzbXdWWElnSlpTZEtzYUZpOStRWVIzQVNYcUZuV2lMRTdtMVhuS00rZ3hZYk9HWWNUaFBTVFZISEt0VVk1Wlh6VFBSNDZQeE11UE4vOWNmaS9QdG04cHVRcDVDT3V4ZWxpTHhKU2lZL1ZJZXk5NWRNNG51cjBlSHEremVPTE1OOFJUWDFzanFxTnZWUlRtaUl0c1JxM3RieGM3bHZWZkZlV1Q4MGx5VzRhUUpKUHpmMXhNUEJuUU1Gb3VRWVNoODNNRHB0SkpjTlNpWVFldEVmd2lpZ0JtWmQ2RUxnL3BFOGJwQzlKQWd5ZmVFbE91MGFVVDVYT1FJMVhaVGF3dDF5L3R2UVFLZERybzRaL0FkWU01YkUvc0U2cXRjQkdRQ00zbzN0a0kzSklQMEpQdUdFN2VLdi83Z1B3YlFWT3dFa01GNG1LMGpGSUZZelY3ZTNhK0hnb3ZHNXd6WlY0TURtSUFUbnNpQXB5a0o4ZjRPMmo5TjZPc3BlbTBESmhxZGhKQkdTKzJFcFNyVXB6Tzh1SFRLbGJ2VVZ5UDRtWG5hSXFUKzJVa0dlOUFYZXh4OUh1cmF6MTdzSHNRYktXWnhoMWE4Y1M2dUZVejB2SDJyVFYvQVFtaWFtVjUzMkQ1VnBzVVRDSmZhaG5rTTk3U2ZpWDhEWlZQQ1VJemRjS2pka2kwV2V5UHdrNUhvWE0zeFlZcnFibXFTV00xZU5INDdwM2JjUlQzZGd1bVdtQ28vcm10cElkN0MwWGFab3NsMnhMQzhaVnlPRFhEZ0U3QkZ2Q3lnQmpCVUJiQzJ5bTJGa3BkdzVMRGRtdTB1Y1BjUHZXOHZseVQxRTYzTUNkNVRxT0cvSGFEcmc2Rm5waVc5Q09oS1cyTUZ1UUNoWFlWRW5CeUt0eXRsZ1hVVlRrY2hUWTgreEhtNmRtU3lweWxYRmQ2amhNbHU4cDk3aVJHNURRYXdRdHFuUkhFQ3dLTVV4M25LQlpGNG9MVlZtbTZDYXBSdTc3TlpLSDZ6Ny9GaEJHTG1JNEdESllMdTRkaFNPcFNrMTFsUW1TMGpRS240enptU051eWpsUGFzRUhNRnlqNWZzQjJwMTF6WUc5VUlNc1RFWXI2MkF3L2VJcEhJWDJjMFA0aHNZelVpY1NNOFRWSGE1UGllUEZVZXFsUDBFUUpLQXgxdzBvRVB5aWZ4eHUxQmZmYnhBUTFoSzR1UEVjRUhFamNzVk8rbW1USGUveU1nTXdLVndTQXF6S1puaVg0Ukh2eFp1Ylh3dXdzd054SGt1R1BVZkZZbWxFYUdYSGt2SnNrVkFpWm85cGx6WHl3ZzBnSkFtcDNWZ3Vsc0lVYUxMOGp3ZE1kcXpzSFNYbFlscW9tY0RlOGlXL2FNY3JQeVlQL0tRc3lEazlyMUpGdE1iUko5SEIxVjJPRy9FdmZBUjhmWWZBMStIbnhnSXhZNVpyL0RsOHJBdEZUVk9BQ3dhbVpQa2VLd3NEaDdKNzRPdGdaUzNYcTdTL2E0TnUwZklWNWdIMFlXdTVldWhuZVBBR0dMcUJNZThFWXFKTTBwaGdxa24xTTlxeDluR1NHWUVBNW1vTGo5L2JzWnIwb2lqNXRRWTJOUGZsMnBOS3V4TGtWOUxMY3VhSVBhVUUrckVwRUJ6Y01PVXNnVWszSVFrdm0rVDRjMTJXdWZNb3h6eFdvR1dSMkw1NGRxdlNEOVA1Vk5YQklmKzZ3dWNHUGFVTzNya0R3Y09PN1RPSTZSN0JxUkY2c0xOanpYS25HM3VVcERzYyt3R1RPazl5LzdFVytkOUZVclFDRVkxVVdzUmpEa1lreTNXbmVuaHJBN2FvbHpaMGtDTk5UUCtPWERrSml4VXNYMVdPa3Vrd3hlcUVXclRYSFA5WEc3Ymd3ZWtFQm11TFo1SmEzbC9mUy9lMEs4QkNDK091VUxHdEpZcXZMUjhiVFZKcHBRWHl4cTVoMUZjYjlnUVcxL1FQZFdPVVdLMENDejJDSGVrNlExbk5DbTZRWUVjcWxMTllKZm5EcXhuenFvYTlJT2pwbEUwanFZejJyMFlwVFYyeHJRTzI4dWVTY0FicERLODhLeWY5SlF6N3hnZWhDWDl0ZDFSMS9FcEUwcnNiNzVjMjdDdUNaVnJnTjlLMWovUi8wckN2Z0ptZjRwMGYzckFmNmVOdjlzNTF0NDBraDhMczZtNUp0dXpNem1KMzN2LzFGbGhnTnBPTWRlbmIvb2dJZjNXYTFaSnMyWEFDR3hna0dkdFNpOFhpNVpBOC9CVHNHMzE5VG45L0N2WlRzSjlmOWd2eEZYdzBYL0VXRERZZjR1dW5KNEo0cFZCdlRlNncrSHJ2S2V5UHlyRHgwMnQ0K2dCQ0xmRU1sTDYzOVB1WC9QOWZKaXE0NWdOcW0xUEV5bkhwUXBEcG1tZTQ5YzFMNzZDdDA0Skc4dnVOUEZOdHk5UWpPdHkycE9uVFQ2R3hWNTZ1OWwzVkJXR3p1S2k3ZHBzeno2ODlaMmNScjlMbnVwWG1wamUrOGpyN3l2bXNkRWFiSE56V3lVZ09pTEFhc1RUemVuK05XYnFGY0c4cFdMV0xxZkF6VlhDTjJXWE5QMWxPSVNPcE4zbHdsb0MvcTF3d3V3OXRDdVNxVklVcnIrUUswWHJrWlBFK0JkZFNIN1pUUmxYMlg3SDB6cTd3MXM3enY1eDFhcTgxQytrR0dobzVpT25NVmFmZDlRWU1aOUp3SW1zZjF2T2ZXVm5lVEdlV0Z3VEpFNjBPTU5tY0p1QmphT3ladHFNcTBNeFJ6TVBLNWxNdmF6eUhWMXRaNXFad3ZCZE1PdzdkM25hV0QvKzUrVENiRTZhVkppRnZabS9UQzRTYUxLYUM1Z09PbHJmSk41YTNmTEpWbnMzSVpEWnE4ZSt0UGJmcFA1eit2clY4bXREL1UwZm5XdndRYVBuMGdzOS91NVIyWVcxeEZOWkVRVHgzTXpjU1FtbGpyeUp2M29Ma3JVVEs2YlUvZWYydmxvKzlzem1aclVmUnRPVE5temJTaFVLTlNCcjVMdDZYdGJaOEFhQmV1MUhDS0crdi8xM3NxZmZWZWhjalg1ZTN3cnZHbi9CNjkzSnIvRmtZa2lXTHFmdmVENFE1czJRN0NyWElQS1RzR1VmTHA3L3A5VGtyRmsxRCtuaTg5OEN5Yzd1SEFJL1FaQi9XSU52U0x0QnNzd3Q0WDY3UjJrc0l6VW9qOTJwbmRSbFNhL24yUEE0MWszNXZzQi9ycnY2MDV5N3gydktoajUzbC9hMTMwRkMvNmtlSmkzM0V5UGZNYmV5WnJvK3Q5YlRETjBQQ3JtV0s0K2ttbTI5WTdTU3JJamRMWlhrSDl3YUMyVmsrTHVvQ2Q3S2RnejBQUUs5Z01yeGowSmVZYlU3Lzd5c094UnVOdVNlSHd4N2FDM3RSS3Z6aXZiclZYS3FhNzFkeS9ROWlKM3ZSWXJmQjdxRzlaYjQ1YVN4Si90Y1NWWGlNK205b3EwY05mZ0FlSmZpaWl5Y0l6Zy8rM3ZKaEZVMGthb3VuTW04VGJnWE1tOHo1bFgyVGM3ZjM4cm8rVmIyeEg1M2NMaVQvOC90SlU3L0NPZmxtUmpxckI4dmI4eDhRci82QjZNUER1dDlQUCtQMEtGdlk2Y2J5Wm1oT09aS1RzUVJmWGhTQ1hVUEJsOFEyanZpZ0cvc3hFTEZHT01XWmhNSHl1UUxQOTNmNGZRKzdmQzhNdTY5OXNMbTErY1I2Qi9QaXBKRlArTjIvRUdWTTRnQUhlUzJ6T1F0emJWZndiUlUxdGlEVTF2THBRZzRqVDlDd0JoL1VOZFVkVWlkQnZJOTVQcHorL1FpY3dNMEs5elkyQXVMNExYbUV5ZWhoYW42ejU3YjdmNXorVGVvL2JlbXZCTmd4eTBkZFMrbjhaUm9iN0F0UlpIOWw4L2xZdDFsYmFBMnZyN2ZOK3pXN1AvM2NIVjdid3pHdUZTVVJtWElxSmh4cWkrakFXZDVJVkdIMnpCQkh6Z1h5R1hMSmtJSStpK09kMFZlekVGNU5jaTFNQkVDNkpNK08vQm83Tit6V2NqSWVudnpXY3FhM0dxRldoeENOZzhJcnViNDYwM3VRdjNPWGtJZDVCOHRKZWVzZ0l1Qk14YmdrM0JKcFpGcEFyUnJ4bnI2bWVnZkRQK0REazgrVnpCUzBiMGVZQjZhZGJqczlMTHVYVEVrQmM0NmRKb1J1dXZxU28xR1B1RDNPQXZxSUEvZUQwdVZrOWhKa0xKcE1MTkhkSzRzN1VTYTNqenNJWnlOT1lXMXpqaTFtUUJ2TGQ5ZU5OdWVISGFHaEJNeTVnNVM4QS83Nk8yamtOMmpqZDl5VUo4dG54WlExYjdqR0pDek4wbFlCZU0zQnVCRUJ1VStwZkpGVDl4R2tFYitYQWdlaFF4bTF6WGxyeVUxQUFLVkdHdHRKcU1UTmg2UEV1V1JFNWxiRkpHWmtmSW10VFF2SWVpdWxFTS9GSHkwZkJ6cFl2bVBhYy9TOUNIRmwrWkJ4Skx3R2RyOEpuS2dmemxyOEExZExLdmVzMzRZMVh2OWZsazh0cnVBL3RPQlpYVkNmVzNaZVltYzdzVkdHL0R2aEF5YWtwQjVEa3NCM2pldkt0TEpESmtiblJ0S3pUcUEvT3ErRTErYnE2eFUwVGRtUGFwZ0Q4aXFNRWxZTndTMkt6RUZSMkEzUzEya0JaeDN4d002Y1FXL0xJV1FTbnoxS1dZUVlxVVlhamRoVzhuZXZKSVlscGtxY2xrVkUzWnRBVW9tTkhBWlhpMGMzdDVOVWVEaW53VkZkZnBKVDZvSGVjNHhUcVpiOTlOZVc4OEtNa281V1ltTWJTVWZwbFZ2eDhQcU12YUJsT3M2a3lwR2tGUDVrK1dMWVNSSUYxdVVxK1R6VHBWaEJKY0F2V1MwT1NEL0pCTGVCbGs3UTVFRUVTUSsvRWR0SVRlM0ZCbThRVWpVUU5rTzhHdjgveWQ4YllBUWtidi90OUx2M01GdEhISzR1bytnc1oyaWV6aVVKalFoNUZQQzNzWHlqeGg0bzBRQnYyZ0RGdndzT3E3VTVmMEJqT1FsdkVydm81dU14cUFqUXJLeEZJNVZPa09TWGRvcGNEcGF2NGFiakd1Q29EMkozMTJJeXlxWUFzYXZ5c1ZhV1QyQ1BsdE02Y3l0d09qM3dGZys1aHAyYkpGT3FMZDlmMytEd0ZQU3BBZ2d2QmYvMlpHUWw3MnZ5L2tlQkIydmNnanRFRVFuYVh0bDgvL2xGcG1DeW1MZjFpSlBscWhNSE9pWXAxcEhlN29Dc3k2UjBuVVNyZUhXdEFGY3lTYWtsM2E2azNFMmdmR1h6YVhOSDBWYVdVd3Y2T3BZR0RsVWJVR3FMNldGbmdxMEs5dFp3QlZjQVQvNG5IM3BBMkdYSWdEWkJUWW0yZHJJNU05SWsyamlKdHRJUDFQS3pvOFVzeUJXdTlyM0V6bVRYYlBIOEk3Q0VhSXE4dCtWbXZSbHNSbjdWSG0rbVlNa2FLZVlkd3JBSk1HQ3krY2J5aEhTM3Rmbmk4R3FoSVVSYk01K2tZSmtrUzZwdHp1WjV0SHo3MGlpRnp3cUpSaU1wcmxlQU8wS0tTM2lzZmdoNjlGNjBxVGxobXoyS2Z3Y3AwSFUySDVHM1FJT1QvSDBDdktjcGRTVGdiYUgwczRMUXlGUEFycGlOaEhROWlwUXJWSE9wbmU2OHM4aWdWRWxvZ2l0WHk3VmxMbDdCUHQzanlwT2llYkNjckd5U2pwVlNMYWtDc3FYOGhhVlNPMitlcmpNaDhLMklXQXZIMjRsRFRrRG5XR0p2eER3c1psL1J1dkVlbm5JRXVrOG1qSjNsaE9jN2NUUWtaampnZTUwY25KMUI1cXVGQStEdmFOTXlLd29iQ0ZLVEVlMnBkY2E0RHVHa0JhalhXWklKWGtVMk5neFNodDVEQ3pad0hxekViZ05raXhtTndXWTNRZnBwQ3paMld0RGFxT0pxRW0xb0kwbUhzamhyY08zcHh0eFpUdGJHL29OZU10UFFISkR5cm9KSEowUzJnZTJkN01jQ2lEdkxtWkMzbHU4TU1BaVozcm1SS0tDUytMWjB0YW9GalkxUU90M0hXRWtVd2hhb1Jxb0dST0dvQ09TK2pXTC8yUU1NQmRPZ3pRNGVJUCtHMnBRL3pEY2NqSEpma2IyZERPMUhtemNtbTUyZmRvbTBOM0p5N01BaHdlNG9lUEpvT2JYZ2QvRUxuWVJiK3I1dHBMVXBhRmJRbWcvWGtmb2FGRU9WZFVKOHVFRWt3VFlmMHY1UGxqUE9SMlRudHBEZFJGRk1GWVNOdldDdVRLTUh5NWRQRUpuYklIdGttQlhkR3BxR1RMaEpIbEQ3bVVpYytPWDBCdit4ZkRjc0tlczZuSDRuUFFic051VHFwNUxnVkF2L3RESng4Q1RvMDJEeG1wUk9pcEh1V05jSXN5bzhmNHYrQnkyVFR4YnpnMmR4N0NRWUo5a3h2YjcvUDV6ZUhqV2lSaW9OQTJ6cElCSEJKQnFVZ3F0YzhyaS9GM0JpcFovV0Q2b0RJUWtIdmNibjZRWC80THdEOStJMmx2TWxKanZES3M4OXJ1UVE5Q0toWXdUL1BkbWhQeXpuc2RabEVCUndKUldJeXNwTElpNHBmMVMydkZMRlB3T1REVmFIMTNqRzczaW1nejJ2YlczUjNzVGlvdlllaEtGanNqSjdtcC95Tjd5UmI1YnpSb2txOEtxdE5GWm83TGNTd01TQ0hOekUzcGVhS0txQ0k1dVFuYTJDZUZVeEJvVWJuYU83UFIzT1FSSWVUYjluV2h1ZE9LL25Wc0tOQVpqbVRxNzIzdko5THAzRmV4QU9TQ2kwVmFrT2JHMWFDTVVtT1JoV0ZockxGMWNjNE4zNWVTcnhGUnIzMXBadjBqT2JzeVBQT0JOTHRpMUp1amlld2l4L3VIK2VUdklMZm5jclBRZFZVTytpOXR4SkxKMEs0ZE81VFIxVlFiTjdPZmlFdzJibzVmMjMvTk1BM0p2TldlZUhVditGZ3pLcGtNV01jbDFhZTI3NjlmV2oza2JrRHE1RDNZdlhtRHNYV2NkL3N2bUdqMUx0clFUR2xCemVLSXJCbmdSV25qVnhZZXY5SnNDUkkveGl1cVNZT0FVZ0NSRXVuMUNoeCtmWTBGNHFCbnd0WGtkcVZKTENvQlZzYW1tN0pxL2gzL0phQjRsblRVcmRKRUVmZzF2YVNMT0hDZkJkQkx0VFlQaEhNZXExTkRZa3k0Y211TUprWlhtYlpoSWg2endDeXgxc3ord0xjYTBWZ0d5emZPZkNJRW1PV2Q2anBXYVFlSE9ML2dpVGRKNU15TlZTdFRaeURHemZJVWpoVHVtN09DS21oclU5OTIrMU5sOVhZcGIzdGlySmVBVjdkamhUVzZvc0hvWWJwUkxSdzJIK0tXMUp2WUR4WnZrR3BiM2xzMm0xUkRrWGJVZmlEOWFDUEEyV2s0K1BNUFFUNGxPbWlDWng3aUFmaEJuUlByQ3RLNHNYQzZrZG5jU01jTk16ZWJzZHVkclp2QVdVSTZlR2pJeHpDMHY0OExSVS9xNENZRVp0SUljdk9OVGgzM3VTMnY1ZVRFc2RDSWo3WkFreVd3SGpuYVRlcndJMkhLSnVmMm9rQnU4dDMwTlRTN2ZOSUlkdWx2ZnZWbGJnOVc0Q2g5QWpFbUNJMFVvTGtHdnNGNm5majZMbDNBaktmYStqNWJ0dW4ydysyY0tESFlMK3FWRXc0ZDd5VmxBVDJ6MUF3RWN4ZTUyOG45WURCNXN2Mzd5b0U4Yk9wSmxjSGNMdWxNUEo3bktaenhoZ29SMGVPTWtINnZId1R5S0lVVFRVSkR4TEFYZzBJQkxSQkdTQWZhV202bmFsdmVEUlp2TnBtbUpVb0d1bkxJRGZrbFJ0MTNoWW4vcmJXdDVKellLZTloWWtDV25ZQmo5SlAwREV1ejBJTU41Sis5QW9tcVhyQXp2WTM5N21DOUgrbG9NNlN0TkdjU3NwSzdhbC9saGx0eUFTdFllTllXR3V4WU8zY0VxZDVldWVSb0hjR3NtQzJQelJTVHJNYXpsQklOL0VVOU5IRENKSU9yNERURUl0ZHJlWG1IZXgrMFhMNEUxQnBkVzIwZEVrT2NXRE9EWGZRdStnTWEvaVNqVEpmMjlsK1NxL1ByZzVuVFJwS0ovTUlianlDbWhQSWpqdUZPc0VQS3FnSkZGbVdCUnF5WGxaa0lYeFd0eEpVSDZRRCtNL3orWmU1WDFocTNxRER6QllQb1pFc0oyZ3RpNzFJZVRaMlh6aTI3UENWclJ2bElPZUF1eGhraktUMlFVODRPZG9Uc2NBSmh1Q1FKOFA5cGM5czJDc0JIMzNnZVE3ZWEwMlNCb3FpUTRHYUhjbmdiNVdacm5lWklESnFHMitoTGdTRXpFR0VPVFYyejdTZ3RRMUdCN2t6N1c4eVIzUzJMOU9BdnlPeklWelZUMmNISXVWdldpZmlmWWxaRU5IM0pZRUxXZHJmV2Q1Ui9vUkF1N2dBNDZXOHg0Y1JhdWpoY1BWeGZ1OEF1cW5LS3lveFV4c0xOOFA3dE9CN0NyMHplOFZybU9IS0dFdDNyOEp3STVrODhYc1E2RGh1Z202aysrTkFJdDJjSmdqY0ZwbHFodk9SUUdYbW9JbDBrYkZJbmVTMWJTV3J5N3h3L2gyNnFoaGZNamQ0dVNONFQ1YzdmczNFWklGUXA2a21Qa2t3dVd3UmlzUnlDQ2dURlFTdW82dklQaGhqaG1wOXZqQnJDenYyU2Z1dWJmbmdiVUcxeS9oZzArV2QvanRCRC9ROXg0bDNQSTJwZ013QzJJWUI5eU1KOWpocjlEUUxvaEFybUk2V2pRRjJUZksreFBwTVJ1Yk54SVA4dTlhMnBCMFR0WWpqVVpLSnh4WTFrMXdOWVRYeThHeDR1ekRKay9RV3E3VzNzT1JzY3V5RTlScnVOUUVYQm9WcUczVExYTjZsVmdPcDBkbTFiTkJCWUlsazRUcUJFa2JkQmxrTDVCZ0NqVDVJQTZ0bDJweHRISE9wTzQxQkdXWW01THRMRlVkbEhKcGtJckNPc2l3bktETTgvVXZKOEhlUTFncnk3Zko2ZXErSk9GZ3RCT1JNUzBQb2tiYWFqalVRZUx4VnkwRXVwUWVTZ3RuVmRDL3BMMWFJNHFHUFJJTERxVXBENHRIR1FsZ0NXRklzN3dibTB4RzNON012WXQ3S1FaT2lBaXFRSE9MVU9ETlYvdWQyUTJ1ZlV5TStWcEpoN1g1dUFiWTRocTh0bndBZXJUNXBQZ1kySHF1dGo1WVRwL0N1UzBPQm1ydHpPeTlkeVl1Q0hlU0dqd3hXM2JwdFJJeFZLTEZUQ1JxMU5DMHNzSDNIS0dWblVDU2tSWVBncXlORmpkQ2g5M2FiN3FNc3JBamZCVGhUa0dDUUdTS0RtNExaNU5FeUJPOE9xZlFtV2Ezd0NXWXFCd0ZHOTRMOERJR3BaWEticlJzN1RXQ1RWWmVveGRWUXRrRnZvTGQ3YUM5ZjR2UTF3R0Ezb3EzN3VXMWp3SGUyeFdTblp2UzdyMUtzQmZhM1FkNzNnUmZDY0Npakp1OU5GR1FjR0lyRG13SW1qbjB6eDdPeTgzQUdxL1RYd09vdkZnK2I3QzVJMnE5cVFvSDBBUXA4Z015cEJwQURFbDM5NWEzakk0Q0VLbFhad3BiRjlMVm13bjFKb0pkaUhkTnNBSU9GaXN4UTQvU2RCSlFmQkNzVnZrVE82bmlhcVF3QlQwSUpXVjR0VUJ2S3RnckJaMHNibW1LaEtQY2c0TWcvR2J4QW5RVjJwdlowdGVrdEZkL25jbm1Sc21vZWtrbjFYU1E3cStWWXFFMlBTZEJwNkp5eXZTV0FuMVRqWDJGQTJ3RUI0M2EzdDFNSEFJbnBLMC9rMzB1L0oybDBKcG1McVhVaTl1VDMxT2dIMWF3Wit6MEVoZEw5VjdYL0tjVzdCVVJ4N3M0bzE5T3NDOFY4aSt4TS9IenF3eGFmMzdkK092LzdGMXJjOXhHa3N4dVlEQkRpaEs5UGp2aTR2Ny9qN3VJM2IyMWJKSHpBTkI5SDRUeVpDZXFNUmcrSk1vbUl4eVdxSGtDMVZWWldWVlo3eGI3L3ZQdUNkNS8zbi9lRGZiOTUvM24zV0RmZjM2MG4vYXRmckMveXFMMnBhK0lWOWg2OTU1MHZSdnFtL3BaMkt6d3R6RHNOMkd3UDRpUlBuZmYvYlhQdjNvZC9GTVBnRjMvSDhIZy8yNFk5amtuSXoveGZUekRhM0JacURHL3RyR3FzL2dSSE1kMzg3QnY2T0lzZWJLMVhqR3NmSDU0UlNPOGV2M3JqNGliMngvTVVKOXp3eS9KZHFueDFvek51dlZQdU56enAvTGt1bmJ4SmExaVZYL2ZPNFo5bTE0MXJEUktnMFdlcEVNcjNxcjJHcXJsek04ZktrYXRCcDZ1L0Y1TDM2ZTJOL0F2NFczZkVvWU5WLzY3S3VEdzhrWHJzZWRKT2QxUDZMMGZieEVlS2poU3NhZE9nN0Q4VVUxREtqaUhaVzJFOERRSGMrVzdOUy9sYU40S2hQdG1IbmFoamY2NVJ1N04xK2FWNzhHcUlleWxlSXVkN3VUbDJRV2J0anpLYTdKM1R2QjF6Slk2STdjRU9aWWdTbkE4ZTE3cHFKNE1INzZueDQzZndsQ2ZZS3d0NmpKZzNxNGhGdnFzQ1dQeTBHUXJyOE1MN1Zpc3lZenJnNE5QVFNtQUIza0M2bHFVRFJramoyRUFjeldDbzJPQUdaY2xKZklGNXNHVDE2MnRrUWkxcVBjOVBlNnJlZGdMWDhnVG4vTENiMXlnZHhyNEU2OHNOZ1h4bEtxZnhQK3VucHFYQzNvamQ2d3FDNEVBTmlPcEdOYVVGK0RnNkZIZ2hIMUhGaHBnWWRWY1NSVDVkVCtnRkdqRmdwZitJYnp0dDVvL1d0UFRYaE1IMTZuazVJUnBEd0pzQkl0YUVtU0xjWGdMbkNrQ21ZNkt5WG1ZVUlJTmx5VjZ2bWtEUHFMYzhHT0hZTVRYWlExZjZIZXNuODJzQTA5Z3M1NDFlMXBXZVdzY0dNS0hEL0ExQXA0RkJkNkM4YjY0d1Q0aFZIakdyTHJlcXZHdGtpbURRQUwyVE96Rkc1UzZMdXpkVlcyT2xaSllkOGJUZDJTWkFCYXREUGlxMVBRRjVjWm4zaWFWTUo4QVNvNzNUT0xWZWVrYmUzQVZhdVB2dEVPNTNDMklNeGllaTNGZjIyampTeHJxU21QVkIzWE9ZMWhYVW9jVFZaaHVGT3pKSG9VVlUvbTlkZCtrTFdIbVBYR01hM2wwVjdkVGI4Um90b0puMlZ2Zm85U1owTFdOWmlpMnpkREVuTFlvUmFCNElqWTRUTUdJVWljam9oUWFZY3h0eHNzVVhub3FtL1BhMlBhbFo3MlhUbWF0b3FTSkV4dWxTcSt6TjlxZzFFWG1wVldtempXZ25MbzFEOFBMQnJKNEYvNnpLUnpvU3MwazcyZmVYSmNROUJLdVRWaXdSN242WjRkU3NQdUUrZnA1eHNSUjJBeFZGQjlRQ20rclVBR3JRQ3l0OG5oejhDQytzRmRkT3BsNWdmL2s1M3VjWnF4ZzFTamNLNnVrSFZBcW0vT1NoaHVVQWpJTmVUUzdvYWFGZlQ4OTloNW5QUlZlcjdlaHozS0hVa3lYbFN4Yk1kUzd5WUJOMy9WWCtvd3M1dGdJemFicXlPeFJkL1RjaExuT3RhNlMxdXNUOFVMRmh0ZGlFcDdsWWNQWFQ3UzIxcTRaOWxqQlVJcS92R3pmK00vQklkRS80YXdKeXl0Y0RQY05ZbVM4MWZrTHpnSS9OeWpscGprWk11L0xIcFMzZnc3RUNOaWZXVkgvaEhLN3RDVlV1dkxLd3Y4ZTgyWEovQjZiNlRFZHlsVzM3QVJhb3VBOEZWVnZzU2J3eHFwbEx5RllkQ21aaXZEbEJiWW94WVY0MDUvdStHbFJMbXIyTnF4dUhjcUlOWUszRXQ3WmN3Rm5BZEFING1uTis1b0JNNDFsbVRxckFaNHczLzNMbGFsQmNQTnArbnkyQm0wLy9hZVF5RHo1YjhUakhoeSs5eWlIODBSTWg4bzhlSW1YdDZZblhvaWVYbW5ZcGNwZXdtampDeHRydU1EeGJlUm1aZkZFUFQzT2pHVXIzb2FUankxSytWeGJRVEdnckVLWlI3MmYvdjlSR0lKQWg2YWQ2Q2c3TEN6K1o4bVpQZWVXREpoWHk5OVBSdGJSOStna1VXS0ZjS1BIaHVtOXUrbDlQdUs4OGZkM2dpSU52V2FnNzh3ZVBsQmlHdW52S2xYRWNFRjNWb1ZLTVNZczhMclpZVGxlRENZOFY4UVFGNGorcGJYeXdVa3FWT0FRUkNXeDhHeFBvWHlMc3pBWEc1MnE5ZHJySGlqelp0NnlKK1A2UEJuTGZqSytuZ3lMaldJakZOYmpaTENqM096SHlmQ094RmljVURiSUdEdnd4MlNzRDVTb1dXSjFtRDVQd2xuc3RxWFgzZFBCSGxDcXp2OGZYVmVtNEhURlZIU2cyV3FSbmRlR0NFK1JNOFhLMEFESlZMMHN0WFVTdGtZeVd6NzFueWc4R3kvNkNlVmVBNjFDR1pZMWRjOHRoYzhOSFJZTHN6OVAzaXdScTlDaDFLdGxydmdrUllOTW41MHJhQjl3WGdQUVNvSERoTjA3TW5wZXlubEwzMlZFcWNiY0VveEp3Z1VQS0tXMU9Qa0VTclZvcnk4Qm1PK0ZySFdkZVY0NHZiVFJQbGQvdDFhUkNoSnlvNE9mZ3NPZGNuTUprK0ViOFF4SCt2MHQzWUFnSHEvQmZMZWtydFk5a0tjS1RsV3BsVXBYRUJJL0NLVm4ycFZibEF1ZytYbTlITnFCM284cHJoUEtsZUlzN0d5WWU0L3o2b2draHNoN2ltenpxeTJ5YWh6cWo1UGY0RkNMSnljUmhzTUY1OWZ5dEdzbHpqMHZ1clFrTkR2R0NNSnhGbjQ1dEFkS2pCb0taVkdTbTBURmdHRUt0ZWFGOWtMV3N3SmlrQUlBOXhzbzI5QUtwalBQMXhDWmY4Sjh4NGR5bkxyVWFvTnltMitXVW5CUEJ6T1NsK1hTTHJNanR2ZUVTOHkyelRHUjhUTVhQQkFyc25mS3czdWh5elRmYVIwajkzcHhWek1NTHlyRXZUTEJVbnlxNFVNRnVSa21NTjdxeU9nNnVwbDJzVDZnM0tqTE92NTJNMjZFem1FajRYMnB3SHpkWFNMdnlqeHdqVmNPRG45c2ErdzFXUVI1dlphOFp5WXZ5UWZuUUY1eFI3enlLSS9MNHEzN0NTTFl0V09ON2tUZVdhTWdsNVNqdkU5TENYRndTdWExSnFVWEgyVmZ1MDhHQzhicHdZUG9oQllPc2ExNHVNYnhQR3lVZWZLa25PejhRYkNBS2JLV1dBSU8vYXlJSENUWmFwd3k4VWhKVDBiWnZCSXgxN1RkQ0w1VXlEUFM1eGpraG80Q00wWTVVQzBabFRYZEtHNjFhMkFZK0lDdjI2Ri93cmxqeTNLR3ZSeGcvaHpNNDdMNi85NXhSclZDdzhVOWtrODEybXNXSUdYblZNTHhvcjJEUzNtVkRJZkpsa0wvUUxUWFZoSUgwenkzeCs0QS9ITktrRGhjTlE2cEg0V1ZhT0N2QVlNVUVsampONHUzalJYTUZ1UTkrVEVKODgwcm8wTXY2bGlPdDVkSTE0dHRpRG1JVkVRd2VmT0RRQW03aHc4Q1k1THpuWHY2VEMzS1JYNktaWmRtNFY3UFlDc0psb2IwSlk1TzE1K1BSTlZrS2dhTVVwZlA1SVUyY2xPNVJzOUxVWmt2M1pGbjVhMjQwVW5FUnVFMFBlSTd3Vi9qenNZVm5TdzdZTjRzelZzZWRMK0k5Mis5R09wQTN6TUtwaDBwSitDazFJenFDOHFkZ0xjb3R3QW5naktjSUxZU1NieEY0RnFWNUg0UHIzZjNXWnNsTGhtczk5TmkzaExIZTZXNGVRTkNtdXZOTisvNWhUQWNkLzVIb1oyT1JOanp0clVQa2lpTWdpRjFSS1dWRUJnckJ4UlNRbzN5K0NnZXB4VzR3QWN5U3BRWnhRTXpaSUxEZ2ZhQ2Z3Y3hxQ0JKNEgrbWZ6ZjhhN3RsdnhEMEdRZ3JZK0tlZVNINmthN0hqanc0TUY5L290MWljUGoycFlITXB4bnNpa21CMnVRbW4zcGVrVHBRQnFxcm5PNEljM0ZaOFU0NHdnN2xDc0FlNXdVL3grbnhpWXpSeVBRYmxMMnZXWkkxblVSSUJBVWFZak1nUlFidXhQSTJmWTVVcE5oaDNsaVM1TEEwNUJtOXhoWHQ0UjNrWm85VVFHbUYva29vMXhrbWxCTU1CL3JjcDhrWjlBNDl4clJXRnA1YktUNXZ1ZHlMd0lLbGZiNFo2OVlMV0paK0F2QmZVNzJiTTFjbDhwbk9zai9mVGMrL3gzblRhVWQwVXB3S0JJMFE4eHZ5SEx5NGd6MkllbXIxWmxrK20zS3Q3RG5ZZzlyTk8xS2ZnVGFSWjhISlVUQXNlK2hSREpDcllsSDQwMEZLcmt3VkRrTFZSVXJHRXBXMFAxTkVITWxJZTRxS0IvS2dVYmhlanE1WmlpYk12ZU1sS2E2YXdRTExNL0JNZFdUeWdseVQzaElrMkUvaGhoTUg3dis4SWZxS0RRL1RpVS9TZU5LaTNFdkhtTFBEZktFclY2aThaSkJoUUpUL2t2Q2VkbE43d2NDdGVFUk96Skt3SWlmTXU5SkdCK3ZxNHRqUlNlTDRNR2gzMkVDc0FEZnk3S25BMFVoRmNLVEViVU1SOG02cUFHNVE3dXNMd3J0bjFPZm9ucjNIYjhsZ1VmR29PZ1hLNzlDaEhMUzdJeStKNlV0MnhBb3c0ZDFTMk51UmR6R09jaVBQc2EzQU41S3R0cGdQR0VJOFdwWWJ5aXhHUjg4NUVTUUlUdlRSN0RnNjNPd285Qng3ZnQ1NDNEcTlCVm85VEpJRVplRk5lWlNIazdJdkV0Rk9CRm00Ny9aeHV0NC9UYy8vamZvS0J1TENIK1J3Wm9KM1BETFV3MjlaZkJKK0xReDJZU095Y200OE05OUlXR0VQd1lvb081U0RjRnZDVER2aExRK1ROeDZvL0xnVkhCeWRzTjNKQ1dhU1hyMGZuRU8ySjR5c0pIK1VROHFZdHdiNlBXeWJoTWR0Q0ZNR2dRaVpEcmpIWG95T0J6ZHNIeWg1WXVxTUU2UUI1VVJ3eExrajdEREJ1MytTaDdjdXRRZktIYmljcmx3eWYrZDhBUnFFdkxKeXdBYkwzblNEK1pDZTU5SWpHZFBvUFBZbmFlYXc1cFZtK3JjREhRQnVEenhTVWpWUytPOEVGL08wYVlRL1B1N1Z4QnM1VkNNVkh1N0VHMnIvUWEzYUJmS2VEZWE3TDJ0Q0dGbENzWDZITENTK0hjYVRHQzBjcUpDZHhDMFNwOTFPZis0RlNpV1UzV1FuZ21xZkpjbm0xKzNsUUhyak9XNVI0YXBLbCt4elE0Vis4SDVVRU1JKy9DYzVyYTBrSHo5aDNrMWxCOFhhOEhpWWowTnpRL0NCdzd1MThFWEo5cTNQdGhXUDJXSSsxOVJLUW9SS2dlU2E3cVZVOGJ6WnFRcnhKRVp5cWw5WnVGNDliQTNtclkwanNRRTdsUDJxZnhDN0FFcTh1S0grUkt6UGtSSzBJOEdKdlhNZ2RjYk15NHYrak9CckRiWjFQSVpudEZrNm1yanlvV1J5cEMvd1NCZlgydXNhT3FuR0UxcUxIUEMxYjdPai9nQlFmNEFtSzR4OWJ4d3YxUXQrakVKcGFWK0MxenVRSFM5YlMwUUJmOHNsSkFueFFtTjJQR3FTSkZHOWVPdFFhNjFUSld0UmpzS01kQzhhNnVGZ09NRlRIdVpsZTRJVlRFVWFVOFJVSHgraTFtbWtTVThwMzdLSDVhbE1EVnRhUnVUTWUwT2hteStBRGROOW5INjNtNHkwa2ZERE5YeXVjZzBvV3dvM0F1Z2JwOFRaT2VGTnhUV0NRK1NyekZEQU92SGpYR2tHU2d1UmFVUmRYWkdaZ0JIbDR1S3hVaEllbldJRHY5ZEJJZ1B6cVE5RVgyM28vOWFRdzhXVjN5ZW5NNUxIMUxiT0ErYjZEUXdOYXRkdU5TVFFVMXNyRWlTSFdrblNKTUtqMVhaU1AxSlNjWlRrWlMrVm1vRnUwa2gwRjZ1eVFON0gwMlhkT0pXb1NNbmJWakpqTlU0VnJ3aE91Vld2a2RjVW9nWjd4SHpPeTJObFdvb2FuVlBraUk2M1BwS0Q0SVhUSi9Hd1FRN0VMZDJQUUY1MVE0ZmVDamIzT0t2WThEd2J6NUIxOHY3czdDTG1ZMGxYLzNnWU5rdjQ4RlJJV3ZuUUgrbGlNWDc4RmNDL3lMTnhadm9yL0U0dnJpelpSSUVhQW9jWlZXZUptTXRTUnNmRHd1Rm1SNEZKMTZnQ2VvVVZWTUorck1BSDcvVVM1cUlpbzFTeEF1YmpQcU56NzVpRmFJaTNiWVJiTmloeEpHTTdFWFRnU1lza0RxMnZsR085ZWEvMDNLUXJMM2ppNEZTK0dzR05sdWsvQVBobHFtZmZFdjY4b1JQZUNWM1ZUNDg5RVdibGloWWJKWGNLNmU5Wk02dHp1ckVpNnRNSWVBWU1XQ3BuZXdrYUxoeUc3Q1JwaW05Wi9FUHpDcDQ0R0tYNnRrZlprbWxKcmpFeEo1eEhpQVlLL1h1VVVrakdXejhJU3hEazh6Ynd4YUgvL1AxVElJR09ycWppU2dOL1JvYy9sSlVvLzN2Q1BNWnIva0pKMUdiQ1FsdjYwa2N5cms5aXFCdVUrZ0thREdVeGJ2WmVQWHpOLzdCZ1VMa1M3bXN3SUZ4cHFHSEJZRDBaVEsyOGVSQWxFaVhJOTIyUWpIeEQ4RWpsbUU3U3VIU2tQMGZLRys1UWpqRjluajczSjhIU2paT3NkbklQLzhUejRldlAxUjQyT0JjNEx0eU1JUFNGNFNBN2RTMUs3YWxQRXc0eWdIOUxGNEs3M1kwMXVKSER3NTMxMmVGTCtYQnQ1UEF0M2ZDd0FsdGRHdnRJRjY3VnBXNzhKWGlRSklTbWluRnp5TzNsdVZrNFVXNXc0ZWFibHFncjdrc1lwZkNRcFJLNXAwaVpIQWhRNC9JN1NnSXZlbHBQUUEwTy90TXluSkxkbVpJalRFWjVoL05RblgzNVBSbXhHZURqNUkzL016MzNrVTUxTDNpMWRZejEzM1RhazNDdGpYUG8rUE0vT2xCblhFaW04c3ByNmVGV09CV3JtZ0N4T2dRdmlXdWNRNWlJenRLa2NjUmNTSTQ5blpYRUlZV2NVVHhrb3NKRnhsbTRia3ZZVjBWS2FodzJOK2tBUUx6a1pkbkR3bWxrYUIxNkpVdm1QWWlobkFnYWFOZVVaWkpHZTkxT3Y3dVhjcXZwQnZ4R2pFT2s1S0IxTGpyclpFV252SnpreHUza0FvWUZYblZOaFFzWEdqdEN4WnQ2U1Zad0VyUS9xRHpxSGFJUnBSWURRNHlHakpqN2loazZKWEZLMXZ1UmhQei9UTGxJb3Q0RTFqTFFLUWsrWEwwNGgzcXk0UFZxVHdaYmt6bFhyTWdFTUlmb0QwUTdRZWlsWDZhTG5RbGpuZWdFbXNjMS9HTXFLTGRFYngzcE1WeUhQNUNSQW5QZEFEdEF0NWlMekNrdTlMQ3RoaS83WEpmZ1FWaVpvT1dGNmlLa0FVZjdXeUdHR3FTbXI1TWZKNVNTU2NvcVpFbGNUNVNnRFJKVnRRei9RUGgwNzBDV2hIcHZiTGgwRGRod1l3Vlg4QnZ5c0JxMzhBMzBJVTlTMWVBdStRYzYrWGF5TFFIN2lISTZOdU04WE5oUlQ4TVdaZGRVcGpBRWgwTGhtcnMyeFRRT1E3QldOK3Ayd1VQV1lFQ05jLzFOUEZmdEFHems5Ykxjb3lCaGYwUTV5TWhzUXBaL1k0WmxTM0NvbDJhWlJzcmptV2l3bmo0anErTm9zdWpSaUdFbDNLcENBc0NmeFdtbEFRUHk1eWlaL1AzMFpmZmthVnVxUW5Ya1BadkpFQjZJSnVrb0FiZ2hqenc2cGI2TmM3aFk1Y1NiRTRzTEJZT3dJcnhmNG1Fdnlmb2t6T1ZEc1pDQXFlRHdnSEt5dFJIK1dBMlRzL3BSakpuMWNRY3l4aE1aYXB3Y3ljOVR6c0NkZUE5VHZ0S2puRWlBRXcyNE1VWkh4NnNSeS9Pd2V0TzhzT050OStQeUtuZnovNDZ5UHpPU3NkcWdJTGZ0blNaWXdUd2hLMWdud1dVSnBiaFpRam1NMThsTlRndFUweExPVEZjWTY5TGZRNFhYOWpyQmF2UDlzUUl6bUlscEhKNTVGTXc0T0FkaFFObGdFNXllZ0MzbEhVa1NzUWVVQ2pvSjlVSEZ0Q0t5VkRPdjFnbXpjTmdCOW1oYnFXRjdPcTg5MFJVOXZuWm44Y25sWHROUmNGcWtwT2dvSWNpYm4rL2xocDZFczlXWnFZMERDWUxqR2RiMkUxeEt0UEtGd29GSDkyaHBXRDBzT3dEdFlXQWo2K0VyTkdweitZQjVoMW9uSHBIVnkxbmlTYlhDVG5MZDllQjdIVzY2SnpkZk10aThjTlBZV0JveElsWmRVUm9saXRkbHdRZW1XR3lJRUhJUjk1Uzg2UUZpdk9UeGZjcDJjRmQvSTltc1hseWREbGhyc0V1ZU4xOG85V1pjSGtuU3o3U1RlNlVKbWJFNDJjR3lFQ1Bqd2Nrak9aQ2VQT2FCSXF0ZCs1TkF5S044QjlYNjlaYXFYQlhOUEphQThhZ1ozVjZBOGthTWVDUkQzQXFUd0tWVVZwRTJRN3doL01RbDFVUi81ckZ0bFlka2VVMU91TGhmZ0xsSkhZUFIwWllHdm5iWXRSNjNabnk1UW8ydEdTVko0bW1EdzRkejV0OWpMcWpNMHdhczBmdEFsYTVtU2dvM2xIeUJITllnOUJVWEtWck1weUpVWU9YUzk2OWlXRTI2VkxpaWNieFhoM0ltWHB0U21FMjRwN3IwRGZVTDJHdG9qNnlGbmtmaFN1RndxNk9FZnZWRzQ0V0VrYmNQYXErRTBsM1hHdXhhMkJDY0JDVldQTFErVHBtY0JIOGJqQTVUOHVpOWVtZHVnckhrcnNkNWlQUUxHYVVkZ0JQS3hTZ0h4eEFIWVc2dW9RTUxnMjJkRXFEWFFNRmVacERUeEpqVVJIbXQ3TXA0Y2lES0JGUnBpa0phZ3dvUDNzM040ckZIaHdaSzhQVzVra01ScWJFSDRUZFZ2Z2lWUkNrc2xHbkRDcWlnNm9jS2I1SjRybEVpREcrMzRTbmpUQkdNMVdTeVpPbjg3eDd0Wi9CZ29LakxjbElHdTI1UXpwaHBhNnAzVDZPVDZLK210YkNBdDFSYmF5Tkd6aWZvams2ZlhVemJoZlVGNXdhWTMzRWVpMm1weWhYRlc3ZGs1UGVPVjk5alBwZTB3Vnp2U2czUDJ5YkRScUtEbUMyV0cxaHdnUlJmQ3YvZTRjd28yemE5SkxrUmcwN3dKVC9aMEZuZEphSWM3VTVDVXhrYjhHK1VDdC9Xb1A4WlpTTi9sQW9vTUJjSHhCbzRjQWtTTElXeU93clZJL3haS08xSHNOUGFFYTdpeXRROWZVbkRzM3VVeTlSNFU4dEhuQVhNV3N3VnZoUGg3dEdwbzJ1RGQ1QnlZZWRnYlU0ZTdMa1AwMmRIaGN0ZFlnb0M2dHRhVkM4TERnelFpWVVqNWtMUVRFYzJtQTg3MmpVOUV1Y2R5RUFEbGNWQlBSODlRYjJCc0cxR09hakkyRFpXb3M3cVRZdVhETFkyS3VOdEUvRndaYUJUK21uNlVuWkJmc1paNnRFNjhIZVR0MjBGd0FjcDJmS3FuNDZLQ2JwQ1U5VklObUlzZk9KNTlxdWhKSytCUDRTcDVkeTg0cUJ6Y3ZnRjU0VWdXbjdOQVA0WHdQOWdQdGpKSGpKaDNsSVpuT2N3ZG1TdmV4SnZ6OU8zZzVNa2pUanJQM0RqQ3dSV01Eems4YVVlMTNXbXpRNTZ6V0REUWxhcml0R2pjR2Zzc1RvaTlYOG42c3N5MEk2OHdwRnE4OXl2OEJIbkRpL3o3QjlRcWtkejhXQWs3eDJGNmZER01xSlRtZ3lPSWZDU2orQlVwOVNqamc1ZENQZ2p6a3F1SnlkaHpPSThzbFN2R3VmMU1sMFRidkR1cGRKMXdueFUrNUc4TnI5Zkx3ekswZkhvaGw4ZjVUdG8yWndOdHJuVUFITXRKS2d0Mm1CTXlaN1pMdGd0MFNPTjhLQWJBdTRmS0pRY2llTGFvbHdBOXdubmVmb05VVnlxWmgwVy92TkFmdWY4WGpsTHh0T040NTI5dHNLeEFwMGFDZjhKdnNKTEZxTk5GZGFHNzBuR2ZEbEpTOWVYRDI0U2JqeVJFWTRVN2pzSjdjWVkyR3pjWGtxNFFYb0dCckVmN3BkZHhhVE14QW9kNVplbGJwb0c4MDB0V3Nvemh1SGo5TisveUtCUGt0VUdNWEExb280TTF5Z1Rsb1R2cU9yU0NRemdwV3k5c0I4dDZtMTZqZkRIbW14dEZnNTJVNm5qODN0R3h5QTk4ZVBzNEQzdUlXWE15K1Z6MXYvaTF6MUtqc0VHMjZNVTZMTVZTM2RURDBHUGVVdm9BZk5tYmRDMU9tRlpuK0hGRFBhU2QyVkJ0eXhoTEtOY1dzemgxcW9qTzZGRHpJQnY2Y0taVnV3blloR1lqV0RKelNQS0RkdXQ0MkYyOEtYb3RkOEJVcUZqM3BMN0g2TFR3d0NoaElDeWU0cU5Ic0lBNkJKb05rcHZWNWEzbnlBS09aK0VEV2pFaUVaS3BuWUNCWUQ1eEVGMDZMNGVaN1YwWHJTaTFLRnFRS1JyWU1CYWd3WHFhemVEZzhsMElIRjB2S1JLcEhOR3p0SkRnWjRUcFZKekt4NndKKzhheENoYVNUd2ErRXM1QXVaajFDUEtwdVF0eWsyT0txV3BrU2c3MUpoZVQ2NzdKekljYlVUSkR0Mm1PeUdTZU5vc2htWkpIME15TTNEZEUyWmMrQUdsZm15bWlGYXIzSTBWQ25RVnovcGM5Y0lheWV2eGY4cDNLdkQyMXNNSDR2UHVNTmRtRGNJZXRPUTVPekhFbm5vTDRIaTBnRkpMTmd2dXRSRG9yWjZNVXN0dks0MURMQ2l5clJSZVBQbkpVWG91Z1BreUUyMkE5cWk1VWJod3JtcngzM3Nwb1ZzU3hwTWh2ZE9jY2hBUHlhSGZtM1NJampmTjF4cnBVdzNXTTk1UThjaXNxYlNUQ3N3Z0hsRTd2eUlsVmx6U1pUbWRTSjdDTkxWMlFuK1pWSHFEK1RUbmhrSmRrUGZXZ2NUc05JczBVdlpsejhLaktCRnpiUVR2Qm5yOXNVeGpzZkhxaEVRU0tqQ2duQmJtSG9vVC9OWlI0RHpmeGhQTWUvcmNOeE9lMVhWU0tqc2FNUjlOQjN6SitPY3ZsbHVoVWFESkZ1QzNpRVhNWmVUNXhpY0gwM0Yzdllub3NvSmhJcTd2STRYcFBYbGR4bFdkR0dvV3ZOc0lsd25NTldTakUvcTU1T2tWUkx3QlE1M3dWUjNaUnNyT3VqS1UrMGlEVkwrMHF0VkxodDVMeWJhWCs3YW42N2lUZmdJeitwK21TbGNRRDVxZHhNcFRMY3hML09xVERYWWxOS2lWR01OQ1NWZlZ0VGZDNzdHb2I0TzVucFlWR1RqOFd4ZlpCOEpsTFRYWkdGV3pGWkplK1ZXdjZ3dVNzYmNDYjZLRE5SdW5XcVd2RVoxa2lqM3hxVUp2ZVdQZFdnMnp2eDhvZDJEajVvVWVBOEVYMjhDVEpUR3pRMzlBMmQyVk1OK3A1dlc4Tmt2WTljVjN6VjdnWjVmNk5udkp4cG1iakhJQ2VkZHFSMWkxcFdwWVM0WnRudFM2Z3g3cGRlL0lJN1FVeWpqVGJURVhvdk9pZ29adDFaUk5ZbkRKQ2Y5YWpHZ3duOEh5T05xUitFMVVuTU5ZNFdCMTFhY1oycDQ4YllkeVI1ZHVUaitTcytCSmdpaUhJRmNxZXhkWGVMN3FOdStGWlIxWVNDWUN5djJwM1BCOUpDL1ZvMXd6MlpDbjVNNTVvN0QrZ2JPMGpsYTNlbUVER3FxTW1kSHM2SFU3elBmRGR1SWRBMkhwTEdFWjBqQ0RDaFVJd2FpNkxsT1RXZTdLNG42S1htQVgwMHRhTWVNT0xLMlk2ZFRyUVpLOVVaZ1FqNjBJcUd2ZFZtSGxVdzMxS29OOVFsSUdKMHZVVStlVk9wTlFVbHhzNk9SbW1qVFBINFJsbVVyYW9Xejh2cHR1alBiRXFuZFQzVlZPSUJ1VTQrNDgwcVBodVFhYjRzSk4xdEN1YzFqTXBZNzBkd3YxVEIwZWlmdm1paGJEQXZieWFxQmF0RWlWKzdza0g0cnZhckFWdzExYWlZUktvd3djTGpjNDlBaG43NGFIZnNKWDBlTTc4bng3S3V0MmxlTEFScUJDS3dtTjZTczhFZ3VoQTNYQjZhbUlsZEpwZy9sMnhPd2tyTXdVY0huN1FBZEhhL21qUUF6dU5SN0VrTmlBR3puMFFReTNreDZEN0NSU2NPNTNjNGxuZmE2aFBzdGdKNk85dEZOVXR3Y09sU3Bha1BKblQ1NzFSaElYQ1BuZmsxRnZwQ29GbE9MSWg2bHladG4zUnBvNGR2UjVOcEo4cUlBeXExTnpTWG9RSm1SRTJXNm40ejFNNXlVbklSdnBNU3dpekovUE15N3VxbUk5aHhPOVhoQzJnRmNjUlNjcFZEaTBlcC9zU3hucnN3eDJaV0syQkJXeWs1RnJ4MzhqWGtWNXowWWFhampjM3FEc2VHZWRMVFpxTGlsRFhvK3JTWllJSGxCT2tuSUkxOG5UQWFYZ3grQWtiVnpxNW9OdDJmdm9jTmJzMVk4bys0QlpXOENES0lOalpFbmVXeHZBR3ptTUkvQ3lhK1cvbWNHdXBNRnErQ1k0V1htZ0MzU0RVZ2VLV1FlZUFYc1FublZQajlzSzViUkJLYU8rdzd5SnZKZkQwamlsMmc3bEx0bk84YnBKUG5keWt0SkVpUkd6Qm9Na1pDM21jMWtkSlV3UjVmZzFMek5KUXN0NVlzaHdRbnhheVBqamMzb0N2cXZCWGpEY0pWV1A2RFJKS0FiMitoa0NKVjVac3Zvb1JReWJYaGdxbmdpVW1CaFBhKzk3UTJWYmxtSGFFVk54d255MFJ1VjlyRFd5RTAvSGplTVFiTW84OUltWUZNYjFMVW9GUnZhZ28vTzVnSG5qMG9pNjlpOHczNHVXTHpCR3IyS29yMkt3VDJBVWFsOWFKMWE5YmRXY1ZHd2s4ejhKSlBDeTlDMkY4NDFnNVpaK0Z5VnBNUVBtYmVFN3FyVnZwRkttSlVyUWE3VDBYUStZS3pJZWhmOXNDUUlZQm9kQUhsVjY4VHhwQzc4aHhhTW1seExwYitKVnY0bkJMbkM0bnNIcWZpa0YvZnhjdnFIL21NcUZHNkZuSXVhZFpMcW1uWFVQdExubVNBa2ZkMnNsU2xadU1HOFAxSEhyTFRFWWpaUk9nWEt0UEt1eThQQ2ZIcG9ONXFNN3ZiQWR5YW5wSzQ4S3AwcVpGNUppZkc5ai9TWUd1OEx6MWhwcDRCRHRrS3k2eFh5dXlmTVVHNGVhaVU3Q2N4S0Q0SzJKUFZFL2xpbmJaa2ZlMjlCUW1maEF4WXFUWXd4Y3F1NmxmQXVVaXkrNE9yWkZ1U1VtVTRuNktNa1Q0UGZTTG1ra1JGeWhLUGd0YmVpYkcrd1ZtQmR5azdpVEhaVkswbGpCV0IzbStxcWMwSGpyNXMycjJ2Z3pGd2gwamw1eHRqSVN1dUZ3Y0R4bEw4eEZ4THlKdTVHUUQ4d1hYSGl6VXNFcHpxVG4zci92WVR2ZjFXQlg0dDIyUXNVczhiK0JPTjBzZEZoMnVFZkd0MXdRdUtFczNCUG1HTWg3ZmlCR0k2UHNIelVKMFVmQzJGeTFDbEtseWc3RE1HSmVDdldxaW5tQm1ibUtQMzByUnZybURQYUpWTmtTdnZMV0FIbU4wMUU4NFJLdURrTCttOUZ4djRTM2d5cVMwWjZJWWRCMVVRUEJnOUhoUEdzaUdoNW1mYkpCdmpVRC9XRU05cGtGaTd5U0IyNHduMG8xMktGaDE3RGxFV1ZqRCtOaW5jcGxmTmtSamVVSllxZ0lTYzJUY3ZTb2ZTK3NNTnlMQTM5djhyNy9xQWI3VEVPUEZRS2NWUmwxckNVNU1LSjJLRFRSOFdSNnRFUHJVbGhIQlh1K0NicnAzV0RmaG1IWCtHRU4vYnhqVFBjSDFJd3NYV0JHUW9VUFhXV3NmOVg3K202dzF4dHl6WGlpazZGN2lpOUxsTjYxWWYxdllhVHZCdnZ0RWtQMXJyV1M4eVZqclJydzN3N1N2UnZzTnpQZzFjblAzd1dQdmh2cys4OWYvaWUrWDRMM254L3A1Ly9aTy9mbXVKRmN5eU9UWkQwa1AzcG1iK3grLzIrM2NXUG5UbmZia3FxS2o5dy9tam42NVNHU3haSmxXOTJ0aW5EWWx1ckJTaUtSQndjSHdMdUhmWCs4ZTlmM3gvdmozVmpmSCsvRyt2NTRmN3diNi92ai9mRnVyTytQZDJOOWY3dy8zbzMxL2ZIKytMWkgrMVl2N0FWOXVuNzZKZHMzaXFITi9yNHAxVTBML0JZWDUwOW9xTi8xOFc3QWI5UlkzdzMxM1dqL0ZNYjZicWpmWnNnaGhMKzBRY2UvdWFHKzVkM1J2R1Q5UWdqLytmTlhjd0x0MzlSSS8rT1FiZ2lVWWtwcFdwbE50cm1KeE05WVcrKzZPWUwxdlpqd3ozSDBiNDNpYTEzM3dsc3owcjhxSm81L00wTU5HN3hyN2FLbXl1L1RDK0JGZkl0dzVLM0RoZmduWFppWHZqaHRlRjh0a1E0dldOTjA1ZlUwL0syZU9Yd3JydjJ6RzJ6OGsrN2c5RXBHM2xSK2wxWSs2OXBuVDFjZ1F0andYbUhsdWZ6WktQZnlMMDJuL04zU3JkclVZcFRmcVZlTlY3eHNXUGszbS8xNm8wbTlmZ0Y2bmVtR2pab3FCdjJYOGE0LzNGaC8wdkVmVm03czJycDRYYUwzdHB6Y3A2OEx6bEgvbWtGWjJMZ3AvMUtQSDhvRy9PQWRxMGZvMWlZVDRZb0JOSExjcHdybWZVbUhQMjhEcEN1dis2NXN4RnRpQ1A0cU1NRERvc0U1VWowUEY4d2ZaN2syNHBLZXVhMFltdWQ5MStDQVhtdmF5RFI0dlcvZk1lc1BOcmlYUEZvcisvR3pDYkRYRmpOVnNHcXlKYWZLZWJFMElvNHd5amcxVm9JaTliRFRGUzhiTm15NmFRTUVlUEhhdmlYOCtzT01kV1Bua2xzWDEyc3B5Zm13T3FCWFBhbU8rR3hzT2VZOVZhSjgvazE4eXRHYzRZb2h4ZzI0azhiWmlBR0hGUWdSN2VXdGloYjM3aTBZYlh3amhxckdrRmF1YncxVDVyNm9rOVZibHFzbjFhRzlvMk1ZT2tZeWUzSE9qZDNic3VlL0dwRk80YVlYYnE4YzVYcGltTU0reEJVdkczN1FmZnh6Ryt0R2tCNnVHSER0Qm1pQW9XTWhnM1BrMDZoMnR1eHNIY1FBOHI5Yk1mSURQT2lUWEZjcnhyMXpBajdQNnpWaWVEV3UxbXY2VmpzSmFwajlaa2oyTXczMlI0NGp1aFcvYnAwdk8xVTJZRzRLM012TjRrQmZ6aVZRTVFvSHQzR2tKNGQzak9aem05cEUyUHNNY3J4NVlveGk2TFVFQXFITDlDTXBxNS9GRU1RM2FLZzhFcjBJMzV0U29nRkgvdmxGYm54K3pRN2VLMVdDSVk2bXp4TU4yZktkODF1NWFmSUVtRTRNTTNmR3B1RnltbUtRejZUSDlJWVp4eFZvRUp4MWlSdllCTElnOGExNTErL3FXVmZHREtXTm5qVGFjcHk2VmJDdEZ3Q2x5bXNWZ3lwTzFSRkQyZmp5VEtyR2xsTmlyT0xCZFVpSGV2QW9SN2ZIQU9RNUNGNXlReUZQemROYkpSaExmeFlQRzMraVZ3ME9MV1FyQWNxMGNreE9GVU52bkNCRVBYVkNzQlRNbng5N3NlZUJiUW9qam1KY0I3eTJzM0pLZGVOOEQ4N3k2b0M3R2RIMzRvRTkrczN6bUsxNFlUWHlQMVhBOVYwOGE2VlAvelhEalJ0NFI4OGcweFZheWFOK2V2bVpGNHlwVVhBdUxJL3p2RmthZWUyRVRYQ3g1ZUNMU1RiT2lNL0pzN1g0SFRtYXFEWlpVRStrdFVtUDE2Wml2N21oRy9FN2V0UjB3K2ZYaHVYU2sreHNtVlZLZ3Y5NFkvWldWeTlGZUI1U1Qzdm45MlFFZG1iMkdSNlFzNnlpbGFPTWpqaStPWjQreWNZeE1kSXdHMnJqR013RUxuZzBmMVJSckRBSGVsK21LOWcxdlRVUCsrcWU5Y3I4cXJXRkNBN041TTBmOVVRaVNUdzBweER5L1RtSHRjTnpkSHo4SkpIL1hpTC9ZWVVEenNjNW56TTRIcHI0TkQrZkE1TDErK25JUzEyamFPVk1XY0lKRHg5M3NrWTZidlBOWWRqNGd3eFZlYzdhTlREeWJjUXplam53Vmp4d0VNTlRHb3JIOTZPVjA3ZGI4WEFqRFBRaTlOSU9yN3VEWnphaHRJaUZzMGY4QkM3MU1MK214K25oVVhGS3RiWGluYk9uUDVtZmF2YldzTGZsc09jZnlyLy9OR045d1ZIZ0dWbFlJYzdIQ2ltdUFWVTJvRkZJOW53TUs5YmpWT3c4VDNhU29PK2ZzM0VIKzJPV2F3K3YyOHYzeUo5L21EL2pidjdjUFByOWNmN2R3WjVud05MemRmRHdwTHRhOGRMODNoeVV6QmxlazBDRHFSS2dEaXNCN3BzSnVGNE5Ccnp3UWxzNVh0ZmdBd09DUnFpZUZoRnoxcHlld2FrT01Ockp3WUR0L0pvdk1JSjdHQk1oUXQ0NG5YQzNVU0o3VGFNU2F6NktCOTZEaTZYaDVlOTV4ckdkOFcvdkJJRlJ2R29TaW8wTVFXK3ZPRW5tUjhDQlZ6SFdHdzFWS1N0ZHpNbDhVVXNERDVCZ1pMMlZnNFA1WGoyZ0FyMVV3dDg3K3lOVk9qckhNTE5WT1dqTDgxMzM4L3Y5WW1hL3lhWlQ0Mm5sZW9oWHovWTgxSGlZLzMrY3I0a0JtZ2xtNW1qNjBRa2VSNnZMRDJ1Yzd6VkdZSk13NW5zWjYydHpiVFY4cEY4K09keHBzS1VPTmVGbWt6Vm9nVGVUNEM5RytSMSsxb0grbVdRRE1PTjBGSTdUd0FTTVp2WlZQUFFaWGpBYi94NlJmUkNzbTQyOWh5SHVRZnJ2aFNYWkFVc1RxM2ZPejZQRFczZk8vUTdPOTlzNnNqTzlzdlA2S1FIV0Z0STVPZlJUalN2OURPcUlVNmFwZHNwR2ZoRHFLQitabzNpYWZOem5pSHlBd2QvTi8zNlE2L2tuanV3amtnRDVzMDh3am9NdHRRTUhyUFY1ZnY0ZVJoakJVRnhBWGRITDMxczVHcDZCWVM4QlhMTG5JY2s1T0V4Qy8wM0NLc1FLUjMxTDllMTNOOWo0aWw1VmQ5MjQwY0E5SWZNMGV6Q3ZWbi9FVGRWOGY0N2t6K0pobUltYTRORnlRSE0zRzhnSHZPZjliR2o1T0w2Zi8vMFpuM2VRd0dZUG5KcndHdW9MR25qMWJEUWZRYm1kc1lHeVFaN2dJUk5lMnpoUUtncU9KZ2Q5Y29MYXh1clN3amZWWmViRm1QVUZPMGZyNlZQbForYVErejA4V1llTmNKeHZnRW1FMjhFd0kvRGxBVWY5RitFWGc1RHRINFVQZllKWDdpVlFhWEE5aHMwMHdXc21lSEpDbVIyOFk0OE4yc3BhVEVLL25lYlhuaHdlT3RwekZveXZqWTRUQ2M0OTJGSXUvc09EcmRjMjFtdkZjRFgrTmNxL1ZkR2tKSG1Vd0NjYkJqM2RJSkUyK2NYRC9QYzlPTlJISEpNWGVNRUhlT3M5TmtNMjFFNDJEcS81QWtQWld5bndIcXdVdXd6NHQyR2o1YURySGljQ1g5dkFHKy94ZncxV1BiMXIyR0MwYjZaQmNud0ZRNzNXaU1IRUdMMXF6U1NldGhHcXFCRmoxZEtUL1d5QW94RHNCM2k1N01VeVQ4cWc1bWwrN2hGQlRRN0c3dWVmLzNQKzNQdjVkeDloME4xczdCMndMWG5kU1FMRXZaWGk3SWlOb2tFWnMxNzkvUE85VUUrZkVRQ1M4ZENOcjhjLzEzMTM1ZWovNlhWY0wvS3NHejg4ckVTVU9RTE82dnBzS0w4NXBIWDJLRDF3SFlPb0pEZVBSK0lSTi9zQlJIeCtUYjZHUVRaUWg5Zm02Lzg2RzJqKy9TQkIzd2pjUFdLajNNSHdCaGdlUGR3T25yaVhBQzhLOUNBZTcrWDlKcXpQWUtYY2tUb0tUU0lvYlpncTNPMVdCemg5RHcvN3ZZelZFMGpUUzVDMkNvSWRHM2lXUmdJVzV1b0g0TU1QTUF5OXFRblUwd0ZlOXdIdmw0LzdCc0dPQ1ZOeGdWZDlRUFE5SVZMZnpVYWUwN241V3U3bTk4cEIzTVA4dksvek5RMjRuczdLdE9vRVhKcU5QUUt6OW1CTFdCV1IzeWR2MEVreVc0UlFlYU5uZm5ldGR1dGFINFB2QmdkZWk3b0tLNFMvU2ZhRWFjRFdXWWhPZ296Ty9JSzlLSHdxUFREcm9UN012ei9nR0RYSmFvM3o4M2J3T3FmNU9VL3dlaDJNNm9pak5LZFBLZU03Z09aaTFjS2o0TjJJak5qT3l0UndaajR1MkdSNWMvRFl6cGgzaC9YWXcvdU9WcGJuMEdoNXFqeFc3dWRhaTZNdFZPYXJ3SUg0U2w3VkUxSlA4cVdaWGlRbmFrTHJuT1Y0Nm9WUUg4VWdiRGFvakJrL2dZNzZOUC91U1FLNXh4bURKbmpjQkhyckl0NDQ4NzVCQ1BVUjMrVWpBaHVEbDZWd0ptUExmd0F1MEdDeWtSMFJ1QjNtNTUrRXRTQjdNV0xqUmxzS3JrbG50WTd4TlU2eUlJZ3p1U2FNZWJIRThMdkFnSXFvZWkxMXA3aElOMGdTNHgzRmNKOGtDTWs0TUFjUk8zaXNUckJyT3h2SUh2VFZJNkp5ZXFPemJKNEo3NStzMUtUdTRhSHlFWnU5K2dPQ3F3YmM1b2dnSnNweG5iMDROOHhaMW11YzErSU9rSVdNUVFCVVlPQjVnREdmYmRrbllYVHU0ZWhBSUwzdkN2TitDRHNRWCtCUjExcEFwc3BPVFpWMHE1WThSM2laN0puMmtoMGlsNW9ON201Kzduayt6ak9aMzFtcEl6akFXSHZCaGdrWTg0RG9mSnlOY1kvQUtzQ1FEWnZnRTQ3ME93UjFHYVp3YythZzZUUGd3UC9NMXgzbjc1SGY2NFJUNUFLUGQ0ZHJhb0dqRDhEdFZKRVJDZ3hZaThtV3VvYlJXWjgxUXcxYjdlbWxjR0N6WjcwaHFQTFUvaVM1QnhoMGgyQnFrZ0NzRjA4WkVWbVR3dHBKRUhTQTBUVTRidmRXS3UxUHMwSDBrZ0hyNW9RQmIzQURmalo3ejJobFU0elBNNXZSU1NvMFk5RUJoa1ptWThUcGtJT3d4a3JCVFBibUo2eHZqNlRBSU1hcHd2RVROalpUdklPVG5HbUVTUWlWbFBoYTRtZVR4NzNWdzI0eTFoZHFWUlVtSE9iRmJLMHVXMnRuejlMQWt3d3dwQk9NSU4rUWozamZ2RWgzYzZTZE1WOE9KajdQNzNmQ3NadzkyZjM4SHIvYnM5by9rL29maEtKaTBOVEl4amlKQnh2TjdIL2g1MC93cEQwTUkrS1U2T2ZyMkFrajhoVjQzU1NCa2ZDOUFySmNES2hZRDJaVzZuaTFUc3pqd3IyZ0s4MzM0S3R0N3l6K1U0MVZ0YWExN0VodzRFZUxIZDRKZDlqQ0swVmtpWWdwV3dreUVyeFhQeS9rTVAvOWlHdklIckRIeldZamkxWW9OWU1SZTkxYkp0eDBwbE5iWVVYYTJUdDNzbDRuc0FkbkdDODMxWk5zbU1tV0FuVm10UXp2ZHcvOFRVTTFKM0V3T0FFVlU4OU1VU2ZKcW0zR3NMY2FhOXhvcUdHakIyWEU3M1h1aStJcEpna0dBc2o0UGFnZUE0WWJKVWRQdkdaZ0J3N3pEUW93MUFjRVpRRnAwc2J4bEFtMER6V3hMUXhzQkV5SUVwd3hUOC9pdndGVTF3N0gvQkZZL0dDbGtQc0pqRU1EYU5GS2RpNC9KOHNUOCtkOEVvcXN0VDkwdUtxRFpVVkdLMGtPdmNkOHNKZkNkM3RzRGJDOG9SREJjZTBVRlk4TytYeVFaSUNtWVVsZDVadjZ5L3k3WDRFYkJ6R2luSEhLMGZsbkswdWJmNTBONG4vUFA2ZktpWXpGUnl0RnkrUXdMd2htT3ZDWkt1YW1ESkhHMU1PZ0dxSGdUbFpLSVhOQUdXSE1QUUtud1VyVkY2c2hIbkNDWEt5c0NnajRIbDhRUE8xZy9DYjQxcHhOMStGK20vdzdiRTNQM3RxZE1ONTQvR3QwYnpBSUxRZjJoQkZQMlBVczBhQmNqbm56SFk3RWU2UlFHYWxmNExIaTdFWHllLzRUdEUrQUVTZ3VZemZBT3l2bGhvMWd4ODdLV3FtTGMwTUg4VDR0TURnOWNXZGxpUXlETmdxejc0Q2g0N3lCODZZK0NCemF6Yy8vS0Q5N3hEVmRBQVBVS0JzSmxscUhhdXl0UHZjZy9SU2VGY2JxWVJFdnV4R2NMMGI4TjhrTnBPNVNnNWNJZWlWSDBSOW1qNUI1emM4SXRuSzZOY21STjBrZW5kMVBHaXUxclkxelFnVEJsdnFZRUx6OE5sL1RTUXd3MnJMRjVRQXM2cFdVUDJMalJwd09JeGlKMFVwUlNweC9ONElwWUNsMy9uNG5XL1pzWUpacmtnU08zcyswY3ZyZW5JN2RpbDIzTnQ5YWF6MUo4VWVRTDloSVJ1dXpKQUJZc0RmQ2dESnR4Vlk4ZDFhMjRibkQ4WFlCbG9zNDJucDh6bEVTQm8wRVV3d2dkZzV2ZURHL0UyR0w5L3NuTnRVT1NZQkoxbU1FTG0xRUY2SGFnQjZRS0h1K1Q0QVdlMUJ1aG1NNk15cDNWalpKUHN1OTJnbEdWUytyeVo1cGhhcE0zek9ERlYvcHRkcVBxUkdEeURmNk44bFFIYzF2SjNrQTl4b2tiNTRKK2pPT3NreEpuYUVQSVBFZHhadDJWaGJWVGJqaGpYQ0tHYWZ0Y1kzMHd0eGtrNVVsT0VuV2hMVFNFNHlra1hTeTRrWnROVCtKTm9KcDVDUCtmWUtXSUNGdzdiRnhuNFJiVlozd3pyblh0YUVmV3R1MW1jUGZnbDF2TWRZZzNrR0RwQWlESGExc05OWWcwaWZsY2daTmtvK2RPMkREbkhHaTFuT2NqOFFERE9XQzExSGw5RUc4WU9mQUVHMWJtU1JENXZHTnluQU1RcUJyejlSR0lJTUdsOXpnSmlkRVFIQTFDdDdQak1wWFBDZnp6T3owc3JPeTFlY1JtVE9xc0xSVGpOZW1xRmxKQm5oSklWdjUvMDFRd01Xc2xjREt3NmY2SlpKRTAxRWlhS3JmTTRXMGwwQ05ocThZbEJyVjMrMVpYTkxDNCt6Z0tieWtBemRaTDVvQTdTeVl3RmQyQW04R2ZPOUhLd3NEdFNSOGNyeXUyYkluUW5JODIxbW90VTRZaEVhQ3VpZm9JSGpjVXhzd3diUG5TZ21XMkZEMTlpalllNUlzb3ExZzJNMjg2eFpqalRkNFZhODJSNE1ITmlTckhWMmpwQyt6ZC9nSWJMb1hUMnJBVjlrN2Y4QkNqTWpESjNoNHM3SzM2U2phaGRiQjJSR1kxUkJkMDFoSDhLa0dEejQ1YWNlSTlVaUNjWlBnVEMzaEptblBka01qV0JIbTdiT2lhNEtoOWxhVzVFUUplRHZSV3pEYjlRVDQ0L1VYUytZWGRYbzl5YjQ1U3hvM3BreFR4ZFh6WWlmczFFbm9vVndPMGd0MU15RGYvWFZlMUgvYmMvT0lFZmlyZ3dkUkNtaXlzaVJGTTJTTTlqdms0QWszV25obDdXa3dDZlpzd0drR0I4ZWFHSGFQSUZRM1JTZUJiQ01lZDI5bDU1cFJUb0JHNkxXOGFmUFBQb3ArNG9UMzJjdnZ2bGhaN3RJNDhVUVN6clZXdTlYY0dteGRNOWl0TUVDOTYxcjVyMGJMOUdRMCtwM2NGSW9yT25DTXVTcUFsYXhaZ0dMd1NLeTFUNEkzQnl2Rnl0RkpreVlIUnc1TzRNQS96UE5IQnlicFBBTjZteS93eUV4L2RnaCtCa21sSHVSSUgwQy9IV2RvdExleUI5ZWpsU0x4Yk13WDhMWUJxZHpNV2ZjdytDejJmZ0JrME83Z284RERyV09OTnVzRjRvWTMwdDNSeUFYd0dHSXVuKzkvdEZJbHBkbWVIcDd4SUF0Q1BXWXZSakRpNzcwczRDUlFJb3BveER1aWlDMWJpZmduNFNvRGpJMUdUK05qUk4xWjJZUDFFendZaXdNSFNaWTBnbGtIZU9wR1VwNUhNZFJvWnYrRk5YL0FwaWV1ZjdDeUFqZkM2RWR3czBHQzU1M3cwbXVqb0s2TkdiMktXeGVlMWFsYzlTUi81QVU5QTRnT2E1RGZ1QmNTT3lLU1AxblpNVS8vNXZWa0wwUDUzQUZac0N3TUdTU2p4cUF2eUxXUFZzb092V0NJbWdaekJEVE1wd2RKNnhJV0dEYi94Y3JKTWNTRWJHR1pKR0V5U1lBV2NEcmx3UEpYZko5a3BYSnRKMHpLbzZUSjJUanUwWjVsaUkyVkZRNVJBaXBWMVcyZVAvc3RuclgyeWtGdVdCUlB0cE9vdVJlRFV5WCtrNlF6NzdBZ1IzaUF1L2wxUjF3TFZmajhuTWFocTBMbDg0bEh0WDFsQjVxSWdhTTNMV1YwYUxza1hwdEcydUw3c09lckdtYUVaMDZpZTZCSEQ0QlBCa01NY3VSUHMyZlBnZWpYT1ZaZ3hRVGJlajdZc3BueWJvVzJDczd2MXV4cEU2YU5HN0dxSjJpSjRoMDd3V3JFUWZRVU8rVEtBd1F1SnpreWM0My9nMEFIcmVna2JqcElCa2g1MDUwanZHbkVDL0pZYThSZ1doaHdLNElUazJNOHlQR2RoS0xyQk8rYUV3VFM4eXEwNlpEbEMwNktOSXFSSGlWajJJc1c0UmNueVRCSWdNcjJReWVIMWh4dDJkZGhDOFRjOUdnckJyeldiMTViZjlOSWMyK253Y0VySnh6WkNiVElEaGdwRS94UFZ1cEdrM2hUMW1ORlc0NkRWS3FGbnArTUFzdEZXdk5yNksxQ2lEOUpzaUpKMmpQYVVtMWx0cFRia1cySVZ0YjhHOFE1RjJlajliYnNIOHZFUmFZUlR6RFFUN01IZlVKc2NHZWwvdlVBcG1ZVXcxT1doNUNxdDZXRU1Gd1J2R3ptV2x2SHEyb2tsNXlVMnM1S09ac2h1bXptd09PRW04UGFvTE9WZ3VkODQrL3R1Y251cHpsYTNsdXBUaHFGNU85czJZVFhST0F4eVd1SVE0L0EwTDN3dTYxc1VHSkNuWjV5eFBzclJvL3l0Mkk0bmc2amJMckpFYUZNNW8rSDN3bUgzY3BwMUFrZDl3bjROUWVuRjJURUNJZTB1L2NPbTBXSHhubU9xalpOcHlnd0RTR3NHbXk3MFFOckkxb0dTUmQ0blVtT0ZxWkVlVVFxdVoza3VTZnplMEQxRXJBazNKeEphRERXMSt2Z0NrN1AzdG15cFE1bnRJNjI3R1hhUzdRZW5jVVBFbkI0OUpVTzRHRFNSRTg1dmthYkhqUGJ0c1A2akxic3BKMkFReSt6K09iZlZ2YlIyZ21rYU9HUXNpUHE4VjVNNWZhMmJGaXNQU1JlSkhTNU5rSzhOVjkwSFp5OE1FcytMdUJISTRRVEp0RWtqVDAvOXdJaklnRTlTTmFKdEJYVlR5cGcvdDNLeHJzNXNEbzVRWXhKc09MbHZ3TWdTK09zaFdidHpBa3lrcVJYRTY2dGNSSXVtdWxTUHBkL1dpSDE5MWpYVVU2TnpLSGVXVm5ZdUJOUFRoWGFrM01DSENYdzAzTDdWMG01eGhWRDFZd0ZGN296dnlUaWc0RHRMQUxPR1N5MjlNbmx5VFR3SFNMK2YwZ0dpcVhHaG13TTU1eGVCRGZtcURjNCtvYWpsUldlU1k0dEduSW4ySmhCVnV0a2JuUmlZdWQ0NTA2T3c4YVc0dWRKUkM2a0JIc3JsVjdNNHRGNFNhUHQ1ZjFHZXk1TS9HRFAvV2VQb0FFYlVGcU4rVTAwbmhEQUtUTXhXWDJPN0UyUC8vQ3N3S3hlMDRxbW9qYmk0ZzRPTzhCSXZaWG5IaVd3NE9KY1JIV1VkK1plamh4dnVuVWoxN3V6WlFPTHlkRXlqQkwxN2gwNnk5djZ5b3UydHB5dHBXTTdxZW05T0pnMHlEVW1LNnRoT3dlL25tdzVZK3NrcDRWaGc3TEtsUTJQVC9aYzB2N0Z5cVp6dlVQQmRhQXlXeXNMSjVWbnJZcGJOZ3RabkE3V0pzYXBxZFBvVUQxN29VenlqbVlkZTg3SjcyM1pjcEZ0MWRsRzNVVEFvb1dKdkJtZFEweWJsZjFhVlJnVEhUNlF3eWlVRGRDOE9BWGhyY016MXZyM3E5ZFV6V3N2V29vRzY2Qkg3Q0NNQkx0cmp3aUdmc2NHNlpBSWFNRWFaTy9hV1NtSzcrWnNXR2ZMZnJxSzd3ZGhaVUlsRmZ0aXoxcnIyem5LSXB0elRKbVZqZGZJaDdJK0tIdlhFK2lSbmZDVnYrT1k1bkhLZHBVZnhDajJrc3ZYWS8wQ3JHcml0U2tYYkcwNWc2Q3BmUC9hckZmTjRLaGhQYzNReUFTM2FrQ2wwMThvZ3h4dDJhZ2lTVzZmTkJsVHF5Y3I2NzcrYmMvTlF5WXIyeE1wczNJQ3poMUZSSFMyVWw4Y2hQRUk1cmNwZXJGbkRVN1dKVG9jSS9QdFhvclFnRmxOanBMSCtXWjluakhyUitUKzJ6azYvUVZrZHdJV08rTGZ4R2FqVUZjS1BRNFN1YmZpSWM5WTRBZDVUblE4bzFtOUtabWVPSk53dm5jT2hhYjNoS2RFNHlRcUNBbE12TllnRzJpeXNnZkRQYjRiZzk0N1BPOWdmelRtWUJMRXdMeDRGRnhBNXN0c09jYlR4RkRETFliNkg4L3E0RlZ0cEtCSDJ5UkhYQ3ZIdUNHbmZFUWdOQXJ0ZE1DWE8xbzVXelgvN0FtdzRGNW9LQzhpVitYOUNTS096ODV4RzYxczZjNm85MkIrbS9pMW9ybjgrRzBPN2liekMrMVVtQjFYOHVkblc4NVlUUUtWa2lpeG1Gd2dIWFZHc1BVb1ZON3ZWcFlueFJtM1VnZWk0ejRUR0I2ZE5qNDRKNDhtbE1hVTBpYTJvSWFqUFBHS2QzTTQrMm1VblB2WnlySG5Kcm4vRVF0Mm1hTi9sbGx3cWpVN1NPZGVxcng1WCtlZnRWWTJJYzRseUkwWXFScTVEcDFvVnI2ejF3WFI2L0tkSEFGS3F1VFJKd2MzRXhvTVRyQkZTTUJCRzZQeit4T293QTVwMHg1QjAwbXc5eWo0dHNmOUdpVVpjSkcwOVdSbDg3bEpObHJoSERkWHQrS0owMHBhYkhMeTE4SEpQeWRiRHVnOTJITm5QOUl5NTNrbjMrRjRQd21IRjZ4czNOdUN2MjFFbEVGS1NHa1RldHVtNGkxVnpKMGhDemZNbXN6dFV2R3cwZmsrWnN2K3FUVWoxMXcvTndjMUNpb1U0bjJnc0dpU2dGZnBPUnJnRTFpYU13d3Y2NHhIK1g1Umd0SExGZmgwVzFKZ2hnQnB3eHVwUHJRVklqNDNGWXRnQUFZcjYrT3prWjBseTdLM1A5bzlqdlk4UDlYZ1NUT0xNQWxkUXEvMUtEOGJaSlBWcHVWcFd5UCsrMTYwQ042a3ZTQWNwcWZ3MHNsKzBXRUtpUEdtaWdlT1RpYk9KSjVRc1ExNVp6cVJYNkhuR0t4c0lOTGo5Wm9lMTQ3WnVqNmRjUFN0MkZDOFZXMWx6bzcycUFpRkM1TmdvNU5FL0V5L2tZTEtuYVozVnJhTEpOZDRBR1dpMWFHRGxSMU45RWczOEtWZWpqMEtwVFU1QXBpMWx1UmJGemRVb0ZJdElBdm1GOTZwd2FxQXhPTXVPOG5kbStEV0hiUVp6YnpXK2ZRZzE1eng2d09TQThTZ25FSExjYUpmWmMwYkpHcVVHV2pzQlNYYkdRWkVPUUtKQjlsMHJIT0k3VDEyMm1CbC95aXo1OWJrT1pENlhmRGlBYnY0Wk05dDFxZEsybzVFdW9IZ0RsWk9yRFloMjZPd0FhRnlQSnVUQmNyRStaWWpMVGlzU1kxdHFjVUhyWGhDanUxc1JMQVRuZThYQkJiUWdYd0F6MDJPZWk5QjVqOXhBdXJKR3VCZ29xU0JMM0pxZFpYTTZIU3JadzBWSll4SjlpazZPR292MGVFZWtTU2JSaEEyQkZFNHNXb3pQeWQzak43amFHb2t3UkNkNEsrUlJkWHUyNDJEMWRRZ2EyMlFha2RYRFQ1cG9OUUlmT2psSm5wYWdFR01UZXVkRnFvbHVhKy9TOEI0c1dWNU9LY3dUZzY4K1JWcjNzdjdxNlpqdEdXN3pPdzR6bzdHNGovcjlKSUFLempXSG9SZVljYW90MUlMT3NGVE5xSjJhb0YvMk40bnlCZlBOQTNMakhPa09qZ2FCVys4NXQ2VzVjSmFtS2lFOTlyNG5MaWlGUEk4Y25LeVhucUU3eXI0MTRNdVhpREdSdy9PbFI3NElJYlpDZTdNWXFHZGNPUDV1VG16OVFFT283ZXlMWk9aUDQvMklFSWpWYWJkakZkdHhhUG84ZVcxajlFQ3NSWUd0VWVxa0NVV1BMNk84Skk1a3I0RERSWUVod1hCckx5dVZrUVVWRGF4bjFWank5SVZjOTR2SVRDc2VjRmJIMXRtTWFTS3gyUysvK0pFL2Q2R21RUzdUNUlJeUJDS3MyY2Y0SVR5KzMrVm9KV1MwQkZCTU5tWEtHeEVkS2k2bTdKWEhyNVN5cVZXVnR0SzFMOXpjczU3WklmdWhFWTZJQWpZejR2MEFRdDF4Z0xjNFdpZmhIcWFIQXJHYkZseXc0N1QvN0RscE94OTVUamZVazZjSEVxcDVxMVR4ZXVuQ3FUUVJoSW1HZ2ZOSEVhUTlNbkIzNG9iV1dseHRuTGUxaU9jd0JOSmZFQ01vYUlKV09PUUoyL0RiazIzaHBYVUdiTVV4SDBETG13U1RwVTFWMnhaR1pBc0NIT0dKMGVqYkYrVEJDNDhTQnB2bEdDRFdiUWtPZ1ZsRG41eGp0SmRaZU5lTTlTME1mM3FHWXgzc2tVblFnNHJRcGpvWUhkdGlxZmNhUlFOZ003RU90cXkrdUlKMytFMGU5cDdnVnRSb0VVampBQVpqc1plT0JvK1ZyQmZrbUFnU2hUWENrWWhlTC9Zc2h3NjQ2b0g0Rkx0dTBSYTZSNjd2WFcwQ1pQanJiUThXaE1ZeWFHQTFnd3hyYVJVMHcyMFM3aENXdzByc015N0JwMFFHQnpPVmpXNGxEcTJsUXlVQmwrTm5KcWRQVmNoZjdWbi9YRVEvbDJUUXBQY3I5SGhqVGM5MmtvdzRCMXh4S1E1SzBMRDFMUnJsZ0orc2VmMjZEay96eFFnaTlsWUx0SUo5bTJkTEk5Vk5oRkxUM2EybEJTR0ZTcnAydkYvaTVGNkFaYzVrSW80dVJYaFNuUlN3dE5LaG15eVpTMmFPVWJNYXpyYnNoZEJ3aW1YbFZRZnJTeGRPa3NjRWVCZHoxWU94K08xcDVkNFY2VmtSZ2Z3Yys1U0VPekUzSFUrN2psb0xVZVRBM0wwRnpBR1R6RCt2VDFYRlJ5dDFIRjZHRklGTEcyRmJ0SjhlbkJ1Vm5DKzk3ZWtCcmQwZlY1TElGaEZjMkFPYkVqbTl6eGdHODYxV1ZaczZ0WllPV1U3MTF4UnIzb1dMalZEd2svNDNMT1ZjMmtOV1Q1Mzg5N2FtSzIxWlkvUzF1RlpSeWR0ZUppUGhoRVJaUytVQ0R1akRMWXNPZTVuZzc2WEtQOWd5MTVZQ2wrVXg5UkN2aWlRNE1FeHluREZPTmQrcHpNRXRocHFiYU1rSi9QbHFiWlk3cUxsT0VyWDZUd0J0Z1NsNENSSVVKcmJlZDVEdzBHb2NDL3A4SnhRNkIzYTcxRm91bkNMUTFBaGkwZVg4QWdLbGFPTU4rcXpsYTEyVHZZOFpOZmdaYk1uL2pSNzFNNUpsMTZjUFBoT3NqU05ROXlISytUL3ZSRHhhOWgweTBOUEFMdXlDZEtHMUxlSHp6V1EwdUpDRmNkVDVOSllXWmdZQllxTWtpcGx1WGx1VnZ6RnlqNVhPZDdJd3ZqY2J2UGZ0aFJoMTJLRFpxdDNqWE9GZ0FMMklQU1B0aTBueU4rRDFqQjdic1grRWRSSVJGYUtBb21jYVRsYk9VdnBNaStRNHRUV3VhblVkaWE1N3NZSk1EU3I1VFh3TVBQSEo1MXU5THBiRGQ0THFKTGNCNFV2VFNXUlkxWXZDVThPYlJZRTd4dVlnZHdVZzkxY1RyWnNnNVFEcjkvQituZ25ZSEt1WjdpVkRiQ0tCOUFxZ1NUSFNRYmdKL0NualpWem1UUTltQmZuaVBmOWFtV2JuWnk5SW04Ym5XQmpNTFAvZGd5dmRZeHdsS3pLdjgwZlpiNldsVHJjaUVPZkhFOGFuTlNtUnlWcW96c1BzNUllb2hwSzIxRnFud05Db3d0UzNSMG93cXlQcFphMnMzTGU3Y0hLU29MSnlqSVdMUmx2SFBoVzBHOXIzalZXQW9zbzBmMG82Yks5OEpNdFBJLzJBempaYzgzUkdVRllyZ0lZNXVQREsvbk5XUlgyYmRXeFAvOEhDMFZoZGFyUVRSbGZmcXJRVU5NS3JyL21UZFVvajVJV2ZiUmxmOWdhZFBDU0RFRk9GeE5jUGpuWk9OYkVCYUgxT2l0MXhwb1Z5NGFjdTJmL3cveU9pSFE4b3kwYmUzakpqY2FXbmNKWEtVR1d0WGhjSUFVTUt0dHJyVlNtQnlzcldka3VpQkhxSFRpNmZKRWZRWGRRWU4wajVib1RzdG9rTmF2bDNzbVc4N2VJZTdzS3Bxemg4cTJQQ3pieVdwTEFLcEgvNUZCUTZrd213ZmJaT0hxSENTRzl4OWtEcWhuMnhETW51ZSsvUzBEK0pNR2xkMTNCWVNrNHI3Y09hQ1dyMVRxTHlYU201b0haZjNTeXN0RUN5eGhVdEpDTmVpODU2endCOEgvbVhadVAvZCt3Njg5NHY3MHRxMVpWSkRFNVhvbkhVN3VTRWxYeVBhNmtWMnVQM1FhTmdLWmRSeWY2anhYb29JTXlSdlA3dEhvc1EyL0xCbXVqTGR1eTV4TnlaK1hvK0ZZeVd4ejB4aUxFS0haUVM4UjRJcDlxNzZ2VzZSa3d5WEdoZ2xuMnVScUZCSTZTSldIUFVTWWRjbHJ2eS93WkgrY3YvOEhLb1dKWmNYWG5aSHVpcFBCR1cvYi96M1RKQnl1MW9NMktQc0lxeHBJcTBPbGF3R1JDK25lVnhFYXc2NTMyZE9ERUpEeHlkTkthbWpUeENrQ1ZManVLUTlLTzRpZkFMZFhVY3FQWG9GaGZDZlJXMTdVVkVsMGxYSzBFSmRvVGdCeG5LeVF5RlVMajdEbC9uVi8zd1VyOVkxYXg5N0lUNC93NlRVeDBFc25xaUhVT3NmaGd2Z1F2cmVUdDB4VmN1bVdzanZmYXJySUJQSXpxVlFsTURwM2xlU2FXbitqOEI1WnNjMFB1cmV5SHBmMXZFOWlkUnVDRHZtY1NYTXpwT2Iyenpra1NQZWxhVW9DTDBqdUx6MWJrdllENWpKV09jMENVQTZsSHZOOS93d3VmRUYxbkk4OGdQaFBkdjFoWlNrRnVjYkwxWmwvZU5CbmxQYlh6WDYyaU45bkxodW1tRy9MOTF6WktyVEpCeThvbjh4dGo2T2I0YXVWYzJPaEFrNHM0bzF5VnpOcTJSdkMxVHBta0lGOFRFVmJSUGF5eUFaN3FpZ0dUS3ZBWkRWNkVuNzA0dEVWdWZma0JSc25hL0QyZWV3ZXNSR25aNk53azlsMmw1em5KYVRDYTN4dzUzSENFcnhua0xTbFpMK0w5OTRvaGgwcmlJai8vWktWc2tuODZLN3NyNnVUd1VTZ3JHbFBXRzBmZzhBUUl5STR5eE1HZGxSMnhCMXZPTWdzTzUzcXRIOE1DcjNqVm44Rks2VjRXUFpDMzYyRzR1Wkh3VVRJVWVjWVNMMmJBYS9lZ3J1N0EzUVlybTdNbFd4YWJVYnJJeG05TTZVN09ZcTFOOGpZSHluaTUvN0JCVDFBenZ2eDkvbEhKZHExNTJNbVcweEVwRDJ5ZHJGWTJTcDNPUFZyWkxNTWNkaUhIR1R1a1lCbVg3QVFMVTQ3b2NjbU5MV2ZrWGsyZ3hDdXB2dVJ3bElxdi9rdkFkbytvUHFmamVtUkJEdGlaOTFaMloySC9mRlh0SjBDRzBaYkNhck95NDRzbUFtd0R0eGtjTDdkemRBRGY0cEd2NlJBODc2dWExb1MxMXF5amJ1YkpDY3lvOHpqamhPU1krMEcrOHdtMDArUmNseXJiSmx0MmdlUkd2VVZMVVFSWUdtR3E0ZmF5VUJ5QSt5OTdGdUp5aGxUR244ZDVKL2IyTERFamR2bVgvU0VoSE1BcTZDWnBKUEprSnFhM3N2RlhzNUtWODRJTnMzcUpjdzBqYmlrYTNJSmh3d29HcnMzSjFVUk1LNUcvRmhZeUJUMnNaTzBtVzNicU5qZ1A3ZFdRNGRxalExTXFkR3VFSVhqUmVQZFlPZnAxOFZ1SDlzbTc2V2hsc1I2YmYrV3VIWGZJSWZOSUdXWUR6c0pzUnZOVXNtdWpPSk1qbXZ6ZklEb0dqeXBhMDVnbUo3Vjh6UU1NdGgzalhzdDZYWHN1VTVWN3U5N054UVErZFZZcTMweE96QUduWElTM3ZTQTQyOEZCZGNMR05PSlpiY05SMzlnR0JWYXNMRVpjMlhrNm4vUml5eUs5Qi96TkJtM1pNLzFMOHNSSmpwK0RsYUpnMVFQUVk3QlZqazY0NWpVTndobW15cEZMNldLekljMUtLbTJMb2FZVmoxcHJZT1kxNXhnY3ZwVnN6dG54cEdzamYzUzJGelVaN1BCOVAvLytLNExYZ3kyTFAvZVY3eFVjK2k5czhiaHRaUUVwUGhtZHZIb1dxMXhzMmQyNXQrVnMxQ2NySlgzbk9lQTZ6RjczRVdTMFdhblcwam9oRG1vd0I1ODFGYThYbklCTksyYTFyS01XV0cxOWhJMWUwOXNzV3NXaEVyN2c4SlRjbUUwbG1Ca2MyQmR3S3Vua21KMHRCM1V3Z012bExpMlNDUnBybUMwbGpMeW40NmJGbkxVQm9SSzFlbzNBT0dhbVExQkU1UTBsWldmN1E4dDZzV1ZUc2p0YktycnVRSCt3bXpienpSUlRqN1lzNldnY1R6TGgrTkxKejE1QjNsWXNXdXRwZStzanJYZ1k1WXNuaDB0V3NYUGpQQ2RKTW1aMFVyY3FrTTdLZnpvam5hUkRpbEFIUGJQeFNTdFU1MlRMQ1RaVmZRQWJzOFdWRktPMmF3K1NWVEtKeG52a2pqUFZ3YnFkckVoNndudWN4ZE5sNy9ra0c2YTFwYjVXOCt2c3l0TFljbENGUW9GeEJWZHRualpTZ1ZackJsL05pNitRL3g2TlJkek9NWjltWlZ0TXBtRzlwTWhaUHVzc01JMnQ5d09lZjRDMzU4aDVoVk5EWlgxdlh0akp3VGZSbHJWTlFYYnZKSUlFZlIyOVlRY2p6SFZidVhLQVE5QUNOQUtkYzcyTjhIZ1UzelMyMUlXcTNyTkd2cWRLR3ZDYTJqMWRvYVpxZlFUaUJpTlZYZTZqL0M1S1VvQ254aUE0bDRtY0pLZVNEaUo1RXUvTSs1aEw1TE5CZjdWU0VaY3FjTVhNSHdKNFV6TmhXMWxNQmNtTlhIUyt1SHNjMzlubEg2enNqSklrT2lmbDhrOTc3bkpONDN5dzV4RkVvME1mUlFrS0cxbWtSckFUQTRhbWtzMnJUUU84Wm9CclU1L3RDajIxbHNaVlJxUW1FSmtjTGpNaWVVUGVPUWRERjBDakp5c0habEFxU0N6L1lNdXFaem9aeGRwckJabWJaWUt4d3ZscDlXaU5TTDhBZHp6YWNnS0syVktJbXdVVHZ3REQ3S3djVC9NVjEvQ0xrLzFRZFpYWGRyMkhKeDBsb1BBRXdrcGFtNjFYVVZ3VFgxL3p3SXAzaHl2dnJiQnNzRkpjTkFwMXArbm9LQjV5RUE0MDgrSW5JZmtmeFNEUFZsWUg1RHE1VHB4SEl5bnpyZXNWcnNFQVR3YzYybktzb2NlUEVmTjlBRlYxc0xLdW5OSGdNT2ZFYzVVQUJ3OVBDTHhPK04xZ3l3YkE2bkdVNWhtYzV5YXJUK2d6R0hrdlI5cjVpdGZiT3FyYys5M0Z1UTltWlZuTUtIL3loaHdxV0pnay9HaGx0WEVud1c2T094NXQyUTUwSnpDTGZWa3BvcjVZMlJkc2RPRE90V21WTi9Hc1NnWFZBZzVtc2JTRllyN0lCL0NsUFppQkM2SjhGdUdORW1SZHNLZ2N6VDdac24zT1dFa0I3bXpaWXpZSlR0SW9lV2ZMTVVFYzlia0ZXNjQ5eHlQdWQrYnJQNC9PYzBreFRVNFExbG81UnNuanAwZHNrTUhLSGc0bTlGNXJwVFNRN1U1WjVEa2dMdmxnenhYRTZ2eFNKWlYvVlI4UUhhTWRWeUpYbHFIMHRpeGNPd0YwczM5cjVtU1Q1UFl6TFpMN3RUNGdvZUJOQ01rZWozUUlEVFE1ZVhDOW1aMHQ1NmNPRmJvcU9lK1pOaHhiMXpRV3RwS3lEUlhhYWhKdVdSc2hweFZNcUVFb0RkS3NiRE1md2NCd0F2Z0lCdWRYNEZ6MnpCMXhEeCtGbVFrcmNDcmQ0bGs5d3RZYnlrYXZPVG1jcThId21GM0tCdmZSeXJiZjdBQ1NJLytjd3RXMjd4Y3JXNDV6R2lHRndaTlFiYU56N0hoQ0YrK21COUVmVEZZWHJDUmIxNzk2NHBScldadkpsbE96Z3kzbmVkRjc5cmJzcktONG5wM0trK0RjblpVaUdSN2pYNndVeXJQcWcrM2hHMXNLWWJ5aTFGc3dmOUhrUXExOUxlT2dtWjlHZU00TDBuMW1aUWZCUjFzMlFPQzRtOEhLdVo4Y3BIQm41ZWpNaE1oMFowdmhpOG5ST1ltWE5jbmVlTjV6Rk95cTNWY0daek1FVzNhS0RqZEFoaG9sNWpFMUk5YXNGOFA5VGU1UmNIaFdzN0x3Y3JTeS9kTVQ4UHJleXVrOFo5enJpUHRtdHV3K0hqWXdIemRqVnU4SXlyaFIyeklPY3FPVGdIL1NWbCtzbkx6Q0tYOG4zSndEc05Eb0JIZ1BWclovYnlwZWRCVGNxWjVLNTdxZXhKdW9wNTNFTUV6b04zMTBWL1FCK3ZOUlBPcTBjZ3FxM3FIV1VPNkkrM0NwZlBjT0c0NndMQXRXZnJHeUN5VG54M2JBeWF4aTVtRGkxb2twYWw1MGt6WmdDLzkzcWJ5ZWFkQkdncThXRjl6QksrNFE1V2V0YTM2UDM3R0Rjd0IyaEpHenlVSWp5UWV2MHJPeDVlUzlXUG1PdFE3VU91ZHBaM1d4dXRsNmcyQ3RtbFhzbk15ZnhFM2hkaU93aE5KTXNnRmtFWlE3N2lWNG9rZk5UdUJ4TnRvN0pHa2U1ZjV6R3VQRmxrT1VCN3V0K21LVFoxVkNYR2tpWFlqZ01BZ1g4VXc1dVBxQ0tESy85Mi8yTEVySk4rZURsYVBmRGZqMUlsaXRsYU5aT1ZLVjdXbTJpR3F0NEFnNEdKaDBWcGFMckFWREhudWlua1VwdDhITS9xOHRoZEtETFV1d1RYaG1iN1p1Y3ZRT1BCbFkvWkd3a1UrQWIxa3A5MG0wSHdNb3hndGcyT2pjZTAzamE4TzVXeHFJdUlCL1RVbGZrNVoxOEppNmlQUUVyUnp2MmdHUEdsZ2RzN08zWlhsTnRHVkpoWm5mWGtkN2hHcUVtcXcrQmJ1cDRFNHZvbytWNEVsbkUweTI3UDJ2WG4weXZ4Um1rT2hlUGFlMjhlbkZ3MUhNWWdpMmNnY2Rla3pEV2svQ08wZUJJYXlNN2ZCZExsWXYwNW0yWnJEYUZkd1F6Qy9ObnB5b21BTnRQK0xHbkVEeUQ0SnBjZ3J3RGw2VC9aaTBYSVBCd3dFTG9qMWI5YldUODMzaUNoNWtqYjBHYXRmeSt1UEtrZGVKOS9XR3NubmVud1k3eXZPNG1YcEoxb3l5RHVTSkwwNXcyQ0pnWWd2K2s1d21Gem1GV2l2bk1uQmk5K1E0d2lEd1pmTWpiSHhPY25CdXNtVXpEQzRLK3d2a1FSWTVLOE51MUFUcitVc2VvU3NnbVh3UERwZVR1NGxQMlZ4c3NxVUcxS3VBMEdOOHNISUVVbU8rYURoVzh0N2VlRXZXakUyVkFKREdxc1EvbFV1eGduc0hKekFlNWFSaDRtYVlNV21PQ2I1YVdRNlRBQS9NbnRzSjdRRVh2R29DcXlRQWFsTFViZHFBcldOZDhPYURsUUpja3NyTXlIRENZRzV0eVlLMDdIR2Y1ai8vejU3MXJGL25uMzJCa1VaZ0o3MlpMTDArV1NrbmpCVWN6cU9ydCtWRThFR1lqZEdXM2NFVm93NE9lMURyUVZEcjRKZ2NCMkNTRFBDNnNYZ01qazVoSEIxaittelBWUjE1ODE1Z2VCeEcwbGs1ZEk3NmhKTUVycDFjVzF2SmptNDNQalJtVzdQMDZFVEdYcnFQWXBNNzJYM2ErUGRzenkzY1J3UXhPU1B5aXoycnNEaDdnTjV3RWsvZjJyTDhXTlZCU1RJdXJTMWJ1U2Q0a285V0NzMXIyTmljUUcydGtmQzRrczRlYmFsWFRiWVVRRWRibHFwejg3WTQxajM4R3lTQzV4RStTUExrWk04aUpHN012YU9qVUUrNnFXeGx6YXQ2bUxWbXFHdzhvU20veWJsaDdQTEg5dXhQMkhIRWxrZWhsN0luanBJS0pXOUhRYkNXdkppakF4Z0ZEcEFMMU8vZTRibVVOL0xmeVdFYlRJSWc3U1N0QmxnTFhxUFY2NVIwUWt1UzlMU09UNmMzKzkzSzlrNERvdnFEbFUxTGNyblJ5VXJWLzE2b3pDZkplTzZFT251Um9WN2pXVDNDbG1DNGw0V2sySnAwVDk1eHYxdFpCL1FFY2NNRitGUEhhaDdzdWJKZ0R3Rk1JeGhzQkg1aUVrRTludGRzd1J1VFNTR3pWOW9jSFBaQSswRTFFc1F4SVBGbVhKa3RKODBrODZXSzJzTlVaMEJFaC9yaSs0LzJYT3lYcXdKMjhJNlQ4OW1jek5JaDk3K3paY2sxYldFUG5KdWMwL2xhWE9RT2NXdnpMeXAxV0I2bGRZMkMyTUhiNWFQM3FaSk1tRVFUa0RNb1IxbXduVVN1RkdhY2JOa01iSUNIZkpCSU9NblIyVGluaE5mWFB6aEJsaWVjVVVvcE9GeXVSdmRlcTNYVk9DZ0xFQnlheW9UcnZNZ202b1c2dStEL0k5WTF0OG5YenpuSUp1aUVWYUMyT1ZUWWpwc3pWMTVTWUUyWVVlTVVhek9wZU16d0dEOWJxUmNsQzlEZ0NHSG5sUVQ0UUh4MHNlZXEyUWRiQ295MWtORWtBYUVCaVlxWU9kVmtjanhQTDlpdk1WOVJwS1VteVFuQ3BqbEpzdGI0UW8zM1ltWEJIaDNHNkx4TzJSdmVyNHRFL25zd05qM1cvR1RMMmJFWEp4R2duNnVhNDdDR1UydEJmN3dTK1ljcnlZSllDU1RvVlJwODhjbVd1c2I4dk4rQWlSOXNXZCtWV1lPSTdNb0VTREhJa2NjR0RFK0krdGVFT3pTZ2Z6dlhPNWxmVHFPVkJ1Wmt6cG9WYlVBV3JrK09jTVpzMlkrLzFvdFdZZExrVUZ2RXQ1d3BjTFp5eGxWMkxEb0l4UVRyN20ycEVkYnE1MDBzd0RWbWFxMFMweHVCcnFCL3FCZ3Z1NmxRSnpBNlJwR25FZWJBNkpNRVBTZkpqSjFCclRTZ1Y0SkVxUlFZazVEM0lsZWRaWnJtNnpBbmtKbHNPVHMyT0dJWDc4Ym9TY1lacTE1ZFA0WFd5dThTd3FpUk5GYnFWUzg0dlFJTWsxbTFUdWc1WGt0cnk0a3U3Q1hSZ2g5bnZOQTdHODllWXFnMVkwMVdsd2pxM3g2aHp1N1dqWlhTTmJiejRkRGlCcVR5YjFZT04yYXFyN2ZsNERoektKNThvM1lpZGpFbkc1WU43WXRBQWZXTVV5VXpROGh6a1lnNk9ZS1NTWklQRCtJeFBZWFNKSHh2a0t4U0k0RVlzMWVEWU9qZnJXd2psTmZuRVh6NWs1VkQ0Zmo5S0FjOXdrSGtUWkJzdmJyMTFkZ0FxMlJqYXMxMEo4ZXpCRkJQblFSYWJEZVR0UVFYMFFaMHVDbWZuT0NCUjczT1JHamdxUTlXMXJ4VGZkUTVCbmUwc2p2aDZBUUZvOE9TZUJDQXIxWGlYdGZ6QTE3WGk3Y2ViQ2xaREE2YndHTmZCME4zb0o5R3dDZkdBNE9WUFZoYnZIYkFQYnEzNTliNkkwUXMydkF1eWhxbGIvV3FhOFpxVndJdmVsWnZPSmRHK3lxem00QmpEMEovREdBSTh2UE84TXg3Y0lKSmFLZXNtLzBJVDNUQVVib1R1SEtCOS9XNjNNVVZMMXBMdDQ1eVJLdGhXU1hxMTN5L0JtOWpKVERVUXNxOUJLZWs5YlFVTzBsV2lpMkJMbklQZTRmN2J1VzZ0TitZc2dDYktLclZETlovL2hPMmo5RzBVazNsVlJDWTVMeUpiU2hQYStGdEJ5SGk3K3lQZXAvTUtkN0RJKytSYUtEeTYyaWxLTHR4bUFCbWZ3YkJ0RHJ6bEVLZEtEbjZ6a21sS3VIZk9kNVlPeUhXaEI1ZUczTU5Ya2Q1bjhGS3pmQWtSL1dEWlBOT0R0emdtUGNHM3ZZc21VemxpaFc2eEJWRzZXWmpqYzRMcnhYQWNTN1M1TEFHckduMzN1OGdSOXNkUERRN0ZnN2dTQTBwMXl6WWZyS3k2alNuZUlQajBZSXRhK1YxbW9uWE1pZzVIdFJnNkQxd2JCTDhTSVdUd2hldWs1TCtET0owclVmUmFKd0FGVFFWZkFGZmVoR1l3ZVp0TzhrODNZa3hub1Qxc2NvR3JjVS8xWDYzTitwU05oZHRKUWNqTlE2bkZwMm8xSnhVNHg2Ly8yTExMblU3cFBRbUNDVUdLNnRUZjNVV0pBL0VKZVRvck43VW9xOVFVMG1DT3NXTEY2R0tPTHkzZFJnSUxYNzAybGlhQkhHalhOZmtCSDhxNGphaGl3NjRieXh6b2FDOVJWRDFDQ3FMT3RsUklKN3k3UXFKb3ZuVkZDOHkxQVVNMkFBRnRPM1A1QnhkaEFKanhUTjN1R2thN0hCeUlZMTlKMm04SUZUVEhoNmlCeXk0dDFJVGEvYmNtcEVwUXhiRDdXdzV5S09UU0Z5VlZkb2JWbXUvV3VmR2FmY2JIVDA2bU44WU9GWTJWckt5VEQzSmNUNDZDWVZPdkxoMkpPd2x5R1VCSjlmalhPSGVwMi9GcWxWanZXS3dDdkNieXNYc0pkTkJmTm9LT2QvQkNGdGdxd09lbDF1ODk1SXR5a1ptb0xrK3dSQ2o2QWRhS3p1VFpDTWZKZEF5QjE5cVcwM3ZPSXkySFBzWUtoNXZzbVhKaW1MWHdmeW1iMmFsckpFdEs1V3R5ZC8zQVhxTUhWTGdvNXd1bVc2TXlCaGU1RHYzc2tacHcrbjhUWVphTmRhTndaWTM5Wmh6c3RTbzJOZEtVN1NEODF6U0tCeDh6SlFzcDlYZDIzTUxJaklPclMwbmJBZkJtRUc4akVid3JOR1A0dkZxTFhHOHJKSk92SjVXdk9zb2JJUTVOQjZMOGdZNTNiSzhNV2Z2SG9YN3pKTWJ2MkREc2thTFRpVllXUzd2RFlUemVpcTB0bXdnOG1KampkOWcvVFV0d1NEUnE0blhPUXQyTzBrd3doNUxlUUR4blJEYlQ3aEJINjBzVnN4ejd6Tk45UWpTbjFFeFp6U2RiTm1ybFhTWU9TS1J0VUZ2bzFCSFFWSzZvOENJMXBZdE9vT0RTeld6cEtPZWlLTWJhQ2J5SnI3SC9Uak0zL3NUb0FGN1p6RWc3TVhvVXNXektzODYyQ3Mrd2pXajNPaGhQVU9PVnFySkE0NFY0aVFWUXV5ZG81Q3ZaemswOFhFbXVJK0FCNWtPTzBDZ01RRW1jSmpaRVhCZ0JNVjJzZVZFbE41SnRYcGwzY0ZoQ0tJY3BSN0pyOFdDcWduZ1pqTnhFbEVNamdhZWpic1ZoM01TN010cnZqaW5hUzNMcVpqNm0rbXFtNHgxZzhGR3dVdTFtYVFxZERqWXN1S1NrNVVQOEppZjRTRWJmRzV1bHJHemN2VGlUcDdYU2tDM2w2eWJJWXZGbEMwVjg1MHQ5YkxLNXlieit4WU04anJ0RVRCS1FLTlN1bEVnQ1lNL1pweGFlRmZHQllPOGQ5Nk05MkJadE9SbEo3U2JIdm5YeGdSNWcrMWViS2lialhYRllCVlRtWE1zZXJ0UGRaS05FeDF6TW5QT2REM0I4TEtYUFZuWlZJd0NsMHpiM0Z2Wmd2d3I0QVAxc3RxVFFOdVQ3eHdSUnlNY2FUQy96ZVphWTQxWThaNXFLRkVDVVNxb3RQbkZ5Y3I1WVpvS0p0N3ZFUlFyd3pPdFFKN0pvVGZUYTN2VXE1ajF5Z2Q1NVJtZUlYcnREWlhQYk9WRzZzUzYvQmtQRWcwZkVObFM2TkVCTXVUbmZCWFBZK0xabE5BL3dSTmZSQUJ6c25JY2FGb1JyaVFuNkxwWTJRd3RjNXFQY293T0RsMWxvcWZJYzNIenhNYW5lWjFNdU9xVGVPWUozNHRHM0FsOE1FQ2dzSkkwMlprL2crTFZEUFVtejNvREI3dFdVYURUVmN6eHZzekd0TFljcjJoQ0plMFFRSmg0V1lxKzJhc3JZMlhTWXkyTWhBMTBlMkU2dFB6YnpGZWdCU2ZnOERKbEp0Q0R3ZWNlWGozS0pqQTU1b01jNXhmeHdCb2tKaXNyTGZKbVBjdEowMHRhZDNJNDkybU5ybm9OUTczWldDc0dXeHNwcVU5c0plK3NIa01mTzl5d1ROUkhCRWVrd3d5cFd4b1BBN3JzWVJpQUpTdUw0TGdCRW1CRkVLMkFpY0dPOE9oUlVxQ2puQlF0akdsbnkxcW5LTmt6RHJQYkNYMWt3bjFxM1pZMklOWUlmYkpTeHpvNW0wSWJnM2lHK1YyUC94Y2JLd3cyMm5wbnVMV1IzUHI4UmdLV0FWN1NjUE4zRW1HUFZwWUQzK09ZWmRzaEZ1WDE5dHpjalNPSkRyWlUxcHVWM2JBNTlPTmt6K3F2enBiVHFYdko3UWNIM3BBWmFJWG0wa1lkdmVEa2l5MzdIRFNPSG9GaUhXTCtGczlqWTVER29ad0NOdnkwRmFPK3BxRysyRmdkRDd0MjBRb0RCdkZLTkt4V2JsSW4zdlJpWlhPMFJvN0JUSDA5MmJKUmNUYTBNNWlJMDh3MFpDZ1JCTzlSSVVaRG5NUXJLOW1mc2V6SlNxV1cxOU9LUlpGbnlhcnhDQit3ZmgzNFZiTlN5RTVjMnN1cGNNWjFaTHJ1SXV1bk1DTmFmUno3TFhIT3p6UFdHOUt5YTcvWHdXdmFrN1dUbkg2TzFKL2dqWW12V05jZmJUa0Vqa2R1STVDRGs1NFoxYXUrbHRyWVJvN01Ec2ZvMlVvTmJ4THZickpobVdNUDhsbWpjTUk2TTNkMDRvVkJnalY2eGxnNUNRZWgzblFzYWx3SnJMKzd3Y1p2ZWZGSzEyeVBCZENjdFFZaHJmazFYaGRoQ0U0d1BGWHpjOUxJblpYenVqSWs2TVJUWlNwclFyVFB6aVI3SzV0cFpFTjZtQTNyd2NxNVU2TjQ0bHd6TmdvTGtSelNucDd2NGtUaHJNbmZBU2JwZklDelpBelpsWnI2QjhJdml0bVpEbTRyOE9pSFA4S3JVQXJYa3dhMXdRelJ5WWJRSTFKbjRMV2czTUhJZEU2cklXR1Frd3o1dU8rdG5GNDRJdE5GRDAwZXVMZXk4b0g2aFhzclp5ZG9Ga3NaZ2NiSjZ6TUxwWDBYMkNyMEpEb0NhbW1waURyYnNoOXFFR3FOU1FSdmxtcXF3THlyV1BYTndZQU5HTlpzdmJHQjRqY3lCeXdQOGNwOEcxc1dwL0g1MlF0L3NMTExjeXNCQ29zS2MrMVdJNTZHQWROT0FqYlNXUlRFTVBEaTZCMmVCbnZKUXRHYlAySEQ1UHo4ZVQ0eGVuak5nNVZLZmlyRkJ0bm9IdTJsUFZhVFBQL0ZqZFJlMjFqamQvTFlYcXNlYjJoYXFtUkhWUDQyMkhLeXM5Wk1EWExVTW1IUWlwRndUT1FBakptbGRGK0U3SDZFMTFWTzlWRnc0SlB3bjR6b082UjdjMkZqeHE4c0dYa1VXaXZEbURzclZXQ3RzQVdzcHhvRkwydENSb3M4NlVCVUJobHVOb0JYTmxTemJRV0ROMTJjQXduU1NvbzJTcWFrdDJYakJnNW8wQWtnMnZ6c0FnOTZFTzZ4bVkvclJ5ZUNEZzYveXZyL25IbnFyV3czUk1xcEY2S2R4WGNUREptVnRoVGpNRGQvQmtIZlNpS0ZFNmZaZnFqRDZ4UmZVaTdKRWhleUg5clBkWEFjanExUWxkLzkwYjY2U3kxYmFIb1A3ZVFjck94S3ArVWpHdWw2SHBLaTU3UFFUUWJ2OVNBMzV3bVE0Z2tHck5yV0NZRWU2YWlNKzQ2UzZlRUkrU2ljSzQvaUM1SVhHWHRUQkQ1SU92aEowdFEwSXAzQVNHYUI0OWE5Q1RObmNLMktSV3ZLcWgvcVZiOGJERmpwVjFSTHhRYWhrYlJleW11bXdib25rNGhjMnprMlFoTTFWbFlORUJlenZDV0Fwc29iNXpPTzFqMDIvS01FU2wvdFdaZGc5cXczWUprSmVXRXRLeCtFaDJXR0xzaEdQY0x6czJkVmN1Z29GYmhUOXBncW1jVjA2d243WnRtQURVSFgxdEhtb1JLTmFqTmpBNFo4RXRhZ0F4eGdJc0hyaVdySVFrVkpSckIwL0FBRFVoMHJSMysydGl6b294ZWtpa29IUit5Ritob2RpS0RCRDR2NWt2a3Q0czJXelo4OW9WRk5sL3ZUc2VvUE1kWUtVOUJhS1JTdU5kRk5WbGZ5UlBQSGcrdUFEVzFGeVlEcUtNUjVsaEZTZHBmaEFJLzhFd3lMeHlUN0NERFZTWjQzeU1iSUVJWGlHcVpnTTc0OVc5bFBZVUpDNUZHQ09KMHpHNjFlRW4xVGYvK2ZaYVEvMUZoWCtOamFRQVN2TXdxZk13biswakxoYU12aGFJeitXNG5ZZHlETzJiODBBc3VkeGNPeXFESGp3YU5rZkhMNTgxbVNFRm1Nd2k3U09SMTZoS2U4NFA4bVdiWVIxOHRaRHIwdFcwelNVekxsZlUwNHZjbUlmNVFOL1ZCanZjTEgxdkEweDJRcTVwdkVVeWNZd1VuNDJHeEFkL2FzN3pTSHJ3ME9mTmc3TUVKcEk2MmhZZ3E0a1FpN0ZXYmhCQzlLcXEwQnBjV2ZtWlU2VytvcmV2UDdqeEd6RGc2OGVyTWU5YWNaNjRiTWx5ZDhJZTRiSGFNT0ZRNlhSdFVKYWU0bExkU3dEekFZRTR3WWJOa2JpaG9FZXJrZERQSWkyU3RLOURpV2lWUVNhOEhPd29HT2tyandPRlBEZXpTMlRBbW50MnlrYjlGWTF4UmJOZjJrOWxJeVc1WmNhS2NZbG1sVFRxZ1RzVHRidHNVWnJXd3FkNEd4UmNHNmpXU1RzcVJRYS90NUxBKzI3R0hGZEhSblpidk90VlpPZzJUMVdBRDVhcno2MzhaWVY3eXJaNnhyUVlFYStoSEJVa0IwbjhTb05CaHJIRndZYmRrQjJ1dU53R1ptN0FIYlNXS0RmRE83dVZDUjFRSy9uZ1dyWDd0aHFrZVlLc0ZzdU5XNy9uUmIrZGtYOElJZ2JJMHoxcEtMblpWVm50b2xNRWtrYmxaVzJHcS9McXRFMXdwYk9DaHVBSTYrQ0Y3VkZrSDB4T3lhUWdOdnpPL2dZcmNROXhzb3hmU1dEUFZOR3VzVmI3c2x6VmNicWU0TmYvREUyMTZyUmpXaU16Q3RqcmFNVmxiWnN1Nk1xVmJDa2w0OFBRUEZzMFBXajg3SnNqWUlPcjNRYU8wdDJjZWJOTmFhQVc5STVkWnVSSEFJZGYyOWRzdno2cTFHVzdhbmJHMDVYNVVpYVhweWJlTEdpZGFNMUtNdGV3UUVxN2VQOUFyNS9uU1lkTXZSK2FkNDVNVmJHejF6QmNkcHkwaml6V1JsTHdJenZ6V09DWFRRUm01c3VSUGw2QTRPZGFSVnE0T2NIS3FJNHVUdjJ2UFcyQlgzNTF6UEY2N3Z1MmY5Vmk5OGhYRlE3Tm1JaHh6Tkg5S21NRVRMVnBReU0xdktGTTJXRXNWb2RkbmVXbjNiemFQUWFaaGNxemQvWC8rS3hyb0JENnRtVTJjSWVPcCtRd0EyT0JDREJ1dGwwTktWcUR4V0ROV0w3UDkwa2Z5N3NiNWVFT2ZkY0IyeVZ2UElXZ25oQlhaVWovVzI3QmRsRmFPdWRUZ0pLM1RlWDhwQTM0MzE1UlFhTVdkVHdhYlRsVTJnblZ6V3RLTFhGRkRmdGFuRXU3SCt1UTAzVkNMdjJsVEcybEY5VStHZCthS2R2K3h4LzZkbkEzNDJFekViUWJKNnJ5cHpjR2JHdU9Zd0NsczVPTzJnZmUwYS83cE80OTJ6dmdwRThJNWx0MFc1YmV0ZVU1MXk4bmZ6cHUvRytuME0xdXY5NVFWYzAwdWkrYit6a2I3RGdGZUFCbGZXTkRsc3d1UjR5cTA1L0wrMW9iNTcxaDhMRWRhNmhHK0s4di9PaHZwdXJEL0hhTCtYUjM4MzF2ZkgrK01kczc0LzNoL3Z4dnIrZURmVzk4Zjc0eWMvL2o5Nzc3TGtPTElzQ2FvN0FKSVJtYWRPMzc2OW1kbTB5UHovSjgxdUZyM29rYjczVkZWbUJJbUg5NkxvSFFxRkdnREdxektyU0pFamRUS0NRZUxoVUZkVE0xTzdjOWI3Ni82NnYrNnZPeE80dis2disrdit1b1ByL1hWLzNWLzMxeDFjNzYvNzYvNjZ2KzZ2TzdqZVgvZlgvWFYvM2NIMS9ycS83cS83Nnc2dTk5ZjlkWC9kWC9mWEhWenZyL3ZyL3JxL2ZzUlhlNzhFdDcwK3FrSFF2VjVwcXZ5WHVNejQ1T0hHVy9mQVdhdmVhOFR2cjlWRmZGOGdQeDZvM2dIeTUzM2RuNmY3Nnc2dWQwQzlnK0VuZyszUFpKaC9mOTNCOWU4RXJydjhNZi9Fei91N2JDb2ZmdDMyeWtIM1ovY09ybmN3dmJQV3p6eU9ONCt1My9INVBPVHZoMkxHZDBDK2crc2RWSDljSUl0YzVyZWM1K3ZQNmp6bkM3eUwvYTNIOHJPejY1L3lITzY0Y0FmWGR3SFZ2M0ZXL3UrMm1jenc0NE5ZNzE5S3U3NkQ3QjFjLzA1czlaYUg5N1VQdXB0WTk5R2grbnVDMHQ3Uk9UeEVGM2luQVJFL2tJUnhCOWc3dU41QjlSMVkxMmNBTlgrL0FoaXdmNWpkbjhrRzB3MXl4ZGJmdmhVYzk4Z2hQd1FUdmdQc0hWei9ESEI5cjhYL1dROVJOSEkyQXNibzkzeThaY2QzdmVmeDY0em92Zk9kZ1gwNjg1OE5hRCtzVG5zSDJUdTQvbFVrZ05lRXZWc2dzaGRnOXY1TkpCMmtuWisvZGl3S29rbllJcituL3I0QjBNdjFTZlMzMC9WL1pZT1pmOWI5KzZua2dqdTQzc0gxUndIV0xRYVMzdkM3TmNiNVZnWVdIYmN5MmowZ25RRjh1ZjdzR1grVU1LbThrT0duTi9PeHNDNWFkZ0w4cld6d2x2dWx3UC9SRFBXSFNwVGRRZlp2RHE0L01HTzlwUXhxalEwcXdEcndTeHZ2M3dzNHpSVVlFNEhjclFDWFZ3QkpBWGt5eDFlQmVMd0JtTklPMXIwRzZyZnF5R3NNT04zQW1IK0tFcTQ3eU43QjlVZG1yOUg3YXMzb1lFQm83NG1WS3lpV0RZYVZDUGhLRURZejhPWHJjYVVObGp0dFhJTXNvT3lZYlAyN2JENmpyQUIzZWNkN3MrY3pzTEt4dlVVTDFzLytySXFMTzhqZXdmWGRRYlUrcE9NbnNWZW5MNmFOOXl0d0ZjTWMwdzBQdUdQRkVhdEwyTlpQNjJkVjE3VWVMM3JvaUcyOVdLV0EwVERYMStqR0RxaXpiQ1o3QVNvWmNOelNuYkh4UFduSGU5NHFOOTFCOWc2dVB6VmozY3RZa2pBMjl3QTJ4R0RIRlREbHphSEFaL3oxSVhkTVN3SHRscEJiTndEOW5pUWdPUmtteXB0YkF0QVJVMmFHTzIxYzU4YUFwaDZ6WHFQSkhOc3Q3TFl4TEh4TmhuSC81bzJwWDFrVDA0b004NmZyczNlUS9ZdUI2eHRCOVMwTE1tMkUwWTdaM0hxd1pZUEI3Z0crNkRNandJODJoQnlFL01XY2Q0WlBZaDN4a3RrZkJNd1VkUElPZHNnYlNpdlJSOWs0Wnhod1pRQ1Byb3RMeEVWYUxYYUFkSlpOYnR6NWR6LzA2Mi9icVBSWE9QRnE1ZmJPakhWdlAvM1c3OUlHaTlsNmVOSU80SXNxQkZ5bmxRTXVEdGYzaE5hYVdIS1ovRXhnc2NhV2l3RzF0V3ZNMm1vaEZwZk45V1hHcTRBMUJkZDNDbGd1WkRQTGhwVW5rVEIwODlON00rM2NaRCs2SSs4T3NIZHdmUk5iZmV2QzIxditkSXRNc0Nma3pEdUFkMHVuUlNBbnBBQlUySHlGQWJnUFpJaUd6bU9TTUxralNRUHczVjFUc0FsRThnSldRSXJENW9uT1p5MnA1MXBnTmRHMnRWbkNoUGJUeXZwSjVqcE9Pd0hWNmQ2djdZN2JvOTlHVFB4Vno5UGZCV2gvYW5COUo2YjZtb1RQR2p2dGlGVk5Hd3ltM0JDT0Z3Ry9ZZU00dUcrK0JDRTh2N2ZCU3dVQWcrWWdZRkYxeFpIZTF3TDRCY0N2SzB5TjJlVm9qc2NWenJ1RVgzUDliMC9mNzFoZ01RQS80YVg2UWplVkxPZnBaSStHUUZBM0M1Y1ljL2ZiU1J5UkJyMUZFdDdTK0xEM2J6K0VEZjh0bXBkK3hwTzhrYTN1Q1ovMzd1Q3U5S2VzQU1wN0x0WmsyS3hxa281NXdid0htR2ZkSXlCSTVuZVRoUHhGUXZSV0FIaEFYQk9iaEZWT3djYlRFSmcxaVBYUVVjNXpLMWxZZjM2Ni92L3ZLMEJZLzl2U2QrbjFhUVI0M2ZkcElzNGwwRng3cjY2RHpseGJySnhyK1Vpd3ZJUHJYd0JjWDhGV3R4WmJCTVRZc1VqM01nWUdnQlkrRXg5cGpabzl6NGlUSFVrZVdHWmFROENrV3dJRmlIYXF6TE9SRFVXMXlVbU9HZlFkRjh5ckFmamFIUEJIOTFhUjgwc0N3SU1KNDdPQUhRendyOTNYQWwvbm0rblljZjF1QmR0SndMN1ErNHRzWUZIcDJsWmxSUTdXUzBLY0pOMWFrNDNjNXo5VnQvMnJBdTFQQTY0Q3Fuc05uVy90MFk0U1FMZitmVFlnbGVWaFR3UzBVM0M4cnB5cURVTFg2RzhlcjhCd05veXRKU0FaUmZ1YnpIa3dvUDBUd085MC9QWDlIWDNlUUtDbHZmM0g2ekV4NEk4aVNVejB2OFlBYXd2Z0s0RGZoUFdxWHNwTWRESlN3bHBuV3oxV1RweWRDVFJWZG5tOC91NlptSHhQbXJWV0p5aXJ6OWl1dnkwYjYyMlBMdnNXR2UyOXJDai9EN2orRmVlTC9hemd1clhEM3FJbnViQXJBdVVTaExiNmdMUzAwSTlYMWpidDBHdHp3TFN5WVZpamtRSWc3S29WbHFtc3VURVByTk11bGMxbCtCS29oalRWK3YxSHZQZ0tGQXBwSzF2dHpXYldCUnB0SnBtZ3U0S2Nhc0xGTVA0c3dLNEF5dDF3RFRGVm1FM2hRTDl2NVA2UGNvOEdzemxHdXF6YmZDdW9YNjZmMVdGdVBGTTJvck8xTmJ1bTcrdW1mMmV4ZnpWdy9ZSGFWMW4zbTdEZWw2NFBGMWJBdENHVzUzUkpYZkR0RlpBaWdOQi9LL3VwTE94d0JiV0wrVDdXVDVOb2pLUG9vTXphR2dIMVovcjVTRXl6WEw4N0U5T2Q2QnB3bU0xZ1BXR2VaS3ZmMDVIa01BbndqNWlYYTdFdWVpS2d1Z2pMVE1HOXppYWNUNklINjdtT0JqelhvcUlLcWtjQTM3QnNSMDZJTFNINVBSMTl2MlBIVVdYQ1czTUc3MmJmK05OWE12Mm9KM0Fqc0w2MUFXQlBtTk1ZRmxzQjRyTENocHNWQnRBUTBERVFGTU1JSzJqMEVyNnJqSkdGZlhXaUQxNEVxQ29JbkRHZmdRWE1PNFNZU1RiRTNBb2Q0OFAxdjc4VG8yd0lkQ283N0svSGxRVDhqbkt0ZXZyZXl1S2U2SE9PeExJRytXemVDTDdRdFN0MHZyekpnVmd1NjlFRGZQMHEzK01ENW1WcWRXTzZ5QnJnaEZjeGtVQVN4c3pBZktUckFjUmxkV3M1Z2JLUlgzQWRhekRTdzUzSi9xemcrc3FrVlZUS3N1V0toR0JCcmRYM2JkVVJ1bklvTFRxZkJDVDUrenBoWDgzMTRScEk3NE1KOVRXc2JvbWRqUkwyWi9wZm9wQzNFQUEzQnNnZlRKaWZDY1FWdkIrdm4vc3JNY3hPcnRFb2pQbEk0TW9KcTRZQWFpQjVJQkhydkZ4L1ZzLzlMUGV4STdaYU1LOHlPSW4rM0YzUGs1TmE5ZHhxa3U2QWx6cmV5cVlQZFB5YTBPSk4wRldiT0dtTHF5OVV3M2Z2VDFoNk9FUUFtejRZTU45c2p2T3pBdXdQQjY0ZkpBVkVGbnpSYm54TFFYVkdYUExreW1TNlFJdFQ2U0VMWTJ3SU1Ick1FejJzR2JMMjJXQ1pNTk9lKzFvdGNKYmppeEpkU1k2RkdlckZTQjRGOHlxSmNnV3g4L1gzaCt1L3Y0bld5WXgvRU1raHFodXUxNEdUZVAxMVE1aE1tRDRTU0RONzVPOWxNRHRpV2RYQUpXU2MrQnZOUmo0RklYd1drQytJUzhKY04xMlM3MDhiQUZyd09tdkVQdzBzZmthQWJYOHlVSDF0cHRMdDhCRkRUWUVPQ2F5Yk95Y0NKdzBSbWJYMFpzRk9BcVNzRy9KRGZCSEdlaUF0TkVuWTNrcjRuUWdJV2dHakFmTisvQmJMK3RFaGVGaUxBSFdtYTNDNi91NDc1Z20yVm9CNm9HdDNwTTk3eGt2RlFZWnZmK1g2Mm5yczN6QWY3WDI1L2sxbC9iOWdYam5BRytOQXpQZEM5MnpBdklKQkFYS2tqVzRraGd5NS8xVSs2UW1vbFkyNkVxdFdwQTFnYVNuSkRKY2ZLSzMvaFVoSUk3YTd3MjZ0Q2NkN2dqRlBhcjR6MTdjRGExNWhmOWh4ODF6eCs5N1FKV0dadklDRXdacGRiNFJaakVhMjBBTDBSa0o4TFJ2S0p2UnVDS3owZDRYQXN5RlEwV1FPdjMvQXNqYy9ZNW5FT1Z6MXpwRkMrNTRlZk5CRFdwTnZEMWRBZXlMWm9LUGpZdWVua1lCMW9PczEwZWRmcnYvL2hKZUVHVVFmYmpBdlZ6c2JaanNLNHp4S3RPRzZ2L2lhMU44ZlJlTXRvcFV5NExJY3cwejhlSDFmajJWQ0xnVnNQaUlMdklrMnhNaWY0VXY2SmdQTXpMejN1cnZkNjJKL05IQjlCOS9WQ1cvYkpkYzZ1RnA2ejRCbEp0YjkzQ1VRR3ZsNUt3K0RsdngwOUxNc1RISXdTWVpDRHhJejBDS2hlc1pMdldVV21lQ0FsN0ltbFRBcVFCM3ArRHY4a2JScTZWcWM2VUU5MFBFODRxVjY0TmxJRmx4aU5OTDVQOUk1OTNLZldQZkVkYk9wQUhFaWRuZVFUUzVqM294UWsyaGNQdmNzK20wRjBjdjFzNzdRNzg5MHovUnZKZ0gwbHZSZlhJL3pnbmw1V0VlZ2RycHVTcTRrelVWUkpTQW5CVXZUOWVtRzUyRHI5N2VDNjd1eDJoOGRaUDgwY1AzZ01xc003Mnp2RmszVUUrN3M3dHlDNHV6OEpMditGTERvUkd5UW1Xd0ZCQzBCR3VnaFBjTzNTeFpod254K2pkRnpHM3J3V0NOOHZ2Nzc2eFZVZnIzK3JESzhFNEhyOGZyZTd3U3FpWUNvaHNBMTZmTWJYaEpXekFndnhPanF0ZmczWW5PVkpmZkNzaG9KMnpNQjE0aVhKZ1hXYjc4UXlGMnV4MWYvcmdMNmI4UkVkUU1kSlB3LzBYc25MS3N0V0UrZFpQTk9tQ2ZESUd1S0pZQWpSVVRaTU9BdHY0RzE2aFdXWFFiTW15TmVHem0rVjY2ay9Ld0ErNmVBNndjbXJTTC9UNmZWUmw0Qk1PeHdDaVNHSkFtV0NjdHltQ3g2WnFhSERnSitad0tjQXowSVo4d1RTU09CSUllQ0Izb29PZ0l1cmhaZzVwaUlQVDVpWHRBLzBrUE5vSHVnQjV2MTVKSGUrMFJNckI1RFpjakF2R3VKZGRHUkFQeUN1VkUyWit4SHVvWlZJcWpBL294NURXMHQwWHFXemF1QzRCbno3UG8vcmh2SFpOWkcxYjFQSkcvVWpZT1BuN1hyU1VDUjJXd2piSGMwK24xTnhqMWg3b1g3alRhWWc5RnZlVzAzc3ZhMVlzUlZrZ0N4Zis1N1JJenZDancvWk5YVER3NnV0L2J2NjgxM2JEUnRMQllZbHVsMjhnenZxalFZcmJRSWV4eUREVUcxdTlZa1hub0oyU2NCK1ViQWJTVGdIZVhualdpY0RZWDRCenJtY2dXY2pzQUVKRHYwQkt6T1VyQ1Q5NEFZNTBUNmI5V2tMM1E5andRK3JMME9lQ2tMTzV0TkpaRWN3UWsrbldoUTJTdkxGRWU2bDdVY2E4UThjYVV5QlVjL0ZlaWY4Rkl1MXNzbURHTFZtZTdQSUJ0WFE5OFp0VXFQb3FOcXU3SStEMUZDbUsrVGN5Y0R0cjAxYnJFNy9FdHJzcDhLcmh1Z2V1dnNvbUxDLzdLeDY3YkN6RndveG1BQVlwcXVQcFdQcHpIc05SR1FaY3hyUjVXOThrUEpEekNIMmZ5ZWdaaGJaWE9QRWlLZk1PL2ZId1NzMmJSRlM2a2VpWVV5ODJ3a3VaUkpydmhLbThkSVRCRnlQcU1BWmtNZzJ4SlRMbkt0SHZHUzBLc3NrcnVSYW1uWUYySjdIWUUwcjVNTGxoMXEzZlVjdUFsaUVnMzNMQnZhV1JKTlgra2VBUFA2Vnk3ZEd1ajhPUnJvUlJZWTZMaWU4Rkl4Y0JFSmlVdmlFakZ5bHlpTjJtY2JJMWRNSzVxcm01ancxdWh6VGZNdFB4UEFmaHE0dm9NVWtGWkFlTXVKSHhJS1o3TTdOMWg2bTA2aVZUbEE1cUx4Z1lDMG9ZZFlyZmdZWkpLQUZ6T3JGdk5TSmM2d2Q4S3FPbUtvRXoyVS9MQTFrcWlyUUZWMTBDY0tadzhBL3BQWWE0TzUwNVltNm1vWVg0SHhTQ3lTei9sTWNrTlBRSHpFMHZXS0l3Tm00TXg2QzRGK3BtdjRUQWtybGtjZzErZ2dtaWxYTWhUTXpWYVl3V1Z6THdvQnBMcG9OWmhYQk9pL3RRUnNGRDIwbHpVOW12VU16Q2Z6dXVtL2FpTEU2OXFSRFRXWEtVR09RM01YQmUrWHZFcEJWUFJEQSt5bjFibSt3eGdXTjNSdjJxRzVScVlaekZUVllXb1VSbndrUnNHZ2VDQlFZT2JBTy82SkFKTkRObTRGYlRGM2s2cC9kOEJMMmRWRUQ5RWdBTU9KRmk3RDRXTDRqaGo1QmZNTXN0cmxWVDN2QWZPNnpRUG01VnNnWU9YU3FZeDVSOVhobWlUU0RhK2VNeWU0dFAzelNLenpqSmNTTEFaU0Job1EwREVMUEJLd1p5eXJLclF1VmJWcDBMM1U5VlIvZjZhZlBXTGVGcTNucUpGTFM1OVJ2NnMzYTU1QlBZbEdtaWpxNkdYVFFCRFdqMWlhb2hjRHlCRklhZ1BEZTRKcWxKamI5ZmwvdHRQV2o4WmNYWkxKalhWTzhOTXZNOWFkNEZQd2VhT0VocG1TSmtrWUp5Z2hraVF4bE15RHpzbWZiTjdUaXpaWjVIZHNzc0p0bmIyRWN3MnhxQ094MG9FQTZwbkE5MEFQOGtDZ2RMNCsyRFhrcmNENkR3SzNDWDlZRGc1WTJoUFc2L1o0RFdVTGdIOFJXRDNTcGpGUllrdU5ZbXBZZjZUTmdYVmIxaC9Qd3JTZUpSSnBKVExnSHYxNlhaOGs0cWdnZHBUTmtST05BNEgrUkp2TVNPRFBkYk8xcnBWMXpaN2VlNVpqNndUazFNdEFrN0FjV2JVRXNKSFRWUlRXN3pGZmFZeHN0c1o2eTQzUC9rK3Z2MzQ0dUFaV2dWc1gyeFhZVHp2Q0JkMUpGVmhaZzVxd0xQQm1QUlFDbnBNd0x0WVdrNEJESzdxWCtwUkNRdmhlR0pTR2s0TWtvSGhSZDhKZ090SlB2MlBlemNXSk4yNXpiUWgwS3RqOWc2N0RoSGxOYW1WaVh6SDNPMmhFZng0Tm94MEk3SUI1ZVJsSFV0OUYycWdTeTZOaFdMMHc0Vit2N3pzWmZmMHM0Smd3TjFucENPeS8wMmR5NkEyNmJ3ZEp2bjIvZ3ZzWmYzU0NWWURoU3BBYUpkUW1pMEtiMkNnUlNaTFFmNkFOaGszUUh3aWNkWUJrUi9mUE9hbHBoMWlXUkYzMGpESXc3NW5LcTFGemVVZTk5b2NEMlE4RjF5dXd2bVpIMnNwRUF2T09HZWNRMUFnajFWN3RzcUl6YWVLaWlGNTVJb1lVRGRvN0VYZyttZlBoTHFsUlF2OGpscjMvU1hSRzFZcnI1enpRZzNxUlVMNStYMmNTTTNxOXZsMlBwZGFCVm0zMmhMbHhTdTBBNmpBdjcrbEZjOVZrU2tlc2VaSlFQVk55clRHYlk5ME0vbE0yRkcwUmJVVWJka21lbGphSjc1S2MwbWpsSXV5VEswTXUxMnQyTUJFRjMrTkJKSzFXb3BsSmttSEphS1dzQ3pNUW51SEh5SERubHlhNDFQR0xUYjNaeUtjSTBTaFlieTVZcXluSGhvYjdZWlVHbjVyQWYrOHZlNmZFbFJvV1I3dGhOditmOVRZM0lkUVY5TGNVUmszd2J2YjhYaTdYNlNWME8xNVpYMzBZQjh5enpSQ1d5UzJrZFk1VFRjTFVESHhEbjNmRzBtcVAyU0ZubmdjQ1cvWStIU1h4eGhuc0V6RzhFMTdLbFA0RDh6YlhiQjdZQjJLeWxVMFZTbkFsa1ZsWWc2d1ZCUFg2WGVoZTl5YkU3K1YrRjJGNVhLSUZ1Z1lOWFJzdXd4cElpK2FIL25mNlhxNDQ2R1V6NGlpRFA0TzErQVBtWFZuYWJqcEtwTUk2ZlNPZ000cnVyRzNNTEU5QUdPSUE3MGZjWWo2T1hObXRJejdhcWp0aGV6cnUzcXFneU1QalRYcnVwMG1oUHhpNDNtSzBxNzN3ekFZMHZBRjhQZWxFSWZPVFNiWU04amVUYUtzWnk2d3dsMkRWeG9BdlJrT3R3UEJJU2FzRHNkMGlEd1d6bUtNOHVOeCtlcVMvZWNEY2JKazF5d3E4b08vK1JzdzhpN3p4TENFbWV4ZndlNmNnU1FSNE01aE9rbWI4Z0UveXdCWml6Q285OExXN1lEbldKUk9BZ3JSVDFrelppUHRJc2tvdEFmdVhpWnl5Z0g0OTd0OW8wd1pkMjA1MDBBbHppMGNHbFRQbUhoT2E2V2RHK213SXcwWElDT2NCMkhKUnkrU1VXWFlpZ2Vrek9tSGJlQWJZSGhDNjFra0o3SitRKzljRDEzY0ExbWluY3hjK213d2lTd0xzYXNTRjcwVzB5OFpvZGowOUZMM1oyVGtqZnlZUWczbElHdEhDdURieFJHRmtJV2JhRUFDQTJPWi9GYWJISmkydU1QMUNqREdMekRIUWRYa2lKbnlrODFTWHBTSmczc2w1UWg1NjN1QjZBWnNSM2g5WHA3dHlDMm9yWVNzWDBldG5hd2tkcytDV3dPSWczM3VXaEUyTHBRVWhoL2RjOS90QWEvSjhCZGhPMWwzZFlLdDNBRE95bmpiSFFkaXZ5bURxNlpBbDBYbWlEZVZaanNFWkR3MHJvTmZJdWV0R3FkSGtoSGl5UnBUNWJ5bnBPdUoxalFnL1ZKbld1NEJyQUtxMzlDQkh2cE9SeVc4bklibHIyWE9lbFZySVhZajE5SElNbWh6aXo1bUltWEdtdWFQRnkvcllRTitqRWdNazg4dmdPRW9pNmtuWTQyL1hFTG9WelpnTlQ1aFJqdkxncVpOVG9jMkNHY3lCSkFXV0lFYk1qYSt6c0RJR0lNNHFNK3RtN1JtazRSNHg5eHR3SGcvVjFwRExpdFRCQ2hKMnQ3SVdCZ0tsVE9GK1MyQ2VaVE5qMzRJajV1VjN6d0tBaFRiVmJ5US85UVM4U2NMK1FaS2M5VlY5RVg3RjNCdUNRZlp3ZmQ5M3ZGUkM2TERJQWNzU0xmWEhZRFB5TStMbW1laFpLeXZKWmxlbi91a1pwdzlQNXIvMUN6YUExYlZDWWlWRXlJaDcvOTF1R3MyU21pU1pVUmRmUzZ6MktRQjFIb0EzU05LSHc5T2paSDdQd1diQkp0RzFUT3BDd1BQZnJnL0xTS0RINThzMXRFZHpiWk1KanhNQkliUEhHb2J6ZTBDTWlRdlFUN0o1TlpJUXlwaVhnejFpWGc2a1Bxc0gwY0lieVJ5N3R1V2VnQ3RqNlkzTElmOUVZREpKK0p6TUF6N1FjZFdXNFI1L1pQaEhMS3NkUUFEVlk5NFNleEF3NWFhSUN4M2piMWZnSzZMUnNqUndvUFgzUk5mbkd3Ri9Kb0l4U2RqT0RRcjEyckV2UkVPYlNSOFFHUzEzMUlZR3Rjd2NUZUl5dy9zcFhMQTkwWGF0anYzZHZXSS9DbVRmQks1dmtBRVNsajN6YTlOV0FUK2VtbTg0ajJvdUVwcVBBaEpjbDVvbHBLNjcrQ1BwWHR4M1hwa2xUK2JVY0pTdEFoL3BPN2ljS3N2M255aVo5Q3diU0kvbGFJLzZBSDZuVVBLM0srdjhhclRZVWZUZ1RxNTFqM245clliaWFrN0RZV1oxaHVwRk8yV0cycG5FRFRjdnFHY0RSeUM5YkdhRDNDdnVFanZJWmozQzF6enp1aHNsWWlnQ1pEb09oeVVHdG5zRXNkT1c3aytSKzk0VDY3MWczZ1RDREZ2YlVJOUdmMlp2aG91d1MvWWNHTEEwNVZFTm5CT3IvTjBRaWNqOVBhOHQ5U3dlUkliNHMxOHpnUDdod1BXR3BnQUVHb3ZMUWlvN2ROcXJtdytVemM0M21RV1FqYmdQSSt4emVZeG14dXZ2SHpEdmtUOUxva1ROWEI1RWtyaGdYajNRa3U3Yll6a2ZpNCtaUFJBbUxDc2ppckFiRUxpM0F1NVZrenNZWUd1RU1RN3dYVmpxY2ovS1o3a0pBcE13NmtsMHp5L0NaQ2R6djdTbEdNTGt0WVN1eUViRm5WVVhTb29WK1ovcWtoT1d0Y1VIV2c4WGMwemNBZlVOTDk0TlNUUnRKaDBYQTZRMVVYbWg0K2dwOGhsb00xS3J5bUt5K1ZtWTVnWExya2JXcEZrRFR5dUpMUFZHSGczekxEZEV2VCtkUFBBcWNLMXRaZWtGWVl0azgvYThNdUxKbEduai9TWEl6bWRoSVVlNnFXTUFwa2tZUUExZFR2VGdzN3VTdXRaUDlONmVnT0ZFRDg2WlBxZU8rSGdrUFN1UjdqdFFpUGtneVNBTmxTY0JHajZuQTJtQUxKTjBrb0huenp6S05XM2xnYXliei9kQXd1REVERzlTV2wrczRNU0FDTE01QWZPeXZDSk11b0VmT0puTXZVb0dVRnpmUG5zWnNDekFvSFlJem8zL1BZb0VreW5hZWFMTmlUdkJNdVpqeEo5SjErZUVWeEg5VzZkQzFQdjNtOUZLSnl4SG1ldW84a1kybFNLSlBRUnlTeVF2UkJJRXpITzloUjBmd29MZk5jRi82NGQ5c01rMVAxRHNTbDhvMU9LU2tDVGhwY3RRWnJNSW5FV2VEZ1RVRXA2QmprRXp5Q2RpQnBWWlBOREQrUnVGdGMvQ0NBNllGNFAvVGdta0J2UCtlSDVnTzNnVG1EYkk2a1krdEwxaEZEeVNScThqUDlnSG8xdnJTRzJ0N2hpdzlBMnQ5L1FCODJHSE9wNm14N3hldGhpZzFXcU5qT1U0YTY3bEhFU2JueWhScU1NbXVaWlVqV3NZcFBpN0xoSUY5QUs0WEk1M3dvdUJ6amNzUjMzenMxRXJFYjVlLy91cmJDQmZKS0dxOGxVOTVnT1d0ZGdzUzNGK1FrMlBPSkpUeWFBeEVhWk80eGpoUnllcCs5eGUwTDI1YWtDQjlUMzlDRzRDMTFmNnNEbzNxeVFaOWNqYURBUkFKeXhOakZ2WndkeFVVdzdkSm1FcExURVh0Z1o4eEx3T2M2UUhCUlJDODRqbGtSWTFoK1RmTUhjODRqcE4zaVFxRXp4alBvNkZrMFlQd2dSNkNrbTc2M2NkWldHcE5XQWppYVdSS2dRYXM4bXh2MnNoNXZvUVJCYVRpU0kwU1ZFMk50Wm5ra3lLWVQvS1N0VzNOSXMwb2Y2bU5abnpWWTVUb3pCdEZ0RE5kc0t5UmJvUnJaS1BsWk41alNTYWVzd2JVcmlFN0NSQXlYWFNHZk9STTl5c01naWhxSkhMTStiajBKOUVud1htTmRSYy9YRXgrUTRlQnpTWjZDRUpxTHNob0M2WGtveG1qaFhaNE0weXdzL0FYSjFjMEpnTHBXMlJ5YkFMQ0hzcEVqb2VNTGNIYkdRM0hZelcyZ2pUekpTVW1RZ2dIb1FOOVBTK2c3QklTQmhkRTAwSFNjVHd6dDZTUk1EaE9aY0pjU0tFUzhZbUF6QVQ1bldWV1VMTkpIcHlnVzhuaG1oeUVPMjV3YnlNeVkwVzU0a0wzSFduRG1RdzkxNi92NWpqY1pHSytrbG85VUdHSDYrZFpZM3A1TlJCbVBna3pCUjA3ZXU2ZktMUDVPdlhZMmtKcUZNUkJybW56eFF4YVMwdU03dG5pYjQ2MG5nZjVCcGRSUDl2NUxvZTVKaTBYcml5N0gvSmRkZGNSNHZsS0J0bkpxLzVGQ2NYM0NJNy91bnl3SHN4MXowMXJRbmJsbVdnY1AyQ3BadVZGdjhQOHVDNitWRlpRcEJDK21JRjNpL1hSWkpGLzZxZjg5WHM2RndMK1l4NTE5RlhMTHVrUUN4Qmh3UVdBdXhuMFVkMUdKK0cvRno5b0F0UG1halQyWmpkOVFRUWtOQmQ3U2wvbzRlTXg2WTRrSE1UYlJPVzVUVUp2c09IdlFnaWpYNlVEVGthZmU0ZVlQV2ZnQUJOTWxvcUpBSm9ndzI4QXZZVHlWdzgwTkJKVTNYVE9ncGpUYUtqbjJnTi9rOTZkdW94MWJYM1NEOTdwdldhU2FwaWI0WjY3TWZyMy83L21OZnVNamc3andGMk9lUE44N0lpdzYxMWRrVzRFb0h0RDlFaXV4dGNYMUVkb0R0VENYYnl0UXRhSCtvRDVsMG16QkpieWVvZVNDZmlCNWI5TkM4RW9oMXBTanlUaUNjQUhHbWhmcGRrVjMyZ2p4UStjd2pXWU43aTJRY2hiV1VlMWQyb2xuRzFtUHUzYXZaYlE5Z2tRTmpLTll1U0M4ekN0Wnd0cXZEUTZLTXhTU3RnNmRmd25UUkJiU010RXRMbWdMVkc2MlV5ekR3SGJGWnJoYldZSC9MUUsvdFNQZGU1cnpIREhvMjJxSjhEa2d4WW03eGc3dGRiSkZrN3lpWjl4cndMTFFzNDgzcmdTYlJWOG5nVVdXZVVaSEVqaWNzUnZwS25TRVEzN2dCTk5rOXkrTERIZStSUFo2K3ZCVmNIaXBDczk5b1FNeWRTcDBDdlRlWWhnR2hjSGVZR0pocXU2cGpoRTJtSkZiQWVzRFFYZnFBSHRoZEdXZHRHRDVJVStFS1orb3o1OERndU44c1N5aytZT3pmeFNKVnNHRHpiOEIwSnVObnZ0SkVRL2tKTSs0aGxYV01taHRVR09wZHEzQXB3alRBS25kUTZCZ0I1SnQyNW1DeDhsc2hqTWdDbzhvS1djZW52VkhLYWFCMnAvQkFOK1J2a09OZ2tSeXNWMUlQM3lXakx0WmIxUDY0UlVOVXluekFmYy9OVndtMk85RWJhMk5WRVBSRXJmY0t5WWFLYTczekhzcjY2RXBLTHJOTXN6L3dvOHR3Z2YvK01lWWZlaUtWckd2c3JYL0IrcFZrM2ZjYWIrZ0QyL1BFcmphNGhENWU3ME5ySjB4dndQV0ErN1hNeW9XNlJIYTB4NE1vdTlVbCt6cDlUZCszcXlmbUl1WDNlU0x0OUkxcVZNOVpnY3hoMnBlS0tneE85cHpkYUlqTUlCdUlXdnFnL3lkOXA5cDhIOFUzbUdpWDRLUTZ1VFROS1RQSEQwaG9RMXV2a0hNdGNnOG1JMkx6RWZRWXo1eEpzRWhuTDJXck11dkxLNTZoSDhDalZBYXkzOTFnT2xtUnR0OGU4dkVzOUw5amp0Z2p6L1k1bDJWdWlEWnZycjc5amJoYnpRTjlmSllkZk1KOUkzQXE3NWVlNkkzRC9OMVB0b0dWcVI1RlVzdEhLVldkMUp2Y1J3WHVOUFBuRGdldlcrSWZJbWNwSkNKcTRPRkFvbE9SR05DYUpjcFR3cU1HOEY1eEhuZkJOMUt6dkEybEsvT0Jwb3FnbExheWxyTDJXK1hBWldRWHVhSERpaExtWjlFak1Wck9xREt5Y0FHTlErcFdxRjlRVWhkbHprcXo4S0hKTGxxU1BBazBoTnBSTVlxeUJIOE9qbmdmSmhOMGFYdXNFVkdiTEx0TFJqVTdCdFdEZHBUOFpoajdDVHdUV0RTMUxGREZpYVFONGx2Qy9rVTI3dHE5MkZNNmY1TmtaSk54K0pnWTZVRVR3SzViampkaTc0VVJNK3B2SUIwVTI5TytVSTBtU0lDNml2VjZ3ckI1eEcxd1d0bnlRSkxEekhZbjAyamN6MkUrUkJWNEJyc3BRa21Sbm1XazZONTdJY2FmRnNodUlIWjQwRTg5R3Y1RHNaU09mMllyTThEc0orTnp6WFNpOExzUTRHUmlCcFZGeWZYQk9FaDV5QTBRSnd0ajZzd2ZNMnlNN3VkNjlZZEF3TEdyQzB1TTJHK2JBUUtmMXZXdVdjaWxnc3BPUmRianpLOG45NVg5ZkJOQXVrcDEzWU16L2Y1Q2tGSi8zNzNpWkdqQ2E5N251TUdYR0UvdzRJV2NVem9uRlNkWTNTdzA2VVZoTHRaS1JHM2d5QVhjUGFrSnp4THh1bkZsb2IrNmpIbE9pQkJtWFpEWFhaR2VpeExDV3FMVm12Ym82NndIeGNNUjM5eGo0ZE9hNlF4TFkyZ0VhV1dSdUFiS1o4SWlsdWNlRVpjZk9rY0tVVm5RajNrMzE3OW50aUVPVEF6R0ZFZk1TR2Y3dmlMbTdsaHVSM2RQaU9naGpZWi9OaGpUVFZ0aE5UMnlDOWVZejVtVlZXa1hRSUc0eFpPWjZOTWttbUh2Rjk4ZVpvRFFyK3JuN1hwZU5MNklOcGhYTnRKWGtvS3RBY0FrdzE3V2xZU2F3dEhSMDE5TlZEdFRtZy84aWlaM0l6NWE5Ykhzc3ZTUlUyMzdDeTB5eTBjZ1lvMXc3M3V3ckFGYWQ5SjhFbUdmUndkbUluQ1d3SjNwT0hBT0ZlV1lCYnorWUpiS0wvRVhTU240SFB6VzRFckR1bWY0WVRYN1VRdTdHSkVPT0pxVGlNU0NqaEFDY0hlY2FXczIrSDJRUlpzT09hc2p5NWZvZXJnYmcwaE1kb2MzZ1BCQVF0bGo2QUJUTVd5Y2ZSR3M3QkdGNE5ySktDVUNCR1dCcndIS1N6MjZ2WVBBSVgrL3F5cFFta1dhbWdLa21zK0ZBbUtHNnpPdnhKcnF1a3duL0M3eVJER3Z2a0EwRWh1MFhjM3pPOWQ0eGVrM2lPYURUcEJaZlg2MEd5S0xUcTR6QXJKYm5yNTFsbldXNXpnOTBibHhucXhhSG1TS2laOHdiUXJnRWtac3Jla20rRnN4SGd3UHpRWXRhZTMweXNzWWtFVllPWkprMURmWlBMOGNLd1ZXQU5RcjdrMWxFWmVPRTE4WkVkQktXSlFueEp3RUxIWTE4b1FYeEJTOVRVMW5QYVRHZlp6OWVBZVlzNFBKNDNhMEhXc2lOZ1ByUnNLR25LM3VaNkcrTGJCcThjejhUS0dmUkh6TjhMYWlDU2dOdm02aWRUY3JnRlZScStkbFhvMTJDc3R1TjBjaVZPWE8zVld1QVhrUHZiRGJpcU5NUDhFWWhDYkdKVEZuWk1DREhwQ0UvVnBpM3lneU9zVTJpcVFKejR4clZuN1dubjMwUXRCR0ZJeWkrQmdPdFA5RGYxb3FTSHZNcEZ3ZEtZR21KMXlOOUIrdkNmRDdmaGFHNmNENmJxTFhGdkJGSVBZWXp2R2VzKzl4M2F6QjRqMVpZQzY0YkdtdkNQa2NiWUZrNmxFeGlJVXMydHBFTHpQM0xqM2dwZ1hKRjZLMW9oRVVXOVRNeFIvWVllTGorcmc2byt5ZGU2Z0VIQ3UrUHRFQlBvbmx4SXFJK0NOL3dVbVJmVzJPVFBGalYwYjgxdTNwcmR0OWlFbnVUMFZjVnBMUU1xVmtKcjdRQlE0djQrYjVjNko0OTBYdS9ZR2x4cC9XWXJRQlRBMS9MdWhiV0Y4UmVDakFBNmRabk1Va3VtSVNMUzhadytac215eWFzbHhCcGllRms3cWw2TUV6Q2ZHdjB4S09DVHJSMjY4L081djVlNk9mcUNUdEtjdk1zbFFLZHViZWNITlJLSUc0aUtJR3VYWXlNcUpKQ1k4aEMyWkFKZEJJSERCRGJlL1NSNEpwTVZyN2NvSHNrazBUcGhDMjU3Qit3Tk1QV2NMbVQzWFhDZkNvbjVITjB4anYzNzdNTm45ckgxYjg3WU43cWVLSUYyUXFML0k1NURhRE9HT0trRjN1Z0FzdVJKOUVHeDFOYW42OXNHU1pyN2o0elkybkQ2TnBwczBuK0FONEdjQW9xQkdBMjFORWtQQjI0cnBVOXVaQitDcEtvV3J4ZUFnQkZBTnk2Zmh4YjBsclhncVY1eWQ3bmhsa3FNQitmUGtseUtXRmV0dFdUdEtWTStvTDVtUGI2ZXNEY3YvWTc1cFV2a0Vpa0NQTmtYNElHY3ljNExoL1VaNzZZRGNSMTNCV3BJT2dsRWM1L3M3c2E0Tk5sZ1J2TldkWTZYZFF0Q0FSYVdyT29Kc1FOaFF0bnlhd215ZUt6ZVlXYUk3ZVlsNk1rQWR0ZXdLYkJmQnhHaS9sTUsxQUkwMkUrVERBYmdCeWtlb0ZsQlg2UXRFQmRCOFpwd29hVEllcWJDUU1BSEQ2ZDZacnB4dFpnV1JxalpVNHVFejRaUmx1UDh6ditjSmh5R21neTBsQ1ZIeDRSMjFKRzlhYUQwYnhkeUY5ZjMwaVAxTHJSTElrZUJmUXhBSHdueFNDUXdoUmNra2dJNm5sN2tHb0JacEk2YzBzMzA1NTAvNnFwbmlsSnh0T00yWkdzTjFFU2x4cXFSN0NyQWhqaC9TZjR1dXNVM3pHUWFXRFdIN0RmQjNhM0Z2dG5nYXVHNUtyMXJRbk9DRExLenZiT21UY1hBY2xXc3BnSlM4TUo5ak05VWdhVnk3SXVtRS82TExKWTJTTTJHM2JKVTJEWlpxNldYblVDN0RyVEtSbE5pbXNTSTJETEpsSG5PcGxLd1BvWVFMVlhXM3ZFZXdQcWVjYzlyZC8vN1FxMERqQ3JnWFFLZ05xMW8wNm1TaUFIckpxQjd4QlVCcWhIUWxsNW1CRUFkb0d2citWN05Kcmp6RmlXZ3AyQ2hKdUNPRGNLWk14SHlJekM2cXJjMVFtaDRWbFpXWElWVEJST2xDc1lLR0hXNDhWemxpdDNzakRyTE1mam1pWmdFcUlqbHFXQ2VVZFVvSk5IeW1jQTZ5M2c2aW9BbUNWeUVUN1BCZUs2MHNuUWVHVUx4VEFEemNxQ011SzlKTFRxRFR1YU1KQ05xWk13c3dsemY5TUh6T2NqMVRITGtIQW9rWlowSUVuZ1FSamZCZlBTcmtpTTE1QitFbmJ1OU1mR0FQQmtrZ0hzVGNDTHJoRXBoc1BhemlUU2RIWlZEc0s2YUNGdk1Zc3AwRTBWa0N2RGVqQUFyNWw5bDNCU0hYTXlpUzlPaW1tMmVwSTE2U1pmOUNza1l4Sm15Z3cxOG5sZ01PZlphbHFQREdHUW9IWElPbXlQdWVOWHJUdzQwZWM4WTI0RGVhUjhBcGVNZFpLTXEvZnBTZTRwbHlTcThaSnVIdHhFNEtLd1lwN3pERitMalEyTk5RT1lQc3h5TU5CYTB3YWxqdGhvRnRBYVRYV0JUZzN0c0d3ZkhMRjBmMkltMFpydmM2T0RLNE9jSk16blkyeHBOKzVJaHpwZ1hrRGZDS2dQV0k1ejBZZXdFNTNZV2VzMUloRzR4SXZPSFdNMmRzRzhHWUkzTmkzdFNxWXFnV2VDcmZseFlrTXV5UEQxcEpIV1dGYldtYkpHOXdCUDVqaDR1TjcvQytEL3diS3pDVUdvcjV1OWh2YXNoN2J3TmR0NnpMcHhhTldFR3B0a28wR3pqOEVGZm9RN08zRTFBc1J1ZnR6NVNnaCtrU2lObjZVejVnTXdCOHc5YlRrWi9aVVNtMVhuL1VJeVJEYkp2dWplc2RRMUdoTGlUSVMwenRuSk4rV2oyT3BlY0lYSlFJL3k5NjNSUmdCZjZxSkpMclYrSzhRNkc4eGRnRlNqN1dUM3lzSThjVjBzdllqd0QzUmNQWlpkTHBrcUF5Yk0vVngvdlg3dVY3bkpPbmVyK3JNK0V6Q3pMTkdzYkZ5dENlVVZoS1lBdktMV3d4UXd5MHhodms1VTFkRTVRRnhXcC9QRm9uTXJLOXJqMnV0M3pPZVBZU1h6N3pSUG1GRFRWUW9vRUdiRUxseVRxVUlvd2ZjQXZveHJNdUFhZFNsR21pOTNmZWxnUUdiQ3ovSlpIWUZoRGVkNWpEc253TFFwZ1gwRytKNXdKUTB3SCtpWmlXQ28rZmhFVFBwNFpjUXNyMlVCU1dBKzhwdC9ObUxkQ0dxVnpYNFl1Qm81d0xsVFpmZ2haeEVEY1pNOFZWczhTR1oxd0x6RUpBVmhRRWMzVEhkVEhwZkI4c1JCMktlYVQ0enlmdFk5Qi9xZTJ2Z0F2SlJ2UFVnWWRUSVBHV2pCUXhhejI1aXdBaEpPWDB6QkpyYVc4WGRUVURuRXJCdlAxNVVzN3haSUpnRUU3QURYcmRuMnlXaXZnSGRjeTlndWlZcnFzYU5qYzAwYXZYekhoU0tXVVdRVng0b1ZCSFROcXlWamxCamp4T1FnRlFLVkJKeEZycnJRYzFWQnQ2ZmNBQ2V2dmhJVEhURDM5V0F6b3NzVkxEdVJhRGdhN1UxWTM1aUtnQnhVZkt6VjNFZFJFT2laL3o4UjVvZUFxMkdzMkdBWkJjdmFNWGV5cmlBN3lVbXhoNnJxU0VyeHRmaVlRWjRIQXZZU3hqN2l4ZTIvN3RwUEZPNy9qcGM2MkFkS0ROVGsxU0FDL1NqZzFsREl3MzlYditmQmhJcDZrN041U0NaNEwxVnV5V1VqWlRZL1BtSmVJcGF3N056SzhLTTIxQTFLUWYrSnJ2ZWFqcG8yZ0dwck5XLzFraGRzbHdidWtTRFVzakNidGEvdmdXeE9yTjF1NVMyS2tRVW1rN3hOV0pyRThISDFFZ1ZPWnNOVWc1ME84eEZCVlQvbERzUkNqUFpNejBsZHAwK1lUemw0SnNMQ1Jra3BZTlhzUzl3VGVSa0M0SVRSeEpOaDlCcmRiRlVOekdwZVB3TmNDOTdXT3ViY3JpSU5KSnVNSDRlc0xEL3dqQ2xkNkExZVJqRVBSbktZcmxscURvTzRkckNsdjMyZ0JCYVh2cHpvUFIzbS9nUk9RK1o1VXRxaHBaVVcvREQ5VHdEL0RYTm5KSmdzUG9kOVBaYStBdlZhSHdNRzY4cVZOR0daYjZnS3dJNUZqQlUyV25ZdzlqWGdkYlc2WlVWQ0tBSFlzckhJbWttTFNnREZ5Q3N3U1pnY3lEQmFCOW9HWWE2VGI1UVJONkp0WnRGN3VVcWl0cXRPUnBMcU1TLzc0L0l2R01BR2xsNEpPc3l3cDJ2d2pIbWJPNDhDSDgxR3B2bUdiT1FaQ0xhTTJHbE4rSm15d0Y0Z2RRZmRJaTdTZGdYQnp0T1RnYW1CcjF0c1JYUS9VbUlzU3dqK0ZmT1o3R2NDN2VyK1B4SFQvUzdNNEVoYUQ4OEYwcHVwaGQ5OC9xMkViSkJrWFYzNHYrUEY2K0FrQ3ptYjdQcGdFbFFObHFWVXpyWXdxZ1JaQTlPMHdqQ3FOSEpheWZiZlVvZTRabE9wVEMwcVYzTVJXSlFJSytiNnVocFdaeWFrMnVrSTcrc0F6QjJ2SUV4UG54MnRGeDB4cjhjdUlyMGtrNnp0c1RTVDRlUW56OVNxWFZzUDlIeDl4OXdrYVNDU3dtRStlMXpVeUkwYmZ3Yk1UY2taa0FlcVZIakNjbXJCdENHRkZmamFZd1Q1bjQvWFhLL0FtaEJQVkx6bEFWRm5JN2RZbStCa2k4bG9xeDVXYTAwbjJma1NnSCtuVUlVZGs3aTFsTXVVR2dMWVhqTDVQSStvaGtZSGtqRFV1cStoejVza204eGh0cFlJZGJJd2UwbVdOWUUybCtDSDlZMVlOa1pvMlpTV0tPV1ZVRDdkQ0lwcGd5bEdMKzRhU2p2Q2EyRGQ2bktybnJGc0FMcGFKSlpBeTQwK1l6TGhlb0wzZmVCMllQV2V6ZWJabkV6R0hTWW5razBGQURlMjZEMGFLQkhMWmtwYXJsVVR4RWRLVXJFUDZ5RGZDOHpiNExzcldIT0Rqb0l0REZ1TzJvTlZkbHpMVllTeTBrZkxBcEZXdWhVQ1J1RmNWQWpPdXc1Ym1Ha0h5ait1TytyM0lKU3Q5YVVQdENBR1lhMVpHTzVnc3BqMXVCK0lVVU1XMXhjS3dWdmFaVjFvcU8ybFhGV2c1aXdObG9ZVkdVdkQ1QUx2VmdVczZ5WTVMR3cza2xwcDVYT2p6cXV0Qk0rRnJpSE10ZGEvL1EwdlhWeHBRejdZU29SdEpjWDJTQmt1MlRUQmU5Sm14RTBPcXRVNlA0ZkpBTFV5VVBVWDRBcVgwZHduWG04WElpSHMrYW9iQkFNaGo5K3VYWkpuV2R1anNOK1Izc2ZkZGZsNmY3bDVncC9MaXh6N2FOYTdPckpOb2szclZOK29ZbVZWai8xb2NHVzNtN0pqTjFBekVMN28yZXpPUEJlbjZxcHNvcUx1L3l3UGNCY1Z6d1k2eUs3VVNnSUtGTlpmaE5VTkFxWnNIRkVUVlArZ3pDY0w5MG1ZYW1PRTlRbkxRbjFOSkdsdEk3QWM5QWZNdTdWS29GRnEzV3J0Ukd1SWlXQUZUTk5PQUl1cVJQWnV4bXVaKzlja3YvNFhnUDhLWC9MbGtoNTdnZGlGbjZQSVFUcmdjVXRDeVFFSXUvSHlVM0ROVkRNRjVxVjFvNnpUWWhKcHJOTS9ZOTRVb3phZnpHd0xQYS9maFJSVjdMaGdXV3ZPVlFwOHZyMUV1aG56eW9XNlFUQ1lPMWx1d25hSjMyb0R5MmN3MStnVlRXck5wQ1UrU3dKbkNnQTVCN3V4bWxIb3NEaDNnWG54SG1oeC9STXZNNGVxNXZxRWw2Sm1MdmF1M1NmWm5HL05hQjRKNkhrb1d6Vklia21xT0pyZFY0Mi9PUm1nYzRLcTF1cnFXalBpYnFKVy9nc3NKN2hHZ0pwdUJOUmIzcmVWMGEvTWRZc1Y3MW45YTFKRTJmRTNDcXpaUkFmT2dXc3l6TWtCZVRScXhwbkp1ODM0R1M4WmRsMWZyaGtoVWRKS1czQjF5Z0ZQNXFpc3VEWVlUSmo3SFROSUh3aG9kZUxGU09EN1RKczkrM2c4aWlURzQ4b2JpaGhaZ3F1MmlTZlNmMHNRZmJ0RWZmbE1jSTNLVTdZZWxyUWowZUUrb3lVOWt0bEFKNnhTR1dWOUhVaW5PMkJlaG5XZ01JVVpYNjA3L0lVU1dPem55b1l2UEQzelFQb29GMitydnN5V2JlcFRxaUZ6RkpLN0dWSTUySGs1MmNHdG9MWDg2d0R2QjZ1dGlBNEl0b0QyaVpKL3Q0VG1lOEF4WWY4WUdhZVZ1cldjTnVTQjZQc2M4NHVPVzRFeUc5MVdaUmYxSDREUlQ5bmZ0VmtKblpPd1ZnWk92WCtqZk40a01sUlBnTWdEQ3krWVZ4dzhDMkdxdVk1dldKYjBYVXpVeG1Tak4vZHNOUHJyWkJKK0pTQ0FHWEZUeVovQ1hOTUtJNWxXbUswSzEyNGVVVEVoVWlKQTZ3UEJlcnl5ejFhT2dVdFdPbG9ZYkl4ZEFmYUJnS2duQURyU1l1QmtReWJSZnBSczZDUTZMWTloZWNCeVBqMmZaekxhSFVTbkFwWU5GeTdjemViYU16Qlg1cEhNdlVvcjRKazIyQjEyZ09EV3p6L2lWZDd4UFdYak9wUkFhNFZJQlc0RGdKRVhTc0I2SjVNZ2NsSVFzSnlQeG4vZmlPWTZZVm02MXhPUTgxUUQ0R1ZxNnlESks2Mmc0R1R5ZjJCdXJLMm05blhVakV1S3VqbG14WUJzZEsrUzBWdkRaT2xuSmJUVzlGVmdXZlRmWURsblB1b2FhdUhOZ0w4WWtaNjlWTSswZ0E3WDkvOU9uL01MWHNvM090SlplNUlyVGxqT2NIZG12Y3lLR2FRWVlGdlJYQlA4Z0R5V0YzVHhhSWdaallqbUVIOHJzYVVWQXB3WjFudTR0cW1tZDlKRFh3dU9hU1ZoZHFzY3NNVjJYd3YrYTkxVmtFMjBJTFpNakdRUUhjV2lza1EybjVWTTBzbE54T1Zva2FjTFRKUkFWakNxY2dGUHJIMm14TzRaOHdZVDdyaE14SEloMm0weUVneDdLZFRJOFJuekppSTJpV3F3ck9DNWVlN1d1eHUzckpoajcyMHFTSUZtQ3J5VU9mVm1BUlQ1NzVIWTN5aEFWNWxwclRmOVJrTDVQekUzaG1pRk9ZeFhOdmtGTC9ac0p5eEhWTlR6K0MrWTF4VjJwT20wcEdmeHdNSld3cElHM2tHK0RSWnVheGJYaEtYalZXTjJaVTB1WWdXb2N5RFhGR3gzVkFIcnBWRFlBSXN0V2VtakdPeDdiQXBiVERiNjd4UXczQ2s0UmgxeHBCTnNuZnptdkUrNVl1U0NlWWFlcy9MTWlrK2l6M1lFdHJWZTlZUjViZTRGODJrSFdwRXdVaDdtT3ozblhMckY1WWNEbHJQMk9Lb2RNYTkyWUhiN1FGSHBtZytzTXYyWkZQVmVBTHRXaWhXNTJhLzVLSEtDcTk0a1lEa0Q2MEJndzdzVHV4NDkwc2svbVdRU2o3VUFzVWlJbnNWK3J5MHRnRnJDTmRCeGFtc3BUT2lkUlo5S0FyYVJCMjJCdDFwRUFJcHU4ZWlJOE1pVnlqRmgzZ1QvRi83b0FnTnVyeFI0YTVqK1VXRDZGdUNOMm93anhsczJrbTZSbVRnbmVkU1VmRzFTN1FUZmdjYWpXTXJLZlIvaGJmZ21BY0VFMyszRUxQaENKS2pRODZuNi9lOEVlT3hSMEdMcFdYeVdZK2VhYzY3a0dVekV3T1JzV0pHanlvcFU4Q0hzZFF0Y2M1QXhkVTd0b0YxcE1JSTcxN20xY3NQVkQ3YitYWFdYR3VSaVBwQU9PcENleXBwUExTODVZZDR4bG9RcDF6cThlbDQ4M3FMcXNVLzBQVWRpeUIyRlEwZVJHdGFrbGlpSjlFeTZNTXhHcGozdmpURDFaUFRzS0xHMk5tWTZLbG02bGJWKzFHdXJtV0Z2Nit4YXA1bFdDMFRlQm1zMm5NNEp5M1Z0T1VBRWxrbGR0bEYwV3ErNlJvMUJ3bzJqdXBxYnFLV1E0MVZpdXhDN1RFUkNhb0xySkFtd2VreDFmaGV3TE45aXdCemx1ZUp1ekF1ZGZ5Vm5BL3hNTXA1Ynh5VmJlU1dhV0ZzcjZROThMUjhDcmk3VTFNWGtLRFhnaCtacENWSFVXWlNJMFdhNlNaV2xWVkRyNlNaeXZXbk4rSDhYVGJIdWhJOTQ4VHl0STZWYmtnek9ScXVzcmE1UG1KdTQ2R2dLWUc2dXJTODIzMml3TkxIT1dOWTZSdjZvMlREUnhnQmxBMS83NnNBMTdRVFBXMnBaWC9PYWJtRFQ1UldBakkySFRVR3dEYzVYYTZoTEFMQk9FbkFhcWJzLzBSZ2JKU1ZycFk1Y0xvV0FEYnNxQjJhckUybWJkYUFoeTJzOGFZQm56WEhVVnQyenVBNjNKUW1ROWY5L3U3N3ZWOHpidXR0QW91a0R2VDNUcGpFaEx0UDZNUDAxWXE2ZDJXbXg4U0EySXFRbnpCM0tYV2FUeTVwQTJVTVE0MlI5NVN4SnBJTWNNNWM1OGNOUkpBRjNsQjJPLzdhakc5SmhXWGIxZE4zWllSSUgya3pCazEwMTgrL1lySlpJVGZDK3Fkbm9jc0N5eW1EdG5qbkF6RzlralZ0SjBhM1hTQkdESzRkSzczUnNPaFY0TGVUZk8rak9TUUdSRTVhN0wybEZTK1dOZDhTeVBiZXVqU2RLTG8yaWYrYmdPSXZrRjRyUmZWbCt1Smkxenk1WjdITFZrMjdMOS9WTTM5RVRFSFlrOTFXbnUrL0VYaFBtUHJLamlhSVQxaWNSSkNNQjZvaVpkd2ZYTFc5V3Q3aXowWUNpaDlZNTg3QzkzWUZDQXY2Y2puWXR0ZjVMcE9GZVJLOTlrQnVWSkVuRUZvUC9vUEFFV0k2bFB0RE5IQWg0TlRtVkRRczdHbFlXbVltbklGUk5rZ3h6YmF6TzNEbXlib3lZbkhiRy9ZcVhxYkpiWVBWYVp2bGFxZUV0REhyTjEzVXJJUmFWbnJreEx6Q3NFRWJ2alpLTGtjRjJkTHhadEZDc3lBSmpvT3RyQ1ZZalFGNEJiakx5M3JPc05YYTY2aWk1VnF0NXZ0UHp5TG1VbWdRNzByOExsdlB6b3ZLM3RFTTdSNkN4dnh2QU9uQmQ2eXVQRG9iQmJqSTduNElGbSthMnhDcXpTVVkxdENNZThWSnJCd0xVRSsyb0Rja0k3Q0RFN2oxSGVtKzkrYy9DVWc4RXFrZjZ2bHJIZWpMeWlSYUhKMkcvekpUT3BGOEJmMVE4Tk1HaWlJeFlWS3B4MFFFMm1OSmFmZUJIc05QWGFxeGIzN1ZWbDF0dVNMSVY3RGVkaWJwK2lxd0Z0dTdqUEVQa216QWF3cUlodk1weEEzeTdPWXlVTUJxWlQ2c0t1SkxnZ3JrOVp3a0E3b0o1K1ZndDFScEltMjBvWW1UTFEzVXFnNFQySFQzeld5WlNheDdUdDA2TWZSWElzdVZneEZ3YkxDMEJpMG1RakJ1c0tacVIwNGhvbmduWU5KUDVsWGEvUWdCWFdXZHZHQytERzQrTk9HTStYNnU2L0hDcFNyVkJleFM5OUprZWxncm1iR0RSWWVuZE9Vb1lBbm5Jc3RsYytNRnhGUXhyUGY1dUdKOWp1V2xET3BpdzNuVHdaeWEyYm1HcHQ4eXgzMnVQaUEwZE44RTdsZ0Z4TTRBejBWWXpiUmp3MUtHSkdYR3BGbGV3c0JtUlNud2o1cU8yMmFPWXU3VDQyV0xUbDBmTTdRbTV1eXNiaHM1REUvbVluZVhvR0d4d2tVTlk5RjYzQWRuVzJKVFNUU0RyL0Z6MzFqaTJjb0dqSW1iVk9MVGtxb2oycVIwbWFwckwzcEIxamc1TEE2eFB0WmpYKy9FeFBJbmVjNlNrRnpQZWdjRHpRRHZ0UlRUZExraFFxQytDbmdmTWd4TlpCYnJFUlcxMWpjYVU4TTk1bzlnQzFXZzl2QmZBcGc4QzV2ZHNkSWlrZzU0MmNHRGRmRnVUV2Nsc3JPNTlhajBZZGVoQjFyeHo3TmRNdXpPY0dlUTVaY0IyRm9aczBxNjVBbzZrTG5UY1o3dzQzZlVFeXNwRUd6bHVUZDdwdkR5ZUp1dldnODdzUWlESHZldlliUVhYdElId0drcnJQUERXNkpXNjZ5YlNNVk9nQTFVZzQ3N2xMM1JUdVVFQldCcit0Z0xjRFlVbWRaR2NNRGZ2NVRxNVd2OWFTNndlRUJzd04xaTZ2WjhNODNPTkFabEFHbGlmR0pDQ3FBSkc5NE5jendiZVBEdmp0cTZzMStxanR3d2tmRzlRZGF4eXJScm1yZUJmRUZjUE1KaXRlb3RpV1hLVnNPNVhxNnhYMmR0azlQVXArRDFYUzdCbmhnSXZyemx1Qk9nRmhGdVM1WjRvZWlzQ2R2cit3WURoWkRZQkhmODBHa0RtNU56ZWNlK3JjdFFXeUc0bHRMRENjdFFxVDd1Tm5MNDZCVW14amtLQ0hzc1IyZXAvV24vMjc5ZS9yUk5Dbi9EaWNLWG1LR3lxVW12dEhrbkhVWlo4a08rcm9jNEQ1bWJiQmN1eE1RMEJ2SmJRTkZpV3NqVVN5ZzJZVDFQUThGN0hMcnRGb2c5NWgyVzMxNjBkV1cvUldRdithRjc0OTA4QzF4cGVQdXpjRUo2dngvZC9JVGFLdWNXVG9BUkpxTFg3QkpQM1VITjFKOFdwTTFlUmtIc3lESzdBanlFZnI5ZmlxM3dtK3hDZk1mZE40RFdlNlZsaGw3Wm5raCs0SVlDanlFNWtpOUZzQU1VOEV4bStuTXhkYzBqMFBhemN4emZwc0d0MXJtNmFabU5FNThpUlNIdjIzZndnQ0lCeDhvc3RCZGt6bGNPa2Z4TERmYUlrVmdYWGJ5VEcvMEovenp2amQyTGpKMks0SFBMWHoyNG8xT2t3TCtOcTRBdkJuYzZwRCtGYTYybUxkWlByeWhLK0lIWmZjcWJPVWVGNldsbU1FL1pOYnkwN0FkQzlWNDIyYjBsdWJibG5iWVg3ZThxOTFzN1BBV3ZaWUxhdVBJdnYxUWhmLzZ0bFdNVXd6TVlrci9UZkt0OHhPYXJmd1JOYUw2TEpQc2s2MUpwY21IVjR4dHc3aEd0eGVScHpFcDMyZ21WN3ZWWThyRlZNYkszTjhocFpLUUxaclNZQ04wc2RSalBVM25tWUpKZzZaYlhtQmpPVDVmZTV5Z1gyZWowU0lCNWtZWE1Ud1lDNXl6K1A0MzdBY3BaVjNiVWZaUGQvRk0yc2srdWlwaE9qWExNc3dud1NyVWtURTJ2Wi93WnhXVmMyRDJ0VVc3bFhYOTN5Q1hock9kUmVkdm9lVXNQV1pJSTlyYThSc0NxNGJnMVFqRVpGUndZa3JrTlNLM2dnRExONmFuRE9vekpOTmlSU21lRWl6L1IzSVZCY2NWUDlqQmxJdWN5eDFzRlc4T1JaV1J4dFZuYk1YWnA4THExb3ZJTVFnS1Bvd3ZwY2JGbEk1cmRxc0ZFVHdWckpBb0liR0pXRzZBbXBVMDlINzY5RnhKcjRHb21kZ2JRWUJ0Tkh2TFM5c3E3TDltYjE0dk1zckhvamxhRXpvQjN4Ujgzbkw3Undlc3pMWlJqQUdpemJmcU11RWdkUXlURGV2S0dUdXNhQlJ1NVZsTVFxd1hkdmdlbDdoUEcvWDBQUThzYlBRWkJjWXJiOTYvVzdtaDNuVW5ZQ2VWblJUQjJUZGJhYkpZZ00xTkE2UzlKbkNzSjdIbHJabU45cmVXUmo1SU1CUzNjcVpwbzZqNjRROEo0d3I1UDl6V2pNVEdvR3pCM3htR1JvaXkydnl4bzFLaEJHalU4WjJ4TUxIQkN2T1d5bHFGZDJ6eVNDZEFQclVGOEMxVFJVaytYZTRST0ZHTmtrdXpyTVcrZDZBemdIMmMxNUYrU2EyUll2RTE0YnpHdHRkU3BxZzJXOUxwZVR0RVlXVUY5T1hlREsvbFUraVdTREZyRlZZRnBKaU9VYk5GWUgydS9sS2VBMjZRSHoxc2IzMGx6M2d1T2U1TnVlZVZ0N1pBRFgrbHJndS9UV2ttTmF5OW9ZalZhUFJTY1RjSUtvTXpMRVlCSmN0VU9SeDlqekJuYW15SzRYWWdUTVcxNHIrSjVsRStET3lwcndaYnZGMWp5SDJzV25EVU04N1hodDFIYjVLT2E2Tm1Dd280c1gxZk0xZ1o2VVRXS0pMMElyLzMvQXZCZTZ4VXN2TTBzQzN6Q2ZHTURUS0grVEhhKzlzczc2MlRxR3BlcXBUeFNLc092V1Y4eXJDbmh5YTRmNUdBcGdXWWVhNEozbEU5YUhHMDdCVHFvUHBrb3ZuUEJ5a2tEZUFVNWJIUzFBM0ZlLzUyKzNBQzdka3JsZDBZdWRTY3F0VGwxYjB3b2kvWnpEOG9FMitRSExETGMyaDdqeXJtS1NYTVdFOFpEMXBzbmFaRUJHUC84Q2J5SEtKVmJjclRoU1JIY2lRUDZWd0pzVFl6MkJiS0pJbFExWUdzeDlIQzZVb0h3U29nWXNLeXcwMlJjMUU1UmJBZlU5d0ZYWjZKcE0wSml3WnNMU0FZb05IUVlCQlozZnd6ZTg5djF6aVVkSHY2dTZVTlZPMldlQXgzSDN0R0FPbExBNkVCTTlTTmdEMFZhemJCbzhaTzBnNFJaSWMzTEcyUVZMYjRJQzMyUXhiUWp5ckhVMThQV3hHZHZWQVNrQTB2ZVVCZmF5eGx1anFyMUpOYWNWRjJ4M2EybUN6ekZjblZRNmlZYlBJTWJydmpWUjEyUUFkaFJ3ekFFam5ZVGg4VG1NSnBJcXBJc3lBNnhKNCs4Qm1DWEpYL3hESXNaRTJpdEhad05wd1c1ellzem96YWJWR2swVkVsbE83eVJyaFlZdnIwbG9NZk5Ed0FodVhmUkpkckdSRnBmZTJFYllNQU1rTDJ3ZTQxSjMzQ296VkZDcjlhcGZNSGRFYnlrc1BWSFkwb3U0end1QncvSU84NUtvSkF0SHBZSDY4NVBJSkNPOER3QnZSTTV6b0lVM3c4N3c5b2Q3cElHdEpKYTI4ZTZSR2RaQWM1S05PTjBJc0h1Qjh6Vk11cndDcUYwNHZsWVZvUGR0Q3BneFpJTWRqSlNrWUR6UU9tWUczeE1wYU9CdERmbDltb25uYVNHY2VLNmZkN3BHbGhjczIzSTd1VWJmc1d3ODRQYy9ZajRkdWdoalZWK0hFbHkzakhWRGwxZm5GMWJCRlpnMUVlejU0aFFjZk1iU05MZkR2SnlEcFlZekFWYlZhclN1anhmS0NTK081N1dXN2dzQktRODZHNGhKdG5JejZnMWhzTzRNWTFEM3FkYXdnQ1JhYlJQc3dMeElXL2dpOFl4OTVXMzZRTG9rVnpUZ2NLM2phMHRYakJqdEhuRGQ4eDZWVFY2cnVUcTd2clF6aWJFbnVSWDFxMDltMDlCemk1alptb1dobG1STkp0R1Z6Zk9wYzZNR0FmdUNwWmRCd3JLMlhML3JUTzg3NDhYOTdVQk1kTUM4TlIxRW5ocDVuMHFIRndPWVhCSEEwVmxaWWE5TzlvZ0dWcW9oelB1QXE1RUZJaWtnbXJrZVpaMG5ZYXhzaWwxTFFJQzVrVXJWWVU1ME0zb0tUK3AzUFZPWVhtZHFIVEEzNnVXeUVMNENCMWtrcDZ0Tyt3dDlCcGVMbk9uN1QxaldIbWI0Y2N2Rk1IVG5JYUNnTnhoZGRLc2t5MjJBbmZ6TldrZFc5Tm1RWTgwcjBrTEMrM1E1dlZVT0tMaTlqQXlJelZvR0kzdEY1dHJEQ3FCUFJDZzZMRHZzOUZoNytFbXhVY0pVcXlDNDJtQVE1cVlKTG8yT0JwRTJGSWd1OHB4eEVuc1VmWm05a2l2QWQzU012U1NzOUZnUG1Cdmo4M05WQ1UyL0kwTFpzemJkejUyOGNETnpYVHN3Snd3anlMQzV1a3ZPaXRmSkFRdzgzTEhCZFhpOFlHdlhTQld6LzRHWGpwSUgwV0wwK0MrU0pEdlFNWFdZZDZEd0FxNi8rMDRzZU1COFFLR09xWjdneTEreTZLaFJ2N2V5aFFieFBDeGdPVXFrWUc0bzAyTGJ6bkFOWE5lSzgvZklDNTlsN3ZMZVlINXJjcU1ZclJQd1ZTQ3EwU29BVElhOURrWkdReEJSY0paL0ZJWTR3cnU0alNhcHcwWCtXdGV1YmQyOU1Pa0w1cldtSEdrTjhweXJtWFo5VHAvcGUvdUF2T3dkcDE0Q0J1dWFwRDRzb1pVMjJGRjBBUHJnYzZMSm5hU0dycU41MzBFU1FienJuV2xCUE9LbFJDUkxhRkVYejFmTUo3dFdIYWNXS2srazhmREM3akJ2T25CbFR5M20xb0lLV3RyRHJWSUZnbEI3TXVDWGhmWG9Rd0xKUHJjQmNKWVZYZlkxSVBvZVRQU3pnTGpzUEpkeXc3R1ZEWUJtalQydmdLalRwTE5aUjJzRzJKTWhSR2tsdWFZYk0rdWNaeXpMSzdsVThSc2RUM1hGZXNLODFueWczL1BjckI0dmRlZnM4YXJEUEorSWZOWHlSd2U2Ym5PRGJISkpzT1p0Q3lrQTEzYm53aW5tUWRUcHJaTUpoODZHN1RSMFlvOTRLYnNZNlNMM21IZFRKY3dud3c1WElPV1EvNWwyUHZXQnJXejVpVzdhRSttdVhJeGNGODZ2MTkvL2sxaDJvZmUya2tRYlJYT05XbUdiQURnaHJJS0JVWGZYcmRFdEUveW9IWmNvY2FObEN1TDYxcTBSMWVtZGdPNmpnVHBoZnpINTNnU2Frd25LVlhMNmh5UXBJeWxBLzkwZ3JudU5nTGtJczRTd1N1MFdVMFlLZWdhUDlKNmVRQzVKSW5JUW90TmhQbzNqaVBuZ3dmcTNYL0F5dnFuQmZISUJUdzNobHR0TFFCQTZpVkRkTU1KcEI4dTlaVTJHMFpJYnJZMUFQNXdNK211R05NTzNxbkt2UHg4OFgzQXUrK2lJZVNaWmFGeGl3WjFjREJCc3JsdXJEcjZRQnZrclhtcm1EclRnUndJdzBJMTh3TndoaU10YjJJMzlJSW14Y2ozbkwxZzJJUUMrZUZ5SEEwN3c5b09hOUpzTXNHcDAwR0EraVFFR21LUG1nVDBHTG5zei9RV3ZLN2NxTjd4M2pVbnUxVzdYR0d6VTVSWU5Eb3owNkJKc1V1NWFqL0JOQWx4bkRwRzFXSGR0WkYyTkluOVYvZk4wQmJ5TFJGaDFRR0ZySXFwbmlpb3JRZnFPcGJ2VkFHL0R5WlVJazJpMFNkaHFUN2pDTEg0TUVtRllrZUdtWUYzczN2QnZMY1ZxTVovY2lPQkJ6Q3U3cUV1Q2FZbFhNa0J4Q0RLVUZ3blQvNDB1TXQvMEI4enRDdG5JdXU3ZUQ1aFhCUFFTYmorSzhGNXJZUnM2UnJidnUyRGVXRENaa0M0WlZwRVJUNGJWNW9BTVgzTFN3SmVrdUkyU2ZSVmNOMUFLZHYyb2ZDc3F5RTl2MUVIZk92cWx2T0c3cHgyYnlONGtXbGtCMEszem0xWmtCUWhRWktOL2Fydm9aSUNlNVFGZVk0MUlCcy8wK3ljNXp3dEZsTFZpNENtUTA2cTN3WWg1WTRQV0EzTk93aGw5VHh0eVdqR005YldldzV0Lys1b21ncTJ5TEdjRTdjSkRIWGJZWU40MUF2aU0rMUhDRHY2YmFtNDlHTjBvMFU1YjlaMGpMUXl1dGVObUFqNmVLcGVjUk5maFk2ampYclRPdFpXTm9RMUN4UWErajErTkpSb1I3L1dCYTh5aWlsZ1o2NjlhdnBORm11REJiZjMxWE5mcVVOZVk3aTF1UTFFdGJNYitlVWkzaG5PRjdtbTArV3d4MkNnMFg1dUJCU01adVk2dnlYeUdOb3E0MXRjMTM0TmhKYUdXTWMvZ2orWjZqSmpYaEhNendRUS93cVZLZ1QxRmhWeXpmWWFmeUtEa1E2MUlzUkpGYkVVTWU2T3dtK2RzN2ZVV2lEcUVrcEVIM01ucmRBQXVCQjVFWitTRjh3dUozSFVXRDFjUXRNSzBOUWxWRjBVZDAzMG1Kc3VWQXV5QlVNSGxLT2ZDSnVHTlhQZzZNYlkrbkNjc2U1dGQwa2kxN0JTRTlORVFObGNXcGFIb0pCRkppOWY3dWlvVHkwYjd2YVY2WUk5OTRKYm11MGNTMk5QNTVXby8xL1RudE1JMEp5UFRBTjdsU3FmN0ltQ3FaVVU2NEExaWhKOUZ4ZS92NGJ1c0dLdzRtbk56dFhoZ0o4dHdrekJubHN1cXNRc0Rhbys1M2FBYk9kNWg2Vk9yWFdxUjVMT240dU9tU1FTdkJkZGJXaHkxYno3cTZTMlN6QUlsaUhxVHRWUFd4azBJbk1sWEkxN2VyVnY2dVJZY1Y5YmIwczZwNDdSNTBUVjRtUTdMbWNZRFNRVHNOY25qd0htVFVka0RCdnhnZHVtNklSd01ZMjAyc3RQNmVXeGNrMWNZNXhaWVRtYkR5RHVZN0Y3akZGNkgvd1BBLzcyUlVOc3lsNWwySktBaW40UzEzenYvZ2pYbXFLRStsMVkxUWJJeE10VWVnNlNpbXE0QVN6ZXIwUUFsRHhXOGlKYkxFMXNIaVVTMWtZYW5HTlJua0FjY05waVhNajVoWHN2S2t3OWc4aERLdURteTB4clpCc3RST2E1VTlFMnQzYmRhRG02RmJGdHRzQW5MTEhUR2ZKS2pkblZOSmp1cUpoU1ZoVEo0SFFrZ2E5YVJnZU9BdWVja3Q1N3lRanZRMzNJR3M1N3JJK2F6MHpzakFlaUR6d21DaEdYNVZUSTYwcHJWbnc0dFpGbW14WDZ6azJ5U2FBWExNVEJyUXd2MXdTMUJ0Sk93Ym5HNGxWQzYxY1AxVnIyMTdBVDZyV1RYWkVMNTZCdzBHYW15V0RHZ3B5dzZTcUNOSzJ1R3czaGVPNE1oUUQzbWxRMjlFSUVMbHFOZnNpUyt2dUNsbkNzUkMxWnZaNjUzaDBsU3dVUUJSYlRodE1KSUFlL0w4UzRsZ0h0S3NmWnFZRkdMcUp2LzAyQnBBZWdtbjlid3ZKTUxFZFdGMXFUVUUvN0l4ck1QYkJhdHMycHBkV2Y4anBjU3JrVDZFdGUvTnBUbHJFWVVIWHlkS2UrMldVQXV5OStwL1pxNkUrV0FqU1VzWjI5cGVENEpHNG5HYUdNanVlSnFYNlAxNFh4RWxWVkhXdkRlYW9GYjIyeTM5TnRiNmxiWGRMZkl1OVdCNnA1S0M5VkxkYnJwS0JKVFdkbmc5Rys1UHRzWnZHaEpWaS9KcElNUWdKNGl0WTRpeDViSVRFc01PQlBBY29kbGZZN1BjaTFiMG1DWm9UWllKdG41bk54a1hSY1p3MmpOQ2Z1OVUvYUoranM2dE5ZV2hRUGVaaVVVVTRiRy8xUERYaWNWTU5DY1NDdy9DVHZXc0tXbG04M0F5OFgvWjlFaUszaWY4ZEtjd0cyR1hCWEFaak9GTm9yYWU4MFRaRWZET2hXUW92WkdWdzVYVnU1SlJqd2lCdVpCalpvNzltaWF6Q0MwSGJPR2hRK1kxKzNXMXVJTFh1cEFYK01wY012STdJalphc2RTQkt6UmJLVXBTRVpoSXhKeDAxMG5FeDNVOGRTLzRHVWUyZjhBOE4veFJ5MjI2cEZGNUFlZE5EdWEwSm5aTFV3eXFYWkQ4aGdlTmRXdVVkMUJua09lUU16QW5VVmVHQU85T1NvMzA3V2dpZTBSNjI1eXQrRGRtMlVCdkhGeHR4SUNITENjdzhNYTRCaFFlWDR3Z1dWMit5dGVmQVFtWVpNOWxsbjBKTnJsS0ZuUVdyN1ZVVmJ6U1hTaUV3Rm5Ka2J3UkFtd0k1YmVBY3krRzhTMWpNbHNUTW13eitqQnp5dkE3UFJVWmtXVFdjZ3RsbzVGTUx1OVdqTzZaTnUwVTdwWVk3YTNBdW1XbkRCdGdHODBKeTd5YkhYQTZVcnNKb2xrZE9aVlRmeDhYVW1halloTDdpYjR4b0NDNVdnaEhUWmFzL2dIa2ZhcUZGQ0hDWExlNGhuTDhkNmpKSTByQmd3Q2trWHlDYldzYXpMRWd0M2ozSHl1Y1dOZGZVajMzMXU4QlRLMlN4dlc1QVAxZk5WbWcyTEMvalBtYzNCMHRrOTljU0tLZlEyT0JOdzk1aGwvN3JKaUp5czJ2MVo3dEROdEVxcDVhbHVmK2t5MldCb09NN0J6ZVZReEM3NE5OQ1NWRnlJejhtZ01qQUxXYVBUWE50Qm4wNHFjNExMZnppTlc1YUZtZzBGRTRGa1Ftdzd0MFc4ZGkvei84TWVVMm9lVlJGOVowY1NkVk9LMHY3S1NzYzdtL3ZCM0RYSmRlM092M2FZM1lqN29UelZZWlpvNktxYitQZGQyajRJWEE1YU5BN1ZpZ0gwT0N2My95WkF4clJOWFF5T3VpSW13Wm9LdlF5NmZBcTRiQXdwekFKaXVXV0J0WGhRQzFzVTdiUWRmZGNDU1F0VkdlU2hod254RVRJTzU2MDR4eC9ZZzRVTmxyZHdOcGRsVTFaRHJjUjFFRHREUjRCekdQd2w3UHNqQzFYQ2Zydzh2dm94bHZhcmFza1Z0dUpFamY1WklRTXUyc0pIRTNHbzhlSXU1ZGZUOTB3WVlweFdORkVHRW9adlJ0SktZY2hHSGswczBLWk5Ya3NOUmZlM2FxQmRJZ29qZCt4dWpoNCtpNy9ZU2NlcG4xRTMrakxsNXpFQUFXcHR1bnVpNE9DSWNoZVVta1MwYU9ZOFNyTXNzUUw3Vm5MSFc2bHcrRzF5M1hxcDl1SWRwMm5HaUNQUS9ZRjZpd3BOVWVZYy9HekRvc0J3WjNHRnBXS0grc1IwQnlUZThHRVFjQ05DNXVKNFp4Q09XZzk3VVhLV1ZoWlRwSEJFaytiYXk5aERKeE5XaEFyNzBKQWRBVWdMTlZoM1JHdlA5YXd3YjVyelcybE9uNExQZjhrQkVUS1lFRDdOajVoSFl1YzlmcTcvTWhzMnVBWXBLYUpNaE1TT1dNNlUwRWhxTjFxL0hkNWJjQURjQ1ZETHpUTW10eWpScm1XTnZFdGt3NE0zUldZMG1xL3lXSlZFR3pJY1hEbVl6R2hIWHlpb1FaM085cDQ4RzE3UURESjMyaGtBV1VJMXZERUE0YXNQc2lLVldwcXFUS29FWEkyMHVCMkV6M2FPRVV0eWZYUFdqSi9yL3RWMnZTZzhuekgwTVFJRE1wU1k5SFU4alNiWEdQQmdITE4zcXVlVTFpWllNeEIxWmErVW9hWU5sWnF3YlRrL0IrN1dqS1ZvblVkUEVXcmlQbGZOYlk2TFJlNmNWWUpwV05vS0MyRE5nRFpTbmxldUdGVDNYU1FvTmxsMVlYRWZkQ2R1RWZONWtnRmRkLzVuVWZDTTJlOEhjcTVVanBHSWl0SjZlQzdZVHJSVUEvRjZPVmdmWmVIakt3U1NTRjFmb1RFWWljTmYzdGZyOXB6SFgxM1RhS1BQaFVTUUR2S3U2YTJsbFU1WURmV2RIc2dDRFkyUFlBcnRYY1duSlNjQ3h3M3hpUUwyeEQzanB3QnJvKy9uQnVkRDVQV0UrUHJ3TmtodzZCVllyS1lySlpJK2loeFdUeElvYUN0U0tNREpOZGc4cDZKeGErQW16RVF0ZWt4TDBiNTdwV2tlTW1FRnB4TEpXR2l2QTZOZ21naVNpWTdqT2VqT0wvdThtYTJ3bGhxTkJoRzVzaVdQSWF0REN0ZVZ1eHRZejVpWktqV1R6ajNpcG5LbC9jNUsxY0tiUWZycUNNMGVPblNTb0I5SlFSMkhwQlg1QW8yTFFpT1VJbHltUXZjb083ZjFURTFwNzUyVnRGVnRuTENmRVRnRWpUb0hPeTZZalhNamZVTktKaTRvZkpSeUNoTFNkK1JuN3d4NHc5NDZ0UVBvTFhud0tlbUsrQjFyVVQ3TElHd0ZxQ0JBd01BMmljNDVZbW0xamhXMDJKb1B0cWc2MHlRTkdOb2lHM3ZGbWVaRGphdUQ5RHJLSlR2YU8rbDZiSzVXREJOZGErK01Zc09TMXBwbkl3N2lzSk0yeUNWY25JL1c0YXBGcGhXMER5NEw3UWQ2cm15NGY1OFU4Y3lQbTlhaXEvZmNpSy9BbS9reXNsdWR1OVpKL0dDV2ZjU0Y1cmhyU1Q0WnNwQ0RTaUpLa2FTV2llZmVLZ1UxdzNhZ1lXQVBXdEZJZDRLWVVaTGx3STdhTnVyWGpxcEdzWkkvNVdKTkdaSVVzNGN4M0N2Tjd2RXd5YU9SNEd2aVo2SFUzQitidGdTQTJ6cWJBWHlXVXlnYmtkRkp1TWVldlAydmd1NzJ5MmNRaTdUTHRTQTRsZVpoVEVKbG9qV3ZrdXVVMHNiMEpuVkhZU1RJYUlyRGVIYVd6cFJ3WXF4WTNtZmRIbmc4TzBDZVRST29RKzdVaU9LYWFiWDh3OTNnd1ZRUUljaUE5dkFlSW5uZTFEanhpWHRiRjE3eHFwVWNpRjB3MkJybU92VWxXTTZ2bFNnWXR5MXpMK20rMU1HOWgyVTJUamlOUXZRVmN0NzRvc3JZRDFxY1ZGQU1pcXM4NXl6QzJCZFJwa0pDRVVaWWROWnRFR1F2MWpRbDdSOUY1THlUY2ErOTFsUTIrMGU5T2hxR3hEcHNKaExPd1FpN0ZTbGlPMGNraTlsL291RjJ2LzRUdE1pcVh6QUs4bDZ3YnVLZlZDMDJ3T1VTc01rcDhGY05ZSVBKSXhySW9QY0Y3cTY1cHZHdmRiSTZwT2sxYXBaU0lORGdQVmtpQ1ZKTlN5a3hIWWJHamlaU1NnQnQ3b1Q1aFBsNmxvd3cvSjYvcWMzV2k5VGJRUFdpRitRSnprL2xFejBZeE9SaXRwRkEzTHY1OEJKdmJubkQvVFF4MkMxUXR1QnFBM1FMV0J1czl1NUZCZ3A1Z0kzcW5LenhYejFWbGVuVlN3VFBkbEk3WXFIcXROb1lKWktQYlZiWjhwcEI5b0NvQ3JqVGdMR2l0SURnVDRFM0M0QStTK1V6Q1BDTWR0QXRDSmE3bGRkZThOYnF1empiVDcyd2tCQ3pCL3dhSktnQS9tZFFsZTJCQXhEbHVGWE1NYkZUQzh0RldUV3FSaDc4RW13Z0M1aHZwZWRtUUF2ZDhqUEFkZVpFbUhFMlpYZnZaS0J0UEQrQjNJUmhjMyt4R29QQVUxeHJDRDNneFpEa1MrTGJtMm1UTVIza1BsQmRSQ1kzcmJsT0FOd1BpOHM0SVJEKzhwdlUxNEhvTG9LNVZGMkJsOFVVaFZoS3RjVFRzaXNjNk1CTk54Q3g1M0M5N0J2U1kxODVtQXJ6Mkdnb3hVQjFJYSsza25BOUdUK3JNUXdTVC9ISFRCTExScVFmWkZFRG5kU1RtdktabjVpQVJrK0dkc0hTb25OWlRPcGJRR3QwMXl0dzdhNzA5Vm9ndW83NzI5NjRKWmdvU1ZORzRjbUErTEJNcndLdUpMVGQrcFpGSUMvQ3oxbUN1azBvaExtcy9tYzAyRVFGSndnNDVVcnhnUGl0cmt1eTlPcjcxdEhHZlRmS1pUWUhVVFdzMDk5OXRMTnFzRU1tTzc2NngzZ0tvcStCNm8vYWFONUlCT2RqSm5EZm1tdjJYaG9oTkVBSzB3bjdxenpyTWk1anJpSmxNekpMQmdjUHRiM2laWE5CZ1h1K3FKc1VONXJXNEl5VzdlQUUra3k1N0ZKYkEraSt3YkdOMGxvWGFsNTJOQmhxVkZRSExsbU1Za01nQlV5d21tZFZpMzN3dklLN2xUWUh1SG1YOWdkaWtCZ0U0dXhJbEoyVmtTUktPNXVkcnpReFJQM3hHUE1XQWJmekc0TjdwMzArU2dPSlNSRWdrMTJNK3IrcUpqbW1nU1BDQ2VkVUEvMHkxNk1sc1VyWDhxaEtPbnA0dDdxNGNKVmVpSnZpTitZNjBRNitPYkQwL0ZGajNNdGUxc3BweFk1ZHdUS2cxR1Z0MTFYZk9UbTR4S2F0dEtjelhzRlRiK1ViRE1MamhvQzZNcWk5eEpVRXJ1ejRQV2p6UWV4L2w4dzVHUXg0TWFLckdtdUZOVlFZQnJVSEFtaitqQ1RROHZVL1poT2JKZ0pMYklCdDQyMEkxZ283S1lpSWdqRXEySW1ES0szS1diaXdqbG1WS2VRUE1uWUdMU2htVEFid0o2MFk5a2R3d21RMXF6VE40b0w5alEzcW5WWE45Tm9mazlWbXFnenhQdExaK3AwVFdpSG5YWUU5UjJ5VFJwSHF5RmlQZlJET3VnT1djckxYQy96ZHBxaW1sTndIcnJjeDFUMjFZV3NuQ3B1RGlSWFBIR3dwMU9TR2xOYXBzM1ZmTG91ckV6Y0ZvdEd5b3pkcFVwdDM1UkNCOUVUWjN2SUxtS0NIbUY5S2ZudWxZV1pOaVpzc01xTVc4YTB3N1lWcWpZN3JNN2dVdmZyWHFHNXFOdHVZMnoyWWpnejBGRVV4VXJjQ2ZXVmJDZGRYYW95RjhLcUZnSlNHMkZyN3ZtWlRMbXF3akM1UElOU29ocE9CNHRZMXprcnhDZ2ZjM2RmM3lSYlJSOW1kdENBUVBtSStiejBKRU5MZFJtMmdxNCtYbjVZemx0SU5DTEpXTms3Z2R0cE9OaDMyWStUNW9uYkxUNXJjTXpUK1ZwYjZYNW5ycnlVU3VSOXBFb0RKRFJqeXFvaTZpQjd6VXVITENxaGg5cThPOE4zK2ljUDFNQzUxSCtXb2QzNUV5cEFmUmtMN0k0dVRKc0Z4by8xWENvVUhZTUhmRGNNSkxkMm9GWEdac0Y4cjJQbUJaNnBVMnRNbTlBd1kxTkc2TjdzYzY3TnAwV1g1NFJoT3VjNldIWnBVSHpFdDZvcjc5RW16MHppVktuWjFnaU1LdGRuYlo1QnhVSWhpRVRhOUpDaU90TjBkOEppRW1TVUovMXhZTElSdmNMRFBBdDJZWFljdnNBYUxTaXlhbGU3cXZPb0dnRlpiYkNSblR5T1ZOa3dVK0cxeGZBNTU3M3hNOTBHdU9RUTI4TlI2UGhLbWxVYjNjSlBaMmJFekNRSXVuai9CRzFwbUF2YUcvUFJodzRSRXliQXJPa3NwSVFNMHNzNkhGZE1GOC9uc1dTWUU3cFJLV1F4RFYrbTBJUUJxSS9YWW53NlEwQWFUM2RjSnl6TTVhbzRoalpjNW5Gb0hFNHg3NlNCSlFWamtGeVpRY0pPVW1MSTFaRUdqWld2VXdHWkF2WmtNQkFjNG9VY0Zra3B3TXhEM21EVFZjR2ROZ09Xa0E5Tnp3Z05CbnpDdG9CaXg3OUVmNTk0VmtNR2JDV1pMUUdYSHRjVEhuMVFSSnNFM2MvRXhRZmErRTFpME1kdzFjUzhCY05WRUZFZVMxQTZvUGJycktDVm5BWVF3ZWdrRWV3a1owdGZydlp3TEoycGZkWXQ1b3dOblVJd0hucjNncENBZGVxaHNxYzM2bTh6bVlrTFdWVEdvRFAvVFE2ZG04c0R2UkFKT1JYa29RMnJ1aGlsc2FhQk9zajhpdHlpWEhzbUh0eVFDMU13aVBKb3hHVGw0RjhmUUJCWFpubmxKV05pMjJvSVJzTUkzb20wd1lYQ2NYWkQzM2VCa0wzNG84Tm1IWlBmWXNVU1dIL0EzbVUxdFZBbWtJUEFzOWo4cTRwMEJDWEVzTVJxMndaU1hCdmtuOFBncFlRM0ExUVBzV0xXTnRkRzAyMm1EWlNKQmwrR0x5VnJUTXFBUW9HN0E0bWNYUG4xT1RWQTJCWmlaSllTUTk5cCswKzdNWGJGMm9YK2g0TDhKS2RLckNSTXlqRm5zblNVNTFtUHRpWnRMSmlqQlROOHFjZGVtMWpSQ0dpZkpyTU8vVGlnWEhlbDFHTndWczJza1JhWVZkbGtDblZnQjIyWCtzL0N4aXg2NnlRRXVKeGhXV3krdWZPNmdxUUI0bGdsTi80RzRsY2NmanJMT0U3andQaTF2REwxaWFiMS9vNytveFA5Ry9IMlFqMEdTYnlncFpFblFwQU5nU2FOOWxCVWhEY1AxSVVOMEZyanNsZ2kzZ1hWdWNCYkYzcklZSXlnNjBIVk5EeXhaTDcwZld0RnFqNGRhYitvQzVFMDhpcmZhWnRGQVhHaDdwNXdmUlMxdXBBRGpTOS9TWUQxVFVMaFVOdlRwNEJ6R3RSWFJ0cUEzOGxNMWt3cThjWk83WG5NMmlrSmg3emgyZzZ0OUVqSEdBTjdySmdkd1VNVWEzOGNJQXJ6TDBCdk15b3hSb3FjT09aRjB5T3VRWWJCSVgyZnhaZDIwUmQ2LzFockZ6YWVCazlOVGZLWkxpOXd4WWptU3E5K04wZlhaK3g5eS9BRmlhdUN1Ukd1USthczJ3UzI3dE1XSkpQeVM0dmtJbVNLL1lUZFlZcHB2Vm5qWlliVGFaUjRqZXllTW1JaC9VYkc2c3U2bHNHVGhRNkY0bnh0WmEydnBnL0VJQVdGbkFnZlN3YjFmMlczV3hUalRTWDdDc1g2eE10U09Ha2lUTDNHRSt3NHM3MURRcHBxVjJDVXVITU5leDFSaVFjVVg1a1ExZU12Y1JBVnVKSFAxem9Qa0N5OEwxWkRSWTNkakdsY1Fxc0p4QUFMbDJCWEhWVE5UdXF1YlJ0VXpxR0J5LzJ2RkJFcVJjek0vcm5tV2tKNUhRZUN5TGF1cWozTmVuUU01aHh1NDhMdGJNbTBvZ3M2dzlpN3RhWGo4RFdIZUQ2dzZnamNBdUdiYlZJKzRKam1wcWVXZFhWeW5WYllDbE42VXpwOUJhV2Rac0o5RjV1VlcxQXFLR1pKRGpiRVVIYmJFc2pPYUNiUzdWNGpEcEpCdkdTWklLSGVibFhZM0pla09TYTVreXNhMHdoUWJMa2lmTkhoZkVOWWFhdkNyQnoxT3dlUUxManB4c0hsU1lwTlFvVWtneUd0K0laVTkvTXFGOVdZbWExdXBTcDRCQnUyUlkxRVdsNER3RWdKNk1SbHZYNHhGKzBzQWtURFdiNzU2SWpGVGR2emZFaDZkNHFGbDgyYUdYam9iTURJR3NPRzFJaXJ2bHl4OFNYR3RoN1FhVDNXcC9qVFJaWU5tRjBXTHBucVhoSDlmLzZURERRdUY1THd4RlErZlJzSzlld2tBdGhCNHhMOUVhaVVFbUxIMUdIK1E4YWh2dUE0RjVGbVo3d253VWVFL2ZlNUx6YkdUUnRnUW1qUUhjSk5jNE1tcVo0SnNQZEJPTjJrYlgzTksyWm5FNVlITlNBak5oblY3cnBnNjRUSDFaWWNrNjNjSkpGaTc2VXA4QjljOW9oQ3hNUnE1UkE2R1JKQ1h1T3F5Vks5cFFNdUNQRXNCSjFqUlhBMmpYNFlYV1BmOGRYODhSeXc2eERrdVBWaUR1RE55cVc4Vkd5SytTVmZtelFmWFZ6UFVWVXNIZWhCY015SlpnWnkwbXhGRFdNR0ZlaGpYQTk1Z25vOG0ybURjYXRDYk01UTZaVVhSTWlHeFFtdzU0ekhZam1mNlJ3cjkvVXNMc0lFQ2U2WnlZSVZSNTRac2tKblNFc201SzJqR25wVjBqbGlZNVRyY2NBeG1BQVc0TUhySzhFYlZFczc1YzhtWXQ0eCtOZFFHOE1ibUd1WTQxbDBDK2lJeXNvN0hvYmpLcm1nd0I4NGtjZXQwNGtYVEd2RUtHN1RWNWZsdkczRnlGQVpxclppWVRXYWtIQXZ0aGpMTHBUN0tCWUVYeTBZb2ZJRFphMzExbi9OT0E2d2FialVhUVREdkJGUkxPWmN4YldwTkpRcmliY0pTLzVjeWthbzROZkc4K0tHeWZNQjhEREFMdVhoNjRHcFk5aUo3RllINlVjOVFIZGFLa0FyY2FjdmNMQStLSkhwNzYrU1BpM3ZYV1BOU2RYSnNXM3VTY05kY0I4M0l1bDJ4U0gxWUZtYlVJS05MYmRGMDFBY3R4eGYvUlo3bXg0enBDbXljU3MvN3R6Rk1TZkIxdE1relF0Y3B5NTFRalVwVEtaSkNvcXE2SFd2N1hFT2d5WVdDUDFVRnlBRzd6YU9ESGh5c3hpamFUTGQ4SHJTUW93V2ZqUndUVmR3UFhnTW11Z1duRVhxT2JFdldQMXdWeVFlenVyamV6b2I5ak5uc1J6VldIdytrSURPMlVPaE13TWNObzhESzdpemVCazBnV2haSlg5ZjFuMGtjZjVBRTZ3dmUvY3dlTFNnSEpTQnpNOWhtZ0V1bTdDZk9wbloxNVgzMFFPem5QWkRZL2wvQlMwSEdaOXpYdjE2Mk9MRTZRVFFIN2pFYXhNTGlNQWFOMmxvRlRBQm9zWDdXWXo2TFNKQ1JFN3g0bFRHZE5Wc2UrMUExNU1JbGVqUklta1p0NEUyMnhiT3pnV3VvQnZrd3FCNXVLbXlPM1ZYNjVKUWY4VUtENjd1RDZEbEpCVkVVd3JZUUZMdHhhUzBaa1dURHFKTVhaMlNTSkcyWVlEL0s5N0poK2tMQ0t4NGJYditrd0g3ZkIyZDFPV05JUmMyT2FGa3VUa1BxZ2ZjRzh2MXdYZEozQTBCb1F5aWF4eGJLRjl2WW53N0oxdU9KYXhZaVdVTG01YVJxYXUycVJjV1ZUajRZdVRpWXhvN0lTZis5ZzJHVjBmTHJKWHdSc1JnbkZwMEJ1NmN6eDFtT3BGUUFuekN0RVhQbFpKcG1BbXdLMFBUVmg2WGt3U3VUanFpKzRDbUZQTjZlU2x5MnQ5VlVBOVdjRDY3dUQ2enNBYmRxeGswVVhmOHZQTVptUWVBb1lqL3ZlaGtDU2EvdDYwVGg1ZU9JM0xHdEh1WDIxQWZBdnZGUWpaUE53akFKcVBUMEFQQ2l4VG1mb2pVUXlFVFBuYzlCaGhnMldOWkZ1bERZL2tKckE0R3FMSWd3Mkd2R3REU1JhM1FIRTVpbktESlV4T2U5Z0NFUFVTaEwxRzgyQlZLSDJpVTBnSXdEZXgwQ0hTbVlDVGpaV1NTUVBjVDgrZzJNcnVuWVQ2SmNEUlh3YTJVMllseGVPd3BpVGFQT2F0K0Rud25WbXJYa0J1S0dMcjJwZStoR0E5VVBCOVFhQWRmcHN4bnIyZGcvZ0pzT1V1REtnTVRjNllWNnVsSTFVNEFCUXUxaFlLLzJDUHh5NjZnTnh3cksyazh0YVZOdDdvQWVYUjhxMDhxQlY0SDJrWSs3TUJzU1RHWTdFcHFwdmJVMW1kZkp3RjBsMHVSS21UaDcycUxZeW1SQjhESmhtcExreXUycFdOdWpKSkxvY2k5YVIxWjNSU3ptNWs0V044dmZwZ0VuMk1pMkJwTkNaNUdadGx5NTBUd1lCUGs1Q2FhUElJQ0RibXlUbWlPVVVWYTUxMVZaekJ0Vkc3bS9Dc25GaVQ5dHFnbmZCdW9Qck93RnNGQWFrRmNIYmdTZFdIaVRYWng2eDRBUmZHNnUrcU03K0w1dVE2UUJ2ZkZJZm1tcWcvVWphMTRHWUJqL0UvOENMV3hkUFNlaE5BcENQbDIzajFNZ21DN2c4WUY1K3c4NzU3SEtsUS9lNFNrSFpJUHU5bnJFK2J0cjVQRXhZSHptVFJidmZNZ1hTekg0V2dCeXhOS3daUkZkMHBXb3duM2N4ZjhOc25nMm91YnFDUnhSeG1ONkpyTVRYYUFva3NpejYvclRDZE5uUW10ZjlZQktDVTVBTTNFcGdKZmpxanJVbXBCOGVWRDhOWEhjQ2JNSnQ4MjUwYW1RMGVBL3dKaU5wWlVFQTg0Si9TSEtCQysyZDJVUXlJSnhOR0tYVkNwWHAxcUpzbnA3UVl1bXV4WUNwQ1JJT01ZdklFS1BSZ0h0aHJNQjgxbjE5LzFuWU5RTXNuM09rZFhQU1JIdndPZk0rbWFTWVM0enBFRHd0KzZxenpMUUkveUtoK0JRa3RTYXpjWStVd0hUNm96cm5QNVBHbVVUUFY5MzNJbEtRMW9FT3Nsa1ZzOUVBODNJcWZVN2NNNkgzbVNjZ2dEWjUxYmtqVDE3MVNuWWEvV3Nsd1o4Q1dEOE5YQ3ZBN21oQUFQWTFIVVI5NDdwZ3MwbFVSTHRwOUJBRGZzSW5kektOV0JvYVE1SlZEUzNVbnI2amd6ZityczVadjJOZTE2aUpreGJ6U29VNisrc0xzUmxtZFVmOFVScFd4eVdycnN6c3NDSGc3Z2dzYXZLTXpaUVBBUXRzUkUvbEVTUGNUQUVEYWh5cXNqYXNqdmtYK3ZmUnlBR3RoTTRLaXFOaGVKQndGN0p1ZWl4ZDNEaUJ4ZjM0T2hpeUYyMmUvV2pyR3Z4TzE2ODFpVlp1U0dnTVk5ZEpCYTA1ZnRlTjVveHRkS291aENRazh4eEVJM2pXeGtMdDhnWDRHWUQxVThIMURZbXVCRzlaQnJNTFR5c2FiWVBZQ2s3MVNNaURlcGFrZ1BxdWFrbUsxcENxRnNaSnFpVDZLVGNGQU11ZS9rZThPSFR4SnRCaDZTTWJHUkJyK05zRUVzbUllZm5haFlEOHNxS1ZnL1RjM215RUJ5ek50TGwxbGNHWFM5dTRMTzRpVVVKbjJOSVlhS2RGTnNMSVp4YVlEOERVN2p4ZWM0T1JxN1F6c0pIUXZhZHJlOFp5MG01djVCNTJ0dUo3MzhzbWVqRUpLSzB4MWtrR1R1Wks4Tk1ZTkwvZ29nZ1lTZS9WV3VyUEJLeC9DcmplQUxRcHVDbFlTVzV0L1EzZ1MzN1VNQ0tMNXVZV1V3cy9Na1pIcXZBNDdpS0pKamJGNWhEdWdubWJZNjE5SGZDSGNRdDdkT3FvN1VjQ3dtY3N1M3Nnd000UHpvTUFWSkhrak03dTBnZm5TT2Vsb1NTM2RUWkdBdURqeWNLZVdZZThpTFRSWTlrODROcGJkUk5PUnRadzQ5NmZKZlRPQk80WHZGUi8xS2poRjhPRUc5cWtSOHpybjBkS1hEWHkvaVNibU90QW16Q2ZzQUZhRHhmNmprYld0RmE0VFBBVFdTUHRPZ1dia2piN3RKZ2JEOTNNVE8vZytybHNka3RHU0N2Z0duV082YVFEQldRT2U5anNoQUZyYlU0WUc3cWNzU3pCR1l3VzFtRStpZ2FZejhoaTg0MzY0SHpCM0hHclB1aG5BMWpjZTk0TEE2NmVCeE9Ga1FjSnhkV3NYQUdOSjMxbUxHM29PR3Q5eE53SVBXT1ppVzRNZUk3Q1JEdXN6MmpUQk40b01rSlVUY0R1Ly9YZlg0eE0wUkFBRDVnYitOVDdVRGZNQythdHBWd2RvSmFTZy94M01vbGFmci82QW1BbGdlanFUWjJ4ZVNRZFJFUW5Nbk9hM2lvRi9PakErc09BNnp1QjdCNjlsdGxuaTNsbWRCTDlLd1Zoa0M3UVpBVCtHdnBtQWtVT3lia3NxMmI5TDFpYXR5aGJMQkphbmtRYkhZeGVtb1E5SDBRTDVrdzBaOE1QZEp5YXRCbE5rdTZBZWY4OWo1Ymg4UGhBNE0rSnJpekF5STBNbzJpKzJsWEZCZkd1TDc5ZWd5TXhVV2JQM0w3TVVjaDNPcTZXRW5LNktTckFjWTkvUSt5VCsveUxyRGVPQnVxbTlnM3pFa0RXVHkreVFhbkZaaTh5RkVkc0xsb29KaW5vUURzeTNVRVFYVTRmZ1JVL09yRCtjT0I2STlCeVRSNndQaDdDdGVNbXhMWjUyc0xIWWRob21QRldiYWFHbTJ2MmpGckt3NUpCZmNpZlJTTTdDSU5rRTVnS0JBY3NadytwcHl4WEtCUkpxdFJLQVI3Z3lHeS9Kcm9lcnovN0hTKzFtMGZNTTloWk5yUU84NDZsVGhJcFBBR1hRYlRGY2h5SmF1N2NQVGNLMDNXbFZCMldGb1U2WWZVZ212U0E1ZkRMR2ltY01KOTN4WWt2M2tBNzBjZFpsbEM3eEViQVdKc3dHdEdHczNrZUpxeWJVK3RBUVFWZlYzNkdEZURkazFPNWcrc1B4R0xUamJ1a202V2tuVm90bGc1T0tRRHRxQnhJZ1RPYlpGWmx0cE1rUEJqOEdNQW16RHZFdUFvaFkxN0d4ZmFFTmJuU3JHd3dPdER4Z25rVEF1dklKOHg3eTBkNGMrb1c4ekhQREliMU01NHhiNHhvQ0p4NVBQU0ptQ0lYdjFjVDZRUG1ydnlxd3pJQW5RbjBnV1c1MENpYnFFWThQVzFNUjlHVklVbS9FY3ZLaTRMNUlMK0VlWU1CRzExelpjcEZOSHYxNjlVSXk5VUE2K1FNWGJNYWlRRytxMjZTSEVJeXo4d1d1LzFMZ3VvUEQ2NmZvTXV1L1R4cXBXMkRuK3NZRnRWcU5kR1N6T0prSXhsdUdtQ05sRjJTZERLdGRrWmwwdldZN1hDSkZQK3NJNGFxWTQyMXVtRXlHbVl2ZXQ5a29vWWpnUnNEYm9lNWZlTkZRdGxXUHBldktROXkxTklzMTY3OEcrbTdSYTRGTS9DSlFMM0h2TzYzYnI0RHNmMEI4MUhwYkY4SnpEdTFKdG5RK0xwMkVuM29RRUgxNVcyRVZVOVkybWlPbUZzRjZqMVNJTldxbVJINy9Kalh3UFF2bTdqNjZjSDFIWFZabU1VVnpXdFNRYitZc0NuSmdtOUlxeXlZOTZhWEZaYWRoS1dvV1VpU1JFaFBHaUtEUVN1U0NSZUYxODhZaElGQk5GTytEaWNCYndhSkR2T01PeWZGdUhXMkphMnpJNTA1VWRnTSt0Mi84RkxuVzhlSVRNTFF0ZlJLZ2E5ZS95TWxpU0MvcSszQ210bXZFY1ZaN3NzZ0RQNHNRTTAxcVU5WDdmU2JKT2c2a1dmMDNPc2ErZ3JnUDdFMGoyYzdRc2hudVBJbzdqUlVCcXpnZHdzWTNFcFljQWZYbnh0a00yNGYreEI1UndKTFB3R1hVWFlkWHZ3K1ppb01XSS9YUmY0ZHkrbWtJM3hDalR1eU10Yk5MVmlmck1rekJwY3pmYzRCODlaUmZtalp3YXZEMHZkV3IzY25DWlg2K1R6SVR6ZW5ubGh0dFRjOFlKN2c2N0VjMnNpYTZnSGVxTHJEUEJtb2VqZ255N1N3ZnNUU1FqSEpjVGVTbU9MYVdaMXcwVXB5eXlVclJ6bCtsMXh5MHh0MExUcG02alRVY2tNU0tyMFJqTXZmQVZSL2VuRGRBYlE2ZXFTc0xMWTFPcXhqWUtLaGVORkNWNTlTL1Z1V0NscjRvWDNOUmdJQ1dQcWdjcUxySXNmWHlFUElHZjFSd2xybk50OWc2VVU2a3ZaWkV6b3RsbzBZd0x3b3ZzT3lkalhMQnNGR050ejQwRkpvcnBMRUVOemJDZDZvbTJVVkJwRW5Zb3hjUGFFam94bXdCc08wdVdPTE45NEJ5K1NVYTg5V2NIVWFheWNTaEp1MEFhejdxSzR4MHRlQTZxdUE5UytCUzMrRms5Z0J0Z254cUpDOUxsdDVKZHlKekdUMDU5RUlhbVp5T3BwbE5ISkVwT05xZzRLVzNqQmJxbXl5RiszeFNHRnhRd0RRa0g0THpKTlFXY0pjTjRpUXZXZXJQU0xYMTA3bS9kcVBYemVnczBuR0ZDTzdIQVdZdGZpK2d2a3o1b25IK243V21sdlpKSGdhUk1HTHZXUVRNTXRHN3VGSTF6Yko5WFBsZjZOc0lHNml3dHJRVHhpUWZnMFF2bHQzMVY4WldQK3k0UHJPK3F3Yjk2dkdMaHB5dVltVkJYRnBTN1R3K1dGVmxzV1pkQzB6aWdiejZYaVZTUjdVRHN0K2NoMURBdEgvZFB3TmwzK3hpeEl6NGdNQnkxbENkOTRFQU85a3BoTkNUNWhuK0xVVUs3SW43QVMwT09ISDVWVjZqd2VSQ3ZSYURTWkM0QTFXNTBzNUc4dXFGV3Q1bEJ0WjdVQlVtV294REJRMzZLTnJXdXFiZGRhL0pNbjdLNE9yQTlxZDVqRVJnM1cvVTZOb25rUEZ4ZW5SaU9ZT3k1cENWOUxDWUJWNUsvRERPaEpnc3Jhb2RaK2dzSlU3cUxSOXRjb0c2dnJFeDZ4T1Rob3VONktoMXVQb3NleHdZemJjMGZrT3N1bTRjZFlqbGgxY3ZDbnFDRzltdDQwdzA4SElPRHExUXBOaERIZzhSU0pqYVdidW5LcXl5QWdJMW82Nldta2t4SnZnc0JMdUE2L3YrMzgxay8yclk4L2ZCbHgzTU52WExDclg3cnJYNkRmdEFHNWxrY2xvb0k2cFpIaS9XUzVyR2dJMnJGTUQxRFl1aWZaYVgzVVE0MlNPazUydHVBYTE5dHEzV05iMERpSUZjTWRSQlNyMmVHVmRWRXVzZXBFQjFCZVZQUVBjOE1VS1VwejRVc2JveHJFL1hxL0ppTGh0RkxLWmJEbEhSVUQ0SURJTHNEU0NqOWhsMUV4ekQvbnY0UHFuU1FkSlF0cTFpK2s2eWZhRVdrNWJSQkR1dFZpNkdibFJIQzJXNWh5dEFKRmpoeENnSCtSbkE1WitEUXpxQ3VZTVdvT0V2TnlPcWxNQ2RPNVpJeUUzbHg3cCtic1NLRWowTUpyN3d3MFFYR0kyd0p1cEFONkpQNUtEMXNCVGpZUktzRVkwOFhsTDJIOEgwanU0Zmg3UWtvU3dsUURRQmJ5bnNGcTExejJmNmJ3MFI2eG5lblZpUURRUU1Kc1FVeG1xYTZDWUFqMnZHS2FyanZndTZhWDJnWU1KNVZrdlp2dERicFpnTmprS3crMUZrbUVXMjJIZU5lZk9UWUV1R3hCM0hYdmpqa2hwVDJOTHdkdXo5L2lJdjd2anlSMWNQNHZscnBsZXJDM2NiQmhRUWx6VGlBMVdxOS9CNGJkcWhJNzU4SHl2VVVBaUIrZXBMWldRTUZzSElJNXkzTTVYRlBBTy9zelNIekIzcWRKcjRRWU9iaVdIbFBWUHdvQWpnRnNyQlFTOC93VldRdm44U2pDTnZ1L05Eei9uTU81WWNnZlhQMXRLZU5kRHdiSlNJUUxXTlphVTRTZWtKbmc3dW9nMUo1RUlYQmZjZ0hnUzcyVENZcTZuZFFNRFhXWEJHT2liZW00UWpSTHdvM2gwdHBXRysxcFBxdmZBdVV0dHNjTHl6dXZrM2N5cDcyQjZCOWUvQ2hoSFkyMzIrTlVDY3kvYXRZY2JCb3lxQTlhQXVRMWlNc3hLQVZIMVFVNDZzVVNSekxseEVvOHRDaWZEakxsVm1BdjJ1WFByZ3ZYUlBsc2oxcU1ra3l2TVR3WjBNOVliVExEeUdlL1pUdXJjNFhZQjZSMU03K0Q2VTRLdUtROWJBT3BLQ1ZuVXZLRGxUQkdvT0hzNS9UczNMVFdTS25MQWVGMjlhamJNVjVOQnJzeElPNWc0d1ZYYml2dGd3NGttQURzRzZnWlFBajVoVkFJcGFCVy9FRnRtM3NJNi94WmpVKzdnZW4vOWlLQ3RYV0JSTW9URFhqVVlZUjEwRkhCMG1pdS9Id2FJWEtnTytBbXVDb2FjWUhPZXZ0WEpTcXNMWE9qdWdDMnZTQ0xBdHZhWk52NGU4QnJyR25ocVFndDRvM1ZmSFJwNmY5M0I5ZjU2TytBNlZxVk1kNnVZM0pWMklXQzZDdXpLRU4za1hnVXh3RHVMOFlCR3h4SzFNU0ppNFd1QUJxd25FZlg5RTI2dkFuZ3owN3lENUIxYzc2OGZsT0c2aDNSRGdsQVAyOGhNSm1LQWtRYXAwM3FkT1kwRC9veDFDejFYYnhxRjkzdnJRMThEbGxIYk0vWisxdjE1dllQci9mVTNBK2VOa0Jjcm9MS2xUMjVsMnAxVjVOYm5SV0czcTFhNHhmejU3bVY2ZjkzQjlmNzZXTkNWQk54YW84WGFOTjVxUDNqR2RzWEVMYldicmhQcXRRWDUwV2RYNldMTHhiL2NBZlVPcnZmWC9mWGVESGNMK05JS3UxMlRHVzc1cnEzUnpwK1dyYjgvaTNkd3ZiL3VyNCtVRXppNzc4Qkw2M1p2QWVrdGVlRGRUM1dIeEhBSDFUdTQzbC8zMTZjQnJkYlp1aW1zZTlpcVk2RUszcDlwY0pKZThQVCszTjNCOWY2NnZ6NFJhRTIxd2w1ZmhwOW1JZCtmdVR1NDNsLzMxNDh1STBTdmFEVDZoODkrdW9QcC9YVUgxL3ZyL3JxLzdxOFBmT1g3SmJpLzdxLzc2LzY2Zyt2OWRYL2RYL2ZYSFZ6dnIvdnIvcnEvL3E2di96MEFJZHA3QTBvTWsyY0FBQUFBU1VWT1JLNUNZSUk9XCIsXG4gIG1vdmVkOiBmYWxzZSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoY2FudmFzLCBvcHQgPSB7fSkge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcztcblxuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMud2lkdGggPSBvcHQud2lkdGggfHwgY2FudmFzLmZyZWVEcmF3aW5nQnJ1c2gud2lkdGg7XG4gICAgdGhpcy5jb2xvciA9IG9wdC5jb2xvciB8fCBjYW52YXMuZnJlZURyYXdpbmdCcnVzaC5jb2xvcjtcblxuICAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AubGluZUpvaW4gPSBcInJvdW5kXCI7XG4gICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5saW5lQ2FwID0gXCJyb3VuZFwiO1xuXG4gICAgdGhpcy5fcmVzZXQoKTtcblxuICAgIGZhYnJpYy5JbWFnZS5mcm9tVVJMKHRoaXMuc3ByYXlCcnVzaERhdGFVcmwsIGZ1bmN0aW9uIChicnVzaCkge1xuICAgICAgY29udGV4dC5icnVzaCA9IGJydXNoO1xuICAgICAgY29udGV4dC5icnVzaC5maWx0ZXJzID0gW107XG4gICAgICBjb250ZXh0LmNoYW5nZUNvbG9yKG9wdC5jb2xvcik7XG4gICAgfSwge2Nyb3NzT3JpZ2luOiBcImFub255bW91c1wifSk7XG5cbiAgfSxcblxuICBjaGFuZ2VDb2xvcjogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgdGhpcy5jb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IoY29sb3IpLnRvUmdiYSgpO1xuICAgIHRoaXMub3BhY2l0eSA9IC8oLChcXHMpKihcXGQoXFwuXFxkKFxcZCopKSopXFwpKS9nLmV4ZWModGhpcy5jb2xvcilbM107XG4gICAgdGhpcy5icnVzaC5maWx0ZXJzWzBdID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLlRpbnQoe2NvbG9yOiAnIycgKyBuZXcgZmFicmljLkNvbG9yKGNvbG9yKS50b0hleCgpfSk7XG4gICAgdGhpcy5icnVzaC5hcHBseUZpbHRlcnModGhpcy5jYW52YXMucmVuZGVyQWxsLmJpbmQodGhpcy5jYW52YXMpKTtcblxuICB9LFxuXG4gIG9uTW91c2VEb3duOiBmdW5jdGlvbiAocG9pbnRlcikge1xuICAgIHRoaXMuX3BvaW50ID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSk7XG4gICAgdGhpcy5fbGFzdFBvaW50ID0gdGhpcy5fcG9pbnQ7XG5cbiAgICB0aGlzLnNpemUgPSB0aGlzLndpZHRoO1xuICAgIHRoaXMuX3N0cm9rZUlkID0gK25ldyBEYXRlKCk7XG4gICAgdGhpcy5faW5rQW1vdW50ID0gMDtcblxuICAgIHRoaXMuY2hhbmdlQ29sb3IodGhpcy5jb2xvcik7XG4gICAgdGhpcy5fcmVuZGVyKCk7XG4gIH0sXG5cbiAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChwb2ludGVyKSB7XG4gICAgdGhpcy5tb3ZlZCA9IHRydWU7XG4gICAgdGhpcy5fbGFzdFBvaW50ID0gdGhpcy5fcG9pbnQ7XG4gICAgdGhpcy5fcG9pbnQgPSBuZXcgZmFicmljLlBvaW50KHBvaW50ZXIueCwgcG9pbnRlci55KTtcbiAgfSxcblxuICBvbk1vdXNlVXA6IGZ1bmN0aW9uIChwb2ludGVyKSB7fSxcblxuICBfcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuXG4gICAgc2V0VGltZW91dChkcmF3LCB0aGlzLl9pbnRlcnZhbCk7XG5cbiAgICBmdW5jdGlvbiBkcmF3KCkge1xuICAgICAgdmFyIHBvaW50LCBkaXN0YW5jZSwgYW5nbGUsIGFtb3VudCwgeCwgeTtcblxuICAgICAgdmFyIGN0eCA9IGNvbnRleHQuY2FudmFzLmNvbnRleHRUb3A7XG4gICAgICB2YXIgdnQgPSBjb250ZXh0LmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNmb3JtKHZ0WzBdLCB2dFsxXSwgdnRbMl0sIHZ0WzNdLCB2dFs0XSwgdnRbNV0pO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5vcGFjaXR5O1xuICAgICAgcG9pbnQgPSBuZXcgZmFicmljLlBvaW50KGNvbnRleHQuX3BvaW50LnggfHwgMCwgY29udGV4dC5fcG9pbnQueSB8fCAwKTtcbiAgICAgIGRpc3RhbmNlID0gcG9pbnQuZGlzdGFuY2VGcm9tKGNvbnRleHQuX2xhc3RQb2ludCk7XG4gICAgICBhbmdsZSA9IHBvaW50LmFuZ2xlQmV0d2Vlbihjb250ZXh0Ll9sYXN0UG9pbnQpO1xuICAgICAgYW1vdW50ID0gKDEwMCAvIGNvbnRleHQuc2l6ZSkgLyAoTWF0aC5wb3coZGlzdGFuY2UsIDIpICsgMSk7XG5cbiAgICAgIGNvbnRleHQuX2lua0Ftb3VudCArPSBhbW91bnQ7XG4gICAgICBjb250ZXh0Ll9pbmtBbW91bnQgPSBNYXRoLm1heChjb250ZXh0Ll9pbmtBbW91bnQgLSBkaXN0YW5jZSAvIDEwLCAwKTtcblxuICAgICAgeCA9IGNvbnRleHQuX2xhc3RQb2ludC54ICsgTWF0aC5zaW4oYW5nbGUpIC0gY29udGV4dC5zaXplIC8gMjtcbiAgICAgIHkgPSBjb250ZXh0Ll9sYXN0UG9pbnQueSArIE1hdGguY29zKGFuZ2xlKSAtIGNvbnRleHQuc2l6ZSAvIDI7XG4gICAgICBjb250ZXh0LmNhbnZhcy5jb250ZXh0VG9wLmRyYXdJbWFnZShjb250ZXh0LmJydXNoLl9lbGVtZW50LCB4LCB5LCBjb250ZXh0LnNpemUsIGNvbnRleHQuc2l6ZSk7XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIGlmIChjb250ZXh0LmNhbnZhcy5faXNDdXJyZW50bHlEcmF3aW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhdywgY29udGV4dC5faW50ZXJ2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5fcmVzZXQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgX3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcG9pbnQgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RQb2ludCA9IG51bGw7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZHJhd1Rvb2wvYnJ1c2hlcy9icnVzaGVzL3NwcmF5QnJ1c2guanMiLCJpbXBvcnQge2ZhYnJpY30gZnJvbSAnZmFicmljJztcblxuZmFicmljLk1hcmtlckJydXNoID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLkJhc2VCcnVzaCwge1xuXG4gIGNvbG9yOiBcIiMwMDAwMDBcIixcbiAgd2lkdGg6IDMwLFxuXG4gIF9iYXNlV2lkdGg6IDEwLFxuICBfbGFzdFBvaW50OiBudWxsLFxuICBfbGluZVdpZHRoOiAzLFxuICBfcG9pbnQ6IG51bGwsXG4gIF9zaXplOiAwLFxuICBtb3ZlZDogZmFsc2UsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oY2FudmFzLCBvcHQgPSB7fSkge1xuXG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy53aWR0aCA9IG9wdC53aWR0aCB8fCBjYW52YXMuZnJlZURyYXdpbmdCcnVzaC53aWR0aDtcbiAgICB0aGlzLmNvbG9yID0gb3B0LmNvbG9yIHx8IGNhbnZhcy5mcmVlRHJhd2luZ0JydXNoLmNvbG9yO1xuICAgIHRoaXMuX3BvaW50ID0gbmV3IGZhYnJpYy5Qb2ludCgpO1xuXG4gICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5saW5lSm9pbiA9ICdyb3VuZCc7XG4gICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5saW5lQ2FwID0gJ3JvdW5kJztcbiAgfSxcblxuICBjaGFuZ2VDb2xvcjogZnVuY3Rpb24oY29sb3IpIHtcbiAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gIH0sXG5cbiAgX3JlbmRlcjogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHZhciBjdHgsIGxpbmVXaWR0aERpZmYsIGksIGxlbjtcbiAgICB2YXIgdnQgPSB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybTtcblxuICAgIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG5cbiAgICBjdHguc2F2ZSgpO1xuXG4gICAgY3R4LnRyYW5zZm9ybSh2dFswXSwgdnRbMV0sIHZ0WzJdLCB2dFszXSwgdnRbNF0sIHZ0WzVdKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICBmb3IoaSA9IDAsIGxlbiA9ICh0aGlzLl9zaXplIC8gdGhpcy5fbGluZVdpZHRoKSAvIDI7IGkgPCBsZW47IGkrKykge1xuICAgICAgbGluZVdpZHRoRGlmZiA9ICh0aGlzLl9saW5lV2lkdGggLSAxKSAqIGk7XG5cbiAgICAgIGN0eC5tb3ZlVG8odGhpcy5fbGFzdFBvaW50LnggKyBsaW5lV2lkdGhEaWZmLCB0aGlzLl9sYXN0UG9pbnQueSArIGxpbmVXaWR0aERpZmYpO1xuICAgICAgY3R4LmxpbmVUbyhwb2ludGVyLnggKyBsaW5lV2lkdGhEaWZmLCBwb2ludGVyLnkgKyBsaW5lV2lkdGhEaWZmKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgdGhpcy5fbGFzdFBvaW50ID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSk7XG4gIH0sXG5cbiAgb25Nb3VzZURvd246IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB0aGlzLl9sYXN0UG9pbnQgPSBwb2ludGVyO1xuICAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3Auc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AubGluZVdpZHRoID0gdGhpcy5fbGluZVdpZHRoO1xuICAgIHRoaXMuX3NpemUgPSB0aGlzLndpZHRoO1xuICAgIHRoaXMubW92ZWQgPSBmYWxzZTtcbiAgfSxcblxuICBvbk1vdXNlTW92ZTogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIGlmICh0aGlzLmNhbnZhcy5faXNDdXJyZW50bHlEcmF3aW5nKSB7XG4gICAgICB0aGlzLl9yZW5kZXIocG9pbnRlcik7XG4gICAgfVxuICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICB9LFxuXG4gIG9uTW91c2VVcDogZnVuY3Rpb24oKSB7fVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9kcmF3VG9vbC9icnVzaGVzL2JydXNoZXMvbWFya2VyQnJ1c2guanMiLCJpbXBvcnQge2ZhYnJpY30gZnJvbSAnZmFicmljJztcblxuZmFicmljLkN1c3RvbUJydXNoID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLkJhc2VCcnVzaCwge1xuXG4gIGNvbG9yOiBcIiMwMDAwMDBcIixcbiAgd2lkdGg6IDMwLFxuXG4gIF9iYXNlV2lkdGg6IDEwLFxuICBfbGFzdFBvaW50OiBudWxsLFxuICBfbGluZVdpZHRoOiAzLFxuICBfcG9pbnQ6IG51bGwsXG4gIF9zaXplOiAwLFxuICBzcHJheUJydXNoRGF0YVVybDogXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFRQUFBQUVDQVlBQUFDcDhaNStBQUFBRTBsRVFWUjQybU5nd0FGK0FmRVB2QUp3QUFCK3ZnUGxEc1FvR0FBQUFBQkpSVTVFcmtKZ2dnPT1cIixcbiAgbW92ZWQ6IGZhbHNlLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGNhbnZhcywgb3B0ID0ge30pIHtcblxuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMud2lkdGggPSBvcHQud2lkdGggfHwgY2FudmFzLmZyZWVEcmF3aW5nQnJ1c2gud2lkdGg7XG4gICAgdGhpcy5jb2xvciA9IG9wdC5jb2xvciB8fCBjYW52YXMuZnJlZURyYXdpbmdCcnVzaC5jb2xvcjtcbiAgICB0aGlzLl9wb2ludCA9IG5ldyBmYWJyaWMuUG9pbnQoKTtcbiAgICB0aGlzLnNwcmF5QnJ1c2hEYXRhVXJsID0gb3B0LmltYWdlIHx8IHRoaXMuc3ByYXlCcnVzaERhdGFVcmw7XG5cbiAgICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmxpbmVKb2luID0gJ3JvdW5kJztcbiAgICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmxpbmVDYXAgPSAncm91bmQnO1xuXG4gICAgZmFicmljLkltYWdlLmZyb21VUkwodGhpcy5zcHJheUJydXNoRGF0YVVybCwgKGJydXNoKSA9PiB7XG4gICAgICB0aGlzLmJydXNoID0gYnJ1c2g7XG4gICAgICB0aGlzLmJydXNoLmZpbHRlcnMgPSBbXTtcbiAgICAgIHRoaXMuY2hhbmdlQ29sb3IodGhpcy5jb2xvcik7XG4gICAgfSwge2Nyb3NzT3JpZ2luOiBcImFub255bW91c1wifSk7XG4gIH0sXG5cbiAgY2hhbmdlQ29sb3I6IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLmJydXNoLmZpbHRlcnNbMF0gPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuVGludCh7Y29sb3I6IGNvbG9yfSk7XG4gICAgdGhpcy5icnVzaC5hcHBseUZpbHRlcnModGhpcy5jYW52YXMucmVuZGVyQWxsLmJpbmQodGhpcy5jYW52YXMpKTtcbiAgfSxcblxuXG4gIF9yZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdHgsIGxpbmVXaWR0aERpZmYsIGksIGxlbiwgeCwgeTtcbiAgICB2YXIgdnQgPSB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybTtcblxuICAgIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG5cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2Zvcm0odnRbMF0sIHZ0WzFdLCB2dFsyXSwgdnRbM10sIHZ0WzRdLCB2dFs1XSk7XG5cbiAgICB2YXIgZGlzdCA9IHRoaXMuX3BvaW50LmRpc3RhbmNlRnJvbSh0aGlzLl9sYXN0UG9pbnQpO1xuICAgIHZhciBhbmdsZSA9IHRoaXMuX3BvaW50LmFuZ2xlQmV0d2Vlbih0aGlzLl9sYXN0UG9pbnQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXN0OyBpKyspIHtcbiAgICAgIHggPSAodGhpcy5fbGFzdFBvaW50LnggKyBNYXRoLnNpbihhbmdsZSkgKiBpICkgLSB0aGlzLl9zaXplIC8gMjtcbiAgICAgIHkgPSAodGhpcy5fbGFzdFBvaW50LnkgKyBNYXRoLmNvcyhhbmdsZSkgKiBpICktIHRoaXMuX3NpemUgLyAyO1xuICAgICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5kcmF3SW1hZ2UodGhpcy5icnVzaC5fZWxlbWVudCwgeCwgeSwgdGhpcy5fc2l6ZSwgdGhpcy5fc2l6ZSk7XG4gICAgfVxuXG4gICAgY3R4LnJlc3RvcmUoKVxuICB9LFxuXG4gIG9uTW91c2VEb3duOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdGhpcy5fcG9pbnQgPSBuZXcgZmFicmljLlBvaW50KHBvaW50ZXIueCwgcG9pbnRlci55KTtcbiAgICB0aGlzLl9sYXN0UG9pbnQgPSB0aGlzLl9wb2ludDtcbiAgICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmxpbmVXaWR0aCA9IHRoaXMuX2xpbmVXaWR0aDtcbiAgICB0aGlzLl9zaXplID0gdGhpcy53aWR0aDtcbiAgICB0aGlzLm1vdmVkID0gZmFsc2U7XG4gIH0sXG5cbiAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB0aGlzLl9sYXN0UG9pbnQgPSB0aGlzLl9wb2ludDtcbiAgICB0aGlzLl9wb2ludCA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRlci54LCBwb2ludGVyLnkpO1xuICAgIGlmICh0aGlzLmNhbnZhcy5faXNDdXJyZW50bHlEcmF3aW5nKSB7XG4gICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICB9XG4gICAgdGhpcy5tb3ZlZCA9IHRydWU7XG4gIH0sXG5cbiAgb25Nb3VzZVVwOiBmdW5jdGlvbigpIHt9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RyYXdUb29sL2JydXNoZXMvYnJ1c2hlcy9jdXN0b21CcnVzaC5qcyIsImltcG9ydCB7ZmFicmljfSBmcm9tICdmYWJyaWMnO1xuXG5mYWJyaWMuSmFwYW5lc2VCcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5CYXNlQnJ1c2gsIHtcblxuICBjb2xvcjogXCIjMDAwMDAwXCIsXG4gIHdpZHRoOiAzMCxcbiAgbWluV2lkdGg6IDEsXG5cbiAgX2xhc3RQb2ludDogbnVsbCxcbiAgX2xpbmVXaWR0aDogMyxcbiAgX3BvaW50OiBudWxsLFxuICBfc2l6ZTogMCxcbiAgSmFwYW5lc2VCcnVzaEJhc2U2NDogJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBR1FBQUFCa0NBWUFBQUJ3NHBWVUFBQUFDWEJJV1hNQUFCWWxBQUFXSlFGSlVpVHdBQUFCTm1sRFExQlFhRzkwYjNOb2IzQWdTVU5ESUhCeWIyWnBiR1VBQUhqYXJZNnhTc05RRkVEUGk2TGlVQ3NFY1hCNGt5Z290dXBneHFRdFJSQ3MxU0hKMXFTaFNta1NYbDdWZm9Tald3Y1hkNy9BeVZGd1VQd0MvMEJ4NnVBUUlZT0RDSjdwM01QbGNzR28ySFduWVpSaEVHdlZianJTOVh3NSs4UU1Vd0RRQ2JQVWJyVU9BT0lranZqQjV5c0M0SG5UcmpzTi9zWjhtQ29OVElEdGJwU0ZJQ3BBLzBLbkdzUVlNSU4rcWtIY0FhWTZhZGRBUEFDbFh1NHZRQ25JL1Ewb0tkZnpRWHdBWnMvMWZERG1BRFBJZlFVd2RYU3BBV3BKT2xKbnZWTXRxNVpsU2J1YkJKRThIbVU2R21SeVB3NFRsU2FxbzZNdWtQOEh3R0srMkc0NmNxMXFXWHZyL0RPdTU4dmMzbzhRZ0ZoNkxGcEJPRlRuM3lxTW5kL240c1o0R1E1dllYcFN0TjBydU5tQWhldWlyVmFodkFYMzR5L0F4ay85NkZwUFlnQUFPL2xwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtDang0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRLSUNBZ1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNEtJQ0FnSUNBZ1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklnb2dJQ0FnSUNBZ0lDQWdJQ0I0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlLSUNBZ0lDQWdJQ0FnSUNBZ2VHMXNibk02YzNSRmRuUTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpVVjJaVzUwSXlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNlpHTTlJbWgwZEhBNkx5OXdkWEpzTG05eVp5OWtZeTlsYkdWdFpXNTBjeTh4TGpFdklnb2dJQ0FnSUNBZ0lDQWdJQ0I0Yld4dWN6cHdhRzkwYjNOb2IzQTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2Y0dodmRHOXphRzl3THpFdU1DOGlDaUFnSUNBZ0lDQWdJQ0FnSUhodGJHNXpPblJwWm1ZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZkR2xtWmk4eExqQXZJZ29nSUNBZ0lDQWdJQ0FnSUNCNGJXeHVjenBsZUdsbVBTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMMlY0YVdZdk1TNHdMeUkrQ2lBZ0lDQWdJQ0FnSUR4NGJYQTZRM0psWVhSdmNsUnZiMncrUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1R3dmVHMXdPa055WldGMGIzSlViMjlzUGdvZ0lDQWdJQ0FnSUNBOGVHMXdPa055WldGMFpVUmhkR1UrTWpBeE5pMHhNUzB4TkZReE56b3pNRG8xTkNzd016b3dNRHd2ZUcxd09rTnlaV0YwWlVSaGRHVStDaUFnSUNBZ0lDQWdJRHg0YlhBNlRXVjBZV1JoZEdGRVlYUmxQakl3TVRZdE1URXRNVFJVTVRnNk1UUTZNak1yTURNNk1EQThMM2h0Y0RwTlpYUmhaR0YwWVVSaGRHVStDaUFnSUNBZ0lDQWdJRHg0YlhBNlRXOWthV1o1UkdGMFpUNHlNREUyTFRFeExURTBWREU0T2pFME9qSXpLekF6T2pBd1BDOTRiWEE2VFc5a2FXWjVSR0YwWlQ0S0lDQWdJQ0FnSUNBZ1BIaHRjRTFOT2tsdWMzUmhibU5sU1VRK2VHMXdMbWxwWkRwa01XTmxaVGxrWVMwNE9HSTVMVFEzWVRBdE9XWmxPUzFpTkRNM09XTmlNelU0WkRnOEwzaHRjRTFOT2tsdWMzUmhibU5sU1VRK0NpQWdJQ0FnSUNBZ0lEeDRiWEJOVFRwRWIyTjFiV1Z1ZEVsRVBtRmtiMkpsT21SdlkybGtPbkJvYjNSdmMyaHZjRG8yWVRRM01qZ3lZUzFsWWpCaUxURXhOemt0WVRNNE5pMDRNbVV3TUdWa05XSTNZV1k4TDNodGNFMU5Pa1J2WTNWdFpXNTBTVVErQ2lBZ0lDQWdJQ0FnSUR4NGJYQk5UVHBQY21sbmFXNWhiRVJ2WTNWdFpXNTBTVVErZUcxd0xtUnBaRHBrWVRFM04yTXhOQzAzTldVMExXUXlOR0l0WVRnMlppMWxOelJoTkRjeE5qQXdZems4TDNodGNFMU5Pazl5YVdkcGJtRnNSRzlqZFcxbGJuUkpSRDRLSUNBZ0lDQWdJQ0FnUEhodGNFMU5Pa2hwYzNSdmNuaytDaUFnSUNBZ0lDQWdJQ0FnSUR4eVpHWTZVMlZ4UGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4Y21SbU9teHBJSEprWmpwd1lYSnpaVlI1Y0dVOUlsSmxjMjkxY21ObElqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9tRmpkR2x2Ymo1amNtVmhkR1ZrUEM5emRFVjJkRHBoWTNScGIyNCtDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcHBibk4wWVc1alpVbEVQbmh0Y0M1cGFXUTZaR0V4Tnpkak1UUXROelZsTkMxa01qUmlMV0U0Tm1ZdFpUYzBZVFEzTVRZd01HTTVQQzl6ZEVWMmREcHBibk4wWVc1alpVbEVQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZkMmhsYmo0eU1ERTJMVEV4TFRFMFZERTNPak13T2pVMEt6QXpPakF3UEM5emRFVjJkRHAzYUdWdVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNmMyOW1kSGRoY21WQloyVnVkRDVCWkc5aVpTQlFhRzkwYjNOb2IzQWdRME1nTWpBeE55QW9WMmx1Wkc5M2N5azhMM04wUlhaME9uTnZablIzWVhKbFFXZGxiblErQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHd2Y21SbU9teHBQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjbVJtT214cElISmtaanB3WVhKelpWUjVjR1U5SWxKbGMyOTFjbU5sSWo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT21GamRHbHZiajV6WVhabFpEd3ZjM1JGZG5RNllXTjBhVzl1UGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2YVc1emRHRnVZMlZKUkQ1NGJYQXVhV2xrT21JM1pUTmhPREJtTFRVMU1tUXROekEwTkMxaVl6QmhMVGsxT0dRd01UTTBaalF6TlR3dmMzUkZkblE2YVc1emRHRnVZMlZKUkQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT25kb1pXNCtNakF4TmkweE1TMHhORlF4Tnpvek1EbzFOQ3N3TXpvd01Ed3ZjM1JGZG5RNmQyaGxiajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbk52Wm5SM1lYSmxRV2RsYm5RK1FXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVGNnS0ZkcGJtUnZkM01wUEM5emRFVjJkRHB6YjJaMGQyRnlaVUZuWlc1MFBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNlkyaGhibWRsWkQ0dlBDOXpkRVYyZERwamFHRnVaMlZrUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4TDNKa1pqcHNhVDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSEprWmpwc2FTQnlaR1k2Y0dGeWMyVlVlWEJsUFNKU1pYTnZkWEpqWlNJK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwaFkzUnBiMjQrYzJGMlpXUThMM04wUlhaME9tRmpkR2x2Ymo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT21sdWMzUmhibU5sU1VRK2VHMXdMbWxwWkRwa01XTmxaVGxrWVMwNE9HSTVMVFEzWVRBdE9XWmxPUzFpTkRNM09XTmlNelU0WkRnOEwzTjBSWFowT21sdWMzUmhibU5sU1VRK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwM2FHVnVQakl3TVRZdE1URXRNVFJVTVRnNk1UUTZNak1yTURNNk1EQThMM04wUlhaME9uZG9aVzQrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHB6YjJaMGQyRnlaVUZuWlc1MFBrRmtiMkpsSUZCb2IzUnZjMmh2Y0NCRFF5QXlNREUxTGpVZ0tFMWhZMmx1ZEc5emFDazhMM04wUlhaME9uTnZablIzWVhKbFFXZGxiblErQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHBqYUdGdVoyVmtQaTg4TDNOMFJYWjBPbU5vWVc1blpXUStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lEd3ZjbVJtT214cFBnb2dJQ0FnSUNBZ0lDQWdJQ0E4TDNKa1pqcFRaWEUrQ2lBZ0lDQWdJQ0FnSUR3dmVHMXdUVTA2U0dsemRHOXllVDRLSUNBZ0lDQWdJQ0FnUEdSak9tWnZjbTFoZEQ1cGJXRm5aUzl3Ym1jOEwyUmpPbVp2Y20xaGRENEtJQ0FnSUNBZ0lDQWdQSEJvYjNSdmMyaHZjRHBEYjJ4dmNrMXZaR1UrTXp3dmNHaHZkRzl6YUc5d09rTnZiRzl5VFc5a1pUNEtJQ0FnSUNBZ0lDQWdQSEJvYjNSdmMyaHZjRHBKUTBOUWNtOW1hV3hsUGtGa2IySmxJRkpIUWlBb01UazVPQ2s4TDNCb2IzUnZjMmh2Y0RwSlEwTlFjbTltYVd4bFBnb2dJQ0FnSUNBZ0lDQThkR2xtWmpwUGNtbGxiblJoZEdsdmJqNHhQQzkwYVdabU9rOXlhV1Z1ZEdGMGFXOXVQZ29nSUNBZ0lDQWdJQ0E4ZEdsbVpqcFlVbVZ6YjJ4MWRHbHZiajR4TkRRd01EQXdMekV3TURBd1BDOTBhV1ptT2xoU1pYTnZiSFYwYVc5dVBnb2dJQ0FnSUNBZ0lDQThkR2xtWmpwWlVtVnpiMngxZEdsdmJqNHhORFF3TURBd0x6RXdNREF3UEM5MGFXWm1PbGxTWlhOdmJIVjBhVzl1UGdvZ0lDQWdJQ0FnSUNBOGRHbG1aanBTWlhOdmJIVjBhVzl1Vlc1cGRENHlQQzkwYVdabU9sSmxjMjlzZFhScGIyNVZibWwwUGdvZ0lDQWdJQ0FnSUNBOFpYaHBaanBEYjJ4dmNsTndZV05sUGpZMU5UTTFQQzlsZUdsbU9rTnZiRzl5VTNCaFkyVStDaUFnSUNBZ0lDQWdJRHhsZUdsbU9sQnBlR1ZzV0VScGJXVnVjMmx2Ymo0eE1EQThMMlY0YVdZNlVHbDRaV3hZUkdsdFpXNXphVzl1UGdvZ0lDQWdJQ0FnSUNBOFpYaHBaanBRYVhobGJGbEVhVzFsYm5OcGIyNCtNVEF3UEM5bGVHbG1PbEJwZUdWc1dVUnBiV1Z1YzJsdmJqNEtJQ0FnSUNBZ1BDOXlaR1k2UkdWelkzSnBjSFJwYjI0K0NpQWdJRHd2Y21SbU9sSkVSajRLUEM5NE9uaHRjRzFsZEdFK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2p3L2VIQmhZMnRsZENCbGJtUTlJbmNpUHo0Q3liaFBBQUFBSUdOSVVrMEFBSG9sQUFDQWd3QUErZjhBQUlEb0FBQlNDQUFCRlZnQUFEcVhBQUFYYjlkYUg1QUFBQjJkU1VSQlZIamE3TDFManlSWGx0LzUrNTlyWnU2ZXljaXNTbmF5bXRXbGdab0NKRUhad0VEbzBXNkE0V0syV3JJL3hId0pzYjlFZjRuYWF6VUx6a3JRUXJzaEZ6Tm9OYWNGa1lLUytZcVh1ejN1K2MvaW1rZEVQbGpGNGpOSXBRRU85L0FJenpTM241MzNPZmZLTm0rUDIzUEUyMHZ3RnNqYjR5MlF0MERlSG0rQnZBWHk5bmdMNUpkLzZFLzVtMlBFOHJkZjg3bC90LzdKSC9sSDN3WSszd0tJQUQ1ZW56L2xJd0U4NHZIVjM3L1AyZFhyZjg2Si82OVgvb0ZQZVhqand2K2U5dmtHNDQrQTgxc2dyN3ozTWVoVFB0SWpIdXQ5enZRbEgrZ0I1M3JLWHZjWWRjb2srTzFySDd6SFZ3WTRaV09BSit5dUx1NjcvS1BmWit2L0JQeVdFd044QWp6a29kOEVUUCtEZ3RLYllNQ0hBUThESGdlY0JHd0R6Z1Ayc2VHdU5pdzZzTHowMlMyZFQ0RU5uVWQ2YnpuM00yQkg3eDI5OTV6NkxvTXYyUGdlWC9tL0FQZlorQWp0VldEL2lvZitQZkNJMy91bVN0UXZISkplaGZFRmYxMytpdmZpS1YyQnBkc1F4V1RYb2RJUlplSlF1dTJnbWRRV09Ld2Y3Z2tmZ080d1dmVFpVendUWGhnTm14dzRlS1lZcHR6U1dleHk1TnlIcndGMnlzWVAyUGtwNy9oOS9yTy9YS1hxMDFXaXZrYWEvRXNCY2dYanQ1d1VvTnR3dCsrWSs2UU11WTBoWEh2YlhXRlRGcytsMEttU0FpZ3Nyb1FMY2hJZWxGbVJSU1owS2RYVStndzE0OURuR2FOaFNESG5YVFk1YzdEWTVNU2x4VGJGbUFkNnd6N3ZNcmh3UDA5NS9EV1FQdkVSME1jdlEvSFBFY2lWbW5yQXJqeGwzOE5tNkdHVGVEc00vVlplZHVxMHNUVlVvcGNwa0JGWTBKRlVCM0lpQ3llS0JLZUlaTWxNcUZKbXdYV21aTUZWeXF5NGlpNDd1VTdVUkYxQ3plR1FkYytRQTFuRmttS1Q1MHdKWThJdVg0WDBoSjMvaXYrZVgxNnB1aVpCUDBmcEVhQ1ArQ2dlOFZtQkQ3cjdsR0ZtMmxaMFI0UHZsb3gzbHM1M3c5eHhlRnVzSVhFUENoRktyRUEyYVZBbTZhQlVjRWE2VnB5bTFHQ3BGalZ3QlMyV0s1UTByaXhhaXR6RUI5ZE9yaFhYeEhXcjdWTGxXZy9VQWRjOWN3NjRpazNPWkJWamluMEdkL01JQ0I3bVVZSSs1YUdQZHVpRzlOeGFPRExvYi9td1BHQlg5cHdPbFh2YkFkM3hvSk9hM0tQay9YQzVSK1NKelIxSGJIRU9Jb3B4QkVHUzZDZ2RLTUZwVVpWUkU2ZlFJbHhOVm9uRlVJRWxSS1cybndVTDBtSmNKUzBMV3FSbDBhSUZ0QWdXU1l1SUphU2x5alVPc1N5NExsQTN1QjRCbmJEVXg1emtDNzd5WC9LcmZNby9HaDdtditLaFA3dmxjUFF4Qkh3WTl4ajdVemFiKzJ4MiswMDVHYkxjeitEWDZYd1E0dGM0N2graEtOalk2Z3dscnI2VnpRckZLR1ZxdS9CT3dXSlJ0WUxnK0p4YWpvQ01aNG1sL1Y0THlqbHF6Q2JuS2kxQnpGYk9SVEhYWlZtU21EdVZXY3pMSkMwYUd5eHhXQUl0TTdWT25GUVk4eTYxRnU1bngzays1Ui85QlZ2LzczeVFSOVYybStCMHh5RHZTMzRybUdJaVNyajJpOHRHWHU1RTZCMUw5NVQrTlhCZjBqdE83d1M5UkFGZE1SSFl3b0xFVHFCS1VZMlBNT3BST21ScUErQ0Y5ZTV2TUR5REYyZk1WWjVGekVWTXBzNmhNbVhOT2FSSjBvenFsREQzUzB6WnQvZVRZVDVJU3pjdTg0NXhhZEs1V1VZdWF3Y1ZIdWEvNUdIOWI1em5JeDRaSHVaSDEycE5QeldjN2xQUSs4QTVveDVRWmU0RTFIRG5Mako2VzF2aE84YnZDTzdadWlmcGp2RkcwSUVMUmlzV3l4aElwQVRTVFVMcThSbDBFODVpVkJHTDBBTFpwTU9hUlM1R00ySktQSXVZWEQxSlRJa21LU2ZCNkN3VHdTVEZpT3BrUEEwMUovV2VwREtGUEUxakxnUHpYTkV5c0Z0R0xwZFRxSGY1aTFvNHl6L25QTi9uci9OTFR2elI2ckY5L0JNNUE5MmpOL3lIbFZTSFZNa0lGSWs2U2IzdGplUWRjQmRyWjNrQWlrVGdvd3N0ZyszMm5GcHRpbEFpVXVsRVZLUUsxTGlTbW1ic201VGswbXdLTTNnT05EZVZwaFVHazlGb0dDVkd3NWhpRW5FZzYyaHBsTXFZWXF5THhyNW5sTHFwVXVaZDVKU0hiazRPaTlqTUkzMzlIV1g1ZjNrMzMyR3FqM2lVWDdEMVIzeVFyMGlOZnpTVjFhTGpqVVdtV0xMUVZ5KzFsdERpWmxBcnRxT2RWV0E2NUVHd0JYcERBWWZVbU5oQ1lDTTN5VkNUR3VPajVIRGxBRFE3ZzZLU3JoTFZVZ1V2eHF2a01HUE5oaGw1QnFhQUVjZVk1QlJpQkVhU1E0Z0Q2Q0Q1UVBvUUVZY1VvNVVIYXhucm9uRVp4cW5UWnZUb0tjaDVvY3dQcUV2UUxRY2Uxbi9KV0R2T2MvTzYxUHpnNnF6aktyZDBscUxMaFZJN3pRdlNoRFJLSEVnT2xnNHBUOWl6cENwamhJQWkzQ01LSm53ZGJLNHhnQnFYQnNWZ1k2V1JCV2t3S0hFbVVoNGRnV3pTczloTmNsYmozK0NnR1poTVRoSVRNQVpNa2c5SnJEQjBRT3dURGlIdmszTEltb2NTc1ErVmc1ZDZXSHJHVGpGS3k2U3huMFNkQm5ienlOMWxwaXdiZmx2aExCL3hLRy9hbWg5U25aV1c0UHMzS2pnR0puVU1aYWxaWEVwSE5EdUNvZys1eHhxRWV1UUIxQ1A2QmxVZHFLeVNVb1FLY0h4MDdWa0Y2SXc2clo4UjlJSWV1VWNhYVBITllOZ0lEYUFOWW92WUFsdkIxckNUdFFYdUlPMUFkMEIzTVhmYWU5d1Z2Z082WTNRMzFGNlQ3RUxzVU95VTNoWnBvL0NnaUVHWmZaVG82THF1ZE83NnVwU2VNU1ljZHhrVXZLUGZValZ3Vi9BZUQvazMraHMrNDVOdlhzTDQ1a0FBL1EyZjhjKzRyM1ArTE43aFFoQVJ2U0l6U2hjUmxndU9BdTZRT3F5dVNZUUxPbDU4bHhZc0tzQ3hlbC9yUXdFVVExbC9YOVIrN3E3QnFUU3cxN0NRZTlENllEQnFvTVFHc1FHMm1LM3hUbWlIdEF2WTRRWXE4QTV4eDlZZFZqQVN1elE3eEU1aXEyVGowSUFZU3NrK2EvUjBwYXRkM3kyMUt3ZVdjbUFUSTZtRjg3akhReTJjNnpuMzlRSC9LOTgzbUFMd0llaWNmNkVIRko2ektCQ3FscnBCbEVWdXdYamdkckVsaFdndzFDNzYwZjF0dG1TRllBaUJRQUpKU0VkSTY1c3ZBZU1LMWswSlUyZm9vc0hxdlVJUzlNQ0FHQ1M5QkVpd1JkcEoyaG50Z0R0ZUpjcm1qaHFNblpJZDB0Wm9LMm5yWkZEa1JsRjZaZll1UzE5NmxkSm5pY1VsMk1RbDBoM085UmY4VGd2bnVzUHZYcFdZN3c3a0UrQkRQbWZQNzFZdmE2c05NUFZWZllvTVVUSkVXSkpDelFERThhSUpOUWhpbFJDcG1SQ3BtUm5yaXNyNk9LWnQxdGZyWjY1aGNRMjFxRWxjdWZIL05XbEZIWEx2RlpCaENHbEEyb0EzTk5XMlJkNUtiSVcyNEIxb0YySm4yQUU3U1Z0U1RUVXFOcGxzSW1JZ1NoOFJuU3BkNllZU2ZaUnVJWUs0QW5PUGg3b1BORlgydWY0RzlNbDNCWEpkTFBwY0MrL3lGOHdzOUxDazNRK1VDaXFDREF5NmtoWko2Mi9DRU1aRmtyeGVZTjNJbDZsWndDc1FyejdXRnkvQnVpbFZSMGdyOEtNNlBBTHF3SjFRSjlONXRYR1dCMm0xU2RZRzJFcmFJbmJZVzVxYTJ3cDJnaFVhcThSNEE5bzQ2MENvcDJSZmFwYnM2THEreEJGTWNzR0dTVE5WNzNGWDhJZ1ArZnhicTdGeTg0ZlBnQS80a3Z2Y1oyRWg2ZGtzdld0ZjZSSlRFcXdWaWlRNUlDUVVzc29hSHNaNkZXOWVXRzc4L0FjVG5WOEg2aWFrVlMzcVd0MWRBN0xjSFIwSW1XNTFQUHBWdFEzZ0k1em1NS0F0ZGdNaGRyaTlKN0hGMmxqYVNBeVJwYzhvdlVydGptQ1dmbG5CYkNOSWJiaXZFd2IrL25YNzh1MkFIS0U4NURIdjhRRDRjd2N2Mk5iQlM5OVJVN2hBTklkVzdkcG55QzRXUlNZUUJZZ2puTlg3UFVMNU5uZk5HeUY5SGFDbVBwdUtreWhlbllWck9Pb1JBOUtBTlFBYlNSdXZuaHlvcVRpMGFWS2pEY25HWXJEcUNzYTlpanZWS09vVlVRa291c1NDUWI5aDVENzNnUGR1U3N1M0F3TG9NK0JESGdILzFWdmVaYUszNnVUc2c1SXQycEF0b1dZM0pIR0UwVlJaR0plNHZtRGZGY3JYUWpyK3d5K3JReDJkaVRmQW9aTlhiMUZYbnR5QXRUSGFTR3dFR3p1Mk5MVzFOV3hEYkVnTkZnT2l6eXg5QkYzVVVtcFppdm91WEd1QVNRb2JKcDB3c09kM2Z4S1U4blcvK0pEUGdVZWNNR0FXZHdSVDdWejZDbGxRdE9oT1dPaktDeXZJMGZRNk45M2UxUjVZZnZrTy85NXFPbStXbnRmaHRKdG85ZXBNQTRON3BGN3lvQ3VwT1hwdDJnaHRRaHBvWUFhbk5pRjZISjNEblNKS3lScGRGNHErQ3kzQkpkWitMWEIvd2J0OHdKZDg5bDJBM1BTOFRoaDR6b0dPU3RUT2RDMHhFaEdnRkc3eGg2NmdOTFdsYTYvcENPZFY5Zk9ERmQyK0RnNDNiNVIybnNXb3lPNThKVFhxQlFQV0lIbEFNY2hzVExNcG9JMmtRYmlYNkpYcWFyaGtjWEVOOVgzUnBnYW1NakF4RVJSKzQyOENwZnloWDc3cURnOU03RW02YXVpRU00NEtTZmJScUxZZzd4aWZxSm1jMTRCOHoxTHlKOERSSzVDdXBVWlhVblB0VWdPOXpJQThJQWFzamVTTnpSQ294dzBnVWxGU1ZCU1pHZGxYYWhVREp3N09TYnB2QktYOHNXOTBoUElGNzdKajV4MnprenYwTmF4T1JFbVVFa0VMSUZHZ0Zva0xsWVFTcTYxNUdjcjNaay8rSkRodjhOcGVsWnFiZ1dwcFRzQVJ6Q294YURnR3BhdDczWk4wQ2hVbFFhQ2FVdGNWWnowUXZPT2VTNTl3MXd2djhtLzUwcDk4V3lCSEtQK1dMLzBGN3pJUjlHemRVNkZQYW0zeGVrMDFkN2VsNG9zVUxlbzJCVkVNVGFXMWFQeW5ndkpOcE9ZS1RndEtXVk02VFowSmRaaEJvc2M2U2xDSFdHTWdGZG1LQUd5eUs0NDZlOHV2c25EaEhUdkRQL1hYR2ZyeVRiL0ZKMnVNVXZpTmo0R2psaDcxb2laMEJkTFNHcXlIbk8wT0UxMERSUEV4b3Y5aGpmeTNrcG8zZ2RITE9iblYzdEJKZEhaTGpFcHFtUUxSR1FxS0VJbzBJdXd3VnRmblZDZER5WXI5Z0oxdmVGLytWa0RlRkRqZUlUeldRdGQzT0p2dmNuU0hMWVhrZ3RWaWxGV0YrV1ZELzJNWStXK3R6blQxbHEvVE9LdkVJenBKSFc2QU1GMnpuUTRmUCtpd0F1UEkwanRyM1dSUG4rZVVoUC9xVDNuc3o3NnRoTnlFOG4vd21NYzhvT1BYbU41TEZVZDMySkhSbWxDSTFYWVVyQ0xGbXUyOU12YTZrWHprSjVTU3J3WGpsNExQTmZ0d2RPdTlmamZSdWFWdHlxcVNXd0pQRUlTeGszQm1SbzIrMUxGbWJobnpDZUhDYi95cVBTbmY1cVFmd1ZXTWNzNGxIYzJqS0YxUU1xQllvUWhiWmMxdmxlTkozNmd1cmpBYzNDNG9mOEFCYUU2QVVVaFhOaWFFaWtYRU1iL25WUTNLQ2RFNmNJcVd6bHFpWDJxL2JHcFFjK0pYdnNQditJVFByNHBkM3diSUc5emhFd2FLcDVycXVwYk5jb1lVMlF6OFZhVGNSRjdTc1E1eW0rekpOd0RUTHZONkk2Mlo2MlpqQWdjdHN4ckhENnd0SHpWRE5ld2xpNWZJV0taSzdlbHpvT1FYUE1tYlVsSys3Wm0rN0E3amljSnU5Ynl5bWxKQ1Rna2RVeXJOVzlIeGRYTXZ5dzFYT0c2SlBmbEd4bC9YTHZNYWlVbk5mcXlPd2RvL2NOMEU2Q1ZjNXJTWDdITVo2ckowOVBVdjJPVytTWW0vRTVDYjd2RDd2RXU4NG5tUlJWRXM3QkFSVW92ZzE2end6Ukp2dWY1aXg1VDdyWktTTjRMeDZ4bm9WVERXMHhlMlNWazF3ak9PR2VkTVlTN3VaaXBMUWoxL1JVcktkejNEVDREZGxlZjFYcnZONjB6dGhUTGt5SEJHb0d3K3ZlaHNkWktPMWNDaXE4d3d1b1gyNUkxZzNwQ1drYS9lYnVvcVJMYXVHUzNZTThGa2U1STlxV2N1cTVSY3NzdC80Ri83TXo1eitUN083bFBnTVIveW1JNHRsM1JFNjFYc0JDbFIxQUlVcjNranRWcDZjeUgxU3JyKzF0cVRQd2hGVFV1dEZWSmFPbnh0YzdKb1hUeG13akdxTUlZOWxkclBIV1g1RlUveVBtTit5T2Q4TDBEK0Z2U0l6NEQzT0dGZ1pGQWhtR29xT2xycE45Y3NxNis2VURyTDNaVmZmMlhrYjcwOStUb28xM0xkWGh1N0lsWGJzOUJrYXlROHluRUk1eGlaVTBWTFV1ck1mek04enZKOW5kbE56MnRoNUdqa3N5OHFGYUtVdFdhaTVnWjdMYm0yNE9vR2xKK05QWGtWeXMyajlaOUpLVmdnWnVRSmNaQTV5SG13eTBqUGxOV3pHWlo3bk9SZjhxOWR2czh6TzlibC8rZlZ5SjhqeFJLVXZsUE5KUWlwMkpHNEMwV1IvQTNzQ1Q4TEtOZlBabzBwRFU2c2Fua0JSc3dJN0lYMkZCMXNSbGRQQS8zeS8vRWt6eGl6Zk45bjl0a05JMytYWDNOQTdHckJuWlFwUmJTZ0VMdTdzaWVtTlNuY2lFK01ROFRQQm9wZWYyVlFXbFRRTEdzVUhDVHRMZTNUM25jdWh5WHJOTE9mZSs0djcvTWt1eC9pNUZvRDk4UGNVSlk3dktNOWg1aW52TndNbENwNjViR216UURlZ0Fha3Z0VWlyZ0xHRzFuaEs0bTV0WWRma3BLcmMyNE5mL1p3ck5rYjc5YmVzVTJ5REd6YzlXTXBFMmZ4SlIrby9CQW5kOU9lWEhKNVpVK1d2clJXNmhMaFk5ZWpWRjZTa05XZXJKMk5vWitQSzh4ckk5dW1kZnFqV2RJSTJvZmpFbnlKZFpGZDdQc3NoNm5tbEF6TEE2WmFmcWlUK3pwNzB2VWRtWXNJaGJLbFZHNW1UbG5UMklKeXMzNXlUUGJkZGxmNEpwQjFlR214dkFTTU1udndwYXlMS0xyQWVabldmbHRqSExsYzlpdy9ISkN2c3lkZFJlcUtTSVVLSWJuSWEwOXZzeUZyeTQ3TGRXcEZ0eWxWL3cwMTJEcTQxQ0t5R1RRSjdSR1hFdWVKTDdBdnNQYVIwMEZzNTd1YzErNkhQck0zMlJPbVdzWWgrMTdxblF4V2JzS3hNUjZFTnhhRFROOXEyMGNqTDkyc0lQbVdRcmsrTit2WXhPZnJ5bW5YdWhHT25aYVVqaHJlZHJFNUxEcGxVdm1oVC9CVmUvSU9oVXNtOVYwbnNoUGhLQzZSb28wcFdMMmdjeXVYcmhuaWx1NCs5Z3ZmWnE5TDEzYmRLNVZGYlo3bGdOZ0xMa0RuZ3JORTV6YVhpdVV3TFhXcVBGaktqM0dTTiszSlkrNnJwMGgxaHQ2S2xHcFFkRFR1V2pzTVcwVGZTVHEyaHg3ckpxSGJyYnBFbXh4REhJMDZNOEZvMklNdWhNOXNuUlYwSHE0WFMzVDdZUm1tbm5INXNSWXc4KzhoZjgwSCtZU2xqbHpNbFJ3OTl2dEp1Z2h4R3NsenhEUE1NOHh6MEF2RU9mWmU2Q0NZeE5Wb2RiSk8vZDVTRTdKbWhJOXUrekhydlRZV3JqTTBpVlhwVkp5YTFzVjh5bzk1NXp6aU0rN2NLR29WUnBXK2g1cHlVYkhkQXNVV0xQYXNxUlhocG51dHNLNmFEMjU3d0doYWc5VFNSdkIwTUw0VU9qYytBMTZFZlNaOGdiak15bGp3L0dNQ2VVbDFWUjV5enBsWUpQY1JrUW9pVzkwa3IxWFg2b0gxa3JvYlNVamRqT0p2THhCV0lEUWJBcGRDWjhBcDhDTGhyTUo1M0FEUy9kZ24rWHRJK0lCSFVPOHl6QmNRdTlHbERyWHJndDQxTjVhMk1sc1JXM0FiQ1RBOXVzb1U2MllVZjN1OUxoLzlMbDlsZ051TThqSDU2R0t0YXltMG8vc3BUclBOZjMrWUczWkwwa2RsSGhXK3pLWHJWVHhFWnV1aEZWdXlwUmtzQnV5K05hUzFwb0pWZFhrTkdIMGJvTndZQjE4QjBCS05JakZYYThHMGRXSElvSHBXOFVEWTFCL1ZocnptQ3Y4OTl6VXhja0toTEozVVQwR0dXa3RtdEtsZDBhdEI2QU4xSEV2QjY5VFdiVk5kMXdtdHF4bjhCVFJpNzVIT0RTK0FGNmw0SVhRcTYzeUllamt1NDNoZ041ZWY2c1Evb1RYZC9aTzE5RHV6cUt0RmRDR25Jc0tGV0tQMmxxVHJmR3pmUEhZSlhuVkMzcDZNOEkwYXJrRjFuYWtmRVplZ004R3A0RG5vdWZFcDlobWhmYjlvM1BCczduNUtCWHVNNGgrdzFNSTQ3VG1KZVpvNzlkMlF3Y2JwamNRMkZGdVM0d0RuNE5XZTNFYlY1U3NhVFYwSjhyZ0trdTJGWUpZMWUxME1RYXA1T0dRV2VtOStaTGYzajBUeEVLUUtuYkpmV3NrM0ZKR3g1cm04Qm94WHFxdGpIYU5yVUg1NjFhV2p2V2lCUjIxUk9pUFczdUpDNkFYV2MvRHpDRCtIT0EzN1hIV3poOE4wUVN6bHA5YTVOMTNoNXp4b2piK1ZvQXVSaE1ORmNTeGlSUWZ1TFYxMW5COVQ5ZHlxQ3VOeEhaZFZYYUZMeEJuU2k2YXVlT3JrdWNPbkppOVVmWUROZEkrb1B6bVFOU3VzLzRWL29TY1VCaTdac3FQV0picXVGK0hpZEVGMDBWTDBiU1JBOUczcTZYWUVqRGVsbzQyVlhhM0xzZ2N1Z0ZPa1o1YWZTVHdUZmw1cW5pSmRMSlhEeU1XODU4dmJBWVJWZFIyaitLUHFxdDBzcFNLQ2w3eXVOd1dNdDBoMTJiaGlaaWxHekNYaTNPZ0YrQm5XVTBuUGpKK255K2s4Y2JrakR5TjM1aS9ZM3g0Z2YwaDExWFFwUVNIb3NIdGRxYTRWVEN0eXRVbXRuOERyZWxrNjF1WTRhVnFqOHd2RWFaTUtua3A2Z3YxTW9lZVZQTy9xY2xuSmNlR3duTERKV3dQa1Rhb3I2TnRvVnVtQ1FpaXpReXF5bXRwaWpkNnQ3dGlOenZXWUF6Kys2bEpiUWM4eEkwYk1wY1c1ekhQRFU2U25GaytGbnpuamxLam5oOHIrbE11NTU4K1hUL24zdHd2SVVYVTk1NzRTZEVMaDZIVTVYU0lpbE5HbXN1UzJLdEdhb3VlNEprcXJuYnltc240b01EZWtZNDI4dFZqTWdyM3hoYVJUbXMxNEl1S0pRMCtEZUNhV1UwL0R4VUllZXQ2WnYrQWY2ei9qeTlzSDVOV0E4YWk2MUJVNUZRNlhDQlY3QlhIVldiKzJwYmJ4MDJpOXRyeTIzc3IzQ1VWWDhZYVBRQ3F0VEhEQVhFbzZiYVVFbmlLZUNEMko1Qm5oRjBtZTExcjNTWXh3c1p5d3lZLzVQRHR1MytIZmd4L3hNSit3MUhmWnorOXdjcGludWVzR2VxSWJuT3VpTWxhdnR1aFpKN200clNheGxoendHcVVkYjdyalJOUjNMZ0d2d1NjK2RpaXVpM29pejFpVGo1bGRjNDQ0dFRtMU9aTjhudkpGV2J6UHdqZ3p6SGNaNndXUDgxTSsvZTdqQ0QrRzZqcGhRNUFhNlJSZEtqT2tzR3kzc3E3V05ieU9EZHYydWtwUmEwZHZsVlJlYnNIOWxtcE1yNis1bURja1l3YU40RDBOeEF2Z21lQ0p6Qk9IdmlybUNSSFBvWjdWMFpjRDA3aG5udUZ1ZlkvUC9VbGJCZTUySGtmVjlSNTN0ZkFlRzZEV1VWMGZSRW9PUytzc1l4dVVpV2dBMnZwUXlEb09YNjZsZU45TWlZdVh5NDJ2R0oyWDh2dXZaMGF1Ri9FMFZNa3JEUFpHRnhJdlpEMEhua2g4Qlh4bCt3bkI4OGpsTkNJdWN0bnRPNVpwNWtIOWxMdjVkM3gydXlYazZIVjl5Q09PWGxkSE1LeGpEcG1oS0NpVDFZcnJXSG9RRXJaZTZpVlVXMWJxdW4zN2xidDl0UWRITEg3RkovRDE0eW9LcjhBc21IMlVESFFSOE1MbU9lSkpvSzhTbmlBL0FUMVYrbm1OL2t4ajd1K3dqS2VNQzF6VzkvajMzMzJrN2FjSUdBY21abmFVS3VaT2xIUWJsRXV1RzIrdWszcVdaTGs5SXl5dEtxWVZLL3dLbEt0WVlxMWxKRmMyNG5wUjZIVWg2QVV6VzU1YXZkK1hzczRsbnpZWWVvcjFsZXl2RkUxbFJjUnptek5OOVRLSi9RbGxQdUhKOGgvNUQvNjdHK3NDMzNvZ3h3VGtxNnRJdUdLNmdMUmRNQ2xic3VXMUdrZGl0UlcyVFVZcnArYU5UcEJjV3ozVExTT2JYbTJDVnJ2UTNsYzl6Z25LbXRkbGFkdG9BZHJidnBBNGMvT29uaUdlWW4yRjhpdkVWMDQvVWNTelRKOHV3Zm13ZFB0MzJFMHpoK1V4a1VmYndjOUZRbTdhaytNcUVnTjNiTkpaY2RlVlZOb3V5dUttMjhPcjErUFdwZEoyVm1EQldsb25vV3BiWGJ2OTNacDNXdi9PRmJFZ0ZrbHpNOVp0NElhMllQUEJzSmQ5Q1RxWE9KUDEzUGlaMEJQUUUreXZKTDVTNWhOQ3o3TEdpMUxpTEErSC9RR05sN3lZLzU1bmVjSi95SSsveTBvT1A3RTk0UU8rNUlMZitNRTZZTnFCbDRycG5Mb2VQNjZTbGpRMUltYU9TNVpiczJCR3pCWXpaamJ0dlRXUW05cEdBSnJhK3hyQkk3UXhBc05CMWlWd0lYR09kSVk0eFhxT2VOb011TDRDUHlIOEZlbW5oSjdOVlM5cTVIa1pmVGt5amZCc2ZwOXArWXovbEgvM2hpWE1melpBWG9YeUc5SURkM3hPdXF1YlZFZmF0WmFpQmJzU01XUFBja3l0cjlZVFlqSk1XTzFDaXhGNUZORXV2blZ3MEZiR0ZnZGJlOG1YUmhmQXVhUnp5MmV5VHBHZUN6MHpia0dmYWRJaGZTWDdxU0tlWmEwdmF1Zzh4cnpjY2ppTW5FMXdXUDRqL3p4L3oyZkpHL3JLZmxaQTNpUXBJM2U4SmRLMVp2UmRKYW5aZWNFczRaZ0lKdENFT1J4SHlvQ0R4VUd3eDlxREx4MnhCeTVwclRxWFJ1ZVN6MEhuc2svWDlQa0xvUmZJenpEUHJGeVRoZkdFNEltY1QwUStXOExQUzhhTEtQVzhqT1Z5eStHdzhIU2VtUmQ0bURlOXFqZkVPai9MUXg5Qi9KcS9qdDl5VW5iTS9aNTMraDQydzNiWUtwZGR0ZTZvbEx2WTdSRythK3RPZ1YxYU80VzNOaHRRcjNDZmpnNnlhRTI1M0N3MFNWNlVtck50T3ROVW1Oa24zb2U0SUhXQmRKSEtjMWRkOUpvdkR0SHRONGRsZjhFMHNVb0dQRXo0NUdnMy9Fc0M4aEtVditLOUdLbmRCVk0vc09zTGJIS1QyODdkZG5Ic1ZPb09heWZuVG1qbllJdGpFMmd3T1ZqcXdWMjBUdlZvR2Z6RWJTSEpDbHJTTEt1ZG1SQmp5Z2ZYMktQY1MxeTY1ajVWOXIxeVA0M2pZVXVPNSt5bWV6eWZUem10M3dUR3p4MEl2TElSNWowb00yT1gxQzRwdzViRE1HMjBrZG1FaDQzc0RSMmJhbThLR213Tkt0bW4zZXU0OXVJckc1MkphRzZ2NnVMYXBtbUZKMHVqeFJoTEhGTFRhREhXMGFPb1U3Q2RSaTVtWUhtZnMvcC9ybnVSZlB3TjlpSDV1UU81Z3ZJcEgrblgvT2U0dVNrbVpIY1hkNFdocjB4RGJMbytyV0ZwQzk3MjZtcVA2VXpwNUZwQWtSU3R5M1k3cVlhU2xtdEFyZEpTbGpxYk1rczVwZW9jeWlrUFpRN3FkSUVXaUFXNjVRRkxmY3ErZnNvbmE3Zm1TOW1CWHpTUXErOXhsSmEycDlaSmdaUFlvVElRcFZLN3BIYkdYZUtPamJ1Z3pjdERpV3BLVzFLMWJaaFpDTGNOTStXMjUySmZFK3BXMHpLT1dnSXRRa3RRbGtKWkpyTHVjWVd6ZkorejJqYTkvT01xNnBjSzVCVVZCa2N3L3pmdnhWL3lQQ29uY1VFcHNJbUJzekpSeWgyNmFPSCtITjUxMGJtK3RLVnNUM2hSOGJLLzNwVjB3SFdtVnJITmtheHRCN2l6L0FkK2xjZk5MZUdUWEcrUVAzbXJwRjhha05mQUhIZTloc2Z4Z1A5Si84RHp1TStmQ2M0Q2RyRmwxb0YzdEdGK2JkUGw0NGJMOTIvczIzdTl5K2haZGpmMlNIekRCcGIrMXFMK0N6NWUyeGYrNXBia1R6alh1K3oxZ2xIL0JEamx6MTY3SGplM0pIOTFIOTRmWXFQS1h6cVExNzZyYVl2bGZBcUNqM2pNWTMxNDQ0LytOK0QvNFV3QXg4MlBqOGVyTzFWLy9BTnNFdlkvRXBDdi9kN0hxL20zYjdnZS8rNjZYdkxxOFlPTTA4azJiNC9iYzhUYlMvQVd5TnZqTFpDM1FONGViNEc4QmZMMmVBdmtsMy84L3dNQU9sVmlvVEMxL29NQUFBQUFTVVZPUks1Q1lJST0nLFxuICBtb3ZlZDogZmFsc2UsXG4gIHBvaW50czogW10sXG4gIHZlbG9jaXR5RmlsdGVyV2VpZ2h0OiAwLjEsXG4gIF9sYXN0VmVsb2NpdHk6IDAsXG4gIF9sYXN0V2lkdGg6IDAsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oY2FudmFzLCBvcHQgPSB7fSkge1xuXG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy53aWR0aCA9IG9wdC53aWR0aCB8fCBjYW52YXMuZnJlZURyYXdpbmdCcnVzaC53aWR0aDtcbiAgICB0aGlzLmNvbG9yID0gb3B0LmNvbG9yIHx8IGNhbnZhcy5mcmVlRHJhd2luZ0JydXNoLmNvbG9yO1xuICAgIHRoaXMuX3BvaW50ID0gbmV3IGZhYnJpYy5Qb2ludCgpO1xuICAgIHRoaXMuSmFwYW5lc2VCcnVzaEJhc2U2NCA9IG9wdC5pbWFnZSB8fCB0aGlzLkphcGFuZXNlQnJ1c2hCYXNlNjQ7XG5cbiAgICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmxpbmVKb2luID0gJ3JvdW5kJztcbiAgICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmxpbmVDYXAgPSAncm91bmQnO1xuXG4gICAgZmFicmljLkltYWdlLmZyb21VUkwodGhpcy5KYXBhbmVzZUJydXNoQmFzZTY0LCAoYnJ1c2gpID0+IHtcbiAgICAgIHRoaXMuYnJ1c2ggPSBicnVzaDtcbiAgICAgIHRoaXMuYnJ1c2guZmlsdGVycyA9IFtdO1xuICAgICAgdGhpcy5jaGFuZ2VDb2xvcih0aGlzLmNvbG9yKTtcbiAgICB9LCB7Y3Jvc3NPcmlnaW46IFwiYW5vbnltb3VzXCJ9KTtcbiAgfSxcblxuICBjaGFuZ2VDb2xvcjogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgdGhpcy5jb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IoY29sb3IpLnRvUmdiYSgpO1xuICAgIHRoaXMub3BhY2l0eSA9IC8oLChcXHMpKihcXGQoXFwuXFxkKFxcZCopKSopXFwpKS9nLmV4ZWModGhpcy5jb2xvcilbM107XG4gICAgdGhpcy5icnVzaC5maWx0ZXJzWzBdID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLlRpbnQoe2NvbG9yOiAnIycgKyBuZXcgZmFicmljLkNvbG9yKGNvbG9yKS50b0hleCgpfSk7XG4gICAgdGhpcy5icnVzaC5hcHBseUZpbHRlcnModGhpcy5jYW52YXMucmVuZGVyQWxsLmJpbmQodGhpcy5jYW52YXMpKTtcbiAgfSxcblxuICBvbk1vdXNlRG93bjogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHRoaXMubW92ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBvaW50cyA9IFtdO1xuICAgIHRoaXMuX2xhc3RWZWxvY2l0eSA9IDA7XG4gICAgdGhpcy5fbGFzdFdpZHRoID0gMDtcbiAgICB0aGlzLl9zdHJva2VVcGRhdGUocG9pbnRlcik7XG4gIH0sXG5cbiAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcblxuICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLmNhbnZhcy5faXNDdXJyZW50bHlEcmF3aW5nKSB7XG4gICAgICB0aGlzLl9zdHJva2VVcGRhdGUocG9pbnRlcik7XG4gICAgfVxuICB9LFxuXG4gIG9uTW91c2VVcDogZnVuY3Rpb24oKSB7XG4gICAgbGV0IGNhbkRyYXdDdXJ2ZSA9IHRoaXMucG9pbnRzLmxlbmd0aCA+IDI7XG4gICAgbGV0IHBvaW50ID0gdGhpcy5wb2ludHNbMF07XG5cbiAgICBpZiAoIWNhbkRyYXdDdXJ2ZSAmJiBwb2ludCkge1xuICAgICAgbGV0IHZ0ID0gdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm07XG4gICAgICBjb25zdCBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSh2dFswXSwgdnRbMV0sIHZ0WzJdLCB2dFszXSwgdnRbNF0sIHZ0WzVdKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMub3BhY2l0eTtcbiAgICAgIHRoaXMuX2RyYXdQb2ludChjdHgsIHBvaW50LngsIHBvaW50LnksICh0aGlzLndpZHRoICsgdGhpcy5taW5XaWR0aCkgLyAyKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgICB0aGlzLl9sYXN0VmVsb2NpdHkgPSAwO1xuICAgIHRoaXMuX2xhc3RXaWR0aCA9IDA7XG4gIH0sXG5cbiAgX3N0cm9rZVVwZGF0ZShwb2ludGVyKSB7XG4gICAgbGV0IHBvaW50ID0gbmV3IFBvaW50KHBvaW50ZXIueCwgcG9pbnRlci55KTtcbiAgICB0aGlzLl9hZGRQb2ludChwb2ludCk7XG4gIH0sXG5cbiAgX2FkZFBvaW50KHBvaW50KSB7XG4gICAgdmFyIF9wb2ludHMgPSB0aGlzLnBvaW50cyxcbiAgICAgICAgYzIsIGMzLFxuICAgICAgICBjdXJ2ZSwgdG1wO1xuXG4gICAgX3BvaW50cy5wdXNoKHBvaW50KTtcblxuICAgIGlmIChfcG9pbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIC8vIFRvIHJlZHVjZSB0aGUgaW5pdGlhbCBsYWcgbWFrZSBpdCB3b3JrIHdpdGggMyBfcG9pbnRzXG4gICAgICAvLyBieSBjb3B5aW5nIHRoZSBmaXJzdCBwb2ludCB0byB0aGUgYmVnaW5uaW5nLlxuICAgICAgaWYgKF9wb2ludHMubGVuZ3RoID09PSAzKSBfcG9pbnRzLnVuc2hpZnQoX3BvaW50c1swXSk7XG5cbiAgICAgIHRtcCA9IHRoaXMuX2NhbGN1bGF0ZUN1cnZlQ29udHJvbFBvaW50cyhfcG9pbnRzWzBdLCBfcG9pbnRzWzFdLCBfcG9pbnRzWzJdKTtcbiAgICAgIGMyID0gdG1wLmMyO1xuICAgICAgdG1wID0gdGhpcy5fY2FsY3VsYXRlQ3VydmVDb250cm9sUG9pbnRzKF9wb2ludHNbMV0sIF9wb2ludHNbMl0sIF9wb2ludHNbM10pO1xuICAgICAgYzMgPSB0bXAuYzE7XG4gICAgICBjdXJ2ZSA9IG5ldyBCZXppZXIoX3BvaW50c1sxXSwgYzIsIGMzLCBfcG9pbnRzWzJdKTtcbiAgICAgIHRoaXMuX2FkZEN1cnZlKGN1cnZlKTtcblxuICAgICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBlbGVtZW50IGZyb20gdGhlIGxpc3QsXG4gICAgICAvLyBzbyB0aGF0IHdlIGFsd2F5cyBoYXZlIG5vIG1vcmUgdGhhbiA0IF9wb2ludHMgaW4gX3BvaW50cyBhcnJheS5cbiAgICAgIF9wb2ludHMuc2hpZnQoKTtcbiAgICB9XG4gIH0sXG5cbiAgX2NhbGN1bGF0ZUN1cnZlQ29udHJvbFBvaW50cyhzMSwgczIsIHMzKSB7XG4gICAgdmFyIGR4MSA9IHMxLnggLSBzMi54LCBkeTEgPSBzMS55IC0gczIueSxcbiAgICAgIGR4MiA9IHMyLnggLSBzMy54LCBkeTIgPSBzMi55IC0gczMueSxcblxuICAgICAgbTEgPSB7eDogKHMxLnggKyBzMi54KSAvIDIuMCwgeTogKHMxLnkgKyBzMi55KSAvIDIuMH0sXG4gICAgICBtMiA9IHt4OiAoczIueCArIHMzLngpIC8gMi4wLCB5OiAoczIueSArIHMzLnkpIC8gMi4wfSxcblxuICAgICAgbDEgPSBNYXRoLnNxcnQoZHgxICogZHgxICsgZHkxICogZHkxKSxcbiAgICAgIGwyID0gTWF0aC5zcXJ0KGR4MiAqIGR4MiArIGR5MiAqIGR5MiksXG5cbiAgICAgIGR4bSA9IChtMS54IC0gbTIueCksXG4gICAgICBkeW0gPSAobTEueSAtIG0yLnkpLFxuXG4gICAgICBrID0gbDIgLyAobDEgKyBsMiksXG4gICAgICBjbSA9IHt4OiBtMi54ICsgZHhtICogaywgeTogbTIueSArIGR5bSAqIGt9LFxuXG4gICAgICB0eCA9IHMyLnggLSBjbS54LFxuICAgICAgdHkgPSBzMi55IC0gY20ueTtcblxuICAgIHJldHVybiB7XG4gICAgICBjMTogbmV3IFBvaW50KG0xLnggKyB0eCwgbTEueSArIHR5KSxcbiAgICAgIGMyOiBuZXcgUG9pbnQobTIueCArIHR4LCBtMi55ICsgdHkpXG4gICAgfTtcbiAgfSxcblxuICBfYWRkQ3VydmUoY3VydmUpIHtcbiAgICB2YXIgc3RhcnRQb2ludCA9IGN1cnZlLnN0YXJ0UG9pbnQsXG4gICAgZW5kUG9pbnQgPSBjdXJ2ZS5lbmRQb2ludCxcbiAgICB2ZWxvY2l0eSwgbmV3V2lkdGg7XG5cbiAgICB2ZWxvY2l0eSA9IGVuZFBvaW50LnZlbG9jaXR5RnJvbShzdGFydFBvaW50KTtcbiAgICB2ZWxvY2l0eSA9IHRoaXMudmVsb2NpdHlGaWx0ZXJXZWlnaHQgKiB2ZWxvY2l0eSArICgxIC0gdGhpcy52ZWxvY2l0eUZpbHRlcldlaWdodCkgKiB0aGlzLl9sYXN0VmVsb2NpdHk7XG5cbiAgICBuZXdXaWR0aCA9IHRoaXMuX3N0cm9rZVdpZHRoKHZlbG9jaXR5KTtcbiAgICB0aGlzLl9kcmF3Q3VydmUoY3VydmUsIHRoaXMuX2xhc3RXaWR0aCwgbmV3V2lkdGgpO1xuXG4gICAgdGhpcy5fbGFzdFZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgdGhpcy5fbGFzdFdpZHRoID0gbmV3V2lkdGg7XG4gIH0sXG5cbiAgX2RyYXdQb2ludChjdHgsIHgsIHksIHNpemUpIHtcbiAgICBjdHguZHJhd0ltYWdlKHRoaXMuYnJ1c2guX2VsZW1lbnQsIHggLSAoc2l6ZSAvIDIpLCB5IC0gKHNpemUgLyAyKSwgc2l6ZSwgc2l6ZSk7XG4gIH0sXG5cbiAgX2RyYXdDdXJ2ZShjdXJ2ZSwgc3RhcnRXaWR0aCwgZW5kV2lkdGgpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuXG4gICAgdmFyIHdpZHRoRGVsdGEgPSBlbmRXaWR0aCAtIHN0YXJ0V2lkdGgsXG4gICAgICBkcmF3U3RlcHMsIHdpZHRoLCBpLCB0LCB0dCwgdHR0LCB1LCB1dSwgdXV1LCB4LCB5O1xuXG4gICAgbGV0IHZ0ID0gdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm07XG5cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2Zvcm0odnRbMF0sIHZ0WzFdLCB2dFsyXSwgdnRbM10sIHZ0WzRdLCB2dFs1XSk7XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5vcGFjaXR5O1xuXG4gICAgZHJhd1N0ZXBzID0gTWF0aC5mbG9vcihjdXJ2ZS5sZW5ndGgoKSk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBkcmF3U3RlcHM7IGkrKykge1xuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBCZXppZXIgKHgsIHkpIGNvb3JkaW5hdGUgZm9yIHRoaXMgc3RlcC5cbiAgICAgIHQgPSBpIC8gZHJhd1N0ZXBzO1xuICAgICAgdHQgPSB0ICogdDtcbiAgICAgIHR0dCA9IHR0ICogdDtcbiAgICAgIHUgPSAxIC0gdDtcbiAgICAgIHV1ID0gdSAqIHU7XG4gICAgICB1dXUgPSB1dSAqIHU7XG5cbiAgICAgIHggPSB1dXUgKiBjdXJ2ZS5zdGFydFBvaW50Lng7XG4gICAgICB4ICs9IDMgKiB1dSAqIHQgKiBjdXJ2ZS5jb250cm9sMS54O1xuICAgICAgeCArPSAzICogdSAqIHR0ICogY3VydmUuY29udHJvbDIueDtcbiAgICAgIHggKz0gdHR0ICogY3VydmUuZW5kUG9pbnQueDtcblxuICAgICAgeSA9IHV1dSAqIGN1cnZlLnN0YXJ0UG9pbnQueTtcbiAgICAgIHkgKz0gMyAqIHV1ICogdCAqIGN1cnZlLmNvbnRyb2wxLnk7XG4gICAgICB5ICs9IDMgKiB1ICogdHQgKiBjdXJ2ZS5jb250cm9sMi55O1xuICAgICAgeSArPSB0dHQgKiBjdXJ2ZS5lbmRQb2ludC55O1xuXG4gICAgICB3aWR0aCA9IHN0YXJ0V2lkdGggKyB0ICogd2lkdGhEZWx0YTtcbiAgICAgIHRoaXMuX2RyYXdQb2ludChjdHgsIHgsIHksIHdpZHRoKTtcbiAgICB9XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsKCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfSxcblxuICBfc3Ryb2tlV2lkdGgodmVsb2NpdHkpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgodGhpcy53aWR0aCAvICh2ZWxvY2l0eSArIDEpLCB0aGlzLm1pbldpZHRoKTtcbiAgfVxufSk7XG5cbnZhciBQb2ludCA9IGZ1bmN0aW9uICh4LCB5LCB0aW1lKSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMudGltZSA9IHRpbWUgfHwgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudmVsb2NpdHlGcm9tID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgcmV0dXJuICh0aGlzLnRpbWUgIT09IHN0YXJ0LnRpbWUpID8gdGhpcy5kaXN0YW5jZVRvKHN0YXJ0KSAvICh0aGlzLnRpbWUgLSBzdGFydC50aW1lKSA6IDE7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZGlzdGFuY2VUbyA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy54IC0gc3RhcnQueCwgMikgKyBNYXRoLnBvdyh0aGlzLnkgLSBzdGFydC55LCAyKSk7XG59O1xuXG52YXIgQmV6aWVyID0gZnVuY3Rpb24gKHN0YXJ0UG9pbnQsIGNvbnRyb2wxLCBjb250cm9sMiwgZW5kUG9pbnQpIHtcbiAgICB0aGlzLnN0YXJ0UG9pbnQgPSBzdGFydFBvaW50O1xuICAgIHRoaXMuY29udHJvbDEgPSBjb250cm9sMTtcbiAgICB0aGlzLmNvbnRyb2wyID0gY29udHJvbDI7XG4gICAgdGhpcy5lbmRQb2ludCA9IGVuZFBvaW50O1xufTtcblxuLy8gUmV0dXJucyBhcHByb3hpbWF0ZWQgbGVuZ3RoLlxuQmV6aWVyLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0ZXBzID0gMTAsXG4gICAgICAgIGxlbmd0aCA9IDAsXG4gICAgICAgIGksIHQsIGN4LCBjeSwgcHgsIHB5LCB4ZGlmZiwgeWRpZmY7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDw9IHN0ZXBzOyBpKyspIHtcbiAgICAgICAgdCA9IGkgLyBzdGVwcztcbiAgICAgICAgY3ggPSB0aGlzLl9wb2ludCh0LCB0aGlzLnN0YXJ0UG9pbnQueCwgdGhpcy5jb250cm9sMS54LCB0aGlzLmNvbnRyb2wyLngsIHRoaXMuZW5kUG9pbnQueCk7XG4gICAgICAgIGN5ID0gdGhpcy5fcG9pbnQodCwgdGhpcy5zdGFydFBvaW50LnksIHRoaXMuY29udHJvbDEueSwgdGhpcy5jb250cm9sMi55LCB0aGlzLmVuZFBvaW50LnkpO1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIHhkaWZmID0gY3ggLSBweDtcbiAgICAgICAgICAgIHlkaWZmID0gY3kgLSBweTtcbiAgICAgICAgICAgIGxlbmd0aCArPSBNYXRoLnNxcnQoeGRpZmYgKiB4ZGlmZiArIHlkaWZmICogeWRpZmYpO1xuICAgICAgICB9XG4gICAgICAgIHB4ID0gY3g7XG4gICAgICAgIHB5ID0gY3k7XG4gICAgfVxuICAgIHJldHVybiBsZW5ndGg7XG59O1xuXG5CZXppZXIucHJvdG90eXBlLl9wb2ludCA9IGZ1bmN0aW9uICh0LCBzdGFydCwgYzEsIGMyLCBlbmQpIHtcbiAgICByZXR1cm4gICAgICAgICAgc3RhcnQgKiAoMS4wIC0gdCkgKiAoMS4wIC0gdCkgICogKDEuMCAtIHQpXG4gICAgICAgICAgICsgMy4wICogIGMxICAgICogKDEuMCAtIHQpICogKDEuMCAtIHQpICAqIHRcbiAgICAgICAgICAgKyAzLjAgKiAgYzIgICAgKiAoMS4wIC0gdCkgKiB0ICAgICAgICAgICogdFxuICAgICAgICAgICArICAgICAgICBlbmQgICAqIHQgICAgICAgICAqIHQgICAgICAgICAgKiB0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RyYXdUb29sL2JydXNoZXMvYnJ1c2hlcy9qYXBhbmVzZUJydXNoLmpzIiwiaW1wb3J0IHtmYWJyaWN9IGZyb20gJ2ZhYnJpYyc7XG5cbmxldCBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kO1xubGV0IGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycztcbmxldCBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG5maWx0ZXJzLlJlbW92ZUNvbG9yID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAge1xuXG4gIHR5cGU6ICdSZW1vdmVDb2xvcicsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5jb2xvciA9IG9wdGlvbnMuY29sb3IgfHwgJyNmZmZmZmYnO1xuXG4gICAgdGhpcy5kaXN0YW5jZSA9IG9wdGlvbnMuZGlzdGFuY2UgPT09IHVuZGVmaW5lZCA/IDEgOiBOdW1iZXIob3B0aW9ucy5kaXN0YW5jZSk7XG5cbiAgfSxcblxuICBhcHBseVRvOiBmdW5jdGlvbihjYW52YXNFbCkge1xuICAgIHZhciBjb250ZXh0ID0gY2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgIGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhc0VsLndpZHRoLCBjYW52YXNFbC5oZWlnaHQpLFxuICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpLFxuICAgICAgdGhyZXNob2xkID0gNjAsXG4gICAgICBkaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2UsXG4gICAgICBsaW1pdCA9IDI1NSAtIHRocmVzaG9sZCxcbiAgICAgIHIsIGcsIGI7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgciA9IGRhdGFbaV07XG4gICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICBiID0gZGF0YVtpICsgMl07XG5cbiAgICAgIGlmKFxuICAgICAgICBNYXRoLmFicyhyIC0gY29sb3IuX3NvdXJjZVswXSkgPCBkaXN0YW5jZSAmJlxuICAgICAgICBNYXRoLmFicyhnIC0gY29sb3IuX3NvdXJjZVsxXSkgPCBkaXN0YW5jZSAmJlxuICAgICAgICBNYXRoLmFicyhiIC0gY29sb3IuX3NvdXJjZVsyXSkgPCBkaXN0YW5jZVxuICAgICAgKXtcbiAgICAgICAgZGF0YVtpICsgM10gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBjb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICB9LFxuXG4gIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcpLCB7XG4gICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgIGRpc3RhbmNlOiB0aGlzLmRpc3RhbmNlLFxuICAgIH0pO1xuICB9XG59KTtcblxuZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlQ29sb3IuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICByZXR1cm4gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZUNvbG9yKG9iamVjdCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9kcmF3VG9vbC91dGlscy9yZW1vdmVDb2xvci5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9zaGltXCIpO1xuXG5yZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9mbi9yZWdleHAvZXNjYXBlXCIpO1xuXG5pZiAoZ2xvYmFsLl9iYWJlbFBvbHlmaWxsKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIm9ubHkgb25lIGluc3RhbmNlIG9mIGJhYmVsLXBvbHlmaWxsIGlzIGFsbG93ZWRcIik7XG59XG5nbG9iYWwuX2JhYmVsUG9seWZpbGwgPSB0cnVlO1xuXG52YXIgREVGSU5FX1BST1BFUlRZID0gXCJkZWZpbmVQcm9wZXJ0eVwiO1xuZnVuY3Rpb24gZGVmaW5lKE8sIGtleSwgdmFsdWUpIHtcbiAgT1trZXldIHx8IE9iamVjdFtERUZJTkVfUFJPUEVSVFldKE8sIGtleSwge1xuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSk7XG59XG5cbmRlZmluZShTdHJpbmcucHJvdG90eXBlLCBcInBhZExlZnRcIiwgXCJcIi5wYWRTdGFydCk7XG5kZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgXCJwYWRSaWdodFwiLCBcIlwiLnBhZEVuZCk7XG5cblwicG9wLHJldmVyc2Usc2hpZnQsa2V5cyx2YWx1ZXMsZW50cmllcyxpbmRleE9mLGV2ZXJ5LHNvbWUsZm9yRWFjaCxtYXAsZmlsdGVyLGZpbmQsZmluZEluZGV4LGluY2x1ZGVzLGpvaW4sc2xpY2UsY29uY2F0LHB1c2gsc3BsaWNlLHVuc2hpZnQsc29ydCxsYXN0SW5kZXhPZixyZWR1Y2UscmVkdWNlUmlnaHQsY29weVdpdGhpbixmaWxsXCIuc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBbXVtrZXldICYmIGRlZmluZShBcnJheSwga2V5LCBGdW5jdGlvbi5jYWxsLmJpbmQoW11ba2V5XSkpO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1wb2x5ZmlsbC9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnRpZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5zZWFsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5wcmV2ZW50LWV4dGVuc2lvbnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLWZyb3plbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtc2VhbGVkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1leHRlbnNpYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wYXJzZS1pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucGFyc2UtZmxvYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmNvbnN0cnVjdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci50by1maXhlZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIudG8tcHJlY2lzaW9uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtc2FmZS1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5tYXgtc2FmZS1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1mbG9hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtaW50Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYWNvc2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hc2luaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmF0YW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY2JydCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNsejMyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY29zaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmV4cG0xJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5pbXVsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cxcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5zaWduJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguc2luaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnRhbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC50cnVuYycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5yYXcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN0YXJ0cy13aXRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5hbmNob3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmJpZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYmxpbmsnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmJvbGQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZpeGVkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mb250Y29sb3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRzaXplJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pdGFsaWNzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5saW5rJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zbWFsbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3RyaWtlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdWInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN1cCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLm5vdycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1pc28tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tcHJpbWl0aXZlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmlzLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZyb20nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuam9pbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zbGljZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zb3J0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZvci1lYWNoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lm1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maWx0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc29tZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5ldmVyeScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLXJpZ2h0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmluZGV4LW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuY29weS13aXRoaW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmlsbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuY29uc3RydWN0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuZmxhZ3MnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLm1hdGNoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5zZWFyY2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnNwbGl0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi53ZWFrLW1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi53ZWFrLXNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5hcnJheS1idWZmZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZGF0YS12aWV3Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDgtY2xhbXBlZC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQxNi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50MzItYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZmxvYXQ2NC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuY29uc3RydWN0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZW51bWVyYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmhhcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5vd24ta2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLmF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtc3RhcnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1lbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tbGVmdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcubWF0Y2gtYWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtZ2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtc2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtZ2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtc2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hcC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5c3RlbS5nbG9iYWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuZXJyb3IuaXMtZXJyb3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pYWRkaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmlzdWJoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaW11bGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC51bXVsaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlZmluZS1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlbGV0ZS1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS1rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEta2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1vd24tbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hc2FwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9ic2VydmFibGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIudGltZXJzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLmltbWVkaWF0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tb2R1bGVzL19jb3JlJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL3NoaW0uanNcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIERFU0NSSVBUT1JTICAgID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBNRVRBICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVlcbiAgLCAkZmFpbHMgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBzaGFyZWQgICAgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgdWlkICAgICAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIHdrcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJylcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxuICAsIHdrc0RlZmluZSAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpXG4gICwga2V5T2YgICAgICAgICAgPSByZXF1aXJlKCcuL19rZXlvZicpXG4gICwgZW51bUtleXMgICAgICAgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKVxuICAsIGlzQXJyYXkgICAgICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIF9jcmVhdGUgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZ09QTkV4dCAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKVxuICAsICRHT1BEICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsICREUCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCAka2V5cyAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BEICAgICAgICAgICA9ICRHT1BELmZcbiAgLCBkUCAgICAgICAgICAgICA9ICREUC5mXG4gICwgZ09QTiAgICAgICAgICAgPSBnT1BORXh0LmZcbiAgLCAkU3ltYm9sICAgICAgICA9IGdsb2JhbC5TeW1ib2xcbiAgLCAkSlNPTiAgICAgICAgICA9IGdsb2JhbC5KU09OXG4gICwgX3N0cmluZ2lmeSAgICAgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnlcbiAgLCBQUk9UT1RZUEUgICAgICA9ICdwcm90b3R5cGUnXG4gICwgSElEREVOICAgICAgICAgPSB3a3MoJ19oaWRkZW4nKVxuICAsIFRPX1BSSU1JVElWRSAgID0gd2tzKCd0b1ByaW1pdGl2ZScpXG4gICwgaXNFbnVtICAgICAgICAgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZVxuICAsIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKVxuICAsIEFsbFN5bWJvbHMgICAgID0gc2hhcmVkKCdzeW1ib2xzJylcbiAgLCBPUFN5bWJvbHMgICAgICA9IHNoYXJlZCgnb3Atc3ltYm9scycpXG4gICwgT2JqZWN0UHJvdG8gICAgPSBPYmplY3RbUFJPVE9UWVBFXVxuICAsIFVTRV9OQVRJVkUgICAgID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJ1xuICAsIFFPYmplY3QgICAgICAgID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBkUCh0aGlzLCAnYScsIHt2YWx1ZTogN30pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24oaXQsIGtleSwgRCl7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZihwcm90b0Rlc2MpZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZihwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKWRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24odGFnKXtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCl7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90bykkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZihoYXMoQWxsU3ltYm9scywga2V5KSl7XG4gICAgaWYoIUQuZW51bWVyYWJsZSl7XG4gICAgICBpZighaGFzKGl0LCBISURERU4pKWRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0paXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7ZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSl9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKXtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpXG4gICAgLCBpICAgID0gMFxuICAgICwgbCA9IGtleXMubGVuZ3RoXG4gICAgLCBrZXk7XG4gIHdoaWxlKGwgPiBpKSRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApe1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSl7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKXJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuICBpdCAgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZihpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSlELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgdmFyIG5hbWVzICA9IGdPUE4odG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xuICAgIGlmKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSlyZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpe1xuICB2YXIgSVNfT1AgID0gaXQgPT09IE9iamVjdFByb3RvXG4gICAgLCBuYW1lcyAgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xuICAgIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSlyZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmKCFVU0VfTkFUSVZFKXtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpe1xuICAgIGlmKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKXRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24odmFsdWUpe1xuICAgICAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8pJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSl0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmKERFU0NSSVBUT1JTICYmIHNldHRlcilzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHtjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mICAgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiAgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJykuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSl7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uKG5hbWUpe1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH1cbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1N5bWJvbDogJFN5bWJvbH0pO1xuXG5mb3IodmFyIHN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaSA9IDA7IHN5bWJvbHMubGVuZ3RoID4gaTsgKXdrcyhzeW1ib2xzW2krK10pO1xuXG5mb3IodmFyIHN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzRGVmaW5lKHN5bWJvbHNbaSsrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24oa2V5KXtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKGtleSl7XG4gICAgaWYoaXNTeW1ib2woa2V5KSlyZXR1cm4ga2V5T2YoU3ltYm9sUmVnaXN0cnksIGtleSk7XG4gICAgdGhyb3cgVHlwZUVycm9yKGtleSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uKCl7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24oKXsgc2V0dGVyID0gZmFsc2U7IH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoe2E6IFN9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpe1xuICAgIGlmKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKXJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIHZhciBhcmdzID0gW2l0XVxuICAgICAgLCBpICAgID0gMVxuICAgICAgLCByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmKHR5cGVvZiByZXBsYWNlciA9PSAnZnVuY3Rpb24nKSRyZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgIGlmKCRyZXBsYWNlciB8fCAhaXNBcnJheShyZXBsYWNlcikpcmVwbGFjZXIgPSBmdW5jdGlvbihrZXksIHZhbHVlKXtcbiAgICAgIGlmKCRyZXBsYWNlcil2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYoIWlzU3ltYm9sKHZhbHVlKSlyZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9faGFzLmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19mYWlscy5qc1xuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgcmVkZWZpbmUgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGN0eCAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKXtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcbiAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0LkdcbiAgICAsIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlNcbiAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcbiAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcbiAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIGV4cFByb3RvICA9IGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pXG4gICAgLCBrZXksIG93biwgb3V0LCBleHA7XG4gIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgaWYodGFyZ2V0KXJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmKGV4cG9ydHNba2V5XSAhPSBvdXQpaGlkZShleHBvcnRzLCBrZXksIGV4cCk7XG4gICAgaWYoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpZXhwUHJvdG9ba2V5XSA9IG91dDtcbiAgfVxufTtcbmdsb2JhbC5jb3JlID0gY29yZTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWAgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qc1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi40LjAnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanNcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoIWlzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnRcbiAgLy8gaW4gb2xkIElFIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnXG4gICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2RvbS1jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIFMpe1xuICBpZighaXNPYmplY3QoaXQpKXJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZighUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanNcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qc1xuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgaGFzICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBTUkMgICAgICAgPSByZXF1aXJlKCcuL191aWQnKSgnc3JjJylcbiAgLCBUT19TVFJJTkcgPSAndG9TdHJpbmcnXG4gICwgJHRvU3RyaW5nID0gRnVuY3Rpb25bVE9fU1RSSU5HXVxuICAsIFRQTCAgICAgICA9ICgnJyArICR0b1N0cmluZykuc3BsaXQoVE9fU1RSSU5HKTtcblxucmVxdWlyZSgnLi9fY29yZScpLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihPLCBrZXksIHZhbCwgc2FmZSl7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nO1xuICBpZihpc0Z1bmN0aW9uKWhhcyh2YWwsICduYW1lJykgfHwgaGlkZSh2YWwsICduYW1lJywga2V5KTtcbiAgaWYoT1trZXldID09PSB2YWwpcmV0dXJuO1xuICBpZihpc0Z1bmN0aW9uKWhhcyh2YWwsIFNSQykgfHwgaGlkZSh2YWwsIFNSQywgT1trZXldID8gJycgKyBPW2tleV0gOiBUUEwuam9pbihTdHJpbmcoa2V5KSkpO1xuICBpZihPID09PSBnbG9iYWwpe1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBpZighc2FmZSl7XG4gICAgICBkZWxldGUgT1trZXldO1xuICAgICAgaGlkZShPLCBrZXksIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKE9ba2V5XSlPW2tleV0gPSB2YWw7XG4gICAgICBlbHNlIGhpZGUoTywga2V5LCB2YWwpO1xuICAgIH1cbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgdGhpc1tTUkNdIHx8ICR0b1N0cmluZy5jYWxsKHRoaXMpO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaWQgPSAwXG4gICwgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19jdHguanNcbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZih0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTUVUQSAgICAgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpXG4gICwgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGhhcyAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBzZXREZXNjICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBpZCAgICAgICA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbigpe1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbihpdCl7XG4gIHNldERlc2MoaXQsIE1FVEEsIHt2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH19KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbihpdCwgY3JlYXRlKXtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZighY3JlYXRlKXJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24oaXQpe1xuICBpZihGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6ICAgICAgTUVUQSxcbiAgTkVFRDogICAgIGZhbHNlLFxuICBmYXN0S2V5OiAgZmFzdEtleSxcbiAgZ2V0V2VhazogIGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fbWV0YS5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXydcbiAgLCBzdG9yZSAgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzXG4vLyBtb2R1bGUgaWQgPSA5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIHRhZywgc3RhdCl7XG4gIGlmKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpZGVmKGl0LCBUQUcsIHtjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWd9KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzXG4vLyBtb2R1bGUgaWQgPSA5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgc3RvcmUgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKVxuICAsIHVpZCAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIFN5bWJvbCAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2xcbiAgLCBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX3drcy1leHQuanNcbi8vIG1vZHVsZSBpZCA9IDEwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxuICAsIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwge3ZhbHVlOiB3a3NFeHQuZihuYW1lKX0pO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gMTAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2xpYnJhcnkuanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2V0S2V5cyAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBlbCl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwga2V5cyAgID0gZ2V0S2V5cyhPKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobGVuZ3RoID4gaW5kZXgpaWYoT1trZXkgPSBrZXlzW2luZGV4KytdXSA9PT0gZWwpcmV0dXJuIGtleTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2tleW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKXtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGhhcyAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgdG9JT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSlcbiAgLCBJRV9QUk9UTyAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBuYW1lcyl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwgaSAgICAgID0gMFxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGtleTtcbiAgZm9yKGtleSBpbiBPKWlmKGtleSAhPSBJRV9QUk9UTyloYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKXtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1xuLy8gbW9kdWxlIGlkID0gMTA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9faW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2NvZi5qc1xuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qc1xuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCB0b0luZGV4ICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCgkdGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG4gICAgICAsIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTyl7XG4gICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanNcbi8vIG1vZHVsZSBpZCA9IDExMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCAgPSBNYXRoLmNlaWxcbiAgLCBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL190by1pbnRlZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1heCAgICAgICA9IE1hdGgubWF4XG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpe1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDExNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKVxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLWtleS5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUFMgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpXG4gICwgcElFICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgcmVzdWx0ICAgICA9IGdldEtleXMoaXQpXG4gICAgLCBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICBpZihnZXRTeW1ib2xzKXtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpXG4gICAgICAsIGlzRW51bSAgPSBwSUUuZlxuICAgICAgLCBpICAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUoc3ltYm9scy5sZW5ndGggPiBpKWlmKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2VudW0ta2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanNcbi8vIG1vZHVsZSBpZCA9IDExOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKXtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBkUHMgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcbiAgLCBFbXB0eSAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cbiAgLCBQUk9UT1RZUEUgICA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uKCl7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpXG4gICAgLCBpICAgICAgPSBlbnVtQnVnS2V5cy5sZW5ndGhcbiAgICAsIGx0ICAgICA9ICc8J1xuICAgICwgZ3QgICAgID0gJz4nXG4gICAgLCBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZShpLS0pZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpe1xuICB2YXIgcmVzdWx0O1xuICBpZihPICE9PSBudWxsKXtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5O1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRQICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcyl7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyAgID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGkgPSAwXG4gICAgLCBQO1xuICB3aGlsZShsZW5ndGggPiBpKWRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qc1xuLy8gbW9kdWxlIGlkID0gMTIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19odG1sLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGdPUE4gICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZlxuICAsIHRvU3RyaW5nICA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24oaXQpe1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanNcbi8vIG1vZHVsZSBpZCA9IDEyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcbiAgLCBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pe1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi5qc1xuLy8gbW9kdWxlIGlkID0gMTI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBwSUUgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIGdPUEQgICAgICAgICAgID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCl7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZihoYXMoTywgUCkpcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanNcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge2NyZWF0ZTogcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7ZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZ9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMTI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuMyAvIDE1LjIuMy43IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0Jywge2RlZmluZVByb3BlcnRpZXM6IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnRpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDEyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG52YXIgdG9JT2JqZWN0ICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJywgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KXtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0b0lPYmplY3QoaXQpLCBrZXkpO1xuICB9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDEzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjb3JlICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSwgZXhlYyl7XG4gIHZhciBmbiAgPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV1cbiAgICAsIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3Qtc2FwLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjkgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgdG9PYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCAkZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0UHJvdG90eXBlT2YnLCBmdW5jdGlvbigpe1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpe1xuICAgIHJldHVybiAkZ2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMTMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgdG9PYmplY3QgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIElFX1BST1RPICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpXG4gICwgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbihPKXtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZihoYXMoTywgSUVfUFJPVE8pKXJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcil7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdwby5qc1xuLy8gbW9kdWxlIGlkID0gMTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCAka2V5cyAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgna2V5cycsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiBmdW5jdGlvbiBrZXlzKGl0KXtcbiAgICByZXR1cm4gJGtleXModG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMTM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5TmFtZXMnLCBmdW5jdGlvbigpe1xuICByZXR1cm4gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0JykuZjtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qc1xuLy8gbW9kdWxlIGlkID0gMTM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi41IE9iamVjdC5mcmVlemUoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgbWV0YSAgICAgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZnJlZXplJywgZnVuY3Rpb24oJGZyZWV6ZSl7XG4gIHJldHVybiBmdW5jdGlvbiBmcmVlemUoaXQpe1xuICAgIHJldHVybiAkZnJlZXplICYmIGlzT2JqZWN0KGl0KSA/ICRmcmVlemUobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi4xNyBPYmplY3Quc2VhbChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBtZXRhICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdzZWFsJywgZnVuY3Rpb24oJHNlYWwpe1xuICByZXR1cm4gZnVuY3Rpb24gc2VhbChpdCl7XG4gICAgcmV0dXJuICRzZWFsICYmIGlzT2JqZWN0KGl0KSA/ICRzZWFsKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZWFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjE1IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyhPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBtZXRhICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdwcmV2ZW50RXh0ZW5zaW9ucycsIGZ1bmN0aW9uKCRwcmV2ZW50RXh0ZW5zaW9ucyl7XG4gIHJldHVybiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyhpdCl7XG4gICAgcmV0dXJuICRwcmV2ZW50RXh0ZW5zaW9ucyAmJiBpc09iamVjdChpdCkgPyAkcHJldmVudEV4dGVuc2lvbnMobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qc1xuLy8gbW9kdWxlIGlkID0gMTM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi4xMiBPYmplY3QuaXNGcm96ZW4oTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzRnJvemVuJywgZnVuY3Rpb24oJGlzRnJvemVuKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzRnJvemVuKGl0KXtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzRnJvemVuID8gJGlzRnJvemVuKGl0KSA6IGZhbHNlIDogdHJ1ZTtcbiAgfTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjEzIE9iamVjdC5pc1NlYWxlZChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNTZWFsZWQnLCBmdW5jdGlvbigkaXNTZWFsZWQpe1xuICByZXR1cm4gZnVuY3Rpb24gaXNTZWFsZWQoaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNTZWFsZWQgPyAkaXNTZWFsZWQoaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQuanNcbi8vIG1vZHVsZSBpZCA9IDE0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuMTEgT2JqZWN0LmlzRXh0ZW5zaWJsZShPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNFeHRlbnNpYmxlJywgZnVuY3Rpb24oJGlzRXh0ZW5zaWJsZSl7XG4gIHJldHVybiBmdW5jdGlvbiBpc0V4dGVuc2libGUoaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZShpdCkgOiB0cnVlIDogZmFsc2U7XG4gIH07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUuanNcbi8vIG1vZHVsZSBpZCA9IDE0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7YXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJyl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gMTQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsICRhc3NpZ24gID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgdmFyIEEgPSB7fVxuICAgICwgQiA9IHt9XG4gICAgLCBTID0gU3ltYm9sKClcbiAgICAsIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbihrKXsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCAgICAgPSB0b09iamVjdCh0YXJnZXQpXG4gICAgLCBhTGVuICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGluZGV4ID0gMVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZlxuICAgICwgaXNFbnVtICAgICA9IHBJRS5mO1xuICB3aGlsZShhTGVuID4gaW5kZXgpe1xuICAgIHZhciBTICAgICAgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSlcbiAgICAgICwga2V5cyAgID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBqICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShsZW5ndGggPiBqKWlmKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1hc3NpZ24uanNcbi8vIG1vZHVsZSBpZCA9IDE0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjMuMTAgT2JqZWN0LmlzKHZhbHVlMSwgdmFsdWUyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge2lzOiByZXF1aXJlKCcuL19zYW1lLXZhbHVlJyl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4yLjkgU2FtZVZhbHVlKHgsIHkpXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5pcyB8fCBmdW5jdGlvbiBpcyh4LCB5KXtcbiAgcmV0dXJuIHggPT09IHkgPyB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSA6IHggIT0geCAmJiB5ICE9IHk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19zYW1lLXZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0fSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGNoZWNrID0gZnVuY3Rpb24oTywgcHJvdG8pe1xuICBhbk9iamVjdChPKTtcbiAgaWYoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCl0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbih0ZXN0LCBidWdneSwgc2V0KXtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldCA9IHJlcXVpcmUoJy4vX2N0eCcpKEZ1bmN0aW9uLmNhbGwsIHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgICAgc2V0KHRlc3QsIFtdKTtcbiAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgICB9IGNhdGNoKGUpeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90byl7XG4gICAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgICAgaWYoYnVnZ3kpTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19zZXQtcHJvdG8uanNcbi8vIG1vZHVsZSBpZCA9IDE0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgdGVzdCAgICA9IHt9O1xudGVzdFtyZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKV0gPSAneic7XG5pZih0ZXN0ICsgJycgIT0gJ1tvYmplY3Qgel0nKXtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbiAgfSwgdHJ1ZSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDE0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJylcbiAgLy8gRVMzIHdyb25nIGhlcmVcbiAgLCBBUkcgPSBjb2YoZnVuY3Rpb24oKXsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19jbGFzc29mLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMi4zLjIgLyAxNS4zLjQuNSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCh0aGlzQXJnLCBhcmdzLi4uKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdGdW5jdGlvbicsIHtiaW5kOiByZXF1aXJlKCcuL19iaW5kJyl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZC5qc1xuLy8gbW9kdWxlIGlkID0gMTUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBhRnVuY3Rpb24gID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgaXNPYmplY3QgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaW52b2tlICAgICA9IHJlcXVpcmUoJy4vX2ludm9rZScpXG4gICwgYXJyYXlTbGljZSA9IFtdLnNsaWNlXG4gICwgZmFjdG9yaWVzICA9IHt9O1xuXG52YXIgY29uc3RydWN0ID0gZnVuY3Rpb24oRiwgbGVuLCBhcmdzKXtcbiAgaWYoIShsZW4gaW4gZmFjdG9yaWVzKSl7XG4gICAgZm9yKHZhciBuID0gW10sIGkgPSAwOyBpIDwgbGVuOyBpKyspbltpXSA9ICdhWycgKyBpICsgJ10nO1xuICAgIGZhY3Rvcmllc1tsZW5dID0gRnVuY3Rpb24oJ0YsYScsICdyZXR1cm4gbmV3IEYoJyArIG4uam9pbignLCcpICsgJyknKTtcbiAgfSByZXR1cm4gZmFjdG9yaWVzW2xlbl0oRiwgYXJncyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLmJpbmQgfHwgZnVuY3Rpb24gYmluZCh0aGF0IC8qLCBhcmdzLi4uICovKXtcbiAgdmFyIGZuICAgICAgID0gYUZ1bmN0aW9uKHRoaXMpXG4gICAgLCBwYXJ0QXJncyA9IGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgYm91bmQgPSBmdW5jdGlvbigvKiBhcmdzLi4uICovKXtcbiAgICB2YXIgYXJncyA9IHBhcnRBcmdzLmNvbmNhdChhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBib3VuZCA/IGNvbnN0cnVjdChmbiwgYXJncy5sZW5ndGgsIGFyZ3MpIDogaW52b2tlKGZuLCBhcmdzLCB0aGF0KTtcbiAgfTtcbiAgaWYoaXNPYmplY3QoZm4ucHJvdG90eXBlKSlib3VuZC5wcm90b3R5cGUgPSBmbi5wcm90b3R5cGU7XG4gIHJldHVybiBib3VuZDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2JpbmQuanNcbi8vIG1vZHVsZSBpZCA9IDE1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIGFyZ3MsIHRoYXQpe1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG4gIHN3aXRjaChhcmdzLmxlbmd0aCl7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2ludm9rZS5qc1xuLy8gbW9kdWxlIGlkID0gMTUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkUCAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBoYXMgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBGUHJvdG8gICAgID0gRnVuY3Rpb24ucHJvdG90eXBlXG4gICwgbmFtZVJFICAgICA9IC9eXFxzKmZ1bmN0aW9uIChbXiAoXSopL1xuICAsIE5BTUUgICAgICAgPSAnbmFtZSc7XG5cbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gMTkuMi40LjIgbmFtZVxuTkFNRSBpbiBGUHJvdG8gfHwgcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiBkUChGUHJvdG8sIE5BTUUsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgdHJ5IHtcbiAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgICAsIG5hbWUgPSAoJycgKyB0aGF0KS5tYXRjaChuYW1lUkUpWzFdO1xuICAgICAgaGFzKHRoYXQsIE5BTUUpIHx8ICFpc0V4dGVuc2libGUodGhhdCkgfHwgZFAodGhhdCwgTkFNRSwgY3JlYXRlRGVzYyg1LCBuYW1lKSk7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUuanNcbi8vIG1vZHVsZSBpZCA9IDE1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgSEFTX0lOU1RBTkNFICAgPSByZXF1aXJlKCcuL193a3MnKSgnaGFzSW5zdGFuY2UnKVxuICAsIEZ1bmN0aW9uUHJvdG8gID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gMTkuMi4zLjYgRnVuY3Rpb24ucHJvdG90eXBlW0BAaGFzSW5zdGFuY2VdKFYpXG5pZighKEhBU19JTlNUQU5DRSBpbiBGdW5jdGlvblByb3RvKSlyZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKEZ1bmN0aW9uUHJvdG8sIEhBU19JTlNUQU5DRSwge3ZhbHVlOiBmdW5jdGlvbihPKXtcbiAgaWYodHlwZW9mIHRoaXMgIT0gJ2Z1bmN0aW9uJyB8fCAhaXNPYmplY3QoTykpcmV0dXJuIGZhbHNlO1xuICBpZighaXNPYmplY3QodGhpcy5wcm90b3R5cGUpKXJldHVybiBPIGluc3RhbmNlb2YgdGhpcztcbiAgLy8gZm9yIGVudmlyb25tZW50IHcvbyBuYXRpdmUgYEBAaGFzSW5zdGFuY2VgIGxvZ2ljIGVub3VnaCBgaW5zdGFuY2VvZmAsIGJ1dCBhZGQgdGhpczpcbiAgd2hpbGUoTyA9IGdldFByb3RvdHlwZU9mKE8pKWlmKHRoaXMucHJvdG90eXBlID09PSBPKXJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59fSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX3BhcnNlLWludCcpO1xuLy8gMTguMi41IHBhcnNlSW50KHN0cmluZywgcmFkaXgpXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuRiAqIChwYXJzZUludCAhPSAkcGFyc2VJbnQpLCB7cGFyc2VJbnQ6ICRwYXJzZUludH0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucGFyc2VJbnRcbiAgLCAkdHJpbSAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW1cbiAgLCB3cyAgICAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctd3MnKVxuICAsIGhleCAgICAgICA9IC9eW1xcLStdPzBbeFhdLztcblxubW9kdWxlLmV4cG9ydHMgPSAkcGFyc2VJbnQod3MgKyAnMDgnKSAhPT0gOCB8fCAkcGFyc2VJbnQod3MgKyAnMHgxNicpICE9PSAyMiA/IGZ1bmN0aW9uIHBhcnNlSW50KHN0ciwgcmFkaXgpe1xuICB2YXIgc3RyaW5nID0gJHRyaW0oU3RyaW5nKHN0ciksIDMpO1xuICByZXR1cm4gJHBhcnNlSW50KHN0cmluZywgKHJhZGl4ID4+PiAwKSB8fCAoaGV4LnRlc3Qoc3RyaW5nKSA/IDE2IDogMTApKTtcbn0gOiAkcGFyc2VJbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWludC5qc1xuLy8gbW9kdWxlIGlkID0gMTU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBzcGFjZXMgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXdzJylcbiAgLCBzcGFjZSAgID0gJ1snICsgc3BhY2VzICsgJ10nXG4gICwgbm9uICAgICA9ICdcXHUyMDBiXFx1MDA4NSdcbiAgLCBsdHJpbSAgID0gUmVnRXhwKCdeJyArIHNwYWNlICsgc3BhY2UgKyAnKicpXG4gICwgcnRyaW0gICA9IFJlZ0V4cChzcGFjZSArIHNwYWNlICsgJyokJyk7XG5cbnZhciBleHBvcnRlciA9IGZ1bmN0aW9uKEtFWSwgZXhlYywgQUxJQVMpe1xuICB2YXIgZXhwICAgPSB7fTtcbiAgdmFyIEZPUkNFID0gZmFpbHMoZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gISFzcGFjZXNbS0VZXSgpIHx8IG5vbltLRVldKCkgIT0gbm9uO1xuICB9KTtcbiAgdmFyIGZuID0gZXhwW0tFWV0gPSBGT1JDRSA/IGV4ZWModHJpbSkgOiBzcGFjZXNbS0VZXTtcbiAgaWYoQUxJQVMpZXhwW0FMSUFTXSA9IGZuO1xuICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFLCAnU3RyaW5nJywgZXhwKTtcbn07XG5cbi8vIDEgLT4gU3RyaW5nI3RyaW1MZWZ0XG4vLyAyIC0+IFN0cmluZyN0cmltUmlnaHRcbi8vIDMgLT4gU3RyaW5nI3RyaW1cbnZhciB0cmltID0gZXhwb3J0ZXIudHJpbSA9IGZ1bmN0aW9uKHN0cmluZywgVFlQRSl7XG4gIHN0cmluZyA9IFN0cmluZyhkZWZpbmVkKHN0cmluZykpO1xuICBpZihUWVBFICYgMSlzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShsdHJpbSwgJycpO1xuICBpZihUWVBFICYgMilzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShydHJpbSwgJycpO1xuICByZXR1cm4gc3RyaW5nO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXRyaW0uanNcbi8vIG1vZHVsZSBpZCA9IDE1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9ICdcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwMycgK1xuICAnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy13cy5qc1xuLy8gbW9kdWxlIGlkID0gMTU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19wYXJzZS1mbG9hdCcpO1xuLy8gMTguMi40IHBhcnNlRmxvYXQoc3RyaW5nKVxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkYgKiAocGFyc2VGbG9hdCAhPSAkcGFyc2VGbG9hdCksIHtwYXJzZUZsb2F0OiAkcGFyc2VGbG9hdH0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdC5qc1xuLy8gbW9kdWxlIGlkID0gMTYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnBhcnNlRmxvYXRcbiAgLCAkdHJpbSAgICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbTtcblxubW9kdWxlLmV4cG9ydHMgPSAxIC8gJHBhcnNlRmxvYXQocmVxdWlyZSgnLi9fc3RyaW5nLXdzJykgKyAnLTAnKSAhPT0gLUluZmluaXR5ID8gZnVuY3Rpb24gcGFyc2VGbG9hdChzdHIpe1xuICB2YXIgc3RyaW5nID0gJHRyaW0oU3RyaW5nKHN0ciksIDMpXG4gICAgLCByZXN1bHQgPSAkcGFyc2VGbG9hdChzdHJpbmcpO1xuICByZXR1cm4gcmVzdWx0ID09PSAwICYmIHN0cmluZy5jaGFyQXQoMCkgPT0gJy0nID8gLTAgOiByZXN1bHQ7XG59IDogJHBhcnNlRmxvYXQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWZsb2F0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoYXMgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgY29mICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jb2YnKVxuICAsIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpXG4gICwgdG9QcmltaXRpdmUgICAgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGZhaWxzICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGdPUE4gICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgZ09QRCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmZcbiAgLCBkUCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCAkdHJpbSAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbVxuICAsIE5VTUJFUiAgICAgICAgICAgID0gJ051bWJlcidcbiAgLCAkTnVtYmVyICAgICAgICAgICA9IGdsb2JhbFtOVU1CRVJdXG4gICwgQmFzZSAgICAgICAgICAgICAgPSAkTnVtYmVyXG4gICwgcHJvdG8gICAgICAgICAgICAgPSAkTnVtYmVyLnByb3RvdHlwZVxuICAvLyBPcGVyYSB+MTIgaGFzIGJyb2tlbiBPYmplY3QjdG9TdHJpbmdcbiAgLCBCUk9LRU5fQ09GICAgICAgICA9IGNvZihyZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJykocHJvdG8pKSA9PSBOVU1CRVJcbiAgLCBUUklNICAgICAgICAgICAgICA9ICd0cmltJyBpbiBTdHJpbmcucHJvdG90eXBlO1xuXG4vLyA3LjEuMyBUb051bWJlcihhcmd1bWVudClcbnZhciB0b051bWJlciA9IGZ1bmN0aW9uKGFyZ3VtZW50KXtcbiAgdmFyIGl0ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsIGZhbHNlKTtcbiAgaWYodHlwZW9mIGl0ID09ICdzdHJpbmcnICYmIGl0Lmxlbmd0aCA+IDIpe1xuICAgIGl0ID0gVFJJTSA/IGl0LnRyaW0oKSA6ICR0cmltKGl0LCAzKTtcbiAgICB2YXIgZmlyc3QgPSBpdC5jaGFyQ29kZUF0KDApXG4gICAgICAsIHRoaXJkLCByYWRpeCwgbWF4Q29kZTtcbiAgICBpZihmaXJzdCA9PT0gNDMgfHwgZmlyc3QgPT09IDQ1KXtcbiAgICAgIHRoaXJkID0gaXQuY2hhckNvZGVBdCgyKTtcbiAgICAgIGlmKHRoaXJkID09PSA4OCB8fCB0aGlyZCA9PT0gMTIwKXJldHVybiBOYU47IC8vIE51bWJlcignKzB4MScpIHNob3VsZCBiZSBOYU4sIG9sZCBWOCBmaXhcbiAgICB9IGVsc2UgaWYoZmlyc3QgPT09IDQ4KXtcbiAgICAgIHN3aXRjaChpdC5jaGFyQ29kZUF0KDEpKXtcbiAgICAgICAgY2FzZSA2NiA6IGNhc2UgOTggIDogcmFkaXggPSAyOyBtYXhDb2RlID0gNDk7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIC9eMGJbMDFdKyQvaVxuICAgICAgICBjYXNlIDc5IDogY2FzZSAxMTEgOiByYWRpeCA9IDg7IG1heENvZGUgPSA1NTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wb1swLTddKyQvaVxuICAgICAgICBkZWZhdWx0IDogcmV0dXJuICtpdDtcbiAgICAgIH1cbiAgICAgIGZvcih2YXIgZGlnaXRzID0gaXQuc2xpY2UoMiksIGkgPSAwLCBsID0gZGlnaXRzLmxlbmd0aCwgY29kZTsgaSA8IGw7IGkrKyl7XG4gICAgICAgIGNvZGUgPSBkaWdpdHMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgLy8gcGFyc2VJbnQgcGFyc2VzIGEgc3RyaW5nIHRvIGEgZmlyc3QgdW5hdmFpbGFibGUgc3ltYm9sXG4gICAgICAgIC8vIGJ1dCBUb051bWJlciBzaG91bGQgcmV0dXJuIE5hTiBpZiBhIHN0cmluZyBjb250YWlucyB1bmF2YWlsYWJsZSBzeW1ib2xzXG4gICAgICAgIGlmKGNvZGUgPCA0OCB8fCBjb2RlID4gbWF4Q29kZSlyZXR1cm4gTmFOO1xuICAgICAgfSByZXR1cm4gcGFyc2VJbnQoZGlnaXRzLCByYWRpeCk7XG4gICAgfVxuICB9IHJldHVybiAraXQ7XG59O1xuXG5pZighJE51bWJlcignIDBvMScpIHx8ICEkTnVtYmVyKCcwYjEnKSB8fCAkTnVtYmVyKCcrMHgxJykpe1xuICAkTnVtYmVyID0gZnVuY3Rpb24gTnVtYmVyKHZhbHVlKXtcbiAgICB2YXIgaXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMSA/IDAgOiB2YWx1ZVxuICAgICAgLCB0aGF0ID0gdGhpcztcbiAgICByZXR1cm4gdGhhdCBpbnN0YW5jZW9mICROdW1iZXJcbiAgICAgIC8vIGNoZWNrIG9uIDEuLmNvbnN0cnVjdG9yKGZvbykgY2FzZVxuICAgICAgJiYgKEJST0tFTl9DT0YgPyBmYWlscyhmdW5jdGlvbigpeyBwcm90by52YWx1ZU9mLmNhbGwodGhhdCk7IH0pIDogY29mKHRoYXQpICE9IE5VTUJFUilcbiAgICAgICAgPyBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSh0b051bWJlcihpdCkpLCB0aGF0LCAkTnVtYmVyKSA6IHRvTnVtYmVyKGl0KTtcbiAgfTtcbiAgZm9yKHZhciBrZXlzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUE4oQmFzZSkgOiAoXG4gICAgLy8gRVMzOlxuICAgICdNQVhfVkFMVUUsTUlOX1ZBTFVFLE5hTixORUdBVElWRV9JTkZJTklUWSxQT1NJVElWRV9JTkZJTklUWSwnICtcbiAgICAvLyBFUzYgKGluIGNhc2UsIGlmIG1vZHVsZXMgd2l0aCBFUzYgTnVtYmVyIHN0YXRpY3MgcmVxdWlyZWQgYmVmb3JlKTpcbiAgICAnRVBTSUxPTixpc0Zpbml0ZSxpc0ludGVnZXIsaXNOYU4saXNTYWZlSW50ZWdlcixNQVhfU0FGRV9JTlRFR0VSLCcgK1xuICAgICdNSU5fU0FGRV9JTlRFR0VSLHBhcnNlRmxvYXQscGFyc2VJbnQsaXNJbnRlZ2VyJ1xuICApLnNwbGl0KCcsJyksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajsgaisrKXtcbiAgICBpZihoYXMoQmFzZSwga2V5ID0ga2V5c1tqXSkgJiYgIWhhcygkTnVtYmVyLCBrZXkpKXtcbiAgICAgIGRQKCROdW1iZXIsIGtleSwgZ09QRChCYXNlLCBrZXkpKTtcbiAgICB9XG4gIH1cbiAgJE51bWJlci5wcm90b3R5cGUgPSBwcm90bztcbiAgcHJvdG8uY29uc3RydWN0b3IgPSAkTnVtYmVyO1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKGdsb2JhbCwgTlVNQkVSLCAkTnVtYmVyKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmNvbnN0cnVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGhhdCwgdGFyZ2V0LCBDKXtcbiAgdmFyIFAsIFMgPSB0YXJnZXQuY29uc3RydWN0b3I7XG4gIGlmKFMgIT09IEMgJiYgdHlwZW9mIFMgPT0gJ2Z1bmN0aW9uJyAmJiAoUCA9IFMucHJvdG90eXBlKSAhPT0gQy5wcm90b3R5cGUgJiYgaXNPYmplY3QoUCkgJiYgc2V0UHJvdG90eXBlT2Ype1xuICAgIHNldFByb3RvdHlwZU9mKHRoYXQsIFApO1xuICB9IHJldHVybiB0aGF0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9faW5oZXJpdC1pZi1yZXF1aXJlZC5qc1xuLy8gbW9kdWxlIGlkID0gMTYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvSW50ZWdlciAgICA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIGFOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4vX2EtbnVtYmVyLXZhbHVlJylcbiAgLCByZXBlYXQgICAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0JylcbiAgLCAkdG9GaXhlZCAgICAgPSAxLi50b0ZpeGVkXG4gICwgZmxvb3IgICAgICAgID0gTWF0aC5mbG9vclxuICAsIGRhdGEgICAgICAgICA9IFswLCAwLCAwLCAwLCAwLCAwXVxuICAsIEVSUk9SICAgICAgICA9ICdOdW1iZXIudG9GaXhlZDogaW5jb3JyZWN0IGludm9jYXRpb24hJ1xuICAsIFpFUk8gICAgICAgICA9ICcwJztcblxudmFyIG11bHRpcGx5ID0gZnVuY3Rpb24obiwgYyl7XG4gIHZhciBpICA9IC0xXG4gICAgLCBjMiA9IGM7XG4gIHdoaWxlKCsraSA8IDYpe1xuICAgIGMyICs9IG4gKiBkYXRhW2ldO1xuICAgIGRhdGFbaV0gPSBjMiAlIDFlNztcbiAgICBjMiA9IGZsb29yKGMyIC8gMWU3KTtcbiAgfVxufTtcbnZhciBkaXZpZGUgPSBmdW5jdGlvbihuKXtcbiAgdmFyIGkgPSA2XG4gICAgLCBjID0gMDtcbiAgd2hpbGUoLS1pID49IDApe1xuICAgIGMgKz0gZGF0YVtpXTtcbiAgICBkYXRhW2ldID0gZmxvb3IoYyAvIG4pO1xuICAgIGMgPSAoYyAlIG4pICogMWU3O1xuICB9XG59O1xudmFyIG51bVRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgdmFyIGkgPSA2XG4gICAgLCBzID0gJyc7XG4gIHdoaWxlKC0taSA+PSAwKXtcbiAgICBpZihzICE9PSAnJyB8fCBpID09PSAwIHx8IGRhdGFbaV0gIT09IDApe1xuICAgICAgdmFyIHQgPSBTdHJpbmcoZGF0YVtpXSk7XG4gICAgICBzID0gcyA9PT0gJycgPyB0IDogcyArIHJlcGVhdC5jYWxsKFpFUk8sIDcgLSB0Lmxlbmd0aCkgKyB0O1xuICAgIH1cbiAgfSByZXR1cm4gcztcbn07XG52YXIgcG93ID0gZnVuY3Rpb24oeCwgbiwgYWNjKXtcbiAgcmV0dXJuIG4gPT09IDAgPyBhY2MgOiBuICUgMiA9PT0gMSA/IHBvdyh4LCBuIC0gMSwgYWNjICogeCkgOiBwb3coeCAqIHgsIG4gLyAyLCBhY2MpO1xufTtcbnZhciBsb2cgPSBmdW5jdGlvbih4KXtcbiAgdmFyIG4gID0gMFxuICAgICwgeDIgPSB4O1xuICB3aGlsZSh4MiA+PSA0MDk2KXtcbiAgICBuICs9IDEyO1xuICAgIHgyIC89IDQwOTY7XG4gIH1cbiAgd2hpbGUoeDIgPj0gMil7XG4gICAgbiAgKz0gMTtcbiAgICB4MiAvPSAyO1xuICB9IHJldHVybiBuO1xufTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoISEkdG9GaXhlZCAmJiAoXG4gIDAuMDAwMDgudG9GaXhlZCgzKSAhPT0gJzAuMDAwJyB8fFxuICAwLjkudG9GaXhlZCgwKSAhPT0gJzEnIHx8XG4gIDEuMjU1LnRvRml4ZWQoMikgIT09ICcxLjI1JyB8fFxuICAxMDAwMDAwMDAwMDAwMDAwMTI4Li50b0ZpeGVkKDApICE9PSAnMTAwMDAwMDAwMDAwMDAwMDEyOCdcbikgfHwgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgJHRvRml4ZWQuY2FsbCh7fSk7XG59KSksICdOdW1iZXInLCB7XG4gIHRvRml4ZWQ6IGZ1bmN0aW9uIHRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpe1xuICAgIHZhciB4ID0gYU51bWJlclZhbHVlKHRoaXMsIEVSUk9SKVxuICAgICAgLCBmID0gdG9JbnRlZ2VyKGZyYWN0aW9uRGlnaXRzKVxuICAgICAgLCBzID0gJydcbiAgICAgICwgbSA9IFpFUk9cbiAgICAgICwgZSwgeiwgaiwgaztcbiAgICBpZihmIDwgMCB8fCBmID4gMjApdGhyb3cgUmFuZ2VFcnJvcihFUlJPUik7XG4gICAgaWYoeCAhPSB4KXJldHVybiAnTmFOJztcbiAgICBpZih4IDw9IC0xZTIxIHx8IHggPj0gMWUyMSlyZXR1cm4gU3RyaW5nKHgpO1xuICAgIGlmKHggPCAwKXtcbiAgICAgIHMgPSAnLSc7XG4gICAgICB4ID0gLXg7XG4gICAgfVxuICAgIGlmKHggPiAxZS0yMSl7XG4gICAgICBlID0gbG9nKHggKiBwb3coMiwgNjksIDEpKSAtIDY5O1xuICAgICAgeiA9IGUgPCAwID8geCAqIHBvdygyLCAtZSwgMSkgOiB4IC8gcG93KDIsIGUsIDEpO1xuICAgICAgeiAqPSAweDEwMDAwMDAwMDAwMDAwO1xuICAgICAgZSA9IDUyIC0gZTtcbiAgICAgIGlmKGUgPiAwKXtcbiAgICAgICAgbXVsdGlwbHkoMCwgeik7XG4gICAgICAgIGogPSBmO1xuICAgICAgICB3aGlsZShqID49IDcpe1xuICAgICAgICAgIG11bHRpcGx5KDFlNywgMCk7XG4gICAgICAgICAgaiAtPSA3O1xuICAgICAgICB9XG4gICAgICAgIG11bHRpcGx5KHBvdygxMCwgaiwgMSksIDApO1xuICAgICAgICBqID0gZSAtIDE7XG4gICAgICAgIHdoaWxlKGogPj0gMjMpe1xuICAgICAgICAgIGRpdmlkZSgxIDw8IDIzKTtcbiAgICAgICAgICBqIC09IDIzO1xuICAgICAgICB9XG4gICAgICAgIGRpdmlkZSgxIDw8IGopO1xuICAgICAgICBtdWx0aXBseSgxLCAxKTtcbiAgICAgICAgZGl2aWRlKDIpO1xuICAgICAgICBtID0gbnVtVG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG11bHRpcGx5KDAsIHopO1xuICAgICAgICBtdWx0aXBseSgxIDw8IC1lLCAwKTtcbiAgICAgICAgbSA9IG51bVRvU3RyaW5nKCkgKyByZXBlYXQuY2FsbChaRVJPLCBmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoZiA+IDApe1xuICAgICAgayA9IG0ubGVuZ3RoO1xuICAgICAgbSA9IHMgKyAoayA8PSBmID8gJzAuJyArIHJlcGVhdC5jYWxsKFpFUk8sIGYgLSBrKSArIG0gOiBtLnNsaWNlKDAsIGsgLSBmKSArICcuJyArIG0uc2xpY2UoayAtIGYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHMgKyBtO1xuICAgIH0gcmV0dXJuIG07XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIudG8tZml4ZWQuanNcbi8vIG1vZHVsZSBpZCA9IDE2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBtc2cpe1xuICBpZih0eXBlb2YgaXQgIT0gJ251bWJlcicgJiYgY29mKGl0KSAhPSAnTnVtYmVyJyl0aHJvdyBUeXBlRXJyb3IobXNnKTtcbiAgcmV0dXJuICtpdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2EtbnVtYmVyLXZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIGRlZmluZWQgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXBlYXQoY291bnQpe1xuICB2YXIgc3RyID0gU3RyaW5nKGRlZmluZWQodGhpcykpXG4gICAgLCByZXMgPSAnJ1xuICAgICwgbiAgID0gdG9JbnRlZ2VyKGNvdW50KTtcbiAgaWYobiA8IDAgfHwgbiA9PSBJbmZpbml0eSl0aHJvdyBSYW5nZUVycm9yKFwiQ291bnQgY2FuJ3QgYmUgbmVnYXRpdmVcIik7XG4gIGZvcig7biA+IDA7IChuID4+Pj0gMSkgJiYgKHN0ciArPSBzdHIpKWlmKG4gJiAxKXJlcyArPSBzdHI7XG4gIHJldHVybiByZXM7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctcmVwZWF0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZhaWxzICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGFOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4vX2EtbnVtYmVyLXZhbHVlJylcbiAgLCAkdG9QcmVjaXNpb24gPSAxLi50b1ByZWNpc2lvbjtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIC8vIElFNy1cbiAgcmV0dXJuICR0b1ByZWNpc2lvbi5jYWxsKDEsIHVuZGVmaW5lZCkgIT09ICcxJztcbn0pIHx8ICEkZmFpbHMoZnVuY3Rpb24oKXtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgJHRvUHJlY2lzaW9uLmNhbGwoe30pO1xufSkpLCAnTnVtYmVyJywge1xuICB0b1ByZWNpc2lvbjogZnVuY3Rpb24gdG9QcmVjaXNpb24ocHJlY2lzaW9uKXtcbiAgICB2YXIgdGhhdCA9IGFOdW1iZXJWYWx1ZSh0aGlzLCAnTnVtYmVyI3RvUHJlY2lzaW9uOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgICByZXR1cm4gcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyAkdG9QcmVjaXNpb24uY2FsbCh0aGF0KSA6ICR0b1ByZWNpc2lvbi5jYWxsKHRoYXQsIHByZWNpc2lvbik7IFxuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLXByZWNpc2lvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjEuMi4xIE51bWJlci5FUFNJTE9OXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtFUFNJTE9OOiBNYXRoLnBvdygyLCAtNTIpfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMS4yLjIgTnVtYmVyLmlzRmluaXRlKG51bWJlcilcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIF9pc0Zpbml0ZSA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmlzRmluaXRlO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNGaW5pdGU6IGZ1bmN0aW9uIGlzRmluaXRlKGl0KXtcbiAgICByZXR1cm4gdHlwZW9mIGl0ID09ICdudW1iZXInICYmIF9pc0Zpbml0ZShpdCk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtZmluaXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtpc0ludGVnZXI6IHJlcXVpcmUoJy4vX2lzLWludGVnZXInKX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjEuMi4zIE51bWJlci5pc0ludGVnZXIobnVtYmVyKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBmbG9vciAgICA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzSW50ZWdlcihpdCl7XG4gIHJldHVybiAhaXNPYmplY3QoaXQpICYmIGlzRmluaXRlKGl0KSAmJiBmbG9vcihpdCkgPT09IGl0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtaW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjEuMi40IE51bWJlci5pc05hTihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNOYU46IGZ1bmN0aW9uIGlzTmFOKG51bWJlcil7XG4gICAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMS4yLjUgTnVtYmVyLmlzU2FmZUludGVnZXIobnVtYmVyKVxudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgaXNJbnRlZ2VyID0gcmVxdWlyZSgnLi9faXMtaW50ZWdlcicpXG4gICwgYWJzICAgICAgID0gTWF0aC5hYnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc1NhZmVJbnRlZ2VyOiBmdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKG51bWJlcil7XG4gICAgcmV0dXJuIGlzSW50ZWdlcihudW1iZXIpICYmIGFicyhudW1iZXIpIDw9IDB4MWZmZmZmZmZmZmZmZmY7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtc2FmZS1pbnRlZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMS4yLjYgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge01BWF9TQUZFX0lOVEVHRVI6IDB4MWZmZmZmZmZmZmZmZmZ9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4xLjIuMTAgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge01JTl9TQUZFX0lOVEVHRVI6IC0weDFmZmZmZmZmZmZmZmZmfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX3BhcnNlLWZsb2F0Jyk7XG4vLyAyMC4xLjIuMTIgTnVtYmVyLnBhcnNlRmxvYXQoc3RyaW5nKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTnVtYmVyLnBhcnNlRmxvYXQgIT0gJHBhcnNlRmxvYXQpLCAnTnVtYmVyJywge3BhcnNlRmxvYXQ6ICRwYXJzZUZsb2F0fSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1mbG9hdC5qc1xuLy8gbW9kdWxlIGlkID0gMTc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX3BhcnNlLWludCcpO1xuLy8gMjAuMS4yLjEzIE51bWJlci5wYXJzZUludChzdHJpbmcsIHJhZGl4KVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTnVtYmVyLnBhcnNlSW50ICE9ICRwYXJzZUludCksICdOdW1iZXInLCB7cGFyc2VJbnQ6ICRwYXJzZUludH0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMi4yLjMgTWF0aC5hY29zaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGxvZzFwICAgPSByZXF1aXJlKCcuL19tYXRoLWxvZzFwJylcbiAgLCBzcXJ0ICAgID0gTWF0aC5zcXJ0XG4gICwgJGFjb3NoICA9IE1hdGguYWNvc2g7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYWNvc2hcbiAgLy8gVjggYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzUwOVxuICAmJiBNYXRoLmZsb29yKCRhY29zaChOdW1iZXIuTUFYX1ZBTFVFKSkgPT0gNzEwXG4gIC8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hY29zaChJbmZpbml0eSkgLT4gTmFOIFxuICAmJiAkYWNvc2goSW5maW5pdHkpID09IEluZmluaXR5XG4pLCAnTWF0aCcsIHtcbiAgYWNvc2g6IGZ1bmN0aW9uIGFjb3NoKHgpe1xuICAgIHJldHVybiAoeCA9ICt4KSA8IDEgPyBOYU4gOiB4ID4gOTQ5MDYyNjUuNjI0MjUxNTZcbiAgICAgID8gTWF0aC5sb2coeCkgKyBNYXRoLkxOMlxuICAgICAgOiBsb2cxcCh4IC0gMSArIHNxcnQoeCAtIDEpICogc3FydCh4ICsgMSkpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hY29zaC5qc1xuLy8gbW9kdWxlIGlkID0gMTc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGgubG9nMXAgfHwgZnVuY3Rpb24gbG9nMXAoeCl7XG4gIHJldHVybiAoeCA9ICt4KSA+IC0xZS04ICYmIHggPCAxZS04ID8geCAtIHggKiB4IC8gMiA6IE1hdGgubG9nKDEgKyB4KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX21hdGgtbG9nMXAuanNcbi8vIG1vZHVsZSBpZCA9IDE3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuNSBNYXRoLmFzaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGFzaW5oICA9IE1hdGguYXNpbmg7XG5cbmZ1bmN0aW9uIGFzaW5oKHgpe1xuICByZXR1cm4gIWlzRmluaXRlKHggPSAreCkgfHwgeCA9PSAwID8geCA6IHggPCAwID8gLWFzaW5oKC14KSA6IE1hdGgubG9nKHggKyBNYXRoLnNxcnQoeCAqIHggKyAxKSk7XG59XG5cbi8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hc2luaCgwKSAtPiAtMCBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXNpbmggJiYgMSAvICRhc2luaCgwKSA+IDApLCAnTWF0aCcsIHthc2luaDogYXNpbmh9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hc2luaC5qc1xuLy8gbW9kdWxlIGlkID0gMTgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi43IE1hdGguYXRhbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkYXRhbmggID0gTWF0aC5hdGFuaDtcblxuLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmF0YW5oKC0wKSAtPiAwIFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhdGFuaCAmJiAxIC8gJGF0YW5oKC0wKSA8IDApLCAnTWF0aCcsIHtcbiAgYXRhbmg6IGZ1bmN0aW9uIGF0YW5oKHgpe1xuICAgIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IE1hdGgubG9nKCgxICsgeCkgLyAoMSAtIHgpKSAvIDI7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmF0YW5oLmpzXG4vLyBtb2R1bGUgaWQgPSAxODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMi4yLjkgTWF0aC5jYnJ0KHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgc2lnbiAgICA9IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNicnQ6IGZ1bmN0aW9uIGNicnQoeCl7XG4gICAgcmV0dXJuIHNpZ24oeCA9ICt4KSAqIE1hdGgucG93KE1hdGguYWJzKHgpLCAxIC8gMyk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNicnQuanNcbi8vIG1vZHVsZSBpZCA9IDE4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbiBzaWduKHgpe1xuICByZXR1cm4gKHggPSAreCkgPT0gMCB8fCB4ICE9IHggPyB4IDogeCA8IDAgPyAtMSA6IDE7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19tYXRoLXNpZ24uanNcbi8vIG1vZHVsZSBpZCA9IDE4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuMTEgTWF0aC5jbHozMih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjbHozMjogZnVuY3Rpb24gY2x6MzIoeCl7XG4gICAgcmV0dXJuICh4ID4+Pj0gMCkgPyAzMSAtIE1hdGguZmxvb3IoTWF0aC5sb2coeCArIDAuNSkgKiBNYXRoLkxPRzJFKSA6IDMyO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jbHozMi5qc1xuLy8gbW9kdWxlIGlkID0gMTg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi4xMiBNYXRoLmNvc2goeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBleHAgICAgID0gTWF0aC5leHA7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY29zaDogZnVuY3Rpb24gY29zaCh4KXtcbiAgICByZXR1cm4gKGV4cCh4ID0gK3gpICsgZXhwKC14KSkgLyAyO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jb3NoLmpzXG4vLyBtb2R1bGUgaWQgPSAxODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZXhwbTEgID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICgkZXhwbTEgIT0gTWF0aC5leHBtMSksICdNYXRoJywge2V4cG0xOiAkZXhwbTF9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5leHBtMS5qc1xuLy8gbW9kdWxlIGlkID0gMTg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXG52YXIgJGV4cG0xID0gTWF0aC5leHBtMTtcbm1vZHVsZS5leHBvcnRzID0gKCEkZXhwbTFcbiAgLy8gT2xkIEZGIGJ1Z1xuICB8fCAkZXhwbTEoMTApID4gMjIwMjUuNDY1Nzk0ODA2NzE5IHx8ICRleHBtMSgxMCkgPCAyMjAyNS40NjU3OTQ4MDY3MTY1MTY4XG4gIC8vIFRvciBCcm93c2VyIGJ1Z1xuICB8fCAkZXhwbTEoLTJlLTE3KSAhPSAtMmUtMTdcbikgPyBmdW5jdGlvbiBleHBtMSh4KXtcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogeCA+IC0xZS02ICYmIHggPCAxZS02ID8geCArIHggKiB4IC8gMiA6IE1hdGguZXhwKHgpIC0gMTtcbn0gOiAkZXhwbTE7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX21hdGgtZXhwbTEuanNcbi8vIG1vZHVsZSBpZCA9IDE4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuMTYgTWF0aC5mcm91bmQoeClcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHNpZ24gICAgICA9IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpXG4gICwgcG93ICAgICAgID0gTWF0aC5wb3dcbiAgLCBFUFNJTE9OICAgPSBwb3coMiwgLTUyKVxuICAsIEVQU0lMT04zMiA9IHBvdygyLCAtMjMpXG4gICwgTUFYMzIgICAgID0gcG93KDIsIDEyNykgKiAoMiAtIEVQU0lMT04zMilcbiAgLCBNSU4zMiAgICAgPSBwb3coMiwgLTEyNik7XG5cbnZhciByb3VuZFRpZXNUb0V2ZW4gPSBmdW5jdGlvbihuKXtcbiAgcmV0dXJuIG4gKyAxIC8gRVBTSUxPTiAtIDEgLyBFUFNJTE9OO1xufTtcblxuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGZyb3VuZDogZnVuY3Rpb24gZnJvdW5kKHgpe1xuICAgIHZhciAkYWJzICA9IE1hdGguYWJzKHgpXG4gICAgICAsICRzaWduID0gc2lnbih4KVxuICAgICAgLCBhLCByZXN1bHQ7XG4gICAgaWYoJGFicyA8IE1JTjMyKXJldHVybiAkc2lnbiAqIHJvdW5kVGllc1RvRXZlbigkYWJzIC8gTUlOMzIgLyBFUFNJTE9OMzIpICogTUlOMzIgKiBFUFNJTE9OMzI7XG4gICAgYSA9ICgxICsgRVBTSUxPTjMyIC8gRVBTSUxPTikgKiAkYWJzO1xuICAgIHJlc3VsdCA9IGEgLSAoYSAtICRhYnMpO1xuICAgIGlmKHJlc3VsdCA+IE1BWDMyIHx8IHJlc3VsdCAhPSByZXN1bHQpcmV0dXJuICRzaWduICogSW5maW5pdHk7XG4gICAgcmV0dXJuICRzaWduICogcmVzdWx0O1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5mcm91bmQuanNcbi8vIG1vZHVsZSBpZCA9IDE4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuMTcgTWF0aC5oeXBvdChbdmFsdWUxWywgdmFsdWUyWywg4oCmIF1dXSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhYnMgICAgID0gTWF0aC5hYnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaHlwb3Q6IGZ1bmN0aW9uIGh5cG90KHZhbHVlMSwgdmFsdWUyKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciBzdW0gID0gMFxuICAgICAgLCBpICAgID0gMFxuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBsYXJnID0gMFxuICAgICAgLCBhcmcsIGRpdjtcbiAgICB3aGlsZShpIDwgYUxlbil7XG4gICAgICBhcmcgPSBhYnMoYXJndW1lbnRzW2krK10pO1xuICAgICAgaWYobGFyZyA8IGFyZyl7XG4gICAgICAgIGRpdiAgPSBsYXJnIC8gYXJnO1xuICAgICAgICBzdW0gID0gc3VtICogZGl2ICogZGl2ICsgMTtcbiAgICAgICAgbGFyZyA9IGFyZztcbiAgICAgIH0gZWxzZSBpZihhcmcgPiAwKXtcbiAgICAgICAgZGl2ICA9IGFyZyAvIGxhcmc7XG4gICAgICAgIHN1bSArPSBkaXYgKiBkaXY7XG4gICAgICB9IGVsc2Ugc3VtICs9IGFyZztcbiAgICB9XG4gICAgcmV0dXJuIGxhcmcgPT09IEluZmluaXR5ID8gSW5maW5pdHkgOiBsYXJnICogTWF0aC5zcXJ0KHN1bSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmh5cG90LmpzXG4vLyBtb2R1bGUgaWQgPSAxODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMi4yLjE4IE1hdGguaW11bCh4LCB5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRpbXVsICAgPSBNYXRoLmltdWw7XG5cbi8vIHNvbWUgV2ViS2l0IHZlcnNpb25zIGZhaWxzIHdpdGggYmlnIG51bWJlcnMsIHNvbWUgaGFzIHdyb25nIGFyaXR5XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuICRpbXVsKDB4ZmZmZmZmZmYsIDUpICE9IC01IHx8ICRpbXVsLmxlbmd0aCAhPSAyO1xufSksICdNYXRoJywge1xuICBpbXVsOiBmdW5jdGlvbiBpbXVsKHgsIHkpe1xuICAgIHZhciBVSU5UMTYgPSAweGZmZmZcbiAgICAgICwgeG4gPSAreFxuICAgICAgLCB5biA9ICt5XG4gICAgICAsIHhsID0gVUlOVDE2ICYgeG5cbiAgICAgICwgeWwgPSBVSU5UMTYgJiB5bjtcbiAgICByZXR1cm4gMCB8IHhsICogeWwgKyAoKFVJTlQxNiAmIHhuID4+PiAxNikgKiB5bCArIHhsICogKFVJTlQxNiAmIHluID4+PiAxNikgPDwgMTYgPj4+IDApO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5pbXVsLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMi4yLjIxIE1hdGgubG9nMTAoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgbG9nMTA6IGZ1bmN0aW9uIGxvZzEwKHgpe1xuICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4xMDtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAuanNcbi8vIG1vZHVsZSBpZCA9IDE5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuMjAgTWF0aC5sb2cxcCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge2xvZzFwOiByZXF1aXJlKCcuL19tYXRoLWxvZzFwJyl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxcC5qc1xuLy8gbW9kdWxlIGlkID0gMTkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi4yMiBNYXRoLmxvZzIoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgbG9nMjogZnVuY3Rpb24gbG9nMih4KXtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMjtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMi5qc1xuLy8gbW9kdWxlIGlkID0gMTkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtzaWduOiByZXF1aXJlKCcuL19tYXRoLXNpZ24nKX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpZ24uanNcbi8vIG1vZHVsZSBpZCA9IDE5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuMzAgTWF0aC5zaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZXhwbTEgICA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKVxuICAsIGV4cCAgICAgPSBNYXRoLmV4cDtcblxuLy8gVjggbmVhciBDaHJvbWl1bSAzOCBoYXMgYSBwcm9ibGVtIHdpdGggdmVyeSBzbWFsbCBudW1iZXJzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuICFNYXRoLnNpbmgoLTJlLTE3KSAhPSAtMmUtMTc7XG59KSwgJ01hdGgnLCB7XG4gIHNpbmg6IGZ1bmN0aW9uIHNpbmgoeCl7XG4gICAgcmV0dXJuIE1hdGguYWJzKHggPSAreCkgPCAxXG4gICAgICA/IChleHBtMSh4KSAtIGV4cG0xKC14KSkgLyAyXG4gICAgICA6IChleHAoeCAtIDEpIC0gZXhwKC14IC0gMSkpICogKE1hdGguRSAvIDIpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaW5oLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMi4yLjMzIE1hdGgudGFuaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGV4cG0xICAgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJylcbiAgLCBleHAgICAgID0gTWF0aC5leHA7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdGFuaDogZnVuY3Rpb24gdGFuaCh4KXtcbiAgICB2YXIgYSA9IGV4cG0xKHggPSAreClcbiAgICAgICwgYiA9IGV4cG0xKC14KTtcbiAgICByZXR1cm4gYSA9PSBJbmZpbml0eSA/IDEgOiBiID09IEluZmluaXR5ID8gLTEgOiAoYSAtIGIpIC8gKGV4cCh4KSArIGV4cCgteCkpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50YW5oLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMi4yLjM0IE1hdGgudHJ1bmMoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdHJ1bmM6IGZ1bmN0aW9uIHRydW5jKGl0KXtcbiAgICByZXR1cm4gKGl0ID4gMCA/IE1hdGguZmxvb3IgOiBNYXRoLmNlaWwpKGl0KTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudHJ1bmMuanNcbi8vIG1vZHVsZSBpZCA9IDE5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvSW5kZXggICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIGZyb21DaGFyQ29kZSAgID0gU3RyaW5nLmZyb21DaGFyQ29kZVxuICAsICRmcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG5cbi8vIGxlbmd0aCBzaG91bGQgYmUgMSwgb2xkIEZGIHByb2JsZW1cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCEhJGZyb21Db2RlUG9pbnQgJiYgJGZyb21Db2RlUG9pbnQubGVuZ3RoICE9IDEpLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjIuMiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jb2RlUG9pbnRzKVxuICBmcm9tQ29kZVBvaW50OiBmdW5jdGlvbiBmcm9tQ29kZVBvaW50KHgpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHJlcyAgPSBbXVxuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBpICAgID0gMFxuICAgICAgLCBjb2RlO1xuICAgIHdoaWxlKGFMZW4gPiBpKXtcbiAgICAgIGNvZGUgPSArYXJndW1lbnRzW2krK107XG4gICAgICBpZih0b0luZGV4KGNvZGUsIDB4MTBmZmZmKSAhPT0gY29kZSl0aHJvdyBSYW5nZUVycm9yKGNvZGUgKyAnIGlzIG5vdCBhIHZhbGlkIGNvZGUgcG9pbnQnKTtcbiAgICAgIHJlcy5wdXNoKGNvZGUgPCAweDEwMDAwXG4gICAgICAgID8gZnJvbUNoYXJDb2RlKGNvZGUpXG4gICAgICAgIDogZnJvbUNoYXJDb2RlKCgoY29kZSAtPSAweDEwMDAwKSA+PiAxMCkgKyAweGQ4MDAsIGNvZGUgJSAweDQwMCArIDB4ZGMwMClcbiAgICAgICk7XG4gICAgfSByZXR1cm4gcmVzLmpvaW4oJycpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZyb20tY29kZS1wb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gMTk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjQgU3RyaW5nLnJhdyhjYWxsU2l0ZSwgLi4uc3Vic3RpdHV0aW9ucylcbiAgcmF3OiBmdW5jdGlvbiByYXcoY2FsbFNpdGUpe1xuICAgIHZhciB0cGwgID0gdG9JT2JqZWN0KGNhbGxTaXRlLnJhdylcbiAgICAgICwgbGVuICA9IHRvTGVuZ3RoKHRwbC5sZW5ndGgpXG4gICAgICAsIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIHJlcyAgPSBbXVxuICAgICAgLCBpICAgID0gMDtcbiAgICB3aGlsZShsZW4gPiBpKXtcbiAgICAgIHJlcy5wdXNoKFN0cmluZyh0cGxbaSsrXSkpO1xuICAgICAgaWYoaSA8IGFMZW4pcmVzLnB1c2goU3RyaW5nKGFyZ3VtZW50c1tpXSkpO1xuICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yYXcuanNcbi8vIG1vZHVsZSBpZCA9IDE5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyAyMS4xLjMuMjUgU3RyaW5nLnByb3RvdHlwZS50cmltKClcbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW0nLCBmdW5jdGlvbigkdHJpbSl7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltKCl7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDMpO1xuICB9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy50cmltLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCAgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGluZGV4ID0gdGhpcy5faVxuICAgICwgcG9pbnQ7XG4gIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7dmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZX07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIGRlZmluZWQgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRPX1NUUklORyl7XG4gIHJldHVybiBmdW5jdGlvbih0aGF0LCBwb3Mpe1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG4gICAgICAsIGkgPSB0b0ludGVnZXIocG9zKVxuICAgICAgLCBsID0gcy5sZW5ndGhcbiAgICAgICwgYSwgYjtcbiAgICBpZihpIDwgMCB8fCBpID49IGwpcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1hdC5qc1xuLy8gbW9kdWxlIGlkID0gMjAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBJdGVyYXRvcnMgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgJGl0ZXJDcmVhdGUgICAgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBJVEVSQVRPUiAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgQlVHR1kgICAgICAgICAgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSkgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICAsIEZGX0lURVJBVE9SICAgID0gJ0BAaXRlcmF0b3InXG4gICwgS0VZUyAgICAgICAgICAgPSAna2V5cydcbiAgLCBWQUxVRVMgICAgICAgICA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCl7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uKGtpbmQpe1xuICAgIGlmKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKXJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2goa2luZCl7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyAgICAgICAgPSBOQU1FICsgJyBJdGVyYXRvcidcbiAgICAsIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFU1xuICAgICwgVkFMVUVTX0JVRyA9IGZhbHNlXG4gICAgLCBwcm90byAgICAgID0gQmFzZS5wcm90b3R5cGVcbiAgICAsICRuYXRpdmUgICAgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF1cbiAgICAsICRkZWZhdWx0ICAgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKVxuICAgICwgJGVudHJpZXMgICA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWRcbiAgICAsICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlXG4gICAgLCBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmKCRhbnlOYXRpdmUpe1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKSk7XG4gICAgaWYoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpe1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmKCFMSUJSQVJZICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSloaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKXtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZigoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSl7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSAgPSByZXR1cm5UaGlzO1xuICBpZihERUZBVUxUKXtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiAgREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiAgICBJU19TRVQgICAgID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYoRk9SQ0VEKWZvcihrZXkgaW4gbWV0aG9kcyl7XG4gICAgICBpZighKGtleSBpbiBwcm90bykpcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDIwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDIwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBkZXNjcmlwdG9yICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpe1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHtuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDIwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGF0ICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKGZhbHNlKTtcbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMyBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0KHBvcylcbiAgY29kZVBvaW50QXQ6IGZ1bmN0aW9uIGNvZGVQb2ludEF0KHBvcyl7XG4gICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQuanNcbi8vIG1vZHVsZSBpZCA9IDIwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMS4xLjMuNiBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKHNlYXJjaFN0cmluZyBbLCBlbmRQb3NpdGlvbl0pXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGNvbnRleHQgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0JylcbiAgLCBFTkRTX1dJVEggPSAnZW5kc1dpdGgnXG4gICwgJGVuZHNXaXRoID0gJydbRU5EU19XSVRIXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShFTkRTX1dJVEgpLCAnU3RyaW5nJywge1xuICBlbmRzV2l0aDogZnVuY3Rpb24gZW5kc1dpdGgoc2VhcmNoU3RyaW5nIC8qLCBlbmRQb3NpdGlvbiA9IEBsZW5ndGggKi8pe1xuICAgIHZhciB0aGF0ID0gY29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIEVORFNfV0lUSClcbiAgICAgICwgZW5kUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZFxuICAgICAgLCBsZW4gICAgPSB0b0xlbmd0aCh0aGF0Lmxlbmd0aClcbiAgICAgICwgZW5kICAgID0gZW5kUG9zaXRpb24gPT09IHVuZGVmaW5lZCA/IGxlbiA6IE1hdGgubWluKHRvTGVuZ3RoKGVuZFBvc2l0aW9uKSwgbGVuKVxuICAgICAgLCBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJGVuZHNXaXRoXG4gICAgICA/ICRlbmRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgZW5kKVxuICAgICAgOiB0aGF0LnNsaWNlKGVuZCAtIHNlYXJjaC5sZW5ndGgsIGVuZCkgPT09IHNlYXJjaDtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGguanNcbi8vIG1vZHVsZSBpZCA9IDIwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBoZWxwZXIgZm9yIFN0cmluZyN7c3RhcnRzV2l0aCwgZW5kc1dpdGgsIGluY2x1ZGVzfVxudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJylcbiAgLCBkZWZpbmVkICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aGF0LCBzZWFyY2hTdHJpbmcsIE5BTUUpe1xuICBpZihpc1JlZ0V4cChzZWFyY2hTdHJpbmcpKXRocm93IFR5cGVFcnJvcignU3RyaW5nIycgKyBOQU1FICsgXCIgZG9lc24ndCBhY2NlcHQgcmVnZXghXCIpO1xuICByZXR1cm4gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWNvbnRleHQuanNcbi8vIG1vZHVsZSBpZCA9IDIwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjIuOCBJc1JlZ0V4cChhcmd1bWVudClcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgY29mICAgICAgPSByZXF1aXJlKCcuL19jb2YnKVxuICAsIE1BVENIICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY29mKGl0KSA9PSAnUmVnRXhwJyk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19pcy1yZWdleHAuanNcbi8vIG1vZHVsZSBpZCA9IDIwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTUFUQ0ggPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZKXtcbiAgdmFyIHJlID0gLy4vO1xuICB0cnkge1xuICAgICcvLi8nW0tFWV0ocmUpO1xuICB9IGNhdGNoKGUpe1xuICAgIHRyeSB7XG4gICAgICByZVtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAhJy8uLydbS0VZXShyZSk7XG4gICAgfSBjYXRjaChmKXsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiB0cnVlO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fZmFpbHMtaXMtcmVnZXhwLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjEuMS4zLjcgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyhzZWFyY2hTdHJpbmcsIHBvc2l0aW9uID0gMClcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY29udGV4dCAgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpXG4gICwgSU5DTFVERVMgPSAnaW5jbHVkZXMnO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKElOQ0xVREVTKSwgJ1N0cmluZycsIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFN0cmluZyAvKiwgcG9zaXRpb24gPSAwICovKXtcbiAgICByZXR1cm4gISF+Y29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIElOQ0xVREVTKVxuICAgICAgLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanNcbi8vIG1vZHVsZSBpZCA9IDIxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjEzIFN0cmluZy5wcm90b3R5cGUucmVwZWF0KGNvdW50KVxuICByZXBlYXQ6IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQuanNcbi8vIG1vZHVsZSBpZCA9IDIxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMS4xLjMuMTggU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoKHNlYXJjaFN0cmluZyBbLCBwb3NpdGlvbiBdKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0xlbmd0aCAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgY29udGV4dCAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpXG4gICwgU1RBUlRTX1dJVEggPSAnc3RhcnRzV2l0aCdcbiAgLCAkc3RhcnRzV2l0aCA9ICcnW1NUQVJUU19XSVRIXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShTVEFSVFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIHN0YXJ0c1dpdGg6IGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIC8qLCBwb3NpdGlvbiA9IDAgKi8pe1xuICAgIHZhciB0aGF0ICAgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgU1RBUlRTX1dJVEgpXG4gICAgICAsIGluZGV4ICA9IHRvTGVuZ3RoKE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0aGF0Lmxlbmd0aCkpXG4gICAgICAsIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkc3RhcnRzV2l0aFxuICAgICAgPyAkc3RhcnRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgaW5kZXgpXG4gICAgICA6IHRoYXQuc2xpY2UoaW5kZXgsIGluZGV4ICsgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aC5qc1xuLy8gbW9kdWxlIGlkID0gMjEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjIgU3RyaW5nLnByb3RvdHlwZS5hbmNob3IobmFtZSlcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2FuY2hvcicsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gYW5jaG9yKG5hbWUpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdhJywgJ25hbWUnLCBuYW1lKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5hbmNob3IuanNcbi8vIG1vZHVsZSBpZCA9IDIxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgcXVvdCAgICA9IC9cIi9nO1xuLy8gQi4yLjMuMi4xIENyZWF0ZUhUTUwoc3RyaW5nLCB0YWcsIGF0dHJpYnV0ZSwgdmFsdWUpXG52YXIgY3JlYXRlSFRNTCA9IGZ1bmN0aW9uKHN0cmluZywgdGFnLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gIHZhciBTICA9IFN0cmluZyhkZWZpbmVkKHN0cmluZykpXG4gICAgLCBwMSA9ICc8JyArIHRhZztcbiAgaWYoYXR0cmlidXRlICE9PSAnJylwMSArPSAnICcgKyBhdHRyaWJ1dGUgKyAnPVwiJyArIFN0cmluZyh2YWx1ZSkucmVwbGFjZShxdW90LCAnJnF1b3Q7JykgKyAnXCInO1xuICByZXR1cm4gcDEgKyAnPicgKyBTICsgJzwvJyArIHRhZyArICc+Jztcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUsIGV4ZWMpe1xuICB2YXIgTyA9IHt9O1xuICBPW05BTUVdID0gZXhlYyhjcmVhdGVIVE1MKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbigpe1xuICAgIHZhciB0ZXN0ID0gJydbTkFNRV0oJ1wiJyk7XG4gICAgcmV0dXJuIHRlc3QgIT09IHRlc3QudG9Mb3dlckNhc2UoKSB8fCB0ZXN0LnNwbGl0KCdcIicpLmxlbmd0aCA+IDM7XG4gIH0pLCAnU3RyaW5nJywgTyk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctaHRtbC5qc1xuLy8gbW9kdWxlIGlkID0gMjE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjMgU3RyaW5nLnByb3RvdHlwZS5iaWcoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYmlnJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBiaWcoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYmlnJywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5iaWcuanNcbi8vIG1vZHVsZSBpZCA9IDIxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy40IFN0cmluZy5wcm90b3R5cGUuYmxpbmsoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYmxpbmsnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJsaW5rKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2JsaW5rJywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ibGluay5qc1xuLy8gbW9kdWxlIGlkID0gMjE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjUgU3RyaW5nLnByb3RvdHlwZS5ib2xkKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JvbGQnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJvbGQoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYicsICcnLCAnJyk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYm9sZC5qc1xuLy8gbW9kdWxlIGlkID0gMjE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjYgU3RyaW5nLnByb3RvdHlwZS5maXhlZCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmaXhlZCcsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gZml4ZWQoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAndHQnLCAnJywgJycpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZpeGVkLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNyBTdHJpbmcucHJvdG90eXBlLmZvbnRjb2xvcihjb2xvcilcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZvbnRjb2xvcicsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gZm9udGNvbG9yKGNvbG9yKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnZm9udCcsICdjb2xvcicsIGNvbG9yKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250Y29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IDIyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy44IFN0cmluZy5wcm90b3R5cGUuZm9udHNpemUoc2l6ZSlcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZvbnRzaXplJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBmb250c2l6ZShzaXplKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnZm9udCcsICdzaXplJywgc2l6ZSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udHNpemUuanNcbi8vIG1vZHVsZSBpZCA9IDIyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy45IFN0cmluZy5wcm90b3R5cGUuaXRhbGljcygpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdpdGFsaWNzJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBpdGFsaWNzKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2knLCAnJywgJycpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0YWxpY3MuanNcbi8vIG1vZHVsZSBpZCA9IDIyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMCBTdHJpbmcucHJvdG90eXBlLmxpbmsodXJsKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnbGluaycsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gbGluayh1cmwpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdhJywgJ2hyZWYnLCB1cmwpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmxpbmsuanNcbi8vIG1vZHVsZSBpZCA9IDIyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMSBTdHJpbmcucHJvdG90eXBlLnNtYWxsKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3NtYWxsJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBzbWFsbCgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzbWFsbCcsICcnLCAnJyk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc21hbGwuanNcbi8vIG1vZHVsZSBpZCA9IDIyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMiBTdHJpbmcucHJvdG90eXBlLnN0cmlrZSgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdHJpa2UnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN0cmlrZSgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdHJpa2UnLCAnJywgJycpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0cmlrZS5qc1xuLy8gbW9kdWxlIGlkID0gMjI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjEzIFN0cmluZy5wcm90b3R5cGUuc3ViKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N1YicsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gc3ViKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N1YicsICcnLCAnJyk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3ViLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTQgU3RyaW5nLnByb3RvdHlwZS5zdXAoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3VwJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBzdXAoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3VwJywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdXAuanNcbi8vIG1vZHVsZSBpZCA9IDIyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4zLjMuMSAvIDE1LjkuNC40IERhdGUubm93KClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnRGF0ZScsIHtub3c6IGZ1bmN0aW9uKCl7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLm5vdy5qc1xuLy8gbW9kdWxlIGlkID0gMjI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gbmV3IERhdGUoTmFOKS50b0pTT04oKSAhPT0gbnVsbCB8fCBEYXRlLnByb3RvdHlwZS50b0pTT04uY2FsbCh7dG9JU09TdHJpbmc6IGZ1bmN0aW9uKCl7IHJldHVybiAxOyB9fSkgIT09IDE7XG59KSwgJ0RhdGUnLCB7XG4gIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKGtleSl7XG4gICAgdmFyIE8gID0gdG9PYmplY3QodGhpcylcbiAgICAgICwgcHYgPSB0b1ByaW1pdGl2ZShPKTtcbiAgICByZXR1cm4gdHlwZW9mIHB2ID09ICdudW1iZXInICYmICFpc0Zpbml0ZShwdikgPyBudWxsIDogTy50b0lTT1N0cmluZygpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1qc29uLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjAuMy40LjM2IC8gMTUuOS41LjQzIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGdldFRpbWUgPSBEYXRlLnByb3RvdHlwZS5nZXRUaW1lO1xuXG52YXIgbHogPSBmdW5jdGlvbihudW0pe1xuICByZXR1cm4gbnVtID4gOSA/IG51bSA6ICcwJyArIG51bTtcbn07XG5cbi8vIFBoYW50b21KUyAvIG9sZCBXZWJLaXQgaGFzIGEgYnJva2VuIGltcGxlbWVudGF0aW9uc1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIG5ldyBEYXRlKC01ZTEzIC0gMSkudG9JU09TdHJpbmcoKSAhPSAnMDM4NS0wNy0yNVQwNzowNjozOS45OTlaJztcbn0pIHx8ICFmYWlscyhmdW5jdGlvbigpe1xuICBuZXcgRGF0ZShOYU4pLnRvSVNPU3RyaW5nKCk7XG59KSksICdEYXRlJywge1xuICB0b0lTT1N0cmluZzogZnVuY3Rpb24gdG9JU09TdHJpbmcoKXtcbiAgICBpZighaXNGaW5pdGUoZ2V0VGltZS5jYWxsKHRoaXMpKSl0aHJvdyBSYW5nZUVycm9yKCdJbnZhbGlkIHRpbWUgdmFsdWUnKTtcbiAgICB2YXIgZCA9IHRoaXNcbiAgICAgICwgeSA9IGQuZ2V0VVRDRnVsbFllYXIoKVxuICAgICAgLCBtID0gZC5nZXRVVENNaWxsaXNlY29uZHMoKVxuICAgICAgLCBzID0geSA8IDAgPyAnLScgOiB5ID4gOTk5OSA/ICcrJyA6ICcnO1xuICAgIHJldHVybiBzICsgKCcwMDAwMCcgKyBNYXRoLmFicyh5KSkuc2xpY2UocyA/IC02IDogLTQpICtcbiAgICAgICctJyArIGx6KGQuZ2V0VVRDTW9udGgoKSArIDEpICsgJy0nICsgbHooZC5nZXRVVENEYXRlKCkpICtcbiAgICAgICdUJyArIGx6KGQuZ2V0VVRDSG91cnMoKSkgKyAnOicgKyBseihkLmdldFVUQ01pbnV0ZXMoKSkgK1xuICAgICAgJzonICsgbHooZC5nZXRVVENTZWNvbmRzKCkpICsgJy4nICsgKG0gPiA5OSA/IG0gOiAnMCcgKyBseihtKSkgKyAnWic7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDIzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRGF0ZVByb3RvICAgID0gRGF0ZS5wcm90b3R5cGVcbiAgLCBJTlZBTElEX0RBVEUgPSAnSW52YWxpZCBEYXRlJ1xuICAsIFRPX1NUUklORyAgICA9ICd0b1N0cmluZydcbiAgLCAkdG9TdHJpbmcgICAgPSBEYXRlUHJvdG9bVE9fU1RSSU5HXVxuICAsIGdldFRpbWUgICAgICA9IERhdGVQcm90by5nZXRUaW1lO1xuaWYobmV3IERhdGUoTmFOKSArICcnICE9IElOVkFMSURfREFURSl7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoRGF0ZVByb3RvLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgdmFyIHZhbHVlID0gZ2V0VGltZS5jYWxsKHRoaXMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyAkdG9TdHJpbmcuY2FsbCh0aGlzKSA6IElOVkFMSURfREFURTtcbiAgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRPX1BSSU1JVElWRSA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1ByaW1pdGl2ZScpXG4gICwgcHJvdG8gICAgICAgID0gRGF0ZS5wcm90b3R5cGU7XG5cbmlmKCEoVE9fUFJJTUlUSVZFIGluIHByb3RvKSlyZXF1aXJlKCcuL19oaWRlJykocHJvdG8sIFRPX1BSSU1JVElWRSwgcmVxdWlyZSgnLi9fZGF0ZS10by1wcmltaXRpdmUnKSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tcHJpbWl0aXZlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgTlVNQkVSICAgICAgPSAnbnVtYmVyJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihoaW50KXtcbiAgaWYoaGludCAhPT0gJ3N0cmluZycgJiYgaGludCAhPT0gTlVNQkVSICYmIGhpbnQgIT09ICdkZWZhdWx0Jyl0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCBoaW50Jyk7XG4gIHJldHVybiB0b1ByaW1pdGl2ZShhbk9iamVjdCh0aGlzKSwgaGludCAhPSBOVU1CRVIpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1wcmltaXRpdmUuanNcbi8vIG1vZHVsZSBpZCA9IDIzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMi4xLjIuMiAvIDE1LjQuMy4yIEFycmF5LmlzQXJyYXkoYXJnKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdBcnJheScsIHtpc0FycmF5OiByZXF1aXJlKCcuL19pcy1hcnJheScpfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmlzLWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGN0eCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGNhbGwgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciAgICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKVxuICAsIHRvTGVuZ3RoICAgICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpXG4gICwgZ2V0SXRlckZuICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlLyosIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKi8pe1xuICAgIHZhciBPICAgICAgID0gdG9PYmplY3QoYXJyYXlMaWtlKVxuICAgICAgLCBDICAgICAgID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheVxuICAgICAgLCBhTGVuICAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBtYXBmbiAgID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcbiAgICAgICwgaW5kZXggICA9IDBcbiAgICAgICwgaXRlckZuICA9IGdldEl0ZXJGbihPKVxuICAgICAgLCBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYobWFwcGluZyltYXBmbiA9IGN0eChtYXBmbiwgYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAgIC8vIGlmIG9iamVjdCBpc24ndCBpdGVyYWJsZSBvciBpdCdzIGFycmF5IHdpdGggZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBzaW1wbGUgY2FzZVxuICAgIGlmKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKXtcbiAgICAgIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQzsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKXtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBmb3IocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZyb20uanNcbi8vIG1vZHVsZSBpZCA9IDIzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaChlKXtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmKHJldCAhPT0gdW5kZWZpbmVkKWFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1jYWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIElURVJBVE9SICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGluZGV4LCB2YWx1ZSl7XG4gIGlmKGluZGV4IGluIG9iamVjdCkkZGVmaW5lUHJvcGVydHkuZihvYmplY3QsIGluZGV4LCBjcmVhdGVEZXNjKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W2luZGV4XSA9IHZhbHVlO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNsYXNzb2YgICA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsIElURVJBVE9SICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgIT0gdW5kZWZpbmVkKXJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIElURVJBVE9SICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24oKXsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24oKXsgdGhyb3cgMjsgfSk7XG59IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYywgc2tpcENsb3Npbmcpe1xuICBpZighc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORylyZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciAgPSBbN11cbiAgICAgICwgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbigpeyByZXR1cm4ge2RvbmU6IHNhZmUgPSB0cnVlfTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1kZXRlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDI0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG5cbi8vIFdlYktpdCBBcnJheS5vZiBpc24ndCBnZW5lcmljXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgZnVuY3Rpb24gRigpe31cbiAgcmV0dXJuICEoQXJyYXkub2YuY2FsbChGKSBpbnN0YW5jZW9mIEYpO1xufSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjMgQXJyYXkub2YoIC4uLml0ZW1zKVxuICBvZjogZnVuY3Rpb24gb2YoLyogLi4uYXJncyAqLyl7XG4gICAgdmFyIGluZGV4ICA9IDBcbiAgICAgICwgYUxlbiAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCByZXN1bHQgPSBuZXcgKHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXkpKGFMZW4pO1xuICAgIHdoaWxlKGFMZW4gPiBpbmRleCljcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHJlc3VsdC5sZW5ndGggPSBhTGVuO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5vZi5qc1xuLy8gbW9kdWxlIGlkID0gMjQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUuam9pbihzZXBhcmF0b3IpXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBhcnJheUpvaW4gPSBbXS5qb2luO1xuXG4vLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2Ugc3RyaW5nc1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAocmVxdWlyZSgnLi9faW9iamVjdCcpICE9IE9iamVjdCB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKGFycmF5Sm9pbikpLCAnQXJyYXknLCB7XG4gIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKXtcbiAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodG9JT2JqZWN0KHRoaXMpLCBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCA/ICcsJyA6IHNlcGFyYXRvcik7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5qb2luLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtZXRob2QsIGFyZyl7XG4gIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyhmdW5jdGlvbigpe1xuICAgIGFyZyA/IG1ldGhvZC5jYWxsKG51bGwsIGZ1bmN0aW9uKCl7fSwgMSkgOiBtZXRob2QuY2FsbChudWxsKTtcbiAgfSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpY3QtbWV0aG9kLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGh0bWwgICAgICAgPSByZXF1aXJlKCcuL19odG1sJylcbiAgLCBjb2YgICAgICAgID0gcmVxdWlyZSgnLi9fY29mJylcbiAgLCB0b0luZGV4ICAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIHRvTGVuZ3RoICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGFycmF5U2xpY2UgPSBbXS5zbGljZTtcblxuLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIEVTMyBzdHJpbmdzIGFuZCBET00gb2JqZWN0c1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIGlmKGh0bWwpYXJyYXlTbGljZS5jYWxsKGh0bWwpO1xufSksICdBcnJheScsIHtcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKGJlZ2luLCBlbmQpe1xuICAgIHZhciBsZW4gICA9IHRvTGVuZ3RoKHRoaXMubGVuZ3RoKVxuICAgICAgLCBrbGFzcyA9IGNvZih0aGlzKTtcbiAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IGVuZDtcbiAgICBpZihrbGFzcyA9PSAnQXJyYXknKXJldHVybiBhcnJheVNsaWNlLmNhbGwodGhpcywgYmVnaW4sIGVuZCk7XG4gICAgdmFyIHN0YXJ0ICA9IHRvSW5kZXgoYmVnaW4sIGxlbilcbiAgICAgICwgdXBUbyAgID0gdG9JbmRleChlbmQsIGxlbilcbiAgICAgICwgc2l6ZSAgID0gdG9MZW5ndGgodXBUbyAtIHN0YXJ0KVxuICAgICAgLCBjbG9uZWQgPSBBcnJheShzaXplKVxuICAgICAgLCBpICAgICAgPSAwO1xuICAgIGZvcig7IGkgPCBzaXplOyBpKyspY2xvbmVkW2ldID0ga2xhc3MgPT0gJ1N0cmluZydcbiAgICAgID8gdGhpcy5jaGFyQXQoc3RhcnQgKyBpKVxuICAgICAgOiB0aGlzW3N0YXJ0ICsgaV07XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgdG9PYmplY3QgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBmYWlscyAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgJHNvcnQgICAgID0gW10uc29ydFxuICAsIHRlc3QgICAgICA9IFsxLCAyLCAzXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24oKXtcbiAgLy8gSUU4LVxuICB0ZXN0LnNvcnQodW5kZWZpbmVkKTtcbn0pIHx8ICFmYWlscyhmdW5jdGlvbigpe1xuICAvLyBWOCBidWdcbiAgdGVzdC5zb3J0KG51bGwpO1xuICAvLyBPbGQgV2ViS2l0XG59KSB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRzb3J0KSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjI1IEFycmF5LnByb3RvdHlwZS5zb3J0KGNvbXBhcmVmbilcbiAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pe1xuICAgIHJldHVybiBjb21wYXJlZm4gPT09IHVuZGVmaW5lZFxuICAgICAgPyAkc29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpKVxuICAgICAgOiAkc29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpLCBhRnVuY3Rpb24oY29tcGFyZWZuKSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZm9yRWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKVxuICAsIFNUUklDVCAgID0gcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmZvckVhY2gsIHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFTVFJJQ1QsICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjEwIC8gMTUuNC40LjE4IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pe1xuICAgIHJldHVybiAkZm9yRWFjaCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2guanNcbi8vIG1vZHVsZSBpZCA9IDI0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyA0IC0+IEFycmF5I2V2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIDYgLT4gQXJyYXkjZmluZEluZGV4XG52YXIgY3R4ICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIElPYmplY3QgID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBhc2MgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRZUEUsICRjcmVhdGUpe1xuICB2YXIgSVNfTUFQICAgICAgICA9IFRZUEUgPT0gMVxuICAgICwgSVNfRklMVEVSICAgICA9IFRZUEUgPT0gMlxuICAgICwgSVNfU09NRSAgICAgICA9IFRZUEUgPT0gM1xuICAgICwgSVNfRVZFUlkgICAgICA9IFRZUEUgPT0gNFxuICAgICwgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNlxuICAgICwgTk9fSE9MRVMgICAgICA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYXG4gICAgLCBjcmVhdGUgICAgICAgID0gJGNyZWF0ZSB8fCBhc2M7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCl7XG4gICAgdmFyIE8gICAgICA9IHRvT2JqZWN0KCR0aGlzKVxuICAgICAgLCBzZWxmICAgPSBJT2JqZWN0KE8pXG4gICAgICAsIGYgICAgICA9IGN0eChjYWxsYmFja2ZuLCB0aGF0LCAzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gMFxuICAgICAgLCByZXN1bHQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkXG4gICAgICAsIHZhbCwgcmVzO1xuICAgIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZil7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG4gICAgICBpZihUWVBFKXtcbiAgICAgICAgaWYoSVNfTUFQKXJlc3VsdFtpbmRleF0gPSByZXM7ICAgICAgICAgICAgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYocmVzKXN3aXRjaChUWVBFKXtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcmVzdWx0LnB1c2godmFsKTsgICAgICAgICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIGlmKElTX0VWRVJZKXJldHVybiBmYWxzZTsgICAgICAgICAgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanNcbi8vIG1vZHVsZSBpZCA9IDI0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA5LjQuMi4zIEFycmF5U3BlY2llc0NyZWF0ZShvcmlnaW5hbEFycmF5LCBsZW5ndGgpXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsLCBsZW5ndGgpe1xuICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWwpKShsZW5ndGgpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDI0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGlzQXJyYXkgID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKVxuICAsIFNQRUNJRVMgID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbCl7XG4gIHZhciBDO1xuICBpZihpc0FycmF5KG9yaWdpbmFsKSl7XG4gICAgQyA9IG9yaWdpbmFsLmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKUMgPSB1bmRlZmluZWQ7XG4gICAgaWYoaXNPYmplY3QoQykpe1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZihDID09PSBudWxsKUMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IHJldHVybiBDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEM7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRtYXAgICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5tYXAsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xNSAvIDE1LjQuNC4xOSBBcnJheS5wcm90b3R5cGUubWFwKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcbiAgICByZXR1cm4gJG1hcCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkubWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMik7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5maWx0ZXIsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy43IC8gMTUuNC40LjIwIEFycmF5LnByb3RvdHlwZS5maWx0ZXIoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pe1xuICAgIHJldHVybiAkZmlsdGVyKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHNvbWUgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgzKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnNvbWUsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4yMyAvIDE1LjQuNC4xNyBBcnJheS5wcm90b3R5cGUuc29tZShjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcbiAgICByZXR1cm4gJHNvbWUodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvbWUuanNcbi8vIG1vZHVsZSBpZCA9IDI1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGV2ZXJ5ICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg0KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmV2ZXJ5LCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuNSAvIDE1LjQuNC4xNiBBcnJheS5wcm90b3R5cGUuZXZlcnkoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcbiAgICByZXR1cm4gJGV2ZXJ5KHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5ldmVyeS5qc1xuLy8gbW9kdWxlIGlkID0gMjUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5yZWR1Y2UsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xOCAvIDE1LjQuNC4yMSBBcnJheS5wcm90b3R5cGUucmVkdWNlKGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLyl7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzWzFdLCBmYWxzZSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UuanNcbi8vIG1vZHVsZSBpZCA9IDI1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgdG9PYmplY3QgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICAgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aGF0LCBjYWxsYmFja2ZuLCBhTGVuLCBtZW1vLCBpc1JpZ2h0KXtcbiAgYUZ1bmN0aW9uKGNhbGxiYWNrZm4pO1xuICB2YXIgTyAgICAgID0gdG9PYmplY3QodGhhdClcbiAgICAsIHNlbGYgICA9IElPYmplY3QoTylcbiAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICwgaW5kZXggID0gaXNSaWdodCA/IGxlbmd0aCAtIDEgOiAwXG4gICAgLCBpICAgICAgPSBpc1JpZ2h0ID8gLTEgOiAxO1xuICBpZihhTGVuIDwgMilmb3IoOzspe1xuICAgIGlmKGluZGV4IGluIHNlbGYpe1xuICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleCArPSBpO1xuICAgIGlmKGlzUmlnaHQgPyBpbmRleCA8IDAgOiBsZW5ndGggPD0gaW5kZXgpe1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgfVxuICB9XG4gIGZvcig7aXNSaWdodCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSlpZihpbmRleCBpbiBzZWxmKXtcbiAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICB9XG4gIHJldHVybiBtZW1vO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktcmVkdWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRyZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheS1yZWR1Y2UnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnJlZHVjZVJpZ2h0LCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTkgLyAxNS40LjQuMjIgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pe1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c1sxXSwgdHJ1ZSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UtcmlnaHQuanNcbi8vIG1vZHVsZSBpZCA9IDI1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGluZGV4T2YgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpXG4gICwgJG5hdGl2ZSAgICAgICA9IFtdLmluZGV4T2ZcbiAgLCBORUdBVElWRV9aRVJPID0gISEkbmF0aXZlICYmIDEgLyBbMV0uaW5kZXhPZigxLCAtMCkgPCAwO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChORUdBVElWRV9aRVJPIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJG5hdGl2ZSkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMSAvIDE1LjQuNC4xNCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZihzZWFyY2hFbGVtZW50IFssIGZyb21JbmRleF0pXG4gIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ID0gMCAqLyl7XG4gICAgcmV0dXJuIE5FR0FUSVZFX1pFUk9cbiAgICAgIC8vIGNvbnZlcnQgLTAgdG8gKzBcbiAgICAgID8gJG5hdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDBcbiAgICAgIDogJGluZGV4T2YodGhpcywgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmluZGV4LW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvSU9iamVjdCAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b0ludGVnZXIgICAgID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgdG9MZW5ndGggICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgJG5hdGl2ZSAgICAgICA9IFtdLmxhc3RJbmRleE9mXG4gICwgTkVHQVRJVkVfWkVSTyA9ICEhJG5hdGl2ZSAmJiAxIC8gWzFdLmxhc3RJbmRleE9mKDEsIC0wKSA8IDA7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKE5FR0FUSVZFX1pFUk8gfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkbmF0aXZlKSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE0IC8gMTUuNC40LjE1IEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IFssIGZyb21JbmRleF0pXG4gIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggPSBAWyotMV0gKi8pe1xuICAgIC8vIGNvbnZlcnQgLTAgdG8gKzBcbiAgICBpZihORUdBVElWRV9aRVJPKXJldHVybiAkbmF0aXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMDtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KHRoaXMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSBsZW5ndGggLSAxO1xuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPiAxKWluZGV4ID0gTWF0aC5taW4oaW5kZXgsIHRvSW50ZWdlcihhcmd1bWVudHNbMV0pKTtcbiAgICBpZihpbmRleCA8IDApaW5kZXggPSBsZW5ndGggKyBpbmRleDtcbiAgICBmb3IoO2luZGV4ID49IDA7IGluZGV4LS0paWYoaW5kZXggaW4gTylpZihPW2luZGV4XSA9PT0gc2VhcmNoRWxlbWVudClyZXR1cm4gaW5kZXggfHwgMDtcbiAgICByZXR1cm4gLTE7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5sYXN0LWluZGV4LW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAyNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge2NvcHlXaXRoaW46IHJlcXVpcmUoJy4vX2FycmF5LWNvcHktd2l0aGluJyl9KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2NvcHlXaXRoaW4nKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuY29weS13aXRoaW4uanNcbi8vIG1vZHVsZSBpZCA9IDI1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMi4xLjMuMyBBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0LCBlbmQgPSB0aGlzLmxlbmd0aClcbid1c2Ugc3RyaWN0JztcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9JbmRleCAgPSByZXF1aXJlKCcuL190by1pbmRleCcpXG4gICwgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBbXS5jb3B5V2l0aGluIHx8IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0Lyo9IDAqLywgc3RhcnQvKj0gMCwgZW5kID0gQGxlbmd0aCovKXtcbiAgdmFyIE8gICAgID0gdG9PYmplY3QodGhpcylcbiAgICAsIGxlbiAgID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgLCB0byAgICA9IHRvSW5kZXgodGFyZ2V0LCBsZW4pXG4gICAgLCBmcm9tICA9IHRvSW5kZXgoc3RhcnQsIGxlbilcbiAgICAsIGVuZCAgID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWRcbiAgICAsIGNvdW50ID0gTWF0aC5taW4oKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogdG9JbmRleChlbmQsIGxlbikpIC0gZnJvbSwgbGVuIC0gdG8pXG4gICAgLCBpbmMgICA9IDE7XG4gIGlmKGZyb20gPCB0byAmJiB0byA8IGZyb20gKyBjb3VudCl7XG4gICAgaW5jICA9IC0xO1xuICAgIGZyb20gKz0gY291bnQgLSAxO1xuICAgIHRvICAgKz0gY291bnQgLSAxO1xuICB9XG4gIHdoaWxlKGNvdW50LS0gPiAwKXtcbiAgICBpZihmcm9tIGluIE8pT1t0b10gPSBPW2Zyb21dO1xuICAgIGVsc2UgZGVsZXRlIE9bdG9dO1xuICAgIHRvICAgKz0gaW5jO1xuICAgIGZyb20gKz0gaW5jO1xuICB9IHJldHVybiBPO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktY29weS13aXRoaW4uanNcbi8vIG1vZHVsZSBpZCA9IDI2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgVU5TQ09QQUJMRVMgPSByZXF1aXJlKCcuL193a3MnKSgndW5zY29wYWJsZXMnKVxuICAsIEFycmF5UHJvdG8gID0gQXJyYXkucHJvdG90eXBlO1xuaWYoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKXJlcXVpcmUoJy4vX2hpZGUnKShBcnJheVByb3RvLCBVTlNDT1BBQkxFUywge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qc1xuLy8gbW9kdWxlIGlkID0gMjYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIyLjEuMy42IEFycmF5LnByb3RvdHlwZS5maWxsKHZhbHVlLCBzdGFydCA9IDAsIGVuZCA9IHRoaXMubGVuZ3RoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtmaWxsOiByZXF1aXJlKCcuL19hcnJheS1maWxsJyl9KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2ZpbGwnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsbC5qc1xuLy8gbW9kdWxlIGlkID0gMjYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIyLjEuMy42IEFycmF5LnByb3RvdHlwZS5maWxsKHZhbHVlLCBzdGFydCA9IDAsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b0luZGV4ICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4JylcbiAgLCB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi8pe1xuICB2YXIgTyAgICAgID0gdG9PYmplY3QodGhpcylcbiAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICwgYUxlbiAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgaW5kZXggID0gdG9JbmRleChhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgbGVuZ3RoKVxuICAgICwgZW5kICAgID0gYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWRcbiAgICAsIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9JbmRleChlbmQsIGxlbmd0aCk7XG4gIHdoaWxlKGVuZFBvcyA+IGluZGV4KU9baW5kZXgrK10gPSB2YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1maWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjggQXJyYXkucHJvdG90eXBlLmZpbmQocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmaW5kICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNSlcbiAgLCBLRVkgICAgID0gJ2ZpbmQnXG4gICwgZm9yY2VkICA9IHRydWU7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYoS0VZIGluIFtdKUFycmF5KDEpW0tFWV0oZnVuY3Rpb24oKXsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZDogZnVuY3Rpb24gZmluZChjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoS0VZKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC5qc1xuLy8gbW9kdWxlIGlkID0gMjY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy45IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmaW5kICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNilcbiAgLCBLRVkgICAgID0gJ2ZpbmRJbmRleCdcbiAgLCBmb3JjZWQgID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZihLRVkgaW4gW10pQXJyYXkoMSlbS0VZXShmdW5jdGlvbigpeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoS0VZKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ0FycmF5Jyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNwZWNpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDI2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGRQICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBTUEVDSUVTICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZKXtcbiAgdmFyIEMgPSBnbG9iYWxbS0VZXTtcbiAgaWYoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSlkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC1zcGVjaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKVxuICAsIHN0ZXAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKVxuICAsIEl0ZXJhdG9ycyAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIHRvSU9iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGtpbmQgID0gdGhpcy5fa1xuICAgICwgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKXtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDI2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvbmUsIHZhbHVlKXtcbiAgcmV0dXJuIHt2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZX07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLXN0ZXAuanNcbi8vIG1vZHVsZSBpZCA9IDI2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFsICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpXG4gICwgZFAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgZ09QTiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCBpc1JlZ0V4cCAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpXG4gICwgJGZsYWdzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mbGFncycpXG4gICwgJFJlZ0V4cCAgICAgICAgICAgPSBnbG9iYWwuUmVnRXhwXG4gICwgQmFzZSAgICAgICAgICAgICAgPSAkUmVnRXhwXG4gICwgcHJvdG8gICAgICAgICAgICAgPSAkUmVnRXhwLnByb3RvdHlwZVxuICAsIHJlMSAgICAgICAgICAgICAgID0gL2EvZ1xuICAsIHJlMiAgICAgICAgICAgICAgID0gL2EvZ1xuICAvLyBcIm5ld1wiIGNyZWF0ZXMgYSBuZXcgb2JqZWN0LCBvbGQgd2Via2l0IGJ1Z2d5IGhlcmVcbiAgLCBDT1JSRUNUX05FVyAgICAgICA9IG5ldyAkUmVnRXhwKHJlMSkgIT09IHJlMTtcblxuaWYocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAoIUNPUlJFQ1RfTkVXIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmUyW3JlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpXSA9IGZhbHNlO1xuICAvLyBSZWdFeHAgY29uc3RydWN0b3IgY2FuIGFsdGVyIGZsYWdzIGFuZCBJc1JlZ0V4cCB3b3JrcyBjb3JyZWN0IHdpdGggQEBtYXRjaFxuICByZXR1cm4gJFJlZ0V4cChyZTEpICE9IHJlMSB8fCAkUmVnRXhwKHJlMikgPT0gcmUyIHx8ICRSZWdFeHAocmUxLCAnaScpICE9ICcvYS9pJztcbn0pKSl7XG4gICRSZWdFeHAgPSBmdW5jdGlvbiBSZWdFeHAocCwgZil7XG4gICAgdmFyIHRpUkUgPSB0aGlzIGluc3RhbmNlb2YgJFJlZ0V4cFxuICAgICAgLCBwaVJFID0gaXNSZWdFeHAocClcbiAgICAgICwgZmlVICA9IGYgPT09IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gIXRpUkUgJiYgcGlSRSAmJiBwLmNvbnN0cnVjdG9yID09PSAkUmVnRXhwICYmIGZpVSA/IHBcbiAgICAgIDogaW5oZXJpdElmUmVxdWlyZWQoQ09SUkVDVF9ORVdcbiAgICAgICAgPyBuZXcgQmFzZShwaVJFICYmICFmaVUgPyBwLnNvdXJjZSA6IHAsIGYpXG4gICAgICAgIDogQmFzZSgocGlSRSA9IHAgaW5zdGFuY2VvZiAkUmVnRXhwKSA/IHAuc291cmNlIDogcCwgcGlSRSAmJiBmaVUgPyAkZmxhZ3MuY2FsbChwKSA6IGYpXG4gICAgICAsIHRpUkUgPyB0aGlzIDogcHJvdG8sICRSZWdFeHApO1xuICB9O1xuICB2YXIgcHJveHkgPSBmdW5jdGlvbihrZXkpe1xuICAgIGtleSBpbiAkUmVnRXhwIHx8IGRQKCRSZWdFeHAsIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gQmFzZVtrZXldOyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbihpdCl7IEJhc2Vba2V5XSA9IGl0OyB9XG4gICAgfSk7XG4gIH07XG4gIGZvcih2YXIga2V5cyA9IGdPUE4oQmFzZSksIGkgPSAwOyBrZXlzLmxlbmd0aCA+IGk7IClwcm94eShrZXlzW2krK10pO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICRSZWdFeHA7XG4gICRSZWdFeHAucHJvdG90eXBlID0gcHJvdG87XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCAnUmVnRXhwJywgJFJlZ0V4cCk7XG59XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ1JlZ0V4cCcpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuY29uc3RydWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDI3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFnc1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7XG4gIHZhciB0aGF0ICAgPSBhbk9iamVjdCh0aGlzKVxuICAgICwgcmVzdWx0ID0gJyc7XG4gIGlmKHRoYXQuZ2xvYmFsKSAgICAgcmVzdWx0ICs9ICdnJztcbiAgaWYodGhhdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuICBpZih0aGF0Lm11bHRpbGluZSkgIHJlc3VsdCArPSAnbSc7XG4gIGlmKHRoYXQudW5pY29kZSkgICAgcmVzdWx0ICs9ICd1JztcbiAgaWYodGhhdC5zdGlja3kpICAgICByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanNcbi8vIG1vZHVsZSBpZCA9IDI3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5yZXF1aXJlKCcuL2VzNi5yZWdleHAuZmxhZ3MnKTtcbnZhciBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgJGZsYWdzICAgICAgPSByZXF1aXJlKCcuL19mbGFncycpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgVE9fU1RSSU5HICAgPSAndG9TdHJpbmcnXG4gICwgJHRvU3RyaW5nICAgPSAvLi9bVE9fU1RSSU5HXTtcblxudmFyIGRlZmluZSA9IGZ1bmN0aW9uKGZuKXtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShSZWdFeHAucHJvdG90eXBlLCBUT19TVFJJTkcsIGZuLCB0cnVlKTtcbn07XG5cbi8vIDIxLjIuNS4xNCBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nKClcbmlmKHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXsgcmV0dXJuICR0b1N0cmluZy5jYWxsKHtzb3VyY2U6ICdhJywgZmxhZ3M6ICdiJ30pICE9ICcvYS9iJzsgfSkpe1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICB2YXIgUiA9IGFuT2JqZWN0KHRoaXMpO1xuICAgIHJldHVybiAnLycuY29uY2F0KFIuc291cmNlLCAnLycsXG4gICAgICAnZmxhZ3MnIGluIFIgPyBSLmZsYWdzIDogIURFU0NSSVBUT1JTICYmIFIgaW5zdGFuY2VvZiBSZWdFeHAgPyAkZmxhZ3MuY2FsbChSKSA6IHVuZGVmaW5lZCk7XG4gIH0pO1xuLy8gRkY0NC0gUmVnRXhwI3RvU3RyaW5nIGhhcyBhIHdyb25nIG5hbWVcbn0gZWxzZSBpZigkdG9TdHJpbmcubmFtZSAhPSBUT19TVFJJTkcpe1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gJHRvU3RyaW5nLmNhbGwodGhpcyk7XG4gIH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAudG8tc3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3MoKVxuaWYocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAvLi9nLmZsYWdzICE9ICdnJylyZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKFJlZ0V4cC5wcm90b3R5cGUsICdmbGFncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IHJlcXVpcmUoJy4vX2ZsYWdzJylcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuZmxhZ3MuanNcbi8vIG1vZHVsZSBpZCA9IDI3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBAQG1hdGNoIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ21hdGNoJywgMSwgZnVuY3Rpb24oZGVmaW5lZCwgTUFUQ0gsICRtYXRjaCl7XG4gIC8vIDIxLjEuMy4xMSBTdHJpbmcucHJvdG90eXBlLm1hdGNoKHJlZ2V4cClcbiAgcmV0dXJuIFtmdW5jdGlvbiBtYXRjaChyZWdleHApe1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyAgPSBkZWZpbmVkKHRoaXMpXG4gICAgICAsIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtNQVRDSF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbTUFUQ0hdKFN0cmluZyhPKSk7XG4gIH0sICRtYXRjaF07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLm1hdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGhpZGUgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgZmFpbHMgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgZGVmaW5lZCAgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCB3a3MgICAgICA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSwgbGVuZ3RoLCBleGVjKXtcbiAgdmFyIFNZTUJPTCAgID0gd2tzKEtFWSlcbiAgICAsIGZucyAgICAgID0gZXhlYyhkZWZpbmVkLCBTWU1CT0wsICcnW0tFWV0pXG4gICAgLCBzdHJmbiAgICA9IGZuc1swXVxuICAgICwgcnhmbiAgICAgPSBmbnNbMV07XG4gIGlmKGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgdmFyIE8gPSB7fTtcbiAgICBPW1NZTUJPTF0gPSBmdW5jdGlvbigpeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KSl7XG4gICAgcmVkZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgS0VZLCBzdHJmbik7XG4gICAgaGlkZShSZWdFeHAucHJvdG90eXBlLCBTWU1CT0wsIGxlbmd0aCA9PSAyXG4gICAgICAvLyAyMS4yLjUuOCBSZWdFeHAucHJvdG90eXBlW0BAcmVwbGFjZV0oc3RyaW5nLCByZXBsYWNlVmFsdWUpXG4gICAgICAvLyAyMS4yLjUuMTEgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XShzdHJpbmcsIGxpbWl0KVxuICAgICAgPyBmdW5jdGlvbihzdHJpbmcsIGFyZyl7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzLCBhcmcpOyB9XG4gICAgICAvLyAyMS4yLjUuNiBSZWdFeHAucHJvdG90eXBlW0BAbWF0Y2hdKHN0cmluZylcbiAgICAgIC8vIDIxLjIuNS45IFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdKHN0cmluZylcbiAgICAgIDogZnVuY3Rpb24oc3RyaW5nKXsgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMpOyB9XG4gICAgKTtcbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qc1xuLy8gbW9kdWxlIGlkID0gMjc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIEBAcmVwbGFjZSBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdyZXBsYWNlJywgMiwgZnVuY3Rpb24oZGVmaW5lZCwgUkVQTEFDRSwgJHJlcGxhY2Upe1xuICAvLyAyMS4xLjMuMTQgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpXG4gIHJldHVybiBbZnVuY3Rpb24gcmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKXtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gID0gZGVmaW5lZCh0aGlzKVxuICAgICAgLCBmbiA9IHNlYXJjaFZhbHVlID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlYXJjaFZhbHVlW1JFUExBQ0VdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGZuLmNhbGwoc2VhcmNoVmFsdWUsIE8sIHJlcGxhY2VWYWx1ZSlcbiAgICAgIDogJHJlcGxhY2UuY2FsbChTdHJpbmcoTyksIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICB9LCAkcmVwbGFjZV07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UuanNcbi8vIG1vZHVsZSBpZCA9IDI3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBAQHNlYXJjaCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzZWFyY2gnLCAxLCBmdW5jdGlvbihkZWZpbmVkLCBTRUFSQ0gsICRzZWFyY2gpe1xuICAvLyAyMS4xLjMuMTUgU3RyaW5nLnByb3RvdHlwZS5zZWFyY2gocmVnZXhwKVxuICByZXR1cm4gW2Z1bmN0aW9uIHNlYXJjaChyZWdleHApe1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyAgPSBkZWZpbmVkKHRoaXMpXG4gICAgICAsIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtTRUFSQ0hdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW1NFQVJDSF0oU3RyaW5nKE8pKTtcbiAgfSwgJHNlYXJjaF07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaC5qc1xuLy8gbW9kdWxlIGlkID0gMjc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIEBAc3BsaXQgbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnc3BsaXQnLCAyLCBmdW5jdGlvbihkZWZpbmVkLCBTUExJVCwgJHNwbGl0KXtcbiAgJ3VzZSBzdHJpY3QnO1xuICB2YXIgaXNSZWdFeHAgICA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpXG4gICAgLCBfc3BsaXQgICAgID0gJHNwbGl0XG4gICAgLCAkcHVzaCAgICAgID0gW10ucHVzaFxuICAgICwgJFNQTElUICAgICA9ICdzcGxpdCdcbiAgICAsIExFTkdUSCAgICAgPSAnbGVuZ3RoJ1xuICAgICwgTEFTVF9JTkRFWCA9ICdsYXN0SW5kZXgnO1xuICBpZihcbiAgICAnYWJiYydbJFNQTElUXSgvKGIpKi8pWzFdID09ICdjJyB8fFxuICAgICd0ZXN0J1skU1BMSVRdKC8oPzopLywgLTEpW0xFTkdUSF0gIT0gNCB8fFxuICAgICdhYidbJFNQTElUXSgvKD86YWIpKi8pW0xFTkdUSF0gIT0gMiB8fFxuICAgICcuJ1skU1BMSVRdKC8oLj8pKC4/KS8pW0xFTkdUSF0gIT0gNCB8fFxuICAgICcuJ1skU1BMSVRdKC8oKSgpLylbTEVOR1RIXSA+IDEgfHxcbiAgICAnJ1skU1BMSVRdKC8uPy8pW0xFTkdUSF1cbiAgKXtcbiAgICB2YXIgTlBDRyA9IC8oKT8/Ly5leGVjKCcnKVsxXSA9PT0gdW5kZWZpbmVkOyAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cFxuICAgIC8vIGJhc2VkIG9uIGVzNS1zaGltIGltcGxlbWVudGF0aW9uLCBuZWVkIHRvIHJld29yayBpdFxuICAgICRzcGxpdCA9IGZ1bmN0aW9uKHNlcGFyYXRvciwgbGltaXQpe1xuICAgICAgdmFyIHN0cmluZyA9IFN0cmluZyh0aGlzKTtcbiAgICAgIGlmKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwKXJldHVybiBbXTtcbiAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICBpZighaXNSZWdFeHAoc2VwYXJhdG9yKSlyZXR1cm4gX3NwbGl0LmNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIHZhciBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyAneScgOiAnJyk7XG4gICAgICB2YXIgbGFzdExhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgc3BsaXRMaW1pdCA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyA0Mjk0OTY3Mjk1IDogbGltaXQgPj4+IDA7XG4gICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgdmFyIHNlcGFyYXRvckNvcHkgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgIHZhciBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoLCBpO1xuICAgICAgLy8gRG9lc24ndCBuZWVkIGZsYWdzIGd5LCBidXQgdGhleSBkb24ndCBodXJ0XG4gICAgICBpZighTlBDRylzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cCgnXicgKyBzZXBhcmF0b3JDb3B5LnNvdXJjZSArICckKD8hXFxcXHMpJywgZmxhZ3MpO1xuICAgICAgd2hpbGUobWF0Y2ggPSBzZXBhcmF0b3JDb3B5LmV4ZWMoc3RyaW5nKSl7XG4gICAgICAgIC8vIGBzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXVtMRU5HVEhdO1xuICAgICAgICBpZihsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KXtcbiAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYCBmb3IgTlBDR1xuICAgICAgICAgIGlmKCFOUENHICYmIG1hdGNoW0xFTkdUSF0gPiAxKW1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGZvcihpID0gMTsgaSA8IGFyZ3VtZW50c1tMRU5HVEhdIC0gMjsgaSsrKWlmKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWZpbmVkKW1hdGNoW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmKG1hdGNoW0xFTkdUSF0gPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nW0xFTkdUSF0pJHB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdW0xFTkdUSF07XG4gICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICBpZihvdXRwdXRbTEVOR1RIXSA+PSBzcGxpdExpbWl0KWJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmKHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0gPT09IG1hdGNoLmluZGV4KXNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0rKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgfVxuICAgICAgaWYobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nW0xFTkdUSF0pe1xuICAgICAgICBpZihsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3JDb3B5LnRlc3QoJycpKW91dHB1dC5wdXNoKCcnKTtcbiAgICAgIH0gZWxzZSBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgICAgcmV0dXJuIG91dHB1dFtMRU5HVEhdID4gc3BsaXRMaW1pdCA/IG91dHB1dC5zbGljZSgwLCBzcGxpdExpbWl0KSA6IG91dHB1dDtcbiAgICB9O1xuICAvLyBDaGFrcmEsIFY4XG4gIH0gZWxzZSBpZignMCdbJFNQTElUXSh1bmRlZmluZWQsIDApW0xFTkdUSF0pe1xuICAgICRzcGxpdCA9IGZ1bmN0aW9uKHNlcGFyYXRvciwgbGltaXQpe1xuICAgICAgcmV0dXJuIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwID8gW10gOiBfc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9O1xuICB9XG4gIC8vIDIxLjEuMy4xNyBTdHJpbmcucHJvdG90eXBlLnNwbGl0KHNlcGFyYXRvciwgbGltaXQpXG4gIHJldHVybiBbZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCl7XG4gICAgdmFyIE8gID0gZGVmaW5lZCh0aGlzKVxuICAgICAgLCBmbiA9IHNlcGFyYXRvciA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZXBhcmF0b3JbU1BMSVRdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChzZXBhcmF0b3IsIE8sIGxpbWl0KSA6ICRzcGxpdC5jYWxsKFN0cmluZyhPKSwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gIH0sICRzcGxpdF07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNwbGl0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY3R4ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBjbGFzc29mICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCAkZXhwb3J0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGlzT2JqZWN0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5JbnN0YW5jZSAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGZvck9mICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICwgdGFzayAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldFxuICAsIG1pY3JvdGFzayAgICAgICAgICA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKClcbiAgLCBQUk9NSVNFICAgICAgICAgICAgPSAnUHJvbWlzZSdcbiAgLCBUeXBlRXJyb3IgICAgICAgICAgPSBnbG9iYWwuVHlwZUVycm9yXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCAkUHJvbWlzZSAgICAgICAgICAgPSBnbG9iYWxbUFJPTUlTRV1cbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIGlzTm9kZSAgICAgICAgICAgICA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnXG4gICwgZW1wdHkgICAgICAgICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIEludGVybmFsLCBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlICAgICA9ICRQcm9taXNlLnJlc29sdmUoMSlcbiAgICAgICwgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uKGV4ZWMpeyBleGVjKGVtcHR5LCBlbXB0eSk7IH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJykgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBzYW1lQ29uc3RydWN0b3IgPSBmdW5jdGlvbihhLCBiKXtcbiAgLy8gd2l0aCBsaWJyYXJ5IHdyYXBwZXIgc3BlY2lhbCBjYXNlXG4gIHJldHVybiBhID09PSBiIHx8IGEgPT09ICRQcm9taXNlICYmIGIgPT09IFdyYXBwZXI7XG59O1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHJldHVybiBzYW1lQ29uc3RydWN0b3IoJFByb21pc2UsIEMpXG4gICAgPyBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICA6IG5ldyBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uKCQkcmVzb2x2ZSwgJCRyZWplY3Qpe1xuICAgIGlmKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ICA9IGFGdW5jdGlvbihyZWplY3QpO1xufTtcbnZhciBwZXJmb3JtID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB7ZXJyb3I6IGV9O1xuICB9XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uKHByb21pc2UsIGlzUmVqZWN0KXtcbiAgaWYocHJvbWlzZS5fbilyZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92XG4gICAgICAsIG9rICAgID0gcHJvbWlzZS5fcyA9PSAxXG4gICAgICAsIGkgICAgID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24ocmVhY3Rpb24pe1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbFxuICAgICAgICAsIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlXG4gICAgICAgICwgcmVqZWN0ICA9IHJlYWN0aW9uLnJlamVjdFxuICAgICAgICAsIGRvbWFpbiAgPSByZWFjdGlvbi5kb21haW5cbiAgICAgICAgLCByZXN1bHQsIHRoZW47XG4gICAgICB0cnkge1xuICAgICAgICBpZihoYW5kbGVyKXtcbiAgICAgICAgICBpZighb2spe1xuICAgICAgICAgICAgaWYocHJvbWlzZS5faCA9PSAyKW9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGhhbmRsZXIgPT09IHRydWUpcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZihkb21haW4pZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmKGRvbWFpbilkb21haW4uZXhpdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2Upe1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSl7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSlydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZihpc1JlamVjdCAmJiAhcHJvbWlzZS5faClvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdlxuICAgICAgLCBhYnJ1cHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYoaXNVbmhhbmRsZWQocHJvbWlzZSkpe1xuICAgICAgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgICBpZihpc05vZGUpe1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbil7XG4gICAgICAgICAgaGFuZGxlcih7cHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZX0pO1xuICAgICAgICB9IGVsc2UgaWYoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcil7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmKGFicnVwdCl0aHJvdyBhYnJ1cHQuZXJyb3I7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICBpZihwcm9taXNlLl9oID09IDEpcmV0dXJuIGZhbHNlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9hIHx8IHByb21pc2UuX2NcbiAgICAsIGkgICAgID0gMFxuICAgICwgcmVhY3Rpb247XG4gIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpe1xuICAgIHJlYWN0aW9uID0gY2hhaW5baSsrXTtcbiAgICBpZihyZWFjdGlvbi5mYWlsIHx8ICFpc1VuaGFuZGxlZChyZWFjdGlvbi5wcm9taXNlKSlyZXR1cm4gZmFsc2U7XG4gIH0gcmV0dXJuIHRydWU7XG59O1xudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYoaXNOb2RlKXtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZihoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCl7XG4gICAgICBoYW5kbGVyKHtwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHByb21pc2UuX3Z9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmKHByb21pc2UuX2QpcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmKCFwcm9taXNlLl9hKXByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciBwcm9taXNlID0gdGhpc1xuICAgICwgdGhlbjtcbiAgaWYocHJvbWlzZS5fZClyZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZihwcm9taXNlID09PSB2YWx1ZSl0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZih0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpe1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB3cmFwcGVyID0ge193OiBwcm9taXNlLCBfZDogZmFsc2V9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2goZSl7XG4gICAgJHJlamVjdC5jYWxsKHtfdzogcHJvbWlzZSwgX2Q6IGZhbHNlfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmKCFVU0VfTkFUSVZFKXtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaChlcnIpe1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpKCRQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCl7XG4gICAgICB2YXIgcmVhY3Rpb24gICAgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rICAgICA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCAgID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fYSl0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fcylub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpe1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcHJvbWlzZSAgPSBuZXcgSW50ZXJuYWw7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ICA9IGN0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1Byb21pc2U6ICRQcm9taXNlfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpe1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZWplY3QgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCl7XG4gICAgLy8gaW5zdGFuY2VvZiBpbnN0ZWFkIG9mIGludGVybmFsIHNsb3QgY2hlY2sgYmVjYXVzZSB3ZSBzaG91bGQgZml4IGl0IHdpdGhvdXQgcmVwbGFjZW1lbnQgbmF0aXZlIFByb21pc2UgY29yZVxuICAgIGlmKHggaW5zdGFuY2VvZiAkUHJvbWlzZSAmJiBzYW1lQ29uc3RydWN0b3IoeC5jb25zdHJ1Y3RvciwgdGhpcykpcmV0dXJuIHg7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlc29sdmUgID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgICQkcmVzb2x2ZSh4KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IHRoaXNcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlc29sdmUgICAgPSBjYXBhYmlsaXR5LnJlc29sdmVcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdmFsdWVzICAgID0gW11cbiAgICAgICAgLCBpbmRleCAgICAgPSAwXG4gICAgICAgICwgcmVtYWluaW5nID0gMTtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIHZhciAkaW5kZXggICAgICAgID0gaW5kZXgrK1xuICAgICAgICAgICwgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIGlmKGFscmVhZHlDYWxsZWQpcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpe1xuICAgIHZhciBDICAgICAgICAgID0gdGhpc1xuICAgICAgLCBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnByb21pc2UuanNcbi8vIG1vZHVsZSBpZCA9IDI3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpe1xuICBpZighKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSl7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19hbi1pbnN0YW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMjgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjdHggICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgY2FsbCAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICwgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBnZXRJdGVyRm4gICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJylcbiAgLCBCUkVBSyAgICAgICA9IHt9XG4gICwgUkVUVVJOICAgICAgPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKXtcbiAgdmFyIGl0ZXJGbiA9IElURVJBVE9SID8gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKVxuICAgICwgZiAgICAgID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmKGlzQXJyYXlJdGVyKGl0ZXJGbikpZm9yKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKXtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTilyZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7ICl7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTilyZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyAgPSBCUkVBSztcbmV4cG9ydHMuUkVUVVJOID0gUkVUVVJOO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19mb3Itb2YuanNcbi8vIG1vZHVsZSBpZCA9IDI4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcbnZhciBhbk9iamVjdCAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIFNQRUNJRVMgICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE8sIEQpe1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yLCBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGN0eCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgaW52b2tlICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBodG1sICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19odG1sJylcbiAgLCBjZWwgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgc2V0VGFzayAgICAgICAgICAgID0gZ2xvYmFsLnNldEltbWVkaWF0ZVxuICAsIGNsZWFyVGFzayAgICAgICAgICA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZVxuICAsIE1lc3NhZ2VDaGFubmVsICAgICA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbFxuICAsIGNvdW50ZXIgICAgICAgICAgICA9IDBcbiAgLCBxdWV1ZSAgICAgICAgICAgICAgPSB7fVxuICAsIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnXG4gICwgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIGlmKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSl7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYoIXNldFRhc2sgfHwgIWNsZWFyVGFzayl7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pe1xuICAgIHZhciBhcmdzID0gW10sIGkgPSAxO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uKCl7XG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpe1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZihyZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcycpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmKE1lc3NhZ2VDaGFubmVsKXtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsO1xuICAgIHBvcnQgICAgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZihPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbigpe1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogICBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL190YXNrLmpzXG4vLyBtb2R1bGUgaWQgPSAyODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgbWFjcm90YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldFxuICAsIE9ic2VydmVyICA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyXG4gICwgcHJvY2VzcyAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBQcm9taXNlICAgPSBnbG9iYWwuUHJvbWlzZVxuICAsIGlzTm9kZSAgICA9IHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpe1xuICB2YXIgaGVhZCwgbGFzdCwgbm90aWZ5O1xuXG4gIHZhciBmbHVzaCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYoaXNOb2RlICYmIChwYXJlbnQgPSBwcm9jZXNzLmRvbWFpbikpcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZShoZWFkKXtcbiAgICAgIGZuICAgPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoKGUpe1xuICAgICAgICBpZihoZWFkKW5vdGlmeSgpO1xuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmKHBhcmVudClwYXJlbnQuZW50ZXIoKTtcbiAgfTtcblxuICAvLyBOb2RlLmpzXG4gIGlmKGlzTm9kZSl7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlclxuICB9IGVsc2UgaWYoT2JzZXJ2ZXIpe1xuICAgIHZhciB0b2dnbGUgPSB0cnVlXG4gICAgICAsIG5vZGUgICA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBuZXcgT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwge2NoYXJhY3RlckRhdGE6IHRydWV9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpe1xuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIHByb21pc2UudGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuY2FsbChnbG9iYWwpXG4gICAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGZuKXtcbiAgICB2YXIgdGFzayA9IHtmbjogZm4sIG5leHQ6IHVuZGVmaW5lZH07XG4gICAgaWYobGFzdClsYXN0Lm5leHQgPSB0YXNrO1xuICAgIGlmKCFoZWFkKXtcbiAgICAgIGhlYWQgPSB0YXNrO1xuICAgICAgbm90aWZ5KCk7XG4gICAgfSBsYXN0ID0gdGFzaztcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX21pY3JvdGFzay5qc1xuLy8gbW9kdWxlIGlkID0gMjg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldCwgc3JjLCBzYWZlKXtcbiAgZm9yKHZhciBrZXkgaW4gc3JjKXJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgc2FmZSk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS1hbGwuanNcbi8vIG1vZHVsZSBpZCA9IDI4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gMjMuMSBNYXAgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoJ01hcCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBNYXAoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KXtcbiAgICB2YXIgZW50cnkgPSBzdHJvbmcuZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudjtcbiAgfSxcbiAgLy8gMjMuMS4zLjkgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSl7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodGhpcywga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcsIHRydWUpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXAuanNcbi8vIG1vZHVsZSBpZCA9IDI4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgZFAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgY3JlYXRlICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgY3R4ICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGFuSW5zdGFuY2UgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGRlZmluZWQgICAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgZm9yT2YgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsICRpdGVyRGVmaW5lID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKVxuICAsIHN0ZXAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJylcbiAgLCBzZXRTcGVjaWVzICA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBmYXN0S2V5ICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5mYXN0S2V5XG4gICwgU0laRSAgICAgICAgPSBERVNDUklQVE9SUyA/ICdfcycgOiAnc2l6ZSc7XG5cbnZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uKHRoYXQsIGtleSl7XG4gIC8vIGZhc3QgY2FzZVxuICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSksIGVudHJ5O1xuICBpZihpbmRleCAhPT0gJ0YnKXJldHVybiB0aGF0Ll9pW2luZGV4XTtcbiAgLy8gZnJvemVuIG9iamVjdCBjYXNlXG4gIGZvcihlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pe1xuICAgIGlmKGVudHJ5LmsgPT0ga2V5KXJldHVybiBlbnRyeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKXtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24odGhhdCwgaXRlcmFibGUpe1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX2kgPSBjcmVhdGUobnVsbCk7IC8vIGluZGV4XG4gICAgICB0aGF0Ll9mID0gdW5kZWZpbmVkOyAgICAvLyBmaXJzdCBlbnRyeVxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgICAgLy8gbGFzdCBlbnRyeVxuICAgICAgdGhhdFtTSVpFXSA9IDA7ICAgICAgICAgLy8gc2l6ZVxuICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG4gICAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpe1xuICAgICAgICBmb3IodmFyIHRoYXQgPSB0aGlzLCBkYXRhID0gdGhhdC5faSwgZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZihlbnRyeS5wKWVudHJ5LnAgPSBlbnRyeS5wLm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5fZiA9IHRoYXQuX2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoYXRbU0laRV0gPSAwO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy4zIE1hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjIuMy40IFNldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIHZhciB0aGF0ICA9IHRoaXNcbiAgICAgICAgICAsIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgICAgaWYoZW50cnkpe1xuICAgICAgICAgIHZhciBuZXh0ID0gZW50cnkublxuICAgICAgICAgICAgLCBwcmV2ID0gZW50cnkucDtcbiAgICAgICAgICBkZWxldGUgdGhhdC5faVtlbnRyeS5pXTtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZihwcmV2KXByZXYubiA9IG5leHQ7XG4gICAgICAgICAgaWYobmV4dCluZXh0LnAgPSBwcmV2O1xuICAgICAgICAgIGlmKHRoYXQuX2YgPT0gZW50cnkpdGhhdC5fZiA9IG5leHQ7XG4gICAgICAgICAgaWYodGhhdC5fbCA9PSBlbnRyeSl0aGF0Ll9sID0gcHJldjtcbiAgICAgICAgICB0aGF0W1NJWkVdLS07XG4gICAgICAgIH0gcmV0dXJuICEhZW50cnk7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMi4zLjYgU2V0LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICAvLyAyMy4xLjMuNSBNYXAucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgICAgIGFuSW5zdGFuY2UodGhpcywgQywgJ2ZvckVhY2gnKTtcbiAgICAgICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDMpXG4gICAgICAgICAgLCBlbnRyeTtcbiAgICAgICAgd2hpbGUoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGlzLl9mKXtcbiAgICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpe1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmKERFU0NSSVBUT1JTKWRQKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIGRlZmluZWQodGhpc1tTSVpFXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24odGhhdCwga2V5LCB2YWx1ZSl7XG4gICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KVxuICAgICAgLCBwcmV2LCBpbmRleDtcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcbiAgICBpZihlbnRyeSl7XG4gICAgICBlbnRyeS52ID0gdmFsdWU7XG4gICAgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGF0Ll9sID0gZW50cnkgPSB7XG4gICAgICAgIGk6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLCAvLyA8LSBpbmRleFxuICAgICAgICBrOiBrZXksICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0ga2V5XG4gICAgICAgIHY6IHZhbHVlLCAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxuICAgICAgICBwOiBwcmV2ID0gdGhhdC5fbCwgICAgICAgICAgICAgLy8gPC0gcHJldmlvdXMgZW50cnlcbiAgICAgICAgbjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgIC8vIDwtIG5leHQgZW50cnlcbiAgICAgICAgcjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHJlbW92ZWRcbiAgICAgIH07XG4gICAgICBpZighdGhhdC5fZil0aGF0Ll9mID0gZW50cnk7XG4gICAgICBpZihwcmV2KXByZXYubiA9IGVudHJ5O1xuICAgICAgdGhhdFtTSVpFXSsrO1xuICAgICAgLy8gYWRkIHRvIGluZGV4XG4gICAgICBpZihpbmRleCAhPT0gJ0YnKXRoYXQuX2lbaW5kZXhdID0gZW50cnk7XG4gICAgfSByZXR1cm4gdGhhdDtcbiAgfSxcbiAgZ2V0RW50cnk6IGdldEVudHJ5LFxuICBzZXRTdHJvbmc6IGZ1bmN0aW9uKEMsIE5BTUUsIElTX01BUCl7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgICRpdGVyRGVmaW5lKEMsIE5BTUUsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgICAgIHRoaXMuX3QgPSBpdGVyYXRlZDsgIC8vIHRhcmdldFxuICAgICAgdGhpcy5fayA9IGtpbmQ7ICAgICAgLy8ga2luZFxuICAgICAgdGhpcy5fbCA9IHVuZGVmaW5lZDsgLy8gcHJldmlvdXNcbiAgICB9LCBmdW5jdGlvbigpe1xuICAgICAgdmFyIHRoYXQgID0gdGhpc1xuICAgICAgICAsIGtpbmQgID0gdGhhdC5fa1xuICAgICAgICAsIGVudHJ5ID0gdGhhdC5fbDtcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgd2hpbGUoZW50cnkgJiYgZW50cnkucillbnRyeSA9IGVudHJ5LnA7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYoIXRoYXQuX3QgfHwgISh0aGF0Ll9sID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGF0Ll90Ll9mKSl7XG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIHRoYXQuX3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBzdGVwKDEpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBlbnRyeS5rKTtcbiAgICAgIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgZW50cnkudik7XG4gICAgICByZXR1cm4gc3RlcCgwLCBbZW50cnkuaywgZW50cnkudl0pO1xuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnICwgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBhZGQgW0BAc3BlY2llc10sIDIzLjEuMi4yLCAyMy4yLjIuMlxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzXG4vLyBtb2R1bGUgaWQgPSAyODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCAkZXhwb3J0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgcmVkZWZpbmVBbGwgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIG1ldGEgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpXG4gICwgZm9yT2YgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIGFuSW5zdGFuY2UgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGlzT2JqZWN0ICAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBmYWlscyAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCAkaXRlckRldGVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JylcbiAgLCBzZXRUb1N0cmluZ1RhZyAgICA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSyl7XG4gIHZhciBCYXNlICA9IGdsb2JhbFtOQU1FXVxuICAgICwgQyAgICAgPSBCYXNlXG4gICAgLCBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCdcbiAgICAsIHByb3RvID0gQyAmJiBDLnByb3RvdHlwZVxuICAgICwgTyAgICAgPSB7fTtcbiAgdmFyIGZpeE1ldGhvZCA9IGZ1bmN0aW9uKEtFWSl7XG4gICAgdmFyIGZuID0gcHJvdG9bS0VZXTtcbiAgICByZWRlZmluZShwcm90bywgS0VZLFxuICAgICAgS0VZID09ICdkZWxldGUnID8gZnVuY3Rpb24oYSl7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnaGFzJyA/IGZ1bmN0aW9uIGhhcyhhKXtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gZmFsc2UgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdnZXQnID8gZnVuY3Rpb24gZ2V0KGEpe1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyB1bmRlZmluZWQgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdhZGQnID8gZnVuY3Rpb24gYWRkKGEpeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7IHJldHVybiB0aGlzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gc2V0KGEsIGIpeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSwgYik7IHJldHVybiB0aGlzOyB9XG4gICAgKTtcbiAgfTtcbiAgaWYodHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgcHJvdG8uZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgQygpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSl7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICBtZXRhLk5FRUQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBpbnN0YW5jZSAgICAgICAgICAgICA9IG5ldyBDXG4gICAgICAvLyBlYXJseSBpbXBsZW1lbnRhdGlvbnMgbm90IHN1cHBvcnRzIGNoYWluaW5nXG4gICAgICAsIEhBU05UX0NIQUlOSU5HICAgICAgID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZVxuICAgICAgLy8gVjggfiAgQ2hyb21pdW0gNDAtIHdlYWstY29sbGVjdGlvbnMgdGhyb3dzIG9uIHByaW1pdGl2ZXMsIGJ1dCBzaG91bGQgcmV0dXJuIGZhbHNlXG4gICAgICAsIFRIUk9XU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24oKXsgaW5zdGFuY2UuaGFzKDEpOyB9KVxuICAgICAgLy8gbW9zdCBlYXJseSBpbXBsZW1lbnRhdGlvbnMgZG9lc24ndCBzdXBwb3J0cyBpdGVyYWJsZXMsIG1vc3QgbW9kZXJuIC0gbm90IGNsb3NlIGl0IGNvcnJlY3RseVxuICAgICAgLCBBQ0NFUFRfSVRFUkFCTEVTICAgICA9ICRpdGVyRGV0ZWN0KGZ1bmN0aW9uKGl0ZXIpeyBuZXcgQyhpdGVyKTsgfSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxuICAgICAgLCBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gVjggfiBDaHJvbWl1bSA0Mi0gZmFpbHMgb25seSB3aXRoIDUrIGVsZW1lbnRzXG4gICAgICAgIHZhciAkaW5zdGFuY2UgPSBuZXcgQygpXG4gICAgICAgICAgLCBpbmRleCAgICAgPSA1O1xuICAgICAgICB3aGlsZShpbmRleC0tKSRpbnN0YW5jZVtBRERFUl0oaW5kZXgsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuICEkaW5zdGFuY2UuaGFzKC0wKTtcbiAgICAgIH0pO1xuICAgIGlmKCFBQ0NFUFRfSVRFUkFCTEVTKXsgXG4gICAgICBDID0gd3JhcHBlcihmdW5jdGlvbih0YXJnZXQsIGl0ZXJhYmxlKXtcbiAgICAgICAgYW5JbnN0YW5jZSh0YXJnZXQsIEMsIE5BTUUpO1xuICAgICAgICB2YXIgdGhhdCA9IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBCYXNlLCB0YXJnZXQsIEMpO1xuICAgICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICAgIH0pO1xuICAgICAgQy5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgIHByb3RvLmNvbnN0cnVjdG9yID0gQztcbiAgICB9XG4gICAgaWYoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTyl7XG4gICAgICBmaXhNZXRob2QoJ2RlbGV0ZScpO1xuICAgICAgZml4TWV0aG9kKCdoYXMnKTtcbiAgICAgIElTX01BUCAmJiBmaXhNZXRob2QoJ2dldCcpO1xuICAgIH1cbiAgICBpZihCVUdHWV9aRVJPIHx8IEhBU05UX0NIQUlOSU5HKWZpeE1ldGhvZChBRERFUik7XG4gICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcbiAgICBpZihJU19XRUFLICYmIHByb3RvLmNsZWFyKWRlbGV0ZSBwcm90by5jbGVhcjtcbiAgfVxuXG4gIHNldFRvU3RyaW5nVGFnKEMsIE5BTUUpO1xuXG4gIE9bTkFNRV0gPSBDO1xuICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChDICE9IEJhc2UpLCBPKTtcblxuICBpZighSVNfV0VBSyljb21tb24uc2V0U3Ryb25nKEMsIE5BTUUsIElTX01BUCk7XG5cbiAgcmV0dXJuIEM7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKCdTZXQnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpe1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHRoaXMsIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAyODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGVhY2ggICAgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKVxuICAsIHJlZGVmaW5lICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBtZXRhICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJylcbiAgLCBhc3NpZ24gICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJylcbiAgLCB3ZWFrICAgICAgICAgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKVxuICAsIGlzT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZ2V0V2VhayAgICAgID0gbWV0YS5nZXRXZWFrXG4gICwgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZVxuICAsIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSB3ZWFrLnVmc3RvcmVcbiAgLCB0bXAgICAgICAgICAgPSB7fVxuICAsIEludGVybmFsTWFwO1xuXG52YXIgd3JhcHBlciA9IGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrTWFwKCl7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gIH07XG59O1xuXG52YXIgbWV0aG9kcyA9IHtcbiAgLy8gMjMuMy4zLjMgV2Vha01hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KXtcbiAgICBpZihpc09iamVjdChrZXkpKXtcbiAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgaWYoZGF0YSA9PT0gdHJ1ZSlyZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGlzKS5nZXQoa2V5KTtcbiAgICAgIHJldHVybiBkYXRhID8gZGF0YVt0aGlzLl9pXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG4gIC8vIDIzLjMuMy41IFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKXtcbiAgICByZXR1cm4gd2Vhay5kZWYodGhpcywga2V5LCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8vIDIzLjMgV2Vha01hcCBPYmplY3RzXG52YXIgJFdlYWtNYXAgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKSgnV2Vha01hcCcsIHdyYXBwZXIsIG1ldGhvZHMsIHdlYWssIHRydWUsIHRydWUpO1xuXG4vLyBJRTExIFdlYWtNYXAgZnJvemVuIGtleXMgZml4XG5pZihuZXcgJFdlYWtNYXAoKS5zZXQoKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh0bXApLCA3KS5nZXQodG1wKSAhPSA3KXtcbiAgSW50ZXJuYWxNYXAgPSB3ZWFrLmdldENvbnN0cnVjdG9yKHdyYXBwZXIpO1xuICBhc3NpZ24oSW50ZXJuYWxNYXAucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgZWFjaChbJ2RlbGV0ZScsICdoYXMnLCAnZ2V0JywgJ3NldCddLCBmdW5jdGlvbihrZXkpe1xuICAgIHZhciBwcm90byAgPSAkV2Vha01hcC5wcm90b3R5cGVcbiAgICAgICwgbWV0aG9kID0gcHJvdG9ba2V5XTtcbiAgICByZWRlZmluZShwcm90bywga2V5LCBmdW5jdGlvbihhLCBiKXtcbiAgICAgIC8vIHN0b3JlIGZyb3plbiBvYmplY3RzIG9uIGludGVybmFsIHdlYWttYXAgc2hpbVxuICAgICAgaWYoaXNPYmplY3QoYSkgJiYgIWlzRXh0ZW5zaWJsZShhKSl7XG4gICAgICAgIGlmKCF0aGlzLl9mKXRoaXMuX2YgPSBuZXcgSW50ZXJuYWxNYXA7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9mW2tleV0oYSwgYik7XG4gICAgICAgIHJldHVybiBrZXkgPT0gJ3NldCcgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgLy8gc3RvcmUgYWxsIHRoZSByZXN0IG9uIG5hdGl2ZSB3ZWFrbWFwXG4gICAgICB9IHJldHVybiBtZXRob2QuY2FsbCh0aGlzLCBhLCBiKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlZGVmaW5lQWxsICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBnZXRXZWFrICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5nZXRXZWFrXG4gICwgYW5PYmplY3QgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGlzT2JqZWN0ICAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBhbkluc3RhbmNlICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBmb3JPZiAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgY3JlYXRlQXJyYXlNZXRob2QgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJylcbiAgLCAkaGFzICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgYXJyYXlGaW5kICAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCg1KVxuICAsIGFycmF5RmluZEluZGV4ICAgID0gY3JlYXRlQXJyYXlNZXRob2QoNilcbiAgLCBpZCAgICAgICAgICAgICAgICA9IDA7XG5cbi8vIGZhbGxiYWNrIGZvciB1bmNhdWdodCBmcm96ZW4ga2V5c1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbih0aGF0KXtcbiAgcmV0dXJuIHRoYXQuX2wgfHwgKHRoYXQuX2wgPSBuZXcgVW5jYXVnaHRGcm96ZW5TdG9yZSk7XG59O1xudmFyIFVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbigpe1xuICB0aGlzLmEgPSBbXTtcbn07XG52YXIgZmluZFVuY2F1Z2h0RnJvemVuID0gZnVuY3Rpb24oc3RvcmUsIGtleSl7XG4gIHJldHVybiBhcnJheUZpbmQoc3RvcmUuYSwgZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICB9KTtcbn07XG5VbmNhdWdodEZyb3plblN0b3JlLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbihrZXkpe1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmKGVudHJ5KXJldHVybiBlbnRyeVsxXTtcbiAgfSxcbiAgaGFzOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmKGVudHJ5KWVudHJ5WzFdID0gdmFsdWU7XG4gICAgZWxzZSB0aGlzLmEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9LFxuICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICB2YXIgaW5kZXggPSBhcnJheUZpbmRJbmRleCh0aGlzLmEsIGZ1bmN0aW9uKGl0KXtcbiAgICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICAgIH0pO1xuICAgIGlmKH5pbmRleCl0aGlzLmEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gISF+aW5kZXg7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24od3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUil7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGl0ZXJhYmxlKXtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll9pID0gaWQrKzsgICAgICAvLyBjb2xsZWN0aW9uIGlkXG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAvLyBsZWFrIHN0b3JlIGZvciB1bmNhdWdodCBmcm96ZW4gb2JqZWN0c1xuICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMy4zLjIgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjQuMy4zIFdlYWtTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgICBpZighaXNPYmplY3Qoa2V5KSlyZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZihkYXRhID09PSB0cnVlKXJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHRoaXMpWydkZWxldGUnXShrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpICYmIGRlbGV0ZSBkYXRhW3RoaXMuX2ldO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjMuMy40IFdlYWtNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy40LjMuNCBXZWFrU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpe1xuICAgICAgICBpZighaXNPYmplY3Qoa2V5KSlyZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZihkYXRhID09PSB0cnVlKXJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHRoaXMpLmhhcyhrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uKHRoYXQsIGtleSwgdmFsdWUpe1xuICAgIHZhciBkYXRhID0gZ2V0V2Vhayhhbk9iamVjdChrZXkpLCB0cnVlKTtcbiAgICBpZihkYXRhID09PSB0cnVlKXVuY2F1Z2h0RnJvemVuU3RvcmUodGhhdCkuc2V0KGtleSwgdmFsdWUpO1xuICAgIGVsc2UgZGF0YVt0aGF0Ll9pXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGF0O1xuICB9LFxuICB1ZnN0b3JlOiB1bmNhdWdodEZyb3plblN0b3JlXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXdlYWsuanNcbi8vIG1vZHVsZSBpZCA9IDI5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgd2VhayA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24td2VhaycpO1xuXG4vLyAyMy40IFdlYWtTZXQgT2JqZWN0c1xucmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKCdXZWFrU2V0JywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtTZXQoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjQuMy4xIFdlYWtTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpe1xuICAgIHJldHVybiB3ZWFrLmRlZih0aGlzLCB2YWx1ZSwgdHJ1ZSk7XG4gIH1cbn0sIHdlYWssIGZhbHNlLCB0cnVlKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1zZXQuanNcbi8vIG1vZHVsZSBpZCA9IDI5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkdHlwZWQgICAgICAgPSByZXF1aXJlKCcuL190eXBlZCcpXG4gICwgYnVmZmVyICAgICAgID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJylcbiAgLCBhbk9iamVjdCAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvSW5kZXggICAgICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4JylcbiAgLCB0b0xlbmd0aCAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGlzT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgQXJyYXlCdWZmZXIgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuQXJyYXlCdWZmZXJcbiAgLCBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJylcbiAgLCAkQXJyYXlCdWZmZXIgPSBidWZmZXIuQXJyYXlCdWZmZXJcbiAgLCAkRGF0YVZpZXcgICAgPSBidWZmZXIuRGF0YVZpZXdcbiAgLCAkaXNWaWV3ICAgICAgPSAkdHlwZWQuQUJWICYmIEFycmF5QnVmZmVyLmlzVmlld1xuICAsICRzbGljZSAgICAgICA9ICRBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2VcbiAgLCBWSUVXICAgICAgICAgPSAkdHlwZWQuVklFV1xuICAsIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEFycmF5QnVmZmVyICE9PSAkQXJyYXlCdWZmZXIpLCB7QXJyYXlCdWZmZXI6ICRBcnJheUJ1ZmZlcn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEkdHlwZWQuQ09OU1RSLCBBUlJBWV9CVUZGRVIsIHtcbiAgLy8gMjQuMS4zLjEgQXJyYXlCdWZmZXIuaXNWaWV3KGFyZylcbiAgaXNWaWV3OiBmdW5jdGlvbiBpc1ZpZXcoaXQpe1xuICAgIHJldHVybiAkaXNWaWV3ICYmICRpc1ZpZXcoaXQpIHx8IGlzT2JqZWN0KGl0KSAmJiBWSUVXIGluIGl0O1xuICB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlUgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiAhbmV3ICRBcnJheUJ1ZmZlcigyKS5zbGljZSgxLCB1bmRlZmluZWQpLmJ5dGVMZW5ndGg7XG59KSwgQVJSQVlfQlVGRkVSLCB7XG4gIC8vIDI0LjEuNC4zIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZShzdGFydCwgZW5kKVxuICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCl7XG4gICAgaWYoJHNsaWNlICE9PSB1bmRlZmluZWQgJiYgZW5kID09PSB1bmRlZmluZWQpcmV0dXJuICRzbGljZS5jYWxsKGFuT2JqZWN0KHRoaXMpLCBzdGFydCk7IC8vIEZGIGZpeFxuICAgIHZhciBsZW4gICAgPSBhbk9iamVjdCh0aGlzKS5ieXRlTGVuZ3RoXG4gICAgICAsIGZpcnN0ICA9IHRvSW5kZXgoc3RhcnQsIGxlbilcbiAgICAgICwgZmluYWwgID0gdG9JbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IGVuZCwgbGVuKVxuICAgICAgLCByZXN1bHQgPSBuZXcgKHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkQXJyYXlCdWZmZXIpKSh0b0xlbmd0aChmaW5hbCAtIGZpcnN0KSlcbiAgICAgICwgdmlld1MgID0gbmV3ICREYXRhVmlldyh0aGlzKVxuICAgICAgLCB2aWV3VCAgPSBuZXcgJERhdGFWaWV3KHJlc3VsdClcbiAgICAgICwgaW5kZXggID0gMDtcbiAgICB3aGlsZShmaXJzdCA8IGZpbmFsKXtcbiAgICAgIHZpZXdULnNldFVpbnQ4KGluZGV4KyssIHZpZXdTLmdldFVpbnQ4KGZpcnN0KyspKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKEFSUkFZX0JVRkZFUik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gMjkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgVFlQRUQgID0gdWlkKCd0eXBlZF9hcnJheScpXG4gICwgVklFVyAgID0gdWlkKCd2aWV3JylcbiAgLCBBQlYgICAgPSAhIShnbG9iYWwuQXJyYXlCdWZmZXIgJiYgZ2xvYmFsLkRhdGFWaWV3KVxuICAsIENPTlNUUiA9IEFCVlxuICAsIGkgPSAwLCBsID0gOSwgVHlwZWQ7XG5cbnZhciBUeXBlZEFycmF5Q29uc3RydWN0b3JzID0gKFxuICAnSW50OEFycmF5LFVpbnQ4QXJyYXksVWludDhDbGFtcGVkQXJyYXksSW50MTZBcnJheSxVaW50MTZBcnJheSxJbnQzMkFycmF5LFVpbnQzMkFycmF5LEZsb2F0MzJBcnJheSxGbG9hdDY0QXJyYXknXG4pLnNwbGl0KCcsJyk7XG5cbndoaWxlKGkgPCBsKXtcbiAgaWYoVHlwZWQgPSBnbG9iYWxbVHlwZWRBcnJheUNvbnN0cnVjdG9yc1tpKytdXSl7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFRZUEVELCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkLnByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gIH0gZWxzZSBDT05TVFIgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFCVjogICAgQUJWLFxuICBDT05TVFI6IENPTlNUUixcbiAgVFlQRUQ6ICBUWVBFRCxcbiAgVklFVzogICBWSUVXXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL190eXBlZC5qc1xuLy8gbW9kdWxlIGlkID0gMjk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCAkdHlwZWQgICAgICAgICA9IHJlcXVpcmUoJy4vX3R5cGVkJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIHJlZGVmaW5lQWxsICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBmYWlscyAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBhbkluc3RhbmNlICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCB0b0ludGVnZXIgICAgICA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIHRvTGVuZ3RoICAgICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBnT1BOICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZlxuICAsIGRQICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGFycmF5RmlsbCAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgQVJSQVlfQlVGRkVSICAgPSAnQXJyYXlCdWZmZXInXG4gICwgREFUQV9WSUVXICAgICAgPSAnRGF0YVZpZXcnXG4gICwgUFJPVE9UWVBFICAgICAgPSAncHJvdG90eXBlJ1xuICAsIFdST05HX0xFTkdUSCAgID0gJ1dyb25nIGxlbmd0aCEnXG4gICwgV1JPTkdfSU5ERVggICAgPSAnV3JvbmcgaW5kZXghJ1xuICAsICRBcnJheUJ1ZmZlciAgID0gZ2xvYmFsW0FSUkFZX0JVRkZFUl1cbiAgLCAkRGF0YVZpZXcgICAgICA9IGdsb2JhbFtEQVRBX1ZJRVddXG4gICwgTWF0aCAgICAgICAgICAgPSBnbG9iYWwuTWF0aFxuICAsIFJhbmdlRXJyb3IgICAgID0gZ2xvYmFsLlJhbmdlRXJyb3JcbiAgLCBJbmZpbml0eSAgICAgICA9IGdsb2JhbC5JbmZpbml0eVxuICAsIEJhc2VCdWZmZXIgICAgID0gJEFycmF5QnVmZmVyXG4gICwgYWJzICAgICAgICAgICAgPSBNYXRoLmFic1xuICAsIHBvdyAgICAgICAgICAgID0gTWF0aC5wb3dcbiAgLCBmbG9vciAgICAgICAgICA9IE1hdGguZmxvb3JcbiAgLCBsb2cgICAgICAgICAgICA9IE1hdGgubG9nXG4gICwgTE4yICAgICAgICAgICAgPSBNYXRoLkxOMlxuICAsIEJVRkZFUiAgICAgICAgID0gJ2J1ZmZlcidcbiAgLCBCWVRFX0xFTkdUSCAgICA9ICdieXRlTGVuZ3RoJ1xuICAsIEJZVEVfT0ZGU0VUICAgID0gJ2J5dGVPZmZzZXQnXG4gICwgJEJVRkZFUiAgICAgICAgPSBERVNDUklQVE9SUyA/ICdfYicgOiBCVUZGRVJcbiAgLCAkTEVOR1RIICAgICAgICA9IERFU0NSSVBUT1JTID8gJ19sJyA6IEJZVEVfTEVOR1RIXG4gICwgJE9GRlNFVCAgICAgICAgPSBERVNDUklQVE9SUyA/ICdfbycgOiBCWVRFX09GRlNFVDtcblxuLy8gSUVFRTc1NCBjb252ZXJzaW9ucyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2llZWU3NTRcbnZhciBwYWNrSUVFRTc1NCA9IGZ1bmN0aW9uKHZhbHVlLCBtTGVuLCBuQnl0ZXMpe1xuICB2YXIgYnVmZmVyID0gQXJyYXkobkJ5dGVzKVxuICAgICwgZUxlbiAgID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gICAgLCBlTWF4ICAgPSAoMSA8PCBlTGVuKSAtIDFcbiAgICAsIGVCaWFzICA9IGVNYXggPj4gMVxuICAgICwgcnQgICAgID0gbUxlbiA9PT0gMjMgPyBwb3coMiwgLTI0KSAtIHBvdygyLCAtNzcpIDogMFxuICAgICwgaSAgICAgID0gMFxuICAgICwgcyAgICAgID0gdmFsdWUgPCAwIHx8IHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDAgPyAxIDogMFxuICAgICwgZSwgbSwgYztcbiAgdmFsdWUgPSBhYnModmFsdWUpXG4gIGlmKHZhbHVlICE9IHZhbHVlIHx8IHZhbHVlID09PSBJbmZpbml0eSl7XG4gICAgbSA9IHZhbHVlICE9IHZhbHVlID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IGZsb29yKGxvZyh2YWx1ZSkgLyBMTjIpO1xuICAgIGlmKHZhbHVlICogKGMgPSBwb3coMiwgLWUpKSA8IDEpe1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZihlICsgZUJpYXMgPj0gMSl7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogcG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmKHZhbHVlICogYyA+PSAyKXtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG4gICAgaWYoZSArIGVCaWFzID49IGVNYXgpe1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYoZSArIGVCaWFzID49IDEpe1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIHBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIHBvdygyLCBlQmlhcyAtIDEpICogcG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG4gIGZvcig7IG1MZW4gPj0gODsgYnVmZmVyW2krK10gPSBtICYgMjU1LCBtIC89IDI1NiwgbUxlbiAtPSA4KTtcbiAgZSA9IGUgPDwgbUxlbiB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yKDsgZUxlbiA+IDA7IGJ1ZmZlcltpKytdID0gZSAmIDI1NSwgZSAvPSAyNTYsIGVMZW4gLT0gOCk7XG4gIGJ1ZmZlclstLWldIHw9IHMgKiAxMjg7XG4gIHJldHVybiBidWZmZXI7XG59O1xudmFyIHVucGFja0lFRUU3NTQgPSBmdW5jdGlvbihidWZmZXIsIG1MZW4sIG5CeXRlcyl7XG4gIHZhciBlTGVuICA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICAgICwgZU1heCAgPSAoMSA8PCBlTGVuKSAtIDFcbiAgICAsIGVCaWFzID0gZU1heCA+PiAxXG4gICAgLCBuQml0cyA9IGVMZW4gLSA3XG4gICAgLCBpICAgICA9IG5CeXRlcyAtIDFcbiAgICAsIHMgICAgID0gYnVmZmVyW2ktLV1cbiAgICAsIGUgICAgID0gcyAmIDEyN1xuICAgICwgbTtcbiAgcyA+Pj0gNztcbiAgZm9yKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltpXSwgaS0tLCBuQml0cyAtPSA4KTtcbiAgbSA9IGUgJiAoMSA8PCAtbkJpdHMpIC0gMTtcbiAgZSA+Pj0gLW5CaXRzO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW2ldLCBpLS0sIG5CaXRzIC09IDgpO1xuICBpZihlID09PSAwKXtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYoZSA9PT0gZU1heCl7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiBzID8gLUluZmluaXR5IDogSW5maW5pdHk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBwb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfSByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIHBvdygyLCBlIC0gbUxlbik7XG59O1xuXG52YXIgdW5wYWNrSTMyID0gZnVuY3Rpb24oYnl0ZXMpe1xuICByZXR1cm4gYnl0ZXNbM10gPDwgMjQgfCBieXRlc1syXSA8PCAxNiB8IGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbn07XG52YXIgcGFja0k4ID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gW2l0ICYgMHhmZl07XG59O1xudmFyIHBhY2tJMTYgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBbaXQgJiAweGZmLCBpdCA+PiA4ICYgMHhmZl07XG59O1xudmFyIHBhY2tJMzIgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBbaXQgJiAweGZmLCBpdCA+PiA4ICYgMHhmZiwgaXQgPj4gMTYgJiAweGZmLCBpdCA+PiAyNCAmIDB4ZmZdO1xufTtcbnZhciBwYWNrRjY0ID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDUyLCA4KTtcbn07XG52YXIgcGFja0YzMiA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KGl0LCAyMywgNCk7XG59O1xuXG52YXIgYWRkR2V0dGVyID0gZnVuY3Rpb24oQywga2V5LCBpbnRlcm5hbCl7XG4gIGRQKENbUFJPVE9UWVBFXSwga2V5LCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpc1tpbnRlcm5hbF07IH19KTtcbn07XG5cbnZhciBnZXQgPSBmdW5jdGlvbih2aWV3LCBieXRlcywgaW5kZXgsIGlzTGl0dGxlRW5kaWFuKXtcbiAgdmFyIG51bUluZGV4ID0gK2luZGV4XG4gICAgLCBpbnRJbmRleCA9IHRvSW50ZWdlcihudW1JbmRleCk7XG4gIGlmKG51bUluZGV4ICE9IGludEluZGV4IHx8IGludEluZGV4IDwgMCB8fCBpbnRJbmRleCArIGJ5dGVzID4gdmlld1skTEVOR1RIXSl0aHJvdyBSYW5nZUVycm9yKFdST05HX0lOREVYKTtcbiAgdmFyIHN0b3JlID0gdmlld1skQlVGRkVSXS5fYlxuICAgICwgc3RhcnQgPSBpbnRJbmRleCArIHZpZXdbJE9GRlNFVF1cbiAgICAsIHBhY2sgID0gc3RvcmUuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgYnl0ZXMpO1xuICByZXR1cm4gaXNMaXR0bGVFbmRpYW4gPyBwYWNrIDogcGFjay5yZXZlcnNlKCk7XG59O1xudmFyIHNldCA9IGZ1bmN0aW9uKHZpZXcsIGJ5dGVzLCBpbmRleCwgY29udmVyc2lvbiwgdmFsdWUsIGlzTGl0dGxlRW5kaWFuKXtcbiAgdmFyIG51bUluZGV4ID0gK2luZGV4XG4gICAgLCBpbnRJbmRleCA9IHRvSW50ZWdlcihudW1JbmRleCk7XG4gIGlmKG51bUluZGV4ICE9IGludEluZGV4IHx8IGludEluZGV4IDwgMCB8fCBpbnRJbmRleCArIGJ5dGVzID4gdmlld1skTEVOR1RIXSl0aHJvdyBSYW5nZUVycm9yKFdST05HX0lOREVYKTtcbiAgdmFyIHN0b3JlID0gdmlld1skQlVGRkVSXS5fYlxuICAgICwgc3RhcnQgPSBpbnRJbmRleCArIHZpZXdbJE9GRlNFVF1cbiAgICAsIHBhY2sgID0gY29udmVyc2lvbigrdmFsdWUpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYnl0ZXM7IGkrKylzdG9yZVtzdGFydCArIGldID0gcGFja1tpc0xpdHRsZUVuZGlhbiA/IGkgOiBieXRlcyAtIGkgLSAxXTtcbn07XG5cbnZhciB2YWxpZGF0ZUFycmF5QnVmZmVyQXJndW1lbnRzID0gZnVuY3Rpb24odGhhdCwgbGVuZ3RoKXtcbiAgYW5JbnN0YW5jZSh0aGF0LCAkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG4gIHZhciBudW1iZXJMZW5ndGggPSArbGVuZ3RoXG4gICAgLCBieXRlTGVuZ3RoICAgPSB0b0xlbmd0aChudW1iZXJMZW5ndGgpO1xuICBpZihudW1iZXJMZW5ndGggIT0gYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gIHJldHVybiBieXRlTGVuZ3RoO1xufTtcblxuaWYoISR0eXBlZC5BQlYpe1xuICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpe1xuICAgIHZhciBieXRlTGVuZ3RoID0gdmFsaWRhdGVBcnJheUJ1ZmZlckFyZ3VtZW50cyh0aGlzLCBsZW5ndGgpO1xuICAgIHRoaXMuX2IgICAgICAgPSBhcnJheUZpbGwuY2FsbChBcnJheShieXRlTGVuZ3RoKSwgMCk7XG4gICAgdGhpc1skTEVOR1RIXSA9IGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgJERhdGFWaWV3ID0gZnVuY3Rpb24gRGF0YVZpZXcoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKXtcbiAgICBhbkluc3RhbmNlKHRoaXMsICREYXRhVmlldywgREFUQV9WSUVXKTtcbiAgICBhbkluc3RhbmNlKGJ1ZmZlciwgJEFycmF5QnVmZmVyLCBEQVRBX1ZJRVcpO1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBidWZmZXJbJExFTkdUSF1cbiAgICAgICwgb2Zmc2V0ICAgICAgID0gdG9JbnRlZ2VyKGJ5dGVPZmZzZXQpO1xuICAgIGlmKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gYnVmZmVyTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCEnKTtcbiAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gYnVmZmVyTGVuZ3RoIC0gb2Zmc2V0IDogdG9MZW5ndGgoYnl0ZUxlbmd0aCk7XG4gICAgaWYob2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlckxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgdGhpc1skQlVGRkVSXSA9IGJ1ZmZlcjtcbiAgICB0aGlzWyRPRkZTRVRdID0gb2Zmc2V0O1xuICAgIHRoaXNbJExFTkdUSF0gPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gIGlmKERFU0NSSVBUT1JTKXtcbiAgICBhZGRHZXR0ZXIoJEFycmF5QnVmZmVyLCBCWVRFX0xFTkdUSCwgJ19sJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQlVGRkVSLCAnX2InKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCWVRFX0xFTkdUSCwgJ19sJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQllURV9PRkZTRVQsICdfbycpO1xuICB9XG5cbiAgcmVkZWZpbmVBbGwoJERhdGFWaWV3W1BST1RPVFlQRV0sIHtcbiAgICBnZXRJbnQ4OiBmdW5jdGlvbiBnZXRJbnQ4KGJ5dGVPZmZzZXQpe1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXSA8PCAyNCA+PiAyNDtcbiAgICB9LFxuICAgIGdldFVpbnQ4OiBmdW5jdGlvbiBnZXRVaW50OChieXRlT2Zmc2V0KXtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF07XG4gICAgfSxcbiAgICBnZXRJbnQxNjogZnVuY3Rpb24gZ2V0SW50MTYoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pO1xuICAgICAgcmV0dXJuIChieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF0pIDw8IDE2ID4+IDE2O1xuICAgIH0sXG4gICAgZ2V0VWludDE2OiBmdW5jdGlvbiBnZXRVaW50MTYoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pO1xuICAgICAgcmV0dXJuIGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbiAgICB9LFxuICAgIGdldEludDMyOiBmdW5jdGlvbiBnZXRJbnQzMihieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgcmV0dXJuIHVucGFja0kzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSk7XG4gICAgfSxcbiAgICBnZXRVaW50MzI6IGZ1bmN0aW9uIGdldFVpbnQzMihieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgcmV0dXJuIHVucGFja0kzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSkgPj4+IDA7XG4gICAgfSxcbiAgICBnZXRGbG9hdDMyOiBmdW5jdGlvbiBnZXRGbG9hdDMyKGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSwgMjMsIDQpO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQ2NDogZnVuY3Rpb24gZ2V0RmxvYXQ2NChieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSksIDUyLCA4KTtcbiAgICB9LFxuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpe1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJOCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKXtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSTgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldEludDE2OiBmdW5jdGlvbiBzZXRJbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSTE2LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldFVpbnQxNjogZnVuY3Rpb24gc2V0VWludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJMTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0SW50MzI6IGZ1bmN0aW9uIHNldEludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDMyOiBmdW5jdGlvbiBzZXRVaW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0kzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDMyOiBmdW5jdGlvbiBzZXRGbG9hdDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tGMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0RmxvYXQ2NDogZnVuY3Rpb24gc2V0RmxvYXQ2NChieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBwYWNrRjY0LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgaWYoIWZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgbmV3ICRBcnJheUJ1ZmZlcjsgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gIH0pIHx8ICFmYWlscyhmdW5jdGlvbigpe1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoLjUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICB9KSl7XG4gICAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKXtcbiAgICAgIHJldHVybiBuZXcgQmFzZUJ1ZmZlcih2YWxpZGF0ZUFycmF5QnVmZmVyQXJndW1lbnRzKHRoaXMsIGxlbmd0aCkpO1xuICAgIH07XG4gICAgdmFyIEFycmF5QnVmZmVyUHJvdG8gPSAkQXJyYXlCdWZmZXJbUFJPVE9UWVBFXSA9IEJhc2VCdWZmZXJbUFJPVE9UWVBFXTtcbiAgICBmb3IodmFyIGtleXMgPSBnT1BOKEJhc2VCdWZmZXIpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7ICl7XG4gICAgICBpZighKChrZXkgPSBrZXlzW2orK10pIGluICRBcnJheUJ1ZmZlcikpaGlkZSgkQXJyYXlCdWZmZXIsIGtleSwgQmFzZUJ1ZmZlcltrZXldKTtcbiAgICB9O1xuICAgIGlmKCFMSUJSQVJZKUFycmF5QnVmZmVyUHJvdG8uY29uc3RydWN0b3IgPSAkQXJyYXlCdWZmZXI7XG4gIH1cbiAgLy8gaU9TIFNhZmFyaSA3LnggYnVnXG4gIHZhciB2aWV3ID0gbmV3ICREYXRhVmlldyhuZXcgJEFycmF5QnVmZmVyKDIpKVxuICAgICwgJHNldEludDggPSAkRGF0YVZpZXdbUFJPVE9UWVBFXS5zZXRJbnQ4O1xuICB2aWV3LnNldEludDgoMCwgMjE0NzQ4MzY0OCk7XG4gIHZpZXcuc2V0SW50OCgxLCAyMTQ3NDgzNjQ5KTtcbiAgaWYodmlldy5nZXRJbnQ4KDApIHx8ICF2aWV3LmdldEludDgoMSkpcmVkZWZpbmVBbGwoJERhdGFWaWV3W1BST1RPVFlQRV0sIHtcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKXtcbiAgICAgICRzZXRJbnQ4LmNhbGwodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKXtcbiAgICAgICRzZXRJbnQ4LmNhbGwodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH1cbiAgfSwgdHJ1ZSk7XG59XG5zZXRUb1N0cmluZ1RhZygkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG5zZXRUb1N0cmluZ1RhZygkRGF0YVZpZXcsIERBVEFfVklFVyk7XG5oaWRlKCREYXRhVmlld1tQUk9UT1RZUEVdLCAkdHlwZWQuVklFVywgdHJ1ZSk7XG5leHBvcnRzW0FSUkFZX0JVRkZFUl0gPSAkQXJyYXlCdWZmZXI7XG5leHBvcnRzW0RBVEFfVklFV10gPSAkRGF0YVZpZXc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLWJ1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gMjk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL190eXBlZCcpLkFCViwge1xuICBEYXRhVmlldzogcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJykuRGF0YVZpZXdcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5kYXRhLXZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDI5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQ4JywgMSwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDI5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5pZihyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpKXtcbiAgdmFyIExJQlJBUlkgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgICAsIGdsb2JhbCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAgICwgZmFpbHMgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgICAsICRleHBvcnQgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAgICwgJHR5cGVkICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3R5cGVkJylcbiAgICAsICRidWZmZXIgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKVxuICAgICwgY3R4ICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICAgLCBhbkluc3RhbmNlICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAgICwgcHJvcGVydHlEZXNjICAgICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAgICwgaGlkZSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAgICwgcmVkZWZpbmVBbGwgICAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICAgLCB0b0ludGVnZXIgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICAgLCB0b0xlbmd0aCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgICAsIHRvSW5kZXggICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpXG4gICAgLCB0b1ByaW1pdGl2ZSAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgICAsIGhhcyAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAgICwgc2FtZSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3NhbWUtdmFsdWUnKVxuICAgICwgY2xhc3NvZiAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAgICwgaXNPYmplY3QgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICAgLCB0b09iamVjdCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgICAsIGlzQXJyYXlJdGVyICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJylcbiAgICAsIGNyZWF0ZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgICAsIGdldFByb3RvdHlwZU9mICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgICAsIGdPUE4gICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgICAsIGdldEl0ZXJGbiAgICAgICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpXG4gICAgLCB1aWQgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgICAsIHdrcyAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAgICwgY3JlYXRlQXJyYXlNZXRob2QgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKVxuICAgICwgY3JlYXRlQXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJylcbiAgICAsIHNwZWNpZXNDb25zdHJ1Y3RvciAgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJylcbiAgICAsIEFycmF5SXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpXG4gICAgLCBJdGVyYXRvcnMgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgICAsICRpdGVyRGV0ZWN0ICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpXG4gICAgLCBzZXRTcGVjaWVzICAgICAgICAgID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKVxuICAgICwgYXJyYXlGaWxsICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKVxuICAgICwgYXJyYXlDb3B5V2l0aGluICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWNvcHktd2l0aGluJylcbiAgICAsICREUCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAgICwgJEdPUEQgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgICAsIGRQICAgICAgICAgICAgICAgICAgPSAkRFAuZlxuICAgICwgZ09QRCAgICAgICAgICAgICAgICA9ICRHT1BELmZcbiAgICAsIFJhbmdlRXJyb3IgICAgICAgICAgPSBnbG9iYWwuUmFuZ2VFcnJvclxuICAgICwgVHlwZUVycm9yICAgICAgICAgICA9IGdsb2JhbC5UeXBlRXJyb3JcbiAgICAsIFVpbnQ4QXJyYXkgICAgICAgICAgPSBnbG9iYWwuVWludDhBcnJheVxuICAgICwgQVJSQVlfQlVGRkVSICAgICAgICA9ICdBcnJheUJ1ZmZlcidcbiAgICAsIFNIQVJFRF9CVUZGRVIgICAgICAgPSAnU2hhcmVkJyArIEFSUkFZX0JVRkZFUlxuICAgICwgQllURVNfUEVSX0VMRU1FTlQgICA9ICdCWVRFU19QRVJfRUxFTUVOVCdcbiAgICAsIFBST1RPVFlQRSAgICAgICAgICAgPSAncHJvdG90eXBlJ1xuICAgICwgQXJyYXlQcm90byAgICAgICAgICA9IEFycmF5W1BST1RPVFlQRV1cbiAgICAsICRBcnJheUJ1ZmZlciAgICAgICAgPSAkYnVmZmVyLkFycmF5QnVmZmVyXG4gICAgLCAkRGF0YVZpZXcgICAgICAgICAgID0gJGJ1ZmZlci5EYXRhVmlld1xuICAgICwgYXJyYXlGb3JFYWNoICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDApXG4gICAgLCBhcnJheUZpbHRlciAgICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoMilcbiAgICAsIGFycmF5U29tZSAgICAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCgzKVxuICAgICwgYXJyYXlFdmVyeSAgICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDQpXG4gICAgLCBhcnJheUZpbmQgICAgICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoNSlcbiAgICAsIGFycmF5RmluZEluZGV4ICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCg2KVxuICAgICwgYXJyYXlJbmNsdWRlcyAgICAgICA9IGNyZWF0ZUFycmF5SW5jbHVkZXModHJ1ZSlcbiAgICAsIGFycmF5SW5kZXhPZiAgICAgICAgPSBjcmVhdGVBcnJheUluY2x1ZGVzKGZhbHNlKVxuICAgICwgYXJyYXlWYWx1ZXMgICAgICAgICA9IEFycmF5SXRlcmF0b3JzLnZhbHVlc1xuICAgICwgYXJyYXlLZXlzICAgICAgICAgICA9IEFycmF5SXRlcmF0b3JzLmtleXNcbiAgICAsIGFycmF5RW50cmllcyAgICAgICAgPSBBcnJheUl0ZXJhdG9ycy5lbnRyaWVzXG4gICAgLCBhcnJheUxhc3RJbmRleE9mICAgID0gQXJyYXlQcm90by5sYXN0SW5kZXhPZlxuICAgICwgYXJyYXlSZWR1Y2UgICAgICAgICA9IEFycmF5UHJvdG8ucmVkdWNlXG4gICAgLCBhcnJheVJlZHVjZVJpZ2h0ICAgID0gQXJyYXlQcm90by5yZWR1Y2VSaWdodFxuICAgICwgYXJyYXlKb2luICAgICAgICAgICA9IEFycmF5UHJvdG8uam9pblxuICAgICwgYXJyYXlTb3J0ICAgICAgICAgICA9IEFycmF5UHJvdG8uc29ydFxuICAgICwgYXJyYXlTbGljZSAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2VcbiAgICAsIGFycmF5VG9TdHJpbmcgICAgICAgPSBBcnJheVByb3RvLnRvU3RyaW5nXG4gICAgLCBhcnJheVRvTG9jYWxlU3RyaW5nID0gQXJyYXlQcm90by50b0xvY2FsZVN0cmluZ1xuICAgICwgSVRFUkFUT1IgICAgICAgICAgICA9IHdrcygnaXRlcmF0b3InKVxuICAgICwgVEFHICAgICAgICAgICAgICAgICA9IHdrcygndG9TdHJpbmdUYWcnKVxuICAgICwgVFlQRURfQ09OU1RSVUNUT1IgICA9IHVpZCgndHlwZWRfY29uc3RydWN0b3InKVxuICAgICwgREVGX0NPTlNUUlVDVE9SICAgICA9IHVpZCgnZGVmX2NvbnN0cnVjdG9yJylcbiAgICAsIEFMTF9DT05TVFJVQ1RPUlMgICAgPSAkdHlwZWQuQ09OU1RSXG4gICAgLCBUWVBFRF9BUlJBWSAgICAgICAgID0gJHR5cGVkLlRZUEVEXG4gICAgLCBWSUVXICAgICAgICAgICAgICAgID0gJHR5cGVkLlZJRVdcbiAgICAsIFdST05HX0xFTkdUSCAgICAgICAgPSAnV3JvbmcgbGVuZ3RoISc7XG5cbiAgdmFyICRtYXAgPSBjcmVhdGVBcnJheU1ldGhvZCgxLCBmdW5jdGlvbihPLCBsZW5ndGgpe1xuICAgIHJldHVybiBhbGxvY2F0ZShzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSwgbGVuZ3RoKTtcbiAgfSk7XG5cbiAgdmFyIExJVFRMRV9FTkRJQU4gPSBmYWlscyhmdW5jdGlvbigpe1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVWludDE2QXJyYXkoWzFdKS5idWZmZXIpWzBdID09PSAxO1xuICB9KTtcblxuICB2YXIgRk9SQ0VEX1NFVCA9ICEhVWludDhBcnJheSAmJiAhIVVpbnQ4QXJyYXlbUFJPVE9UWVBFXS5zZXQgJiYgZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgVWludDhBcnJheSgxKS5zZXQoe30pO1xuICB9KTtcblxuICB2YXIgc3RyaWN0VG9MZW5ndGggPSBmdW5jdGlvbihpdCwgU0FNRSl7XG4gICAgaWYoaXQgPT09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICB2YXIgbnVtYmVyID0gK2l0XG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKGl0KTtcbiAgICBpZihTQU1FICYmICFzYW1lKG51bWJlciwgbGVuZ3RoKSl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgcmV0dXJuIGxlbmd0aDtcbiAgfTtcblxuICB2YXIgdG9PZmZzZXQgPSBmdW5jdGlvbihpdCwgQllURVMpe1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoaXQpO1xuICAgIGlmKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICUgQllURVMpdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlID0gZnVuY3Rpb24oaXQpe1xuICAgIGlmKGlzT2JqZWN0KGl0KSAmJiBUWVBFRF9BUlJBWSBpbiBpdClyZXR1cm4gaXQ7XG4gICAgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSB0eXBlZCBhcnJheSEnKTtcbiAgfTtcblxuICB2YXIgYWxsb2NhdGUgPSBmdW5jdGlvbihDLCBsZW5ndGgpe1xuICAgIGlmKCEoaXNPYmplY3QoQykgJiYgVFlQRURfQ09OU1RSVUNUT1IgaW4gQykpe1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJdCBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvciEnKTtcbiAgICB9IHJldHVybiBuZXcgQyhsZW5ndGgpO1xuICB9O1xuXG4gIHZhciBzcGVjaWVzRnJvbUxpc3QgPSBmdW5jdGlvbihPLCBsaXN0KXtcbiAgICByZXR1cm4gZnJvbUxpc3Qoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSksIGxpc3QpO1xuICB9O1xuXG4gIHZhciBmcm9tTGlzdCA9IGZ1bmN0aW9uKEMsIGxpc3Qpe1xuICAgIHZhciBpbmRleCAgPSAwXG4gICAgICAsIGxlbmd0aCA9IGxpc3QubGVuZ3RoXG4gICAgICAsIHJlc3VsdCA9IGFsbG9jYXRlKEMsIGxlbmd0aCk7XG4gICAgd2hpbGUobGVuZ3RoID4gaW5kZXgpcmVzdWx0W2luZGV4XSA9IGxpc3RbaW5kZXgrK107XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgYWRkR2V0dGVyID0gZnVuY3Rpb24oaXQsIGtleSwgaW50ZXJuYWwpe1xuICAgIGRQKGl0LCBrZXksIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9kW2ludGVybmFsXTsgfX0pO1xuICB9O1xuXG4gIHZhciAkZnJvbSA9IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qLCBtYXBmbiwgdGhpc0FyZyAqLyl7XG4gICAgdmFyIE8gICAgICAgPSB0b09iamVjdChzb3VyY2UpXG4gICAgICAsIGFMZW4gICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIG1hcGZuICAgPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZFxuICAgICAgLCBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZFxuICAgICAgLCBpdGVyRm4gID0gZ2V0SXRlckZuKE8pXG4gICAgICAsIGksIGxlbmd0aCwgdmFsdWVzLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIWlzQXJyYXlJdGVyKGl0ZXJGbikpe1xuICAgICAgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHZhbHVlcyA9IFtdLCBpID0gMDsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpKyspe1xuICAgICAgICB2YWx1ZXMucHVzaChzdGVwLnZhbHVlKTtcbiAgICAgIH0gTyA9IHZhbHVlcztcbiAgICB9XG4gICAgaWYobWFwcGluZyAmJiBhTGVuID4gMiltYXBmbiA9IGN0eChtYXBmbiwgYXJndW1lbnRzWzJdLCAyKTtcbiAgICBmb3IoaSA9IDAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKSwgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTsgbGVuZ3RoID4gaTsgaSsrKXtcbiAgICAgIHJlc3VsdFtpXSA9IG1hcHBpbmcgPyBtYXBmbihPW2ldLCBpKSA6IE9baV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyICRvZiA9IGZ1bmN0aW9uIG9mKC8qLi4uaXRlbXMqLyl7XG4gICAgdmFyIGluZGV4ICA9IDBcbiAgICAgICwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCByZXN1bHQgPSBhbGxvY2F0ZSh0aGlzLCBsZW5ndGgpO1xuICAgIHdoaWxlKGxlbmd0aCA+IGluZGV4KXJlc3VsdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXgrK107XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBpT1MgU2FmYXJpIDYueCBmYWlscyBoZXJlXG4gIHZhciBUT19MT0NBTEVfQlVHID0gISFVaW50OEFycmF5ICYmIGZhaWxzKGZ1bmN0aW9uKCl7IGFycmF5VG9Mb2NhbGVTdHJpbmcuY2FsbChuZXcgVWludDhBcnJheSgxKSk7IH0pO1xuXG4gIHZhciAkdG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZygpe1xuICAgIHJldHVybiBhcnJheVRvTG9jYWxlU3RyaW5nLmFwcGx5KFRPX0xPQ0FMRV9CVUcgPyBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcykpIDogdmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgdmFyIHByb3RvID0ge1xuICAgIGNvcHlXaXRoaW46IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCAvKiwgZW5kICovKXtcbiAgICAgIHJldHVybiBhcnJheUNvcHlXaXRoaW4uY2FsbCh2YWxpZGF0ZSh0aGlzKSwgdGFyZ2V0LCBzdGFydCwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5RXZlcnkodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZpbGw6IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyosIHN0YXJ0LCBlbmQgKi8peyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlGaWxsLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5RmlsdGVyKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLFxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCkpO1xuICAgIH0sXG4gICAgZmluZDogZnVuY3Rpb24gZmluZChwcmVkaWNhdGUgLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5RmluZCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChwcmVkaWNhdGUgLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5RmluZEluZGV4KHZhbGlkYXRlKHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICBhcnJheUZvckVhY2godmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ICovKXtcbiAgICAgIHJldHVybiBhcnJheUluZGV4T2YodmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggKi8pe1xuICAgICAgcmV0dXJuIGFycmF5SW5jbHVkZXModmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5Sm9pbi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggKi8peyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlMYXN0SW5kZXhPZi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIG1hcDogZnVuY3Rpb24gbWFwKG1hcGZuIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiAkbWFwKHZhbGlkYXRlKHRoaXMpLCBtYXBmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiwgaW5pdGlhbFZhbHVlICovKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gLyosIGluaXRpYWxWYWx1ZSAqLyl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZVJpZ2h0LmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpe1xuICAgICAgdmFyIHRoYXQgICA9IHRoaXNcbiAgICAgICAgLCBsZW5ndGggPSB2YWxpZGF0ZSh0aGF0KS5sZW5ndGhcbiAgICAgICAgLCBtaWRkbGUgPSBNYXRoLmZsb29yKGxlbmd0aCAvIDIpXG4gICAgICAgICwgaW5kZXggID0gMFxuICAgICAgICAsIHZhbHVlO1xuICAgICAgd2hpbGUoaW5kZXggPCBtaWRkbGUpe1xuICAgICAgICB2YWx1ZSAgICAgICAgID0gdGhhdFtpbmRleF07XG4gICAgICAgIHRoYXRbaW5kZXgrK10gPSB0aGF0Wy0tbGVuZ3RoXTtcbiAgICAgICAgdGhhdFtsZW5ndGhdICA9IHZhbHVlO1xuICAgICAgfSByZXR1cm4gdGhhdDtcbiAgICB9LFxuICAgIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlTb21lKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbil7XG4gICAgICByZXR1cm4gYXJyYXlTb3J0LmNhbGwodmFsaWRhdGUodGhpcyksIGNvbXBhcmVmbik7XG4gICAgfSxcbiAgICBzdWJhcnJheTogZnVuY3Rpb24gc3ViYXJyYXkoYmVnaW4sIGVuZCl7XG4gICAgICB2YXIgTyAgICAgID0gdmFsaWRhdGUodGhpcylcbiAgICAgICAgLCBsZW5ndGggPSBPLmxlbmd0aFxuICAgICAgICAsICRiZWdpbiA9IHRvSW5kZXgoYmVnaW4sIGxlbmd0aCk7XG4gICAgICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSkoXG4gICAgICAgIE8uYnVmZmVyLFxuICAgICAgICBPLmJ5dGVPZmZzZXQgKyAkYmVnaW4gKiBPLkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICB0b0xlbmd0aCgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0luZGV4KGVuZCwgbGVuZ3RoKSkgLSAkYmVnaW4pXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICB2YXIgJHNsaWNlID0gZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCl7XG4gICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcyksIHN0YXJ0LCBlbmQpKTtcbiAgfTtcblxuICB2YXIgJHNldCA9IGZ1bmN0aW9uIHNldChhcnJheUxpa2UgLyosIG9mZnNldCAqLyl7XG4gICAgdmFsaWRhdGUodGhpcyk7XG4gICAgdmFyIG9mZnNldCA9IHRvT2Zmc2V0KGFyZ3VtZW50c1sxXSwgMSlcbiAgICAgICwgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICAgICwgc3JjICAgID0gdG9PYmplY3QoYXJyYXlMaWtlKVxuICAgICAgLCBsZW4gICAgPSB0b0xlbmd0aChzcmMubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSAwO1xuICAgIGlmKGxlbiArIG9mZnNldCA+IGxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgd2hpbGUoaW5kZXggPCBsZW4pdGhpc1tvZmZzZXQgKyBpbmRleF0gPSBzcmNbaW5kZXgrK107XG4gIH07XG5cbiAgdmFyICRpdGVyYXRvcnMgPSB7XG4gICAgZW50cmllczogZnVuY3Rpb24gZW50cmllcygpe1xuICAgICAgcmV0dXJuIGFycmF5RW50cmllcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9LFxuICAgIGtleXM6IGZ1bmN0aW9uIGtleXMoKXtcbiAgICAgIHJldHVybiBhcnJheUtleXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfSxcbiAgICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcygpe1xuICAgICAgcmV0dXJuIGFycmF5VmFsdWVzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNUQUluZGV4ID0gZnVuY3Rpb24odGFyZ2V0LCBrZXkpe1xuICAgIHJldHVybiBpc09iamVjdCh0YXJnZXQpXG4gICAgICAmJiB0YXJnZXRbVFlQRURfQVJSQVldXG4gICAgICAmJiB0eXBlb2Yga2V5ICE9ICdzeW1ib2wnXG4gICAgICAmJiBrZXkgaW4gdGFyZ2V0XG4gICAgICAmJiBTdHJpbmcoK2tleSkgPT0gU3RyaW5nKGtleSk7XG4gIH07XG4gIHZhciAkZ2V0RGVzYyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSl7XG4gICAgcmV0dXJuIGlzVEFJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXG4gICAgICA/IHByb3BlcnR5RGVzYygyLCB0YXJnZXRba2V5XSlcbiAgICAgIDogZ09QRCh0YXJnZXQsIGtleSk7XG4gIH07XG4gIHZhciAkc2V0RGVzYyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjKXtcbiAgICBpZihpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgICAgJiYgaXNPYmplY3QoZGVzYylcbiAgICAgICYmIGhhcyhkZXNjLCAndmFsdWUnKVxuICAgICAgJiYgIWhhcyhkZXNjLCAnZ2V0JylcbiAgICAgICYmICFoYXMoZGVzYywgJ3NldCcpXG4gICAgICAvLyBUT0RPOiBhZGQgdmFsaWRhdGlvbiBkZXNjcmlwdG9yIHcvbyBjYWxsaW5nIGFjY2Vzc29yc1xuICAgICAgJiYgIWRlc2MuY29uZmlndXJhYmxlXG4gICAgICAmJiAoIWhhcyhkZXNjLCAnd3JpdGFibGUnKSB8fCBkZXNjLndyaXRhYmxlKVxuICAgICAgJiYgKCFoYXMoZGVzYywgJ2VudW1lcmFibGUnKSB8fCBkZXNjLmVudW1lcmFibGUpXG4gICAgKXtcbiAgICAgIHRhcmdldFtrZXldID0gZGVzYy52YWx1ZTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSBlbHNlIHJldHVybiBkUCh0YXJnZXQsIGtleSwgZGVzYyk7XG4gIH07XG5cbiAgaWYoIUFMTF9DT05TVFJVQ1RPUlMpe1xuICAgICRHT1BELmYgPSAkZ2V0RGVzYztcbiAgICAkRFAuZiAgID0gJHNldERlc2M7XG4gIH1cblxuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFBTExfQ09OU1RSVUNUT1JTLCAnT2JqZWN0Jywge1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldERlc2MsXG4gICAgZGVmaW5lUHJvcGVydHk6ICAgICAgICAgICAkc2V0RGVzY1xuICB9KTtcblxuICBpZihmYWlscyhmdW5jdGlvbigpeyBhcnJheVRvU3RyaW5nLmNhbGwoe30pOyB9KSl7XG4gICAgYXJyYXlUb1N0cmluZyA9IGFycmF5VG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgICAgcmV0dXJuIGFycmF5Sm9pbi5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciAkVHlwZWRBcnJheVByb3RvdHlwZSQgPSByZWRlZmluZUFsbCh7fSwgcHJvdG8pO1xuICByZWRlZmluZUFsbCgkVHlwZWRBcnJheVByb3RvdHlwZSQsICRpdGVyYXRvcnMpO1xuICBoaWRlKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgSVRFUkFUT1IsICRpdGVyYXRvcnMudmFsdWVzKTtcbiAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCB7XG4gICAgc2xpY2U6ICAgICAgICAgICRzbGljZSxcbiAgICBzZXQ6ICAgICAgICAgICAgJHNldCxcbiAgICBjb25zdHJ1Y3RvcjogICAgZnVuY3Rpb24oKXsgLyogbm9vcCAqLyB9LFxuICAgIHRvU3RyaW5nOiAgICAgICBhcnJheVRvU3RyaW5nLFxuICAgIHRvTG9jYWxlU3RyaW5nOiAkdG9Mb2NhbGVTdHJpbmdcbiAgfSk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdidWZmZXInLCAnYicpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnl0ZU9mZnNldCcsICdvJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdieXRlTGVuZ3RoJywgJ2wnKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2xlbmd0aCcsICdlJyk7XG4gIGRQKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgVEFHLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpc1tUWVBFRF9BUlJBWV07IH1cbiAgfSk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIEJZVEVTLCB3cmFwcGVyLCBDTEFNUEVEKXtcbiAgICBDTEFNUEVEID0gISFDTEFNUEVEO1xuICAgIHZhciBOQU1FICAgICAgID0gS0VZICsgKENMQU1QRUQgPyAnQ2xhbXBlZCcgOiAnJykgKyAnQXJyYXknXG4gICAgICAsIElTTlRfVUlOVDggPSBOQU1FICE9ICdVaW50OEFycmF5J1xuICAgICAgLCBHRVRURVIgICAgID0gJ2dldCcgKyBLRVlcbiAgICAgICwgU0VUVEVSICAgICA9ICdzZXQnICsgS0VZXG4gICAgICAsIFR5cGVkQXJyYXkgPSBnbG9iYWxbTkFNRV1cbiAgICAgICwgQmFzZSAgICAgICA9IFR5cGVkQXJyYXkgfHwge31cbiAgICAgICwgVEFDICAgICAgICA9IFR5cGVkQXJyYXkgJiYgZ2V0UHJvdG90eXBlT2YoVHlwZWRBcnJheSlcbiAgICAgICwgRk9SQ0VEICAgICA9ICFUeXBlZEFycmF5IHx8ICEkdHlwZWQuQUJWXG4gICAgICAsIE8gICAgICAgICAgPSB7fVxuICAgICAgLCBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheSAmJiBUeXBlZEFycmF5W1BST1RPVFlQRV07XG4gICAgdmFyIGdldHRlciA9IGZ1bmN0aW9uKHRoYXQsIGluZGV4KXtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIHJldHVybiBkYXRhLnZbR0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbih0aGF0LCBpbmRleCwgdmFsdWUpe1xuICAgICAgdmFyIGRhdGEgPSB0aGF0Ll9kO1xuICAgICAgaWYoQ0xBTVBFRCl2YWx1ZSA9ICh2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpKSA8IDAgPyAwIDogdmFsdWUgPiAweGZmID8gMHhmZiA6IHZhbHVlICYgMHhmZjtcbiAgICAgIGRhdGEudltTRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLm8sIHZhbHVlLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuICAgIHZhciBhZGRFbGVtZW50ID0gZnVuY3Rpb24odGhhdCwgaW5kZXgpe1xuICAgICAgZFAodGhhdCwgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICAgIHJldHVybiBnZXR0ZXIodGhpcywgaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICByZXR1cm4gc2V0dGVyKHRoaXMsIGluZGV4LCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYoRk9SQ0VEKXtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGRhdGEsICRvZmZzZXQsICRsZW5ndGgpe1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUsICdfZCcpO1xuICAgICAgICB2YXIgaW5kZXggID0gMFxuICAgICAgICAgICwgb2Zmc2V0ID0gMFxuICAgICAgICAgICwgYnVmZmVyLCBieXRlTGVuZ3RoLCBsZW5ndGgsIGtsYXNzO1xuICAgICAgICBpZighaXNPYmplY3QoZGF0YSkpe1xuICAgICAgICAgIGxlbmd0aCAgICAgPSBzdHJpY3RUb0xlbmd0aChkYXRhLCB0cnVlKVxuICAgICAgICAgIGJ5dGVMZW5ndGggPSBsZW5ndGggKiBCWVRFUztcbiAgICAgICAgICBidWZmZXIgICAgID0gbmV3ICRBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmKGRhdGEgaW5zdGFuY2VvZiAkQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihkYXRhKSkgPT0gQVJSQVlfQlVGRkVSIHx8IGtsYXNzID09IFNIQVJFRF9CVUZGRVIpe1xuICAgICAgICAgIGJ1ZmZlciA9IGRhdGE7XG4gICAgICAgICAgb2Zmc2V0ID0gdG9PZmZzZXQoJG9mZnNldCwgQllURVMpO1xuICAgICAgICAgIHZhciAkbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGlmKCRsZW5ndGggPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICBpZigkbGVuICUgQllURVMpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9ICRsZW4gLSBvZmZzZXQ7XG4gICAgICAgICAgICBpZihieXRlTGVuZ3RoIDwgMCl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSB0b0xlbmd0aCgkbGVuZ3RoKSAqIEJZVEVTO1xuICAgICAgICAgICAgaWYoYnl0ZUxlbmd0aCArIG9mZnNldCA+ICRsZW4pdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggPSBieXRlTGVuZ3RoIC8gQllURVM7XG4gICAgICAgIH0gZWxzZSBpZihUWVBFRF9BUlJBWSBpbiBkYXRhKXtcbiAgICAgICAgICByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZSh0aGF0LCAnX2QnLCB7XG4gICAgICAgICAgYjogYnVmZmVyLFxuICAgICAgICAgIG86IG9mZnNldCxcbiAgICAgICAgICBsOiBieXRlTGVuZ3RoLFxuICAgICAgICAgIGU6IGxlbmd0aCxcbiAgICAgICAgICB2OiBuZXcgJERhdGFWaWV3KGJ1ZmZlcilcbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlKGluZGV4IDwgbGVuZ3RoKWFkZEVsZW1lbnQodGhhdCwgaW5kZXgrKyk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBjcmVhdGUoJFR5cGVkQXJyYXlQcm90b3R5cGUkKTtcbiAgICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgVHlwZWRBcnJheSk7XG4gICAgfSBlbHNlIGlmKCEkaXRlckRldGVjdChmdW5jdGlvbihpdGVyKXtcbiAgICAgIC8vIFY4IHdvcmtzIHdpdGggaXRlcmF0b3JzLCBidXQgZmFpbHMgaW4gbWFueSBvdGhlciBjYXNlc1xuICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQ1NTJcbiAgICAgIG5ldyBUeXBlZEFycmF5KG51bGwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkoaXRlcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfSwgdHJ1ZSkpe1xuICAgICAgVHlwZWRBcnJheSA9IHdyYXBwZXIoZnVuY3Rpb24odGhhdCwgZGF0YSwgJG9mZnNldCwgJGxlbmd0aCl7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSk7XG4gICAgICAgIHZhciBrbGFzcztcbiAgICAgICAgLy8gYHdzYCBtb2R1bGUgYnVnLCB0ZW1wb3JhcmlseSByZW1vdmUgdmFsaWRhdGlvbiBsZW5ndGggZm9yIFVpbnQ4QXJyYXlcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvcHVsbC82NDVcbiAgICAgICAgaWYoIWlzT2JqZWN0KGRhdGEpKXJldHVybiBuZXcgQmFzZShzdHJpY3RUb0xlbmd0aChkYXRhLCBJU05UX1VJTlQ4KSk7XG4gICAgICAgIGlmKGRhdGEgaW5zdGFuY2VvZiAkQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihkYXRhKSkgPT0gQVJSQVlfQlVGRkVSIHx8IGtsYXNzID09IFNIQVJFRF9CVUZGRVIpe1xuICAgICAgICAgIHJldHVybiAkbGVuZ3RoICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpLCAkbGVuZ3RoKVxuICAgICAgICAgICAgOiAkb2Zmc2V0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyBuZXcgQmFzZShkYXRhLCB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUykpXG4gICAgICAgICAgICAgIDogbmV3IEJhc2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoVFlQRURfQVJSQVkgaW4gZGF0YSlyZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgfSk7XG4gICAgICBhcnJheUZvckVhY2goVEFDICE9PSBGdW5jdGlvbi5wcm90b3R5cGUgPyBnT1BOKEJhc2UpLmNvbmNhdChnT1BOKFRBQykpIDogZ09QTihCYXNlKSwgZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgaWYoIShrZXkgaW4gVHlwZWRBcnJheSkpaGlkZShUeXBlZEFycmF5LCBrZXksIEJhc2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IFR5cGVkQXJyYXlQcm90b3R5cGU7XG4gICAgICBpZighTElCUkFSWSlUeXBlZEFycmF5UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHlwZWRBcnJheTtcbiAgICB9XG4gICAgdmFyICRuYXRpdmVJdGVyYXRvciAgID0gVHlwZWRBcnJheVByb3RvdHlwZVtJVEVSQVRPUl1cbiAgICAgICwgQ09SUkVDVF9JVEVSX05BTUUgPSAhISRuYXRpdmVJdGVyYXRvciAmJiAoJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gJ3ZhbHVlcycgfHwgJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gdW5kZWZpbmVkKVxuICAgICAgLCAkaXRlcmF0b3IgICAgICAgICA9ICRpdGVyYXRvcnMudmFsdWVzO1xuICAgIGhpZGUoVHlwZWRBcnJheSwgVFlQRURfQ09OU1RSVUNUT1IsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgVFlQRURfQVJSQVksIE5BTUUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBERUZfQ09OU1RSVUNUT1IsIFR5cGVkQXJyYXkpO1xuXG4gICAgaWYoQ0xBTVBFRCA/IG5ldyBUeXBlZEFycmF5KDEpW1RBR10gIT0gTkFNRSA6ICEoVEFHIGluIFR5cGVkQXJyYXlQcm90b3R5cGUpKXtcbiAgICAgIGRQKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRBRywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBOQU1FOyB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBPW05BTUVdID0gVHlwZWRBcnJheTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKFR5cGVkQXJyYXkgIT0gQmFzZSksIE8pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlMsIE5BTUUsIHtcbiAgICAgIEJZVEVTX1BFUl9FTEVNRU5UOiBCWVRFUyxcbiAgICAgIGZyb206ICRmcm9tLFxuICAgICAgb2Y6ICRvZlxuICAgIH0pO1xuXG4gICAgaWYoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSloaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIEJZVEVTX1BFUl9FTEVNRU5ULCBCWVRFUyk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCwgTkFNRSwgcHJvdG8pO1xuXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0VEX1NFVCwgTkFNRSwge3NldDogJHNldH0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhQ09SUkVDVF9JVEVSX05BTUUsIE5BTUUsICRpdGVyYXRvcnMpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoVHlwZWRBcnJheVByb3RvdHlwZS50b1N0cmluZyAhPSBhcnJheVRvU3RyaW5nKSwgTkFNRSwge3RvU3RyaW5nOiBhcnJheVRvU3RyaW5nfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgICBuZXcgVHlwZWRBcnJheSgxKS5zbGljZSgpO1xuICAgIH0pLCBOQU1FLCB7c2xpY2U6ICRzbGljZX0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBbMSwgMl0udG9Mb2NhbGVTdHJpbmcoKSAhPSBuZXcgVHlwZWRBcnJheShbMSwgMl0pLnRvTG9jYWxlU3RyaW5nKClcbiAgICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcuY2FsbChbMSwgMl0pO1xuICAgIH0pKSwgTkFNRSwge3RvTG9jYWxlU3RyaW5nOiAkdG9Mb2NhbGVTdHJpbmd9KTtcblxuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IENPUlJFQ1RfSVRFUl9OQU1FID8gJG5hdGl2ZUl0ZXJhdG9yIDogJGl0ZXJhdG9yO1xuICAgIGlmKCFMSUJSQVJZICYmICFDT1JSRUNUX0lURVJfTkFNRSloaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIElURVJBVE9SLCAkaXRlcmF0b3IpO1xuICB9O1xufSBlbHNlIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDI5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50OCcsIDEsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDI5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50OCcsIDEsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhDbGFtcGVkQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSwgdHJ1ZSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWNsYW1wZWQtYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDMwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQxNicsIDIsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gSW50MTZBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDMwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50MTYnLCAyLCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQxNkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDMwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQzMicsIDQsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gSW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MzItYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDMwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50MzInLCA0LCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDMwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdGbG9hdDMyJywgNCwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBGbG9hdDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDMwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdGbG9hdDY0JywgOCwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBGbG9hdDY0QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0NjQtYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDMwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyNi4xLjEgUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdClcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIGFuT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgckFwcGx5ICAgID0gKHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3QgfHwge30pLmFwcGx5XG4gICwgZkFwcGx5ICAgID0gRnVuY3Rpb24uYXBwbHk7XG4vLyBNUyBFZGdlIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgckFwcGx5KGZ1bmN0aW9uKCl7fSk7XG59KSwgJ1JlZmxlY3QnLCB7XG4gIGFwcGx5OiBmdW5jdGlvbiBhcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdCl7XG4gICAgdmFyIFQgPSBhRnVuY3Rpb24odGFyZ2V0KVxuICAgICAgLCBMID0gYW5PYmplY3QoYXJndW1lbnRzTGlzdCk7XG4gICAgcmV0dXJuIHJBcHBseSA/IHJBcHBseShULCB0aGlzQXJndW1lbnQsIEwpIDogZkFwcGx5LmNhbGwoVCwgdGhpc0FyZ3VtZW50LCBMKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuYXBwbHkuanNcbi8vIG1vZHVsZSBpZCA9IDMwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyNi4xLjIgUmVmbGVjdC5jb25zdHJ1Y3QodGFyZ2V0LCBhcmd1bWVudHNMaXN0IFssIG5ld1RhcmdldF0pXG52YXIgJGV4cG9ydCAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY3JlYXRlICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGFGdW5jdGlvbiAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBhbk9iamVjdCAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBpc09iamVjdCAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBmYWlscyAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGJpbmQgICAgICAgPSByZXF1aXJlKCcuL19iaW5kJylcbiAgLCByQ29uc3RydWN0ID0gKHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3QgfHwge30pLmNvbnN0cnVjdDtcblxuLy8gTVMgRWRnZSBzdXBwb3J0cyBvbmx5IDIgYXJndW1lbnRzIGFuZCBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4vLyBGRiBOaWdodGx5IHNldHMgdGhpcmQgYXJndW1lbnQgYXMgYG5ldy50YXJnZXRgLCBidXQgZG9lcyBub3QgY3JlYXRlIGB0aGlzYCBmcm9tIGl0XG52YXIgTkVXX1RBUkdFVF9CVUcgPSBmYWlscyhmdW5jdGlvbigpe1xuICBmdW5jdGlvbiBGKCl7fVxuICByZXR1cm4gIShyQ29uc3RydWN0KGZ1bmN0aW9uKCl7fSwgW10sIEYpIGluc3RhbmNlb2YgRik7XG59KTtcbnZhciBBUkdTX0JVRyA9ICFmYWlscyhmdW5jdGlvbigpe1xuICByQ29uc3RydWN0KGZ1bmN0aW9uKCl7fSk7XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTkVXX1RBUkdFVF9CVUcgfHwgQVJHU19CVUcpLCAnUmVmbGVjdCcsIHtcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzIC8qLCBuZXdUYXJnZXQqLyl7XG4gICAgYUZ1bmN0aW9uKFRhcmdldCk7XG4gICAgYW5PYmplY3QoYXJncyk7XG4gICAgdmFyIG5ld1RhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gVGFyZ2V0IDogYUZ1bmN0aW9uKGFyZ3VtZW50c1syXSk7XG4gICAgaWYoQVJHU19CVUcgJiYgIU5FV19UQVJHRVRfQlVHKXJldHVybiByQ29uc3RydWN0KFRhcmdldCwgYXJncywgbmV3VGFyZ2V0KTtcbiAgICBpZihUYXJnZXQgPT0gbmV3VGFyZ2V0KXtcbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgb3B0aW1pemF0aW9uIGZvciAwLTQgYXJndW1lbnRzXG4gICAgICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgVGFyZ2V0O1xuICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0pO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgfVxuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBsb3Qgb2YgYXJndW1lbnRzIGNhc2VcbiAgICAgIHZhciAkYXJncyA9IFtudWxsXTtcbiAgICAgICRhcmdzLnB1c2guYXBwbHkoJGFyZ3MsIGFyZ3MpO1xuICAgICAgcmV0dXJuIG5ldyAoYmluZC5hcHBseShUYXJnZXQsICRhcmdzKSk7XG4gICAgfVxuICAgIC8vIHdpdGggYWx0ZXJlZCBuZXdUYXJnZXQsIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGNvbnN0cnVjdG9yc1xuICAgIHZhciBwcm90byAgICA9IG5ld1RhcmdldC5wcm90b3R5cGVcbiAgICAgICwgaW5zdGFuY2UgPSBjcmVhdGUoaXNPYmplY3QocHJvdG8pID8gcHJvdG8gOiBPYmplY3QucHJvdG90eXBlKVxuICAgICAgLCByZXN1bHQgICA9IEZ1bmN0aW9uLmFwcGx5LmNhbGwoVGFyZ2V0LCBpbnN0YW5jZSwgYXJncyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiBpbnN0YW5jZTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuY29uc3RydWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjYuMS4zIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcylcbnZhciBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4vLyBNUyBFZGdlIGhhcyBicm9rZW4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSAtIHRocm93aW5nIGluc3RlYWQgb2YgcmV0dXJuaW5nIGZhbHNlXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShkUC5mKHt9LCAxLCB7dmFsdWU6IDF9KSwgMSwge3ZhbHVlOiAyfSk7XG59KSwgJ1JlZmxlY3QnLCB7XG4gIGRlZmluZVByb3BlcnR5OiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKXtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHByb3BlcnR5S2V5ID0gdG9QcmltaXRpdmUocHJvcGVydHlLZXksIHRydWUpO1xuICAgIGFuT2JqZWN0KGF0dHJpYnV0ZXMpO1xuICAgIHRyeSB7XG4gICAgICBkUC5mKHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlZmluZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMzA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDI2LjEuNCBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGdPUEQgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSl7XG4gICAgdmFyIGRlc2MgPSBnT1BEKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgICByZXR1cm4gZGVzYyAmJiAhZGVzYy5jb25maWd1cmFibGUgPyBmYWxzZSA6IGRlbGV0ZSB0YXJnZXRbcHJvcGVydHlLZXldO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5kZWxldGUtcHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDMxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyAyNi4xLjUgUmVmbGVjdC5lbnVtZXJhdGUodGFyZ2V0KVxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIEVudW1lcmF0ZSA9IGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IGFuT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdmFyIGtleXMgPSB0aGlzLl9rID0gW10gICAgICAgLy8ga2V5c1xuICAgICwga2V5O1xuICBmb3Ioa2V5IGluIGl0ZXJhdGVkKWtleXMucHVzaChrZXkpO1xufTtcbnJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJykoRW51bWVyYXRlLCAnT2JqZWN0JywgZnVuY3Rpb24oKXtcbiAgdmFyIHRoYXQgPSB0aGlzXG4gICAgLCBrZXlzID0gdGhhdC5fa1xuICAgICwga2V5O1xuICBkbyB7XG4gICAgaWYodGhhdC5faSA+PSBrZXlzLmxlbmd0aClyZXR1cm4ge3ZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWV9O1xuICB9IHdoaWxlKCEoKGtleSA9IGtleXNbdGhhdC5faSsrXSkgaW4gdGhhdC5fdCkpO1xuICByZXR1cm4ge3ZhbHVlOiBrZXksIGRvbmU6IGZhbHNlfTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGVudW1lcmF0ZTogZnVuY3Rpb24gZW51bWVyYXRlKHRhcmdldCl7XG4gICAgcmV0dXJuIG5ldyBFbnVtZXJhdGUodGFyZ2V0KTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZW51bWVyYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjYuMS42IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkgWywgcmVjZWl2ZXJdKVxudmFyIGdPUEQgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuZnVuY3Rpb24gZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkvKiwgcmVjZWl2ZXIqLyl7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogYXJndW1lbnRzWzJdXG4gICAgLCBkZXNjLCBwcm90bztcbiAgaWYoYW5PYmplY3QodGFyZ2V0KSA9PT0gcmVjZWl2ZXIpcmV0dXJuIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIGlmKGRlc2MgPSBnT1BELmYodGFyZ2V0LCBwcm9wZXJ0eUtleSkpcmV0dXJuIGhhcyhkZXNjLCAndmFsdWUnKVxuICAgID8gZGVzYy52YWx1ZVxuICAgIDogZGVzYy5nZXQgIT09IHVuZGVmaW5lZFxuICAgICAgPyBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIGlmKGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpcmV0dXJuIGdldChwcm90bywgcHJvcGVydHlLZXksIHJlY2VpdmVyKTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge2dldDogZ2V0fSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjYuMS43IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgZ09QRCAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSl7XG4gICAgcmV0dXJuIGdPUEQuZihhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qc1xuLy8gbW9kdWxlIGlkID0gMzEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDI2LjEuOCBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldClcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZ2V0UHJvdG8gPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGdldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZih0YXJnZXQpe1xuICAgIHJldHVybiBnZXRQcm90byhhbk9iamVjdCh0YXJnZXQpKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMzE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDI2LjEuOSBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBoYXM6IGZ1bmN0aW9uIGhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KXtcbiAgICByZXR1cm4gcHJvcGVydHlLZXkgaW4gdGFyZ2V0O1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5oYXMuanNcbi8vIG1vZHVsZSBpZCA9IDMxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyNi4xLjEwIFJlZmxlY3QuaXNFeHRlbnNpYmxlKHRhcmdldClcbnZhciAkZXhwb3J0ICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhbk9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCAkaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBpc0V4dGVuc2libGU6IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZSh0YXJnZXQpe1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgcmV0dXJuICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKHRhcmdldCkgOiB0cnVlO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5pcy1leHRlbnNpYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjYuMS4xMSBSZWZsZWN0Lm93bktleXModGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge293bktleXM6IHJlcXVpcmUoJy4vX293bi1rZXlzJyl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5vd24ta2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMzE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBnT1BOICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJylcbiAgLCBnT1BTICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgUmVmbGVjdCAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBSZWZsZWN0ICYmIFJlZmxlY3Qub3duS2V5cyB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KXtcbiAgdmFyIGtleXMgICAgICAgPSBnT1BOLmYoYW5PYmplY3QoaXQpKVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgcmV0dXJuIGdldFN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fb3duLWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDMxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyNi4xLjEyIFJlZmxlY3QucHJldmVudEV4dGVuc2lvbnModGFyZ2V0KVxudmFyICRleHBvcnQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYW5PYmplY3QgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCAkcHJldmVudEV4dGVuc2lvbnMgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgcHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCl7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICB0cnkge1xuICAgICAgaWYoJHByZXZlbnRFeHRlbnNpb25zKSRwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qc1xuLy8gbW9kdWxlIGlkID0gMzE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDI2LjEuMTMgUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgViBbLCByZWNlaXZlcl0pXG52YXIgZFAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGdPUEQgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5mdW5jdGlvbiBzZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgVi8qLCByZWNlaXZlciovKXtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDQgPyB0YXJnZXQgOiBhcmd1bWVudHNbM11cbiAgICAsIG93bkRlc2MgID0gZ09QRC5mKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KVxuICAgICwgZXhpc3RpbmdEZXNjcmlwdG9yLCBwcm90bztcbiAgaWYoIW93bkRlc2Mpe1xuICAgIGlmKGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpe1xuICAgICAgcmV0dXJuIHNldChwcm90bywgcHJvcGVydHlLZXksIFYsIHJlY2VpdmVyKTtcbiAgICB9XG4gICAgb3duRGVzYyA9IGNyZWF0ZURlc2MoMCk7XG4gIH1cbiAgaWYoaGFzKG93bkRlc2MsICd2YWx1ZScpKXtcbiAgICBpZihvd25EZXNjLndyaXRhYmxlID09PSBmYWxzZSB8fCAhaXNPYmplY3QocmVjZWl2ZXIpKXJldHVybiBmYWxzZTtcbiAgICBleGlzdGluZ0Rlc2NyaXB0b3IgPSBnT1BELmYocmVjZWl2ZXIsIHByb3BlcnR5S2V5KSB8fCBjcmVhdGVEZXNjKDApO1xuICAgIGV4aXN0aW5nRGVzY3JpcHRvci52YWx1ZSA9IFY7XG4gICAgZFAuZihyZWNlaXZlciwgcHJvcGVydHlLZXksIGV4aXN0aW5nRGVzY3JpcHRvcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIG93bkRlc2Muc2V0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IChvd25EZXNjLnNldC5jYWxsKHJlY2VpdmVyLCBWKSwgdHJ1ZSk7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtzZXQ6IHNldH0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC5qc1xuLy8gbW9kdWxlIGlkID0gMzIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDI2LjEuMTQgUmVmbGVjdC5zZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKVxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBzZXRQcm90byA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpO1xuXG5pZihzZXRQcm90bykkZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIHNldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKXtcbiAgICBzZXRQcm90by5jaGVjayh0YXJnZXQsIHByb3RvKTtcbiAgICB0cnkge1xuICAgICAgc2V0UHJvdG8uc2V0KHRhcmdldCwgcHJvdG8pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YuanNcbi8vIG1vZHVsZSBpZCA9IDMyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9BcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRpbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiwgZnJvbUluZGV4ID0gMCAqLyl7XG4gICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2luY2x1ZGVzJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRhdCAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIGF0OiBmdW5jdGlvbiBhdChwb3Mpe1xuICAgIHJldHVybiAkYXQodGhpcywgcG9zKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5hdC5qc1xuLy8gbW9kdWxlIGlkID0gMzIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhZCAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1wYWQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIHBhZFN0YXJ0OiBmdW5jdGlvbiBwYWRTdGFydChtYXhMZW5ndGggLyosIGZpbGxTdHJpbmcgPSAnICcgKi8pe1xuICAgIHJldHVybiAkcGFkKHRoaXMsIG1heExlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRydWUpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydC5qc1xuLy8gbW9kdWxlIGlkID0gMzI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIHJlcGVhdCAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpXG4gICwgZGVmaW5lZCAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGhhdCwgbWF4TGVuZ3RoLCBmaWxsU3RyaW5nLCBsZWZ0KXtcbiAgdmFyIFMgICAgICAgICAgICA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxuICAgICwgc3RyaW5nTGVuZ3RoID0gUy5sZW5ndGhcbiAgICAsIGZpbGxTdHIgICAgICA9IGZpbGxTdHJpbmcgPT09IHVuZGVmaW5lZCA/ICcgJyA6IFN0cmluZyhmaWxsU3RyaW5nKVxuICAgICwgaW50TWF4TGVuZ3RoID0gdG9MZW5ndGgobWF4TGVuZ3RoKTtcbiAgaWYoaW50TWF4TGVuZ3RoIDw9IHN0cmluZ0xlbmd0aCB8fCBmaWxsU3RyID09ICcnKXJldHVybiBTO1xuICB2YXIgZmlsbExlbiA9IGludE1heExlbmd0aCAtIHN0cmluZ0xlbmd0aFxuICAgICwgc3RyaW5nRmlsbGVyID0gcmVwZWF0LmNhbGwoZmlsbFN0ciwgTWF0aC5jZWlsKGZpbGxMZW4gLyBmaWxsU3RyLmxlbmd0aCkpO1xuICBpZihzdHJpbmdGaWxsZXIubGVuZ3RoID4gZmlsbExlbilzdHJpbmdGaWxsZXIgPSBzdHJpbmdGaWxsZXIuc2xpY2UoMCwgZmlsbExlbik7XG4gIHJldHVybiBsZWZ0ID8gc3RyaW5nRmlsbGVyICsgUyA6IFMgKyBzdHJpbmdGaWxsZXI7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1wYWQuanNcbi8vIG1vZHVsZSBpZCA9IDMyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYWQgICAgPSByZXF1aXJlKCcuL19zdHJpbmctcGFkJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBwYWRFbmQ6IGZ1bmN0aW9uIHBhZEVuZChtYXhMZW5ndGggLyosIGZpbGxTdHJpbmcgPSAnICcgKi8pe1xuICAgIHJldHVybiAkcGFkKHRoaXMsIG1heExlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGZhbHNlKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtZW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbUxlZnQnLCBmdW5jdGlvbigkdHJpbSl7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltTGVmdCgpe1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAxKTtcbiAgfTtcbn0sICd0cmltU3RhcnQnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tbGVmdC5qc1xuLy8gbW9kdWxlIGlkID0gMzI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zZWJtYXJrYmFnZS9lY21hc2NyaXB0LXN0cmluZy1sZWZ0LXJpZ2h0LXRyaW1cbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW1SaWdodCcsIGZ1bmN0aW9uKCR0cmltKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW1SaWdodCgpe1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAyKTtcbiAgfTtcbn0sICd0cmltRW5kJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLXJpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9TdHJpbmcucHJvdG90eXBlLm1hdGNoQWxsL1xudmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBkZWZpbmVkICAgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBpc1JlZ0V4cCAgICA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpXG4gICwgZ2V0RmxhZ3MgICAgPSByZXF1aXJlKCcuL19mbGFncycpXG4gICwgUmVnRXhwUHJvdG8gPSBSZWdFeHAucHJvdG90eXBlO1xuXG52YXIgJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yID0gZnVuY3Rpb24ocmVnZXhwLCBzdHJpbmcpe1xuICB0aGlzLl9yID0gcmVnZXhwO1xuICB0aGlzLl9zID0gc3RyaW5nO1xufTtcblxucmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKSgkUmVnRXhwU3RyaW5nSXRlcmF0b3IsICdSZWdFeHAgU3RyaW5nJywgZnVuY3Rpb24gbmV4dCgpe1xuICB2YXIgbWF0Y2ggPSB0aGlzLl9yLmV4ZWModGhpcy5fcyk7XG4gIHJldHVybiB7dmFsdWU6IG1hdGNoLCBkb25lOiBtYXRjaCA9PT0gbnVsbH07XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIG1hdGNoQWxsOiBmdW5jdGlvbiBtYXRjaEFsbChyZWdleHApe1xuICAgIGRlZmluZWQodGhpcyk7XG4gICAgaWYoIWlzUmVnRXhwKHJlZ2V4cCkpdGhyb3cgVHlwZUVycm9yKHJlZ2V4cCArICcgaXMgbm90IGEgcmVnZXhwIScpO1xuICAgIHZhciBTICAgICA9IFN0cmluZyh0aGlzKVxuICAgICAgLCBmbGFncyA9ICdmbGFncycgaW4gUmVnRXhwUHJvdG8gPyBTdHJpbmcocmVnZXhwLmZsYWdzKSA6IGdldEZsYWdzLmNhbGwocmVnZXhwKVxuICAgICAgLCByeCAgICA9IG5ldyBSZWdFeHAocmVnZXhwLnNvdXJjZSwgfmZsYWdzLmluZGV4T2YoJ2cnKSA/IGZsYWdzIDogJ2cnICsgZmxhZ3MpO1xuICAgIHJ4Lmxhc3RJbmRleCA9IHRvTGVuZ3RoKHJlZ2V4cC5sYXN0SW5kZXgpO1xuICAgIHJldHVybiBuZXcgJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yKHJ4LCBTKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5tYXRjaC1hbGwuanNcbi8vIG1vZHVsZSBpZCA9IDMyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdvYnNlcnZhYmxlJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbnZhciAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgb3duS2V5cyAgICAgICAgPSByZXF1aXJlKCcuL19vd24ta2V5cycpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBnT1BEICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3Qpe1xuICAgIHZhciBPICAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAgICwgZ2V0RGVzYyA9IGdPUEQuZlxuICAgICAgLCBrZXlzICAgID0gb3duS2V5cyhPKVxuICAgICAgLCByZXN1bHQgID0ge31cbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGtleXMubGVuZ3RoID4gaSljcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGtleSA9IGtleXNbaSsrXSwgZ2V0RGVzYyhPLCBrZXkpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDMzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtdmFsdWVzLWVudHJpZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkdmFsdWVzID0gcmVxdWlyZSgnLi9fb2JqZWN0LXRvLWFycmF5JykoZmFsc2UpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoaXQpe1xuICAgIHJldHVybiAkdmFsdWVzKGl0KTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDMzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2V0S2V5cyAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGlzRW51bSAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc0VudHJpZXMpe1xuICByZXR1cm4gZnVuY3Rpb24oaXQpe1xuICAgIHZhciBPICAgICAgPSB0b0lPYmplY3QoaXQpXG4gICAgICAsIGtleXMgICA9IGdldEtleXMoTylcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaSAgICAgID0gMFxuICAgICAgLCByZXN1bHQgPSBbXVxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUobGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChPLCBrZXkgPSBrZXlzW2krK10pKXtcbiAgICAgIHJlc3VsdC5wdXNoKGlzRW50cmllcyA/IFtrZXksIE9ba2V5XV0gOiBPW2tleV0pO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC10by1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMzM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZW50cmllcyA9IHJlcXVpcmUoJy4vX29iamVjdC10by1hcnJheScpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZW50cmllczogZnVuY3Rpb24gZW50cmllcyhpdCl7XG4gICAgcmV0dXJuICRlbnRyaWVzKGl0KTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gICAgICAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcblxuLy8gQi4yLjIuMiBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX18oUCwgZ2V0dGVyKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fZGVmaW5lR2V0dGVyX186IGZ1bmN0aW9uIF9fZGVmaW5lR2V0dGVyX18oUCwgZ2V0dGVyKXtcbiAgICAkZGVmaW5lUHJvcGVydHkuZih0b09iamVjdCh0aGlzKSwgUCwge2dldDogYUZ1bmN0aW9uKGdldHRlciksIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0pO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1nZXR0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBGb3JjZWQgcmVwbGFjZW1lbnQgcHJvdG90eXBlIGFjY2Vzc29ycyBtZXRob2RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKXx8ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHZhciBLID0gTWF0aC5yYW5kb20oKTtcbiAgLy8gSW4gRkYgdGhyb3dzIG9ubHkgZGVmaW5lIG1ldGhvZHNcbiAgX19kZWZpbmVTZXR0ZXJfXy5jYWxsKG51bGwsIEssIGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovfSk7XG4gIGRlbGV0ZSByZXF1aXJlKCcuL19nbG9iYWwnKVtLXTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZm9yY2VkLXBhbS5qc1xuLy8gbW9kdWxlIGlkID0gMzM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG5cbi8vIEIuMi4yLjMgT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZVNldHRlcl9fKFAsIHNldHRlcilcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2RlZmluZVNldHRlcl9fOiBmdW5jdGlvbiBfX2RlZmluZVNldHRlcl9fKFAsIHNldHRlcil7XG4gICAgJGRlZmluZVByb3BlcnR5LmYodG9PYmplY3QodGhpcyksIFAsIHtzZXQ6IGFGdW5jdGlvbihzZXR0ZXIpLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9KTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtc2V0dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGdldFByb3RvdHlwZU9mICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxuLy8gQi4yLjIuNCBPYmplY3QucHJvdG90eXBlLl9fbG9va3VwR2V0dGVyX18oUClcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2xvb2t1cEdldHRlcl9fOiBmdW5jdGlvbiBfX2xvb2t1cEdldHRlcl9fKFApe1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcylcbiAgICAgICwgSyA9IHRvUHJpbWl0aXZlKFAsIHRydWUpXG4gICAgICAsIEQ7XG4gICAgZG8ge1xuICAgICAgaWYoRCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBLKSlyZXR1cm4gRC5nZXQ7XG4gICAgfSB3aGlsZShPID0gZ2V0UHJvdG90eXBlT2YoTykpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZ2V0UHJvdG90eXBlT2YgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG4vLyBCLjIuMi41IE9iamVjdC5wcm90b3R5cGUuX19sb29rdXBTZXR0ZXJfXyhQKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fbG9va3VwU2V0dGVyX186IGZ1bmN0aW9uIF9fbG9va3VwU2V0dGVyX18oUCl7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKVxuICAgICAgLCBLID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSlcbiAgICAgICwgRDtcbiAgICBkbyB7XG4gICAgICBpZihEID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIEspKXJldHVybiBELnNldDtcbiAgICB9IHdoaWxlKE8gPSBnZXRQcm90b3R5cGVPZihPKSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLXNldHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMzQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ01hcCcsIHt0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdNYXAnKX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAudG8tanNvbi5qc1xuLy8gbW9kdWxlIGlkID0gMzQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgZnJvbSAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSl7XG4gIHJldHVybiBmdW5jdGlvbiB0b0pTT04oKXtcbiAgICBpZihjbGFzc29mKHRoaXMpICE9IE5BTUUpdGhyb3cgVHlwZUVycm9yKE5BTUUgKyBcIiN0b0pTT04gaXNuJ3QgZ2VuZXJpY1wiKTtcbiAgICByZXR1cm4gZnJvbSh0aGlzKTtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qc1xuLy8gbW9kdWxlIGlkID0gMzQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXIsIElURVJBVE9SKXtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3JPZihpdGVyLCBmYWxzZSwgcmVzdWx0LnB1c2gsIHJlc3VsdCwgSVRFUkFUT1IpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1mcm9tLWl0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnU2V0Jywge3RvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ1NldCcpfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9wcm9wb3NhbC1nbG9iYWxcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnU3lzdGVtJywge2dsb2JhbDogcmVxdWlyZSgnLi9fZ2xvYmFsJyl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMzQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvcHJvcG9zYWwtaXMtZXJyb3JcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjb2YgICAgID0gcmVxdWlyZSgnLi9fY29mJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnRXJyb3InLCB7XG4gIGlzRXJyb3I6IGZ1bmN0aW9uIGlzRXJyb3IoaXQpe1xuICAgIHJldHVybiBjb2YoaXQpID09PSAnRXJyb3InO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuZXJyb3IuaXMtZXJyb3IuanNcbi8vIG1vZHVsZSBpZCA9IDM0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpYWRkaDogZnVuY3Rpb24gaWFkZGgoeDAsIHgxLCB5MCwgeTEpe1xuICAgIHZhciAkeDAgPSB4MCA+Pj4gMFxuICAgICAgLCAkeDEgPSB4MSA+Pj4gMFxuICAgICAgLCAkeTAgPSB5MCA+Pj4gMDtcbiAgICByZXR1cm4gJHgxICsgKHkxID4+PiAwKSArICgoJHgwICYgJHkwIHwgKCR4MCB8ICR5MCkgJiB+KCR4MCArICR5MCA+Pj4gMCkpID4+PiAzMSkgfCAwO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pYWRkaC5qc1xuLy8gbW9kdWxlIGlkID0gMzQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGlzdWJoOiBmdW5jdGlvbiBpc3ViaCh4MCwgeDEsIHkwLCB5MSl7XG4gICAgdmFyICR4MCA9IHgwID4+PiAwXG4gICAgICAsICR4MSA9IHgxID4+PiAwXG4gICAgICAsICR5MCA9IHkwID4+PiAwO1xuICAgIHJldHVybiAkeDEgLSAoeTEgPj4+IDApIC0gKCh+JHgwICYgJHkwIHwgfigkeDAgXiAkeTApICYgJHgwIC0gJHkwID4+PiAwKSA+Pj4gMzEpIHwgMDtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaXN1YmguanNcbi8vIG1vZHVsZSBpZCA9IDM0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpbXVsaDogZnVuY3Rpb24gaW11bGgodSwgdil7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZlxuICAgICAgLCAkdSA9ICt1XG4gICAgICAsICR2ID0gK3ZcbiAgICAgICwgdTAgPSAkdSAmIFVJTlQxNlxuICAgICAgLCB2MCA9ICR2ICYgVUlOVDE2XG4gICAgICAsIHUxID0gJHUgPj4gMTZcbiAgICAgICwgdjEgPSAkdiA+PiAxNlxuICAgICAgLCB0ICA9ICh1MSAqIHYwID4+PiAwKSArICh1MCAqIHYwID4+PiAxNik7XG4gICAgcmV0dXJuIHUxICogdjEgKyAodCA+PiAxNikgKyAoKHUwICogdjEgPj4+IDApICsgKHQgJiBVSU5UMTYpID4+IDE2KTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaW11bGguanNcbi8vIG1vZHVsZSBpZCA9IDM0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB1bXVsaDogZnVuY3Rpb24gdW11bGgodSwgdil7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZlxuICAgICAgLCAkdSA9ICt1XG4gICAgICAsICR2ID0gK3ZcbiAgICAgICwgdTAgPSAkdSAmIFVJTlQxNlxuICAgICAgLCB2MCA9ICR2ICYgVUlOVDE2XG4gICAgICAsIHUxID0gJHUgPj4+IDE2XG4gICAgICAsIHYxID0gJHYgPj4+IDE2XG4gICAgICAsIHQgID0gKHUxICogdjAgPj4+IDApICsgKHUwICogdjAgPj4+IDE2KTtcbiAgICByZXR1cm4gdTEgKiB2MSArICh0ID4+PiAxNikgKyAoKHUwICogdjEgPj4+IDApICsgKHQgJiBVSU5UMTYpID4+PiAxNik7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnVtdWxoLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleVxuICAsIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5zZXQ7XG5cbm1ldGFkYXRhLmV4cCh7ZGVmaW5lTWV0YWRhdGE6IGZ1bmN0aW9uIGRlZmluZU1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHRhcmdldEtleSl7XG4gIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIGFuT2JqZWN0KHRhcmdldCksIHRvTWV0YUtleSh0YXJnZXRLZXkpKTtcbn19KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5kZWZpbmUtbWV0YWRhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDM1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTWFwICAgICA9IHJlcXVpcmUoJy4vZXM2Lm1hcCcpXG4gICwgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgc2hhcmVkICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdtZXRhZGF0YScpXG4gICwgc3RvcmUgICA9IHNoYXJlZC5zdG9yZSB8fCAoc2hhcmVkLnN0b3JlID0gbmV3IChyZXF1aXJlKCcuL2VzNi53ZWFrLW1hcCcpKSk7XG5cbnZhciBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwID0gZnVuY3Rpb24odGFyZ2V0LCB0YXJnZXRLZXksIGNyZWF0ZSl7XG4gIHZhciB0YXJnZXRNZXRhZGF0YSA9IHN0b3JlLmdldCh0YXJnZXQpO1xuICBpZighdGFyZ2V0TWV0YWRhdGEpe1xuICAgIGlmKCFjcmVhdGUpcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBzdG9yZS5zZXQodGFyZ2V0LCB0YXJnZXRNZXRhZGF0YSA9IG5ldyBNYXApO1xuICB9XG4gIHZhciBrZXlNZXRhZGF0YSA9IHRhcmdldE1ldGFkYXRhLmdldCh0YXJnZXRLZXkpO1xuICBpZigha2V5TWV0YWRhdGEpe1xuICAgIGlmKCFjcmVhdGUpcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB0YXJnZXRNZXRhZGF0YS5zZXQodGFyZ2V0S2V5LCBrZXlNZXRhZGF0YSA9IG5ldyBNYXApO1xuICB9IHJldHVybiBrZXlNZXRhZGF0YTtcbn07XG52YXIgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IGZ1bmN0aW9uKE1ldGFkYXRhS2V5LCBPLCBQKXtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCBmYWxzZSk7XG4gIHJldHVybiBtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBtZXRhZGF0YU1hcC5oYXMoTWV0YWRhdGFLZXkpO1xufTtcbnZhciBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE8sIFApe1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIGZhbHNlKTtcbiAgcmV0dXJuIG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBtZXRhZGF0YU1hcC5nZXQoTWV0YWRhdGFLZXkpO1xufTtcbnZhciBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUsIE8sIFApe1xuICBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIHRydWUpLnNldChNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSk7XG59O1xudmFyIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gZnVuY3Rpb24odGFyZ2V0LCB0YXJnZXRLZXkpe1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKHRhcmdldCwgdGFyZ2V0S2V5LCBmYWxzZSlcbiAgICAsIGtleXMgICAgICAgID0gW107XG4gIGlmKG1ldGFkYXRhTWFwKW1ldGFkYXRhTWFwLmZvckVhY2goZnVuY3Rpb24oXywga2V5KXsga2V5cy5wdXNoKGtleSk7IH0pO1xuICByZXR1cm4ga2V5cztcbn07XG52YXIgdG9NZXRhS2V5ID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6IFN0cmluZyhpdCk7XG59O1xudmFyIGV4cCA9IGZ1bmN0aW9uKE8pe1xuICAkZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCBPKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzdG9yZTogc3RvcmUsXG4gIG1hcDogZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCxcbiAgaGFzOiBvcmRpbmFyeUhhc093bk1ldGFkYXRhLFxuICBnZXQ6IG9yZGluYXJ5R2V0T3duTWV0YWRhdGEsXG4gIHNldDogb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSxcbiAga2V5czogb3JkaW5hcnlPd25NZXRhZGF0YUtleXMsXG4gIGtleTogdG9NZXRhS2V5LFxuICBleHA6IGV4cFxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fbWV0YWRhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDM1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5XG4gICwgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCA9IG1ldGFkYXRhLm1hcFxuICAsIHN0b3JlICAgICAgICAgICAgICAgICAgPSBtZXRhZGF0YS5zdG9yZTtcblxubWV0YWRhdGEuZXhwKHtkZWxldGVNZXRhZGF0YTogZnVuY3Rpb24gZGVsZXRlTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgdmFyIHRhcmdldEtleSAgID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKVxuICAgICwgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKGFuT2JqZWN0KHRhcmdldCksIHRhcmdldEtleSwgZmFsc2UpO1xuICBpZihtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkIHx8ICFtZXRhZGF0YU1hcFsnZGVsZXRlJ10obWV0YWRhdGFLZXkpKXJldHVybiBmYWxzZTtcbiAgaWYobWV0YWRhdGFNYXAuc2l6ZSlyZXR1cm4gdHJ1ZTtcbiAgdmFyIHRhcmdldE1ldGFkYXRhID0gc3RvcmUuZ2V0KHRhcmdldCk7XG4gIHRhcmdldE1ldGFkYXRhWydkZWxldGUnXSh0YXJnZXRLZXkpO1xuICByZXR1cm4gISF0YXJnZXRNZXRhZGF0YS5zaXplIHx8IHN0b3JlWydkZWxldGUnXSh0YXJnZXQpO1xufX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlbGV0ZS1tZXRhZGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMzUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGdldFByb3RvdHlwZU9mICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzXG4gICwgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmdldFxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeUdldE1ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE8sIFApe1xuICB2YXIgaGFzT3duID0gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIGlmKGhhc093bilyZXR1cm4gb3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIHZhciBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IG9yZGluYXJ5R2V0TWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCkgOiB1bmRlZmluZWQ7XG59O1xuXG5tZXRhZGF0YS5leHAoe2dldE1ldGFkYXRhOiBmdW5jdGlvbiBnZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlHZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59fSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldCAgICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9lczYuc2V0JylcbiAgLCBmcm9tICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKVxuICAsIG1ldGFkYXRhICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRQcm90b3R5cGVPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5c1xuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlNZXRhZGF0YUtleXMgPSBmdW5jdGlvbihPLCBQKXtcbiAgdmFyIG9LZXlzICA9IG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApXG4gICAgLCBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgaWYocGFyZW50ID09PSBudWxsKXJldHVybiBvS2V5cztcbiAgdmFyIHBLZXlzICA9IG9yZGluYXJ5TWV0YWRhdGFLZXlzKHBhcmVudCwgUCk7XG4gIHJldHVybiBwS2V5cy5sZW5ndGggPyBvS2V5cy5sZW5ndGggPyBmcm9tKG5ldyBTZXQob0tleXMuY29uY2F0KHBLZXlzKSkpIDogcEtleXMgOiBvS2V5cztcbn07XG5cbm1ldGFkYXRhLmV4cCh7Z2V0TWV0YWRhdGFLZXlzOiBmdW5jdGlvbiBnZXRNZXRhZGF0YUtleXModGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlNZXRhZGF0YUtleXMoYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzFdKSk7XG59fSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDM1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gbWV0YWRhdGEuZ2V0XG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleTtcblxubWV0YWRhdGEuZXhwKHtnZXRPd25NZXRhZGF0YTogZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldClcbiAgICAsIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDM1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5c1xuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoe2dldE93bk1ldGFkYXRhS2V5czogZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGFLZXlzKHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1sxXSkpO1xufX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEta2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMzU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGdldFByb3RvdHlwZU9mICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleTtcblxudmFyIG9yZGluYXJ5SGFzTWV0YWRhdGEgPSBmdW5jdGlvbihNZXRhZGF0YUtleSwgTywgUCl7XG4gIHZhciBoYXNPd24gPSBvcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgaWYoaGFzT3duKXJldHVybiB0cnVlO1xuICB2YXIgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIHJldHVybiBwYXJlbnQgIT09IG51bGwgPyBvcmRpbmFyeUhhc01ldGFkYXRhKE1ldGFkYXRhS2V5LCBwYXJlbnQsIFApIDogZmFsc2U7XG59O1xuXG5tZXRhZGF0YS5leHAoe2hhc01ldGFkYXRhOiBmdW5jdGlvbiBoYXNNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlIYXNNZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59fSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW1ldGFkYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAzNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhc1xuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbm1ldGFkYXRhLmV4cCh7aGFzT3duTWV0YWRhdGE6IGZ1bmN0aW9uIGhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHJldHVybiBvcmRpbmFyeUhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpXG4gICAgLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn19KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtb3duLW1ldGFkYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXlcbiAgLCBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gbWV0YWRhdGEuc2V0O1xuXG5tZXRhZGF0YS5leHAoe21ldGFkYXRhOiBmdW5jdGlvbiBtZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSl7XG4gIHJldHVybiBmdW5jdGlvbiBkZWNvcmF0b3IodGFyZ2V0LCB0YXJnZXRLZXkpe1xuICAgIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEoXG4gICAgICBtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSxcbiAgICAgICh0YXJnZXRLZXkgIT09IHVuZGVmaW5lZCA/IGFuT2JqZWN0IDogYUZ1bmN0aW9uKSh0YXJnZXQpLFxuICAgICAgdG9NZXRhS2V5KHRhcmdldEtleSlcbiAgICApO1xuICB9O1xufX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lm1ldGFkYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3J3YWxkcm9uL3RjMzktbm90ZXMvYmxvYi9tYXN0ZXIvZXM2LzIwMTQtMDkvc2VwdC0yNS5tZCM1MTAtZ2xvYmFsYXNhcC1mb3ItZW5xdWV1aW5nLWEtbWljcm90YXNrXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBtaWNyb3Rhc2sgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpXG4gICwgcHJvY2VzcyAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucHJvY2Vzc1xuICAsIGlzTm9kZSAgICA9IHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJztcblxuJGV4cG9ydCgkZXhwb3J0LkcsIHtcbiAgYXNhcDogZnVuY3Rpb24gYXNhcChmbil7XG4gICAgdmFyIGRvbWFpbiA9IGlzTm9kZSAmJiBwcm9jZXNzLmRvbWFpbjtcbiAgICBtaWNyb3Rhc2soZG9tYWluID8gZG9tYWluLmJpbmQoZm4pIDogZm4pO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuYXNhcC5qc1xuLy8gbW9kdWxlIGlkID0gMzYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5wYXJzaW5nL2VzLW9ic2VydmFibGVcbnZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZ2xvYmFsICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgbWljcm90YXNrICAgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpXG4gICwgT0JTRVJWQUJMRSAgPSByZXF1aXJlKCcuL193a3MnKSgnb2JzZXJ2YWJsZScpXG4gICwgYUZ1bmN0aW9uICAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYW5JbnN0YW5jZSAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIGhpZGUgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgZm9yT2YgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIFJFVFVSTiAgICAgID0gZm9yT2YuUkVUVVJOO1xuXG52YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24oZm4pe1xuICByZXR1cm4gZm4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFGdW5jdGlvbihmbik7XG59O1xuXG52YXIgY2xlYW51cFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uKHN1YnNjcmlwdGlvbil7XG4gIHZhciBjbGVhbnVwID0gc3Vic2NyaXB0aW9uLl9jO1xuICBpZihjbGVhbnVwKXtcbiAgICBzdWJzY3JpcHRpb24uX2MgPSB1bmRlZmluZWQ7XG4gICAgY2xlYW51cCgpO1xuICB9XG59O1xuXG52YXIgc3Vic2NyaXB0aW9uQ2xvc2VkID0gZnVuY3Rpb24oc3Vic2NyaXB0aW9uKXtcbiAgcmV0dXJuIHN1YnNjcmlwdGlvbi5fbyA9PT0gdW5kZWZpbmVkO1xufTtcblxudmFyIGNsb3NlU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24oc3Vic2NyaXB0aW9uKXtcbiAgaWYoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKXtcbiAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICB9XG59O1xuXG52YXIgU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24ob2JzZXJ2ZXIsIHN1YnNjcmliZXIpe1xuICBhbk9iamVjdChvYnNlcnZlcik7XG4gIHRoaXMuX2MgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX28gPSBvYnNlcnZlcjtcbiAgb2JzZXJ2ZXIgPSBuZXcgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIodGhpcyk7XG4gIHRyeSB7XG4gICAgdmFyIGNsZWFudXAgICAgICA9IHN1YnNjcmliZXIob2JzZXJ2ZXIpXG4gICAgICAsIHN1YnNjcmlwdGlvbiA9IGNsZWFudXA7XG4gICAgaWYoY2xlYW51cCAhPSBudWxsKXtcbiAgICAgIGlmKHR5cGVvZiBjbGVhbnVwLnVuc3Vic2NyaWJlID09PSAnZnVuY3Rpb24nKWNsZWFudXAgPSBmdW5jdGlvbigpeyBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTsgfTtcbiAgICAgIGVsc2UgYUZ1bmN0aW9uKGNsZWFudXApO1xuICAgICAgdGhpcy5fYyA9IGNsZWFudXA7XG4gICAgfVxuICB9IGNhdGNoKGUpe1xuICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgIHJldHVybjtcbiAgfSBpZihzdWJzY3JpcHRpb25DbG9zZWQodGhpcykpY2xlYW51cFN1YnNjcmlwdGlvbih0aGlzKTtcbn07XG5cblN1YnNjcmlwdGlvbi5wcm90b3R5cGUgPSByZWRlZmluZUFsbCh7fSwge1xuICB1bnN1YnNjcmliZTogZnVuY3Rpb24gdW5zdWJzY3JpYmUoKXsgY2xvc2VTdWJzY3JpcHRpb24odGhpcyk7IH1cbn0pO1xuXG52YXIgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbihzdWJzY3JpcHRpb24pe1xuICB0aGlzLl9zID0gc3Vic2NyaXB0aW9uO1xufTtcblxuU3Vic2NyaXB0aW9uT2JzZXJ2ZXIucHJvdG90eXBlID0gcmVkZWZpbmVBbGwoe30sIHtcbiAgbmV4dDogZnVuY3Rpb24gbmV4dCh2YWx1ZSl7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKXtcbiAgICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLm5leHQpO1xuICAgICAgICBpZihtKXJldHVybiBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2xvc2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBlcnJvcjogZnVuY3Rpb24gZXJyb3IodmFsdWUpe1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zO1xuICAgIGlmKHN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKXRocm93IHZhbHVlO1xuICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLmVycm9yKTtcbiAgICAgIGlmKCFtKXRocm93IHZhbHVlO1xuICAgICAgdmFsdWUgPSBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZSh2YWx1ZSl7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKXtcbiAgICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICAgIHN1YnNjcmlwdGlvbi5fbyA9IHVuZGVmaW5lZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLmNvbXBsZXRlKTtcbiAgICAgICAgdmFsdWUgPSBtID8gbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSkgOiB1bmRlZmluZWQ7XG4gICAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9IGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgJE9ic2VydmFibGUgPSBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZXIpe1xuICBhbkluc3RhbmNlKHRoaXMsICRPYnNlcnZhYmxlLCAnT2JzZXJ2YWJsZScsICdfZicpLl9mID0gYUZ1bmN0aW9uKHN1YnNjcmliZXIpO1xufTtcblxucmVkZWZpbmVBbGwoJE9ic2VydmFibGUucHJvdG90eXBlLCB7XG4gIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKXtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbihvYnNlcnZlciwgdGhpcy5fZik7XG4gIH0sXG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goZm4pe1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IChjb3JlLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2UpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICBhRnVuY3Rpb24oZm4pO1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoYXQuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dCA6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogcmVqZWN0LFxuICAgICAgICBjb21wbGV0ZTogcmVzb2x2ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5yZWRlZmluZUFsbCgkT2JzZXJ2YWJsZSwge1xuICBmcm9tOiBmdW5jdGlvbiBmcm9tKHgpe1xuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgPyB0aGlzIDogJE9ic2VydmFibGU7XG4gICAgdmFyIG1ldGhvZCA9IGdldE1ldGhvZChhbk9iamVjdCh4KVtPQlNFUlZBQkxFXSk7XG4gICAgaWYobWV0aG9kKXtcbiAgICAgIHZhciBvYnNlcnZhYmxlID0gYW5PYmplY3QobWV0aG9kLmNhbGwoeCkpO1xuICAgICAgcmV0dXJuIG9ic2VydmFibGUuY29uc3RydWN0b3IgPT09IEMgPyBvYnNlcnZhYmxlIDogbmV3IEMoZnVuY3Rpb24ob2JzZXJ2ZXIpe1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZS5zdWJzY3JpYmUob2JzZXJ2ZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbihvYnNlcnZlcil7XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCFkb25lKXtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYoZm9yT2YoeCwgZmFsc2UsIGZ1bmN0aW9uKGl0KXtcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChpdCk7XG4gICAgICAgICAgICAgIGlmKGRvbmUpcmV0dXJuIFJFVFVSTjtcbiAgICAgICAgICAgIH0pID09PSBSRVRVUk4pcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICBpZihkb25lKXRocm93IGU7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7IGRvbmUgPSB0cnVlOyB9O1xuICAgIH0pO1xuICB9LFxuICBvZjogZnVuY3Rpb24gb2YoKXtcbiAgICBmb3IodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlbXMgPSBBcnJheShsKTsgaSA8IGw7KWl0ZW1zW2ldID0gYXJndW1lbnRzW2krK107XG4gICAgcmV0dXJuIG5ldyAodHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgPyB0aGlzIDogJE9ic2VydmFibGUpKGZ1bmN0aW9uKG9ic2VydmVyKXtcbiAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIWRvbmUpe1xuICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0ZW1zW2ldKTtcbiAgICAgICAgICAgIGlmKGRvbmUpcmV0dXJuO1xuICAgICAgICAgIH0gb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKXsgZG9uZSA9IHRydWU7IH07XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5oaWRlKCRPYnNlcnZhYmxlLnByb3RvdHlwZSwgT0JTRVJWQUJMRSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXG4kZXhwb3J0KCRleHBvcnQuRywge09ic2VydmFibGU6ICRPYnNlcnZhYmxlfSk7XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ09ic2VydmFibGUnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JzZXJ2YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGllOS0gc2V0VGltZW91dCAmIHNldEludGVydmFsIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmaXhcbnZhciBnbG9iYWwgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCAkZXhwb3J0ICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpbnZva2UgICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBwYXJ0aWFsICAgID0gcmVxdWlyZSgnLi9fcGFydGlhbCcpXG4gICwgbmF2aWdhdG9yICA9IGdsb2JhbC5uYXZpZ2F0b3JcbiAgLCBNU0lFICAgICAgID0gISFuYXZpZ2F0b3IgJiYgL01TSUUgLlxcLi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gPC0gZGlydHkgaWU5LSBjaGVja1xudmFyIHdyYXAgPSBmdW5jdGlvbihzZXQpe1xuICByZXR1cm4gTVNJRSA/IGZ1bmN0aW9uKGZuLCB0aW1lIC8qLCAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gc2V0KGludm9rZShcbiAgICAgIHBhcnRpYWwsXG4gICAgICBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksXG4gICAgICB0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pXG4gICAgKSwgdGltZSk7XG4gIH0gOiBzZXQ7XG59O1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkIgKyAkZXhwb3J0LkYgKiBNU0lFLCB7XG4gIHNldFRpbWVvdXQ6ICB3cmFwKGdsb2JhbC5zZXRUaW1lb3V0KSxcbiAgc2V0SW50ZXJ2YWw6IHdyYXAoZ2xvYmFsLnNldEludGVydmFsKVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvd2ViLnRpbWVycy5qc1xuLy8gbW9kdWxlIGlkID0gMzYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBwYXRoICAgICAgPSByZXF1aXJlKCcuL19wYXRoJylcbiAgLCBpbnZva2UgICAgPSByZXF1aXJlKCcuL19pbnZva2UnKVxuICAsIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oLyogLi4ucGFyZ3MgKi8pe1xuICB2YXIgZm4gICAgID0gYUZ1bmN0aW9uKHRoaXMpXG4gICAgLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBwYXJncyAgPSBBcnJheShsZW5ndGgpXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBfICAgICAgPSBwYXRoLl9cbiAgICAsIGhvbGRlciA9IGZhbHNlO1xuICB3aGlsZShsZW5ndGggPiBpKWlmKChwYXJnc1tpXSA9IGFyZ3VtZW50c1tpKytdKSA9PT0gXylob2xkZXIgPSB0cnVlO1xuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICAsIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIGogPSAwLCBrID0gMCwgYXJncztcbiAgICBpZighaG9sZGVyICYmICFhTGVuKXJldHVybiBpbnZva2UoZm4sIHBhcmdzLCB0aGF0KTtcbiAgICBhcmdzID0gcGFyZ3Muc2xpY2UoKTtcbiAgICBpZihob2xkZXIpZm9yKDtsZW5ndGggPiBqOyBqKyspaWYoYXJnc1tqXSA9PT0gXylhcmdzW2pdID0gYXJndW1lbnRzW2srK107XG4gICAgd2hpbGUoYUxlbiA+IGspYXJncy5wdXNoKGFyZ3VtZW50c1trKytdKTtcbiAgICByZXR1cm4gaW52b2tlKGZuLCBhcmdzLCB0aGF0KTtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX3BhcnRpYWwuanNcbi8vIG1vZHVsZSBpZCA9IDM2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19wYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICR0YXNrICAgPSByZXF1aXJlKCcuL190YXNrJyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiwge1xuICBzZXRJbW1lZGlhdGU6ICAgJHRhc2suc2V0LFxuICBjbGVhckltbWVkaWF0ZTogJHRhc2suY2xlYXJcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL3dlYi5pbW1lZGlhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDM2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGl0ZXJhdG9ycyAgICA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJylcbiAgLCByZWRlZmluZSAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGdsb2JhbCAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBJdGVyYXRvcnMgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCB3a3MgICAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJylcbiAgLCBJVEVSQVRPUiAgICAgID0gd2tzKCdpdGVyYXRvcicpXG4gICwgVE9fU1RSSU5HX1RBRyA9IHdrcygndG9TdHJpbmdUYWcnKVxuICAsIEFycmF5VmFsdWVzICAgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmZvcih2YXIgY29sbGVjdGlvbnMgPSBbJ05vZGVMaXN0JywgJ0RPTVRva2VuTGlzdCcsICdNZWRpYUxpc3QnLCAnU3R5bGVTaGVldExpc3QnLCAnQ1NTUnVsZUxpc3QnXSwgaSA9IDA7IGkgPCA1OyBpKyspe1xuICB2YXIgTkFNRSAgICAgICA9IGNvbGxlY3Rpb25zW2ldXG4gICAgLCBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdXG4gICAgLCBwcm90byAgICAgID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZVxuICAgICwga2V5O1xuICBpZihwcm90byl7XG4gICAgaWYoIXByb3RvW0lURVJBVE9SXSloaWRlKHByb3RvLCBJVEVSQVRPUiwgQXJyYXlWYWx1ZXMpO1xuICAgIGlmKCFwcm90b1tUT19TVFJJTkdfVEFHXSloaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBBcnJheVZhbHVlcztcbiAgICBmb3Ioa2V5IGluICRpdGVyYXRvcnMpaWYoIXByb3RvW2tleV0pcmVkZWZpbmUocHJvdG8sIGtleSwgJGl0ZXJhdG9yc1trZXldLCB0cnVlKTtcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDM2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL21hc3Rlci9MSUNFTlNFIGZpbGUuIEFuXG4gKiBhZGRpdGlvbmFsIGdyYW50IG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW5cbiAqIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy5kb21haW4pIHtcbiAgICAgIGludm9rZSA9IHByb2Nlc3MuZG9tYWluLmJpbmQoaW52b2tlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIHJ1bnRpbWUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIiB8fFxuICAgICAgICAgICAgICAobWV0aG9kID09PSBcInRocm93XCIgJiYgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgLy8gQSByZXR1cm4gb3IgdGhyb3cgKHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyB0aHJvd1xuICAgICAgICAgICAgLy8gbWV0aG9kKSBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgICAgdmFyIHJldHVybk1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdO1xuICAgICAgICAgICAgaWYgKHJldHVybk1ldGhvZCkge1xuICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gocmV0dXJuTWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgYXJnKTtcbiAgICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmV0dXJuIG1ldGhvZCB0aHJldyBhbiBleGNlcHRpb24sIGxldCB0aGF0XG4gICAgICAgICAgICAgICAgLy8gZXhjZXB0aW9uIHByZXZhaWwgb3ZlciB0aGUgb3JpZ2luYWwgcmV0dXJuIG9yIHRocm93LlxuICAgICAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICAgICAgLy8gQ29udGludWUgd2l0aCB0aGUgb3V0ZXIgcmV0dXJuLCBub3cgdGhhdCB0aGUgZGVsZWdhdGVcbiAgICAgICAgICAgICAgLy8gaXRlcmF0b3IgaGFzIGJlZW4gdGVybWluYXRlZC5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKFxuICAgICAgICAgICAgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSxcbiAgICAgICAgICAgIGRlbGVnYXRlLml0ZXJhdG9yLFxuICAgICAgICAgICAgYXJnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gTGlrZSByZXR1cm5pbmcgZ2VuZXJhdG9yLnRocm93KHVuY2F1Z2h0KSwgYnV0IHdpdGhvdXQgdGhlXG4gICAgICAgICAgICAvLyBvdmVyaGVhZCBvZiBhbiBleHRyYSBmdW5jdGlvbiBjYWxsLlxuICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERlbGVnYXRlIGdlbmVyYXRvciByYW4gYW5kIGhhbmRsZWQgaXRzIG93biBleGNlcHRpb25zIHNvXG4gICAgICAgICAgLy8gcmVnYXJkbGVzcyBvZiB3aGF0IHRoZSBtZXRob2Qgd2FzLCB3ZSBjb250aW51ZSBhcyBpZiBpdCBpc1xuICAgICAgICAgIC8vIFwibmV4dFwiIHdpdGggYW4gdW5kZWZpbmVkIGFyZy5cbiAgICAgICAgICBtZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG4gICAgICAgICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgICBtZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBhcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmRlbGVnYXRlICYmIG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG4gICAgICAgIHJldHVybiAhIWNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gQW1vbmcgdGhlIHZhcmlvdXMgdHJpY2tzIGZvciBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbFxuICAvLyBvYmplY3QsIHRoaXMgc2VlbXMgdG8gYmUgdGhlIG1vc3QgcmVsaWFibGUgdGVjaG5pcXVlIHRoYXQgZG9lcyBub3RcbiAgLy8gdXNlIGluZGlyZWN0IGV2YWwgKHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzXG4pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcbi8vIG1vZHVsZSBpZCA9IDM2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2NvcmUucmVnZXhwLmVzY2FwZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuUmVnRXhwLmVzY2FwZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvZm4vcmVnZXhwL2VzY2FwZS5qc1xuLy8gbW9kdWxlIGlkID0gMzY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZW5qYW1pbmdyL1JleEV4cC5lc2NhcGVcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcmUgICAgID0gcmVxdWlyZSgnLi9fcmVwbGFjZXInKSgvW1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWdFeHAnLCB7ZXNjYXBlOiBmdW5jdGlvbiBlc2NhcGUoaXQpeyByZXR1cm4gJHJlKGl0KTsgfX0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvY29yZS5yZWdleHAuZXNjYXBlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihyZWdFeHAsIHJlcGxhY2Upe1xuICB2YXIgcmVwbGFjZXIgPSByZXBsYWNlID09PSBPYmplY3QocmVwbGFjZSkgPyBmdW5jdGlvbihwYXJ0KXtcbiAgICByZXR1cm4gcmVwbGFjZVtwYXJ0XTtcbiAgfSA6IHJlcGxhY2U7XG4gIHJldHVybiBmdW5jdGlvbihpdCl7XG4gICAgcmV0dXJuIFN0cmluZyhpdCkucmVwbGFjZShyZWdFeHAsIHJlcGxhY2VyKTtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX3JlcGxhY2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==